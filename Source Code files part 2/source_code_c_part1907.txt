Request Register.  Indicates which software and hardware interrupts
; are pending.  When lowering IRQL either from exiting an ISR or calling
; KfLowerIrql, this value is checked for delayed software or hardware
; interrupts.  Any interrupt above the new IRQL level is then dispatched.
;

        public  HalpIRR
HalpIRR         dd  0

;
; Interrupt Request Active Register.  Indicates which hardware interrupts are
; currently being serviced.  Used to prevent recursion in HalEndSystemInterrupt.
;

        public  HalpIRRActive
HalpIRRActive   dd  0

;
; Interrupt Disable Register.  Indicates which interrupts are physically masked
; at the PIC.  IRQ02, the link the secondary interrupt controller, is never
; disabled.
;

        public  HalpIDR
HalpIDR         dd  0FFFFFFFBh

;
; Edge/level Control Register.  Indicates which IRQs are edge or level
; sensitive.
;
        public  HalpEisaELCR
HalpEisaELCR    dd  0

;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissNormal   ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        public  HalpSpecialDismissLevelTable
HalpSpecialDismissLevelTable label   dword
        dd      offset FLAT:HalpDismissLevel        ; irq 0
        dd      offset FLAT:HalpDismissLevel        ; irq 1
        dd      offset FLAT:HalpDismissLevel        ; irq 2
        dd      offset FLAT:HalpDismissLevel        ; irq 3
        dd      offset FLAT:HalpDismissLevel        ; irq 4
        dd      offset FLAT:HalpDismissLevel        ; irq 5
        dd      offset FLAT:HalpDismissLevel        ; irq 6
        dd      offset FLAT:HalpDismissIrq07Level   ; irq 7
        dd      offset FLAT:HalpDismissLevel        ; irq 8
        dd      offset FLAT:HalpDismissLevel        ; irq 9
        dd      offset FLAT:HalpDismissLevel        ; irq A
        dd      offset FLAT:HalpDismissLevel        ; irq B
        dd      offset FLAT:HalpDismissLevel        ; irq C
        dd      offset FLAT:HalpDismissLevel        ; irq D
        dd      offset FLAT:HalpDismissLevel        ; irq E
        dd      offset FLAT:HalpDismissIrq0fLevel   ; irq F

;++
;VOID
;FASTCALL
;HalBeginSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql,
;    OUT PKIRQL OldIrql
;    )
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This assumes that [esp+4] is OldIrql.
;
;    N.B.  This routine automatically IRETs if the interrupt is spurious.
;
;    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
;    This is fine since the irql is being raise to mask it off.
;    HalEndSystemInterrupt is simply a LowerIrql request.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be dismissed
;
;    Irql   - Supplies the IRQL to raise to
;
;    OldIrql- Location to return OldIrql
;
;Return Value:
;
;    None.
;
;--
align dword

cPublicFastCall HalBeginSystemInterrupt ,2

;
; N.B. The interrupt dispatch code jumps through HalpSpecialDismissTable to
; avoid skipping through to the next instruction.
;

        jmp     HalpSpecialDismissTable[ecx*4]

HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
HalpIrq0fSpurious:
;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        add     esp, 8                  ; clear return address and OldIrql
        SPURIOUS_INTERRUPT_EXIT

HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     HalpDismissNormal       ; No, so this is NOT a spurious int

        add     esp, 8
        SPURIOUS_INTERRUPT_EXIT

align 4

;
; The clock and profile interrupts bypass HalpSpecialDismissTable and enter at
; this point with the same entry conditions as HalBeginSystemInterrupt.
;

        public  @HalBeginClockInterrupt@8
@HalBeginClockInterrupt@8 label byte
        public  @HalBeginProfileInterrupt@8
@HalBeginProfileInterrupt@8 label byte

HalpDismissNormal:
;
; Raise IRQL to requested level
;
        xor     ebx, ebx
        mov     bl, PCRB[PcIrql]        ; (ebx) = Current Irql

;
; Now we check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious and set the appropriate bit
; in the IRR so we can dispatch the interrupt when Irql is lowered
;
        cmp     dl, bl
        jbe     Hdsi300

        mov     PCRB[PcIrql], dl        ; set new Irql
        mov     byte ptr [esp+4], bl    ; save current irql to OldIrql variable

;
; Dismiss interrupt.
;
        mov     eax, ecx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?
        jae     short Hbsi100           ; EIO to both master and slave

        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        sti
        fstRET  HalBeginSystemInterrupt

align 4
Hbsi100:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al

        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        sti
        fstRET  HalBeginSystemInterrupt

align 4
Hdsi300:
;
; An interrupt has come in at a lower Irql, so we dismiss it as spurious and
; set the appropriate bit in the IRR so that KeLowerIrql knows to dispatch
; it when Irql is lowered.
;
; (ecx) = 8259 IRQ#
; (al)  = New Irql
; (ebx) = Current Irql
;

        mov     eax, 1
        add     ecx, 4                  ; (ecx) = Irq # + 4
        shl     eax, cl
        or      HalpIRR, eax

;
; Raise Irql to prevent it from happening again
;

;
; Get the PIC masks for Irql
;

        mov     eax, KiI8259MaskTable[ebx*4]
        or      eax, HalpIDR

;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

Hbsi390:
        add     esp, 8
        SPURIOUS_INTERRUPT_EXIT

HalpDismissIrq0fLevel:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
        jmp     HalpIrq0fSpurious

HalpDismissIrq07Level:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, so this is NOT a spurious int
        add     esp, 8                  ; clear return address and OldIrql
        SPURIOUS_INTERRUPT_EXIT

align 4
;
; The system control interrupt (SCI) and SMBus interrupt bypasses
; HalpSpecialDismissTable and enter at this point with the same entry conditions
; as HalBeginSystemInterrupt.
;

        public  @HalBeginSystemControlInterrupt@8
@HalBeginSystemControlInterrupt@8 label byte
        public  @HalBeginSMBusInterrupt@8
@HalBeginSMBusInterrupt@8 label byte

HalpDismissLevel:
;
; Raise IRQL to requested level
;
        xor     ebx, ebx
        mov     bl, PCRB[PcIrql]        ; (ebx) = Current Irql

        cmp     ecx, 8                  ; EOI for irq2?
        jb      Hbsi400

        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

;
; Now we check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious and set the appropriate bit
; in the IRR so we can dispatch the interrupt when Irql is lowered
;
Hbsi400:
        cmp     dl, bl
        jbe     Hdsi300

        mov     PCRB[PcIrql], dl        ; set new Irql
        mov     byte ptr [esp+4], bl    ; save current irql to OldIrql variable

        sti
        fstRET  HalBeginSystemInterrupt

fstENDP HalBeginSystemInterrupt

;++
;VOID
;HalDisableSystemInterrupt(
;    IN ULONG BusInterruptLevel
;    )
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    BusInterruptLevel - Supplies the IRQ of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,1
.FPO ( 0, 1, 0, 0, 0, 0 )

        movzx   ecx, byte ptr [esp+4]       ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                     ; (ebx) = bit in IMR to disable
        cli
        or      HalpIDR, edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;VOID
;HalEnableSystemInterrupt(
;    IN ULONG BusInterruptLevel,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    BusInterruptLevel - Supplies the IRQ of the interrupt to be enabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalEnableSystemInterrupt       ,2
.FPO ( 0, 2, 0, 0, 0, 0 )

        movzx   ecx, byte ptr [esp+4]       ; (ecx) = 8259 irq #

;
; Clear or set the edge\level mask bit depending on what the caller wants.
;
        btr     HalpEisaELCR, ecx
        mov     al, [esp+8]
        cmp     al, 0
        jnz     short hes_edge

        ; Caller wants level triggered interrupts
        bts     HalpEisaELCR, ecx

        mov     edx, HalpSpecialDismissLevelTable[ecx*4]
        mov     HalpSpecialDismissTable[ecx*4], edx

hes_edge:
;
; Program the HW to make it match the callers request.
;
        mov     eax, HalpEisaELCR
        mov     edx, EISA_EDGE_LEVEL0
        out     dx, al
        IODelay
        mov     al, ah
        inc     edx
        out     dx, al

hes_ProgPIC:

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        cli
        and     HalpIDR, eax

;
; Get the PIC masks for Irql 0
;
        mov     eax, KiI8259MaskTable[0]
        or      eax, HalpIDR
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        sti
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\mcpxsmb.inc ===
;/*++
;
;Copyright (c) 2001  Microsoft Corporation
;
;Module Name:
;
;    mcpxsmb.inc
;
;Abstract:
;
;    This module defines the MCPX SMBus logic block registers and fields.
;
;--
if 0        ; Begin C only code         */

//
// Define the SMBus registers starting at XPCICFG_SMBUS_IO_REGISTER_BASE_1.
//

#define MCPX_SMBUS_HOST_STATUS_REGISTER         0x00
#define MCPX_SMBUS_HOST_CONTROL_REGISTER        0x02
#define MCPX_SMBUS_HOST_ADDRESS_REGISTER        0x04
#define MCPX_SMBUS_HOST_DATA_REGISTER           0x06
#define MCPX_SMBUS_HOST_COMMAND_REGISTER        0x08
#define MCPX_SMBUS_HOST_BLOCK_DATA_REGISTER     0x09

//
// Define the status bits for MCPX_SMBUS_HOST_STATUS_REGISTER.
//

#define MCPX_STATUS_HOST_ABORT                  0x0001
#define MCPX_STATUS_COLLISION                   0x0002
#define MCPX_STATUS_PROTOCOL_ERROR              0x0004
#define MCPX_STATUS_HOST_BUSY                   0x0008
#define MCPX_STATUS_HOST_CYCLE_COMPLETE         0x0010
#define MCPX_STATUS_TIMEOUT_ERROR               0x0020

//
// Define the control bits for MCPX_SMBUS_HOST_CONTROL_REGISTER.
//

#define MCPX_CONTROL_CYCLE_READ_WRITE_BYTE      0x0002
#define MCPX_CONTROL_CYCLE_READ_WRITE_WORD      0x0003
#define MCPX_CONTROL_HOST_START                 0x0008
#define MCPX_CONTROL_INTERRUPT_ENABLE           0x0010

//
// Define the address bits for MCPX_SMBUS_HOST_ADDRESS_REGISTER.
//

#define MCPX_ADDRESS_READ_CYCLE                 0x0001

/*
endif

;
; Define the SMBus registers starting at XPCICFG_SMBUS_IO_REGISTER_BASE_1.
;

MCPX_SMBUS_HOST_STATUS_REGISTER         EQU     00h
MCPX_SMBUS_HOST_CONTROL_REGISTER        EQU     02h
MCPX_SMBUS_HOST_ADDRESS_REGISTER        EQU     04h
MCPX_SMBUS_HOST_DATA_REGISTER           EQU     06h
MCPX_SMBUS_HOST_COMMAND_REGISTER        EQU     08h
MCPX_SMBUS_HOST_BLOCK_DATA_REGISTER     EQU     09h

;
; Define the status bits for MCPX_SMBUS_HOST_STATUS_REGISTER.
;

MCPX_STATUS_HOST_ABORT                  EQU     0001h
MCPX_STATUS_COLLISION                   EQU     0002h
MCPX_STATUS_PROTOCOL_ERROR              EQU     0004h
MCPX_STATUS_HOST_BUSY                   EQU     0008h
MCPX_STATUS_HOST_CYCLE_COMPLETE         EQU     0010h
MCPX_STATUS_TIMEOUT_ERROR               EQU     0020h

;
; Define the control bits for MCPX_SMBUS_HOST_CONTROL_REGISTER.
;

MCPX_CONTROL_CYCLE_READ_WRITE_BYTE      EQU     0002h
MCPX_CONTROL_CYCLE_READ_WRITE_WORD      EQU     0003h
MCPX_CONTROL_HOST_START                 EQU     0008h
MCPX_CONTROL_INTERRUPT_ENABLE           EQU     0010h

;
; Define the address bits for MCPX_SMBUS_HOST_ADDRESS_REGISTER.
;

MCPX_ADDRESS_READ_CYCLE                 EQU     0001h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\mcpxacpi.inc ===
;/*++
;
;Copyright (c) 2001  Microsoft Corporation
;
;Module Name:
;
;    mcpxacpi.inc
;
;Abstract:
;
;    This module defines the MCPX ACPI logic block registers and fields.
;
;--
if 0        ; Begin C only code         */

//
// Define the ACPI registers starting at XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0.
//

#define MCPX_ACPI_PM1_STATUS_REGISTER           0x00
#define MCPX_ACPI_PM1_ENABLE_REGISTER           0x02
#define MCPX_ACPI_PM1_CONTROL_REGISTER          0x04
#define MCPX_ACPI_PM_TIMER_REGISTER             0x08
#define MCPX_ACPI_GPE0_STATUS_REGISTER          0x20
#define MCPX_ACPI_GPE0_ENABLE_REGISTER          0x22
#define MCPX_ACPI_GLOBAL_SMI_CONTROL            0x28

//
// Define the status bits for MCPX_ACPI_PM1_STATUS_REGISTER.
//

#define PM1_TIMER_STATUS                        0x0001

//
// Define the enable bits for MCPX_ACPI_PM1_ENABLE_REGISTER.
//

#define PM1_TIMER_ENABLE                        0x0001

//
// Define the control bits for MCPX_ACPI_PM1_CONTROL_REGISTER.
//

#define PM1_SCI_ENABLE                          0x0001

//
// Define the enable bits for MCPX_ACPI_GPE0_ENABLE_REGISTER.
//

#define GPE0_EXTSMI_ENABLE                      0x0002

//
// Define the control bits for MCPX_ACPI_GLOBAL_SMI_CONTROL.
//

#define GPE0_SMI_ENABLE                         0x0001

/*
endif

;
; Define the ACPI registers starting at XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0.
;

MCPX_ACPI_PM1_STATUS_REGISTER           EQU     00h
MCPX_ACPI_PM1_ENABLE_REGISTER           EQU     02h
MCPX_ACPI_PM1_CONTROL_REGISTER          EQU     04h
MCPX_ACPI_PM_TIMER_REGISTER             EQU     08h
MCPX_ACPI_GPE0_STATUS_REGISTER          EQU     20h
MCPX_ACPI_GPE0_ENABLE_REGISTER          EQU     22h
MCPX_ACPI_GLOBAL_SMI_CONTROL            EQU     28h

;
; Define the status bits for MCPX_ACPI_PM1_STATUS_REGISTER.
;

PM1_TIMER_STATUS                        EQU     0001h

;
; Define the status bits for MCPX_ACPI_GPE0_STATUS_REGISTER.
;

GPE0_EXTSMI_STATUS                      EQU     0002h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\pcisetup.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    pcisetup.c

Abstract:

    This module implements routines to setup PCI at system boot.

--*/

#include "halp.h"
#include <pci.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpSetupPCIDevices)
#endif

VOID
HalpSetupPCIDevices(
    VOID
    )
{
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_COMMON_CONFIG Configuration;
    ULONG interrupt;
    UCHAR pciint;
    UCHAR acpitimer;
    ULONG agpcmd;
    ULONG acicfg;
    ULONG epgpclock;
    ULONG mcpUsbCfg20Value;

    PCISlotNumber.u.AsULONG = 0;

    //
    // Interrupt routing.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_LPCBRIDGE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_LPCBRIDGE_FUNCTION_ID;

    pciint = 0x3;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x6A, &pciint, sizeof(pciint));

    interrupt = 0x0E065491;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x6C, &interrupt, sizeof(interrupt));

    interrupt = 0x00000b0c;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x64, &interrupt, sizeof(interrupt));

    //
    // Select a 32-bit ACPI timer.
    //

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0x81, &acpitimer, sizeof(acpitimer));

    acpitimer |= 0x08;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x81, &acpitimer, sizeof(acpitimer));

    //
    // Configure the IDE controller.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_IDE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_IDE_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER);
    Configuration.ProgIf &= ~0x05;
    Configuration.u.type0.BaseAddresses[4] = XPCICFG_IDE_IO_REGISTER_BASE_4 | PCI_ADDRESS_IO_SPACE;
    *((PULONG)((PUCHAR)&Configuration + 0x50)) = 2;
    *((PULONG)((PUCHAR)&Configuration + 0x58)) = 0x20202020;
    *((PULONG)((PUCHAR)&Configuration + 0x60)) = 0xC0C0C0C0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Configure the NIC.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_NIC_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_NIC_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_NIC_MEMORY_REGISTER_BASE_0;
    Configuration.u.type0.BaseAddresses[1] = XPCICFG_NIC_IO_REGISTER_BASE_1 | PCI_ADDRESS_IO_SPACE;
    Configuration.u.type0.InterruptLine = XPCICFG_NIC_IRQ;
    Configuration.u.type0.InterruptPin = 0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Configure USB0.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_USB0_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_USB0_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_USB0_MEMORY_REGISTER_BASE_0;
    Configuration.u.type0.InterruptLine = XPCICFG_USB0_IRQ;
    Configuration.u.type0.InterruptPin = 0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Assign peripheral ports 0 through 3 to USB0
    //

    mcpUsbCfg20Value = MCP_USB_CFG_20_PORT0 | MCP_USB_CFG_20_PORT1 | MCP_USB_CFG_20_PORT2 | MCP_USB_CFG_20_PORT3;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, MCP_USB_CFG_20, &mcpUsbCfg20Value, sizeof(mcpUsbCfg20Value));
    
    //
    // Configure USB1.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_USB1_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_USB1_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_USB1_MEMORY_REGISTER_BASE_0;
    Configuration.u.type0.InterruptLine = XPCICFG_USB1_IRQ;
    Configuration.u.type0.InterruptPin = 0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Assign peripheral ports 4 and 5 to USB1
    //
    mcpUsbCfg20Value = MCP_USB_CFG_20_PORT4 | MCP_USB_CFG_20_PORT5;
    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, MCP_USB_CFG_20, &mcpUsbCfg20Value, sizeof(mcpUsbCfg20Value));

    //
    // Configure audio.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_ACI_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_ACI_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.InterruptLine = XPCICFG_ACI_IRQ;
    Configuration.u.type0.InterruptPin = 0;
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_ACI_IO_REGISTER_BASE_0 | PCI_ADDRESS_IO_SPACE;
    Configuration.u.type0.BaseAddresses[1] = XPCICFG_ACI_IO_REGISTER_BASE_1 | PCI_ADDRESS_IO_SPACE;
    Configuration.u.type0.BaseAddresses[2] = XPCICFG_ACI_MEMORY_REGISTER_BASE_2;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_APU_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_APU_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.InterruptLine = XPCICFG_APU_IRQ;
    Configuration.u.type0.InterruptPin = 0;
    Configuration.u.type0.BaseAddresses[0] = XPCICFG_APU_MEMORY_REGISTER_BASE_0;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // AUDIO: set GP and EP DSPs clock frequency
    //

    PCISlotNumber.u.AsULONG = 0;
    PCISlotNumber.u.bits.DeviceNumber = 1;
    PCISlotNumber.u.bits.FunctionNumber = 0;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0x8C, &epgpclock, sizeof(epgpclock));

    //
    // bits 26 and 27 set the clock frequency of the MCP
    // 0x00, 2b00  =  160
    // 0x01, 2b01  =  200
    // 0x02, 2b10  =  133
    // 0x03, 2b11  =  160
    //

    epgpclock &= ~(0x3 << 26);
    epgpclock |= 0x2 << 26;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x8C, &epgpclock, sizeof(epgpclock));

    //
    // Turn on S/PDIF
    //

    _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xCD, 8);

    //
    // Set up ACI and S/PDIF to always loop on the DMA, regardless of whether
    // interrupts have been handled or not.
    //

    HalReadPCISpace(0, XPCICFG_ACI_DEVICE_ID, 0x4C, &acicfg, sizeof(acicfg));

    acicfg |= (1UL << 16);
    acicfg |= (1UL << 24);

    HalWritePCISpace(0, XPCICFG_ACI_DEVICE_ID, 0x4C, &acicfg, sizeof(acicfg));

    //
    // Configure AGP.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_AGPBRIDGE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_AGPBRIDGE_FUNCTION_ID;

    HalReadPCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);

    Configuration.u.type1.PrimaryBus = 0;
    Configuration.u.type1.SecondaryBus = 1;
    Configuration.u.type1.SubordinateBus = 1;

    Configuration.u.type1.MemoryBase = 0xFD00;
    Configuration.u.type1.MemoryLimit = 0xFE70;
    Configuration.u.type1.PrefetchBase = 0xF000;

    if (XboxHardwareInfo.Flags & XBOX_HW_FLAG_ARCADE) {
        Configuration.u.type1.PrefetchLimit = 0xF7F0;
    } else {
        Configuration.u.type1.PrefetchLimit = 0xF3F0;
    }

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Enable agp, 4x and fast writes on the host
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_GPU_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_GPU_FUNCTION_ID;

    agpcmd =  0x4 | 0x010 | 0x100;

    HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x48, &agpcmd, sizeof(agpcmd));

    //
    // Configure NV20.
    //

    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_GPU_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_GPU_FUNCTION_ID;

    HalReadPCISpace(1, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    Configuration.Command |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_BUS_MASTER | PCI_ENABLE_MEMORY_SPACE);
    Configuration.u.type0.InterruptLine = XPCICFG_GPU_IRQ;
    Configuration.u.type0.InterruptPin = 1;

    HalWritePCISpace(1, PCISlotNumber.u.AsULONG, 0, &Configuration, sizeof(Configuration));

    //
    // Enable agp, 4x and fast writes on the card
    //

    agpcmd = 0x4 | 0x010 | 0x100;

    HalWritePCISpace(1, PCISlotNumber.u.AsULONG, 0x4C, &agpcmd, sizeof(agpcmd));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\mcupdate.asm ===
TITLE   "Microcode Update Loader Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     mcupdate.asm
;
;  Abstract:
;
;     This module implements the routines to update the microcode for an Intel
;     processor.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalMicrocodeUpdateLoader(
;     VOID
;     )
;
; Routine Description:
;
;     This function updates the microcode for an Intel processor.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _HalMicrocodeUpdateLoader, 0

;
; Determine what family and model of processor we're executing on.
;

        mov     eax, 1
        cpuid

        mov     ecx, eax

        cmp     ecx, 0686h
        lea     eax, [HalpMicrocode686]+MudbUpdateData
        je      LoadMicrocodeUpdate

        cmp     ecx, 068Ah
        lea     eax, [HalpMicrocode68A]+MudbUpdateData
        je      LoadMicrocodeUpdate

        stdRET  _HalMicrocodeUpdateLoader

;
; Load the microcode update into the processor.  EAX contains the linear address
; of the start of the update data, EDX is zero, and ECX contains the microcode
; update register.
;

LoadMicrocodeUpdate:
        mov     ecx, 079h               ; microcode update register
        xor     edx, edx
        wrmsr                           ; do the update

        stdRET  _HalMicrocodeUpdateLoader

stdENDP _HalMicrocodeUpdateLoader

;
; Include the latest microcode updates for the processors that Xbox can run on.
;

        ALIGN   4
        PUBLIC  HalpMicrocode686
HalpMicrocode686 LABEL BYTE
        INCLUDE ..\bootx\mcupdate\mu168608.txt
.errnz ($ - HalpMicrocode686) NE MudbStructureLength

        ALIGN   4
        PUBLIC  HalpMicrocode68A
HalpMicrocode68A LABEL BYTE
        INCLUDE ..\bootx\mcupdate\mu168A01.txt
.errnz ($ - HalpMicrocode68A) NE MudbStructureLength

INIT    ends

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\pmtimer.asm ===
title  "ACPI Timer Functions"
;++
;
; Copyright (c) 1989-2001  Microsoft Corporation
;
; Module Name:
;
;    pmtimer.asm
;
; Abstract:
;
;    This module implements the code for ACPI-related timer functions.
;
; Environment:
;
;    Kernel mode only.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc
include i386\ix8259.inc
INCLUDE i386\mcpxacpi.inc
        .list

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

MSBMASK32               EQU     80000000h

        PUBLIC  HalpPerformanceCounterLow, HalpPerformanceCounterHigh1, HalpPerformanceCounterHigh2
HalpPerformanceCounterLow       dd      0
HalpPerformanceCounterHigh1     dd      0
HalpPerformanceCounterHigh2     dd      0

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current 64-bit performance counter.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

cPublicProc _KeQueryPerformanceCounter, 0
cPublicFpo 0, 1

        push    ebx

        ;
        ; Snap current times
        ;

kqpc10: mov     ecx, HalpPerformanceCounterHigh2
        mov     ebx, HalpPerformanceCounterLow

        cmp     ecx, HalpPerformanceCounterHigh1
        jne     short kqpc10        ; Loop until consistent copy read

        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM_TIMER_REGISTER
        in      eax, dx

        ;
        ; See if h/w MSb matches s/w copy
        ;

        mov     edx, eax
        xor     edx, ebx
        and     edx, MSBMASK32      ; Isolate MSb match or mismatch

        ;
        ; Strip high hardware bit
        ;

        and     eax, NOT MSBMASK32

        ;
        ; merge low bits
        ;

        and     ebx, MSBMASK32
        or      eax, ebx

        ;
        ; If there was a mismatch, add a tick
        ;

        add     eax, edx
        adc     ecx, 0

        mov     edx, ecx                ; get the top-half of the return value

kqpc40: pop     ebx

        stdRET  _KeQueryPerformanceCounter

stdENDP _KeQueryPerformanceCounter

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceFrequency (
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current 64-bit performance frequency.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Current frequency of the performance counter will be returned.
;
;--

cPublicProc _KeQueryPerformanceFrequency, 0
cPublicFpo 0, 0

;
; Return the frequency of the legacy core frequency (13.5Mhz) divided by four to
; obtain the ACPI timer frequency (3.375Mhz).
;
        mov     eax, 3375000
        xor     edx, edx
        stdRET  _KeQueryPerformanceFrequency

stdENDP _KeQueryPerformanceFrequency

;++
;
; VOID
; HalpAcpiTimerCarry (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called to service the PM timer carry interrupt
;
;    N.B. This function is called at interrupt time and assumes the
;    caller clears the interrupt
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalpAcpiTimerCarry, 0
cPublicFpo 0, 0

        ;
        ; Get current time from h/w
        ;

        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM_TIMER_REGISTER
        in      eax, dx
        mov     ecx, eax

        mov     eax, HalpPerformanceCounterLow
        mov     edx, HalpPerformanceCounterHigh2

        ;
        ; Add one tick
        ;

        add     eax, MSBMASK32
        adc     edx, 0

        ;
        ; MSb of h/w should now match s/w.  If not, add another tick
        ; to get them back in sync.  (debugger might knock them
        ; out of sync)
        ;

        xor     ecx, eax
        and     ecx, MSBMASK32
        add     eax, ecx
        adc     edx, 0

        ;
        ; Store in reverse order of code which reads it
        ;

        mov     HalpPerformanceCounterHigh1, edx
        mov     HalpPerformanceCounterLow, eax
        mov     HalpPerformanceCounterHigh2, edx

        stdRET  _HalpAcpiTimerCarry
stdENDP _HalpAcpiTimerCarry

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\sciinta.asm ===
TITLE   "System Control Interrupt Service Routine"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     sciinta.asm
;
;  Abstract:
;
;     This module implements the routines to handle a System Control Interrupt
;     (SCI) from the ACPI logic block or external SMI.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
INCLUDE i386\kimacro.inc
INCLUDE i386\ix8259.inc
INCLUDE i386\mcpxacpi.inc
        .list

        EXTRNP  HalBeginSystemControlInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemLevelInterrupt,1,,FASTCALL
        EXTRNP  _KeInsertQueueDpc,3
        EXTRNP  _HalpAcpiTimerCarry,0
        EXTRN   _KiPCR:DWORD
        EXTRN   _HalpSystemControlInterruptDpc:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpSystemControlInterrupt(
;     VOID
;     )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by the
;    ACPI logic block or an external SMI that has been rerouted to the SCI.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpSystemControlInterrupt, 0

        ENTER_INTERRUPT

        mov     ecx, SCI_VECTOR - PRIMARY_VECTOR_BASE
        mov     edx, SCI_LEVEL
        push    0                       ; allocate space to save OldIrql
        fstCall HalBeginSystemControlInterrupt

;
; Check if the signal for an ACPI timer overflow has been set.  If so, clear the
; signal and increment the high bits of the performance counter.
;

        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_STATUS_REGISTER
        in      al, dx
        and     al, PM1_TIMER_STATUS
        jz      NotAcpiTimerInterrupt
        out     dx, al                  ; clear signal by writing the bit back
        stdCall _HalpAcpiTimerCarry

;
; Check if the signal for the external SMI has been set.  If so, clear the
; signal and queue a DPC to talk to the SMC at a safe point.
;

NotAcpiTimerInterrupt:
        mov     edx, XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GPE0_STATUS_REGISTER
        in      al, dx
        test    al, GPE0_EXTSMI_STATUS
        jz      NotExternalSMI
        mov     al, GPE0_EXTSMI_STATUS
        out     dx, al

        stdCall _KeInsertQueueDpc,<offset _HalpSystemControlInterruptDpc, 0, 0>

NotExternalSMI:
        mov     eax, SCI_VECTOR - PRIMARY_VECTOR_BASE
        LEVEL_INTERRUPT_EXIT

stdENDP _HalpSystemControlInterrupt

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\pcispace.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    pcispace.c

Abstract:

    This module implements the routines to interface with PCI configuration
    space.

--*/

#include "halp.h"

//
// Function prototype for PCI configuration space accessors.
//

typedef
ULONG
(*PHAL_PCISPACE_ACCESS_ROUTINE)(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    );

ULONG
HalpReadPCISpaceUchar(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads one byte from PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to read from.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location to receive the data read.

Return Value:

    The number of bytes read from PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    *((PUCHAR)Buffer) = (UCHAR)_inp(PCI_TYPE1_DATA_PORT + RegisterByteOffset);

    return sizeof(UCHAR);
}

ULONG
HalpReadPCISpaceUshort(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads two bytes from PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to read from.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location to receive the data read.

Return Value:

    The number of bytes read from PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    *((PUSHORT)Buffer) = (USHORT)_inpw(PCI_TYPE1_DATA_PORT + RegisterByteOffset);

    return sizeof(USHORT);
}

ULONG
HalpReadPCISpaceUlong(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    OUT PVOID Buffer
    )
/*++

Routine Description:

    This routine reads four bytes from PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to read from.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location to receive the data read.

Return Value:

    The number of bytes read from PCI configuration space.

--*/
{
    ASSERT((RegisterNumber % sizeof(ULONG)) == 0);

    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    *((PULONG)Buffer) = _inpd(PCI_TYPE1_DATA_PORT);

    return sizeof(ULONG);
}

ULONG
HalpWritePCISpaceUchar(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine writes one byte to PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to write to.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location that has the data to write out.

Return Value:

    The number of bytes written to PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    _outp(PCI_TYPE1_DATA_PORT + RegisterByteOffset, *((PUCHAR)Buffer));

    return sizeof(UCHAR);
}

ULONG
HalpWritePCISpaceUshort(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine writes two bytes to PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to write to.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location that has the data to write out.

Return Value:

    The number of bytes written to PCI configuration space.

--*/
{
    ULONG RegisterByteOffset;

    RegisterByteOffset = RegisterNumber % sizeof(ULONG);
    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    _outpw(PCI_TYPE1_DATA_PORT + RegisterByteOffset, *((PUSHORT)Buffer));

    return sizeof(USHORT);
}

ULONG
HalpWritePCISpaceUlong(
    IN PCI_TYPE1_CFG_BITS CfgBits,
    IN ULONG RegisterNumber,
    IN PVOID Buffer
    )
/*++

Routine Description:

    This routine writes four bytes to PCI configuration space.

Arguments:

    CfgBits - Specifies the bus, device, and function number to write to.

    RegisterNumber - Specifies the register number to transfer.

    Buffer - Specifies the location that has the data to write out.

Return Value:

    The number of bytes written to PCI configuration space.

--*/
{
    ASSERT((RegisterNumber % sizeof(ULONG)) == 0);

    CfgBits.u.bits.RegisterNumber = RegisterNumber / sizeof(ULONG);

    _outpd(PCI_TYPE1_ADDR_PORT, CfgBits.u.AsULONG);
    _outpd(PCI_TYPE1_DATA_PORT, *((PULONG)Buffer));

    return sizeof(ULONG);
}

//
// Array of PCI configuration space read routines.
//
const PHAL_PCISPACE_ACCESS_ROUTINE HalpPCISpaceReaders[] = {
    HalpReadPCISpaceUlong,
    HalpReadPCISpaceUchar,
    HalpReadPCISpaceUshort
};

//
// Array of PCI configuration space write routines.
//
const PHAL_PCISPACE_ACCESS_ROUTINE HalpPCISpaceWriters[] = {
    HalpWritePCISpaceUlong,
    HalpWritePCISpaceUchar,
    HalpWritePCISpaceUshort
};

//
// Matrix of indexes into the above read and write routine arrays in order to
// access a given byte offset and transfer length.
//
const UCHAR HalpPCISpaceAccessMatrix[4][4] = {
    {0, 1, 2, 2},
    {1, 1, 1, 1},
    {2, 1, 2, 2},
    {1, 1, 1, 1}
};

VOID
HalReadWritePCISpace(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG RegisterNumber,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN WritePCISpace
    )
/*++

Routine Description:

    This routine reads from or writes to a buffer with PCI configuration space.

Arguments:

    BusNumber - Specifies the desired PCI bus number.

    SlotNumber - Specifies the desired PCI device and function number.

    RegisterNumber - Specifies the desired starting PCI register number.

    Buffer - Specifies the buffer to receive the data or supply the data for the
        transfer.

    Length - Specifies the number of bytes to transfer.

    WritePCISpace - Specifies TRUE if data should be written to PCI
        configuration space, else FALSE if data should be read from PCI
        configuration space.

Return Value:

    None.

--*/
{
    PCI_SLOT_NUMBER PCISlotNumber;
    PCI_TYPE1_CFG_BITS CfgBits;
#if DBG
    USHORT DbgVendorID;
#endif
    const PHAL_PCISPACE_ACCESS_ROUTINE *PCISpaceAccessors;
    ULONG BytesTransferred;
    UCHAR AccessIndex;

    ASSERT(BusNumber <= PCI_MAX_BRIDGE_NUMBER);
    ASSERT(RegisterNumber < sizeof(PCI_COMMON_CONFIG));

    //
    // Initialize the static portion of the configuration bits.
    //

    PCISlotNumber.u.AsULONG = SlotNumber;

    CfgBits.u.AsULONG = 0;
    CfgBits.u.bits.BusNumber = BusNumber;
    CfgBits.u.bits.DeviceNumber = PCISlotNumber.u.bits.DeviceNumber;
    CfgBits.u.bits.FunctionNumber = PCISlotNumber.u.bits.FunctionNumber;
    CfgBits.u.bits.Enable = 1;

    //
    // Synchronize access to PCI configuration space by disabling interrupts.
    //

    _disable();

#if DBG
    //
    // If we're writing out to PCI space, then assert that there's a device
    // connected to the supplied bus/device/function number.
    //

    if (WritePCISpace) {
        HalpReadPCISpaceUshort(CfgBits, 0, &DbgVendorID);
        ASSERT(DbgVendorID != PCI_INVALID_VENDORID);
    }
#endif

    //
    // Determine which set of function pointers to use to access PCI
    // configuration space.
    //

    PCISpaceAccessors = WritePCISpace ? HalpPCISpaceWriters : HalpPCISpaceReaders;

    //
    // Transfer the data to or from PCI configuration space.
    //

    while (Length > 0) {

        AccessIndex = HalpPCISpaceAccessMatrix[RegisterNumber % sizeof(ULONG)][Length % sizeof(ULONG)];

        BytesTransferred = PCISpaceAccessors[AccessIndex](CfgBits,
            RegisterNumber, Buffer);

        RegisterNumber += BytesTransferred;
        Buffer = (PUCHAR)Buffer + BytesTransferred;
        Length -= BytesTransferred;
    }

    //
    // Reenable interrupts now that we're finished accessing PCI configuration
    // space.
    //

    _enable();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\superio.asm ===
TITLE   "Super I/O Controller Initialization Routine"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     superio.asm
;
;  Abstract:
;
;     This module implements the routines to interact with the system super I/O
;     controller.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
INCLUDE i386\ix8259.inc
        .list

;
; Define the ports used to interact with the super I/O controller.
;

SMC_CONFIG_PORT                     EQU     02Eh
SMC_INDEX_PORT                      EQU     02Fh
SMC_DATA_PORT                       EQU     02Fh

;
; Define the values to enter and exit the configuration mode of the super I/O
; controller.
;

SMC_ENTER_CONFIGURATION_MODE        EQU     055h
SMC_EXIT_CONFIGURATION_MODE         EQU     0AAh

;
; Define the logical device numbers.
;

SMC_FLOPPY_DRIVE_CONTROLLER         EQU     000h
SMC_PARALLEL_PORT                   EQU     003h
SMC_SERIAL_PORT_1                   EQU     004h
SMC_SERIAL_PORT_2                   EQU     005h
SMC_KEYBOARD                        EQU     007h
SMC_GAME_PORT                       EQU     009h
SMC_PME                             EQU     00Ah
SMC_MPU_401                         EQU     00Bh
SMC_USB_HUB                         EQU     00Ch

;
; Define the global configuration registers.
;

SMC_LOGICAL_DEVICE_NUMBER           EQU     007h

SMC_CONFIGURATION_PORT_0            EQU     026h
SMC_CONFIGURATION_PORT_1            EQU     027h
SMC_DEVICE_ACTIVATE                 EQU     030h
SMC_DEVICE_PRIMARY_ADDRESS_HIGH     EQU     060h
SMC_DEVICE_PRIMARY_ADDRESS_LOW      EQU     061h

IFDEF DEVKIT
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
ELSE
INIT    SEGMENT DWORD PUBLIC 'CODE'
ENDIF
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; HalInitializeSuperIo(
;     VOID
;     )
;
; Routine Description:
;
;     This function initializes the super I/O controller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     Returns TRUE if the super I/O controller exists, else FALSE.
;
;--
cPublicProc _HalInitializeSuperIo, 0

;
; Place the the super I/O controller in configuration mode.
;

        mov     edx, SMC_CONFIG_PORT
        mov     al, SMC_ENTER_CONFIGURATION_MODE
        out     dx, al
        IODelay

;
; Check if the super I/O controller exists by reading from the configuration
; port address and comparing it to the hardcoded configuration port address.
;

        mov     al, SMC_CONFIGURATION_PORT_0
        out     dx, al
        IODelay
        inc     edx
        in      al, dx
        dec     edx
        cmp     al, SMC_CONFIG_PORT
        jne     ControllerNotFound

        mov     al, SMC_CONFIGURATION_PORT_1
        out     dx, al
        IODelay
        inc     edx
        in      al, dx
        dec     edx
        test    al, al
        jnz     ControllerNotFound

;
; Select the first serial I/O port for configuration.
;

        mov     al, SMC_LOGICAL_DEVICE_NUMBER
        out     dx, al
        IODelay
        inc     edx
        mov     al, SMC_SERIAL_PORT_1
        out     dx, al
        IODelay
        dec     edx

;
; Activate the first serial I/O port at a base address of 0x03F8.
;

        mov     al, SMC_DEVICE_ACTIVATE
        out     dx, al
        IODelay
        inc     edx
        mov     al, 1
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_HIGH
        out     dx, al
        IODelay
        inc     edx
        mov     al, 003h
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_LOW
        out     dx, al
        IODelay
        inc     edx
        mov     al, 0F8h
        out     dx, al
        IODelay
        dec     edx

;
; Take the the super I/O controller out of configuration mode.
;

        mov     al, SMC_EXIT_CONFIGURATION_MODE
        out     dx, al

;
; Return TRUE to indicate that we initialized the super I/O controller.
;

        mov     al, 1
        stdRET  _HalInitializeSuperIo

;
; Return TRUE to indicate that we initialized the super I/O controller.
;

ControllerNotFound:
        xor     al, al
        stdRET  _HalInitializeSuperIo

stdENDP _HalInitializeSuperIo

IFDEF DEVKIT
_TEXT   ends
ELSE
INIT    ends
ENDIF

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\smbussci.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    smbussci.c

Abstract:

    This module implements the routines to send and receive data over SMBus.

    This module implements the routines to handle a System Control Interrupt
    (SCI) from the ACPI logic block or external SMI.

    This module implements the routines to interface with the System Management
    Controller (SMC).

--*/

#include "halp.h"
#include "mcpxsmb.inc"
#include "mcpxacpi.inc"
#include <av.h>
#include <xconfig.h>
#include <ldr.h>

VOID
IdexCdRomTrayOpenNotification(
    VOID
    );

VOID
IdexDiskShutdownSystem(
    VOID
    );

//
// Local support.
//

BOOLEAN
HalpHandleNextSMCInterruptReason(
    NTSTATUS SMBusStatus
    );

VOID
HalpDpcForSMBusInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
HalpDpcForSMBusRetry(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
HalpDpcForSystemControlInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define the default number of retries allowed for a SMBus transaction.  Each
// retry is tried a millisecond apart.
//

#define HAL_DEFAULT_SMBUS_RETRIES           20

//
// Structure used to return information and signal completion of a SMBus
// transaction.
//

typedef struct _SMBUS_STATUS_BLOCK {
    NTSTATUS Status;
    ULONG DataValue;
    KEVENT CompletionEvent;
} SMBUS_STATUS_BLOCK, *PSMBUS_STATUS_BLOCK;

//
// Function prototype for an SMBus completion routine for SMC interrupt
// handling.
//

typedef
BOOLEAN
(*PSMBUS_COMPLETION_ROUTINE)(
    NTSTATUS SMBusStatus
    );

//
// Guards access to the SMBus.
//
INITIALIZED_KEVENT(HalpSMBusLock, SynchronizationEvent, TRUE);

//
// DPC object used to complete handling of an SMBus interrupt at DISPATCH_LEVEL.
//
INITIALIZED_KDPC(HalpSMBusInterruptDpc, HalpDpcForSMBusInterrupt, NULL);

//
// DPC object used to retry an SMBus transaction.
//
INITIALIZED_KDPC(HalpSMBusRetryDpc, HalpDpcForSMBusRetry, NULL);

//
// Timer object used to retry an SMBus transaction.
//
INITIALIZED_KTIMER(HalpSMBusRetryTimer, SynchronizationTimer);

//
// DPC object used to complete handling of an System Control Interrupt at
// DISPATCH_LEVEL.
//
INITIALIZED_KDPC(HalpSystemControlInterruptDpc, HalpDpcForSystemControlInterrupt, NULL);

//
// Stores the number of retries remaining for a SMBus transaction.
//
ULONG HalpSMBusRetries;

//
// Stores TRUE if a SMC interrupt was received while the SMBus was owned by a
// PASSIVE_LEVEL owner or the SMC interrupt state machine is already busy.
//
BOOLEAN HalpSMBusSMCInterruptPending;

//
// Stores the interrupt reason flags for the SMC interrupt in progress.
//
UCHAR HalpSMCInterruptReason;

//
// Points at the current SMBus status block.
//
PSMBUS_STATUS_BLOCK HalpSMBusStatusBlock;

//
// Points at the DPC completion routine for the current SMBus transaction.
//
PSMBUS_COMPLETION_ROUTINE HalpSMBusCompletionRoutine;

//
// Stores the SMC command code and data value to execute when the kernel is
// ready to reset or shutdown the system.
//
UCHAR HalpSMCResetOrShutdownCommandCode;
ULONG HalpSMCResetOrShutdownDataValue;

//
// Cached read of the tray state from the SMC.  This is initialized to an
// invalid value so that we know to go read the tray state from the SMC.
//
ULONG HalpTrayState = MAXULONG;

//
// Stores the number of times that the tray state has changed, which can be
// useful for detecting missed tray state changes.
//
ULONG HalpTrayStateChangeCount;

//
// Stores whether or not a tray eject in secure mode forces a reboot of the
// system or not.  This is FALSE for cold boots before we've started to load an
// Xbox executable.
//
DECLSPEC_STICKY BOOLEAN HalpTrayEjectRequiresReboot;

//
// Stores TRUE if a tray eject has occurred during the boot process.
//
BOOLEAN HalpTrayEjectDuringBootOccurred;

#ifdef DEVKIT
//
// Notification event for when a tray eject is complete.
//
INITIALIZED_KEVENT(HalpTrayEjectCompleteEvent, NotificationEvent, TRUE);
#endif

//
// Stores TRUE if HalInitiateShutdown has been called while the SMBus lock was
// owned.
//
BOOLEAN HalpShutdownRequestPending;

//
// Stores the AV pack that the console was booted with.
//
DECLSPEC_STICKY ULONG HalBootSMCVideoMode = SMC_VIDEO_MODE_NONE;

//
// Stores the flags that should be stored in the scratch register in addition to
// SMC_SCRATCH_TRAY_EJECT_PENDING when a tray eject occurs.
//
ULONG HalpSMCScratchRegister = SMC_SCRATCH_SHORT_ANIMATION;


//
// Grovel at private data in ntos\av.
//
extern ULONG AvpCapabilities;
extern ULONG AvpCurrentMode;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpInitializeSystemControlInterrupt)
#pragma alloc_text(INIT, HalpProcessSMCInitialState)
#pragma alloc_text(INIT, HalBlockIfNoAVPack)
#endif

VOID
HalpKickoffReadSMBus(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue
    )
/*++

Routine Description:

    This routine programs the SMBus controller for a "read byte" or "read word"
    transaction and starts the transaction.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    ReadWordValue - Specifies TRUE if 16-bits should be read, else FALSE if
        8-bits should be read.

Return Value:

    Status of operation.

--*/
{
    UCHAR ControlValue;

    //
    // Reset the number of retries for the SMBus transaction.
    //

    HalpSMBusRetries = HAL_DEFAULT_SMBUS_RETRIES;

    //
    // Setup the parameters for the SMBus transaction.
    //

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER,
        (UCHAR)(SlaveAddress | MCPX_ADDRESS_READ_CYCLE));
    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_COMMAND_REGISTER,
        CommandCode);

    //
    // Clear the the status register.
    //

    _outpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER,
        _inpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER));

    //
    // Initiate the read transaction.
    //

    if (ReadWordValue) {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_WORD;
    } else {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_BYTE;
    }

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER,
        ControlValue);
}

NTSTATUS
HalReadSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue,
    OUT ULONG *DataValue
    )
/*++

Routine Description:

    This routine submits a "read byte" or "read word" transaction over SMBus.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    ReadWordValue - Specifies TRUE if 16-bits should be read, else FALSE if
        8-bits should be read.

    DataValue - Specifies the location of the buffer to receive the data read
        from the SMBus.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SMBUS_STATUS_BLOCK SMBusStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Prevent thread suspension while we own the SMBus lock.
    //

    KeEnterCriticalRegion();

    //
    // Synchronize access to the SMBus by acquiring the SMBus lock.  Besides
    // other callers of this routine, we also need to synchronize with the SCI
    // handler: the SCI handler checks the SMBus lock at DPC level and either
    // takes ownership of the lock or else sets the HalpSMBusSMCInterruptPending
    // flag for delayed processing.
    //

    KeWaitForSingleObject(&HalpSMBusLock, Executive, KernelMode, FALSE, NULL);

    //
    // Initialize the completion event and set the global pointer to point at
    // our status block.
    //

    KeInitializeEvent(&SMBusStatusBlock.CompletionEvent, NotificationEvent, FALSE);

    HalpSMBusStatusBlock = &SMBusStatusBlock;

    //
    // Kickoff the SMBus read transaction.
    //

    HalpKickoffReadSMBus(SlaveAddress, CommandCode, ReadWordValue);

    //
    // Block for completion of the SMBus transaction and return the status.
    //

    KeWaitForSingleObject(&SMBusStatusBlock.CompletionEvent, Executive,
        KernelMode, FALSE, NULL);

    KeLeaveCriticalRegion();

    if (ReadWordValue) {
        *DataValue = SMBusStatusBlock.DataValue;
    } else {
        *DataValue = (UCHAR)SMBusStatusBlock.DataValue;
    }

    return SMBusStatusBlock.Status;
}

VOID
HalpKickoffWriteSMBus(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    )
/*++

Routine Description:

    This routine programs the SMBus controller for a "read byte" or "read word"
    transaction and starts the transaction.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    WriteWordValue - Specifies TRUE if 16-bits should be written, else FALSE
        if 8-bits should be written.

    DataValue - Specifies the data value to transmit over SMBus.

Return Value:

    None.

--*/
{
    UCHAR ControlValue;

    //
    // Reset the number of retries for the SMBus transaction.
    //

    HalpSMBusRetries = HAL_DEFAULT_SMBUS_RETRIES;

    //
    // Setup the parameters for the SMBus transaction.
    //

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER,
        (UCHAR)(SlaveAddress & ~MCPX_ADDRESS_READ_CYCLE));
    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_COMMAND_REGISTER,
        CommandCode);
    _outpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER,
        (USHORT)DataValue);

    //
    // Clear the the status register.
    //

    _outpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER,
        _inpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER));

    //
    // Initiate the write transaction.
    //

    if (WriteWordValue) {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_WORD;
    } else {
        ControlValue = MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START |
            MCPX_CONTROL_CYCLE_READ_WRITE_BYTE;
    }

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER,
        ControlValue);
}

NTSTATUS
HalWriteSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    )
/*++

Routine Description:

    This routine submits a "write byte" or "write word" transaction over SMBus.

Arguments:

    SlaveAddress - Specifies the slave address of the SMBus device to access.

    CommandCode - Specifies the command field to pass during as part of the host
        cycle.

    WriteWordValue - Specifies TRUE if 16-bits should be written, else FALSE
        if 8-bits should be written.

    DataValue - Specifies the data value to transmit over SMBus.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SMBUS_STATUS_BLOCK SMBusStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Prevent thread suspension while we own the SMBus lock.
    //

    KeEnterCriticalRegion();

    //
    // Synchronize access to the SMBus by acquiring the SMBus lock.  Besides
    // other callers of this routine, we also need to synchronize with the SCI
    // handler: the SCI handler checks the SMBus lock at DPC level and either
    // takes ownership of the lock or else sets the HalpSMBusSMCInterruptPending
    // flag for delayed processing.
    //

    KeWaitForSingleObject(&HalpSMBusLock, Executive, KernelMode, FALSE, NULL);

    //
    // Initialize the completion event and set the global pointer to point at
    // our status block.
    //

    KeInitializeEvent(&SMBusStatusBlock.CompletionEvent, NotificationEvent, FALSE);

    HalpSMBusStatusBlock = &SMBusStatusBlock;

    //
    // Kickoff the SMBus write transaction.
    //

    HalpKickoffWriteSMBus(SlaveAddress, CommandCode, WriteWordValue, DataValue);

    //
    // Block for completion of the SMBus transaction and return the status.
    //

    KeWaitForSingleObject(&SMBusStatusBlock.CompletionEvent, Executive,
        KernelMode, FALSE, NULL);

    KeLeaveCriticalRegion();

    return SMBusStatusBlock.Status;
}

BOOLEAN
HalpWriteSMCResetOrShutdownComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after sending the final reset or shutdown command
    to the SMC.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to write out the reset or shutdown command, try repeating
    // the command.
    //

    if (!NT_SUCCESS(SMBusStatus)) {

        HalpSMBusCompletionRoutine = HalpWriteSMCResetOrShutdownComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, HalpSMCResetOrShutdownCommandCode,
            FALSE, HalpSMCResetOrShutdownDataValue);

        return TRUE;
    }

    HalHaltSystem();

    return TRUE;
}

VOID
HalMustCompletePacketsFinished(
    VOID
    )
{
    ULONG DiskShutdownStartTickCount;

    ASSERT(IoPendingMustCompletePackets == 0);

    //
    // Check if the SMBus is busy.  If not, then we can attempt to shutdown now.
    // Otherwise, we'll wait for the SMBus completion routine to make the call.
    //

    if (HalpSMBusCompletionRoutine != NULL) {
        return;
    }

    //
    // If the command that we're sending is a shutdown command, then flush and
    // spindown the disk device.  This can take awhile, so pretend like we're
    // not in a DPC in order to avoid triggering the "DPC running too long"
    // debug code.
    //

    if (((HalpSMCResetOrShutdownCommandCode == SMC_COMMAND_OS_RESUME) &&
        (HalpSMCResetOrShutdownDataValue == SMC_OS_RESUME_SHUTDOWN_COMPLETE)) ||
        ((HalpSMCResetOrShutdownCommandCode == SMC_COMMAND_RESET) &&
        (HalpSMCResetOrShutdownDataValue == SMC_RESET_ASSERT_SHUTDOWN))) {

        KeGetCurrentPrcb()->DpcRoutineActive = FALSE;

        DiskShutdownStartTickCount = KeQueryTickCount();

        IdexDiskShutdownSystem();

        //
        // Older builds of the SMC have a synchronization bug where we can't
        // send a "shutdown in progress" notification followed shortly by a
        // "shutdown complete" notification: the SMC fails to see the second
        // notification and we take the full SMC timeout to finally shutdown.
        // To workaround the problem, we need to add a delay between the
        // notifications.  The above disk shutdown call will give us most of the
        // delay we need, but some drives respond to the shutdown commands
        // quickly enough that we need to spin here to close the window where
        // we're exposed to the SMC bug.
        //

        while ((KeQueryTickCount() - DiskShutdownStartTickCount) < 125);

    } else {

#ifdef DEVKIT
        //
        // Notify the debugger that we're resetting.
        //

        DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
#endif
    }

    //
    // Write the reset or shutdown command to the SMC.
    //

    HalpSMBusCompletionRoutine = HalpWriteSMCResetOrShutdownComplete;

    HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, HalpSMCResetOrShutdownCommandCode,
        FALSE, HalpSMCResetOrShutdownDataValue);
}

BOOLEAN
HalpWriteSMCAudioClampComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is called from the common reset and shutdown sequence after
    clamping the audio output.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // Clear the completion routine so that HalMustCompletePacketsFinished knows
    // that we aren't in the middle of an SMBus transaction.
    //

    HalpSMBusCompletionRoutine = NULL;

    //
    // Disable the video DACs using one of the GPIO pins.
    //

    _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xD3, 0x05);

    //
    // Now that we've disabled audio and video, check if there are any pending
    // must complete I/O request packets.  If not, then we can attempt to
    // shutdown now.  Otherwise, exit and wait for the I/O manager to call us
    // back.
    //

    if (IoPendingMustCompletePackets == 0) {
        HalMustCompletePacketsFinished();
    }

    //
    // Return TRUE so that we continue to own the SMBus even though we may not
    // have started a transaction.
    //

    return TRUE;
}

DECLSPEC_NORETURN
VOID
HalpCommonResetOrShutdown(
    VOID
    )
/*++

Routine Description:

    This routine is called to start the common reset and shutdown sequence.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(KeIsExecutingDpc());

    //
    // There's at least one device that's busy processing I/O.  We're going to
    // need to block for that I/O to complete, but we want to disable audio and
    // video as quickly as possible.
    //
    // Disable the audio output by turning on the SMC's audio clamp.
    //

    HalpSMBusCompletionRoutine = HalpWriteSMCAudioClampComplete;

    HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_AUDIO_CLAMP, FALSE,
        SMC_AUDIO_CLAMP_CLAMP);

    //
    // Enter an infinite DPC processing loop to prevent any more title code from
    // running.  Note that we may be nested inside KeRetireDpcListLoop, but that
    // routine is reentrant and we aren't consuming much of the DPC stack.
    //

    KeRetireDpcListLoop();
}

BOOLEAN
HalpCommonResetOrShutdownComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after an SMBus transaction that should be followed
    by a reset or shutdown.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    HalpCommonResetOrShutdown();

    return TRUE;
}

BOOLEAN
HalpReadSMCVideoModeComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to read the video mode
    from the SMC has completed.  This is called as a result of the SMC detecting
    that a new AV pack has been attached.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    ULONG VideoMode;

    //
    // If we failed to read the video mode from the SMC, then we'll leave the
    // video DACs disabled.  The user can replug in the AV pack to attempt to
    // retry this operation.
    //

    if (!NT_SUCCESS(SMBusStatus)) {
        return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
    }

    //
    // Read the video mode data from the SMBus controller.
    //

    VideoMode = (UCHAR)_inp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER);
    VideoMode = (VideoMode & SMC_VIDEO_MODE_VMODE_MASK);

    //
    // If no AV pack is attached, then treat this as a spurious interrupt.
    //

    if (VideoMode == SMC_VIDEO_MODE_NONE) {
        return HalpHandleNextSMCInterruptReason(SMBusStatus);
    }

    //
    // If the video mode doesn't match the video mode that the title was started
    // in, then reboot the system.
    //

    if (VideoMode != HalBootSMCVideoMode) {

        //
        // Setup the SMC command code and data value that should be sent to the
        // SMC when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
        HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_RESET;

        HalpCommonResetOrShutdown();
    }

    //
    // If the capabilities haven't been set yet, then the system isn't using
    // video yet, so we don't need to do anything.
    //

    if (AvpCapabilities == 0) {
        return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
    }

    //
    // The video mode matches the video mode that the title was started in.
    // Enable the video DACs.  If this fails for some unexpected reason, the
    // user can replug in the AV pack to attempt to retry this operation.
    //

    HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

    HalpKickoffWriteSMBus(TV_ENCODER_ID, 0xBA, FALSE,
        0x20 | ((AvpCurrentMode & 0x0F000000) >> 24));

    return TRUE;
}

BOOLEAN
HalpTrayEjectWriteSMCNonSecureComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to write that the system
    should move to the non-secure state after a tray eject event has occurred
    during a boot cycle.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to switch to non-secure mode, then we can't eject the tray
    // without causing a reboot.  Ignore the user's press of the tray eject
    // button and make them hit it again in order to retry the state machine.
    //

    if (!NT_SUCCESS(SMBusStatus)) {
        return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
    }

    //
    // Now that we've switch to non-secure mode, go ahead and eject the tray.
    //

    HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

    HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
        FALSE, SMC_DVD_TRAY_OPERATION_OPEN);

    return TRUE;
}

BOOLEAN
HalpTrayEjectWriteSMCResumeComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to write that the system
    should resume after a tray eject event has occurred.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to write out the OS resume response, then all we can really
    // do is try the operation again.  The SMC will reboot us if it doesn't see
    // a response in a short period of time, so there's no point in trying to
    // advance the state machine.
    //

    if (!NT_SUCCESS(SMBusStatus)) {

        HalpSMBusCompletionRoutine = HalpTrayEjectWriteSMCResumeComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
            FALSE, SMC_OS_RESUME_RESUME);

        return TRUE;
    }

    //
    // Check if we're in non-secure mode where a tray open event doesn't force a
    // reboot (e.g., the dashboard scenerio).
    //
    // Also check if we're cold-booting and haven't reached the point where we
    // require a reboot in order to gracefully handle a tray eject.
    //

    if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) {

        HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
            FALSE, SMC_DVD_TRAY_OPERATION_OPEN);

    } else if (!HalpTrayEjectRequiresReboot) {

        ASSERT(!KeHasQuickBooted);

        //
        // This tray eject is happening asynchronously to the rest of the boot
        // process.  Other pieces of the kernel needed to know we've ejected the
        // tray and switched to non-secure mode.
        //

        HalpTrayEjectDuringBootOccurred = TRUE;

        //
        // Switch to non-secure mode so that we can eject the tray without
        // rebooting.
        //

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE | XBOX_BOOTFLAG_TRAYEJECT;

        HalpSMBusCompletionRoutine = HalpTrayEjectWriteSMCNonSecureComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, FALSE,
            SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

    } else {

        //
        // Setup the SMC command code and data value that should be sent to the
        // SMC when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
        HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_RESET;

        //
        // Write out to the scratch register that a tray eject is pending.
        //

        HalpSMBusCompletionRoutine = HalpCommonResetOrShutdownComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
            FALSE, SMC_SCRATCH_TRAY_EJECT_PENDING | HalpSMCScratchRegister);
    }

    return TRUE;
}

BOOLEAN
HalpTrayOpenWriteSMCResumeComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to write that the system
    should resume after a tray open event has occurred.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to write out the OS resume response, then all we can really
    // do is try the operation again.  The SMC will reboot us if it doesn't see
    // a response in a short period of time, so there's no point in trying to
    // advance the state machine.
    //

    if (!NT_SUCCESS(SMBusStatus)) {

        HalpSMBusCompletionRoutine = HalpTrayOpenWriteSMCResumeComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
            FALSE, SMC_OS_RESUME_RESUME);

        return TRUE;
    }

    //
    // If we got into this routine and we're not already set for non-secure
    // mode, then we must have received a tray open before we reached a point
    // where a tray eject requires a reboot of the system.  Switch into
    // non-secure mode which also forces a launch of the dashboard.
    //

    if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) == 0) {

        ASSERT(!HalpTrayEjectRequiresReboot);

        //
        // This tray eject is happening asynchronously to the rest of the boot
        // process.  Other pieces of the kernel needed to know we've ejected the
        // tray and switched to non-secure mode.
        //

        HalpTrayEjectDuringBootOccurred = TRUE;

        //
        // Switch to non-secure mode which will also force us to boot the
        // dashboard.  Note that the SMC should be booting in non-secure mode
        // already, but explicitly setting the SMC to non-secure mode mimics
        // other control paths more closely.
        //

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, FALSE,
            SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

        HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

        return TRUE;
    }

    //
    // Handle the next interrupt reason flag.
    //

    return HalpHandleNextSMCInterruptReason(STATUS_SUCCESS);
}

BOOLEAN
HalpHandleNextSMCInterruptReason(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked to handle the next flag in the pending interrupt
    reason mask.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // Check if the user has hit the power button.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_SHUTDOWN) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_SHUTDOWN;

        //
        // Setup the SMC command code and data value that should be sent to the
        // SMC when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_OS_RESUME;
        HalpSMCResetOrShutdownDataValue = SMC_OS_RESUME_SHUTDOWN_COMPLETE;

        //
        // Notify the SMC that we're still alive and handling this interrupt by
        // telling it that we we're in the middle of shutting down the system.
        //

        HalpSMBusCompletionRoutine = HalpCommonResetOrShutdownComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME, FALSE,
            SMC_OS_RESUME_SHUTDOWN_IN_PROGRESS);

        //
        // Enter an infinite DPC processing loop to prevent any more title code
        // from running.
        //

        KeRetireDpcListLoop();
    }

    //
    // Check if an AV pack has been disconnected.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_NO_AV_PACK) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_NO_AV_PACK;

        //
        // If the console is configured to run manufacturing conent, then do
        // nothing.  Manufacturing test wants full control of the DACs.
        //

        if ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0) {

            //
            // Disable the video DACs and return to this routine to handle the
            // next interrupt reason flag.
            //

            HalpSMBusCompletionRoutine = HalpHandleNextSMCInterruptReason;

            HalpKickoffWriteSMBus(TV_ENCODER_ID, 0xBA, FALSE, 0x3F);

            return TRUE;
        }
    }

    //
    // Check if an AV pack has been connected.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_NEW_AV_PACK) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_NEW_AV_PACK;

        //
        // If the console is configured to run manufacturing content, then do
        // nothing.  Manufacturing test wants full control of the DACs.
        //

        if ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0) {

            //
            // Read the video mode from the SMC.
            //

            HalpSMBusCompletionRoutine = HalpReadSMCVideoModeComplete;

            HalpKickoffReadSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_VIDEO_MODE, FALSE);

            return TRUE;
        }
    }

    //
    // Check if the user has pressed the tray eject button.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_EJECT) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_EJECT;

#ifdef DEVKIT
        //
        // Indicate the a tray eject is in progress.
        //

        KeClearEvent(&HalpTrayEjectCompleteEvent);
#endif

        //
        // Increment the number of tray state changes and set the cached tray
        // state to the unloading state.  We do this before actually ejecting
        // the media so that the dashboard sees an immediate change as it's
        // polling the SMC tray state.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = SMC_TRAY_STATE_UNLOADING;

        //
        // Notify the SMC that we're still alive and handling this interrupt by
        // telling it that we want to resume.
        //

        HalpSMBusCompletionRoutine = HalpTrayEjectWriteSMCResumeComplete;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
            FALSE, SMC_OS_RESUME_RESUME);

        return TRUE;
    }

    //
    // Check if the user has opened the tray.  Note that although we control the
    // tray eject button above, the user may attempt to force open the tray
    // through mechanical means.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_OPENED) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_OPENED;

#ifdef DEVKIT
        //
        // Indicate the a tray eject is complete.
        //

        KeSetEvent(&HalpTrayEjectCompleteEvent, EVENT_INCREMENT, FALSE);
#endif

        //
        // Increment the number of tray state changes and set the cached tray
        // state to an invalid state.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = MAXULONG;

        //
        // Notify the IDE driver that the tray has opened so that any state can
        // be reset.
        //

        IdexCdRomTrayOpenNotification();

        //
        // Reset the title identifier that the Xbox executable loader allows to
        // be loaded from media.
        //

        XeCdRomMediaTitleID = 0;

        //
        // Check if we're in non-secure mode where a tray open event doesn't
        // force a reboot (e.g., the dashboard scenerio).  If we see a tray open
        // event before we're at a point where a tray eject requires a reboot,
        // then pretend like this tray open is really a tray eject.
        //

        if (((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) ||
            !HalpTrayEjectRequiresReboot) {

            //
            // Notify the SMC that we're still alive and handling this interrupt
            // by telling it that we want to resume.
            //

            HalpSMBusCompletionRoutine = HalpTrayOpenWriteSMCResumeComplete;

            HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
                FALSE, SMC_OS_RESUME_RESUME);

            return TRUE;

        } else {

            //
            // Setup the SMC command code and data value that should be sent to
            // the SMC when the shutdown is complete.
            //

            HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_OS_RESUME;
            HalpSMCResetOrShutdownDataValue = SMC_OS_RESUME_REBOOT;

            HalpCommonResetOrShutdown();
        }
    }

    //
    // Check if the user has closed the tray.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_CLOSED) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_CLOSED;

        //
        // Increment the number of tray state changes and set the cached tray
        // state to the closed state.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = SMC_TRAY_STATE_CLOSED;
    }

    //
    // Check if the drive has finished media detection.
    //

    if ((HalpSMCInterruptReason & SMC_INTERRUPT_REASON_TRAY_DETECTED) != 0) {

        HalpSMCInterruptReason &= ~SMC_INTERRUPT_REASON_TRAY_DETECTED;

        //
        // Increment the number of tray state changes and set the cached tray
        // state to an invalid state.  The SMC needs to be queried to see if
        // the drive has valid media or not.
        //

        HalpTrayStateChangeCount++;
        HalpTrayState = MAXULONG;
    }

    return FALSE;
}

BOOLEAN
HalpReadSMCInterruptReasonComplete(
    NTSTATUS SMBusStatus
    )
/*++

Routine Description:

    This routine is invoked after the SMBus transaction to read the interrupt
    reason from the SMC has completed.

Arguments:

    SMBusStatus - Specifies the status of the last SMBus transaction.

Return Value:

    Returns TRUE if the SMC interrupt handling state machine has more work to
    do, else FALSE.

--*/
{
    //
    // If we failed to read the interrupt reason from the SMC, then there's not
    // much we can do so bail out of the SMC interrupt handling.
    //

    if (!NT_SUCCESS(SMBusStatus)) {
        return FALSE;
    }

    //
    // Read the interrupt reason data from the SMBus controller.
    //

    HalpSMCInterruptReason =
        (UCHAR)_inp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER);

    //
    // Start processing the next flag in the interrupt reason.
    //

    return HalpHandleNextSMCInterruptReason(SMBusStatus);
}

VOID
HalpReadSMCInterruptReason(
    VOID
    )
/*++

Routine Description:

    This routine is the starting point for the SMC interrupt handling state
    machine.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Read the interrupt reason from the SMC.
    //

    HalpSMBusCompletionRoutine = HalpReadSMCInterruptReasonComplete;

    HalpKickoffReadSMBus(SMC_SLAVE_ADDRESS, SMC_COMMAND_INTERRUPT_REASON, FALSE);
}

VOID
HalpReleaseSMBusLock(
    VOID
    )
/*++

Routine Description:

    This routine releases the SMBus lock.  This routine must be called at
    DISPATCH_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (HalpSMBusSMCInterruptPending) {

        //
        // The SMC has generated an interrupt but the SMBus was busy.  Enter the
        // SMC interrupt handling state machine.
        //

        HalpSMBusSMCInterruptPending = FALSE;

        HalpReadSMCInterruptReason();

    } else if (HalpShutdownRequestPending) {

        //
        // HalInitiateShutdown was called while the SMBus was busy.  Call that
        // routine now that the lock is available.
        //

        HalpShutdownRequestPending = FALSE;

        //
        // Setup the SMC command code and data value that should be sent to the SMC
        // when the shutdown is complete.
        //

        HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
        HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_SHUTDOWN;

        HalpCommonResetOrShutdown();

    } else {

        //
        // Release the SMBus lock on behalf of the SMBus service or the SMC
        // interrupt handling state machine.
        //

        KeSetEvent(&HalpSMBusLock, 0, FALSE);
    }
}

VOID
HalpDpcForSMBusInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered when the interrupt service routine
    has work that must be executed at DISPATCH_LEVEL.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG StatusValue;
    LARGE_INTEGER TimerDueTime;

    StatusValue = PtrToUlong(SystemArgument1);

    //
    // Determine if there was a SMBus collision or protocol error.  If so and we
    // haven't exceeded our retry count, then delay and retry the transaction.
    //

    if (StatusValue & (MCPX_STATUS_COLLISION | MCPX_STATUS_PROTOCOL_ERROR)) {

        if (HalpSMBusRetries > 0) {

            //
            // Retry the transaction in two milliseconds.
            //

            TimerDueTime.QuadPart = -20000;

            KeSetTimer(&HalpSMBusRetryTimer, TimerDueTime, &HalpSMBusRetryDpc);

            HalpSMBusRetries--;

            return;
        }

        HalDbgPrint(("HAL: exceeded retry count for SMBus transaction.\n"));
    }

    //
    // Determine what status to return to the caller of the SMBus service.
    //

    if (StatusValue & MCPX_STATUS_HOST_CYCLE_COMPLETE) {
        status = STATUS_SUCCESS;
    } else if (StatusValue & MCPX_STATUS_TIMEOUT_ERROR) {
        HalDbgPrint(("HAL: SMBus transaction timed out.\n"));
        status = STATUS_IO_TIMEOUT;
    } else {
        HalDbgPrint(("HAL: SMBus transaction errored out.\n"));
        status = STATUS_IO_DEVICE_ERROR;
    }

    if (HalpSMBusCompletionRoutine != NULL) {

        //
        // Invoke the SMBus completion routine and bail out if the completion
        // routine indicates that there's still more work to do.
        //

        if (HalpSMBusCompletionRoutine(status)) {
            return;
        }

        HalpSMBusCompletionRoutine = NULL;

    } else if (HalpSMBusStatusBlock != NULL) {

        //
        // Return the status and the current value of the data register to the
        // SMBus service.
        //

        HalpSMBusStatusBlock->Status = status;
        HalpSMBusStatusBlock->DataValue =
            _inpw(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER);

        //
        // Signal completion of the SMBus transaction.
        //

        KeSetEvent(&HalpSMBusStatusBlock->CompletionEvent, 0, FALSE);

        HalpSMBusStatusBlock = NULL;

    } else {
        HalDbgPrint(("HAL: Spurious SMBus interrupt.\n"));
    }

    //
    // Release the SMBus lock.
    //

    HalpReleaseSMBusLock();
}

VOID
HalpDpcForSMBusRetry(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered by the SMBus retry timer.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    //
    // The SMBus controller registers are already setup for the transaction;
    // the host start bit just needs to be set again.
    //

    _outp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER,
        _inp(XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_CONTROL_REGISTER) |
        MCPX_CONTROL_INTERRUPT_ENABLE | MCPX_CONTROL_HOST_START);
}

VOID
HalpDpcForSystemControlInterrupt(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered when the interrupt service routine
    has work that must be executed at DISPATCH_LEVEL.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    //
    // Test if the SMBus lock is currently owned.  If so, set a flag so that
    // when the SMBus is available, we can take control.
    //

    if (!KeReadStateEvent(&HalpSMBusLock)) {
        HalpSMBusSMCInterruptPending = TRUE;
        return;
    }

    //
    // The SMBus lock is currently unowned.  Clear the event so that other
    // PASSIVE_LEVEL callers will block and so that this routine will not be
    // reentered.
    //

    KeClearEvent(&HalpSMBusLock);

    //
    // Enter the SMC interrupt handling state machine.
    //

    HalpReadSMCInterruptReason();
}

VOID
HalpInitializeSystemControlInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine programs the ACPI management block to deliver all System
    Management Interrupts (SMIs) as a System Control Interrupts (SCIs) and
    enables all SCI sources that we're interested in using.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Select SCI generation instead of SMI generation for ACPI events.
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_CONTROL_REGISTER,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_CONTROL_REGISTER) |
        PM1_SCI_ENABLE);

    //
    // Enable external SMIs (now routed as a system control interrupt).
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GPE0_ENABLE_REGISTER,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GPE0_ENABLE_REGISTER) |
        GPE0_EXTSMI_ENABLE);

    //
    // Enable the ACPI timer carry overflow interrupt.
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_ENABLE_REGISTER,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_PM1_ENABLE_REGISTER) |
        PM1_TIMER_ENABLE);

    //
    // Enable interrupts from the system management block.
    //

    _outpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GLOBAL_SMI_CONTROL,
        _inpw(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + MCPX_ACPI_GLOBAL_SMI_CONTROL) |
        GPE0_SMI_ENABLE);
}

VOID
HalpProcessSMCInitialState(
    VOID
    )
/*++

Routine Description:

    This routine processes the initial state of the SMC at boot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG VideoMode;
    BOOLEAN TrayEjectPending;
#ifdef DEVKIT
    ULONG Index;
    ULONG FirmwareRevision[3];
#endif
    ULONG InterruptReason;
    ULONG Scratch;

    TrayEjectPending = FALSE;

    //
    // Initialize the boot AV pack.
    //

    if (NT_SUCCESS(HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_VIDEO_MODE,
        &VideoMode))) {
        HalBootSMCVideoMode = (VideoMode & SMC_VIDEO_MODE_VMODE_MASK);
    }

#ifdef DEVKIT
    //
    // Read the SMC firmware revision and print it to the debugger.
    //

    for (Index = 0; Index < 3; Index++) {
        HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_FIRMWARE_REVISION,
            &FirmwareRevision[Index]);
    }

    HalDbgPrint(("HAL: SMC version %c%c%c\n", FirmwareRevision[0],
        FirmwareRevision[1], FirmwareRevision[2]));
#endif

    //
    // Read the interrupt reason to see if a DVD tray eject is pending, which
    // will happen if the user powers on the system by hitting the tray eject
    // button.
    //

    status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_INTERRUPT_REASON,
        &InterruptReason);

    if (NT_SUCCESS(status)) {

        if ((InterruptReason & SMC_INTERRUPT_REASON_TRAY_EJECT) != 0) {
            TrayEjectPending = TRUE;
        }

        //
        // If we happen to see a pending tray open interrupt, then tell the SMC
        // that we're resuming.  This should only happen when a DEVKIT kernel in
        // ROM loads a kernel from the hard disk after ejecting the tray.
        //
        // Also, a tray eject interrupt was pending at boot, then tell the SMC
        // that we're resuming so that the SMC knows that we're alive to handle
        // the interrupt.
        //

        if (((InterruptReason & SMC_INTERRUPT_REASON_TRAY_OPENED) != 0) ||
            ((InterruptReason & SMC_INTERRUPT_REASON_TRAY_EJECT) != 0)) {
            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_RESUME,
                SMC_OS_RESUME_RESUME);
        }
    }

    //
    // Read the our SMC scratch register to see if we're rebooting because the
    // user pressed the tray eject button.  The scratch register is cleared
    // across power cycles, but we need to clear it ourselves across cold
    // reboots.
    //

    status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
        &Scratch);

    if (NT_SUCCESS(status)) {

        if ((Scratch & SMC_SCRATCH_TRAY_EJECT_PENDING) != 0) {
            TrayEjectPending = TRUE;
        }
    }

    //
    // Always write out the following flags to the scratch register.  This has
    // the effect of clearing the tray eject request that we might have seen
    // above and also telling future cold boots of the kernel that only the
    // short animation needs to be displayed because the drives are already
    // spun up.
    //

    HalWriteSMCScratchRegister(SMC_SCRATCH_SHORT_ANIMATION);

    //
    // Propagate flags from the SMC scratch register to the boot flags.
    //

    if ((Scratch & SMC_SCRATCH_SHORT_ANIMATION) != 0) {
        XboxBootFlags |= XBOX_BOOTFLAG_SHORTANIMATION;
    }

    if ((Scratch & SMC_SCRATCH_DISPLAY_FATAL_ERROR) != 0) {
        XboxBootFlags |= XBOX_BOOTFLAG_DISPLAYFATALERROR;
    }

    if ((Scratch & SMC_SCRATCH_DASHBOARD_BOOT) != 0) {
        XboxBootFlags |= XBOX_BOOTFLAG_DASHBOARDBOOT;
    }

    //
    // If we've determined that we need to do a tray eject, then we're going to
    // force a boot into the dashboard.  The SMC needs to go into non-secure
    // mode now, so that the tray open event doesn't require us to reboot (which
    // would cause a IDE bus reset that would close the tray).
    //

    if (TrayEjectPending) {

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE | XBOX_BOOTFLAG_TRAYEJECT;

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_DVD_TRAY_OPERATION,
            SMC_DVD_TRAY_OPERATION_OPEN);

        HalpTrayState = SMC_TRAY_STATE_UNLOADING;
    }
}

VOID
HalBlockIfNoAVPack(
    VOID
    )
/*++

Routine Description:

    This routine blocks forever if no AV pack is attached at boot.  If an AV
    pack is attached, then this routine returns immediately.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LARGE_INTEGER Interval;

    if ((AvSMCVideoModeToAVPack(HalBootSMCVideoMode) == AV_PACK_NONE) &&
        ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0)) {

        //
        // Clear the scratch register so that when we do reboot, we see the full
        // boot animation.
        //

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH, 0);

        //
        // Block for several minutes to allow the user a chance to attach an AV
        // pack.  If no AV pack is attached after that time, then attempt to
        // shutdown the system.
        //

        for (;;) {

            Interval.QuadPart = -5 * 60000 * 10000i64;

            HalDbgPrint(("HAL: no AV pack detected; blocking for AV pack attachment.\n"));

            KeDelayExecutionThread(KernelMode, FALSE, &Interval);

            HalDbgPrint(("HAL: no AV pack detected; turning system off.\n"));

            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET,
                SMC_RESET_ASSERT_SHUTDOWN);
        }
    }
}

BOOLEAN
HalEnableTrayEjectRequiresReboot(
    IN BOOLEAN EnterNonSecureMode
    )
/*++

Routine Description:

    This routine sets the flag that indicates that a tray eject will require a
    reboot.

Arguments:

    EnterNonSecureMode - Specifies TRUE if the console should be switched to
        non-secure mode before returning from this routine.

Return Value:

    Returns TRUE if a tray eject has occurred before setting the flag.

--*/
{
    KIRQL OldIrql;
    SMBUS_STATUS_BLOCK SMBusStatusBlock;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Prevent thread suspension while we own the SMBus lock.
    //

    KeEnterCriticalRegion();

    //
    // Synchronize with the SCI handler which acquires the SMBus lock for the
    // entire handling of an SCI.  This ensures that we're not in the middle of
    // handling a tray eject interrupt while we're in this code.  Also, we
    // require the lock below in order to switch to non-secure mode if
    // requested.
    //

    KeWaitForSingleObject(&HalpSMBusLock, Executive, KernelMode, FALSE, NULL);

    //
    // Set the flag that any future tray eject interrupts will require a reboot
    // in order to do the eject work.
    //

    HalpTrayEjectRequiresReboot = TRUE;

    //
    // Check if the caller wants us to switch to non-secure mode and that we're
    // not already in non-secure mode.  We can only switch to non-secure mode if
    // this is a cold boot.
    //

    if (!KeHasQuickBooted && EnterNonSecureMode &&
        ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) == 0)) {

        //
        // Initialize the completion event and set the global pointer to point at
        // our status block.
        //

        KeInitializeEvent(&SMBusStatusBlock.CompletionEvent, NotificationEvent,
            FALSE);

        HalpSMBusStatusBlock = &SMBusStatusBlock;

        //
        // Switch to non-secure mode.
        //

        XboxBootFlags |= XBOX_BOOTFLAG_NONSECUREMODE;

        HalpKickoffWriteSMBus(SMC_SLAVE_ADDRESS,
            SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN, FALSE,
            SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE);

        //
        // Block for completion of the SMBus transaction.
        //

        KeWaitForSingleObject(&SMBusStatusBlock.CompletionEvent, Executive,
            KernelMode, FALSE, NULL);

    } else {

        //
        // Release the SMBus lock.  The lock release must be called at DPC level
        // in order to properly synchronize with the SCI handler.
        //

        OldIrql = KeRaiseIrqlToDpcLevel();

        HalpReleaseSMBusLock();

        KeLowerIrql(OldIrql);
    }

    KeLeaveCriticalRegion();

    //
    // Return to the caller whether or not a tray eject has occurred before the
    // above flag was set.
    //

    return HalpTrayEjectDuringBootOccurred;
}

NTSTATUS
HalReadSMCTrayState(
    OUT PULONG TrayState,
    OUT PULONG TrayStateChangeCount OPTIONAL
    )
/*++

Routine Description:

    This routine reads the SMC tray state.  The SMC tray state is cached
    globally and invalidated when a tray open or close event occurs.  Callers
    that use this routine instead of directly polling the SMC can avoid
    generating unnecessary SMBus traffic.

Arguments:

    TrayState - Specifies the buffer to receive the tray state.

    TrayStateChangeCount - Specifies the optional buffer to receive the number
        of times that the tray has been opened and closed.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    KIRQL OldIrql;
    ULONG LocalTrayState;
    ULONG LocalTrayStateChangeCount;

    //
    // Capture the contents of the tray state globals.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    LocalTrayState = HalpTrayState;
    LocalTrayStateChangeCount = HalpTrayStateChangeCount;

    KeLowerIrql(OldIrql);

    //
    // Check if the tray state is either uninitialized or has been cleared by
    // the SMC interrupt handler because of a tray state change.
    //

    if (LocalTrayState == MAXULONG) {

        //
        // Read the tray state from the SMC.
        //

        status = HalReadSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_TRAY_STATE,
            &LocalTrayState);

        if (NT_SUCCESS(status)) {

            //
            // Mask out the bits not related to the tray state and normalize the
            // tray state.  Because the SMC only interrupts us when media is
            // detected, when the drive is empty, or when the tray is opening,
            // we'll only return this set of states.  Most callers don't care
            // about the other transition states anyway.
            //

            LocalTrayState &= SMC_TRAY_STATE_STATE_MASK;

            switch (LocalTrayState) {

                case SMC_TRAY_STATE_NO_MEDIA:
                case SMC_TRAY_STATE_MEDIA_DETECT:
                    break;

                default:
                    LocalTrayState = SMC_TRAY_STATE_OPEN;
                    break;
            }

            //
            // If the tray state change count hasn't changed since we performed
            // the above read, then cache the tray state back in the global.
            //

            OldIrql = KeRaiseIrqlToDpcLevel();

            if (LocalTrayStateChangeCount == HalpTrayStateChangeCount) {
                HalpTrayState = LocalTrayState;
            }

            KeLowerIrql(OldIrql);
        }

    } else {
        status = STATUS_SUCCESS;
    }

    //
    // Return the results to the caller.
    //

    *TrayState = LocalTrayState;

    if (TrayStateChangeCount != NULL) {
        *TrayStateChangeCount = LocalTrayStateChangeCount;
    }

    return status;
}

VOID
HalWriteSMCLEDStates(
    IN ULONG LEDStates
    )
/*++

Routine Description:

    This routine writes the supplied LED states to the SMC and enables the LED
    override so that the LEDs show the requested state.

Arguments:

    LEDStates - Specifies the LED states to send to the SMC.

Return Value:

    None.

--*/
{
    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_LED_STATES, LEDStates);

    HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_LED_OVERRIDE,
        SMC_LED_OVERRIDE_USE_REQUESTED_LED_STATES);
}

BOOLEAN
HalIsResetOrShutdownPending(
    VOID
    )
/*++

Routine Description:

    This routine returns whether or not the console is in the middle of a reset
    or shutdown sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the console is in the middle of a reset or shutdown
    sequence.

--*/
{
    //
    // If the SMC reset or shutdown code has been filled in, then we're in the
    // middle of a reset or shutdown sequence.  The SMC doesn't support any
    // commands with a value of zero.
    //

    return (BOOLEAN)(HalpSMCResetOrShutdownCommandCode != 0);
}

VOID
HalInitiateShutdown(
    VOID
    )
/*++

Routine Description:

    This routine initiates a shutdown operation.

    Note that this routine may return if the SMBus lock is already owned.  The
    shutdown will start as soon as the SMBus lock is available.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    HalDbgPrint(("HalInitiateShutdown called.\n"));

    //
    // Test if the SMBus lock is currently owned.  If so, set a flag so that
    // when the SMBus is available, we can take control.
    //

    if (!KeReadStateEvent(&HalpSMBusLock)) {
        HalpShutdownRequestPending = TRUE;
        return;
    }

    //
    // The SMBus lock is currently unowned.  Clear the event so that other
    // PASSIVE_LEVEL callers will block and so that this routine will not be
    // reentered.
    //

    KeClearEvent(&HalpSMBusLock);

    //
    // Setup the SMC command code and data value that should be sent to the SMC
    // when the shutdown is complete.
    //

    HalpSMCResetOrShutdownCommandCode = SMC_COMMAND_RESET;
    HalpSMCResetOrShutdownDataValue = SMC_RESET_ASSERT_SHUTDOWN;

    HalpCommonResetOrShutdown();
}

NTSTATUS
HalWriteSMCScratchRegister(
    IN ULONG ScratchRegister
    )
/*++

Routine Description:

    This routine initiates a shutdown operation.

    Note that this routine may return if the SMBus lock is already owned.  The
    shutdown will start as soon as the SMBus lock is available.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;

    //
    // Remember the value that we're writing out for the scratch register.  This
    // is needed when we're ejecting the tray: this value is OR'ed with
    // SMC_SCRATCH_TRAY_EJECT_PENDING.
    //

    HalpSMCScratchRegister = ScratchRegister;

    //
    // Write the value out to the SMC.
    //

    status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_SCRATCH,
        ScratchRegister);

    return status;
}

VOID
HalEnableSecureTrayEject(
    VOID
    )
/*++

Routine Description:

    This routine switches the console to secure mode where a tray eject or tray
    open interrupt causes the console to reboot.  Once the console is in secure
    mode, it cannot be switched back to non-secure mode.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;

    //
    // We only need to enable secure mode if the system is currently in
    // non-secure mode.
    //

    if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) {

        XboxBootFlags &= ~XBOX_BOOTFLAG_NONSECUREMODE;

        do {
            status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS,
                SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN,
                SMC_RESET_ON_TRAY_OPEN_SECURE_MODE);
        } while (!NT_SUCCESS(status));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\smbinta.asm ===
TITLE   "System Management Bus Interupt Service Routine"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     smbinta.asm
;
;  Abstract:
;
;     This module implements the routines to handle a SMBus interrupt.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
INCLUDE i386\kimacro.inc
INCLUDE i386\ix8259.inc
INCLUDE i386\mcpxsmb.inc
        .list

        EXTRNP  HalBeginSMBusInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemLevelInterrupt,1,,FASTCALL
        EXTRNP  _KeInsertQueueDpc,3
        EXTRNP  _KeStallExecutionProcessor,1
        EXTRN   _KiPCR:DWORD
        EXTRN   _HalpSMBusInterruptDpc:DWORD

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpSMBusInterrupt(
;     VOID
;     )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by the
;    SMBus controller.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpSMBusInterrupt, 0

        ENTER_INTERRUPT

        mov     ecx, SMBUS_VECTOR - PRIMARY_VECTOR_BASE
        mov     edx, SMBUS_LEVEL
        push    0                       ; allocate space to save OldIrql
        fstCall HalBeginSMBusInterrupt

;
; Read the status from the SMBus controller and dismiss the interrupt by writing
; the status back out the SMBus controller.
;

        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_STATUS_REGISTER
        in      al, dx
        out     dx, al

;
; Queue a DPC to finish processing of the transaction.  Pass the SMBus status as
; the first parameter to the DPC.
;

        stdCall _KeInsertQueueDpc,<offset _HalpSMBusInterruptDpc, eax, 0>

        mov     eax, SMBUS_VECTOR - PRIMARY_VECTOR_BASE
        LEVEL_INTERRUPT_EXIT

stdENDP _HalpSMBusInterrupt

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\xxioacc.asm ===
title  "ix ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixioacc.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; I/O port space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in PORT space.
;  (Uses x86 in and out instructions)
;
;  WARNING: Port addresses must always be in the range 0 to 64K, because
;           that's the range the hardware understands.
;
;--

;++
;
;   VOID
;   READ_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insb
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_UCHAR

stdENDP _READ_PORT_BUFFER_UCHAR

;++
;
;   VOID
;   READ_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insw
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_USHORT

stdENDP _READ_PORT_BUFFER_USHORT

;++
;
;   VOID
;   READ_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insd
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_ULONG

stdENDP _READ_PORT_BUFFER_ULONG

;++
;
;   VOID
;   WRITE_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsb
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_UCHAR

stdENDP _WRITE_PORT_BUFFER_UCHAR

;++
;
;   VOID
;   WRITE_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsw
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_USHORT

stdENDP _WRITE_PORT_BUFFER_USHORT

;++
;
;   VOID
;   WRITE_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsd
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_ULONG

stdENDP _WRITE_PORT_BUFFER_ULONG

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\channel.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    channel.c

Abstract:

    This module implements routines that apply to the channel object.

--*/

#include "idex.h"

//
// Global IDE channel object for the primary IDE channel.
//
IDE_CHANNEL_OBJECT IdexChannelObject;

//
// Global physical region descriptor table.  Because of PCI IDE hardware
// restrictions, the table cannot span a 64K physical address boundary.  To
// ensure that this happens, we'll place the table in its own section and align
// it to a boundary greater than the size of the table.
//
#pragma bss_seg("IDEXPRDT")
IDE_PCI_PHYSICAL_REGION_DESCRIPTOR
    IdexChannelPhysicalRegionDescriptorTable[IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1];
#pragma bss_seg()
#pragma comment(linker, "/SECTION:IDEXPRDT,,ALIGN=512")

#if DBG
//
// Stores whether or not IdexChannelPrepareToQuickRebootSystem has been called.
//
BOOLEAN IdexChannelQuickRebooting;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexChannelIdentifyDevice)
#pragma alloc_text(INIT, IdexChannelSetTransferMode)
#endif

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusy(
    OUT PUCHAR IdeStatus
    )
/*++

Routine Description:

    This routine spins until the the IDE status register's DRQ bit is clear,
    which indicates that the device is ready to accept a command.

Arguments:

    IdeStatus - Specifies a location to receive the final read of the IDE status
        register.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Spin for up to one second.
    //

    for (Retries = 10000; Retries > 0; Retries--) {

        *IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(*IdeStatus, IDE_STATUS_BSY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    return FALSE;
}

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusyAndNotDrq(
    OUT PUCHAR IdeStatus
    )
/*++

Routine Description:

    This routine spins until the the IDE status register's DRQ bit is set and
    the BSY flag is clear, which indicates that the device is ready to return
    data.

Arguments:

    IdeStatus - Specifies a location to receive the final read of the IDE status
        register.

Return Value:

    Returns TRUE if the DRQ bit was set before timing out, else FALSE.

--*/
{
    ULONG Retries;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Spin for up to one second.
    //

    for (Retries = 10000; Retries > 0; Retries--) {

        *IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(*IdeStatus, IDE_STATUS_BSY) &&
            IdexIsFlagSet(*IdeStatus, IDE_STATUS_DRQ)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    return FALSE;
}

VOID
IdexChannelSetTimerPeriod(
    IN LONG Period
    )
/*++

Routine Description:

    This routine sets the period for the channel's timer.

Arguments:

    Period - Specifies the period for the channel's timer in milliseconds.

Return Value:

    None.

--*/
{
    LARGE_INTEGER TimerDueTime;

    TimerDueTime.QuadPart = (LONG)(-10000 * Period);

    KeSetTimerEx(&IdexChannelObject.Timer, TimerDueTime, Period,
        &IdexChannelObject.TimerDpc);
}

VOID
FASTCALL
IdexChannelPrepareBufferTransfer(
    IN PUCHAR Buffer,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine initializes the channel's physical descriptor table to describe
    the physical pages in the supplied user buffer.

Arguments:

    Buffer - Specifies the buffer with the pages to be placed in the physical
        descriptor table.

    ByteCount - Specifies the number of bytes from the buffer to be placed in
        the physical descriptor table.

Return Value:

    None.

--*/
{
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR PhysicalRegionDescriptor;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR EndingPhysicalRegionDescriptor;
    ULONG BytesRemaining;
    ULONG RegionPhysicalAddress;
    ULONG RegionByteCount;
    ULONG CurrentPhysicalAddress;

    ASSERT((ByteCount > 0) && (ByteCount <= IDE_ATA_MAXIMUM_TRANSFER_BYTES));

    PhysicalRegionDescriptor = IdexChannelPhysicalRegionDescriptorTable;
    EndingPhysicalRegionDescriptor = PhysicalRegionDescriptor +
        (IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1);
    BytesRemaining = ByteCount;

    //
    // Handle the first page of the buffer specially since it can be non-page
    // aligned.
    //

    RegionPhysicalAddress = MmGetPhysicalAddress(Buffer);
    RegionByteCount = PAGE_SIZE - BYTE_OFFSET(Buffer);

    if (RegionByteCount > BytesRemaining) {
        RegionByteCount = BytesRemaining;
    }

    Buffer += RegionByteCount;
    BytesRemaining -= RegionByteCount;

    //
    // Handle the rest of the pages in the buffer.  All of these elements will
    // start on a page boundary.
    //

    if (BytesRemaining > 0) {

        for (;;) {

            CurrentPhysicalAddress = MmGetPhysicalAddress(Buffer);

            //
            // Check if this page is physically contiguous with the active
            // region and that it's in the same 64K chunk of memory.  If either
            // of these are false, then the active region is complete and we'll
            // start a new region.
            //

            if ((RegionPhysicalAddress + RegionByteCount != CurrentPhysicalAddress) ||
                ((RegionPhysicalAddress >> 16) != (CurrentPhysicalAddress >> 16))) {

                ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
                ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
                ASSERT(RegionByteCount <= 0x10000);

                PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
                PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
                PhysicalRegionDescriptor++;

                ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

                RegionPhysicalAddress = CurrentPhysicalAddress;
                RegionByteCount = 0;
            }

            //
            // Adjust the active region size and the number of bytes remaining
            // while watching for the last possibly non-whole page.
            //

            if (BytesRemaining > PAGE_SIZE) {

                RegionByteCount += PAGE_SIZE;
                Buffer += PAGE_SIZE;
                BytesRemaining -= PAGE_SIZE;

            } else {

                RegionByteCount += BytesRemaining;
                break;
            }
        }
    }

    //
    // There are no more bytes remaining, so save off the active region and set
    // the end of table flag.
    //

    ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT(RegionByteCount <= 0x10000);

    PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
    PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
    PhysicalRegionDescriptor->ByteCount.b.EndOfTable = 1;

    ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

    //
    // Reload the bus master's descriptor table register and clear any
    // interrupts and errors.
    //

    IdexWriteBusMasterDescriptorTablePort(
        IdexChannelObject.PhysicalRegionDescriptorTablePhysical);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT |
        IDE_BUS_MASTER_STATUS_ERROR);
}

VOID
IdexChannelPrepareScatterGatherTransfer(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG SegmentByteOffset,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine initializes the channel's physical descriptor table to describe
    the physical pages in the supplied user buffer.

Arguments:

    SegmentArray - Specifies the virtual addresses of the pages that make up the
        transfer buffer.

    SegmentByteOffset - Specifies the byte offset to start reading from the
        segment array.

    ByteCount - Specifies the number of bytes from the buffer to be placed in
        the physical descriptor table.

Return Value:

    None.

--*/
{
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR PhysicalRegionDescriptor;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR EndingPhysicalRegionDescriptor;
    ULONG BytesRemaining;
    ULONG RegionByteCount;
    ULONG RegionPhysicalAddress;
    PVOID Buffer;
    ULONG CurrentPhysicalAddress;

    ASSERT((ByteCount > 0) && (ByteCount <= IDE_ATA_MAXIMUM_TRANSFER_BYTES));

    PhysicalRegionDescriptor = IdexChannelPhysicalRegionDescriptorTable;
    EndingPhysicalRegionDescriptor = PhysicalRegionDescriptor +
        (IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1);
    BytesRemaining = ByteCount;

    //
    // Advance the segment array to the specified byte offset.  The byte offset
    // should be a multiple of the page size.
    //

    ASSERT(BYTE_OFFSET(SegmentByteOffset) == 0);

    SegmentArray += (SegmentByteOffset >> PAGE_SHIFT);

    //
    // Process the file segment element array.
    //

    RegionByteCount = 0;
    RegionPhysicalAddress = 0;

    for (;;) {

        Buffer = PAGE_ALIGN(SegmentArray->Buffer);
        CurrentPhysicalAddress = MmGetPhysicalAddress(Buffer);

        //
        // For the first iteration of the loop, initialize the starting physical
        // region address to the current physical address.
        //

        if (RegionByteCount == 0) {
            RegionPhysicalAddress = CurrentPhysicalAddress;
        }

        //
        // Check if this page is physically contiguous with the active
        // region and that it's in the same 64K chunk of memory.  If either
        // of these are false, then the active region is complete and we'll
        // start a new region.
        //

        if ((RegionPhysicalAddress + RegionByteCount != CurrentPhysicalAddress) ||
            ((RegionPhysicalAddress >> 16) != (CurrentPhysicalAddress >> 16))) {

            ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
            ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
            ASSERT(RegionByteCount <= 0x10000);

            PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
            PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
            PhysicalRegionDescriptor++;

            ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

            RegionPhysicalAddress = CurrentPhysicalAddress;
            RegionByteCount = 0;
        }

        //
        // Adjust the active region size and the number of bytes remaining
        // while watching for the last possibly non-whole page.
        //

        if (BytesRemaining > PAGE_SIZE) {

            RegionByteCount += PAGE_SIZE;
            SegmentArray++;
            BytesRemaining -= PAGE_SIZE;

        } else {

            RegionByteCount += BytesRemaining;
            break;
        }
    }

    //
    // There are no more bytes remaining, so save off the active region and set
    // the end of table flag.
    //

    ASSERT((RegionPhysicalAddress & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT((RegionByteCount & IDE_ALIGNMENT_REQUIREMENT) == 0);
    ASSERT(RegionByteCount <= 0x10000);

    PhysicalRegionDescriptor->PhysicalAddress = RegionPhysicalAddress;
    PhysicalRegionDescriptor->ByteCount.AsULong = (USHORT)RegionByteCount;
    PhysicalRegionDescriptor->ByteCount.b.EndOfTable = 1;

    ASSERT(PhysicalRegionDescriptor <= EndingPhysicalRegionDescriptor);

    //
    // Reload the bus master's descriptor table register and clear any
    // interrupts and errors.
    //

    IdexWriteBusMasterDescriptorTablePort(
        IdexChannelObject.PhysicalRegionDescriptorTablePhysical);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT |
        IDE_BUS_MASTER_STATUS_ERROR);
}

BOOLEAN
IdexChannelInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PVOID ServiceContext
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ.

Arguments:

    InterruptObject - Specifies the interrupt object.

    ServiceContext - Specifies the context associated with this interrupt
        instance.

Return Value:

    TRUE if the interrupt was consumed by this interrupt routine, else FALSE.

--*/
{
    PIDE_INTERRUPT_ROUTINE InterruptRoutine;
    UCHAR IdeStatus;

    InterruptRoutine = IdexChannelObject.InterruptRoutine;

    if (InterruptRoutine != NULL) {

        //
        // Dispatch the interrupt to the appropriate handler.
        //

        InterruptRoutine();

    } else {

        //
        // Read the status register to dismiss the interrupt.
        //

        IdeStatus = IdexReadStatusPort();
    }

    return TRUE;
}

VOID
IdexChannelDpcForIsr(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystmeArgument2
    )
/*++

Routine Description:

    This routine is a DPC that is triggered when the interrupt service routine
    has work that must be executed at DISPATCH_LEVEL.

Arguments:

    Dpc - Specifies the finish DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the first argument passed to KeInsertQueueDpc.

    SystemArgument2 - Specifies the second argument passed to KeInsertQueueDpc.

Return Value:

    None.

--*/
{
    //
    // Dispatch the DPC request to the appropriate handler.
    //

    IdexChannelObject.FinishIoRoutine();
}

VOID
IdexChannelPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the device that is currently resetting itself to check if
    the reset sequence has completed.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
    ASSERT(IdexChannelObject.Timeout > 0);

    //
    // Poll the device to see if the reset sequence has completed.
    //

    if (IdexChannelObject.PollResetCompleteRoutine()) {

        //
        // Clear the poll reset routine.
        //

        IdexChannelObject.PollResetCompleteRoutine = NULL;

        //
        // Restore the channel's timer to the normal period.
        //

        IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);

        //
        // If the number of retries hasn't exceeded the maximum retry count,
        // then restart the current packet.
        //

        if (IdexChannelObject.IoRetries < IdexChannelObject.MaximumIoRetries) {
            IdexChannelRestartCurrentPacket();
            return;
        }

    } else {

        //
        // Decrement the reset timeout and bail if the countdown hasn't reached
        // zero.
        //

        IdexChannelObject.Timeout--;

        if (IdexChannelObject.Timeout != 0) {
            return;
        }

        //
        // Clear the poll reset routine.
        //

        IdexChannelObject.PollResetCompleteRoutine = NULL;

        //
        // Restore the channel's timer to the normal period.
        //

        IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);
    }

    //
    // The reset has timed out or the number of retries has exceeded the maximum
    // retry count, so complete the IRP with a device error and start the next
    // packet.
    //

    Irp = IdexChannelObject.CurrentIrp;

    Irp->IoStatus.Status = STATUS_DISK_RESET_FAILED;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexChannelTimer(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine is invoked once per second by the I/O manager in order to check
    for commands that have timed out.

Arguments:

    Dpc - Specifies the timer DPC contained in the channel object.

    DeferredContext - Specifies the context associated with this DPC instance.

    SystemArgument1 - Specifies the low 32-bits of the system time.

    SystemArgument2 - Specifies the high 32-bits of the system time.

Return Value:

    None.

--*/
{
    PIDE_TIMEOUT_EXPIRED_ROUTINE TimeoutExpiredRoutine;
    PIRP Irp;

    //
    // Do the quick check to see if we're waiting for an interrupt to occur.  If
    // there's no interrupt routine set, then there's no point checking the
    // I/O timeout value.
    //

    if (IdexChannelObject.InterruptRoutine == NULL) {

        //
        // Check if we're in the middle of resetting a device.  If so, check if
        // the device has completed its reset sequence.
        //

        if (IdexChannelObject.PollResetCompleteRoutine != NULL) {
            ASSERT(IdexChannelObject.Timer.Period == IDE_FAST_TIMER_PERIOD);
            IdexChannelPollResetComplete();
            return;
        }

        //
        // Bail out now if there isn't a timeout expired routine set.  If
        // there's no timer work to be done, then the timer had better be set to
        // use the slow period.
        //

        if (IdexChannelObject.TimeoutExpiredRoutine == NULL) {
            ASSERT(IdexChannelObject.Timer.Period == IDE_SLOW_TIMER_PERIOD);
            return;
        }

        //
        // Decrement the timeout and bail if the countdown hasn't reached
        // zero.
        //

        ASSERT(IdexChannelObject.Timeout > 0);
        IdexChannelObject.Timeout--;

        if (IdexChannelObject.Timeout != 0) {
            return;
        }

        //
        // Save and clear the timeout expired routine.
        //

        TimeoutExpiredRoutine = IdexChannelObject.TimeoutExpiredRoutine;
        IdexChannelObject.TimeoutExpiredRoutine = NULL;

        //
        // Restore the channel's timer to the normal period.
        //

        IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);

        //
        // Invoke the timeout expired routine.
        //

        TimeoutExpiredRoutine();

        return;
    }

    //
    // If we're waiting for an interrupt to occur, then the timer had better be
    // set to use the slow period.  Also, verify that the other types of timer
    // callback routines are not set.
    //

    ASSERT(IdexChannelObject.Timer.Period == IDE_SLOW_TIMER_PERIOD);
    ASSERT(IdexChannelObject.PollResetCompleteRoutine == NULL);
    ASSERT(IdexChannelObject.TimeoutExpiredRoutine == NULL);

    //
    // Decrement the timeout and bail if the countdown hasn't reached zero.
    //

    ASSERT(IdexChannelObject.Timeout > 0);
    IdexChannelObject.Timeout--;

    if (IdexChannelObject.Timeout != 0) {
        return;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Check again if the interrupt was triggered now that we're synchronized
    // with the interrupt service routine.
    //

    if (IdexChannelObject.InterruptRoutine == NULL) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        return;
    }

    IdexDbgPrint(("IDEX: command timed out.\n"));

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Ensure that the bus master interface is stopped.
    //

    IdexWriteBusMasterCommandPort(0);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

    //
    // Indicate that the IRP timed out and finish processing the packet back at
    // DPC level.
    //

    Irp->IoStatus.Status = STATUS_IO_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    IdexChannelObject.FinishIoRoutine();
}

VOID
IdexChannelStartNextPacketStock(
    VOID
    )
/*++

Routine Description:

    This routine starts the next I/O request packet or marks the IDE channel as
    not busy if no I/O request packets are queued.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    PIRP Irp;
    PDEVICE_OBJECT DeviceObject;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Clear out the current IRP for debugging purposes.
    //

    IdexChannelObject.CurrentIrp = NULL;

    //
    // Check if we're already nested inside of a StartIo call.  If so, set a
    // flag so that when we pop out of the StartIo call, we'll start another
    // packet.
    //

    if (IdexChannelObject.StartPacketBusy) {
        IdexChannelObject.StartPacketRequested = TRUE;
        return;
    }

    do {

        //
        // Reset the start packet requested flag.
        //

        IdexChannelObject.StartPacketRequested = FALSE;

        //
        // Pull off the next IRP from the device queue.  If there aren't any
        // IRPs queued, then bail out.
        //

        DeviceQueueEntry = KeRemoveDeviceQueue(&IdexChannelObject.DeviceQueue);

        if (DeviceQueueEntry == NULL) {
            break;
        }

        Irp = CONTAINING_RECORD(DeviceQueueEntry, IRP, Tail.Overlay.DeviceQueueEntry);
        DeviceObject = IoGetCurrentIrpStackLocation(Irp)->DeviceObject;

        //
        // Store the current IRP in the channel for debugging purposes.
        //

        IdexChannelObject.CurrentIrp = Irp;

        //
        // Reset the number of retries that have been performed for the current
        // IRP.
        //

        IdexChannelObject.IoRetries = 0;

        //
        // Set the default number of retries that are allowed per IRP.
        //

        IdexChannelObject.MaximumIoRetries = IDE_NORMAL_RETRY_COUNT;

        //
        // Indicate that we're already inside of a start packet call so that
        // recursive calls to start another packet don't overflow the stack.
        //

        IdexChannelObject.StartPacketBusy = TRUE;

        //
        // Invoke the driver's StartIo routine to start the IRP.
        //

        DeviceObject->DriverObject->DriverStartIo(DeviceObject, Irp);

        //
        // We're no longer busy handling a start packet call.
        //

        IdexChannelObject.StartPacketBusy = FALSE;

        //
        // Continue pulling packets off of the device queue while we received a
        // nested start packet call.
        //

    } while (IdexChannelObject.StartPacketRequested);
}

VOID
IdexChannelStartPacketStock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine attempts to start the specified I/O request packet.  If the
    IDE channel is already busy, then the packet is queued as appropriate.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    BOOLEAN Inserted;

    //
    // If a DMA transfer is still in progress and we quick reboot, then we could
    // corrupt the memory from the next instance of the kernel.
    //

    ASSERTMSG("I/O cannot be started after reboot was requested\n",
        !IdexChannelQuickRebooting);

    //
    // Synchronize access to the device queue by raising to DPC level.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Attempt to insert the packet into the channel's device queue.
    //

    Inserted = KeInsertDeviceQueue(&IdexChannelObject.DeviceQueue,
        &Irp->Tail.Overlay.DeviceQueueEntry);

    //
    // If the packet wasn't inserted into the device queue, then the device
    // queue was not busy and we can start the IRP now.
    //

    if (!Inserted) {

        //
        // Store the current IRP in the channel for debugging purposes.
        //

        IdexChannelObject.CurrentIrp = Irp;

        //
        // Reset the number of retries that have been performed for the current
        // IRP.
        //

        IdexChannelObject.IoRetries = 0;

        //
        // Set the default number of retries that are allowed per IRP.
        //

        IdexChannelObject.MaximumIoRetries = IDE_NORMAL_RETRY_COUNT;

        //
        // Indicate that we're already inside of a start packet call so that
        // recursive calls to start another packet don't overflow the stack.
        //

        IdexChannelObject.StartPacketBusy = TRUE;

        //
        // Invoke the driver's StartIo routine to start the IRP.
        //

        DeviceObject->DriverObject->DriverStartIo(DeviceObject, Irp);

        //
        // We're no longer busy handling a start packet call.
        //

        IdexChannelObject.StartPacketBusy = FALSE;

        //
        // If a request was made to start a packet while we were nested inside
        // of the above StartIo call, then handle the deferred start now.
        //

        if (IdexChannelObject.StartPacketRequested) {
            IdexChannelStartNextPacket();
        }
    }

    KeLowerIrql(OldIrql);
}

VOID
IdexChannelRestartCurrentPacket(
    VOID
    )
/*++

Routine Description:

    This routine increments the I/O retry count for the channel and restarts the
    current IRP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Increment the number of times that we've retried the current packet.
    //

    IdexChannelObject.IoRetries++;

    //
    // Invoke the driver's StartIo routine to start the IRP.
    //

    IrpSp->DeviceObject->DriverObject->DriverStartIo(IrpSp->DeviceObject, Irp);
}

VOID
IdexChannelAbortCurrentPacket(
    VOID
    )
/*++

Routine Description:

    This routine aborts the current IRP.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexChannelInvalidParameterRequest(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called from a queued device I/O control routine when an
    invalid parameter is detected.  The I/O request is completed with
    STATUS_INVALID_PARAMETER and the next packet is started.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IdexChannelStartNextPacket();
}

VOID
IdexChannelIdePassThroughInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an IDE pass through request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    PIRP Irp;
    PATA_PASS_THROUGH AtaPassThrough;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Take a snapshot of the IDE registers.
    //

    AtaPassThrough = (PATA_PASS_THROUGH)Irp->UserBuffer;

    AtaPassThrough->IdeReg.bFeaturesReg = IdexReadErrorPort();
    AtaPassThrough->IdeReg.bSectorCountReg = IdexReadSectorCountPort();
    AtaPassThrough->IdeReg.bSectorNumberReg = IdexReadSectorNumberPort();
    AtaPassThrough->IdeReg.bCylLowReg = IdexReadCylinderLowPort();
    AtaPassThrough->IdeReg.bCylHighReg = IdexReadCylinderHighPort();
    AtaPassThrough->IdeReg.bCommandReg = IdeStatus;

    //
    // If this is a data in command, then read the data from the device.
    //

    if ((AtaPassThrough->DataBufferSize != 0) &&
        !AtaPassThrough->IdeReg.bHostSendsData) {

        IdexReadDataPortBufferUshort((PUSHORT)AtaPassThrough->DataBuffer,
            AtaPassThrough->DataBufferSize / sizeof(USHORT));

        if ((AtaPassThrough->DataBufferSize & 1) != 0) {
            ((PUCHAR)AtaPassThrough->DataBuffer)[AtaPassThrough->DataBufferSize - 1] =
                IdexReadDataPortUchar();
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexChannelFinishIdePassThrough(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_IDE_PASS_THROUGH request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IoCompleteRequest(IdexChannelObject.CurrentIrp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexChannelStartIdePassThrough(
    IN PIRP Irp,
    IN UCHAR TargetDevice,
    IN PIDE_RESET_DEVICE_ROUTINE ResetDeviceRoutine
    )
/*++

Routine Description:

    This routine handles queued IOCTL_IDE_PASS_THROUGH requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

    TargetDevice - Specifies the device number to send the pass through to.

    ResetDeviceRoutine - Specifies the routine to invoke to reset the device if
        it's busy.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PATA_PASS_THROUGH AtaPassThrough;
    UCHAR IdeStatus;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    AtaPassThrough = (PATA_PASS_THROUGH)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the input buffer is the same as the output buffer, that the
    // input buffer is large enough, and that the output buffer is large enough
    // (including the data buffer size).
    //

    if ((Irp->UserBuffer != IrpSp->Parameters.DeviceIoControl.InputBuffer) ||
        (IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ATA_PASS_THROUGH)) ||
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(ATA_PASS_THROUGH))) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes in the
    // output buffer.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    IdexProgramTargetDevice(TargetDevice);

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        ResetDeviceRoutine();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexWriteFeaturesPort(AtaPassThrough->IdeReg.bFeaturesReg);
    IdexWriteSectorCountPort(AtaPassThrough->IdeReg.bSectorCountReg);
    IdexWriteSectorNumberPort(AtaPassThrough->IdeReg.bSectorNumberReg);
    IdexWriteCylinderLowPort(AtaPassThrough->IdeReg.bCylLowReg);
    IdexWriteCylinderHighPort(AtaPassThrough->IdeReg.bCylHighReg);
    IdexWriteCommandPort(AtaPassThrough->IdeReg.bCommandReg);

    //
    // If this is a data out command, then wait for the device to be not busy
    // and ready to accept data.
    //

    if ((AtaPassThrough->DataBufferSize != 0) &&
        AtaPassThrough->IdeReg.bHostSendsData) {

        if (!IdexChannelSpinWhileBusyAndNotDrq(&IdeStatus)) {
            ResetDeviceRoutine();
            return;
        }

        //
        // Write out the data to the device.
        //

        IdexWriteDataPortBufferUshort((PUSHORT)AtaPassThrough->DataBuffer,
            AtaPassThrough->DataBufferSize / sizeof(USHORT));

        if ((AtaPassThrough->DataBufferSize & 1) != 0) {
            IdexWriteDataPortUchar(((PUCHAR)AtaPassThrough->DataBuffer)[AtaPassThrough->DataBufferSize - 1]);
        }
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexChannelIdePassThroughInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexChannelFinishIdePassThrough;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexChannelIdentifyDevice(
    IN UCHAR TargetDevice,
    IN UCHAR IdentifyCommand,
    OUT PIDE_IDENTIFY_DATA IdentifyData
    )
/*++

Routine Description:

    This routine executes an identify command for the supplied device.

Arguments:

    TargetDrive - Specifies the IDE drive to be identified.

    IdentifyCommand - Specifies the IDE identify command to be sent.

    IdentifyData - Specifies the buffer to receive the identification data.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(TargetDevice);

    //
    // Check if the channel has anything attached to it.
    //

    IdexWriteCylinderLowPort(0x5A);
    IdexWriteCylinderHighPort(0xA5);

    if ((IdexReadCylinderLowPort() != 0x5A) ||
        (IdexReadCylinderHighPort() != 0xA5)) {
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the identify command.
    //

    IdexWriteCommandPort(IdentifyCommand);

    //
    // Spin until the device has is not busy and is ready to send data.
    //

    if (!IdexChannelSpinWhileBusyAndNotDrq(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Read the identify data.
    //

    IdexReadDataPortBufferUlong((PULONG)IdentifyData, sizeof(*IdentifyData) /
        sizeof(ULONG));

    //
    // If the channel has raised an error, then abandon the request.  The device
    // may have indicated that the data is available but is invalid.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexChannelSetTransferMode(
    IN UCHAR TargetDevice,
    IN UCHAR TransferMode
    )
/*++

Routine Description:

    This routine sets the transfer mode for the supplied device to the supplied
    transfer mode.

Arguments:

    TargetDevice - Specifies the device number to set the transfer mode for.

    TransferMode - Specifies the desired transfer mode for the device.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(TargetDevice);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the set transfer mode command.
    //

    IdexWriteFeaturesPort(IDE_FEATURE_SET_TRANSFER_MODE);
    IdexWriteSectorCountPort(TransferMode);

    IdexWriteCommandPort(IDE_COMMAND_SET_FEATURES);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexChannelIssueImmediateCommand(
    IN UCHAR TargetDevice,
    IN UCHAR IdeCommand
    )
/*++

Routine Description:

    This routine issues the supplied immediate command to the supplied device.

Arguments:

    TargetDevice - Specifies the device number to set the transfer mode for.

    IdeCommand - Specifies the IDE command to issue.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(TargetDevice);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IdeCommand);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

VOID
IdexChannelCreate(
    VOID
    )
/*++

Routine Description:

    This routine constructs and initializes a channel device object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG InterruptVector;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR PhysicalRegionDescriptor;
    PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR EndingPhysicalRegionDescriptor;
#ifdef ARCADE
    BOOLEAN MediaBoardDetected;
#endif

    //
    // Initialize the pointers to the stock start packet routines.
    //

    IdexChannelObject.StartPacketRoutine = IdexChannelStartPacketStock;
    IdexChannelObject.StartNextPacketRoutine = IdexChannelStartNextPacketStock;

    //
    // Initialize the channe's device queue.
    //

    KeInitializeDeviceQueue(&IdexChannelObject.DeviceQueue);

    //
    // Initialize and start the channel's timer.
    //

    KeInitializeDpc(&IdexChannelObject.TimerDpc, IdexChannelTimer, NULL);

    KeInitializeTimerEx(&IdexChannelObject.Timer, SynchronizationTimer);

    IdexChannelSetTimerPeriod(IDE_SLOW_TIMER_PERIOD);

    //
    // Initialize the channel's post interrupt DPC handler.
    //

    KeInitializeDpc(&IdexChannelObject.FinishDpc, IdexChannelDpcForIsr, NULL);

    //
    // Enable interrupts for the channel.
    //

    IdexWriteDeviceControlPort(0);

    //
    // Connect to the channel's interrupt.
    //

    InterruptVector = HalGetInterruptVector(IDE_CHANNEL_IRQ_RESOURCE,
        &IdexChannelObject.InterruptIrql);

    KeInitializeInterrupt(&IdexChannelObject.InterruptObject,
        IdexChannelInterrupt, NULL, InterruptVector,
        IdexChannelObject.InterruptIrql, Latched, FALSE);

    if (!KeConnectInterrupt(&IdexChannelObject.InterruptObject)) {
        IdexBugCheck(IDE_BUG_CHECK_CHANNEL, STATUS_UNSUCCESSFUL);
    }

    //
    // Verify that the physical region descriptor table doesn't straddle a 64K
    // physical address boundary.
    //

    PhysicalRegionDescriptor = IdexChannelPhysicalRegionDescriptorTable;
    EndingPhysicalRegionDescriptor = PhysicalRegionDescriptor +
        (IDE_ATA_MAXIMUM_TRANSFER_PAGES + 1);

    ASSERT(((ULONG_PTR)PhysicalRegionDescriptor >> 16) ==
        (ULONG_PTR)EndingPhysicalRegionDescriptor >> 16);

    //
    // Cache the physical address of the table so that we can point the hardware
    // at it later.
    //

    IdexChannelObject.PhysicalRegionDescriptorTablePhysical =
        MmGetPhysicalAddress(IdexChannelPhysicalRegionDescriptorTable);

#ifdef ARCADE
    //
    // Check for the existence of a media board by comparing the chip
    // revision and DIMM size registers against bus noise
    //

    MediaBoardDetected =
        (BOOLEAN)(IdexReadPortUshort(SEGA_REGISTER_CHIP_REVISION) != 0xFFFF) &&
        (BOOLEAN)(IdexReadPortUshort(SEGA_REGISTER_DIMM_SIZE) != 0xFFFF);

#ifdef DEVKIT
    //
    // Create the disk and either the media board or CD-ROM device objects.
    //

    if (KeHasQuickBooted) {
        IdexDiskCreateQuick();
        MediaBoardDetected ? IdexMediaBoardCreateQuick() : IdexCdRomCreateQuick();
    } else {
        IdexDiskCreate();
        MediaBoardDetected ? IdexMediaBoardCreate() : IdexCdRomCreate();
    }
#else
    //
    // Create the media board device objects.
    //

    if (KeHasQuickBooted) {
        IdexMediaBoardCreateQuick();
    } else if (!MediaBoardDetected) {
        IdexDbgPrint(("IDEX: media board not detected.\n"));
        IdexMediaBoardFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    } else {
        IdexMediaBoardCreate();
    }
#endif
#else
    //
    // Create the disk and CD-ROM device objects.
    //

    if (KeHasQuickBooted) {
        IdexDiskCreateQuick();
        IdexCdRomCreateQuick();
    } else {
        IdexDiskCreate();
        IdexCdRomCreate();
    }
#endif
}

#if DBG

VOID
IdexChannelPrepareToQuickRebootSystem(
    VOID
    )
/*++

Routine Description:

    This routine is called in debug versions of the kernel in order to verify
    that no I/O is in progress and that no further I/O is submitted.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // If a DMA transfer is still in progress and we quick reboot, then we could
    // corrupt the memory from the next instance of the kernel.
    //

    ASSERTMSG("I/O still in progress when reboot was requested\n",
        (IdexChannelObject.CurrentIrp == NULL));

    IdexChannelQuickRebooting = TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\cdrom.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    cdrom.c

Abstract:

    This module implements routines that apply to the CD-ROM object.

--*/

#include "idex.h"

#if !defined(ARCADE) || defined(DEVKIT)

//
// Single instance of the CD-ROM device object.
//
PDEVICE_OBJECT IdexCdRomDeviceObject;

//
// Name of the CD-ROM device object and its DOS devices symbolic link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexCdRomDeviceName, "\\Device\\CdRom0");
INITIALIZED_OBJECT_STRING_RDATA(IdexCdRomDosDevicesName, "\\??\\CdRom0:");

//
// Static transfer buffer used for IOCTLs that need to transfer a small number
// of bytes.  Used to avoid adding pool allocation and free code to several code
// paths.  The buffer is already locked due to being part of the kernel image.
//
UCHAR IdexCdRomStaticTransferBuffer[32];

//
// Number of bytes that are available on the single "partition" of the device
// media.  The actual number is filled in when IOCTL_CDROM_GET_DRIVE_GEOMETRY is
// invoked.
//
LONGLONG IdexCdRomPartitionLength = _I64_MAX;

//
// Stores whether or not the disc has passed DVD-X2 authentication.
//
DECLSPEC_STICKY BOOLEAN IdexCdRomDVDX2Authenticated;

#if DBG
//
// Stores the last SCSI error read from the drive.
//
SENSE_DATA IdexCdRomDebugSenseData;

//
// Stores the number of errors that have occurred at the various spindle speeds.
//
ULONG IdexCdRomDebugErrors[DVDX2_SPINDLE_SPEED_MAXIMUM];

//
// Stores the number of sectors that have been transferred.
//
ULONG IdexCdRomDebugReadsFinished;
#endif

//
// Stores the maximum spindle speed requested by the title.
//
ULONG IdexCdRomMaximumSpindleSpeed = DVDX2_SPINDLE_SPEED_MAXIMUM;

//
// Stores the current spindle speed; this should be less than or equal to the
// maximum spindle speed.  Note that this is sticky across boots so that if the
// spindle speed is reduced in one instance of the kernel, the next instance of
// the kernel can correct it.
//
DECLSPEC_STICKY ULONG IdexCdRomCurrentSpindleSpeed = DVDX2_SPINDLE_SPEED_MAXIMUM;

//
// Stores the last sector that was read from while the spindle was slowed down.
//
DECLSPEC_STICKY ULONG IdexCdRomSpindleSlowdownSectorNumber;

//
// Stores the number of sectors that must be transfered before allowing the
// spindle to speed back up.
//
DECLSPEC_STICKY ULONG IdexCdRomSpindleSlowdownSectorsRemaining;

//
// Stores the number of sectors that need to be crossed before we'll attempt to
// restore the spindle speed to the next faster spindle speed.
//
const ULONG IdexCdRomSpindleSpeedupTable[DVDX2_SPINDLE_SPEED_MAXIMUM + 1] = {
    4096,                               // DVDX2_SPINDLE_SPEED_MINIMUM
    8192,                               // DVDX2_SPINDLE_SPEED_MEDIUM
    MAXULONG,                           // DVDX2_SPINDLE_SPEED_MAXIMUM
};

//
// Local support.
//

DECLSPEC_NORETURN
VOID
IdexCdRomFatalError(
    IN ULONG ErrorCode
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexCdRomFatalError)
#pragma alloc_text(INIT, IdexCdRomCreate)
#endif

BOOLEAN
IdexCdRomPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the CD-ROM device to check for completion of a reset
    sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the device has completed its reset sequence.

--*/
{
    UCHAR IdeStatus;

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_CDROM_DEVICE_NUMBER);

    //
    // Check if the device is busy.
    //

    IdeStatus = IdexReadStatusPort();

    if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IdexCdRomResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine software resets the CD-ROM device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IdexAssertIrqlAtChannelDIRQL();

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_CDROM_DEVICE_NUMBER);

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_DEVICE_RESET);

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Speed up the timer to check for completion of the reset sequence.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    //
    // Delay for up to twenty-five seconds (100 milliseconds per unit).
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexCdRomPollResetComplete;
    IdexChannelObject.Timeout = 250;
}

BOOLEAN
IdexCdRomSelectDeviceAndSpinWhileBusy(
    VOID
    )
/*++

Routine Description:

    This routine selects the CD-ROM device and spins until the the IDE status
    register's BSY bit is clear, which indicates that the device is ready to
    accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_CDROM_DEVICE_NUMBER);

    //
    // Spin for up to a tenth second.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

BOOLEAN
IdexCdRomWritePacket(
    PCDB Cdb
    )
/*++

Routine Description:

    This routine selects the CD-ROM device and spins until the the IDE status
    register's BSY bit is clear, which indicates that the device is ready to
    accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_PACKET);

    //
    // Spin until the device indicates that it's ready to receive the SCSI CDB.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY) &&
            IdexIsFlagSet(IdeStatus, IDE_STATUS_DRQ)) {

            //
            // Issue the SCSI CDB.
            //

            IdexWriteDataPortCdb(Cdb);

            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

VOID
IdexCdRomNoTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    UCHAR InterruptReason;
    PIRP Irp;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Verify that the interrupt reason indicates that the command is complete.
    //

    InterruptReason = IdexReadInterruptReasonPort();

    if ((InterruptReason & (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) !=
        (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) {
        return;
    }

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexCdRomTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR BusMasterStatus;
    UCHAR IdeStatus;
    UCHAR InterruptReason;
    PIRP Irp;

    //
    // Read the bus master status register and verify that the interrupt bit is
    // set if we haven't already seen the bus master interrupt.
    //

    BusMasterStatus = IdexReadBusMasterStatusPort();

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Verify that the interrupt reason indicates that the command is complete.
    //

    InterruptReason = IdexReadInterruptReasonPort();

    if (IdexChannelObject.ExpectingBusMasterInterrupt) {

        if (IdexIsFlagClear(BusMasterStatus, IDE_BUS_MASTER_STATUS_INTERRUPT)) {
            return;
        }

        //
        // Deactivate the bus master interface and dismiss the interrupt.
        //

        IdexWriteBusMasterCommandPort(0);
        IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

        IdexChannelObject.ExpectingBusMasterInterrupt = FALSE;
    }

    if ((InterruptReason & (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) !=
        (IDE_INTERRUPT_REASON_IO | IDE_INTERRUPT_REASON_CD)) {
        return;
    }

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR) ||
        IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ERROR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else if (IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ACTIVE)) {
        Irp->IoStatus.Status = STATUS_DATA_OVERRUN;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexCdRomIssueAtapiRequest(
    IN PCDB Cdb,
    IN PVOID TransferBuffer,
    IN ULONG TransferLength,
    IN BOOLEAN DataOut,
    IN PIDE_FINISHIO_ROUTINE FinishIoRoutine
    )
/*++

Routine Description:

    This routine issues the supplied ATAPI request.

Arguments:

    Cdb - Specifies the SCSI CDB to issue.

    TransferBuffer - Specifies the pointer to the input or output buffer.

    TransferLength - Specifies the number of bytes to transfer.

    DataOut - Specifies the direction of the data transfer.

    FinishIoRoutine - Specifies the routine to invoke on completion of the ATAPI
        request.

Return Value:

    None.

--*/
{
    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexCdRomSelectDeviceAndSpinWhileBusy()) {
        FinishIoRoutine();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (TransferLength != 0) {
        IdexChannelPrepareBufferTransfer(TransferBuffer, TransferLength);
        IdexWriteFeaturesPort(IDE_FEATURE_DMA);
    } else {
        IdexWriteFeaturesPort(0);
    }

    //
    // Write out the IDE command and the SCSI CDB.
    //

    if (!IdexCdRomWritePacket(Cdb)) {
        FinishIoRoutine();
        return;
    }

    //
    // Activate the bus master interface.
    //

    if (TransferLength != 0) {
        if (DataOut) {
            IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START);
        } else {
            IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
                IDE_BUS_MASTER_COMMAND_READ);
        }
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = (TransferLength != 0) ?
        IdexCdRomTransferInterrupt : IdexCdRomNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = FinishIoRoutine;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATAPI_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

VOID
IdexCdRomSetSpindleSpeed(
    IN ULONG SpindleSpeedControl,
    IN PIDE_FINISHIO_ROUTINE FinishIoRoutine
    )
/*++

Routine Description:

    This routine prepares a spindle speed ATAPI request and issues the request.

Arguments:

    SpindleSpeedControl - Specifies the desired speed of the spindle.

    FinishIoRoutine - Specifies the routine to invoke on completion of the ATAPI
        request.

Return Value:

    None.

--*/
{
    PDVDX2_ADVANCED_DRIVE_CONTROL AdvancedDriveControl;
    CDB Cdb;

    ASSERT(SpindleSpeedControl <= IdexCdRomMaximumSpindleSpeed);

    IdexDbgPrint(("IDEX: setting spindle speed to %d.\n", SpindleSpeedControl));

    //
    // Change the current spindle speed to the requested spindle speed.  Note
    // that if the drive fails to handle the below ATAPI request, the software
    // state won't match the hardware state, but that's not likely to occur and
    // won't cause any problems for the drive or driver, so we'll ignore that
    // possibility.
    //

    IdexCdRomCurrentSpindleSpeed = SpindleSpeedControl;

    //
    // If spindle speed change is part of the error recovery path in this driver
    // and not an explicit call to IOCTL_CDROM_SET_SPINDLE_SPEED, then we need
    // to keep track of the number of sectors where we'll apply the new spindle
    // speed before we increase to the new spindle speed.
    //

    IdexCdRomSpindleSlowdownSectorsRemaining =
        IdexCdRomSpindleSpeedupTable[SpindleSpeedControl];

    //
    // Prepare the advanced drive control page.
    //

    ASSERT(sizeof(IdexCdRomStaticTransferBuffer) >= sizeof(DVDX2_ADVANCED_DRIVE_CONTROL));

    AdvancedDriveControl = (PDVDX2_ADVANCED_DRIVE_CONTROL)IdexCdRomStaticTransferBuffer;

    RtlZeroMemory(AdvancedDriveControl, sizeof(DVDX2_ADVANCED_DRIVE_CONTROL));

    *((PUSHORT)&AdvancedDriveControl->Header.ModeDataLength) =
        IdexConstantUshortByteSwap(sizeof(DVDX2_ADVANCED_DRIVE_CONTROL) -
        FIELD_OFFSET(DVDX2_ADVANCED_DRIVE_CONTROL, Header.MediumType));
    AdvancedDriveControl->AdvancedDriveControlPage.PageCode =
        DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL;
    AdvancedDriveControl->AdvancedDriveControlPage.PageLength =
        sizeof(DVDX2_ADVANCED_DRIVE_CONTROL_PAGE) -
        FIELD_OFFSET(DVDX2_ADVANCED_DRIVE_CONTROL_PAGE, SpindleSpeedControl);
    AdvancedDriveControl->AdvancedDriveControlPage.SpindleSpeedControl =
        (UCHAR)SpindleSpeedControl;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
    Cdb.MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL;
    *((PUSHORT)&Cdb.MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_ADVANCED_DRIVE_CONTROL));

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        sizeof(DVDX2_ADVANCED_DRIVE_CONTROL), TRUE, FinishIoRoutine);
}

VOID
IdexCdRomFinishSpeedReduction(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing after reducing
    the spindle speed as a result of an error from the drive.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Restart the current packet in around 300ms.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    IdexChannelObject.TimeoutExpiredRoutine = IdexChannelRestartCurrentPacket;
    IdexChannelObject.Timeout = 3;
}

BOOLEAN
IdexCdRomSpeedReductionRequested(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when the drive has returned a sense code indicating
    that cache errors have been detected and a speed reduction is requested.

    If a speed reduction is initiated, then the current IRP will be retried at
    the lower spindle speed.

Arguments:

    None.

Return Value:

    Returns TRUE if a speed reduction ATAPI request has been issued, else FALSE.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    //
    // If the current spindle speed is already at the minimum value, then do
    // nothing.
    //

    if (IdexCdRomCurrentSpindleSpeed != DVDX2_SPINDLE_SPEED_MINIMUM) {

        //
        // If this is not a read request, then do nothing.
        //

        IrpSp = IoGetCurrentIrpStackLocation(IdexChannelObject.CurrentIrp);

        if (IrpSp->MajorFunction == IRP_MJ_READ) {

            //
            // Remember the sector number where we last slowed down the drive.
            //

            IdexCdRomSpindleSlowdownSectorNumber =
                IrpSp->Parameters.IdexReadWrite.SectorNumber;

            //
            // Reduce the spindle speed by another notch and then restart the
            // current packet.
            //

            IdexCdRomSetSpindleSpeed(IdexCdRomCurrentSpindleSpeed - 1,
                IdexCdRomFinishSpeedReduction);

            return TRUE;
        }
    }

    return FALSE;
}

VOID
IdexCdRomFinishSpindleSpeedRestore(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing after restoring
    the spindle speed to the maximum value.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    //
    // Don't use IdexChannelRestartCurrentPacket in order to avoid incrementing
    // the number of retries for this packet.
    //

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Invoke the driver's StartIo routine to start the IRP.
    //

    IrpSp->DeviceObject->DriverObject->DriverStartIo(IrpSp->DeviceObject, Irp);
}

BOOLEAN
IdexCdRomCheckForRestoreSpindleSpeed(
    IN ULONG StartingSectorNumber,
    IN ULONG NumberOfSectors
    )
/*++

Routine Description:

    This routine checks if the supplied sector number is outside of the range of
    sectors that caused the spindle speed of the drive to be reduced.

Arguments:

    StartingSectorNumber - Specifies the starting sector number of the current
        read request.

    NumberOfSectors - Specifies the number of sectors for the current read
        request.

Return Value:

    Returns TRUE if the spindle speed is being restored, else FALSE.

--*/
{
    ASSERT(IdexCdRomCurrentSpindleSpeed < IdexCdRomMaximumSpindleSpeed);

    //
    // Reduce the number of sectors that must be read before attempting to
    // increase the spindle speed.  This check is to prevent scenerios where
    // reading the same block of data over and over keeps the spindle speed from
    // ever being restored.
    //

    if (NumberOfSectors < IdexCdRomSpindleSlowdownSectorsRemaining) {
        IdexCdRomSpindleSlowdownSectorsRemaining -= NumberOfSectors;
    } else {
        IdexCdRomSpindleSlowdownSectorsRemaining = 0;
    }

    //
    // Check if we're still inside the sector range that caused us to last
    // slowdown and that we haven't run the count of transfered sectors down to
    // zero.
    //

    if ((IdexCdRomSpindleSlowdownSectorsRemaining != 0) &&
        (StartingSectorNumber >= IdexCdRomSpindleSlowdownSectorNumber) &&
        (StartingSectorNumber < IdexCdRomSpindleSlowdownSectorNumber +
            IdexCdRomSpindleSpeedupTable[IdexCdRomCurrentSpindleSpeed])) {
        return FALSE;
    }

    //
    // Remember the sector number where we last speed up the drive.
    //

    IdexCdRomSpindleSlowdownSectorNumber = StartingSectorNumber;

    //
    // We're outside of the slowdown sector range.  Attempt to restore the
    // spindle speed back to the maximum value.
    //

    IdexCdRomSetSpindleSpeed(IdexCdRomCurrentSpindleSpeed + 1,
        IdexCdRomFinishSpindleSpeedRestore);

    return TRUE;
}

VOID
IdexCdRomFinishRequestSense(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a request to read
    the sense data from the drive.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PSENSE_DATA SenseData;
    NTSTATUS status;
    BOOLEAN Retry;
    BOOLEAN DelayedRetry;
    BOOLEAN AdjustSpindleSpeed;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;

#if DBG
    //
    // Keep track of the number of errors that have occurred at the various
    // spindle speeds.
    //

    IdexCdRomDebugErrors[IdexCdRomCurrentSpindleSpeed]++;
#endif

    //
    // If we're unable to get the correct sense information, give up and just
    // complete the IRP with STATUS_IO_DEVICE_ERROR.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
        goto CompleteRequest;
    }

    //
    // Interpret and process the sense data.
    //

    SenseData = (PSENSE_DATA)IdexCdRomStaticTransferBuffer;
    status = STATUS_IO_DEVICE_ERROR;
    Retry = FALSE;
    DelayedRetry = FALSE;
    AdjustSpindleSpeed = FALSE;

    switch (SenseData->SenseKey) {

        case SCSI_SENSE_NO_SENSE:
            if (SenseData->IncorrectLength) {
                status = STATUS_INVALID_BLOCK_LENGTH;
            } else {
                Retry = TRUE;
            }
            break;

        case SCSI_SENSE_RECOVERED_ERROR:
            if (SenseData->IncorrectLength) {
                status = STATUS_INVALID_BLOCK_LENGTH;
            } else if (SenseData->AdditionalSenseCode ==
                DVDX2_ADSENSE_SPEED_REDUCTION_REQUESTED) {
                Retry = TRUE;
                AdjustSpindleSpeed = TRUE;
            } else {
                status = STATUS_SUCCESS;
            }
            break;

        case SCSI_SENSE_NOT_READY:
            status = STATUS_DEVICE_NOT_READY;

            switch (SenseData->AdditionalSenseCode) {

                case SCSI_ADSENSE_LUN_NOT_READY:
                    Retry = TRUE;
                    DelayedRetry = TRUE;
                    break;

                case SCSI_ADSENSE_INVALID_MEDIA:
                    status = STATUS_UNRECOGNIZED_MEDIA;
                    break;

                case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE:
                    status = STATUS_NO_MEDIA_IN_DEVICE;
                    break;
            }
            break;

        case SCSI_SENSE_MEDIUM_ERROR:
            status = STATUS_DEVICE_DATA_ERROR;

            switch (SenseData->AdditionalSenseCode) {

                case SCSI_ADSENSE_INVALID_MEDIA:
                    status = STATUS_UNRECOGNIZED_MEDIA;
                    break;

                case DVDX2_ADSENSE_GENERAL_READ_ERROR:
                    Retry = TRUE;

                    if (IdexChannelObject.IoRetries != 0) {
                        AdjustSpindleSpeed = TRUE;
                    }

                    break;
            }
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            status = STATUS_INVALID_DEVICE_REQUEST;

            switch (SenseData->AdditionalSenseCode) {

                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    status = STATUS_NONEXISTENT_SECTOR;
                    break;

                case SCSI_ADSENSE_INVALID_MEDIA:
                    status = STATUS_UNRECOGNIZED_MEDIA;
                    break;

                case SCSI_ADSENSE_COPY_PROTECTION_FAILURE:
                case DVDX2_ADSENSE_COPY_PROTECTION_FAILURE:
                    status = STATUS_TOO_MANY_SECRETS;
                    break;

                case DVDX2_ADSENSE_COMMAND_ERROR:
                    Retry = TRUE;
                    break;
            }
            break;

        case SCSI_SENSE_UNIT_ATTENTION:
            Retry = TRUE;

            if (SenseData->AdditionalSenseCode == DVDX2_ADSENSE_INSUFFICIENT_TIME) {
                AdjustSpindleSpeed = TRUE;
            }

            break;

        default:
            Retry = TRUE;
            break;
    }

    Irp->IoStatus.Status = status;

#if DBG
    //
    // Keep a copy of the the last sense data for debugging purposes.
    //

    RtlCopyMemory(&IdexCdRomDebugSenseData, SenseData, sizeof(SENSE_DATA));
#endif

    //
    // Retry the request if possible.
    //

    if (Retry &&
        (IdexChannelObject.IoRetries < IdexChannelObject.MaximumIoRetries)) {

        //
        // If this isn't a retry associated with a spindle speed reduction, then
        // restart the current packet and bail out now.
        //

        if (!AdjustSpindleSpeed) {

            if (!DelayedRetry) {
                IdexChannelRestartCurrentPacket();
                return;
            }

            //
            // Restart the current packet in around 800ms.
            //

            IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

            IdexChannelObject.TimeoutExpiredRoutine = IdexChannelRestartCurrentPacket;
            IdexChannelObject.Timeout = 8;

            return;
        }

        //
        // Otherwise, try to slow down the spindle.  If the spindle cannot be
        // slowed down, then abandon the retry and fall into the non-retry path.
        //

        if (IdexCdRomSpeedReductionRequested()) {
            return;
        }
    }

    //
    // If the request is a SCSI pass through request and the caller has supplied
    // an output buffer, then copy the sense data to the caller's output buffer
    // and return success.  The caller checks the number of bytes written to the
    // output buffer to know whether or not an error has actually occurred.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
        (IrpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_SCSI_PASS_THROUGH_DIRECT) &&
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0)) {

        RtlCopyMemory(Irp->UserBuffer, SenseData, sizeof(SENSE_DATA));

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = sizeof(SENSE_DATA);
    }

    //
    // The request cannot be retried or the retry count has exceeded the limit, so
    // complete the IRP and start the next request.
    //

CompleteRequest:
    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexCdRomFinishGeneric(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    CDB Cdb;

    Irp = IdexChannelObject.CurrentIrp;

    if (Irp->IoStatus.Status == STATUS_IO_DEVICE_ERROR) {

        //
        // The command completed with an error.  Request the sense data so that
        // we can return a more useful error to the caller.
        //

        RtlZeroMemory(&Cdb, sizeof(CDB));

        Cdb.CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
        Cdb.CDB6INQUIRY.AllocationLength = sizeof(SENSE_DATA);

        IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
            sizeof(SENSE_DATA), FALSE, IdexCdRomFinishRequestSense);

        return;

    } else if (Irp->IoStatus.Status == STATUS_IO_TIMEOUT) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

        IdexCdRomResetDevice();

        return;
    }

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexCdRomFinishGenericWithOverrun(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

    If the request completed with STATUS_DATA_OVERRUN, then this is converted
    to STATUS_SUCCESS.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    //
    // The media may not have enough data to fill the output buffer, but this
    // isn't an error.
    //

    if (Irp->IoStatus.Status == STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartReadTOC(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_READ_TOC and
    IOCTL_CDROM_GET_LAST_SESSION requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG TransferLength;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    TransferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Verify that the output buffer and length is non-zero and has the proper
    // alignment requirement.
    //

    if ((TransferLength == 0) ||
        ((TransferLength & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
        ((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // The maximum transfer length for the TOC is sizeof(CDROM_TOC).
    //

    if (TransferLength > sizeof(CDROM_TOC)) {
        TransferLength = sizeof(CDROM_TOC);
    }

    //
    // Lock the user's buffer into memory if necessary.
    //

    IoLockUserBuffer(Irp, TransferLength);

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = TransferLength;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.READ_TOC.OperationCode = SCSIOP_READ_TOC;
    *((PUSHORT)Cdb.READ_TOC.AllocationLength) = RtlUshortByteSwap((USHORT)TransferLength);

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_TOC) {
        Cdb.READ_TOC.Msf = CDB_USE_MSF;
    } else {
        Cdb.READ_TOC.Format = GET_LAST_SESSION;
    }

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, Irp->UserBuffer, TransferLength, FALSE,
        IdexCdRomFinishGenericWithOverrun);
}

VOID
FASTCALL
IdexCdRomStartCheckVerify(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_CHECK_VERIFY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    CDB Cdb;

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.CDB6GENERIC.OperationCode = SCSIOP_TEST_UNIT_READY;

    //
    // No retries are allowed for this IRP.
    //

    IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, NULL, 0, FALSE, IdexCdRomFinishGeneric);
}

VOID
IdexCdRomFinishGetDriveGeometry(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_CDROM_GET_DRIVE_GEOMETRY request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PREAD_CAPACITY_DATA ReadCapacity;
    ULONG NumberOfSectors;
    PDISK_GEOMETRY DiskGeometry;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // Compute the drive's geometry.
    //

    ReadCapacity = (PREAD_CAPACITY_DATA)IdexCdRomStaticTransferBuffer;
    NumberOfSectors = RtlUlongByteSwap(ReadCapacity->LogicalBlockAddress) + 1;
    IdexCdRomPartitionLength = (ULONGLONG)NumberOfSectors * IDE_ATAPI_CD_SECTOR_SIZE;

    DiskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
    DiskGeometry->Cylinders.QuadPart = NumberOfSectors;
    DiskGeometry->MediaType = RemovableMedia;
    DiskGeometry->TracksPerCylinder = 1;
    DiskGeometry->SectorsPerTrack = 1;
    DiskGeometry->BytesPerSector = IDE_ATAPI_CD_SECTOR_SIZE;

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartGetDriveGeometry(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_GET_DRIVE_GEOMETRY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    CDB Cdb;

    ASSERT(sizeof(IdexCdRomStaticTransferBuffer) >= sizeof(READ_CAPACITY_DATA));

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.CDB6GENERIC.OperationCode = SCSIOP_READ_CAPACITY;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        sizeof(READ_CAPACITY_DATA), FALSE, IdexCdRomFinishGetDriveGeometry);
}

VOID
FASTCALL
IdexCdRomStartRawRead(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_RAW_READ requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PRAW_READ_INFO RawReadInfo;
    ULONG StartingSector;
    ULONG TransferLength;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(RAW_READ_INFO)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    RawReadInfo = (PRAW_READ_INFO)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Compute the logical block address and transfer length for the request.
    //

    StartingSector = (ULONG)(RawReadInfo->DiskOffset.QuadPart >>
        IDE_ATAPI_CD_SECTOR_SHIFT);
    TransferLength = RawReadInfo->SectorCount * IDE_ATAPI_RAW_CD_SECTOR_SIZE;

    //
    // Verify that the parameters are valid.  The requested read length must be
    // less than the maximum transfer size, the ending offset must be in within
    // the bounds of the disk, the output buffer must have enough bytes to
    // contain the read length, and the output buffer must have the proper
    // alignment requirement.
    //

    if ((RawReadInfo->SectorCount > (IDE_ATAPI_MAXIMUM_TRANSFER_BYTES / IDE_ATAPI_RAW_CD_SECTOR_SIZE) + 1) ||
        (TransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) ||
        ((RawReadInfo->DiskOffset.QuadPart + TransferLength) > IdexCdRomPartitionLength) ||
        ((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = TransferLength;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.READ_CD.OperationCode = SCSIOP_READ_CD;
    *((PULONG)Cdb.READ_CD.StartingLBA) = RtlUlongByteSwap(StartingSector);
    Cdb.READ_CD.TransferBlocks[2] = (UCHAR)(RawReadInfo->SectorCount);
    Cdb.READ_CD.TransferBlocks[1] = (UCHAR)(RawReadInfo->SectorCount >> 8);
    Cdb.READ_CD.TransferBlocks[0] = (UCHAR)(RawReadInfo->SectorCount >> 16);

    switch (RawReadInfo->TrackMode) {

        case CDDA:
            Cdb.READ_CD.ExpectedSectorType = 1;
            Cdb.READ_CD.IncludeUserData = 1;
            Cdb.READ_CD.HeaderCode = 3;
            Cdb.READ_CD.IncludeSyncData = 1;
            break;

        case YellowMode2:
            Cdb.READ_CD.ExpectedSectorType = 3;
            Cdb.READ_CD.IncludeUserData = 1;
            Cdb.READ_CD.HeaderCode = 1;
            Cdb.READ_CD.IncludeSyncData = 1;
            break;

        case XAForm2:
            Cdb.READ_CD.ExpectedSectorType = 5;
            Cdb.READ_CD.IncludeUserData = 1;
            Cdb.READ_CD.HeaderCode = 3;
            Cdb.READ_CD.IncludeSyncData = 1;
            break;

        default:
            IdexChannelInvalidParameterRequest(Irp);
            return;
    }

    //
    // No retries are allowed for this IRP.
    //

    IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, Irp->UserBuffer, TransferLength, FALSE,
        IdexCdRomFinishGeneric);
}

VOID
FASTCALL
IdexCdRomStartSetSpindleSpeed(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_CDROM_SET_SPINDLE_SPEED requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PULONG SpindleSpeedControl;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength != sizeof(ULONG)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    SpindleSpeedControl = (PULONG)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that this is a valid spindle speed.
    //

    if (*SpindleSpeedControl > DVDX2_SPINDLE_SPEED_MAXIMUM) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Change the maximum spindle speed to the requested spindle speed.  Note
    // that if the drive fails to handle the below ATAPI request, the software
    // state won't match the hardware state, but that's not likely to occur and
    // won't cause any problems for the drive or driver, so we'll ignore that
    // possibility.
    //

    IdexCdRomMaximumSpindleSpeed = *SpindleSpeedControl;

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Issue the ATAPI spindle speed control request.
    //

    IdexCdRomSetSpindleSpeed(*SpindleSpeedControl, IdexCdRomFinishGeneric);
}

VOID
IdexCdRomFinishStartSession(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_DVD_START_SESSION request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PCDVD_KEY_HEADER KeyHeader;
    PCDVD_REPORT_AGID_DATA ReportAGIDData;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // Copy the authentication grant ID (AGID) to the user's buffer.
    //

    KeyHeader = (PCDVD_KEY_HEADER)IdexCdRomStaticTransferBuffer;
    ReportAGIDData = (PCDVD_REPORT_AGID_DATA)KeyHeader->Data;
    *((PDVD_SESSION_ID)Irp->UserBuffer) = ReportAGIDData->AGID;

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartStartSession(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_START_SESSION requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    CDB Cdb;

    ASSERT(sizeof(IdexCdRomStaticTransferBuffer) >= sizeof(CDVD_KEY_HEADER) +
        sizeof(CDVD_REPORT_AGID_DATA));

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DVD_SESSION_ID)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = sizeof(DVD_SESSION_ID);

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.REPORT_KEY.OperationCode = SCSIOP_REPORT_KEY;
    *((PUSHORT)Cdb.REPORT_KEY.AllocationLength) =
        IdexConstantUshortByteSwap(sizeof(CDVD_KEY_HEADER) + sizeof(CDVD_REPORT_AGID_DATA));

    ASSERT(Cdb.REPORT_KEY.KeyFormat == DVD_REPORT_AGID);
    ASSERT(Cdb.REPORT_KEY.AGID == 0);

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        sizeof(CDVD_KEY_HEADER) + sizeof(CDVD_REPORT_AGID_DATA), FALSE,
        IdexCdRomFinishStartSession);
}

VOID
IdexCdRomFinishReadKey(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_DVD_READ_KEY request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PCDVD_KEY_HEADER KeyHeader;
    PDVD_COPY_PROTECT_KEY CopyProtectKey;
    ULONG KeyDataLength;
    ULONG TransferLength;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // The media may not have enough data to fill the output buffer, but this
    // isn't an error.
    //

    if (Irp->IoStatus.Status == STATUS_DATA_OVERRUN) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    KeyHeader = (PCDVD_KEY_HEADER)IdexCdRomStaticTransferBuffer;
    CopyProtectKey = (PDVD_COPY_PROTECT_KEY)Irp->UserBuffer;

    //
    // Compute the number of bytes that the device should have returned for the
    // given key format and the number of bytes that were actually transferred.
    // We're not returning the Reserved bytes in the CDVD_KEY_HEADER to the
    // caller, so subtract these from the length of the key.
    //

    KeyDataLength = RtlUshortByteSwap(*((PUSHORT)&KeyHeader->DataLength));

    if (KeyDataLength > sizeof(KeyHeader->Reserved)) {
        KeyDataLength -= sizeof(KeyHeader->Reserved);
    }

    TransferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
        sizeof(DVD_COPY_PROTECT_KEY);

    if (KeyDataLength < TransferLength) {
        TransferLength = KeyDataLength;
    }

    //
    // Copy the input buffer's DVD_COPY_PROTECT_KEY structure to the output
    // buffer.  The I/O manager doesn't handle buffered I/O by using the same
    // input and output buffer, so we need to do this copy ourselves.
    //

    RtlCopyMemory(CopyProtectKey, IrpSp->Parameters.DeviceIoControl.InputBuffer,
        sizeof(DVD_COPY_PROTECT_KEY));

    //
    // Copy the key data to the output buffer as appropriate.
    //

    if (CopyProtectKey->KeyType == DvdTitleKey) {
        RtlCopyMemory(CopyProtectKey->KeyData, KeyHeader->Data + 1,
            TransferLength - 1);
        CopyProtectKey->KeyData[TransferLength - 1] = 0;
        CopyProtectKey->KeyFlags = KeyHeader->Data[0];
    } else {
        RtlCopyMemory(CopyProtectKey->KeyData, KeyHeader->Data, TransferLength);
    }

    CopyProtectKey->KeyLength = sizeof(DVD_COPY_PROTECT_KEY) + TransferLength;

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = CopyProtectKey->KeyLength;

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexCdRomStartReadKey(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_READ_KEY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_COPY_PROTECT_KEY CopyProtectKey;
    ULONG TransferLength;
    ULONG LogicalBlockAddress;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_COPY_PROTECT_KEY)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    CopyProtectKey = (PDVD_COPY_PROTECT_KEY)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the output buffer is large enough to receive at least the
    // DVD_COPY_PROTECT_KEY header.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DVD_COPY_PROTECT_KEY)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Compute the transfer length for the request.  The transfer length is
    // restricted to the static tranfer buffer length.
    //

    TransferLength = sizeof(CDVD_KEY_HEADER) +
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength -
        sizeof(DVD_COPY_PROTECT_KEY);

    if (TransferLength > sizeof(IdexCdRomStaticTransferBuffer)) {
        IdexDbgPrint(("IDEX: transfer length exceeds static buffer length.\n"));
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.REPORT_KEY.OperationCode = SCSIOP_REPORT_KEY;
    *((PUSHORT)Cdb.REPORT_KEY.AllocationLength) =
        RtlUshortByteSwap((USHORT)TransferLength);
    Cdb.REPORT_KEY.KeyFormat = (UCHAR)CopyProtectKey->KeyType;
    Cdb.REPORT_KEY.AGID = (UCHAR)CopyProtectKey->SessionId;

    if (CopyProtectKey->KeyType == DvdTitleKey) {
        LogicalBlockAddress = (ULONG)(CopyProtectKey->Parameters.TitleOffset.QuadPart >>
            IDE_ATAPI_CD_SECTOR_SHIFT);
        *((PULONG)Cdb.REPORT_KEY.LogicalBlockAddress) =
            RtlUlongByteSwap(LogicalBlockAddress);
    }

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        TransferLength, FALSE, IdexCdRomFinishReadKey);
}

VOID
FASTCALL
IdexCdRomStartSendKey(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_SEND_KEY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_COPY_PROTECT_KEY CopyProtectKey;
    ULONG TransferLength;
    PCDVD_KEY_HEADER KeyHeader;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_COPY_PROTECT_KEY)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    CopyProtectKey = (PDVD_COPY_PROTECT_KEY)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Compute the transfer length for the request.  The transfer length is
    // restricted to the static tranfer buffer length.
    //

    TransferLength = CopyProtectKey->KeyLength - sizeof(DVD_COPY_PROTECT_KEY) +
        sizeof(CDVD_KEY_HEADER);

    if (TransferLength > sizeof(IdexCdRomStaticTransferBuffer)) {
        IdexDbgPrint(("IDEX: transfer length exceeds static buffer length.\n"));
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Prepare the transfer buffer.
    //

    KeyHeader = (PCDVD_KEY_HEADER)IdexCdRomStaticTransferBuffer;
    *((PUSHORT)KeyHeader->DataLength) = RtlUshortByteSwap((USHORT)(TransferLength -
        FIELD_OFFSET(CDVD_KEY_HEADER, Reserved)));
    RtlZeroMemory(KeyHeader->Reserved, sizeof(KeyHeader->Reserved));
    RtlCopyMemory(KeyHeader->Data, CopyProtectKey->KeyData, TransferLength -
        sizeof(CDVD_KEY_HEADER));

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.SEND_KEY.OperationCode = SCSIOP_SEND_KEY;
    *((PUSHORT)Cdb.SEND_KEY.ParameterListLength) =
        RtlUshortByteSwap((USHORT)TransferLength);
    Cdb.SEND_KEY.KeyFormat = (UCHAR)CopyProtectKey->KeyType;
    Cdb.SEND_KEY.AGID = (UCHAR)CopyProtectKey->SessionId;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, IdexCdRomStaticTransferBuffer,
        TransferLength, TRUE, IdexCdRomFinishGeneric);
}

VOID
FASTCALL
IdexCdRomStartEndSession(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_END_SESSION requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_SESSION_ID SessionId;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_SESSION_ID)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    SessionId = (PDVD_SESSION_ID)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DVD_SESSION_ID)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.SEND_KEY.OperationCode = SCSIOP_SEND_KEY;
    Cdb.SEND_KEY.AGID = (UCHAR)*SessionId;
    Cdb.SEND_KEY.KeyFormat = DVD_INVALIDATE_AGID;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, NULL, 0, FALSE, IdexCdRomFinishGeneric);
}

VOID
IdexCdRomStartReadStructure(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DVD_READ_STRUCTURE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDVD_READ_STRUCTURE ReadStructure;
    ULONG TransferLength;
    ULONG MinimumTransferLength;
    ULONG LogicalBlockAddress;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(DVD_READ_STRUCTURE)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    ReadStructure = (PDVD_READ_STRUCTURE)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the output buffer is large enough to receive the data, but
    // isn't too large to overflow READ_DVD_STRUCTURES_HEADER.Length.  The read
    // length must have the proper alignment.
    //

    TransferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (ReadStructure->Format == DvdPhysicalDescriptor) {
        MinimumTransferLength = sizeof(DVD_DESCRIPTOR_HEADER) +
            sizeof(DVD_LAYER_DESCRIPTOR);
    } else {
        MinimumTransferLength = sizeof(DVD_DESCRIPTOR_HEADER);
    }

    if ((TransferLength < MinimumTransferLength) ||
        (TransferLength > MAXUSHORT) ||
        ((TransferLength & IDE_ALIGNMENT_REQUIREMENT) != 0)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Compute the logical block address.
    //

    LogicalBlockAddress = (ULONG)(ReadStructure->BlockByteOffset.QuadPart >>
        IDE_ATAPI_CD_SECTOR_SHIFT);

    //
    // Lock the user's buffer into memory if necessary.
    //

    IoLockUserBuffer(Irp, TransferLength);

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = TransferLength;

    //
    // Prepare the SCSI CDB.
    //

    Cdb.READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
    *((PUSHORT)Cdb.READ_DVD_STRUCTURE.AllocationLength) =
        RtlUshortByteSwap((USHORT)TransferLength);
    *((PULONG)Cdb.READ_DVD_STRUCTURE.RMDBlockNumber) =
        RtlUlongByteSwap(LogicalBlockAddress);
    Cdb.READ_DVD_STRUCTURE.LayerNumber = ReadStructure->LayerNumber;
    Cdb.READ_DVD_STRUCTURE.Format = (UCHAR)ReadStructure->Format;

    if (IdexIsFlagSet(ReadStructure->LayerNumber, 0x80)) {
        Cdb.READ_DVD_STRUCTURE.Control = 0xC0;
    }

    if (ReadStructure->Format == DvdDiskKeyDescriptor) {
        Cdb.READ_DVD_STRUCTURE.AGID = (UCHAR)ReadStructure->SessionId;
    }

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest(&Cdb, Irp->UserBuffer, TransferLength, FALSE,
        IdexCdRomFinishGenericWithOverrun);
}

VOID
IdexCdRomFinishScsiPassThrough(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a
    IOCTL_SCSI_PASS_THROUGH_DIRECT request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    PSCSI_PASS_THROUGH_DIRECT PassThrough;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PassThrough =
        (PSCSI_PASS_THROUGH_DIRECT)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Manually unlock the caller's data buffer if IdexCdRomStartScsiPassThrough
    // locked down the buffer.
    //

    if (PassThrough->DataTransferLength != 0) {
        MmLockUnlockBufferPages(PassThrough->DataBuffer,
            PassThrough->DataTransferLength, TRUE);
    }

    //
    // Jump to the generic handler.
    //

    IdexCdRomFinishGeneric();
}

VOID
FASTCALL
IdexCdRomStartScsiPassThrough(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_SCSI_PASS_THROUGH_DIRECT requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PSCSI_PASS_THROUGH_DIRECT PassThrough;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is either empty or large enough to receive
    // the sense data.
    //

    if ((IrpSp->Parameters.DeviceIoControl.OutputBufferLength != 0) &&
        (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(SENSE_DATA))) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(SCSI_PASS_THROUGH_DIRECT)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    PassThrough =
        (PSCSI_PASS_THROUGH_DIRECT)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Perform minimal verification of the contents of the pass through data
    // structure and the data transfer buffer.
    //

    if ((PassThrough->Length != sizeof(SCSI_PASS_THROUGH_DIRECT)) ||
        (PassThrough->DataTransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) ||
        (((ULONG_PTR)PassThrough->DataBuffer & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
        ((PassThrough->DataTransferLength & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
        (PassThrough->DataTransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES)) {
        IdexChannelInvalidParameterRequest(Irp);
        return;
    }

    //
    // If the caller is expecting data to be transferred, then manually lock
    // down the pages.
    //

    if (PassThrough->DataTransferLength != 0) {
        MmLockUnlockBufferPages(PassThrough->DataBuffer,
            PassThrough->DataTransferLength, FALSE);
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Issue the ATAPI request.
    //

    IdexCdRomIssueAtapiRequest((PCDB)&PassThrough->Cdb, PassThrough->DataBuffer,
        PassThrough->DataTransferLength, (BOOLEAN)(PassThrough->DataIn ==
        SCSI_IOCTL_DATA_OUT), IdexCdRomFinishScsiPassThrough);
}

VOID
IdexCdRomFinishRead(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a IRP_MJ_READ
    request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

#if DBG
    //
    // Keep track of the number of reads that have been completed.
    //

    IdexCdRomDebugReadsFinished++;
#endif

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexCdRomFinishGeneric();
        return;
    }

    //
    // If there are still more bytes to transfer in this request, then adjust
    // the transfer counts and requeue the packet.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) {

        IrpSp->Parameters.IdexReadWrite.Length -= IDE_ATAPI_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.BufferOffset += IDE_ATAPI_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.SectorNumber += IDE_ATAPI_CD_MAXIMUM_TRANSFER_SECTORS;

        IdexChannelStartPacket(IrpSp->DeviceObject, Irp);
        IdexChannelStartNextPacket();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_CD_ROM_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexCdRomStartRead(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_READ and IRP_MJ_WRITE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG TransferLength;
    ULONG NumberOfSectors;
    CDB Cdb;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If the number of bytes remaining is greater than the maximum transfer
    // size allowed by the hardware, then clip the number of bytes to the
    // maximum.
    //

    TransferLength = IrpSp->Parameters.IdexReadWrite.Length;

    if (TransferLength > IDE_ATAPI_MAXIMUM_TRANSFER_BYTES) {
        TransferLength = IDE_ATAPI_MAXIMUM_TRANSFER_BYTES;
    }

    NumberOfSectors = (TransferLength >> IDE_ATAPI_CD_SECTOR_SHIFT);

    //
    // Check if the current spindle speed is less than the maximum speed and if
    // the spindle speed can be restored to normal.  If so, then this will have
    // issued an ATAPI request that on completion, will cause this routine to be
    // called again.
    //

    if ((IdexCdRomCurrentSpindleSpeed < IdexCdRomMaximumSpindleSpeed) &&
        IdexCdRomCheckForRestoreSpindleSpeed(IrpSp->Parameters.IdexReadWrite.SectorNumber,
            NumberOfSectors)) {
        return;
    }

    //
    // Prepare the SCSI CDB.
    //

    RtlZeroMemory(&Cdb, sizeof(CDB));

    Cdb.CDB10.OperationCode = SCSIOP_READ;
    Cdb.CDB10.LogicalBlock = RtlUlongByteSwap(IrpSp->Parameters.IdexReadWrite.SectorNumber);
    Cdb.CDB10.TransferBlocks = RtlUshortByteSwap((USHORT)NumberOfSectors);

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexCdRomSelectDeviceAndSpinWhileBusy()) {
        IdexCdRomFinishRead();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (IdexIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION) ||
        IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IdexChannelPrepareBufferTransfer(IrpSp->Parameters.IdexReadWrite.Buffer +
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    } else {
        IdexChannelPrepareScatterGatherTransfer(Irp->SegmentArray,
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    }

    IdexWriteFeaturesPort(IDE_FEATURE_DMA);

    //
    // Write out the IDE command and the SCSI CDB.
    //

    if (!IdexCdRomWritePacket(&Cdb)) {
        IdexCdRomFinishRead();
        return;
    }

    //
    // Activate the bus master interface.
    //

    IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
        IDE_BUS_MASTER_COMMAND_READ);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexCdRomTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexCdRomFinishRead;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATAPI_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexCdRomRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle IRP_MJ_READ
    requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    LONGLONG StartingByteOffset;
    LONGLONG EndingByteOffset;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the parameters are valid.  The buffer length must be an
    // integral number of sectors, the starting offset must be sector aligned,
    // and the ending offset must be within the bounds of the disk.  The I/O
    // buffer must have the proper device alignment.
    //

    StartingByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    EndingByteOffset = StartingByteOffset + IrpSp->Parameters.Read.Length;

    if (IdexIsFlagClear(IrpSp->Flags, SL_FSCACHE_REQUEST)) {

        if (((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.BufferOffset & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.Length & IDE_ATAPI_CD_SECTOR_MASK) != 0) ||
            ((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATAPI_CD_SECTOR_MASK) != 0) ||
            (EndingByteOffset > IdexCdRomPartitionLength)) {

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Bypass parameter checking if this request is coming from the cache.
        // We'll trust that the file system cache is submitting a valid request,
        // but we'll double check in debug.
        //

        ASSERT((PtrToUlong(IrpSp->Parameters.Read.CacheBuffer) &
            IDE_ATAPI_CD_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.Length & IDE_ATAPI_CD_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATAPI_CD_SECTOR_MASK) == 0);
        ASSERT(EndingByteOffset <= IdexCdRomPartitionLength);
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format unpacks the cache buffer and buffer offset fields to
    // different fields by collapsing the byte offset to a sector number.
    //

    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATAPI_CD_SECTOR_SHIFT);

    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
           FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Length));

    //
    // Move the buffer pointer and the buffer starting offset around depending
    // on whether or not this is a file system cache request.
    //

    if (IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IrpSp->Parameters.IdexReadWrite.BufferOffset = 0;
        ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.CacheBuffer) ==
               FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Buffer));
    } else {
        IrpSp->Parameters.IdexReadWrite.BufferOffset =
            IrpSp->Parameters.Read.BufferOffset;
        IrpSp->Parameters.IdexReadWrite.Buffer = (PUCHAR)Irp->UserBuffer;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.IdexReadWrite.Length;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
IdexCdRomRequestDVDX2AuthenticationPage(
    OUT PDVDX2_AUTHENTICATION Authentication
    )
/*++

Routine Description:

    This routine requests the DVD-X2 authentication page from the CD-ROM device.

Arguments:

    Authentication - Specifies the buffer to receive the authentication page.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Request the authentication page from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    RtlZeroMemory(Authentication, sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {

        //
        // If the drive reported back an authentication failure at this point,
        // then change the error to STATUS_UNRECOGNIZED_MEDIA to help
        // distinguish between a disc that doesn't contain any anti-piracy
        // protection from a disc that failed the anti-piracy checks below.
        //

        if (status == STATUS_TOO_MANY_SECRETS) {
            return STATUS_UNRECOGNIZED_MEDIA;
        } else {
            return status;
        }
    }

    //
    // Check if the DVD-X2 drive thinks that this is a valid CDF header.
    //

    if (Authentication->AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
        return STATUS_UNRECOGNIZED_MEDIA;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexCdRomRequestDVDX2ControlData(
    OUT PDVDX2_CONTROL_DATA ControlData
    )
/*++

Routine Description:

    This routine requests the DVD-X2 control data structure from the CD-ROM
    device.

Arguments:

    ControlData - Specifies the buffer to receive the control data structure.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Request the control data structure from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = ControlData;
    PassThrough.DataTransferLength = sizeof(DVDX2_CONTROL_DATA);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
    *((PUSHORT)&Cdb->READ_DVD_STRUCTURE.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_CONTROL_DATA));
    *((PULONG)Cdb->READ_DVD_STRUCTURE.RMDBlockNumber) =
        IdexConstantUlongByteSwap((ULONG)(~DVDX2_CONTROL_DATA_BLOCK_NUMBER));
    Cdb->READ_DVD_STRUCTURE.LayerNumber = (UCHAR)(~DVDX2_CONTROL_DATA_LAYER);
    Cdb->READ_DVD_STRUCTURE.Format = DvdPhysicalDescriptor;
    Cdb->READ_DVD_STRUCTURE.Control = 0xC0;

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: control data read failed (status=%08x).\n", status));
    }

    return status;
}

/*## -- not necessary
NTSTATUS
IdexCdRomVerifyDVDX2AuthoringSignature(
    IN PDVDX2_CONTROL_DATA ControlData
    )
*++

Routine Description:

    This routine verifies the authoring signature of the supplied DVD-X2 control
    data structure.

Arguments:

    ControlData - Specifies the control data structure to be verified.

Return Value:

    Status of operation.

--*
{
    PUCHAR PublicKeyData;
    UCHAR AuthoringDigest[XC_DIGEST_LEN];
    PUCHAR Workspace;
    BOOLEAN Verified;

    PublicKeyData = XePublicKeyData;

    //
    // Calculate the digest for bytes 0 to 1226 of the control data structure
    // and verify that this matches the authoring hash stored in the control
    // data structure.
    //

    XCCalcDigest((PUCHAR)&ControlData->LayerDescriptor,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, LayerDescriptor), AuthoringDigest);

    if (!RtlEqualMemory(AuthoringDigest, ControlData->AuthoringHash,
        XC_DIGEST_LEN)) {
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Allocate a workspace to do the digest verification.
    //

    Workspace = (PUCHAR)ExAllocatePoolWithTag(XCCalcKeyLen(PublicKeyData) * 2,
        'sWxI');

    if (Workspace == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Verify that the SHA1 digest matches the encrypted header digest.
    //

    Verified = XCVerifyDigest(ControlData->AuthoringSignature, PublicKeyData,
        Workspace, AuthoringDigest);

    ExFreePool(Workspace);

    if (Verified) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_TOO_MANY_SECRETS;
    }
}*/

VOID
IdexCdRomDecryptHostChallengeResponseTable(
    IN PDVDX2_CONTROL_DATA ControlData
    )
/*++

Routine Description:

    This routine decrypts the host challenge response table of the supplied
    DVD-X2 control data structure.

Arguments:

    ControlData - Specifies the control data structure that contains the host
        challenge response table to be decrypted.

Return Value:

    None.

--*/
{
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT RC4KeyStruct;

    //
    // Compute the SHA-1 hash of the data between bytes 1183 to 1226 of the
    // control data structure.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)&ControlData->AuthoringTimeStamp,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringTimeStamp));
    A_SHAFinal(&SHAHash, SHADigest);

    //
    // Compute a 56-bit RC4 session key from the SHA-1 hash.
    //

    rc4_key(&RC4KeyStruct, 56 / 8, SHADigest);

    //
    // Decrypt the host challenge response table in place using the RC4 session
    // key.
    //

    rc4(&RC4KeyStruct, sizeof(ControlData->HostChallengeResponseTable.Entries),
        (PUCHAR)&ControlData->HostChallengeResponseTable.Entries);
}

NTSTATUS
IdexCdRomAuthenticationChallenge(
    IN PDVDX2_CONTROL_DATA ControlData,
    IN PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY HostChallengeResponseEntry,
    IN BOOLEAN FirstChallenge,
    IN BOOLEAN FinalChallenge
    )
/*++

Routine Description:

    This routine issues the supplied challenge to the drive and checks the
    response from the drive.

Arguments:

    ControlData - Specifies the control data structure.

    HostChallengeResponseEntry - Specifies the challenge to issue.

    FirstChallenge - Specifies TRUE if this is the first challenge being made to
        the drive.

    FinalChallenge - Specifies TRUE if this is the final challenge being made to
        the drive.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    DVDX2_AUTHENTICATION Authentication;

    ASSERT(HostChallengeResponseEntry->ChallengeLevel == 1);

    //
    // Prepare the SCSI pass through structure.
    //

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

    //
    // Prepare the authentication page.
    //

    RtlZeroMemory(&Authentication, sizeof(DVDX2_AUTHENTICATION));

    *((PUSHORT)&Authentication.Header.ModeDataLength) =
        IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION) -
        FIELD_OFFSET(DVDX2_AUTHENTICATION, Header.MediumType));
    Authentication.AuthenticationPage.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    Authentication.AuthenticationPage.PageLength = sizeof(DVDX2_AUTHENTICATION_PAGE) -
        FIELD_OFFSET(DVDX2_AUTHENTICATION_PAGE, PartitionArea);
    Authentication.AuthenticationPage.CDFValid = 1;
    Authentication.AuthenticationPage.DiscCategoryAndVersion =
        (ControlData->LayerDescriptor.BookType << 4) +
        ControlData->LayerDescriptor.BookVersion;
    Authentication.AuthenticationPage.DrivePhaseLevel = 1;
    Authentication.AuthenticationPage.ChallengeID = HostChallengeResponseEntry->ChallengeID;
    Authentication.AuthenticationPage.ChallengeValue = HostChallengeResponseEntry->ChallengeValue;

    if (!FirstChallenge) {
        Authentication.AuthenticationPage.Authentication = 1;
    }

    if (FinalChallenge) {
        Authentication.AuthenticationPage.PartitionArea = 1;
    }

    //
    // Issue the challenge to the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
    PassThrough.DataBuffer = &Authentication;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);

    RtlZeroMemory(Cdb, sizeof(CDB));

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: challenge operation failed (status=%08x).\n", status));
        return status;
    }

    //
    // Read the response from the DVD-X2 drive.
    //

    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;

    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

    status = IoSynchronousDeviceIoControlRequest(IOCTL_SCSI_PASS_THROUGH_DIRECT,
        IdexCdRomDeviceObject, &PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT),
        NULL, 0, NULL, FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: response operation failed (status=%08x).\n", status));
        return status;
    }

    //
    // Check that the drive's response matches the expected response.
    //

    if (!Authentication.AuthenticationPage.Authentication ||
        (Authentication.AuthenticationPage.ResponseValue !=
        HostChallengeResponseEntry->ResponseValue)) {
        IdexDbgPrint(("IDEX: invalid response from drive.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexCdRomAuthenticationSequence(
    VOID
    )
/*++

Routine Description:

    This routine handles the IOCTL_CDROM_AUTHENTICATION_SEQUENCE request.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    DVDX2_AUTHENTICATION Authentication;
    DVDX2_CONTROL_DATA ControlData;
    LONG StartingIndex;
    LONG Index;
    LONG EndingIndex;
    BOOLEAN FirstChallenge;
    PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY HostChallengeResponseEntry;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // If we've already authenticated the DVD-X2 disc, then don't bother doing
    // it again.
    //

    if (IdexCdRomDVDX2Authenticated) {
        return STATUS_SUCCESS;
    }

    //
    // Request the authentication page from the DVD-X2 drive.
    //

    status = IdexCdRomRequestDVDX2AuthenticationPage(&Authentication);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Request the control data structure from the DVD-X2 drive.
    //

    status = IdexCdRomRequestDVDX2ControlData(&ControlData);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Verify that the disc category and version from the authentication page
    // matches the control data structure.
    //

    if (Authentication.AuthenticationPage.DiscCategoryAndVersion !=
        (ControlData.LayerDescriptor.BookType << 4) + ControlData.LayerDescriptor.BookVersion) {
        IdexDbgPrint(("IDEX: disc category and version mismatch.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

//## -- we're going to need this on retail systems for shadow boot!
//#ifdef DEVKIT
    //
    // Check if the DVD-X2 drive already thinks that we're authenticated.  This
    // can only happen in a DEVKIT environment where we loaded a ROM from the
    // CD-ROM or hard disk and cold booted into that ROM.  The second instance
    // of the ROM doesn't know if the first instance of the ROM already ran the
    // authentication sequence, so we rely on the the drive.
    //

    if ((Authentication.AuthenticationPage.PartitionArea != 0) &&
        (Authentication.AuthenticationPage.Authentication != 0)) {
        IdexCdRomDVDX2Authenticated = TRUE;
        return STATUS_SUCCESS;
    }
//#endif

    //
    // Verify that the encrypted digest stored in the control data structure
    // matches the digest of the structure.
    //

//## -- unnecessary
/*    status = IdexCdRomVerifyDVDX2AuthoringSignature(&ControlData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: failed to verify control data structure (status=%08x).\n", status));
        return status;
    }*/

    //
    // Decrypt the contents of the host challenge response table.
    //

    IdexCdRomDecryptHostChallengeResponseTable(&ControlData);

    //
    // Validate the the host challenge response table is the expected version
    // and that there are the expected number of entries in the table.
    //

    if ((ControlData.HostChallengeResponseTable.Version != 1) ||
        (ControlData.HostChallengeResponseTable.NumberOfEntries == 0) ||
        (ControlData.HostChallengeResponseTable.NumberOfEntries >
            DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT)) {
        IdexDbgPrint(("IDEX: invalid host challenge response table.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Walk through the host challenge response starting at a random starting
    // index and issue challenge response values.
    //

    StartingIndex = KeQueryPerformanceCounter().LowPart %
        ControlData.HostChallengeResponseTable.NumberOfEntries;
    Index = StartingIndex;
    EndingIndex = -1;
    FirstChallenge = TRUE;

    do {

        HostChallengeResponseEntry = &ControlData.HostChallengeResponseTable.Entries[Index];

        //
        // Check if this is a supported challenge level.  If so, issue the
        // authentication challenge to the DVD-X2 drive.
        //

        if (HostChallengeResponseEntry->ChallengeLevel == 1) {

            status = IdexCdRomAuthenticationChallenge(&ControlData,
                HostChallengeResponseEntry, FirstChallenge, FALSE);

            if (!NT_SUCCESS(status)) {
                return status;
            }

            EndingIndex = Index;
            FirstChallenge = FALSE;
        }

        //
        // Advance the index and jump back to zero if we reach the end of the
        // table.
        //

        Index++;

        if (Index == ControlData.HostChallengeResponseTable.NumberOfEntries) {
            Index = 0;
        }

    } while (Index != StartingIndex);

    //
    // If we found a challenge response table with no entries that we can
    // process, then fail authentication.  We need at least one entry in order
    // to issue the final request to switch to the Xbox partition.
    //

    if (EndingIndex == -1) {
        IdexDbgPrint(("IDEX: no usable challenge response entries.\n"));
        return STATUS_TOO_MANY_SECRETS;
    }

    //
    // Issue the last challenge response entry again, but this time switch to
    // the Xbox partition.
    //

    HostChallengeResponseEntry = &ControlData.HostChallengeResponseTable.Entries[EndingIndex];

    status = IdexCdRomAuthenticationChallenge(&ControlData,
        HostChallengeResponseEntry, FALSE, TRUE);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Remember that the disc has passed DVD-X2 authentication.
    //

    IdexCdRomDVDX2Authenticated = TRUE;

    return STATUS_SUCCESS;
}

NTSTATUS
IdexCdRomDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CDROM_READ_TOC:
        case IOCTL_CDROM_GET_LAST_SESSION:
        case IOCTL_CDROM_CHECK_VERIFY:
        case IOCTL_CDROM_GET_DRIVE_GEOMETRY:
        case IOCTL_CDROM_RAW_READ:
        case IOCTL_CDROM_SET_SPINDLE_SPEED:
        case IOCTL_DVD_START_SESSION:
        case IOCTL_DVD_READ_KEY:
        case IOCTL_DVD_SEND_KEY:
        case IOCTL_DVD_END_SESSION:
        case IOCTL_DVD_SEND_KEY2:
        case IOCTL_DVD_READ_STRUCTURE:
        case IOCTL_IDE_PASS_THROUGH:
        case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            IoMarkIrpPending(Irp);
            IdexChannelStartPacket(DeviceObject, Irp);
            status = STATUS_PENDING;
            break;

        case IOCTL_CDROM_AUTHENTICATION_SEQUENCE:
            status = IdexCdRomAuthenticationSequence();
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // If the request is no longer pending, then complete the request.
    //

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
IdexCdRomStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the channel to handle the next queued I/O request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Dispatch the IRP request.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_READ:
            IdexCdRomStartRead(Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_CDROM_READ_TOC:
                case IOCTL_CDROM_GET_LAST_SESSION:
                    IdexCdRomStartReadTOC(Irp);
                    break;

                case IOCTL_CDROM_CHECK_VERIFY:
                    IdexCdRomStartCheckVerify(Irp);
                    break;

                case IOCTL_CDROM_GET_DRIVE_GEOMETRY:
                    IdexCdRomStartGetDriveGeometry(Irp);
                    break;

                case IOCTL_CDROM_RAW_READ:
                    IdexCdRomStartRawRead(Irp);
                    break;

                case IOCTL_CDROM_SET_SPINDLE_SPEED:
                    IdexCdRomStartSetSpindleSpeed(Irp);
                    break;

                case IOCTL_DVD_START_SESSION:
                    IdexCdRomStartStartSession(Irp);
                    break;

                case IOCTL_DVD_READ_KEY:
                    IdexCdRomStartReadKey(Irp);
                    break;

                case IOCTL_DVD_SEND_KEY:
                case IOCTL_DVD_SEND_KEY2:
                    IdexCdRomStartSendKey(Irp);
                    break;

                case IOCTL_DVD_END_SESSION:
                    IdexCdRomStartEndSession(Irp);
                    break;

                case IOCTL_DVD_READ_STRUCTURE:
                    IdexCdRomStartReadStructure(Irp);
                    break;

                case IOCTL_IDE_PASS_THROUGH:
                    IdexChannelStartIdePassThrough(Irp, IDE_CDROM_DEVICE_NUMBER,
                        IdexCdRomResetDevice);
                    break;

                case IOCTL_SCSI_PASS_THROUGH_DIRECT:
                    IdexCdRomStartScsiPassThrough(Irp);
                    break;

                default:
                    IdexBugCheck(IDE_BUG_CHECK_CDROM, Irp);
                    break;
            }
            break;

        default:
            IdexBugCheck(IDE_BUG_CHECK_CDROM, Irp);
            break;
    }
}

VOID
IdexCdRomTrayOpenNotification(
    VOID
    )
/*++

Routine Description:

    This routine is called by the SMC interrupt handler when a tray open event
    has occurred.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Reset any assumptions about the state of the media.
    //

    IdexCdRomPartitionLength = _I64_MAX;
    IdexCdRomDVDX2Authenticated = FALSE;

#if DBG
    //
    // Reset any debug statistics.
    //

    RtlZeroMemory(IdexCdRomDebugErrors, sizeof(IdexCdRomDebugErrors));
    IdexCdRomDebugReadsFinished = 0;
#endif
}

VOID
IdexCdRomFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine is called when a fatal CD-ROM device related error is detected.

Arguments:

    ErrorCode - Specifies the fatal error code.

Return Value:

    None.

--*/
{
    IdexDbgBreakPoint();

    //
    // Flush the LEDs to indicate that there is CD-ROM related problem.
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_RED_STATE0 | SMC_LED_STATES_GREEN_STATE1 |
        SMC_LED_STATES_GREEN_STATE2 | SMC_LED_STATES_GREEN_STATE3);

    //
    // Display the universal error message.
    //

    ExDisplayFatalError(ErrorCode);
}

VOID
IdexCdRomCreateQuick(
    VOID
    )
/*++

Routine Description:

    This routine initializes the CD-ROM device subsystem after a quick reboot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT CdRomDeviceObject;
    DVDX2_AUTHENTICATION Authentication;

    //
    // Create the CD-ROM's device object.
    //

    status = IoCreateDevice(&IdexCdRomDriverObject, 0, &IdexCdRomDeviceName,
        FILE_DEVICE_CD_ROM, FALSE, &CdRomDeviceObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_CDROM, status);
    }

    //
    // Create the \DosDevices symbolic link.
    //

    status = IoCreateSymbolicLink(&IdexCdRomDosDevicesName, &IdexCdRomDeviceName);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_CDROM, status);
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    CdRomDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Set the alignment requirement for the device.
    //

    CdRomDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    CdRomDeviceObject->SectorSize = IDE_ATAPI_CD_SECTOR_SIZE;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    CdRomDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Store the device object globally so that it can be quickly found later.
    //

    IdexCdRomDeviceObject = CdRomDeviceObject;

    //
    // If the kernel is quick booting and we think that the current media is
    // DVD-X2, then verify that assumption by checking the DVD-X2 authentication
    // page.  This code is in place to prevent media swap piracy attacks.
    //

    if (KeHasQuickBooted && IdexCdRomDVDX2Authenticated) {

        //
        // Assume that the drive has not passed DVD-X2 authentication.
        //

        IdexCdRomDVDX2Authenticated = FALSE;

        //
        // Request the authentication page from the DVD-X2 drive.
        //

        status = IdexCdRomRequestDVDX2AuthenticationPage(&Authentication);

        if (NT_SUCCESS(status)) {

            //
            // If the DVD-X2 drive is in the Xbox partition and has successfully
            // completed DVD-X2 authentication, then the media likely hasn't
            // changed from the last time DVD-X2 authentication was performed.
            //

            if ((Authentication.AuthenticationPage.PartitionArea != 0) &&
                (Authentication.AuthenticationPage.Authentication != 0)) {
                IdexCdRomDVDX2Authenticated = TRUE;
            }
        }
    }
}

VOID
IdexCdRomCreate(
    VOID
    )
/*++

Routine Description:

    This routine initializes the CD-ROM device subsystem.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG Retries;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    IDE_IDENTIFY_DATA IdentifyData;
    ULONG IOErrors;

    //
    // Wait for the device to finish its hardware reset sequence.  When cold
    // booting, the IDE controller in the south bridge will do a hardware reset
    // of the IDE bus, so we don't need to a software reset here.
    //
    // If we're booting a kernel that was loaded from the hard disk or CD-ROM,
    // then the device should already be ready to go, so we can skip the
    // initialization here.
    //

    HalPulseHardwareMonitorPin();

    if (IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_SHADOW)) {

        //
        // Spin for up to thirty seconds as required by the ATA specification.
        //

        for (Retries = 600; Retries > 0; Retries--) {

            if (IdexCdRomPollResetComplete()) {
                break;
            }

            //
            // Delay for 50 milliseconds.
            //

            Interval.QuadPart = -50 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }

        if (Retries == 0) {
            IdexDbgPrint(("IDEX: CD-ROM timed out during reset.\n"));
            IdexCdRomFatalError(FATAL_ERROR_DVD_TIMEOUT);
        }
    }

    //
    // The below calls may cause an interrupt to be raised, so while we're
    // initializing the hardware, raise IRQL to synchronize with the interrupt
    // service routine.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    //
    // Set the PIO transfer mode for the CD-ROM device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_CDROM_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_PIO_MODE_4);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: CD-ROM not PIO configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexCdRomFatalError(FATAL_ERROR_DVD_BAD_CONFIG);
    }

    //
    // Set the DMA transfer mode for the CD-ROM device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_CDROM_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_UDMA_MODE_2);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: CD-ROM not DMA configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexCdRomFatalError(FATAL_ERROR_DVD_BAD_CONFIG);
    }

    //
    // Issue an ATAPI identify device command in order to verify that the device
    // is present.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelIdentifyDevice(IDE_CDROM_DEVICE_NUMBER,
        IDE_COMMAND_IDENTIFY_PACKET_DEVICE, &IdentifyData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: CD-ROM not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexCdRomFatalError(FATAL_ERROR_DVD_NOT_FOUND);
    }

    KeLowerIrql(OldIrql);

    //
    // At this point, we can use the quick boot creation code.
    //

    IdexCdRomCreateQuick();

    //
    // If we're cold-booting and we're ejecting the tray, then don't bother
    // waiting for the CD-ROM device to become ready because the tray is about
    // to be ejected and we're going to force a launch into the dashboard
    // anyway.
    //

    HalPulseHardwareMonitorPin();

    if (!KeHasQuickBooted &&
        IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_TRAYEJECT)) {

        //
        // Delay until the CD-ROM device reports that it's ready.  We also handle
        // a 6-29 error here which is returned as STATUS_IO_DEVICE_ERROR.  We only
        // want to handle a certain number of IO errors here.
        //

        IOErrors = 0;

        while (IOErrors < 5) {

            status = IoSynchronousDeviceIoControlRequest(IOCTL_CDROM_CHECK_VERIFY,
                IdexCdRomDeviceObject, NULL, 0, NULL, 0, NULL, FALSE);

            if (status == STATUS_IO_DEVICE_ERROR) {
                IOErrors++;
            } else if (status != STATUS_DEVICE_NOT_READY) {
                break;
            }

            //
            // Delay for 200 milliseconds.
            //

            Interval.QuadPart = -200 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }
    }
}

//
// Driver object for the CD-ROM object.
//
DECLSPEC_RDATA DRIVER_OBJECT IdexCdRomDriverObject = {
    IdexCdRomStartIo,                   // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CREATE
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CLOSE
        IdexCdRomRead,                  // IRP_MJ_READ
        IoInvalidDeviceRequest,         // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        IdexCdRomDeviceControl,         // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

#else

//
// Single instance of the CD-ROM device object.
//
PDEVICE_OBJECT IdexCdRomDeviceObject;

VOID
IdexCdRomTrayOpenNotification(
    VOID
    )
/*++

Routine Description:

    This routine is called by the SMC interrupt handler when a tray open event
    has occurred.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\halx\i386\xxhal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxhal.c

Abstract:

    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for an
    x86 system.

--*/

#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalInitSystemPhase0)
#endif

VOID
HalInitSystemPhase0(
    VOID
    )
/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONGLONG ApicBits;

    _outp(0x61, 0x08);

    //
    // Disable the processor APIC (advanced programmable interrupt
    // controller).  The processor powers on with the APIC enabled.
    //

    HalPulseHardwareMonitorPin();
    ApicBits = RDMSR(APIC_BASE_MSR);
    WRMSR(APIC_BASE_MSR, (ApicBits & ~APIC_ENABLED));

    //
    // Initialize the 8259 programmable interrupt controller.  Note that
    // this will enable interrupts.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializePICs();

    //
    // Initialize the real time clock.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializeRealTimeClock();

    //
    // Note that HalpInitializeClock MUST be called after
    // HalpInitializeStallExecution, because HalpInitializeStallExecution
    // reprograms the timer.
    //

//  HalpInitializeStallExecution();

    //
    // Setup the clock.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializeClock();

    //
    // Make sure the profile interrupt is disabled.
    //

    HalPulseHardwareMonitorPin();
    HalStopProfileInterrupt(0);

    //
    // Configure the devices built into the south bridge.
    //

    HalPulseHardwareMonitorPin();
    HalpSetupPCIDevices();

    //
    // Initialize the System Control Interrupt.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializeSystemControlInterrupt();
}

VOID
HalInitSystemPhase0Quick(
    VOID
    )
/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the 8259 programmable interrupt controller.  Note that
    // this will enable interrupts.
    //

    HalPulseHardwareMonitorPin();
    HalpInitializePICs();
}

VOID
HalInitSystemPhase1(
    VOID
    )
/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Connect to the system interrupts.
    //

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(CLOCK_VECTOR, KeClockInterrupt);
    HalEnableSystemInterrupt(CLOCK_VECTOR - PRIMARY_VECTOR_BASE, Latched);

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(PROFILE_VECTOR, HalpProfileInterrupt);
    HalEnableSystemInterrupt(PROFILE_VECTOR - PRIMARY_VECTOR_BASE, Latched);

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(SMBUS_VECTOR, HalpSMBusInterrupt);
    HalEnableSystemInterrupt(SMBUS_VECTOR - PRIMARY_VECTOR_BASE, LevelSensitive);

    //
    // The following actions need to be performed before servicing interrupts
    // from the SMC, but after connecting to the above interrupt vectors.
    //

    if (!KeHasQuickBooted) {
        HalPulseHardwareMonitorPin();
        HalpProcessSMCInitialState();
    }

    //
    // Connect to the System Control Interrupt.
    //

    HalPulseHardwareMonitorPin();
    KiSetHandlerAddressToIDT(SCI_VECTOR, HalpSystemControlInterrupt);
    HalEnableSystemInterrupt(SCI_VECTOR - PRIMARY_VECTOR_BASE, LevelSensitive);
}

VOID
HalPulseHardwareMonitorPin(
    VOID
    )
/*++

Routine Description:

    This function pulses the hardware monitor pin used to externally monitor the
    boot process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Don't pulse the hardware monitor pin if this is a quick boot or a shadow
    // boot.
    //

    if (!KeHasQuickBooted &&
        ((XboxBootFlags & XBOX_BOOTFLAG_SHADOW) == 0)) {

        _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xCF, 0x05);

        KeStallExecutionProcessor(5);

        _outp(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 + 0xCF, 0x04);

        KeStallExecutionProcessor(5);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\disk.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    This module implements routines that apply to the disk object.

--*/

#include "idex.h"

#if !defined(ARCADE) || defined(DEVKIT)

//
// Define the maximum number of disk partitions that we'll reserve space for.
//

#define IDE_DISK_PARTITION_ARRAY_ELEMENTS       20

//
// Name of the disk object directory and its device object.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexDiskDirectoryName, "\\Device\\Harddisk0");

//
// These disk identification strings are used by various other pieces of code to
// help uniquely identify this system.  The strings are based on the data
// returned from IDE_COMMAND_IDENTIFY_DEVICE.
//
DECLSPEC_STICKY UCHAR IdexDiskModelNumberBuffer[40];
DECLSPEC_STICKY STRING HalDiskModelNumber;
DECLSPEC_STICKY UCHAR IdexDiskSerialNumberBuffer[20];
DECLSPEC_STICKY STRING HalDiskSerialNumber;

//
// Stores whether or not the disk was successfully unlocked or not.
//
DECLSPEC_STICKY BOOLEAN IdexDiskSecurityUnlocked;

//
// Array of all of the created disk and partition device objects.
//
PDEVICE_OBJECT IdexDiskPartitionArray[IDE_DISK_PARTITION_ARRAY_ELEMENTS];

//
// All device objects relative to \Device\Harddisk0 start with this string.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexDiskPartitionPrefix, "Partition");

//
// Number of sectors addressable from the driver.
//
DECLSPEC_STICKY ULONG IdexDiskUserAddressableSectors;

#ifndef IDEX_DISK_FIXED_SECTOR_COUNT
//
// Number of sectors allocated to the data paritition (Partition1).
//
DECLSPEC_STICKY ULONG IdexDiskDataPartitionSectors;
#endif

//
// Number of cache partitions available on the disk.
//
#ifdef IDEX_DISK_FIXED_SECTOR_COUNT
DECLSPEC_RDATA ULONG HalDiskCachePartitionCount =
    XDISK_NUMBER_OF_CACHE_PARTITIONS(XDISK_FIXED_SECTOR_COUNT);
#else
DECLSPEC_STICKY ULONG HalDiskCachePartitionCount;
#endif

//
// Define macros to abstract the disk geometry data for a fixed vs. dynamic
// configuration.
//
#ifdef IDEX_DISK_FIXED_SECTOR_COUNT
#define IDEX_DISK_CACHE_PARTITION_COUNT \
    XDISK_NUMBER_OF_CACHE_PARTITIONS(XDISK_FIXED_SECTOR_COUNT)
#define IDEX_DISK_DATA_PARTITION_SECTORS \
    (XDISK_FIXED_SECTOR_COUNT - \
    (XDISK_UNPARTITIONED_SECTORS + XDISK_SHELL_PARTITION_SECTORS + \
    (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS)))
#else
#define IDEX_DISK_CACHE_PARTITION_COUNT     HalDiskCachePartitionCount
#define IDEX_DISK_DATA_PARTITION_SECTORS    IdexDiskDataPartitionSectors
#endif

//
// Local support.
//

DECLSPEC_NORETURN
VOID
IdexDiskFatalError(
    IN ULONG ErrorCode
    );

VOID
IdexDiskInitIdentifierString(
    IN PUCHAR IdentifyDataString,
    OUT PUCHAR DiskIdentifierBuffer,
    IN SIZE_T DiskIdentifierLength,
    OUT PSTRING DiskIdentifierString
    );

NTSTATUS
IdexDiskSetDeviceParameters(
    VOID
    );

VOID
IdexDiskSecurityUnlock(
    UCHAR Password[IDE_ATA_PASSWORD_LENGTH]
    );

VOID
IdexDiskIncrementPowerCycleCount(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexDiskFatalError)
#pragma alloc_text(INIT, IdexDiskInitIdentifierString)
#pragma alloc_text(INIT, IdexDiskSetDeviceParameters)
#pragma alloc_text(INIT, IdexDiskSecurityUnlock)
#pragma alloc_text(INIT, IdexDiskCreate)
#pragma alloc_text(INIT, IdexDiskIncrementPowerCycleCount)
#endif

BOOLEAN
IdexDiskPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the disk device to check for completion of a reset
    sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the device has completed its reset sequence.

--*/
{
    UCHAR IdeStatus;

    //
    // The software reset caused both the disk device and the CD-ROM device to
    // start their reset sequences.  Check if the CD-ROM device has finished its
    // reset sequence first.
    //

    if (!IdexCdRomPollResetComplete()) {
        return FALSE;
    }

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_DISK_DEVICE_NUMBER);

    //
    // Check if the device is busy.
    //

    IdeStatus = IdexReadStatusPort();

    if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY) &&
        IdexIsFlagSet(IdeStatus, IDE_STATUS_DRDY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IdexDiskResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine software resets the disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IdexAssertIrqlAtChannelDIRQL();

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Ensure that the software reset flag is not asserted.
    //

    IdexWriteDeviceControlPort(0);
    KeStallExecutionProcessor(50);

    //
    // Assert the software reset flag.
    //

    IdexWriteDeviceControlPort(IDE_DEVICE_CONTROL_SRST);
    KeStallExecutionProcessor(100);

    //
    // De-assert the software reset flag.
    //

    IdexWriteDeviceControlPort(0);
    KeStallExecutionProcessor(50);

    //
    // Set the reset complete poll routine and a reset timeout of 10 seconds.
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexDiskPollResetComplete;
    IdexChannelObject.Timeout = 100;

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Speed up the timer to check for completion of the reset sequence.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    //
    // Delay for up to twenty-five seconds (100 milliseconds per unit).
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexDiskPollResetComplete;
    IdexChannelObject.Timeout = 250;
}

BOOLEAN
IdexDiskSelectDeviceAndSpinWhileBusy(
    VOID
    )
/*++

Routine Description:

    This routine selects the disk device and spins until the the IDE status
    register's BSY bit is clear, which indicates that the device is ready to
    accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_DISK_DEVICE_NUMBER);

    //
    // Spin for up to a tenth second.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY) &&
            IdexIsFlagSet(IdeStatus, IDE_STATUS_DRDY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

VOID
IdexDiskNoTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that doesn't
    transfer any data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexDiskTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR BusMasterStatus;
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the bus master status register and verify that the interrupt bit is
    // set if we haven't already seen the bus master interrupt.
    //

    BusMasterStatus = IdexReadBusMasterStatusPort();

    if (IdexChannelObject.ExpectingBusMasterInterrupt) {

        if (IdexIsFlagClear(BusMasterStatus, IDE_BUS_MASTER_STATUS_INTERRUPT)) {
            return;
        }

        //
        // Deactivate the bus master interface and dismiss the interrupt.
        //

        IdexWriteBusMasterCommandPort(0);
        IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

        IdexChannelObject.ExpectingBusMasterInterrupt = FALSE;
    }

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Deactivate the bus master interface and dismiss the interrupt.
    //

    IdexWriteBusMasterCommandPort(0);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR) ||
        IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ERROR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else if (IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ACTIVE)) {
        Irp->IoStatus.Status = STATUS_DATA_OVERRUN;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexDiskFinishGeneric(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    Irp = IdexChannelObject.CurrentIrp;

    if (Irp->IoStatus.Status == STATUS_IO_TIMEOUT) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

        IdexDiskResetDevice();

        return;
    }

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexDiskStartVerify(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IOCTL_DISK_VERIFY requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexDiskSelectDeviceAndSpinWhileBusy()) {
        IdexDiskFinishGeneric();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexProgramLBATransfer(IDE_DISK_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber,
        (IrpSp->Parameters.IdexReadWrite.Length >> IDE_ATA_SECTOR_SHIFT));

    IdexWriteCommandPort(IDE_COMMAND_VERIFY);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexDiskNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexDiskFinishGeneric;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskVerify(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_VERIFY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_DISK_EXTENSION DiskExtension;
    PIO_STACK_LOCATION IrpSp;
    PVERIFY_INFORMATION VerifyInformation;
    LONGLONG StartingByteOffset;

    DiskExtension = (PIDE_DISK_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the input buffer is large enough.
    //

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(VERIFY_INFORMATION)) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    VerifyInformation =
        (PVERIFY_INFORMATION)IrpSp->Parameters.DeviceIoControl.InputBuffer;

    //
    // Verify that the verify length doesn't exceed the ATA limits.
    //

    if (VerifyInformation->Length > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Compute the starting byte offset for the verify.
    //

    StartingByteOffset = VerifyInformation->StartingOffset.QuadPart +
        DiskExtension->PartitionInformation.StartingOffset.QuadPart;

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format uses the same IRP parameters as an IDE read and write.
    //

    IrpSp->Parameters.IdexReadWrite.Length = VerifyInformation->Length;
    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATA_SECTOR_SHIFT);

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = 0;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

VOID
IdexDiskFinishReadWrite(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a IRP_MJ_READ or
    IRP_MJ_WRITE request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexDiskFinishGeneric();
        return;
    }

    //
    // If there are still more bytes to transfer in this request, then adjust
    // the transfer counts and requeue the packet.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {

        //
        // If the console is preparing to reset or shutdown, there's no reason
        // to continue processing this request.
        //

        if (HalIsResetOrShutdownPending()) {
            IdexChannelAbortCurrentPacket();
            return;
        }

        IrpSp->Parameters.IdexReadWrite.Length -= IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.BufferOffset += IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.SectorNumber += IDE_ATA_MAXIMUM_TRANSFER_SECTORS;

        IdexChannelStartPacket(IrpSp->DeviceObject, Irp);
        IdexChannelStartNextPacket();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexDiskStartReadWrite(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_READ and IRP_MJ_WRITE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    ULONG TransferLength;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If the number of bytes remaining is greater than the maximum transfer
    // size allowed by the hardware, then clip the number of bytes to the
    // maximum.
    //

    TransferLength = IrpSp->Parameters.IdexReadWrite.Length;

    if (TransferLength > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {
        TransferLength = IDE_ATA_MAXIMUM_TRANSFER_BYTES;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexDiskSelectDeviceAndSpinWhileBusy()) {
        IdexDiskFinishReadWrite();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (IdexIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION) ||
        IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IdexChannelPrepareBufferTransfer(IrpSp->Parameters.IdexReadWrite.Buffer +
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    } else {
        IdexChannelPrepareScatterGatherTransfer(Irp->SegmentArray,
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    }

    //
    // Issue the IDE command and activate the bus master interface.
    //

    IdexProgramLBATransfer(IDE_DISK_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber,
        (TransferLength >> IDE_ATA_SECTOR_SHIFT));

    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        IdexWriteCommandPort(IDE_COMMAND_READ_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
            IDE_BUS_MASTER_COMMAND_READ);
    } else {
        IdexWriteCommandPort(IDE_COMMAND_WRITE_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START);
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexDiskTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexDiskFinishReadWrite;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ and
    IRP_MJ_WRITE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_DISK_EXTENSION DiskExtension;
    PIO_STACK_LOCATION IrpSp;
    LONGLONG StartingByteOffset;
    LONGLONG EndingByteOffset;

    DiskExtension = (PIDE_DISK_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the parameters are valid.  The buffer length must be an
    // integral number of sectors, the starting offset must be sector aligned,
    // and the ending offset must be within the bounds of the disk.  The I/O
    // buffer must have the proper device alignment.
    //

    StartingByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    EndingByteOffset = StartingByteOffset + IrpSp->Parameters.Read.Length;

    if (IdexIsFlagClear(IrpSp->Flags, SL_FSCACHE_REQUEST)) {

        if (((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.BufferOffset & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) != 0) ||
            ((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) != 0) ||
            (EndingByteOffset >
                DiskExtension->PartitionInformation.PartitionLength.QuadPart)) {

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Bypass parameter checking if this request is coming from the cache.
        // We'll trust that the file system cache is submitting a valid request,
        // but we'll double check in debug.
        //

        ASSERT((PtrToUlong(IrpSp->Parameters.Read.CacheBuffer) &
            IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT(EndingByteOffset <=
            DiskExtension->PartitionInformation.PartitionLength.QuadPart);
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    //
    // Adjust the starting byte offset by the partition's starting offset.
    //

    StartingByteOffset += DiskExtension->PartitionInformation.StartingOffset.QuadPart;

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format unpacks the cache buffer and buffer offset fields to
    // different fields by collapsing the byte offset to a sector number.
    //

    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATA_SECTOR_SHIFT);

    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
           FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Length));

    //
    // Move the buffer pointer and the buffer starting offset around depending
    // on whether or not this is a file system cache request.
    //

    if (IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IrpSp->Parameters.IdexReadWrite.BufferOffset = 0;
        ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.CacheBuffer) ==
               FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Buffer));
    } else {
        IrpSp->Parameters.IdexReadWrite.BufferOffset =
            IrpSp->Parameters.Read.BufferOffset;
        IrpSp->Parameters.IdexReadWrite.Buffer = (PUCHAR)Irp->UserBuffer;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.IdexReadWrite.Length;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

VOID
FASTCALL
IdexDiskStartFlushBuffers(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_FLUSH_BUFFER requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // No retries are allowed for this IRP.
    //

    IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexDiskSelectDeviceAndSpinWhileBusy()) {
        IdexDiskFinishGeneric();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_FLUSH_CACHE);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexDiskNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexDiskFinishGeneric;
    IdexChannelObject.Timeout = IDE_ATA_FLUSH_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskFlushBuffers(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_FLUSH_BUFFER requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
IdexDiskGetDriveGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_DRIVE_GEOMETRY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDISK_GEOMETRY DiskGeometry;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DISK_GEOMETRY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    DiskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
    DiskGeometry->Cylinders.QuadPart = IdexDiskUserAddressableSectors;
    DiskGeometry->MediaType = FixedMedia;
    DiskGeometry->TracksPerCylinder = 1;
    DiskGeometry->SectorsPerTrack = 1;
    DiskGeometry->BytesPerSector = IDE_ATA_SECTOR_SIZE;

    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexDiskGetPartitionInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_PARTITION_INFO request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_DISK_EXTENSION DiskExtension;
    PIO_STACK_LOCATION IrpSp;
    PPARTITION_INFORMATION PartitionInformation;

    DiskExtension = (PIDE_DISK_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTITION_INFORMATION)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    PartitionInformation = (PPARTITION_INFORMATION)Irp->UserBuffer;

    *PartitionInformation = DiskExtension->PartitionInformation;

    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            status = IdexDiskGetDriveGeometry(DeviceObject, Irp);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO:
            status = IdexDiskGetPartitionInfo(DeviceObject, Irp);
            break;

        case IOCTL_DISK_VERIFY:
            status = IdexDiskVerify(DeviceObject, Irp);
            break;

        case IOCTL_IDE_PASS_THROUGH:
            IoMarkIrpPending(Irp);
            IdexChannelStartPacket(DeviceObject, Irp);
            status = STATUS_PENDING;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // If the request is no longer pending, then complete the request.
    //

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
IdexDiskStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the channel to handle the next queued I/O request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Mark all IRPS as must complete IRPs because we have to wait for
    // completion of any disk device command in order to issue the shutdown
    // commands.
    //

    IoMarkIrpMustComplete(Irp);

    //
    // Dispatch the IRP request.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
            IdexDiskStartReadWrite(Irp);
            break;

        case IRP_MJ_FLUSH_BUFFERS:
            IdexDiskStartFlushBuffers(Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_DISK_VERIFY:
                    IdexDiskStartVerify(Irp);
                    break;

                case IOCTL_IDE_PASS_THROUGH:
                    IdexChannelStartIdePassThrough(Irp, IDE_DISK_DEVICE_NUMBER,
                        IdexDiskResetDevice);
                    break;

                default:
                    IdexBugCheck(IDE_BUG_CHECK_DISK, Irp);
                    break;
            }
            break;

        default:
            IdexBugCheck(IDE_BUG_CHECK_DISK, Irp);
            break;
    }
}

VOID
IdexDiskShutdownSystem(
    VOID
    )
/*++

Routine Description:

    This routine flushes and spins down the disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;
    NTSTATUS status;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we haven't yet connected to the interrupt object, then we don't know
    // what the real interrupt IRQL should be.  Because the interrupt service
    // routine can't run, we don't really care, so set the interrupt IRQL to the
    // current IRQL.
    //

    if (!IdexChannelObject.InterruptObject.Connected) {
        IdexChannelObject.InterruptIrql = DISPATCH_LEVEL;
    }

    //
    // The below calls may cause an interrupt to be raised, so while we're
    // initializing the hardware, raise IRQL to synchronize with the interrupt
    // service routine.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    //
    // Flush the disk device's cache.
    //

    status = IdexChannelIssueImmediateCommand(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_FLUSH_CACHE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: shutdown failed to flush disk (status=%08x).\n",
            status));
        KeLowerIrql(DISPATCH_LEVEL);
        return;
    }

    //
    // Spindown the disk device.
    //

    status = IdexChannelIssueImmediateCommand(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_STANDBY_IMMEDIATE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: shutdown failed to spindown disk (status=%08x).\n",
            status));
        KeLowerIrql(DISPATCH_LEVEL);
        return;
    }

    KeLowerIrql(DISPATCH_LEVEL);
}

NTSTATUS
IdexDiskPartitionCreate(
    IN ULONG PartitionNumber
    )
/*++

Routine Description:

    This routine constructs and initializes a partition device object.

Arguments:

    PartitionNumber - Specifies the index of the partition.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PARTITION_INFORMATION PartitionInformation;
    PDEVICE_OBJECT DiskDeviceObject;
    PIDE_DISK_EXTENSION DiskExtension;

    ASSERT(PartitionNumber != 0);

    switch (PartitionNumber) {

        case XDISK_DATA_PARTITION:
            //
            // Compute the data partition's starting sector and length.
            //

            PartitionInformation.HiddenSectors = XDISK_UNPARTITIONED_SECTORS +
                (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS) +
                XDISK_SHELL_PARTITION_SECTORS;
            PartitionInformation.PartitionLength.QuadPart =
                ((ULONGLONG)IDEX_DISK_DATA_PARTITION_SECTORS * IDE_ATA_SECTOR_SIZE);
            break;

        case XDISK_SHELL_PARTITION:
            //
            // Compute the shell partition's starting sector and length.
            //

            PartitionInformation.HiddenSectors = XDISK_UNPARTITIONED_SECTORS +
                (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS);
            PartitionInformation.PartitionLength.QuadPart =
                XDISK_SHELL_PARTITION_SIZE;
            break;
		//HACK  ADD F PARTITION 11/12/2002 MAX

		case XDISK_F_PARTITION:
            //
            // Compute the f partition's starting sector and length.
            //

          PartitionInformation.HiddenSectors =XDISK_UNPARTITIONED_SECTORS +
                (IDEX_DISK_CACHE_PARTITION_COUNT * XDISK_CACHE_PARTITION_SECTORS) +
                XDISK_SHELL_PARTITION_SECTORS+
                IDEX_DISK_DATA_PARTITION_SECTORS;
          PartitionInformation.PartitionLength.QuadPart = ((ULONGLONG)IdexDiskUserAddressableSectors-
                (ULONGLONG)PartitionInformation.HiddenSectors)*IDE_ATA_SECTOR_SIZE;
  			break;
        default:
            //
            // We're attempting to create a cache partition.  Verify that the
            // partition number is valid.
            //

            if (PartitionNumber >= IDEX_DISK_CACHE_PARTITION_COUNT +
                XDISK_FIRST_CACHE_PARTITION) {
                return STATUS_OBJECT_NAME_NOT_FOUND;
            }

            //
            // Compute the cache partition's starting sector and length.
            //

            PartitionInformation.HiddenSectors = XDISK_UNPARTITIONED_SECTORS +
                ((PartitionNumber - XDISK_FIRST_CACHE_PARTITION) *
                XDISK_CACHE_PARTITION_SECTORS);
            PartitionInformation.PartitionLength.QuadPart =
                XDISK_CACHE_PARTITION_SIZE;
            break;
    }

    PartitionInformation.StartingOffset.QuadPart =
        ((ULONGLONG)PartitionInformation.HiddenSectors * IDE_ATA_SECTOR_SIZE);
    PartitionInformation.PartitionNumber = PartitionNumber;

    ASSERT(PartitionInformation.StartingOffset.QuadPart +
        PartitionInformation.PartitionLength.QuadPart <=
        ((PIDE_DISK_EXTENSION)IdexDiskPartitionArray[0]->DeviceExtension)->
        PartitionInformation.PartitionLength.QuadPart);

    //
    // Create the partition's device object.
    //

    status = IoCreateDevice(&IdexDiskDriverObject, sizeof(IDE_DISK_EXTENSION),
        NULL, FILE_DEVICE_DISK, FALSE, &DiskDeviceObject);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    DiskDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Set the alignment requirement for the device.
    //

    DiskDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    DiskDeviceObject->SectorSize = IDE_ATA_SECTOR_SIZE;

    //
    // Initialize the partition's device extension data.
    //

    DiskExtension = (PIDE_DISK_EXTENSION)DiskDeviceObject->DeviceExtension;

    DiskExtension->DeviceObject = DiskDeviceObject;
    DiskExtension->PartitionInformation = PartitionInformation;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    DiskDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Atomically insert the device object into the global array of created
    // device objects.  If another thread beats us to the creation of this
    // device object, then delete the one we created.
    //

    if (InterlockedCompareExchangePointer(&IdexDiskPartitionArray[PartitionNumber],
        DiskDeviceObject, NULL) != NULL) {
        IoDeleteDevice(DiskDeviceObject);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdexDiskParseDirectory(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    )
/*++

Routine Description:

    This routine is called by the object manager to parse a name relative to the
    "\Device\Harddisk0" disk directory.

Arguments:

    ParseObject - Specifies the object that the remaining name is relative to.

    ObjectType - Specifies the desired object type for the parsed object.

    Attributes - Specifies the object attributes for the parsed object.

    CompleteName - Specifies the entire name as supplied by the initiator of the
        object parse.

    RemainingName - Specifies the portion of the name that must still be
        resolved.

    Context - Specifies additional parse context information from the initiator
        of the object parse.

    Object - Specifies the buffer to receive the parsed object.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    BOOLEAN TrailingBackslash;
    OBJECT_STRING ElementName;
    POSTR Buffer;
    POSTR EndingBuffer;
    OCHAR Char;
    ULONG PartitionNumber;
    PDEVICE_OBJECT DiskDeviceObject;

    *Object = NULL;

    //
    // If there's no more name to parse, then fail the parse.
    //

    if (RemainingName->Length == 0) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Check if the name ends in a backslash.
    //

    if (RemainingName->Buffer[(RemainingName->Length / sizeof(OCHAR)) - 1] ==
        OBJ_NAME_PATH_SEPARATOR) {
        TrailingBackslash = TRUE;
    } else {
        TrailingBackslash = FALSE;
    }

    //
    // Pull off the next element of the path name.
    //

    ObDissectName(*RemainingName, &ElementName, RemainingName);

    //
    // Verify that there aren't multiple backslashes in the name.
    //

    if ((RemainingName->Length != 0) && (RemainingName->Buffer[0] ==
        OBJ_NAME_PATH_SEPARATOR)) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    //
    // Move the remaining name buffer back to the path separator.  If we
    // successfully find or create a disk object below, then we'll want to pass
    // the remaining name on to the I/O manager where it'll be passed into a
    // file system which wants to see an absolute path.
    //

    if (TrailingBackslash || (RemainingName->Length != 0)) {
        RemainingName->Buffer--;
        RemainingName->Length += sizeof(OCHAR);
        RemainingName->MaximumLength = RemainingName->Length;
    }

    //
    // Check that the element starts with the expected prefix.
    //

    if ((ElementName.Length > IdexDiskPartitionPrefix.Length) &&
        RtlPrefixString(&IdexDiskPartitionPrefix, &ElementName, TRUE)) {

        //
        // Convert the partition number string into a number.  Note that we
        // don't worry about integer overflow in this loop; "Partition0" is
        // equal to "Partition4294967296".
        //

        PartitionNumber = 0;
        Buffer = ElementName.Buffer + IdexDiskPartitionPrefix.Length;
        EndingBuffer = ElementName.Buffer + ElementName.Length;

        while (Buffer < EndingBuffer) {

            Char = *Buffer;

            if (Char >= '0' && Char <= '9') {
                PartitionNumber = PartitionNumber * 10 + (Char - '0');
                Buffer++;
            } else {
                break;
            }
        }

        //
        // If we reached the end of the string without finding any non-numeric
        // characters and the partition number is in range, then the partition
        // number is valid.
        //

        if ((Buffer == EndingBuffer) &&
            (PartitionNumber < IDE_DISK_PARTITION_ARRAY_ELEMENTS)) {

            //
            // Check the array of created disk objects to see if we've already
            // created a disk object for the specified partition number.  If
            // not, then attempt to create the disk object.
            //

            for (;;) {

                DiskDeviceObject = IdexDiskPartitionArray[PartitionNumber];

                if (DiskDeviceObject != NULL) {
                    break;
                }

                status = IdexDiskPartitionCreate(PartitionNumber);

                if (!NT_SUCCESS(status)) {

                    if ((status == STATUS_OBJECT_NAME_NOT_FOUND) &&
                        (RemainingName->Length != 0)) {
                        status = STATUS_OBJECT_PATH_NOT_FOUND;
                    }

                    return status;
                }
            }

            //
            // Delegate the rest of the processing to the standard I/O
            // manager parse routine for devices (the object manager doesn't
            // support STATUS_REPARSE).
            //

            return IoParseDevice(DiskDeviceObject, ObjectType, Attributes,
                CompleteName, RemainingName, Context, Object);
        }
    }

    return (RemainingName->Length == 0) ? STATUS_OBJECT_NAME_NOT_FOUND :
        STATUS_OBJECT_PATH_NOT_FOUND;
}

VOID
IdexDiskFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine is called when a fatal disk device related error is detected.

Arguments:

    ErrorCode - Specifies the fatal error code.

Return Value:

    None.

--*/
{
    IdexDbgBreakPoint();

    //
    // Flush the LEDs to indicate that there is disk related problem.
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_GREEN_STATE0 | SMC_LED_STATES_RED_STATE1 |
        SMC_LED_STATES_RED_STATE2 | SMC_LED_STATES_RED_STATE3);

    //
    // Display the universal error message.
    //

    ExDisplayFatalError(ErrorCode);
}

VOID
IdexDiskInitIdentifierString(
    IN PUCHAR IdentifyDataString,
    OUT PUCHAR DiskIdentifierBuffer,
    IN SIZE_T DiskIdentifierLength,
    OUT PSTRING DiskIdentifierString
    )
/*++

Routine Description:

    This routine takes a string from the identify data packet and copies it to a
    global buffer after converting it to the native host format.  The string is
    initialized with the global buffer, the length of the buffer with the
    trailing spaces stripped off, and the length of the buffer itself.

Arguments:

    IdentifyDataString - Specifies the string from the identify data packet.

    DiskIdentifierBuffer - Specifies the buffer to copy the identify data
        string to, in the native host format.

    DiskIdentifierLength - Specifies the length of the disk identifier buffer.

    DiskIdentifierString - Specifies the string to initialize with the raw
        buffer and length.

Return Value:

    None.

--*/
{
    PUSHORT UshortSource;
    PUSHORT UshortDestinationEnd;
    PUSHORT UshortDestination;
    PUCHAR EndBuffer;

    ASSERT((DiskIdentifierLength & 1) == 0);

    //
    // Copy the string from the identify data packet to the disk identifier
    // buffer.  The disk returns the characters in the wrong endian for us, so
    // swap them here.
    //

    UshortSource = (PUSHORT)IdentifyDataString;
    UshortDestinationEnd = (PUSHORT)(DiskIdentifierBuffer + DiskIdentifierLength);

    for (UshortDestination = (PUSHORT)DiskIdentifierBuffer; UshortDestination <
        UshortDestinationEnd; UshortDestination++) {
        *UshortDestination = RtlUshortByteSwap(*UshortSource++);
    }

    //
    // Strip off the trailing spaces from the string.
    //

    EndBuffer = DiskIdentifierBuffer + DiskIdentifierLength;

    while (EndBuffer > DiskIdentifierBuffer) {

        if (*(EndBuffer - 1) != ' ') {
            break;
        }

        EndBuffer--;
    }

    //
    // Initialize the global string with the pointer to the buffer, the string's
    // actual length, and the string's maximum possible length.
    //

    DiskIdentifierString->Buffer = DiskIdentifierBuffer;
    DiskIdentifierString->Length = (USHORT)(EndBuffer - DiskIdentifierBuffer);
    DiskIdentifierString->MaximumLength = (USHORT)DiskIdentifierLength;
}

VOID
IdexDiskCreateQuick(
    VOID
    )
/*++

Routine Description:

    This routine initializes the disk device subsystem after a quick reboot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PVOID DiskDirectoryObject;
    HANDLE DiskDirectoryHandle;
    PDEVICE_OBJECT DiskDeviceObject;
    PIDE_DISK_EXTENSION DiskExtension;

    //
    // Create the dynamic disk directory that will contain our device objects.
    //

    InitializeObjectAttributes(&ObjectAttributes, &IdexDiskDirectoryName,
        OBJ_PERMANENT | OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = ObCreateObject(&IdexDiskDirectoryObjectType, &ObjectAttributes, 0,
        (PVOID *)&DiskDirectoryObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_DISK, status);
    }

    status = ObInsertObject(DiskDirectoryObject, &ObjectAttributes, 0,
        &DiskDirectoryHandle);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_DISK, status);
    }

    NtClose(DiskDirectoryHandle);

    //
    // Create the disk's Partition0 device object.
    //

    status = IoCreateDevice(&IdexDiskDriverObject, sizeof(IDE_DISK_EXTENSION),
        NULL, FILE_DEVICE_DISK, FALSE, &DiskDeviceObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_DISK, status);
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    DiskDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Indicate that the disk itself should only be mounted with the RAW file
    // system.
    //

    DiskDeviceObject->Flags |= DO_RAW_MOUNT_ONLY;

    //
    // Set the alignment requirement for the device.
    //

    DiskDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    DiskDeviceObject->SectorSize = IDE_ATA_SECTOR_SIZE;

    //
    // Initialize the disk's device extension data.
    //

    DiskExtension = (PIDE_DISK_EXTENSION)DiskDeviceObject->DeviceExtension;

    DiskExtension->DeviceObject = DiskDeviceObject;

    //
    // Compute the length of the partition (the size in bytes of the entire
    // disk).
    //

    DiskExtension->PartitionInformation.PartitionLength.QuadPart =
        (ULONGLONG)IdexDiskUserAddressableSectors * IDE_ATA_SECTOR_SIZE;
    DiskExtension->PartitionInformation.PartitionNumber = 0;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    DiskDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Insert the Partition0 device object into the global array of created
    // device objects.
    //

    IdexDiskPartitionArray[0] = DiskDeviceObject;
}

NTSTATUS
IdexDiskSetDeviceParameters(
    VOID
    )
/*++

Routine Description:

    This routine sets the device parameters for the disk device to the maximum
    number of logical sectors per track and logical heads.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_DISK_DEVICE_NUMBER);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // Issue the set device parameters command.
    //

    IdexProgramTargetDeviceWithData(IDE_DISK_DEVICE_NUMBER, 15);

    IdexWriteSectorCountPort(63);

    IdexWriteCommandPort(IDE_COMMAND_SET_DEVICE_PARAMETERS);

    //
    // Spin until the device is not busy.
    //

    if (!IdexChannelSpinWhileBusy(&IdeStatus)) {
        return STATUS_IO_TIMEOUT;
    }

    //
    // If the channel has raised an error, then abandon the request.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    return STATUS_SUCCESS;
}

VOID
IdexDiskSecurityUnlock(
    UCHAR Password[IDE_ATA_PASSWORD_LENGTH]
    )
/*++

Routine Description:

    This routine unlocks the disk device.

Arguments:

    Password - Specifies the password of the disk device.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    IDE_SECURITY_DATA SecurityData;
    ATA_PASS_THROUGH AtaPassThrough;
    KIRQL OldIrql;
    IDE_IDENTIFY_DATA IdentifyData;

    //
    // Prepare the security sector.
    //

    RtlZeroMemory(&SecurityData, sizeof(IDE_SECURITY_DATA));
    RtlCopyMemory(SecurityData.Password, Password, IDE_ATA_PASSWORD_LENGTH);

    //
    // Prepare the pass through structure.
    //

    RtlZeroMemory(&AtaPassThrough.IdeReg, sizeof(IDEREGS));
    AtaPassThrough.IdeReg.bCommandReg = IDE_COMMAND_SECURITY_UNLOCK;
    AtaPassThrough.IdeReg.bHostSendsData = TRUE;
    AtaPassThrough.DataBufferSize = sizeof(IDE_SECURITY_DATA);
    AtaPassThrough.DataBuffer = &SecurityData;

    //
    // Issue the security unlock command.
    //

    status = IoSynchronousDeviceIoControlRequest(IOCTL_IDE_PASS_THROUGH,
        IdexDiskPartitionArray[0], &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
        &AtaPassThrough, sizeof(ATA_PASS_THROUGH), NULL, FALSE);

    if (NT_SUCCESS(status)) {

        //
        // Check if the device raised an error.
        //

        if (IdexIsFlagSet(AtaPassThrough.IdeReg.bCommandReg, IDE_STATUS_ERR)) {
            status = STATUS_IO_DEVICE_ERROR;
        } else {
            IdexDiskSecurityUnlocked = TRUE;
            status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(status)) {

        IdexDbgPrint(("IDEX: hard disk failed to unlock (status=%08x).\n", status));

        //
        // We failed to unlock the drive.  If the console is not in the
        // manufacturing region, then fail to boot the system.
        //

		/*## -- continue so that at least the user can run configmagic from
		//         a CD...
        if (IdexIsFlagClear(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {
            IdexDiskFatalError(FATAL_ERROR_HDD_CANNOT_UNLOCK);
        }*/
    }

    //
    // The Western Digital drives have a firmware bug where after unlocking the
    // drive, the sequential read mode of the drive's cache is not properly
    // initialized causing severe performance degradation.  The workaround to
    // cause the cache to be properly initialized is to issue another ATA
    // identify device command followed by a set device parameters command.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    status = IdexChannelIdentifyDevice(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_IDENTIFY_DEVICE, &IdentifyData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    }

    status = IdexDiskSetDeviceParameters();

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    }

    KeLowerIrql(OldIrql);
}

VOID
IdexDiskIncrementPowerCycleCount(
    VOID
    )
/*++

Routine Description:

    This routine increments the number of times that the system has been power
    cycled.  This information is stored in the refurb information sector on the
    disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    XBOX_REFURB_INFO RefurbInfo;

    //
    // If this is a shadow boot, then don't increment the number of power
    // cycles.  If this boot is showing a short animation, then this can't be a
    // power on boot, so also don't increment the number of power cycles.
    //
    // Also, if the console is in the manufacturing region, then don't write out
    // anything to the disk.
    //

    if (IdexIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_SHADOW) ||
        IdexIsFlagSet(XboxBootFlags, XBOX_BOOTFLAG_SHORTANIMATION) ||
        IdexIsFlagSet(XboxGameRegion, XC_GAME_REGION_MANUFACTURING)) {
        return;
    }

    //
    // Read the refurb information from the drive.
    //

    status = ExReadWriteRefurbInfo(&RefurbInfo, sizeof(XBOX_REFURB_INFO), FALSE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: failed to read refurb info (status=%08x).\n", status));
        return;
    }

    //
    // Increment the number of times that the system has been powered on.
    //

    RefurbInfo.PowerCycleCount++;

    //
    // Write the refurb information back out to the drive.
    //

    status = ExReadWriteRefurbInfo(&RefurbInfo, sizeof(XBOX_REFURB_INFO), TRUE);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: failed to write refurb info (status=%08x).\n", status));
        return;
    }
}

VOID
IdexDiskCreate(
    VOID
    )
/*++

Routine Description:

    This routine initializes the disk device subsystem.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    ULONG Retries;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    IDE_IDENTIFY_DATA IdentifyData;
    UCHAR Password[IDE_ATA_PASSWORD_LENGTH];

    //
    // Wait for the device to finish its hardware reset sequence.  When cold
    // booting, the IDE controller in the south bridge will do a hardware reset
    // of the IDE bus, so we don't need to a software reset here.
    //
    // If we're booting a kernel that was loaded from the hard disk or CD-ROM,
    // then the device should already be ready to go, so we can skip the
    // initialization here.
    //

    HalPulseHardwareMonitorPin();

    if (IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_SHADOW)) {

        //
        // Spin for up to thirty seconds as required by the ATA specification.
        //

        for (Retries = 600; Retries > 0; Retries--) {

            if (IdexDiskPollResetComplete()) {
                break;
            }

            //
            // Delay for 50 milliseconds.
            //

            Interval.QuadPart = -50 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }

        if (Retries == 0) {
            IdexDbgPrint(("IDEX: hard disk timed out during reset.\n"));
            IdexDiskFatalError(FATAL_ERROR_HDD_TIMEOUT);
        }
    }

    //
    // The below calls may cause an interrupt to be raised, so while we're
    // initializing the hardware, raise IRQL to synchronize with the interrupt
    // service routine.
    //

    IdexRaiseIrqlToChannelDIRQL(&OldIrql);

    //
    // Set the PIO transfer mode for the disk device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_DISK_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_PIO_MODE_4);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not PIO configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }

    //
    // Set the DMA transfer mode for the disk device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelSetTransferMode(IDE_DISK_DEVICE_NUMBER,
        IDE_TRANSFER_MODE_UDMA_MODE_2);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not DMA configured (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }

    //
    // Issue an ATA identify device command in order to determine the geometry
    // of the disk device.
    //

    HalPulseHardwareMonitorPin();

    status = IdexChannelIdentifyDevice(IDE_DISK_DEVICE_NUMBER,
        IDE_COMMAND_IDENTIFY_DEVICE, &IdentifyData);

    if (!NT_SUCCESS(status)) {
        IdexDbgPrint(("IDEX: hard disk not found (status=%02x).\n",
            IdexReadStatusPort()));
        KeLowerIrql(OldIrql);
        IdexDiskFatalError(FATAL_ERROR_HDD_NOT_FOUND);
    }

    KeLowerIrql(OldIrql);

    //
    // Build the disk identification strings.
    //

    IdexDiskInitIdentifierString(IdentifyData.ModelNumber,
        IdexDiskModelNumberBuffer, sizeof(IdexDiskModelNumberBuffer),
        &HalDiskModelNumber);
    IdexDiskInitIdentifierString(IdentifyData.SerialNumber,
        IdexDiskSerialNumberBuffer, sizeof(IdexDiskSerialNumberBuffer),
        &HalDiskSerialNumber);

#ifdef IDEX_DISK_FIXED_SECTOR_COUNT
    //
    // Verify that the disk has at least the fixed number of sectors that we're
    // hardcoded to support.
    //

    if (IdentifyData.UserAddressableSectors < XDISK_FIXED_SECTOR_COUNT) {
        IdexDbgPrint(("IDEX: hard disk too small.\n"));
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }
#else
    //
    // Compute the number of cache partitions available on the disk.
    //

    HalDiskCachePartitionCount =
        XDISK_NUMBER_OF_CACHE_PARTITIONS(IdentifyData.UserAddressableSectors);

    if (HalDiskCachePartitionCount == 0) {
        IdexDbgPrint(("IDEX: hard disk too small to have a cache partition.\n"));
        IdexDiskFatalError(FATAL_ERROR_HDD_BAD_CONFIG);
    }

    //
    // Verify that the number of cache partitions doesn't exceed the size of the
    // global array of device objects minus the partitions 0 through 2 (the
    // entire disk, the data partition, and the shell partition).
    //

    if (HalDiskCachePartitionCount > IDE_DISK_PARTITION_ARRAY_ELEMENTS -
        XDISK_FIRST_CACHE_PARTITION) {
        HalDiskCachePartitionCount = IDE_DISK_PARTITION_ARRAY_ELEMENTS -
            XDISK_FIRST_CACHE_PARTITION;
    }

    //
    // Compute the number of sectors allocated to the data partition.
    //

    IdexDiskDataPartitionSectors = IdentifyData.UserAddressableSectors -
        (XDISK_UNPARTITIONED_SECTORS + XDISK_SHELL_PARTITION_SECTORS +
        (HalDiskCachePartitionCount * XDISK_CACHE_PARTITION_SECTORS));
#endif

    //
    // Store the number of user addressable sectors so that its available after
    // a quick reboot.
    //

    IdexDiskUserAddressableSectors = IdentifyData.UserAddressableSectors;

    //
    // At this point, we can use the quick boot creation code.
    //

    IdexDiskCreateQuick();

    //
    // Check if the drive has the security feature enabled.
    //

    HalPulseHardwareMonitorPin();

    if (IdentifyData.SecurityEnabled) {

        //
        // Check if the drive needs to be unlocked.
        //

        if (IdentifyData.SecurityLocked) {

            //
            // Generate the password using the hard disk key stored in the
            // EEPROM and the hard disk's model and serial numbers.
            //

            RtlZeroMemory(Password, IDE_ATA_PASSWORD_LENGTH);

            XcHMAC(XboxHDKey, XBOX_KEY_LENGTH, HalDiskModelNumber.Buffer,
                HalDiskModelNumber.Length, HalDiskSerialNumber.Buffer,
                HalDiskSerialNumber.Length, Password);

            //
            // Attempt to unlock the drive.
            //

            IdexDiskSecurityUnlock(Password);

        } else {

            //
            // The security feature is enabled, but the drive's password has
            // already been cleared.  There isn't anyway to verify the password
            // once the drive is unlocked, so we'll have to assume that we
            // unlocked it in a previous instance of the kernel.
            //

            IdexDiskSecurityUnlocked = TRUE;
        }

    } else {

        //
        // The loader will check to see if the XBE that is found is allowed to
        // run from a non-secure drive or if we're in the manufacturing region
        // where a non-secure drive is always allowed.
        //

        IdexDbgPrint(("IDEX: hard disk is not locked.\n"));
    }

    //
    // Increment the number of times that the system has been powered on.  The
    // CD-ROM device will still be busy detecting media, so this shouldn't have
    // a significant impact on boot time.
    //

    HalPulseHardwareMonitorPin();

    IdexDiskIncrementPowerCycleCount();
}

//
// Driver object for the disk object.
//
DECLSPEC_RDATA DRIVER_OBJECT IdexDiskDriverObject = {
    IdexDiskStartIo,                    // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CREATE
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CLOSE
        IdexDiskReadWrite,              // IRP_MJ_READ
        IdexDiskReadWrite,              // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IdexDiskFlushBuffers,           // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        IdexDiskDeviceControl,          // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//
// Object type for the dynamic disk directory.
//
DECLSPEC_RDATA OBJECT_TYPE IdexDiskDirectoryObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    IdexDiskParseDirectory,
    &ObpDefaultObject,
    'ksiD'
};

#else

//
// These disk identification strings are used by various other pieces of code to
// help uniquely identify this system.  The strings are based on the data
// returned from IDE_COMMAND_IDENTIFY_DEVICE.
//
DECLSPEC_RDATA STRING HalDiskModelNumber;
DECLSPEC_RDATA STRING HalDiskSerialNumber;

//
// Number of cache partitions available on the disk.
//
DECLSPEC_RDATA ULONG HalDiskCachePartitionCount = 0;

VOID
IdexDiskShutdownSystem(
    VOID
    )
/*++

Routine Description:

    This routine flushes and spins down the disk device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\driver.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    driver.c

Abstract:

    This module implements routines that apply to the driver object including
    initialization and IRP dispatch routines.

--*/

#include "idex.h"

NTSTATUS
IdexDriverIrpReturnSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles IRPs that should always return STATUS_SUCCESS.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;
}

VOID
IdexBugCheckWorker(
    IN ULONG FileAndLineCode,
    IN ULONG_PTR BugCheckParameter1
    )
/*++

Routine Description:

    This routine is a wrapper for KeBugCheckEx so that the generated code for
    IdexBugCheck is smaller.

Arguments:

    FileAndLineCode - Specifies the file and line identifiers as generated by
        the IdexBugCheck macro.

    BugCheckParameter1 - Specifies the first bug check parameter to KeBugCheckEx.

Return Value:

    None.

--*/
{
    KeBugCheckEx(PORT_DRIVER_INTERNAL, FileAndLineCode, BugCheckParameter1, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\mediabrd.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    mediabrd.h

Abstract:

    This module contains the definitions and structures for interfacing with a
    Sega media board.

--*/

#ifndef _MEDIABRD_
#define _MEDIABRD_

//
// Define the media board's extended IDE command values.
//

#define MEDIA_BOARD_COMMAND_REGISTER_READ16                 0x50
#define MEDIA_BOARD_COMMAND_REGISTER_WRITE16                0x51
#define MEDIA_BOARD_COMMAND_BOOT_ERASE                      0x52
#define MEDIA_BOARD_COMMAND_BOOT_WRITE                      0x53
#define MEDIA_BOARD_COMMAND_REGISTER_READ32                 0x60
#define MEDIA_BOARD_COMMAND_REGISTER_WRITE32                0x61

//
// Define the starting logical block addresses and sector count of the various
// areas of the media board.
//

#define MEDIA_BOARD_FILE_SYSTEM_AREA_START_LBA              0x0000000
#define MEDIA_BOARD_COMMUNICATION_AREA_ASIC_START_LBA       0x9000000
#define MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT         0x8000
#define MEDIA_BOARD_BOOT_ROM_START_LBA                      0x8000000
#define MEDIA_BOARD_BOOT_ROM_FPGA_SECTOR_COUNT              0x1000
#define MEDIA_BOARD_BOOT_ROM_ASIC_SECTOR_COUNT              0x2000

//
// Define the static partition numbers.
//

#define MEDIA_BOARD_FILE_SYSTEM_PARTITION                   0
#define MEDIA_BOARD_COMMUNICATION_AREA_PARTITION            2
#define MEDIA_BOARD_BOOT_ROM_PARTITION                      3

#endif  // MEDIABRD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\sources.inc ===
!IF 0

Copyright (c) 1989-2002  Microsoft Corporation

!ENDIF

MAJORCOMP=ntos
MINORCOMP=idex

TARGETPATH=$(BASEDIR)\private\ntos\obj
TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\public\ddk\inc;$(BASEDIR)\private\inc\crypto

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\cdrom.c    \
        ..\channel.c  \
        ..\disk.c     \
        ..\driver.c

PRECOMPILED_INCLUDE=..\idex.h
PRECOMPILED_PCH=idex.pch
PRECOMPILED_OBJ=idex.obj
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\idex.h ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    idex.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the IDE port driver.

--*/

#ifndef _IDEX_
#define _IDEX_

#include <ntos.h>
#include <pci.h>
#include <ldr.h>
#include <scsi.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <idexchan.h>
#include <xcrypt.h>
#include <dvdx2.h>
#include <xdisk.h>
#include <smcdef.h>
#include <xconfig.h>
#include <segalpc.h>
#include <stdio.h>
#include <conio.h>
#include <limits.h>
#include <pshpack4.h>

//
// Enforce a hard limit of XDISK_FIXED_SECTOR_COUNT hard disk sectors when the
// following is defined.
//

#define IDEX_DISK_FIXED_SECTOR_COUNT

//
// DBG sensitive DbgPrint and DbgBreakPoint wrappers.
//

#if DBG
#define IdexDbgPrint(x)                         DbgPrint x
#define IdexDbgBreakPoint()                     DbgBreakPoint()
#else
#define IdexDbgPrint(x)
#define IdexDbgBreakPoint()
#endif

//
// Bit flag macros.
//

#define IdexIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define IdexIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Bug check module codes.
//

#define IDE_BUG_CHECK_CDROM                     (0x00010000)
#define IDE_BUG_CHECK_CHANNEL                   (0x00020000)
#define IDE_BUG_CHECK_DISK                      (0x00030000)
#define IDE_BUG_CHECK_DRIVER                    (0x00040000)
#define IDE_BUG_CHECK_MEDIA_BOARD               (0x00050000)

//
// Define the number of times that an operation will be retried after a device
// error is detected or after a timeout occurs.  For all of the above IRP codes,
// the retry count is placed in Argument4 of the IRP stack.
//

#define IDE_NO_RETRY_COUNT                      0
#define IDE_NORMAL_RETRY_COUNT                  4

//
// Define the timeouts in seconds for various IDE operations.
//

#define IDE_ATA_DEFAULT_TIMEOUT                 10
#define IDE_ATA_FLUSH_TIMEOUT                   30
#define IDE_ATAPI_DEFAULT_TIMEOUT               12

//
// Define the timer periods in milliseconds for various states of IRP handling.
//

#define IDE_SLOW_TIMER_PERIOD                   1000
#define IDE_FAST_TIMER_PERIOD                   100

//
// Macros to synchronize execution with the interrupt service routine.  The
// proper way to handle this is via KeSynchronizeExecution, but we can generate
// smaller code by raising and lowering the interrupt IRQL ourselves.
//

#define IdexRaiseIrqlToChannelDIRQL(oldirql) \
    KeRaiseIrql(IdexChannelObject.InterruptIrql, (oldirql))

#define IdexRaiseIrqlToChannelDIRQLFromDPCLevel() { \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL); \
    KfRaiseIrql(IdexChannelObject.InterruptIrql); \
}

#define IdexLowerIrqlFromChannelDIRQL(oldirql) \
    KeLowerIrql(oldirql);

#define IdexAssertIrqlAtChannelDIRQL() \
    ASSERT(KeGetCurrentIrql() == IdexChannelObject.InterruptIrql)

//
// Macros to wrap the indirection of routines through the channel object.
//

#define IdexChannelStartPacket(device, irp) \
    IdexChannelObject.StartPacketRoutine(device, irp)

#define IdexChannelStartNextPacket() \
    IdexChannelObject.StartNextPacketRoutine()

//
// Disk device extension data.
//

typedef struct _IDE_DISK_EXTENSION {
    PDEVICE_OBJECT DeviceObject;
    PARTITION_INFORMATION PartitionInformation;
} IDE_DISK_EXTENSION, *PIDE_DISK_EXTENSION;

//
// Media board device extension data.
//

typedef struct _IDE_MEDIA_BOARD_EXTENSION {
    PDEVICE_OBJECT DeviceObject;
    PARTITION_INFORMATION PartitionInformation;
} IDE_MEDIA_BOARD_EXTENSION, *PIDE_MEDIA_BOARD_EXTENSION;

//
// Define the default device numbers for the various IDE devices.
//

#define IDE_DISK_DEVICE_NUMBER                  0
#define IDE_CDROM_DEVICE_NUMBER                 1
#define IDE_MEDIA_BOARD_DEVICE_NUMBER           1

//
// Define the PCI resource for the bus master interface.
//

#define IDE_PCI_BUS_MASTER_BASE                 XPCICFG_IDE_IO_REGISTER_BASE_4
#define IDE_PCI_BUS_MASTER_BMICP                (IDE_PCI_BUS_MASTER_BASE + 0x0)
#define IDE_PCI_BUS_MASTER_BMISP                (IDE_PCI_BUS_MASTER_BASE + 0x2)
#define IDE_PCI_BUS_MASTER_BMIDP                (IDE_PCI_BUS_MASTER_BASE + 0x4)
#define IDE_PCI_BUS_MASTER_BMICS                (IDE_PCI_BUS_MASTER_BASE + 0x8)
#define IDE_PCI_BUS_MASTER_BMISS                (IDE_PCI_BUS_MASTER_BASE + 0xA)
#define IDE_PCI_BUS_MASTER_BMIDS                (IDE_PCI_BUS_MASTER_BASE + 0xC)

//
// Define the legacy ISA resources for single IDE channel support.
//

#define IDE_CHANNEL_COMMAND_BASE                0x01F0
#define IDE_CHANNEL_CONTROL_BASE                0x03F4
#define IDE_CHANNEL_IRQ_RESOURCE                14

//
// Macros to compute the IDE registers for an IDE channel.  These macros allow
// us to expand to multiple channels in the future.
//

#define IDE_DATA_REGISTER                       (IDE_CHANNEL_COMMAND_BASE + 0)
#define IDE_ERROR_REGISTER                      (IDE_CHANNEL_COMMAND_BASE + 1)
#define IDE_SECTOR_COUNT_REGISTER               (IDE_CHANNEL_COMMAND_BASE + 2)
#define IDE_SECTOR_NUMBER_REGISTER              (IDE_CHANNEL_COMMAND_BASE + 3)
#define IDE_CYLINDER_LOW_REGISTER               (IDE_CHANNEL_COMMAND_BASE + 4)
#define IDE_CYLINDER_HIGH_REGISTER              (IDE_CHANNEL_COMMAND_BASE + 5)
#define IDE_DEVICE_SELECT_REGISTER              (IDE_CHANNEL_COMMAND_BASE + 6)
#define IDE_STATUS_REGISTER                     (IDE_CHANNEL_COMMAND_BASE + 7)
#define IDE_COMMAND_REGISTER                    (IDE_CHANNEL_COMMAND_BASE + 7)
#define IDE_ALTERNATE_STATUS_REGISTER           (IDE_CHANNEL_CONTROL_BASE + 2)
#define IDE_DEVICE_CONTROL_REGISTER             (IDE_CHANNEL_CONTROL_BASE + 2)

//
// Macros to read and write from the IDE registers.  These macros allow us to
// hook the reads and writes to the registers on an individual basis.
//

#define IdexReadDataPortUchar() \
    IdexReadPortUchar(IDE_DATA_REGISTER)

#define IdexWriteDataPortUchar(data) \
    IdexWritePortUchar(IDE_DATA_REGISTER, (data))

#define IdexReadDataPortUshort() \
    IdexReadPortUshort(IDE_DATA_REGISTER)

#define IdexReadDataPortBufferUshort(buffer, count) \
    IdexReadPortBufferUshort(IDE_DATA_REGISTER, (buffer), (count))

#define IdexWriteDataPortBufferUshort(buffer, count) \
    IdexWritePortBufferUshort(IDE_DATA_REGISTER, (buffer), (count))

#define IdexReadDataPortBufferUlong(buffer, count) \
    IdexReadPortBufferUlong(IDE_DATA_REGISTER, (buffer), (count))

#define IdexWriteDataPortBufferUlong(buffer, count) \
    IdexWritePortBufferUlong(IDE_DATA_REGISTER, (buffer), (count))

#define IdexReadErrorPort() \
    IdexReadPortUchar(IDE_ERROR_REGISTER)

#define IdexReadSectorCountPort() \
    IdexReadPortUchar(IDE_SECTOR_COUNT_REGISTER)

#define IdexWriteSectorCountPort(data) \
    IdexWritePortUchar(IDE_SECTOR_COUNT_REGISTER, (data))

#define IdexReadSectorNumberPort() \
    IdexReadPortUchar(IDE_SECTOR_NUMBER_REGISTER)

#define IdexWriteSectorNumberPort(data) \
    IdexWritePortUchar(IDE_SECTOR_NUMBER_REGISTER, (data))

#define IdexReadCylinderLowPort() \
    IdexReadPortUchar(IDE_CYLINDER_LOW_REGISTER)

#define IdexWriteCylinderLowPort(data) \
    IdexWritePortUchar(IDE_CYLINDER_LOW_REGISTER, (data))

#define IdexReadCylinderHighPort() \
    IdexReadPortUchar(IDE_CYLINDER_HIGH_REGISTER)

#define IdexWriteCylinderHighPort(data) \
    IdexWritePortUchar(IDE_CYLINDER_HIGH_REGISTER, (data))

#define IdexReadDeviceSelectPort() \
    IdexReadPortUchar(IDE_DEVICE_SELECT_REGISTER)

#define IdexWriteDeviceSelectPort(data) \
    IdexWritePortUchar(IDE_DEVICE_SELECT_REGISTER, (data))

#define IdexReadStatusPort() \
    IdexReadPortUchar(IDE_STATUS_REGISTER)

#define IdexWriteCommandPort(data) \
    IdexWritePortUchar(IDE_COMMAND_REGISTER, (data))

#define IdexReadAlternateStatusPort() \
    IdexReadPortUchar(IDE_ALTERNATE_STATUS_REGISTER)

#define IdexWriteDeviceControlPort(data) \
    IdexWritePortUchar(IDE_DEVICE_CONTROL_REGISTER, (data))

//
// Macros to access the IDE registers using the ATAPI register names.
//

#define IdexWriteFeaturesPort(data) \
    IdexWritePortUchar(IDE_ERROR_REGISTER, (data))

#define IdexReadInterruptReasonPort     IdexReadSectorCountPort
#define IdexReadByteCountLowPort        IdexReadCylinderLowPort
#define IdexWriteByteCountLowPort       IdexWriteCylinderLowPort
#define IdexReadByteCountHighPort       IdexReadCylinderHighPort
#define IdexWriteByteCountHighPort      IdexWriteCylinderHighPort

//
// Macros to access the IDE registers from a more abstract level.
//

#define IdexProgramTargetDevice(device) \
    IdexWriteDeviceSelectPort((UCHAR)(0xA0 | ((device) << 4)))

#define IdexProgramTargetDeviceWithData(device, data) \
    IdexWriteDeviceSelectPort((UCHAR)(0xA0 | ((device) << 4) | ((data) & 0xF)))

#define IdexProgramLBATransfer(device, sector, count) { \
    IdexWriteDeviceSelectPort((UCHAR)(0xE0 | ((device) << 4) | \
        (((sector) & 0xF000000) >> 24))); \
    IdexWriteSectorNumberPort((UCHAR)(((sector) & 0xFF) >> 0)); \
    IdexWriteCylinderLowPort((UCHAR)(((sector) & 0xFF00) >> 8)); \
    IdexWriteCylinderHighPort((UCHAR)(((sector) & 0xFF0000) >> 16)); \
    IdexWriteSectorCountPort((UCHAR)(count)); \
}

#define IdexWriteDataPortCdb(cdb) \
    IdexWriteDataPortBufferUlong((PULONG)(cdb), 3);

//
// Define the IDE status register flags.
//

#define IDE_STATUS_ERR                          ((UCHAR)0x01)
#define IDE_STATUS_DRQ                          ((UCHAR)0x08)
#define IDE_STATUS_DRDY                         ((UCHAR)0x40)
#define IDE_STATUS_BSY                          ((UCHAR)0x80)

//
// Define the IDE device control register flags.
//

#define IDE_DEVICE_CONTROL_NIEN                 ((UCHAR)0x02)
#define IDE_DEVICE_CONTROL_SRST                 ((UCHAR)0x04)

//
// Define the IDE command values.
//

#define IDE_COMMAND_DEVICE_RESET                ((UCHAR)0x08)
#define IDE_COMMAND_READ_SECTORS                ((UCHAR)0x20)
#define IDE_COMMAND_WRITE_SECTORS               ((UCHAR)0x30)
#define IDE_COMMAND_VERIFY                      ((UCHAR)0x40)
#define IDE_COMMAND_SET_DEVICE_PARAMETERS       ((UCHAR)0x91)
#define IDE_COMMAND_PACKET                      ((UCHAR)0xA0)
#define IDE_COMMAND_IDENTIFY_PACKET_DEVICE      ((UCHAR)0xA1)
#define IDE_COMMAND_READ_MULTIPLE               ((UCHAR)0xC4)
#define IDE_COMMAND_WRITE_MULTIPLE              ((UCHAR)0xC5)
#define IDE_COMMAND_SET_MULTIPLE_MODE           ((UCHAR)0xC6)
#define IDE_COMMAND_READ_DMA                    ((UCHAR)0xC8)
#define IDE_COMMAND_WRITE_DMA                   ((UCHAR)0xCA)
#define IDE_COMMAND_STANDBY_IMMEDIATE           ((UCHAR)0xE0)
#define IDE_COMMAND_FLUSH_CACHE                 ((UCHAR)0xE7)
#define IDE_COMMAND_IDENTIFY_DEVICE             ((UCHAR)0xEC)
#define IDE_COMMAND_SET_FEATURES                ((UCHAR)0xEF)
#define IDE_COMMAND_SECURITY_SET_PASSWORD       ((UCHAR)0xF1)
#define IDE_COMMAND_SECURITY_UNLOCK             ((UCHAR)0xF2)
#define IDE_COMMAND_SECURITY_DISABLE_PASSWORD   ((UCHAR)0xF6)

//
// Define the IDE feature values for an ATA device.
//

#define IDE_FEATURE_SET_TRANSFER_MODE           ((UCHAR)0x03)

//
// Define the IDE feature flags for an ATAPI device.
//

#define IDE_FEATURE_DMA                         ((UCHAR)0x01)
#define IDE_FEATURE_OVL                         ((UCHAR)0x02)

//
// Define the IDE interrupt reason flags for an ATAPI device.
//

#define IDE_INTERRUPT_REASON_CD                 ((UCHAR)0x01)
#define IDE_INTERRUPT_REASON_IO                 ((UCHAR)0x02)

//
// Define the data transfer values for an ATA device.
//

#define IDE_ATA_SECTOR_SHIFT                    9
#define IDE_ATA_SECTOR_SIZE                     (1 << IDE_ATA_SECTOR_SHIFT)
#define IDE_ATA_SECTOR_MASK                     (IDE_ATA_SECTOR_SIZE - 1)
#define IDE_ATA_MAXIMUM_TRANSFER_SECTORS        256
#define IDE_ATA_MAXIMUM_TRANSFER_BYTES          (IDE_ATA_MAXIMUM_TRANSFER_SECTORS * IDE_ATA_SECTOR_SIZE)
#define IDE_ATA_MAXIMUM_TRANSFER_PAGES          (IDE_ATA_MAXIMUM_TRANSFER_BYTES >> PAGE_SHIFT)

//
// Define the data transfer values for an ATAPI device.
//

#define IDE_ATAPI_CD_SECTOR_SHIFT               11
#define IDE_ATAPI_CD_SECTOR_SIZE                (1 << IDE_ATAPI_CD_SECTOR_SHIFT)
#define IDE_ATAPI_CD_SECTOR_MASK                (IDE_ATAPI_CD_SECTOR_SIZE - 1)
#define IDE_ATAPI_CD_MAXIMUM_TRANSFER_SECTORS   64
#define IDE_ATAPI_RAW_CD_SECTOR_SIZE            2352
#define IDE_ATAPI_MAXIMUM_TRANSFER_BYTES        (IDE_ATAPI_CD_MAXIMUM_TRANSFER_SECTORS * IDE_ATAPI_CD_SECTOR_SIZE)
#define IDE_ATAPI_MAXIMUM_TRANSFER_PAGES        (IDE_ATAPI_MAXIMUM_TRANSFER_BYTES >> PAGE_SHIFT)

//
// Define the transfer modes for the set transfer mode feature.
//

#define IDE_TRANSFER_MODE_PIO                   ((UCHAR)0x00)
#define IDE_TRANSFER_MODE_PIO_NO_IORDY          ((UCHAR)0x01)
#define IDE_TRANSFER_MODE_PIO_MODE_3            ((UCHAR)0x0B)
#define IDE_TRANSFER_MODE_PIO_MODE_4            ((UCHAR)0x0C)
#define IDE_TRANSFER_MODE_MWDMA_MODE_0          ((UCHAR)0x20)
#define IDE_TRANSFER_MODE_MWDMA_MODE_1          ((UCHAR)0x21)
#define IDE_TRANSFER_MODE_MWDMA_MODE_2          ((UCHAR)0x22)
#define IDE_TRANSFER_MODE_UDMA_MODE_0           ((UCHAR)0x40)
#define IDE_TRANSFER_MODE_UDMA_MODE_1           ((UCHAR)0x41)
#define IDE_TRANSFER_MODE_UDMA_MODE_2           ((UCHAR)0x42)
#define IDE_TRANSFER_MODE_UDMA_MODE_3           ((UCHAR)0x43)
#define IDE_TRANSFER_MODE_UDMA_MODE_4           ((UCHAR)0x44)
#define IDE_TRANSFER_MODE_UDMA_MODE_5           ((UCHAR)0x45)

//
// Define the number of bytes in a password buffer for an ATA device.
//

#define IDE_ATA_PASSWORD_LENGTH                 32

//
// Define the data buffer alignment requirements for a DMA bus master operation.
//

#define IDE_ALIGNMENT_REQUIREMENT               FILE_WORD_ALIGNMENT

//
// Macros to read and write from the PCI bus master interface.
//

#define IdexReadBusMasterCommandPort(channel) \
    IdexReadPortUchar(IDE_PCI_BUS_MASTER_BMICP)

#define IdexWriteBusMasterCommandPort(data) \
    IdexWritePortUchar(IDE_PCI_BUS_MASTER_BMICP, (data))

#define IdexReadBusMasterStatusPort() \
    IdexReadPortUchar(IDE_PCI_BUS_MASTER_BMISP)

#define IdexWriteBusMasterStatusPort(data) \
    IdexWritePortUchar(IDE_PCI_BUS_MASTER_BMISP, (data))

#define IdexReadBusMasterDescriptorTablePort() \
    IdexReadPortUlong(IDE_PCI_BUS_MASTER_BMIDP)

#define IdexWriteBusMasterDescriptorTablePort(data) \
    IdexWritePortUlong(IDE_PCI_BUS_MASTER_BMIDP, (data))

//
// Define the bus master interface command register flags.
//

#define IDE_BUS_MASTER_COMMAND_START            0x01
#define IDE_BUS_MASTER_COMMAND_READ             0x08

//
// Define the bus master interface status register flags.
//

#define IDE_BUS_MASTER_STATUS_ACTIVE            0x01
#define IDE_BUS_MASTER_STATUS_ERROR             0x02
#define IDE_BUS_MASTER_STATUS_INTERRUPT         0x04

//
// Structure that's passed to the bus master interface to indicate the location
// of the data buffer's pages.
//

typedef struct _IDE_PCI_PHYSICAL_REGION_DESCRIPTOR {
    ULONG PhysicalAddress;
    union {
        ULONG AsULong;
        struct {
            ULONG AsUShort : 16;
            ULONG Reserved : 15;
            ULONG EndOfTable : 1;
        } b;
    } ByteCount;
} IDE_PCI_PHYSICAL_REGION_DESCRIPTOR, *PIDE_PCI_PHYSICAL_REGION_DESCRIPTOR;

//
// Routines that act on the driver device.
//

NTSTATUS
IdexDriverIrpReturnSuccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Routines that act on the channel device.
//

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusy(
    OUT PUCHAR IdeStatus
    );

BOOLEAN
FASTCALL
IdexChannelSpinWhileBusyAndNotDrq(
    OUT PUCHAR IdeStatus
    );

VOID
IdexChannelSetTimerPeriod(
    IN LONG Period
    );

VOID
FASTCALL
IdexChannelPrepareBufferTransfer(
    IN PUCHAR Buffer,
    IN ULONG ByteCount
    );

VOID
IdexChannelPrepareScatterGatherTransfer(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG SegmentByteOffset,
    IN ULONG ByteCount
    );

VOID
IdexChannelRestartCurrentPacket(
    VOID
    );

VOID
IdexChannelAbortCurrentPacket(
    VOID
    );

VOID
FASTCALL
IdexChannelInvalidParameterRequest(
    IN PIRP Irp
    );

VOID
IdexChannelStartIdePassThrough(
    IN PIRP Irp,
    IN UCHAR TargetDevice,
    IN PIDE_RESET_DEVICE_ROUTINE ResetDeviceRoutine
    );

NTSTATUS
IdexChannelIdentifyDevice(
    IN UCHAR TargetDevice,
    IN UCHAR IdentifyCommand,
    OUT PIDE_IDENTIFY_DATA IdentifyData
    );

NTSTATUS
IdexChannelSetTransferMode(
    IN UCHAR TargetDevice,
    IN UCHAR TransferMode
    );

NTSTATUS
IdexChannelIssueImmediateCommand(
    IN UCHAR TargetDevice,
    IN UCHAR IdeCommand
    );

VOID
IdexChannelCreate(
    VOID
    );

//
// Routines that act on the disk device.
//

VOID
IdexDiskCreateQuick(
    VOID
    );

VOID
IdexDiskCreate(
    VOID
    );

//
// Routines that act on the CD-ROM device.
//

BOOLEAN
IdexCdRomPollResetComplete(
    VOID
    );

VOID
IdexCdRomCreateQuick(
    VOID
    );

VOID
IdexCdRomCreate(
    VOID
    );

//
// Routines that act on the media board device.
//

DECLSPEC_NORETURN
VOID
IdexMediaBoardFatalError(
    IN ULONG ErrorCode
    );

VOID
IdexMediaBoardCreateQuick(
    VOID
    );

VOID
IdexMediaBoardCreate(
    VOID
    );

//
// Routines that perform I/O port operations.
//

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

#define IdexReadPortUchar(port)             ((UCHAR)_inp((USHORT)(port)))
#define IdexReadPortUshort(port)            ((USHORT)_inpw((USHORT)(port)))
#define IdexReadPortUlong(port)             ((ULONG)_inpd((USHORT)(port)))
#define IdexWritePortUchar(port, data)      (_outp((USHORT)(port),(UCHAR)(data)))
#define IdexWritePortUshort(port, data)     (_outpw((USHORT)(port),(USHORT)(data)))
#define IdexWritePortUlong(port, data)      (_outpd((USHORT)(port),(ULONG)(data)))

#define IdexReadPortBufferUshort(port, buffer, count) \
    READ_PORT_BUFFER_USHORT((PUSHORT)(port), buffer, count)
#define IdexWritePortBufferUshort(port, buffer, count) \
    WRITE_PORT_BUFFER_USHORT((PUSHORT)(port), buffer, count)
#define IdexReadPortBufferUlong(port, buffer, count) \
    READ_PORT_BUFFER_ULONG((PULONG)(port), buffer, count)
#define IdexWritePortBufferUlong(port, buffer, count) \
    WRITE_PORT_BUFFER_ULONG((PULONG)(port), buffer, count)

//
// Macros to swap the byte order of a USHORT or ULONG at compile time.
//

#define IdexConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define IdexConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))

//
// Miscellaneous routines.
//

DECLSPEC_NORETURN
VOID
IdexBugCheckWorker(
    IN ULONG FileAndLineCode,
    IN ULONG_PTR BugCheckParameter1
    );

#define IdexBugCheck(fileid, parameter1) \
    IdexBugCheckWorker((((ULONG)fileid) | __LINE__), ((ULONG_PTR)parameter1))

//
// External symbols.
//

extern DRIVER_OBJECT IdexDiskDriverObject;
extern OBJECT_TYPE IdexDiskDirectoryObjectType;
extern DRIVER_OBJECT IdexCdRomDriverObject;
extern DRIVER_OBJECT IdexMediaBoardDriverObject;

#include <poppack.h>

#endif  // IDEX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\mediabrd.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    mediabrd.c

Abstract:

    This module implements routines that apply to the media board object.

--*/

#include "idex.h"
#include "mediabrd.h"

//
// Name of the media board object directory and its device object.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardDirectoryName,
    "\\Device\\MediaBoard");

//
// Name of the media board's file system area device object and its DOS devices
// symbolic link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardFsDeviceName,
    "\\Device\\MediaBoard\\Partition0");
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardFsDosDevicesName, "\\??\\mbfs:");

//
// Name of the media board's communication area device object and its DOS
// devices symbolic link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardCommunicationDeviceName,
    "\\Device\\MediaBoard\\Partition1");
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardCommunicationDosDevicesName,
    "\\??\\mbcom:");

//
// Name of the media board's boot ROM device object and its DOS devices symbolic
// link.
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardBootROMDeviceName,
    "\\Device\\MediaBoard\\Partition2");
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardBootROMDosDevicesName,
    "\\??\\mbrom:");

//
//
//
INITIALIZED_OBJECT_STRING_RDATA(IdexMediaBoardCdRomDeviceName, "\\Device\\CdRom0");

//
// Number of sectors addressable from the driver.
//
DECLSPEC_STICKY ULONG IdexMediaBoardUserAddressableSectors;

//
// Stores whether or not this is the FPGA version of the media board.
//
DECLSPEC_STICKY BOOLEAN IdexMediaBoardFPGABoard;

//
// Local support.
//

VOID
IdexMediaBoardFinishBootROMEraseSector(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdexMediaBoardFatalError)
#pragma alloc_text(INIT, IdexMediaBoardCreate)
#endif

BOOLEAN
IdexMediaBoardPollResetComplete(
    VOID
    )
/*++

Routine Description:

    This routine polls the media board device to check for completion of a reset
    sequence.

Arguments:

    None.

Return Value:

    Returns TRUE if the device has completed its reset sequence.

--*/
{
    UCHAR IdeStatus;

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_MEDIA_BOARD_DEVICE_NUMBER);

    //
    // Check if the device is busy.
    //

    IdeStatus = IdexReadStatusPort();

    if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
IdexMediaBoardResetDevice(
    VOID
    )
/*++

Routine Description:

    This routine software resets the media board device.

Arguments:

    None.

Return Value:

    None.

--*/
{
    IdexAssertIrqlAtChannelDIRQL();

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_MEDIA_BOARD_DEVICE_NUMBER);

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(IDE_COMMAND_DEVICE_RESET);

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Speed up the timer to check for completion of the reset sequence.
    //

    IdexChannelSetTimerPeriod(IDE_FAST_TIMER_PERIOD);

    //
    // Delay for up to twenty-five seconds (100 milliseconds per unit).
    //

    IdexChannelObject.PollResetCompleteRoutine = IdexMediaBoardPollResetComplete;
    IdexChannelObject.Timeout = 250;
}

BOOLEAN
IdexMediaBoardSelectDeviceAndSpinWhileBusy(
    VOID
    )
/*++

Routine Description:

    This routine selects the media board device and spins until the the IDE
    status register's BSY bit is clear, which indicates that the device is ready
    to accept a command.

Arguments:

    None.

Return Value:

    Returns TRUE if the BSY bit was clear before timing out, else FALSE.

--*/
{
    ULONG Retries;
    UCHAR IdeStatus;

    IdexAssertIrqlAtChannelDIRQL();

    //
    // Select the IDE device.
    //

    IdexProgramTargetDevice(IDE_MEDIA_BOARD_DEVICE_NUMBER);

    //
    // Spin for up to a tenth second.
    //

    for (Retries = 1000; Retries > 0; Retries--) {

        IdeStatus = IdexReadStatusPort();

        if (IdexIsFlagClear(IdeStatus, IDE_STATUS_BSY)) {
            return TRUE;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // Lower the IRQL back to DISPATCH_LEVEL.
    //

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);

    //
    // Mark the IRP as timed out.  The caller will pass this IRP to the generic
    // error handler which will reset the device and retry the IRP if allowed.
    //

    IdexChannelObject.CurrentIrp->IoStatus.Status = STATUS_IO_TIMEOUT;

    return FALSE;
}

VOID
IdexMediaBoardTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that transfers data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR BusMasterStatus;
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the bus master status register and verify that the interrupt bit is
    // set if we haven't already seen the bus master interrupt.
    //

    BusMasterStatus = IdexReadBusMasterStatusPort();

    if (IdexChannelObject.ExpectingBusMasterInterrupt) {

        if (IdexIsFlagClear(BusMasterStatus, IDE_BUS_MASTER_STATUS_INTERRUPT)) {
            return;
        }

        //
        // Deactivate the bus master interface and dismiss the interrupt.
        //

        IdexWriteBusMasterCommandPort(0);
        IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

        IdexChannelObject.ExpectingBusMasterInterrupt = FALSE;
    }

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Deactivate the bus master interface and dismiss the interrupt.
    //

    IdexWriteBusMasterCommandPort(0);
    IdexWriteBusMasterStatusPort(IDE_BUS_MASTER_STATUS_INTERRUPT);

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR) ||
        IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ERROR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else if (IdexIsFlagSet(BusMasterStatus, IDE_BUS_MASTER_STATUS_ACTIVE)) {
        Irp->IoStatus.Status = STATUS_DATA_OVERRUN;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexMediaBoardNoTransferInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is invoked when a hardware interrupt occurs on the channel's
    IRQ and the pending interrupt IRP is for an ATA request that doesn't
    transfer any data.

Arguments:

    None.

Return Value:

    None.

--*/
{
    UCHAR IdeStatus;
    PIRP Irp;

    //
    // Read the status register to dismiss the interrupt.
    //

    IdeStatus = IdexReadStatusPort();

    //
    // Clear the interrupt routine and grab the current IRP.
    //

    IdexChannelObject.InterruptRoutine = NULL;
    Irp = IdexChannelObject.CurrentIrp;

    //
    // Set the status code as appropriate.
    //

    if (IdexIsFlagSet(IdeStatus, IDE_STATUS_ERR)) {
        Irp->IoStatus.Status = STATUS_IO_DEVICE_ERROR;
    } else {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    // Finish processing the IRP at DPC level.
    //

    KeInsertQueueDpc(&IdexChannelObject.FinishDpc, NULL, NULL);
}

VOID
IdexMediaBoardFinishGeneric(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to generically finish processing a
    request after its hardware interrupt has fired or after the IDE command has
    timed out.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;

    Irp = IdexChannelObject.CurrentIrp;

    if (Irp->IoStatus.Status == STATUS_IO_TIMEOUT) {

        //
        // Attempt to reset the device.  If the reset completes successfully and
        // the retry count has not been exceeded the maximum retry count, then
        // the IRP will be restarted.
        //

        IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

        IdexMediaBoardResetDevice();

        return;
    }

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
IdexMediaBoardFinishBootROMWriteFlash(
    VOID
    )
/*++

Routine Description:

    This routine flashes the next 16-bit value from the user's buffer.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    ULONG FlashAddress;
    PUCHAR Buffer;
    PIDE_FINISHIO_ROUTINE FinishIoRoutine;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexMediaBoardSelectDeviceAndSpinWhileBusy()) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // Program the address in the ROM to be flashed.
    //

    FlashAddress = ((IrpSp->Parameters.IdexReadWrite.SectorNumber -
        MEDIA_BOARD_BOOT_ROM_START_LBA) << IDE_ATA_SECTOR_SHIFT) +
        (IDE_ATA_SECTOR_SIZE -
        (IrpSp->Parameters.IdexReadWrite.Length & IDE_ATA_SECTOR_MASK));
DbgPrint("flash address=%08x\n", FlashAddress);

    IdexWriteFeaturesPort((UCHAR)FlashAddress);
    IdexWriteSectorCountPort((UCHAR)(FlashAddress >> 8));
    IdexWriteSectorNumberPort((UCHAR)(FlashAddress >> 16));

    //
    // Program the 16-bit value to be flashed.
    //

    Buffer = IrpSp->Parameters.IdexReadWrite.Buffer +
        IrpSp->Parameters.IdexReadWrite.BufferOffset;
DbgPrint("buffer=%08x, data=%04x\n", Buffer, *((PUSHORT)Buffer));

    IdexWriteCylinderLowPort(*Buffer);
    IdexWriteCylinderHighPort(*(Buffer + 1));

    //
    // Issue the IDE command.
    //

    IdexWriteCommandPort(MEDIA_BOARD_COMMAND_BOOT_WRITE);

    //
    // Adjust the number of bytes remaining to be transferred
    //

    IrpSp->Parameters.IdexReadWrite.Length -= sizeof(USHORT);
    IrpSp->Parameters.IdexReadWrite.BufferOffset += sizeof(USHORT);

    //
    // Determine which step to advance to next.  If there are no more bytes
    // remaining to be transferred, then we'll complete the request on
    // completion.  If we're at a sector boundary, then we'll need to erase the
    // next sector.  Otherwise, return to this routine in order to flash the
    // next byte.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length == 0) {
        FinishIoRoutine = IdexMediaBoardFinishGeneric;
    } else if ((IrpSp->Parameters.IdexReadWrite.Length & IDE_ATA_SECTOR_MASK) == 0) {
        IrpSp->Parameters.IdexReadWrite.SectorNumber++;
        FinishIoRoutine = IdexMediaBoardFinishBootROMEraseSector;
    } else {
        FinishIoRoutine = IdexMediaBoardFinishBootROMWriteFlash;
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexMediaBoardNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = FinishIoRoutine;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

VOID
IdexMediaBoardFinishBootROMEraseSector(
    VOID
    )
/*++

Routine Description:

    This routine erases a sector of the boot ROM.  This must be done prior to
    flashing new data into the boot ROM.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    ASSERT((IrpSp->Parameters.IdexReadWrite.Length & IDE_ATA_SECTOR_MASK) == 0);

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexMediaBoardSelectDeviceAndSpinWhileBusy()) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // Issue the IDE command.
    //

    IdexProgramLBATransfer(IDE_MEDIA_BOARD_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber, 0);
DbgPrint("erase sector=%08x\n", IrpSp->Parameters.IdexReadWrite.SectorNumber);

    IdexWriteCommandPort(MEDIA_BOARD_COMMAND_BOOT_ERASE);

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexMediaBoardNoTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexMediaBoardFinishBootROMWriteFlash;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

VOID
IdexMediaBoardFinishReadWrite(
    VOID
    )
/*++

Routine Description:

    This routine is invoked at DPC level to finish processing a IRP_MJ_READ or
    IRP_MJ_WRITE request.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;

    Irp = IdexChannelObject.CurrentIrp;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Jump to the generic handler to process errors.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        IdexMediaBoardFinishGeneric();
        return;
    }

    //
    // If there are still more bytes to transfer in this request, then adjust
    // the transfer counts and requeue the packet.
    //

    if (IrpSp->Parameters.IdexReadWrite.Length > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {

        //
        // If the console is preparing to reset or shutdown, there's no reason
        // to continue processing this request.
        //

        if (HalIsResetOrShutdownPending()) {
            IdexChannelAbortCurrentPacket();
            return;
        }

        IrpSp->Parameters.IdexReadWrite.Length -= IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.BufferOffset += IDE_ATA_MAXIMUM_TRANSFER_BYTES;
        IrpSp->Parameters.IdexReadWrite.SectorNumber += IDE_ATA_MAXIMUM_TRANSFER_SECTORS;

        IdexChannelStartPacket(IrpSp->DeviceObject, Irp);
        IdexChannelStartNextPacket();
        return;
    }

    //
    // Complete the request and start the next packet.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    IdexChannelStartNextPacket();
}

VOID
FASTCALL
IdexMediaBoardStartReadWrite(
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles queued IRP_MJ_READ and IRP_MJ_WRITE requests.

Arguments:

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;
    ULONG TransferLength;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // If this is a write request to the boot ROM, then we need to go down a
    // different code path.  The boot ROM doesn't implement the write DMA
    // command.
    //

    if (IrpSp->MajorFunction == IRP_MJ_WRITE) {

        MediaBoardExtension =
            (PIDE_MEDIA_BOARD_EXTENSION)IrpSp->DeviceObject->DeviceExtension;

        if (MediaBoardExtension->PartitionInformation.PartitionNumber ==
            MEDIA_BOARD_BOOT_ROM_PARTITION) {

            //
            // No retries are allowed for this IRP.
            //

            IdexChannelObject.MaximumIoRetries = IDE_NO_RETRY_COUNT;

            //
            // Initialize the status of the operation to success.
            //

            Irp->IoStatus.Status = STATUS_SUCCESS;

            //
            // Enter the state machine for writing to the boot ROM.
            //

__asm int 3;
            IdexMediaBoardFinishBootROMEraseSector();

            return;
        }
    }

    //
    // If the number of bytes remaining is greater than the maximum transfer
    // size allowed by the hardware, then clip the number of bytes to the
    // maximum.
    //

    TransferLength = IrpSp->Parameters.IdexReadWrite.Length;

    if (TransferLength > IDE_ATA_MAXIMUM_TRANSFER_BYTES) {
        TransferLength = IDE_ATA_MAXIMUM_TRANSFER_BYTES;
    }

    //
    // Synchronize execution with the interrupt service routine.
    //

    IdexRaiseIrqlToChannelDIRQLFromDPCLevel();

    //
    // Select the IDE device and spin until the device is not busy.
    //

    if (!IdexMediaBoardSelectDeviceAndSpinWhileBusy()) {
        IdexMediaBoardFinishReadWrite();
        return;
    }

    //
    // Prepare the bus master interface for the DMA transfer.
    //

    if (IdexIsFlagClear(Irp->Flags, IRP_SCATTER_GATHER_OPERATION) ||
        IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IdexChannelPrepareBufferTransfer(IrpSp->Parameters.IdexReadWrite.Buffer +
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    } else {
        IdexChannelPrepareScatterGatherTransfer(Irp->SegmentArray,
            IrpSp->Parameters.IdexReadWrite.BufferOffset, TransferLength);
    }

    //
    // Issue the IDE command and activate the bus master interface.
    //

    IdexProgramLBATransfer(IDE_MEDIA_BOARD_DEVICE_NUMBER,
        IrpSp->Parameters.IdexReadWrite.SectorNumber,
        (TransferLength >> IDE_ATA_SECTOR_SHIFT));

    if (IrpSp->MajorFunction == IRP_MJ_READ) {
        IdexWriteCommandPort(IDE_COMMAND_READ_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START |
            IDE_BUS_MASTER_COMMAND_READ);
    } else {
        IdexWriteCommandPort(IDE_COMMAND_WRITE_DMA);
        IdexWriteBusMasterCommandPort(IDE_BUS_MASTER_COMMAND_START);
    }

    //
    // Indicate that we're expecting an interrupt for this IRP.
    //

    ASSERT(IdexChannelObject.InterruptRoutine == NULL);

    IdexChannelObject.InterruptRoutine = IdexMediaBoardTransferInterrupt;
    IdexChannelObject.FinishIoRoutine = IdexMediaBoardFinishReadWrite;
    IdexChannelObject.ExpectingBusMasterInterrupt = TRUE;
    IdexChannelObject.Timeout = IDE_ATA_DEFAULT_TIMEOUT;

    IdexLowerIrqlFromChannelDIRQL(DISPATCH_LEVEL);
}

NTSTATUS
IdexMediaBoardReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O manager to handle IRP_MJ_READ and
    IRP_MJ_WRITE requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;
    PIO_STACK_LOCATION IrpSp;
    LONGLONG StartingByteOffset;
    LONGLONG EndingByteOffset;

    MediaBoardExtension = (PIDE_MEDIA_BOARD_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the parameters are valid.  The buffer length must be an
    // integral number of sectors, the starting offset must be sector aligned,
    // and the ending offset must be within the bounds of the disk.  The I/O
    // buffer must have the proper device alignment.
    //

    StartingByteOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    EndingByteOffset = StartingByteOffset + IrpSp->Parameters.Read.Length;

    if (IdexIsFlagClear(IrpSp->Flags, SL_FSCACHE_REQUEST)) {

        if (((PtrToUlong(Irp->UserBuffer) & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.BufferOffset & IDE_ALIGNMENT_REQUIREMENT) != 0) ||
            ((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) != 0) ||
            ((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) != 0) ||
            (EndingByteOffset >
                MediaBoardExtension->PartitionInformation.PartitionLength.QuadPart)) {

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INVALID_PARAMETER;
        }

    } else {

        //
        // Bypass parameter checking if this request is coming from the cache.
        // We'll trust that the file system cache is submitting a valid request,
        // but we'll double check in debug.
        //

        ASSERT((PtrToUlong(IrpSp->Parameters.Read.CacheBuffer) &
            IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.Length & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT((IrpSp->Parameters.Read.ByteOffset.LowPart & IDE_ATA_SECTOR_MASK) == 0);
        ASSERT(EndingByteOffset <=
            MediaBoardExtension->PartitionInformation.PartitionLength.QuadPart);
    }

    //
    // If this is a zero length request, then we can complete the IRP now.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_SUCCESS;
    }

    //
    // Adjust the starting byte offset by the partition's starting offset.
    //

    StartingByteOffset += MediaBoardExtension->PartitionInformation.StartingOffset.QuadPart;

    //
    // Convert the I/O request parameters to the internal IDE format.  The
    // internal format unpacks the cache buffer and buffer offset fields to
    // different fields by collapsing the byte offset to a sector number.
    //

    IrpSp->Parameters.IdexReadWrite.SectorNumber = (ULONG)(StartingByteOffset >>
        IDE_ATA_SECTOR_SHIFT);

    ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.Length) ==
           FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Length));

    //
    // Move the buffer pointer and the buffer starting offset around depending
    // on whether or not this is a file system cache request.
    //

    if (IdexIsFlagSet(IrpSp->Flags, SL_FSCACHE_REQUEST)) {
        IrpSp->Parameters.IdexReadWrite.BufferOffset = 0;
        ASSERT(FIELD_OFFSET(IO_STACK_LOCATION, Parameters.Read.CacheBuffer) ==
               FIELD_OFFSET(IO_STACK_LOCATION, Parameters.IdexReadWrite.Buffer));
    } else {
        IrpSp->Parameters.IdexReadWrite.BufferOffset =
            IrpSp->Parameters.Read.BufferOffset;
        IrpSp->Parameters.IdexReadWrite.Buffer = (PUCHAR)Irp->UserBuffer;
    }

    //
    // Initialize the IRP's information result to the number of bytes
    // transferred.
    //

    Irp->IoStatus.Information = IrpSp->Parameters.IdexReadWrite.Length;

    //
    // Queue the I/O reqeust.
    //

    IoMarkIrpPending(Irp);
    IdexChannelStartPacket(DeviceObject, Irp);

    return STATUS_PENDING;
}

NTSTATUS
IdexMediaBoardGetDriveGeometry(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_DRIVE_GEOMETRY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PDISK_GEOMETRY DiskGeometry;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(DISK_GEOMETRY)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    DiskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
    DiskGeometry->Cylinders.QuadPart = IdexMediaBoardUserAddressableSectors;
    DiskGeometry->MediaType = FixedMedia;
    DiskGeometry->TracksPerCylinder = 1;
    DiskGeometry->SectorsPerTrack = 1;
    DiskGeometry->BytesPerSector = IDE_ATA_SECTOR_SIZE;

    Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexMediaBoardGetPartitionInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_GET_PARTITION_INFO request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;
    PIO_STACK_LOCATION IrpSp;
    PPARTITION_INFORMATION PartitionInformation;

    MediaBoardExtension = (PIDE_MEDIA_BOARD_EXTENSION)DeviceObject->DeviceExtension;
    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Verify that the output buffer is large enough to receive the data.
    //

    if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
        sizeof(PARTITION_INFORMATION)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Fill in the output buffer and return.
    //

    PartitionInformation = (PPARTITION_INFORMATION)Irp->UserBuffer;

    *PartitionInformation = MediaBoardExtension->PartitionInformation;

    Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);

    return STATUS_SUCCESS;
}

NTSTATUS
IdexMediaBoardDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is indirectly called by the I/O manager to handle
    IRP_MJ_DEVICE_CONTROL requests.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    NTSTATUS status;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            status = IdexMediaBoardGetDriveGeometry(DeviceObject, Irp);
            break;

        case IOCTL_DISK_GET_PARTITION_INFO:
            status = IdexMediaBoardGetPartitionInfo(DeviceObject, Irp);
            break;

        case IOCTL_IDE_PASS_THROUGH:
            IoMarkIrpPending(Irp);
            IdexChannelStartPacket(DeviceObject, Irp);
            status = STATUS_PENDING;
            break;

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    //
    // If the request is no longer pending, then complete the request.
    //

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;
}

VOID
IdexMediaBoardStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the channel to handle the next queued I/O request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If the console is preparing to reset or shutdown, there's no reason to
    // continue processing this request.
    //

    if (HalIsResetOrShutdownPending()) {
        IdexChannelAbortCurrentPacket();
        return;
    }

    //
    // Mark all IRPS as must complete IRPs because we have to wait for
    // completion of any disk device command in order to issue the shutdown
    // commands.
    //

    IoMarkIrpMustComplete(Irp);

    //
    // Dispatch the IRP request.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    switch (IrpSp->MajorFunction) {

        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
            IdexMediaBoardStartReadWrite(Irp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

                case IOCTL_IDE_PASS_THROUGH:
                    IdexChannelStartIdePassThrough(Irp,
                        IDE_MEDIA_BOARD_DEVICE_NUMBER, IdexMediaBoardResetDevice);
                    break;

                default:
                    IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, Irp);
                    break;
            }
            break;

        default:
            IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, Irp);
            break;
    }
}

VOID
IdexMediaBoardFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine is called when a fatal media board device related error is
    detected.

Arguments:

    ErrorCode - Specifies the fatal error code.

Return Value:

    None.

--*/
{
    IdexDbgBreakPoint();

    //
    // Flush the LEDs to indicate that there is CD-ROM related problem.
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_RED_STATE0 | SMC_LED_STATES_GREEN_STATE1 |
        SMC_LED_STATES_GREEN_STATE2 | SMC_LED_STATES_GREEN_STATE3);

    //
    // Display the universal error message.
    //

    ExDisplayFatalError(ErrorCode);
}

VOID
IdexMediaBoardCreateDevice(
    IN POBJECT_STRING DeviceName,
    IN POBJECT_STRING DosDevicesName,
    IN ULONG StartingSector,
    IN ULONG NumberOfSectors,
    IN ULONG PartitionNumber,
    IN BOOLEAN RawMountOnly
    )
/*++

Routine Description:

    This routine constructs and initializes a media board device object.

Arguments:

    DeviceName - Specifies the name of the device object.

    DosDevicesName - Specifies the DOS devices name of the device object.

    StartingSector - Specifies the starting sector number of the partition.

    NumberOfSectors - Specifies the number of sectors in the partition.

    PartitionNumber - Specifies the partition number.

    RawMountOnly - Specifies TRUE if the device should only be mounted with the
        RAW file system, else FALSE.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT MediaBoardDeviceObject;
    PIDE_MEDIA_BOARD_EXTENSION MediaBoardExtension;

    //
    // Create the media board's device object.
    //

    status = IoCreateDevice(&IdexMediaBoardDriverObject,
        sizeof(IDE_MEDIA_BOARD_EXTENSION), DeviceName, FILE_DEVICE_MEDIA_BOARD,
        FALSE, &MediaBoardDeviceObject);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }

    //
    // Create the \DosDevices symbolic link.
    //

    status = IoCreateSymbolicLink(DosDevicesName, DeviceName);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }

    //
    // Mark the device object as support direct I/O so that user buffers are
    // passed down to us as locked buffers.  Also indicate that we can accept
    // scatter/gather buffers.
    //

    MediaBoardDeviceObject->Flags |= DO_DIRECT_IO | DO_SCATTER_GATHER_IO;

    //
    // Indicate that the disk itself should only be mounted with the RAW file
    // system, if appropriate.
    //

    if (RawMountOnly) {
        MediaBoardDeviceObject->Flags |= DO_RAW_MOUNT_ONLY;
    }

    //
    // Set the alignment requirement for the device.
    //

    MediaBoardDeviceObject->AlignmentRequirement = IDE_ALIGNMENT_REQUIREMENT;

    //
    // Set the size of a sector in bytes for the device.
    //

    MediaBoardDeviceObject->SectorSize = IDE_ATA_SECTOR_SIZE;

    //
    // Initialize the media board's device extension data.
    //

    MediaBoardExtension = (PIDE_MEDIA_BOARD_EXTENSION)MediaBoardDeviceObject->DeviceExtension;

    MediaBoardExtension->DeviceObject = MediaBoardDeviceObject;

    //
    // Compute the partition information for the device.
    //

    MediaBoardExtension->PartitionInformation.StartingOffset.QuadPart =
        ((ULONGLONG)StartingSector * IDE_ATA_SECTOR_SIZE);
    MediaBoardExtension->PartitionInformation.PartitionLength.QuadPart =
        ((ULONGLONG)NumberOfSectors * IDE_ATA_SECTOR_SIZE);
    MediaBoardExtension->PartitionInformation.PartitionNumber = PartitionNumber;

    //
    // The device has finished initializing and is ready to accept requests.
    //

    MediaBoardDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
}

VOID
IdexMediaBoardCreateQuick(
    VOID
    )
/*++

Routine Description:

    This routine initializes the media board device subsystem after a quick
    reboot.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE MediaBoardDirectoryHandle;
    ULONG FileSystemAreaSectorCount;
    ULONG BootROMSectorCount;

    //
    // Create the static media board directory that will contain our device
    // objects.
    //

    InitializeObjectAttributes(&ObjectAttributes, &IdexMediaBoardDirectoryName,
        OBJ_PERMANENT | OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateDirectoryObject(&MediaBoardDirectoryHandle,
        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }

    NtClose(MediaBoardDirectoryHandle);

    //
    // Create the file system area partition object.  For the FPGA board, we
    // have to remove some of the sectors from the end of the partition for the
    // communication area.
    //

    FileSystemAreaSectorCount = IdexMediaBoardUserAddressableSectors;

    if (IdexMediaBoardFPGABoard) {
        FileSystemAreaSectorCount -= MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT;
    }

    IdexMediaBoardCreateDevice(&IdexMediaBoardFsDeviceName,
        &IdexMediaBoardFsDosDevicesName, MEDIA_BOARD_FILE_SYSTEM_AREA_START_LBA,
        FileSystemAreaSectorCount, 0, FALSE);

    //
    // Create the communication area partition object.  For the FPGA board, the
    // communication area is at the top of the DIMM memory.  For the ASIC board,
    // the communication area is in its own address range.
    //

    if (IdexMediaBoardFPGABoard) {
        IdexMediaBoardCreateDevice(&IdexMediaBoardCommunicationDeviceName,
            &IdexMediaBoardCommunicationDosDevicesName,
            FileSystemAreaSectorCount,
            MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT, 1, TRUE);
    } else {
        IdexMediaBoardCreateDevice(&IdexMediaBoardCommunicationDeviceName,
            &IdexMediaBoardCommunicationDosDevicesName,
            MEDIA_BOARD_COMMUNICATION_AREA_ASIC_START_LBA,
            MEDIA_BOARD_COMMUNICATION_AREA_SECTOR_COUNT, 1, TRUE);
    }

    //
    // Create the boot ROM partition object.
    //

    BootROMSectorCount = (IdexMediaBoardFPGABoard ?
        MEDIA_BOARD_BOOT_ROM_FPGA_SECTOR_COUNT :
        MEDIA_BOARD_BOOT_ROM_ASIC_SECTOR_COUNT);

    IdexMediaBoardCreateDevice(&IdexMediaBoardBootROMDeviceName,
        &IdexMediaBoardBootROMDosDevicesName, MEDIA_BOARD_BOOT_ROM_START_LBA,
        BootROMSectorCount, 2, TRUE);

    //
    //
    //

    status = IoCreateSymbolicLink(&IdexMediaBoardCdRomDeviceName,
        &IdexMediaBoardFsDeviceName);

    if (!NT_SUCCESS(status)) {
        IdexBugCheck(IDE_BUG_CHECK_MEDIA_BOARD, status);
    }
}

VOID
IdexMediaBoardCreate(
    VOID
    )
/*++

Routine Description:

    This routine initializes the media board device subsystem.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Retries;
    LARGE_INTEGER Interval;
    USHORT ChipRevision;
    PCI_SLOT_NUMBER PCISlotNumber;
    UCHAR PCIData;
    USHORT DimmSize;
    ULONG UserAddressableSectors;

    //
    // Wait for the device to finish its hardware reset sequence.  When cold
    // booting, the IDE controller in the south bridge will do a hardware reset
    // of the IDE bus, so we don't need to a software reset here.
    //
    // If we're booting a kernel that was loaded from the hard disk or CD-ROM,
    // then the device should already be ready to go, so we can skip the
    // initialization here.
    //

    HalPulseHardwareMonitorPin();

    if (IdexIsFlagClear(XboxBootFlags, XBOX_BOOTFLAG_SHADOW)) {

        //
        // Spin for up to thirty seconds as required by the ATA specification.
        //

        for (Retries = 600; Retries > 0; Retries--) {

            if (IdexMediaBoardPollResetComplete()) {
                break;
            }

            //
            // Delay for 50 milliseconds.
            //

            Interval.QuadPart = -50 * 10000;
            KeDelayExecutionThread(KernelMode, FALSE, &Interval);
        }

        if (Retries == 0) {
            IdexDbgPrint(("IDEX: media board timed out during reset.\n"));
            IdexMediaBoardFatalError(FATAL_ERROR_HDD_TIMEOUT);
        }
    }

    //
    // Check the chip revision of the media board.  Different versions of the
    // media board operate at different DMA and PIO transfer modes.
    //

    PCISlotNumber.u.AsULONG = 0;
    PCISlotNumber.u.bits.DeviceNumber = XPCICFG_IDE_DEVICE_ID;
    PCISlotNumber.u.bits.FunctionNumber = XPCICFG_IDE_FUNCTION_ID;

    ChipRevision = IdexReadPortUshort(SEGA_REGISTER_CHIP_REVISION);

    if ((ChipRevision & SEGA_CHIP_REVISION_CHIP_ID_MASK) ==
        SEGA_CHIP_REVISION_FPGA_CHIP_ID) {

        //
        // Remember that this is a FPGA board.
        //

        IdexMediaBoardFPGABoard = TRUE;

        //
        // Disable UDMA access.
        //

        PCIData = 0x00;
        HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x62, &PCIData, sizeof(UCHAR));

        //
        // Change the DMA transfer mode to MDMA mode 0.
        //

        PCIData = 0x77;
        HalWritePCISpace(0, PCISlotNumber.u.AsULONG, 0x5A, &PCIData, sizeof(UCHAR));
    }

    //
    // Determine the number of user addressable sectors given the DIMM size
    // reported by the media board.
    //

    DimmSize = IdexReadPortUshort(SEGA_REGISTER_DIMM_SIZE);

    switch (DimmSize & SEGA_DIMM_SIZE_SIZE_MASK) {

        case SEGA_DIMM_SIZE_128M:
            UserAddressableSectors = ((128 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        case SEGA_DIMM_SIZE_256M:
            UserAddressableSectors = ((256 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        case SEGA_DIMM_SIZE_512M:
            UserAddressableSectors = ((512 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        case SEGA_DIMM_SIZE_1024M:
            UserAddressableSectors = ((1024 * 1024 * 1024) >> IDE_ATA_SECTOR_SHIFT);
            break;

        default:
            __assume(0);
    }

    IdexMediaBoardUserAddressableSectors = UserAddressableSectors;

    //
    // At this point, we can use the quick boot creation code.
    //

    IdexMediaBoardCreateQuick();
}

//
// Driver object for the media board object.
//
DECLSPEC_RDATA DRIVER_OBJECT IdexMediaBoardDriverObject = {
    IdexMediaBoardStartIo,              // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CREATE
        IdexDriverIrpReturnSuccess,     // IRP_MJ_CLOSE
        IdexMediaBoardReadWrite,        // IRP_MJ_READ
        IdexMediaBoardReadWrite,        // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        IdexMediaBoardDeviceControl,    // IRP_MJ_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\idex\dvdx2.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dvdx2.h

Abstract:

    This module contains the definitions and structures for interfacing with a
    DVD-X2 ATAPI drive.

--*/

#ifndef _DVDX2_
#define _DVDX2_

#include <windef.h>
#include <xcrypt.h>
#include <sha.h>
#include <rc4.h>

#include <pshpack1.h>

//
// DVD-X2 specific additional sense codes.
//

#define DVDX2_ADSENSE_SPEED_REDUCTION_REQUESTED     0x80    // sense key 0x01
#define DVDX2_ADSENSE_GENERAL_READ_ERROR            0x80    // sense key 0x03
#define DVDX2_ADSENSE_COPY_PROTECTION_FAILURE       0x80    // sense key 0x05
#define DVDX2_ADSENSE_COMMAND_ERROR                 0x81    // sense key 0x05
#define DVDX2_ADSENSE_INSUFFICIENT_TIME             0x2E    // sense key 0x06

//
// DVD-X2 specific mode sense and select extensions.
//

#define DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL      0x20
#define DVDX2_MODE_PAGE_AUTHENTICATION              0x3E

//
// DVD-X2 advanced drive control page.
//

typedef struct _DVDX2_ADVANCED_DRIVE_CONTROL_PAGE {
    UCHAR PageCode : 6;         //  DVDX2_MODE_PAGE_ADVANCED_DRIVE_CONTROL
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR SpindleSpeedControl;
    UCHAR Reserved2[9];
} DVDX2_ADVANCED_DRIVE_CONTROL_PAGE, *PDVDX2_ADVANCED_DRIVE_CONTROL_PAGE;

typedef struct _DVDX2_ADVANCED_DRIVE_CONTROL {
    MODE_PARAMETER_HEADER10 Header;
    DVDX2_ADVANCED_DRIVE_CONTROL_PAGE AdvancedDriveControlPage;
} DVDX2_ADVANCED_DRIVE_CONTROL, *PDVDX2_ADVANCED_DRIVE_CONTROL;

//
// Define the DVD-X2 spindle speed control parameters.
//

#define DVDX2_SPINDLE_SPEED_MINIMUM                 0
#define DVDX2_SPINDLE_SPEED_MEDIUM                  1
#define DVDX2_SPINDLE_SPEED_MAXIMUM                 2

//
// DVD-X2 authentication page.
//

typedef struct _DVDX2_AUTHENTICATION_PAGE {
    UCHAR PageCode : 6;         //  DVDX2_MODE_PAGE_AUTHENTICATION
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR PartitionArea;
    UCHAR CDFValid;
    UCHAR Authentication;
    UCHAR DiscCategoryAndVersion;
    UCHAR DrivePhaseLevel;
    UCHAR ChallengeID;
    ULONG ChallengeValue;
    ULONG ResponseValue;
    ULONG Reserved2;
} DVDX2_AUTHENTICATION_PAGE, *PDVDX2_AUTHENTICATION_PAGE;

typedef struct _DVDX2_AUTHENTICATION {
    MODE_PARAMETER_HEADER10 Header;
    DVDX2_AUTHENTICATION_PAGE AuthenticationPage;
} DVDX2_AUTHENTICATION, *PDVDX2_AUTHENTICATION;

#define DVDX2_CDF_INVALID                           0x00
#define DVDX2_CDF_VALID                             0x01

//
// DVD-X2 host challenge response entry.
//

typedef struct _DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY {
    UCHAR ChallengeLevel;
    UCHAR ChallengeID;
    ULONG ChallengeValue;
    UCHAR ResponseModifier;
    ULONG ResponseValue;
} DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY, *PDVDX2_HOST_CHALLENGE_RESPONSE_ENTRY;

//
// Define the maximum number of entries allocated in the host challenge response
// table.
//

#define DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT   23

//
// DVD-X2 host challenge response table.
//

typedef struct _DVDX2_HOST_CHALLENGE_RESPONSE_TABLE {
    UCHAR Version;
    UCHAR NumberOfEntries;
    DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY Entries[DVDX2_HOST_CHALLENGE_RESPONSE_ENTRY_COUNT];
} DVDX2_HOST_CHALLENGE_RESPONSE_TABLE, *PDVDX2_HOST_CHALLENGE_RESPONSE_TABLE;

//
// DVD-X2 control data structure.
//

typedef struct _DVDX2_CONTROL_DATA {
    UCHAR Length[2];
    UCHAR Reserved[2];
    DVD_LAYER_DESCRIPTOR LayerDescriptor;
    UCHAR Reserved2[15];
    UCHAR Reserved3[736];
    DVDX2_HOST_CHALLENGE_RESPONSE_TABLE HostChallengeResponseTable;
    UCHAR Reserved4[32];
    LARGE_INTEGER ContentSourceTimeStamp;
    UCHAR Reserved5[20];
    GUID ContentSourceIdentifier;
    UCHAR Reserved6[84];
    LARGE_INTEGER AuthoringTimeStamp;
    UCHAR Reserved7[19];
    UCHAR AuthoringSystemType;
    GUID AuthoringSystemIdentifier;
    UCHAR AuthoringHash[XC_DIGEST_LEN];
    UCHAR AuthoringSignature[XC_ENC_SIGNATURE_SIZE];
    LARGE_INTEGER MasteringTimeStamp;
    UCHAR Reserved8[19];
    UCHAR MasteringSystemType;
    GUID MasteringSystemIdentifier;
    UCHAR MasteringHash[XC_DIGEST_LEN];
    UCHAR MasteringSignature[64];
    UCHAR Reserved9;
} DVDX2_CONTROL_DATA, *PDVDX2_CONTROL_DATA;

//
// Define the layer and block number that holds the control data structure.
//

#define DVDX2_CONTROL_DATA_LAYER                    1
#define DVDX2_CONTROL_DATA_BLOCK_NUMBER             0x00FD0200

#include <poppack.h>

#endif  // DVDX2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ani.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ani.h

Abstract:

    Startup animation control methods

--*/

#pragma once

// Starts the animation which will run on a background thread.  This API
// returns immediately.
//
void AniStartAnimation(BOOLEAN fShort);

// Shut down the animation.  This will abort any pending fades if the time
// passed to SetTerminationTime was incorrect.  This API may block briefly
// as the background thread is terminated.
//
void AniTerminateAnimation();

// Blocks until the animation has completed (until the animation is ready
// to display the Microsoft logo).
//
void AniBlockOnAnimation();

// Sets the pointer to compressed Microsoft logo.
//
VOID AniSetLogo(PVOID pv, ULONG Size);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\av.h ===
/*--

Copyright (c) Microsoft Corporation

Module Name:

    av.h

Abstract:

    This module contains the public data structures and procedure
    prototypes to identify AV packs and program TV encoder

--*/

#ifndef _AV_H
#define _AV_H

#if !defined(_NTSYSTEM_)
#define NTKERNELAVAPI DECLSPEC_IMPORT
#else
#define NTKERNELAVAPI
#endif

//
// TV encoder ID
//

#define CONEXANT_ENCODER_ID         0x8A
#define FOCUS_ENCODER_ID            0xD4

#ifdef FOCUS
#define TV_ENCODER_ID               FOCUS_ENCODER_ID
#else
#define TV_ENCODER_ID               CONEXANT_ENCODER_ID
#endif


//
// AV pack identifiers
//
#define AV_PACK_NONE                      0x00000000

#define AV_PACK_STANDARD                  0x00000001
#define AV_PACK_RFU                       0x00000002
#define AV_PACK_SCART                     0x00000003
#define AV_PACK_HDTV                      0x00000004
#define AV_PACK_VGA                       0x00000005
#define AV_PACK_SVIDEO                    0x00000006
#define AV_PACK_MAX                       0x00000007

#define AV_PACK_MASK                      0x000000FF

//
// AV_ region types
//
#define AV_STANDARD_NTSC_M                0x00000100
#define AV_STANDARD_NTSC_J                0x00000200
#define AV_STANDARD_PAL_I                 0x00000300
#define AV_STANDARD_PAL_M                 0x00000400
#define AV_STANDARD_MAX                   0x00000500

#define AV_STANDARD_MASK                  0x0000FF00
#define AV_STANDARD_BIT_SHIFT             8

// Allows 16:9 for all SDTV and DTV modes.  HDTV 
// modes (720p and 1080i) are assumed to support 16:9.
//
#define AV_FLAGS_WIDESCREEN               0x00010000
#define AV_FLAGS_LETTERBOX                0x00100000

#define AV_ASPECT_RATIO_MASK              (AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX)

// 480i support is assumed.
#define AV_FLAGS_HDTV_480i                0x00000000
#define AV_FLAGS_HDTV_720p                0x00020000
#define AV_FLAGS_HDTV_1080i               0x00040000
#define AV_FLAGS_HDTV_480p                0x00080000

#define AV_HDTV_MODE_MASK                 (AV_FLAGS_HDTV_480p | AV_FLAGS_HDTV_720p | AV_FLAGS_HDTV_1080i | AV_FLAGS_HDTV_480i)

// Whether the display is interlaced or not.
#define AV_FLAGS_INTERLACED               0x00200000

// Indicates a field-rendered mode.
#define AV_FLAGS_FIELD                    0x01000000

// Indicates that this is in the funky pixel aspect ratio mode.
#define AV_FLAGS_10x11PAR                 0x02000000

// The refresh rate supported by the display.
#define AV_FLAGS_60Hz                     0x00400000
#define AV_FLAGS_50Hz                     0x00800000

#define AV_REFRESH_MASK                   (AV_FLAGS_60Hz | AV_FLAGS_50Hz)

#define AV_USER_FLAGS_MASK                (AV_ASPECT_RATIO_MASK | AV_HDTV_MODE_MASK | AV_FLAGS_60Hz)
#define AV_USER_FLAGS_BIT_SHIFT           16

//
// TV encoder options
//

// !!! Do not change the MACROVISION_MODE value without
//    updating the DVD software!

#define AV_OPTION_MACROVISION_MODE        1
#define AV_OPTION_ENABLE_CC               2
#define AV_OPTION_DISABLE_CC              3
#define AV_OPTION_SEND_CC_DATA            4
#define AV_QUERY_CC_STATUS                5
#define AV_QUERY_AV_CAPABILITIES          6
#define AV_OPTION_BLANK_SCREEN            9
#define AV_OPTION_MACROVISION_COMMIT      10
#define AV_OPTION_FLICKER_FILTER          11
#define AV_OPTION_ZERO_MODE               12
#define AV_OPTION_QUERY_MODE              13
#define AV_OPTION_ENABLE_LUMA_FILTER      14
#define AV_OPTION_GUESS_FIELD             15
#define AV_QUERY_ENCODER_TYPE             16
#define AV_QUERY_MODE_TABLE_VERSION       17
#define AV_OPTION_CGMS                    18
#define AV_OPTION_WIDESCREEN              19

//
// TV encoder types.
//

#define AV_ENCODER_CONEXANT_871           0
#define AV_ENCODER_FOCUS                  1

//
// Macrovision modes
//

#define AV_MV_OFF                         0
#define AV_MV_AGC_ONLY                    1
#define AV_MV_TWO_STRIPES_PLUS_AGC        2
#define AV_MV_FOUR_STRIPES_PLUS_AGC       3

// 
// CGMS modes
//

#define AV_CGMS_UNRESTRICTED              0
#define AV_CGMS_ONECOPY                   1
#define AV_CGMS_NOCOPIES                  3

//
// APIs
//

NTKERNELAVAPI
ULONG
NTAPI
AvSetDisplayMode(
    IN  PVOID RegisterBase,
    IN  ULONG Step,
    IN  ULONG DisplayMode,            // mode from the AV_MODE list (avmode.h)
    IN  ULONG SourceColorFormat,      // D3DFORMAT
    IN  ULONG Pitch,
    IN  ULONG FrameBuffer
    );

NTKERNELAVAPI
VOID
NTAPI
AvSendTVEncoderOption(
    IN  PVOID RegisterBase,
    IN  ULONG Option,
    IN  ULONG Param,
    OUT PULONG Result
    );

NTKERNELAVAPI
PVOID
NTAPI
AvGetSavedDataAddress(
    VOID
    );

NTKERNELAVAPI
VOID
NTAPI
AvSetSavedDataAddress(
    PVOID Address
    );

VOID
NTAPI
AvRelocateSavedDataAddress(
    IN PVOID Address,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAVAPI
ULONG
NTAPI
AvSMCVideoModeToAVPack(
    ULONG VideoMode
    );

#endif // _AV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\bldr.inc ===
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     bldr.inc
;
;  Abstract:
;
;     This module contains shared constants for the various boot loaders.
;
;--

;
; Define the starting physical address where the ROM decrypts the boot loader
;

BLDR_BOOT_ORIGIN                    EQU     00090000h

;
; Define the starting physical address where the boot loader relocates itself
;

BLDR_RELOCATED_ORIGIN               EQU     00400000h

;
; Initialize any page table entries with valid, write, accessed, and dirty.
;

BLDR_VALID_KERNEL_PTE_BITS          EQU     063h

;
; Initialize any page table entries with valid, write, accessed, large page, and dirty.
;

BLDR_VALID_KERNEL_LARGE_PTE_BITS    EQU     0E3h

;
; Initialize any page table entries with valid, write, accessed, large page, 
; cache disabled, write through, and dirty.
;

BLDR_VALID_KERNEL_LARGE_PTE_UC_BITS  EQU    0FBh


;
; Origin for the processor reset vector.
;

BOOT_CODE_ORIGIN                    EQU     0FE00h

;
; Size of the rom loader (must match BLDR_BLOCK_SIZE in bldr.h).
;

ROMLDR_SIZE                         EQU     6000h

;
; Size of the rom preloader (must match PRELDR_BLOCK_SIZE in bldr.h).
;

ROMPRELDR_SIZE                      EQU     2A00h

;
; Signature in the rom loader (must match BLDR_SIGNATURE in bldr.h)
;

ROMLDR_SIGNATURE                    EQU     7854794Ah

;
; Size of the XBOOT_PARAM structure defined in bldr.h
;

ROMLDR_BOOTPARAMSIZE                EQU     28

;
; ROMDEC hash address and nonce
;

ROMDEC_HASH                         EQU     88
ROMDEC_N                            EQU     100

;
; ROMDEC key size in bytes
;

ROMDEC_KEYSIZE                      EQU     16

;
; linear address for ROMDEC stack
;

ROMDEC_STACK                        EQU     8F000h

;
; linear address for RC4 key structure (258 bytes)
;

ROMDEC_KEYSTRUCT                    EQU     8F000h

;
; linear address for the start of the ROMDEC code block (top 512 bytes of
; the address space)
;

ROMDEC_STARTADDRESS                 EQU     0FFFFFE00h

;
; ROMDEC buffer size to decrypt
;

ROMDEC_BUFFERSIZE                   EQU     ROMLDR_SIZE

;
; liner address for input buffer used in encryption
;

ROMDEC_INPUTBUFFER                  EQU     (ROMDEC_STARTADDRESS - ROMLDR_SIZE)

;
; liner address for output buffer used in encryption
;

ROMDEC_OUTPUTBUFFER                 EQU     BLDR_BOOT_ORIGIN

;
; linear address for the init table
;

ROMDEC_INIT_TABLE                   EQU     0FF000080h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\avmode.h ===
/*
 * AV modes and tables.  
 */

#pragma once

// Update when we add modes after release.

#define AV_MODE_TABLE_VERSION  0

//
// Mode enum values where:
//
//  0xC0000000 - output mode mask:
//
//    0x00000000 - 480 line SDTV
//    0x40000000 - 525 line SDTV
//    0x80000000 - HDTV
//    0xC0000000 - VGA
//
//  0x20000000 - use SCART output
//  0x10000000 - enable WSS
//
//  0x08000000 - disable DAC D
//  0x04000000 - disable DAC C
//  0x02000000 - disable DAC B
//  0x01000000 - disable DAC A
//
//  0x00FF0000 - register table index
//  0x0000FF00 - CRTC table index
//  0x000000FF - TV table index, based on output mode mask above
//

#define AV_MODE_OFF                                 0x00000000

#define AV_MODE_640x480_TO_NTSC_M_YC                0x04010101
#define AV_MODE_640x480_TO_NTSC_M_YC_16x9           0x14010101
#define AV_MODE_720x480_TO_NTSC_M_YC                0x04020202
#define AV_MODE_720x480_TO_NTSC_M_YC_16x9           0x14020202
#define AV_MODE_640x480_TO_NTSC_M_RGB               0x20010101
#define AV_MODE_640x480_TO_NTSC_M_RGB_16x9          0x30010101
#define AV_MODE_720x480_TO_NTSC_M_RGB               0x20020202
#define AV_MODE_720x480_TO_NTSC_M_RGB_16x9          0x30020202

#define AV_MODE_640x480_TO_NTSC_J_YC                0x04010103
#define AV_MODE_640x480_TO_NTSC_J_YC_16x9           0x14010103
#define AV_MODE_720x480_TO_NTSC_J_YC                0x04020204
#define AV_MODE_720x480_TO_NTSC_J_YC_16x9           0x14020204
#define AV_MODE_640x480_TO_NTSC_J_RGB               0x20010103
#define AV_MODE_640x480_TO_NTSC_J_RGB_16x9          0x30010103
#define AV_MODE_720x480_TO_NTSC_J_RGB               0x20020204
#define AV_MODE_720x480_TO_NTSC_J_RGB_16x9          0x30020204

#define AV_MODE_640x480_TO_PAL_M_YC                 0x04010105
#define AV_MODE_640x480_TO_PAL_M_YC_16x9            0x14010105
#define AV_MODE_720x480_TO_PAL_M_YC                 0x04020206
#define AV_MODE_720x480_TO_PAL_M_YC_16x9            0x14020206
#define AV_MODE_640x480_TO_PAL_M_RGB                0x20010105
#define AV_MODE_640x480_TO_PAL_M_RGB_16x9           0x30010105
#define AV_MODE_720x480_TO_PAL_M_RGB                0x20020206
#define AV_MODE_720x480_TO_PAL_M_RGB_16x9           0x30020206

#define AV_MODE_640x480_TO_PAL_I_YC                 0x44030307
#define AV_MODE_640x480_TO_PAL_I_YC_16x9            0x54030307
#define AV_MODE_720x480_TO_PAL_I_YC                 0x44040408
#define AV_MODE_720x480_TO_PAL_I_YC_16x9            0x54040408
#define AV_MODE_640x576_TO_PAL_I_YC                 0x44050509
#define AV_MODE_640x576_TO_PAL_I_YC_16x9            0x54050509
#define AV_MODE_720x576_TO_PAL_I_YC                 0x4406060A
#define AV_MODE_720x576_TO_PAL_I_YC_16x9            0x5406060A
#define AV_MODE_640x480_TO_PAL_I_RGB                0x60030307
#define AV_MODE_640x480_TO_PAL_I_RGB_16x9           0x70030307
#define AV_MODE_720x480_TO_PAL_I_RGB                0x60040408
#define AV_MODE_720x480_TO_PAL_I_RGB_16x9           0x70040408
#define AV_MODE_640x576_TO_PAL_I_RGB                0x60050509
#define AV_MODE_640x576_TO_PAL_I_RGB_16x9           0x70050509
#define AV_MODE_720x576_TO_PAL_I_RGB                0x6006060A
#define AV_MODE_720x576_TO_PAL_I_RGB_16x9           0x7006060A
                                                    
#define AV_MODE_640x480_TO_PAL_60_YC                0x0401010B
#define AV_MODE_640x480_TO_PAL_60_YC_16x9           0x1401010B
#define AV_MODE_720x480_TO_PAL_60_YC                0x0402020C
#define AV_MODE_720x480_TO_PAL_60_YC_16x9           0x1402020C
#define AV_MODE_640x480_TO_PAL_60_RGB               0x2001010B
#define AV_MODE_640x480_TO_PAL_60_RGB_16x9          0x3001010B
#define AV_MODE_720x480_TO_PAL_60_RGB               0x2002020C
#define AV_MODE_720x480_TO_PAL_60_RGB_16x9          0x3002020C

#define AV_MODE_640x480_TO_NTSC_YPrPb               0x0801010D
#define AV_MODE_640x480_TO_NTSC_YPrPb_16x9          0x1801010D
#define AV_MODE_720x480_TO_NTSC_YPrPb               0x0802020E
#define AV_MODE_720x480_TO_NTSC_YPrPb_16x9          0x1802020E

#define AV_MODE_640x480_FPAR_TO_NTSC_M_YC           0x040F0D0F
#define AV_MODE_640x480_FPAR_TO_NTSC_M_YC_16x9      0x140F0D0F
#define AV_MODE_640x480_FPAR_TO_NTSC_M_RGB          0x200F0D0F
#define AV_MODE_640x480_FPAR_TO_NTSC_M_RGB_16x9     0x300F0D0F

#define AV_MODE_640x480_FPAR_TO_NTSC_J_YC           0x040F0D10
#define AV_MODE_640x480_FPAR_TO_NTSC_J_YC_16x9      0x140F0D10
#define AV_MODE_640x480_FPAR_TO_NTSC_J_RGB          0x200F0D10
#define AV_MODE_640x480_FPAR_TO_NTSC_J_RGB_16x9     0x300F0D10

#define AV_MODE_640x480_FPAR_TO_PAL_60_YC           0x040F0D11
#define AV_MODE_640x480_FPAR_TO_PAL_60_YC_16x9      0x140F0D11
#define AV_MODE_640x480_FPAR_TO_PAL_60_RGB          0x200F0D11
#define AV_MODE_640x480_FPAR_TO_PAL_60_RGB_16x9     0x300F0D11

#define AV_MODE_640x480_FPAR_TO_NTSC_YPrPb          0x080F0D12
#define AV_MODE_640x480_FPAR_TO_NTSC_YPrPb_16x9     0x180F0D12

#define AV_MODE_640x480_FPAR_TO_PAL_I_YC            0x44100E13
#define AV_MODE_640x480_FPAR_TO_PAL_I_YC_16x9       0x54100E13
#define AV_MODE_640x480_FPAR_TO_PAL_I_RGB           0x60100E13
#define AV_MODE_640x480_FPAR_TO_PAL_I_RGB_16x9      0x70100E13

#define AV_MODE_640x480_TO_PAL_I_YPrPb              0x48030314
#define AV_MODE_640x480_TO_PAL_I_YPrPb_16x9         0x58030314
#define AV_MODE_720x480_TO_PAL_I_YPrPb              0x48040415
#define AV_MODE_720x480_TO_PAL_I_YPrPb_16x9         0x58040415
#define AV_MODE_640x576_TO_PAL_I_YPrPb              0x48050516
#define AV_MODE_640x576_TO_PAL_I_YPrPb_16x9         0x58050516
#define AV_MODE_720x576_TO_PAL_I_YPrPb              0x48060617
#define AV_MODE_720x576_TO_PAL_I_YPrPb_16x9         0x58060617
#define AV_MODE_640x480_FPAR_TO_PAL_I_YPrPb         0x48100E18
#define AV_MODE_640x480_FPAR_TO_PAL_I_YPrPb_16x9    0x58100E18

#define AV_MODE_640x480_TO_PAL_60_YPrPb             0x08010119
#define AV_MODE_640x480_TO_PAL_60_YPrPb_16x9        0x18010119
#define AV_MODE_720x480_TO_PAL_60_YPrPb             0x0802021A
#define AV_MODE_720x480_TO_PAL_60_YPrPb_16x9        0x1802021A
#define AV_MODE_640x480_FPAR_TO_PAL_60_YPrPb        0x080F0D1B
#define AV_MODE_640x480_FPAR_TO_PAL_60_YPrPb_16x9   0x180F0D1B

#define AV_MODE_640x576_FPAR_TO_PAL_I_YC            0x4412101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_YC_16x9       0x5412101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_RGB           0x6012101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_RGB_16x9      0x7012101C
#define AV_MODE_640x576_FPAR_TO_PAL_I_YPrPb         0x4812101D
#define AV_MODE_640x576_FPAR_TO_PAL_I_YPrPb_16x9    0x5812101D

#define AV_MODE_640x480_TO_VGA                      0x88070701
#define AV_MODE_720x480_TO_VGA                      0x88080801
#define AV_MODE_1280x720_TO_VGA                     0x880B0A02
#define AV_MODE_1920x1080_TO_VGA                    0x880E0C03

#define AV_MODE_640x480_TO_480P                     0x88070701
#define AV_MODE_720x480_TO_480P                     0x88080801
#define AV_MODE_1280x720P_TO_720P                   0x880B0A02
#define AV_MODE_1920x1080I_TO_1080I                 0x880E0C03

#define AV_MODE_640x480_FPAR_TO_480P                0x88110F01

#define AV_MODE_FLAGS_DACA_DISABLE                  0x01000000
#define AV_MODE_FLAGS_DACB_DISABLE                  0x02000000
#define AV_MODE_FLAGS_DACC_DISABLE                  0x04000000
#define AV_MODE_FLAGS_DACD_DISABLE                  0x08000000

#define AV_MODE_FLAGS_WSS                           0x10000000
#define AV_MODE_FLAGS_SCART                         0x20000000
#define AV_MODE_FLAGS_NTSCJ                         0x00000080

#define AV_MODE_OUT_MASK                            0xC0000000
#define AV_MODE_OUT_480SDTV                         0x00000000

// BAH!  This should be 576SDTV, but it's too late to change it now.
#define AV_MODE_OUT_525SDTV                         0x40000000
#define AV_MODE_OUT_HDTV                            0x80000000
#define AV_MODE_OUT_VGA                             0xC0000000

#ifdef DEFINE_REGISTERS

#define AVP_MV_NTSC_MODE_0           1
#define AVP_MV_NTSC_MODE_1           2
#define AVP_MV_NTSC_MODE_2           3
#define AVP_MV_NTSC_MODE_3           4
#define AVP_MV_PAL_MODE_0            1
#define AVP_MV_PAL_MODE_1            2

//
// FOCUS
//

#ifdef FOCUS

const UCHAR AvpFocusFPGAPLLRegisters[ ][9] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}, /* offset */
    { /*      1 */ 0x41, 0x01, 0x78, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*      1 */
};


const UCHAR AvpTVRegisters[ ][137] =
{
    { /* offset */ 0x7e, 0x0c, 0x0d, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x26, 0x27, 0x38, 0x39, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x80, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x92, 0x93, 0x9a, 0x9b, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xb2, 0xb3, 0xb6, 0xb7, 0xc0, 0xc1, 0x0c, 0x0d, 0x0c, 0x0d, 0x7e}, /* offset */
    { /*     01 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     01 */
    { /*     02 */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     02 */
    { /*     03 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x3c, 0x01, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     03 */
    { /*     04 */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x3c, 0x01, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     04 */
    { /*     05 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xe6, 0xef, 0xe3, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x29, 0x1d, 0x01, 0x3f, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x12, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x40, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     05 */
    { /*     06 */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xe6, 0xef, 0xe3, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x29, 0x1d, 0x01, 0x3f, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x12, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x40, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     06 */
    { /*     07 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x17, 0x00, 0x80, 0x02, 0xc3, 0x30, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     07 */
    { /*     08 */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x17, 0x00, 0xd0, 0x02, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     08 */
    { /*     09 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x1a, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     09 */
    { /*     0a */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x1a, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     0a */
    { /*     0b */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0b */
    { /*     0c */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0c */
    { /*     0d */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0d */
    { /*     0e */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0e */
    { /*     0f */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     0f */
    { /*     10 */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x3c, 0x01, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     10 */
    { /*     11 */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     11 */
    { /*     12 */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x21, 0xf0, 0x7c, 0x1f, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x40, 0x80, 0x3b, 0x00, 0x01, 0x47, 0x00, 0x3c, 0x00, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x03, 0x89, 0x04, 0x89, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x19, 0xff, 0x03, 0x24, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x04, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x6f, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     12 */
    { /*     13 */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x17, 0x00, 0x88, 0x02, 0xc3, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     13 */
    { /*     14 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x17, 0x00, 0x80, 0x02, 0xc3, 0x30, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     14 */
    { /*     15 */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x17, 0x00, 0xd0, 0x02, 0xc3, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     15 */
    { /*     16 */ 0x01, 0x01, 0x01, 0x8c, 0x00, 0x1a, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     16 */
    { /*     17 */ 0x01, 0x01, 0x01, 0x64, 0x00, 0x1a, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     17 */
    { /*     18 */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x17, 0x00, 0x88, 0x02, 0xc3, 0x30, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0xd7, 0x0d, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0xa4, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     18 */
    { /*     19 */ 0x01, 0x01, 0x00, 0xb0, 0x00, 0x18, 0x00, 0x80, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     19 */
    { /*     1a */ 0x01, 0x01, 0x00, 0x88, 0x00, 0x18, 0x00, 0xd0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     1a */
    { /*     1b */ 0x01, 0x01, 0x00, 0xab, 0x00, 0x18, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x00, 0x15, 0x00, 0x10, 0xff, 0x0e, 0x00, 0x90, 0xfc, 0x36, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1d, 0x25, 0x1b, 0x1b, 0x24, 0x00, 0x0f, 0x0f, 0x60, 0x01, 0xcd, 0x01, 0x91, 0x04, 0x91, 0x01, 0x00, 0x00, 0x0a, 0x05, 0x00, 0x1a, 0xff, 0x03, 0x1e, 0x0f, 0x78, 0x00, 0x00, 0x14, 0x41, 0x08, 0x00, 0xa3, 0xc8, 0x11, 0x07, 0x11, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x55, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     1b */
    { /*     1c */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x1a, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x00, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc4, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0x00, 0x00, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     1c */
    { /*     1d */ 0x01, 0x01, 0x01, 0x87, 0x00, 0x1a, 0x00, 0x88, 0x02, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x01, 0x01, 0x15, 0x00, 0xc0, 0x7a, 0x10, 0x00, 0x00, 0xeb, 0x41, 0x00, 0xef, 0x07, 0x7f, 0x00, 0x03, 0x03, 0x0c, 0x00, 0x82, 0x00, 0x2a, 0x09, 0x8a, 0xcb, 0x00, 0x00, 0x89, 0x04, 0x7a, 0x3c, 0x9a, 0x2c, 0x1f, 0x01, 0x3f, 0x00, 0x3e, 0x03, 0x1a, 0x2a, 0x1c, 0x3d, 0x14, 0x00, 0xfe, 0x7e, 0x60, 0x05, 0xcd, 0x01, 0x91, 0x07, 0x91, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x1a, 0x55, 0x01, 0x1e, 0x07, 0x7e, 0x02, 0x54, 0x16, 0x49, 0x08, 0x00, 0xa3, 0xc8, 0x22, 0x02, 0x22, 0x3e, 0x03, 0x77, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x13, 0x13, 0x9c, 0x03, 0xc5, 0x48, 0x00, 0x80, 0xe4, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0xd7, 0x05, 0xf0, 0x00, 0xa0, 0xa0, 0x03, 0x01, 0x00, 0x01, 0x00}, /*     1d */
};


const UCHAR AvpFocusFPGAHDPLLRegisters[ ][9] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}, /* offset */
    { /*     01 */ 0x41, 0x01, 0x78, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*     01 */
    { /*     02 */ 0x41, 0x01, 0xf8, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*     02 */
    { /*     03 */ 0x41, 0x01, 0xf8, 0x00, 0x00, 0xff, 0x03, 0x00, 0x5a}, /*     03 */
};


//##
const UCHAR AvpHDTVRegisters[ ][66] =
{
    { /* offset */ 0x7e, 0x0c, 0x0d, 0x0a, 0x0b, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x26, 0x27, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xb2, 0xb3, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x0c, 0x0d, 0x0c, 0x0d, 0x7e}, /* offset */
    { /*     01 */ 0x01, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xef, 0x03, 0x7f, 0x00, 0x07, 0x07, 0x0c, 0x00, 0x3e, 0x48, 0x3f, 0x3f, 0x3b, 0x00, 0x1b, 0x03, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0xa0, 0x00, 0x92, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xb7, 0x00, 0xd0, 0x02, 0x23, 0x00, 0xe0, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     01 */
    { /*     02 */ 0x01, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x04, 0xc7, 0x00, 0x01, 0x01, 0x0c, 0x00, 0x2e, 0x58, 0x28, 0x46, 0xdc, 0x00, 0x2c, 0x06, 0x00, 0x00, 0xe4, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0xa0, 0x00, 0x92, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x72, 0x01, 0x00, 0x05, 0x18, 0x00, 0xd0, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     02 */
    { /*     03 */ 0x01, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3b, 0x04, 0xc7, 0x00, 0x01, 0x01, 0x0c, 0x00, 0xae, 0x58, 0x2c, 0x2c, 0x58, 0x00, 0x6c, 0x08, 0x01, 0x00, 0xe4, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0x00, 0xa0, 0x00, 0x92, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xe5, 0x00, 0x80, 0x07, 0x14, 0x00, 0x1c, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00}, /*     03 */
};


const UCHAR AvpFocusRGBEnable[ ][16] =
{
    { /* offset */ 0x4E, 0x4F, 0x92, 0x93, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad}, /* offset */
    { /*  mask  */ 0xFF, 0xFF, 0x07, 0x40, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, /*   mask */
    { /*    RGB */ 0x3C, 0x01, 0x01, 0x00, 0x4d, 0x00, 0x96, 0x00, 0x1d, 0x00, 0xa0, 0x00, 0xdb, 0x00, 0x7e, 0x00}, /*    RGB */
};


// The setup value here is wrong if we're in RGB mode.  This needs
// to be whacked in some way...waiting for info from Ron.  Ron does
// not remmember what this note means but will validate these values.
//
const UCHAR AvpMacrovision[ ][15] =
{
    { /* offset */ 0x4e, 0x50, 0x52, 0x53, 0x59, 0x5d, 0x5e, 0x64, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0xb2, 0xb3}, /* offset */
    { /*    Off */ 0x47, 0x3c, 0x1d, 0x25, 0x00, 0x01, 0xcd, 0x00, 0x11, 0x07, 0x11, 0x3c, 0x00, 0x55, 0x05}, /*    Off */
    { /*    AGC */ 0x38, 0x2d, 0x1d, 0x25, 0x36, 0x01, 0xbe, 0x00, 0x11, 0x07, 0x11, 0x3b, 0x03, 0x4d, 0x03}, /*    AGC */
    { /* AGC+2L */ 0x38, 0x2d, 0x1d, 0x25, 0x3e, 0x01, 0xbe, 0x00, 0x11, 0x07, 0x11, 0x3b, 0x03, 0x4d, 0x03}, /* AGC+2L */
    { /* AGC+4L */ 0x38, 0x2d, 0x17, 0x21, 0x3e, 0x05, 0xbe, 0x02, 0x15, 0x05, 0x15, 0x3b, 0x03, 0x4d, 0x03}, /* AGC+4L */
};

const UCHAR AvpMacrovisionPAL[ ][7] =
{
    { /* offset */ 0x4e, 0x50, 0x59, 0x5e, 0x7d, 0xb2, 0xb3}, /* offset */
    { /*PAL Off */ 0x3f, 0x3e, 0x00, 0xcd, 0x03, 0xd7, 0x05}, /*PAL Off */
    { /* PAL On */ 0x33, 0x32, 0x3e, 0xc1, 0x02, 0x0c, 0x03}, /* PAL On */
};

// 0x00680880 - NV_PRAMDAC_FP_DEBUG_0
// 0x00680898 - NV_PRAMDAC_FP_DEBUG_6
// 0x0068089C - NV_PRAMDAC_FP_DEBUG_7
// 0x006808C0 - NV_PRAMDAC_TVO_SETUP
// 0x006808C4 - NV_PRAMDAC_TVO_BLANK_COLOR
// 0x0068084C - NV_PRAMDAC_FP_INACTIVE_PXL_COLOR
// 0x00680630 - NV_PRAMDAC_COMPOSITE
// 0x00680800 - NV_PRAMDAC_FP_VDISPLAY_END
// 0x00680804 - NV_PRAMDAC_FP_VTOTAL
// 0x00680808 - NV_PRAMDAC_FP_VCRTC
// 0x0068080C - NV_PRAMDAC_FP_VSYNC_START
// 0x00680810 - NV_PRAMDAC_FP_VSYNC_END
// 0x00680814 - NV_PRAMDAC_FP_VVALID_START
// 0x00680818 - NV_PRAMDAC_FP_VVALID_END
// 0x00680820 - NV_PRAMDAC_FP_HDISPLAY_END
// 0x00680824 - NV_PRAMDAC_FP_HTOTAL
// 0x00680828 - NV_PRAMDAC_FP_HCRTC
// 0x0068082C - NV_PRAMDAC_FP_HSYNC_START
// 0x00680830 - NV_PRAMDAC_FP_HSYNC_END
// 0x00680834 - NV_PRAMDAC_FP_HVALID_START
// 0x00680838 - NV_PRAMDAC_FP_HVALID_END
// 0x00680848 - NV_PRAMDAC_FP_TG_CONTROL
// 0x00680680 - NV_PRAMDAC_LGS_HSYNC_NUMERATOR
// 0x00680684 - NV_PRAMDAC_LGS_HSYNC_DENOMINATOR
// 0x00680688 - NV_PRAMDAC_LGS_HSYNC_HIGH
// 0x0068068C - NV_PRAMDAC_LGS_HSYNC_HIGH_VSYNC
// 0x00680690 - NV_PRAMDAC_LGS_SWITCHES
//
const ULONG _declspec(selectany) AvpRegisters[][26] =
{
    { /* offset */ 0x00680898, 0x0068089C, 0x006808C0, 0x006808C4, 0x0068084C, 0x00680630, 0x00680800, 0x00680804, 0x00680808, 0x0068080C, 0x00680810, 0x00680814, 0x00680818, 0x00680820, 0x00680824, 0x00680828, 0x0068082C, 0x00680830, 0x00680834, 0x00680838, 0x00680848, 0x00680680, 0x00680684, 0x00680688, 0x0068068C, 0x00680690 }, /* offset */
    { /*      1 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F2, 0x000001F4, 0x00000000, 0x000001DF, 0x0000027F, 0x000003A7, 0x00000257, 0x000002F3, 0x00000333, 0x00000000, 0x0000027F, 0x10100111, 0x000C6ED0, 0x0000020D, 0x0000009B, 0x0000026C, 0x00000000 }, /*  1 */
    { /*      2 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F2, 0x000001F4, 0x00000000, 0x000001DF, 0x000002CF, 0x000003A7, 0x000002A7, 0x0000031B, 0x0000035B, 0x00000000, 0x000002CF, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  2 */
    { /*      3 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F4, 0x000001F6, 0x00000000, 0x000001DF, 0x0000027F, 0x0000035F, 0x00000257, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000F387C, 0x00000271, 0x000000BE, 0x000002F8, 0x00000000 }, /*  3 */
    { /*      4 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F4, 0x000001F6, 0x00000000, 0x000001DF, 0x000002CF, 0x0000035F, 0x000002AF, 0x0000030B, 0x0000034B, 0x00000000, 0x000002CF, 0x10100111, 0x0010D2A4, 0x00000271, 0x000000D2, 0x00000348, 0x00000000 }, /*  4 */
    { /*      5 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000256, 0x00000258, 0x00000000, 0x0000023F, 0x0000027F, 0x0000035F, 0x00000257, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /*  5 */
    { /*      6 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000256, 0x00000258, 0x00000000, 0x0000023F, 0x000002CF, 0x0000035F, 0x000002AF, 0x0000030B, 0x0000034B, 0x00000000, 0x000002CF, 0x10100111, 0x0010E62C, 0x00000271, 0x000000B1, 0x000002C4, 0x00000000 }, /*  6 */
    { /*      7 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  7 */
    { /*      8 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100111, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  8 */
    { /*      9 */ 0x0AA94000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x000000A0, 0x0000045F, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  9 */
    { /*      A */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004CF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  A */
    { /*      B */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100111, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  B */
    { /*      C */ 0x071AE000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AA, 0x000007AB, 0x00000803, 0x000000F0, 0x0000068F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  C */
    { /*      D */ 0x10000000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x00000759, 0x000007AB, 0x00000803, 0x00000000, 0x0000077F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  D */
    { /*      E */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043B, 0x0000043B, 0x00000445, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AB, 0x000007AC, 0x00000804, 0x00000000, 0x0000077F, 0x10133111, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  E */
    { /*      F */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F2, 0x000001F4, 0x00000000, 0x000001DF, 0x0000027F, 0x000003A7, 0x000002A7, 0x000002F3, 0x00000333, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  F */
    { /*     10 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001F4, 0x000001F6, 0x00000000, 0x000001DF, 0x0000027F, 0x0000035F, 0x000002A7, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /* 10 */
    { /*     11 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x000002CF, 0x000002DF, 0x0000031E, 0x00000020, 0x000002AD, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /* 11 */
    { /*     12 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000256, 0x00000258, 0x00000000, 0x0000023F, 0x0000027F, 0x0000035F, 0x00000257, 0x000002CF, 0x0000030F, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /* 12 */
};

const UCHAR _declspec(selectany) AvpCRTCRegisters[][34] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x20, 0x25, 0x2D, 0x33, 0x39, 0x41 }, /* offset */
    { /*      1 */ 0x70, 0x4F, 0x4F, 0x94, 0x5D, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x04, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      1 */
    { /*      2 */ 0x70, 0x59, 0x59, 0x94, 0x62, 0xA4, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x04, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      2 */
    { /*      3 */ 0x67, 0x4F, 0x4F, 0x8B, 0x59, 0xBB, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x06, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      3 */
    { /*      4 */ 0x67, 0x59, 0x59, 0x8B, 0x5E, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x06, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      4 */
    { /*      5 */ 0x67, 0x4F, 0x4F, 0x8B, 0x59, 0xBB, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      5 */
    { /*      6 */ 0x67, 0x59, 0x59, 0x8B, 0x5E, 0xBF, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      6 */
    { /*      7 */ 0x59, 0x4F, 0x4F, 0x9D, 0x51, 0x39, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      7 */
    { /*      8 */ 0x63, 0x59, 0x59, 0x87, 0x5B, 0xA3, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      8 */
    { /*      9 */ 0x78, 0x4F, 0x4F, 0x9C, 0x57, 0xA1, 0xFC, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x09, 0xDF, 0x00, 0x00, 0xDF, 0xFD, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      9 */
    { /*      A */ 0xC8, 0x9F, 0x9F, 0x8C, 0xA7, 0x31, 0xEC, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x09, 0xCF, 0x00, 0x00, 0xCF, 0xED, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      A */
    { /*      B */ 0x67, 0x4F, 0x4F, 0x8B, 0x54, 0xBF, 0x03, 0x11, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x06, 0xEF, 0x00, 0x00, 0xEF, 0x04, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0x36, 0x00 }, /*      B */
    { /*      C */ 0x04, 0xEF, 0xEF, 0x88, 0xF4, 0x3F, 0x2F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x02, 0x1B, 0x00, 0x00, 0x1B, 0x30, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x00, 0x01, 0x11, 0x10, 0x00 }, /*      C */
    { /*      D */ 0x70, 0x4F, 0x4F, 0x94, 0x5D, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x04, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      D */
    { /*      E */ 0x67, 0x4F, 0x4F, 0x8B, 0x59, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0x06, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x00, 0x00, 0x11, 0xFF, 0x00 }, /*      E */
    { /*      F */ 0x61, 0x57, 0x57, 0x85, 0x59, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      F */
    { /*     10 */ 0x67, 0x4F, 0x4F, 0x94, 0x59, 0xBF, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*     10 */
};

#else !FOCUS

//
// CONEXTANT
//

const UCHAR _declspec(selectany) AvpCommonTVRegisters[][22] =
{
    { /* offset */ 0x2E, 0x30, 0x32, 0x34, 0x38, 0x3A, 0x3C, 0x40, 0x60, 0x62, 0x64, 0x6C, 0x6E, 0x70, 0x72, 0x74, 0xC4, 0xC6, 0xC8, 0xCA, 0xCC, 0xD8 }, /* offset */
    { /*      1 */ 0x00, 0x00, 0x28, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x46, 0x00, 0x0F, 0x00, 0x01, 0x01, 0x9C, 0x9B, 0xC0, 0xC0, 0x40 }, /*      1 */
};

const UCHAR _declspec(selectany) AvpTVRegisters[][63] =
{
    { /* offset */ 0xD6, 0x36, 0x3E, 0x5A, 0x5C, 0x66, 0x68, 0x6A, 0x76, 0x78, 0x7A, 0x7C, 0x7E, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9A, 0x9C, 0x9E, 0xA0, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xAE, 0xB0, 0xB2, 0xB4, 0xB6, 0xCE, 0xDA, 0xDC, 0xDE, 0xE0, 0xE2, 0xE4, 0xE6, 0xE8, 0xEA, 0xEC, 0xEE, 0xF0, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA, 0xFC, }, /* offset */
    { /*      1 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x85, 0x44, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x0A, 0xE4, 0x7C, 0xCB, 0x8F, 0x9A, 0x12, 0x99, 0x86, 0x25, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      1 */
    { /*      2 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x98, 0x5C, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x0A, 0xE4, 0x7B, 0xCA, 0x8E, 0x9A, 0xC8, 0xA4, 0x78, 0x21, 0x5E, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      2 */
    { /*      3 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x85, 0x44, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x08, 0xE4, 0x7C, 0xDC, 0x9A, 0xA7, 0x12, 0x99, 0x86, 0x25, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      3 */
    { /*      4 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x98, 0x5C, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x08, 0xE4, 0x7B, 0xDB, 0x9A, 0xA7, 0xC8, 0xA4, 0x78, 0x21, 0x5E, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      4 */
    { /*      5 */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x8E, 0x4C, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x2A, 0xF0, 0x58, 0xCD, 0x92, 0xA4, 0x8F, 0x0A, 0x7C, 0x25, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      5 */
    { /*      6 */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x9F, 0x64, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x0A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x43, 0x3A, 0x6F, 0x21, 0x5A, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      6 */
    { /*      7 */ 0x00, 0xE4, 0x80, 0x00, 0x00, 0x41, 0x35, 0x03, 0x3C, 0x88, 0x76, 0x8C, 0x44, 0x15, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xF7, 0x03, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x55, 0x15, 0x0B, 0x24, 0xF0, 0x5E, 0xD9, 0x9B, 0xA3, 0x33, 0x98, 0x83, 0x2D, 0x52, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      7 */
    { /*      8 */ 0x00, 0xE4, 0x80, 0xFF, 0x00, 0x08, 0xE7, 0x02, 0xE4, 0xD8, 0x82, 0x9A, 0x58, 0x27, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x08, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x5C, 0xD7, 0x99, 0xA4, 0x3A, 0xEB, 0x2D, 0x29, 0x56, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      8 */
    { /*      9 */ 0x00, 0xD2, 0x80, 0xFF, 0x00, 0xAD, 0x3F, 0x03, 0x28, 0x88, 0x74, 0x8A, 0x42, 0x0A, 0x16, 0x22, 0xA6, 0x00, 0x14, 0x7E, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0xC7, 0xF1, 0x0A, 0x24, 0xF0, 0x5E, 0xD9, 0x9A, 0xA4, 0x18, 0x75, 0x17, 0x2E, 0x00, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      9 */
    { /*      A */ 0x00, 0xD2, 0x80, 0x00, 0x00, 0xAF, 0xE3, 0x02, 0xEC, 0xD8, 0x82, 0x9C, 0x5A, 0x2B, 0x16, 0x22, 0xA6, 0x00, 0x76, 0x8D, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x4E, 0x0C, 0x24, 0xF0, 0x5D, 0xD7, 0x99, 0xA3, 0x57, 0x53, 0xFE, 0x28, 0x56, 0x19, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*      A */
    { /*      B */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x88, 0x40, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x20, 0xF0, 0x5E, 0xD9, 0x9B, 0xA3, 0x7D, 0xB7, 0x7A, 0x2E, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      B */
    { /*      C */ 0x00, 0xC0, 0x80, 0x00, 0x00, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x9A, 0x56, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x20, 0xF0, 0x5C, 0xD7, 0x98, 0xA3, 0xB7, 0x1B, 0x75, 0x29, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      C */
    { /*      D */ 0x08, 0xA4, 0x90, 0x00, 0x03, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x86, 0x44, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x0A, 0xE4, 0x77, 0x9E, 0x8D, 0x9A, 0x12, 0x99, 0x86, 0x25, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      D */
    { /*      E */ 0x08, 0xA4, 0x90, 0x00, 0x03, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x97, 0x5B, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x0A, 0xE4, 0x76, 0x9E, 0x8D, 0x9A, 0xC8, 0xA4, 0x78, 0x21, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      E */
    { /*      F */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x95, 0x56, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x0A, 0xE4, 0x7B, 0xCA, 0x8E, 0x9A, 0x2A, 0x2E, 0x19, 0x22, 0x5D, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*      F */
    { /*     10 */ 0x00, 0xA4, 0x80, 0xFF, 0x01, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x95, 0x56, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x08, 0xE4, 0x7B, 0xDA, 0x9A, 0xA7, 0x2A, 0x2E, 0x19, 0x22, 0x5D, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     10 */
    { /*     11 */ 0x00, 0xA4, 0x80, 0x00, 0x00, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x96, 0x52, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x20, 0xF0, 0x5D, 0xD7, 0x99, 0xA3, 0xDE, 0xF2, 0x3B, 0x2A, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     11 */    
    { /*     12 */ 0x08, 0xA4, 0x90, 0x00, 0x03, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x8E, 0x56, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x0A, 0xE4, 0x76, 0x9E, 0x8D, 0x9A, 0x2A, 0x2E, 0x19, 0x22, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     12 */
    { /*     13 */ 0x00, 0xD2, 0x80, 0xFF, 0x00, 0x40, 0x35, 0x03, 0xE4, 0xC0, 0x82, 0x9A, 0x58, 0x3B, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x1B, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x5C, 0xD7, 0x99, 0xA4, 0x3A, 0xEB, 0x2D, 0x29, 0x56, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     13 */
    { /*     14 */ 0x08, 0xE4, 0x90, 0x00, 0x00, 0x41, 0x35, 0x03, 0x3C, 0x88, 0x76, 0x8C, 0x44, 0x15, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xF7, 0x03, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x55, 0x15, 0x0B, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x33, 0x98, 0x83, 0x2D, 0x51, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     14 */
    { /*     15 */ 0x08, 0xE4, 0x90, 0x00, 0x00, 0x08, 0xE7, 0x02, 0xE4, 0xD8, 0x82, 0x9A, 0x58, 0x27, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x08, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x3A, 0xEB, 0x2D, 0x29, 0x55, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     15 */
    { /*     16 */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0xAD, 0x3F, 0x03, 0x28, 0x88, 0x74, 0x8A, 0x42, 0x0A, 0x16, 0x22, 0xA6, 0x00, 0x14, 0x7E, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0xC7, 0xF1, 0x0A, 0x24, 0xF0, 0x5A, 0x9E, 0x8E, 0xA3, 0x18, 0x75, 0x17, 0x2E, 0x00, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     16 */
    { /*     17 */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0xAF, 0xE3, 0x02, 0xEC, 0xD8, 0x82, 0x9C, 0x5A, 0x2B, 0x16, 0x22, 0xA6, 0x00, 0x76, 0x8D, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x4E, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x57, 0x53, 0xFE, 0x28, 0x56, 0xE1, 0x05, 0x57, 0x20, 0x40, 0x6E, 0x7E, 0xF4, 0x51, 0x0F, 0xF1, 0x05, 0xD3, 0x78, 0xA2, 0x25, 0x54, 0xA5, 0x00, }, /*     17 */
    { /*     18 */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0x40, 0x35, 0x03, 0xE4, 0xC0, 0x82, 0x9A, 0x58, 0x3B, 0x16, 0x20, 0xA6, 0x00, 0x1A, 0x1B, 0x0C, 0x0D, 0x23, 0xE0, 0x06, 0xE1, 0x4A, 0x00, 0x40, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x3A, 0xEB, 0x2D, 0x29, 0x56, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     18 */
    { /*     19 */ 0x08, 0xA4, 0x90, 0x00, 0x00, 0x15, 0x4B, 0x00, 0x10, 0x88, 0x72, 0x88, 0x40, 0xED, 0x13, 0xF2, 0x26, 0x00, 0x08, 0x73, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x10, 0x68, 0xDA, 0x0A, 0x20, 0xF0, 0x5A, 0x84, 0x4A, 0x8C, 0x7D, 0xB7, 0x7A, 0x2E, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     19 */
    { /*     1A */ 0x08, 0xC0, 0x90, 0x00, 0x00, 0xF8, 0x42, 0x00, 0xCC, 0xD8, 0x80, 0x9A, 0x56, 0x07, 0x13, 0xF2, 0x26, 0x00, 0x66, 0x7F, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xF7, 0x2A, 0x0C, 0x20, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0xB7, 0x1B, 0x75, 0x29, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1A */
    { /*     1B */ 0x08, 0xA4, 0x90, 0x00, 0x00, 0x39, 0x44, 0x00, 0xAC, 0xC0, 0x7E, 0x96, 0x52, 0x0D, 0x13, 0xF2, 0x26, 0x00, 0x56, 0x83, 0x03, 0x0D, 0x24, 0xE0, 0x06, 0x00, 0x50, 0xAE, 0xF1, 0x0B, 0x20, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0xDE, 0xF2, 0x3B, 0x2A, 0x5A, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1B */    
    { /*     1C */ 0x00, 0xD2, 0x80, 0xFF, 0x00, 0x05, 0xF3, 0x02, 0xC8, 0xC0, 0x80, 0x98, 0x54, 0x2B, 0x16, 0x22, 0xA6, 0x00, 0x64, 0x8F, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x0E, 0x0C, 0x24, 0xF0, 0x5D, 0xD7, 0x99, 0xA4, 0x26, 0xF3, 0xD7, 0x29, 0x55, 0x19, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1C */
    { /*     1D */ 0x08, 0xD2, 0x90, 0x00, 0x00, 0x05, 0xF3, 0x02, 0xC8, 0xC0, 0x80, 0x98, 0x54, 0x28, 0x16, 0x22, 0xA6, 0x00, 0x64, 0x8F, 0x03, 0x71, 0x2A, 0x40, 0x0A, 0x00, 0x50, 0x39, 0x0E, 0x0C, 0x24, 0xF0, 0x59, 0x9E, 0x8E, 0xA3, 0x26, 0xF3, 0xD7, 0x29, 0x00, 0xE1, 0x0F, 0xFC, 0x20, 0xD0, 0x6F, 0x0F, 0x00, 0x00, 0x0C, 0xF3, 0x09, 0xBD, 0x66, 0xB5, 0x90, 0xB2, 0x7D, 0x00, }, /*     1D */
};

const UCHAR _declspec(selectany) AvpHDTVRegisters[][13] =
{
    { /* offset */ 0xD6, 0x2E, 0x32, 0x3C, 0x3E, 0x40, 0xC4, 0xC6, 0xCE, 0xA0, 0x9E, 0x9C, 0x6C }, /* offset */
    { /*      1 */ 0x0C, 0xAD, 0x48, 0x90, 0x8C, 0x8C, 0x01, 0x9C, 0xE1, 0x8C, 0x00, 0x00, 0x46 }, /*      1 */
    { /*      2 */ 0x0C, 0xAA, 0x49, 0x90, 0x8C, 0x8C, 0x01, 0x9C, 0xE1, 0x21, 0x00, 0x00, 0x46 }, /*      2 */
    { /*      3 */ 0x0C, 0xAB, 0x49, 0x90, 0x8C, 0x8C, 0x01, 0x9C, 0xE1, 0x21, 0x00, 0x00, 0x46 }, /*      3 */
};

//
// SCART
//

const UCHAR _declspec(selectany) AvpSCARTEnable[][12] =
{
    { /* offset */ 0x5A, 0x6C, 0xA2, 0xA4, 0xA6, 0xA8, 0xAA, 0xAC, 0xBA, 0xC6, 0xCE, 0xD6, }, /* offset */
    { /*      1 */ 0xFF, 0x4E, 0x08, 0xE7, 0x77, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      1 */ 
    { /*      2 */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      2 */ 
    { /*      3 */ 0xFF, 0x4E, 0x08, 0xE7, 0x77, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      3 */ 
    { /*      4 */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      4 */ 
    { /*      5 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      5 */ 
    { /*      6 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      6 */ 
    { /*      7 */ 0x00, 0x4E, 0x24, 0xE8, 0x5B, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      7 */ 
    { /*      8 */ 0xFF, 0x4E, 0x24, 0xE8, 0x5A, 0x7C, 0x46, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      8 */ 
    { /*      9 */ 0xFF, 0x4E, 0x24, 0xE8, 0x5B, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      9 */ 
    { /*      A */ 0x00, 0x4E, 0x24, 0xE8, 0x5A, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      A */ 
    { /*      B */ 0x00, 0x4E, 0x20, 0xE8, 0x5B, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      B */ 
    { /*      C */ 0x00, 0x4E, 0x20, 0xE8, 0x5A, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*      C */ 
    { /*      D */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      D */ 
    { /*      E */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*      E */ 
    { /*      F */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x46, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*      F */ 
    { /*     10 */ 0xFF, 0x4E, 0x08, 0xE7, 0x76, 0x7B, 0x45, 0x87, 0x20, 0x98, 0xE1, 0x0C, }, /*     10 */ 
    { /*     11 */ 0x00, 0x4E, 0x20, 0xE8, 0x5A, 0x7B, 0x45, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*     11 */ 
    { /*     12 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     12 */ 
    { /*     13 */ 0xFF, 0x4E, 0x24, 0xE8, 0x5A, 0x7C, 0x46, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*     13 */ 
    { /*     14 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     14 */ 
    { /*     15 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     15 */ 
    { /*     16 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     16 */ 
    { /*     17 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     17 */ 
    { /*     18 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     18 */ 
    { /*     19 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     19 */ 
    { /*     1A */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     1A */ 
    { /*     1B */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     1B */ 
    { /*     1C */ 0xFF, 0x4E, 0x24, 0xE8, 0x5A, 0x7C, 0x46, 0x88, 0x20, 0x98, 0xE1, 0x0C, }, /*     1C */ 
    { /*     1D */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }, /*     1D */ 
};

//
// Closed captioning
//

const UCHAR _declspec(selectany) AvpCCRegisters[][4] =
{
    { /* offset */ 0x5E, 0xD0, 0xD2, 0xD4, }, /* offset */
    { /*      1 */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      1 */
    { /*      2 */ 0x44, 0x4C, 0x60, 0x19, }, /*      2 */
    { /*      3 */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      3 */
    { /*      4 */ 0x44, 0x4C, 0x60, 0x19, }, /*      4 */
    { /*      5 */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      5 */
    { /*      6 */ 0x44, 0x4C, 0x60, 0x19, }, /*      6 */
    { /*      7 */ 0x22, 0x35, 0x57, 0x1A, }, /*      7 */
    { /*      8 */ 0x22, 0x4D, 0x55, 0x19, }, /*      8 */
    { /*      9 */ 0x22, 0x2E, 0x78, 0x1A, }, /*      9 */
    { /*      A */ 0x22, 0x4E, 0x55, 0x19, }, /*      A */
    { /*      B */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      B */
    { /*      C */ 0x44, 0x4C, 0x60, 0x19, }, /*      C */
    { /*      D */ 0x44, 0x2F, 0x8E, 0x1A, }, /*      D */
    { /*      E */ 0x44, 0x4C, 0x60, 0x19, }, /*      E */
    { /*      F */ 0x44, 0x47, 0xA0, 0x19, }, /*      F */
    { /*     10 */ 0x44, 0x47, 0xA0, 0x19, }, /*     10 */
    { /*     11 */ 0x44, 0x47, 0xA0, 0x19, }, /*     11 */
    { /*     12 */ 0x44, 0x47, 0xA0, 0x19, }, /*     12 */
    { /*     13 */ 0x22, 0x4E, 0x60, 0x19, }, /*     13 */
};

//
// Macrovision.
//

const UCHAR _declspec(selectany) AvpMacrovision[][6] =
{
    { /* offset */ 0xFC, 0xF2, 0xF4, 0xF6, 0xF8, 0xFA }, /* offset */
    { /*      1 */ 0x00, 0x66, 0xB5, 0x90, 0xB2, 0x7D }, /* 1 */
    { /*      2 */ 0x00, 0x66, 0xB5, 0x90, 0xB2, 0x7D }, /* 2 */
    { /*      3 */ 0x00, 0x6C, 0x31, 0x92, 0x32, 0xDD }, /* 3 */
    { /*      4 */ 0x00, 0x66, 0xB5, 0x90, 0xB2, 0x7D }, /* 4 */
};

const UCHAR _declspec(selectany) AvpMacrovisionEnable[][1] =
{
    { /* offset */ 0xFC }, /* offset */
    { /*      1 */ 0x00 }, /* 1 */
    { /*      2 */ 0x63 }, /* 2 */
    { /*      3 */ 0xE3 }, /* 3 */
    { /*      4 */ 0xE3 }, /* 4 */
};

const UCHAR _declspec(selectany) AvpMacrovisionPAL[][1] =
{
    { /* offset */ 0xFC }, /* offset */
    { /*      0 */ 0x00 }, /* 5 */
    { /*      1 */ 0x63 }, /* 6 */
};

// 0x00680880 - NV_PRAMDAC_FP_DEBUG_0
// 0x00680898 - NV_PRAMDAC_FP_DEBUG_6
// 0x0068089C - NV_PRAMDAC_FP_DEBUG_7
// 0x006808C0 - NV_PRAMDAC_TVO_SETUP
// 0x006808C4 - NV_PRAMDAC_TVO_BLANK_COLOR
// 0x0068084C - NV_PRAMDAC_FP_INACTIVE_PXL_COLOR
// 0x00680630 - NV_PRAMDAC_COMPOSITE
// 0x00680800 - NV_PRAMDAC_FP_VDISPLAY_END
// 0x00680804 - NV_PRAMDAC_FP_VTOTAL
// 0x00680808 - NV_PRAMDAC_FP_VCRTC
// 0x0068080C - NV_PRAMDAC_FP_VSYNC_START
// 0x00680810 - NV_PRAMDAC_FP_VSYNC_END
// 0x00680814 - NV_PRAMDAC_FP_VVALID_START
// 0x00680818 - NV_PRAMDAC_FP_VVALID_END
// 0x00680820 - NV_PRAMDAC_FP_HDISPLAY_END
// 0x00680824 - NV_PRAMDAC_FP_HTOTAL
// 0x00680828 - NV_PRAMDAC_FP_HCRTC
// 0x0068082C - NV_PRAMDAC_FP_HSYNC_START
// 0x00680830 - NV_PRAMDAC_FP_HSYNC_END
// 0x00680834 - NV_PRAMDAC_FP_HVALID_START
// 0x00680838 - NV_PRAMDAC_FP_HVALID_END
// 0x00680848 - NV_PRAMDAC_FP_TG_CONTROL
// 0x00680680 - NV_PRAMDAC_LGS_HSYNC_NUMERATOR
// 0x00680684 - NV_PRAMDAC_LGS_HSYNC_DENOMINATOR
// 0x00680688 - NV_PRAMDAC_LGS_HSYNC_HIGH
// 0x0068068C - NV_PRAMDAC_LGS_HSYNC_HIGH_VSYNC
// 0x00680690 - NV_PRAMDAC_LGS_SWITCHES
//
const ULONG _declspec(selectany) AvpRegisters[][26] =
{
    { /* offset */ 0x00680898, 0x0068089C, 0x006808C0, 0x006808C4, 0x0068084C, 0x00680630, 0x00680800, 0x00680804, 0x00680808, 0x0068080C, 0x00680810, 0x00680814, 0x00680818, 0x00680820, 0x00680824, 0x00680828, 0x0068082C, 0x00680830, 0x00680834, 0x00680838, 0x00680848, 0x00680680, 0x00680684, 0x00680688, 0x0068068C, 0x00680690 }, /* offset */
    { /*      1 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x0000027F, 0x00000307, 0x00000257, 0x0000028D, 0x000002AD, 0x00000000, 0x0000027F, 0x10100111, 0x000C6ED0, 0x0000020D, 0x0000009B, 0x0000026C, 0x00000000 }, /*  1 */
    { /*      2 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x000002CF, 0x00000365, 0x000002A7, 0x000002DF, 0x000002FF, 0x00000000, 0x000002CF, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  2 */
    { /*      3 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EB, 0x00000000, 0x000001DF, 0x0000027F, 0x000003B5, 0x00000257, 0x000002B7, 0x000002D7, 0x00000000, 0x0000027F, 0x10100111, 0x000F387C, 0x00000271, 0x000000BE, 0x000002F8, 0x00000000 }, /*  3 */
    { /*      4 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EB, 0x00000000, 0x000001DF, 0x000002CF, 0x00000419, 0x000002AF, 0x0000030B, 0x0000032B, 0x00000000, 0x000002CF, 0x10100111, 0x0010D2A4, 0x00000271, 0x000000D2, 0x00000348, 0x00000000 }, /*  4 */
    { /*      5 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000249, 0x0000024C, 0x00000000, 0x0000023F, 0x0000027F, 0x00000313, 0x00000257, 0x0000028F, 0x000002AF, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /*  5 */
    { /*      6 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000249, 0x0000024C, 0x00000000, 0x0000023F, 0x000002CF, 0x00000375, 0x000002AF, 0x000002E1, 0x00000302, 0x00000000, 0x000002CF, 0x10100111, 0x0010E62C, 0x00000271, 0x000000B1, 0x000002C4, 0x00000000 }, /*  6 */
    { /*      7 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  7 */
    { /*      8 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x0000029F, 0x000002E1, 0x00000320, 0x00000000, 0x000002CF, 0x10100111, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /*  8 */
    { /*      9 */ 0x0AA94000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x000000A0, 0x0000045F, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  9 */
    { /*      A */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004CF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100011, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  A */
    { /*      B */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x000002CF, 0x000002ED, 0x000002CF, 0x000002D4, 0x000002D9, 0x00000000, 0x000002CF, 0x000004FF, 0x00000671, 0x000004FF, 0x00000545, 0x00000595, 0x00000000, 0x000004FF, 0x10100111, 0x00000672, 0x00000001, 0x0000014A, 0x00000528, 0x00000001 }, /*  B */
    { /*      C */ 0x071AE000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AA, 0x000007AB, 0x00000803, 0x000000F0, 0x0000068F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  C */
    { /*      D */ 0x10000000, 0x07183800, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043C, 0x0000043C, 0x00000446, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x00000759, 0x000007AB, 0x00000803, 0x00000000, 0x0000077F, 0x10133011, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  D */
    { /*      E */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000003, 0x00000437, 0x00000464, 0x0000043B, 0x0000043B, 0x00000445, 0x00000000, 0x00000437, 0x0000077F, 0x00000897, 0x000007AB, 0x000007AC, 0x00000804, 0x00000000, 0x0000077F, 0x10133111, 0x00000898, 0x00000001, 0x000001B8, 0x000006E0, 0x00000001 }, /*  E */
    { /*      F */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x0000027F, 0x00000355, 0x000002A7, 0x000002B0, 0x000002D0, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /*  F */
    { /*     10 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001EA, 0x000001ED, 0x00000000, 0x000001DF, 0x0000027F, 0x00000419, 0x000002A7, 0x000002DB, 0x000002FB, 0x00000000, 0x0000027F, 0x10100111, 0x000DF05C, 0x0000020D, 0x000000AE, 0x000002B8, 0x00000000 }, /* 10 */
    { /*     11 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x000001DF, 0x0000020C, 0x000001DF, 0x000001E8, 0x000001EE, 0x00000000, 0x000001DF, 0x000002CF, 0x00000359, 0x000002CF, 0x000002DF, 0x0000031E, 0x00000020, 0x000002AD, 0x10100011, 0x0000035A, 0x00000001, 0x000000AB, 0x000002AE, 0x00000001 }, /* 11 */
    { /*     12 */ 0x10000000, 0x10000000, 0x00000000, 0x40801080, 0x00801080, 0x00000002, 0x0000023F, 0x00000270, 0x0000023F, 0x00000249, 0x0000024C, 0x00000000, 0x0000023F, 0x0000027F, 0x00000363, 0x00000257, 0x000002B0, 0x000002D0, 0x00000000, 0x0000027F, 0x10100111, 0x000F07A8, 0x00000271, 0x0000009D, 0x00000276, 0x00000000 }, /* 12 */
};

const UCHAR _declspec(selectany) AvpCRTCRegisters[][34] =
{
    { /* offset */ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x20, 0x25, 0x2D, 0x33, 0x39, 0x41 }, /* offset */
    { /*      1 */ 0x56, 0x4F, 0x4F, 0x9C, 0x51, 0x35, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      1 */
    { /*      2 */ 0x65, 0x59, 0x59, 0x89, 0x5B, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      2 */
    { /*      3 */ 0x6F, 0x4F, 0x4F, 0x93, 0x55, 0xB9, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      3 */
    { /*      4 */ 0x6F, 0x59, 0x59, 0x93, 0x5B, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      4 */
    { /*      5 */ 0x56, 0x4F, 0x4F, 0x9C, 0x51, 0x35, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      5 */
    { /*      6 */ 0x65, 0x59, 0x59, 0x89, 0x5B, 0xBF, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      6 */
    { /*      7 */ 0x59, 0x4F, 0x4F, 0x9D, 0x51, 0x39, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      7 */
    { /*      8 */ 0x63, 0x59, 0x59, 0x87, 0x5B, 0xA3, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      8 */
    { /*      9 */ 0x78, 0x4F, 0x4F, 0x9C, 0x57, 0xA1, 0xFC, 0x1F, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE4, 0x09, 0xDF, 0x00, 0x00, 0xDF, 0xFD, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      9 */
    { /*      A */ 0xC8, 0x9F, 0x9F, 0x8C, 0xA7, 0x31, 0xEC, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0x09, 0xCF, 0x00, 0x00, 0xCF, 0xED, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      A */
    { /*      B */ 0x67, 0x4F, 0x4F, 0x8B, 0x54, 0xBF, 0x03, 0x11, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF1, 0x06, 0xEF, 0x00, 0x00, 0xEF, 0x04, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0x36, 0x00 }, /*      B */
    { /*      C */ 0x04, 0xEF, 0xEF, 0x88, 0xF4, 0x3F, 0x2F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1D, 0x02, 0x1B, 0x00, 0x00, 0x1B, 0x30, 0xE3, 0xFF, 0x00, 0x38, 0x05, 0x80, 0x00, 0x01, 0x11, 0x10, 0x00 }, /*      C */
    { /*      D */ 0x65, 0x4F, 0x4F, 0x89, 0x5B, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      D */
    { /*      E */ 0x7E, 0x4F, 0x4F, 0x82, 0x5B, 0x3F, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0B, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x00, 0x00, 0x11, 0xFF, 0x00 }, /*      E */
    { /*      F */ 0x61, 0x57, 0x57, 0x85, 0x59, 0xBF, 0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0xDF, 0x00, 0x00, 0xDF, 0x0C, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*      F */
    { /*     10 */ 0x65, 0x4F, 0x4F, 0x9C, 0x51, 0x35, 0x6F, 0xF0, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x08, 0x3F, 0x00, 0x00, 0x3F, 0x70, 0xE3, 0xFF, 0x00, 0x3A, 0x05, 0x80, 0x10, 0x00, 0x11, 0xFF, 0x00 }, /*     10 */
};

#endif !FOCUS

//
// Common registers
//

const ULONG _declspec(selectany) AvpFpDebug0[] =
{
    /* offset */ 0x00680880,
    /*      1 */ 0x21101100,
    /*      2 */ 0x21101100,
    /*      3 */ 0x21101100,
    /*      4 */ 0x21101100,
    /*      5 */ 0x21101100,
    /*      6 */ 0x21101100,
    /*      7 */ 0x21101101,
    /*      8 */ 0x21101100,
    /*      9 */ 0x21101115,
    /*      A */ 0x21101111,
    /*      B */ 0x21101100,
    /*      C */ 0x21101155,
    /*      D */ 0x21101151,
    /*      E */ 0x21101100,
    /*      F */ 0x21101100,
    /*     10 */ 0x21101100,
    /*     11 */ 0x21101101,
    /*     12 */ 0x21101100,
};

const UCHAR _declspec(selectany) AvpSRXRegisters[] =
{
 // SR0   SR1   SR2   SR3   SR4   
    0x03, 0x21, 0x0F, 0x00, 0x06, 
};

const UCHAR _declspec(selectany) AvpGRXRegisters[] =
{
 // GR0   GR1   GR2   GR3   GR4   GR5   GR6   GR7   GR8   
    0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF, 
};

const UCHAR _declspec(selectany) AvpARXRegisters[] =
{
 // AR0   AR1   AR2   AR3   AR4   AR5   AR6   AR7   AR8   AR9   ARA   ARB   ARC   ARD   ARE   ARF   AR10  AR11  AR12  AR13  AR14  
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x4A, 0x0F, 0x00, 0x00, 
};


#endif DEFINE_REGISTERS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\em387.inc ===
subttl  em387.inc - Emulator Internal Format and Macros
	page
;***
;em387.inc - Emulator Internal Format and Macros
;
;	 Microsoft Confidential
;
;	 Copyright (c) Microsoft Corporation 1987, 1992
;
;	 All Rights Reserved
;
;Purpose:
;	Emulator Internal Format and Macros
;
;Revision History:  (also see emulator.hst)
;
;    8/23/91  TP    New tag definitions
;   10/30/89  WAJ   Added this header.
;   02/12/89  WAJ   Added local stack frame definition.
;
;*******************************************************************************


GetEmData	macro	dest,use
ifdef	_CRUISER
	mov	dest,[edataSEG]
elseifdef  _DOS32EXT
ifdifi	<use>,<ax>
	push	eax
	call	_SelKrnGetEmulData
	mov	dest,ax
	pop	eax
else
	call	_SelKrnGetEmulData
	mov	dest,ax
endif
endif
	endm



;The SKIP macro optimizes very short jumps by treating the code
;as data to a "cmp" instruction.  This reduces jump time from
;8 clocks or more down to 2 clocks.  It destroy the flags!

SKIP	macro	dist,target
if	dist eq 4
	db	3DH			;cmp eax,<immed>
elseif	dist eq 3
	db	3DH,0			;cmp eax,<immed>
elseif	dist eq 2
	db	66H,3DH			;cmp ax,<immed>
elseif	dist eq 1
	db	3CH			;cmp al,<immed>
else
	.err
endif

	ifnb	<target>
.erre	$+dist eq target
	endif

	endm

;*******************************************************************************
;
;   80x87 environment structures.
;
;*******************************************************************************


Env80x87_32 struc
	E32_ControlWord	dw	?
	reserved1		dw	?
	E32_StatusWord	dw	?
	reserved2		dw	?
	E32_TagWord		dw	?
	reserved3		dw	?
	E32_CodeOff		dd	?
	E32_CodeSeg		dw	?
	reserved4		dw	?
	E32_DataOff		dd	?
	E32_DataSeg		dw	?
	reserved5		dw	?
Env80x87_32 ends


;---------------------------------------------------------------------------
;
; Emulator Internal Format:
;
;	     +0  +1  +2  +3  +4  +5  +6  +7  +8  +9  +10 +11
;	    .___.___.___.___.___.___.___.___.___.___.___.___.
;   ptr --> |___|___|___|___|___|___|___|___|___|___|___|___|
;	     lsb			 msb tag sgn exl exh
;	    |<---      mantissa 	--->|       |exponent
;
;   The mantissa contains the leading 1 before the decimal point in the hi
;   bit of the msb. The exponent is not biased (signed two's complement).
;   The flag and tag bytes are as below.
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Sign:   |___|_X_|_X_|_X_|_X_|_X_|_X_|_X_|  X = unused
;	      ^ 
;     SIGN
;
;
;   bit:      7   6   5   4   3   2   1   0
;	    .___.___.___.___.___.___.___.___.
;   Tag:    |___|___|_X_|_X_|___|___|___|___|  X = unused
;	      ^	  ^	      ^	  ^   ^   ^
;	      |	  |	      |	  |   |	  |
;    387 tag -+---+	      |	  |   |   |
;			      |	  |   |	  |
;    Special enumeration -----+---+   |	  |
;				      |	  |
;    Internal tag --------------------+---+
;
;There are four internal tags: Single, Double, Zero, Special.  Within
;Special, there is NAN, Infinity, Denormal, and Empty.
;
;Representations for Single, Double, and Denormal are the same.  Denormals
;are not actually kept denormalized, although they are rounded to the
;correct number of bits as if they were.  The Single tag means the 
;low 32 bits of the mantissa are zero.  This allows optimizing multiply 
;and divide.
;
;Tag		Mantissa	Exponent	Sign
;---------------------------------------------------
;Zero		0		0		valid
;Empty		?		?		?
;NAN		valid		TexpMax		valid
;Infinity	8000...000	TexpMax		valid
;
;The mantissa for a NAN distinguishes between a quiet NAN (QNAN) or a 
;signaling NAN (SNAN).  If the bit below the MSB is 1, it is a QNAN,
;otherwise it is an SNAN.
;


;*******************************************************************************
;*
;*  Stack entry defineds with a struct.
;*
;*******************************************************************************

EmStackEntry struc
    bMan0   db	    ?
    bMan1   db	    ?
    bMan2   db	    ?
    bMan3   db	    ?
    bMan4   db	    ?
    bMan5   db	    ?
    bMan6   db	    ?
    bMan7   db	    ?
    bTag    db	    ?
    bSgn    db      ?
    bExpLo  db      ?
    bExpHi  db      ?
EmStackEntry ends

wMantisa struc
    wMan0   dw	    ?
    wMan1   dw	    ?
    wMan2   dw	    ?
    wMan3   dw	    ?
    TagSgn  dw	    ?
    wExp    dw	    ?
wMantisa ends


lMantisa struc
    lManLo	dd	?
    lManHi	dd	?
    ExpSgn	dd	?
lMantisa ends

.erre	size lMantisa eq size wMantisa

Reg87Len	equ	size lMantisa


;*******************************************************************************
;*
;*  bFlags and bTag constants.
;*
;*******************************************************************************

;The rules for internal number formats:
;
;1. Everything is either normalized or zero--unnormalized formats cannot
;get in.  So if the high half mantissa is zero, the number must be all zero.
;
;2. Although the exponent bias is different, NANs and Infinities are in
;standard IEEE format - exponent is TexpMax, mantissa indicates NAN vs.
;infinity (mantissa for infinity is 800..000H).
;
;3. Denormals have an exponent less than TexpMin.
;
;4. If the low half of the mantissa is zero, it is tagged bTAG_SNGL
;
;5. Everything else is bTAG_VALID


bSign	    equ     80h

;These are the INTERNAL flags
TAG_MASK	equ	3
TAG_SHIFT	equ	2
;
TAG_SNGL	equ	0		;SINGLE: low 32 bits are zero
TAG_VALID	equ	1
TAG_ZERO	equ	2
TAG_SPCL	equ	3		;NAN, Infinity, Denormal, Empty
ZEROorSPCL      equ     2	       ;Test for Zero or Special
;Enumeration of "special":
TAG_SPCLBITS	equ	0CH
TAG_EMPTY	equ	TAG_SPCL+(0 shl TAG_SHIFT)
TAG_INF		equ	TAG_SPCL+(1 shl TAG_SHIFT)
TAG_NAN		equ	TAG_SPCL+(2 shl TAG_SHIFT)
TAG_DEN		equ	TAG_SPCL+(3 shl TAG_SHIFT)

;These are the tags used by the 387
T87_VALID	equ	0
T87_ZERO	equ	1
T87_SPCL	equ	2		;NAN, Infinity, Denormal
T87_EMPTY	equ	3

;The tag word for each stack entry combines these two tags.
;Internal tags are in the low bits, 387 tags are in the high two bits
bTAG_VALID	equ	(T87_VALID shl 6) or TAG_VALID
bTAG_SNGL	equ	(T87_VALID shl 6) or TAG_SNGL
bTAG_ZERO	equ	(T87_ZERO shl 6) or TAG_ZERO
bTAG_NAN	equ	(T87_SPCL shl 6) or TAG_NAN
bTAG_INF	equ	(T87_SPCL shl 6) or TAG_INF
bTAG_EMPTY	equ	(T87_EMPTY shl 6) or TAG_EMPTY
bTAG_DEN	equ	(T87_SPCL shl 6) or TAG_DEN
bTAG_NOPOP	equ	-1

bTAG_MASK   equ     3



MantissaByteCnt equ	8

IexpBias	equ	3FFFh	; 16,383
IexpMax 	equ	7FFFh	; Biased Exponent for Infinity
IexpMin 	equ	0	; Biased Exponent for zero

DexpBias	equ	3FFh	; 1023
DexpMax 	equ	7FFh	; Biased Exponent for Infinity
DexpMin 	equ	0	; Biased Exponent for zero

SexpBias	equ	07Fh	; 127
SexpMax 	equ	0FFh	; Biased Exponent for Infinity
SexpMin 	equ	0	; Biased Exponent for zero

TexpBias	equ	0	; Bias for internal format of temp real
UnderBias	equ	24576	; 3 * 2^13.  Extra bias for unmasked underflow
TexpMax		equ	IexpMax - IexpBias + TexpBias	;NAN/Infinity exponent
TexpMin		equ	IexpMin-IexpBias+1	;Smallest non-denormal exponent

; Control Word Format	CWcntl

RoundControl		equ	0Ch
    RCchop		equ	0Ch
    RCup		equ	08h
    RCdown		equ	04h
    RCnear		equ	 0

PrecisionControl	equ	03h
    PC24		equ	 0
    PC53		equ	02h
    PC64		equ	03h

; Status Word Format	SWcc
    C0			equ	01h
    C1			equ	02h
    C2			equ	04h
    C3			equ	40h
ConditionCode		equ	C3 or C2 or C1 or C0
    CCgreater		equ	 0
    CCless		EQU	C0
    CCequal		equ	C3
    CCincomprable	equ	C3 or C2 or C0

RoundUp			equ	C1
StackOverflow		equ	C1

; Status Flags Format	CURerr

Invalid 		equ	   1h		; chip status flags
Denormal		equ	   2h
ZeroDivide		equ	   4h
Overflow		equ	   8h
Underflow		equ	  10h
Precision		equ	  20h
StackFlag		equ	  40h
Summary 		equ	  80h

SavedErrs		equ	Invalid or Denormal or ZeroDivide or Overflow or Underflow or Precision or StackFlag
LongSavedFlags	equ	(CCincomprable SHL 16) OR (SavedErrs SHL 8)	; save C0, C2, C3 & errs
;*******************************************************************************
;*
;*  Define emulator interrupt stack frame.
;*
;*******************************************************************************

StackFrame   struc
            regEAX	    dd	    ?
	    regECX	    dd	    ?
	    regEDX	    dd	    ?
	    regEBX	    dd	    ?
	    regESP	    dd	    ?
	    regEBP	    dd	    ?
	    regESI	    dd	    ?
	    regEDI	    dd	    ?
	    OldCodeOff      dd      ?
	    OldLongStatus   dd      ?
	    regDS	    dd	    ?
	    regEIP	    dd	    ?
	    regCS	    dd	    ?
	    regFlg	    dd	    ?
StackFrame  ends

regAX	    equ		    word ptr regEAX

; .erre   StatusWord eq LongStatusWord+1
OldStatus   equ		    word ptr OldLongStatus+1

;*******************************************************************************
;*
;*  Define emulator entry point macro.
;*
;*******************************************************************************

EM_ENTRY	macro	entryname
ifdef NT386
public ___&entryname
___&entryname:
endif			; ifdef NT386
		endm

Em87Busy	EQU	1
Em87Idle	EQU	0



ifdef NT386
;*********************************************************************;
;								      ;
;                     Emulator TEB Layout                             ;
;								      ;
;*********************************************************************;

.errnz (TbSystemReserved1 and 3)        ; Make sure TB is dword aligned

Numlev          equ     8               ; Number of stack registers

InitControlWord	equ	37FH		; Default - Round near,
					; 64 bits, all exceptions masked

DefaultControlWord equ  27FH            ; Default - Round near,
                                        ; 53 bits, all exceptions masked

EmulatorTebData struc
    TbSystemResrvd  db      TbSystemReserved1 DUP (?)   ; Skip to Emulator area

    RoundMode       dd      ?           ; Address of rounding routine
    SavedRoundMode  dd      ?           ; For restoring RoundMode
    ZeroVector      dd      ?           ; Address of sum-to-zero routine
    TransRound      dd      ?           ; Round mode w/o precision
    Result          dd      ?           ; Result pointer
    PrevCodeOff     dd      ?
    PrevDataOff     dd      ?

    ;(See comment below on 'emulator stack area'
    CURstk          dd      ?           ; init to start of stack
    BEGstk          db      (Numlev-1)*Reg87Len dup(?) ;Allocate register 1 - 7
    INITstk         db      Reg87Len dup(?)

    FloatTemp       db      Reg87Len dup(?)
    ArgTemp         db      Reg87Len dup(?)

    Einstall        db      0           ; Emulator installed flag
    SWerr           db      ?           ; Initially no exceptions (sticky flags)
    SWcc            db      ?           ; Condition codes from various operations
    CURerr          db      ?           ; initially 8087 exception flags clear
                                        ; this is the internal flag reset after
                                        ; each operation to detect per instruction
                                        ; errors
    CWmask          db      ?           ; exception masks
    CWcntl          db      ?           ; arithmetic control flags
    ErrMask         db      ?
    dummy           db      ?
EmulatorTebData ends

ENDstk          equ byte ptr INITstk + Reg87Len
LongStatusWord  equ dword ptr Einstall  ;Combine Einstall, CURerr, StatusWord
StatusWord      equ word ptr SWerr      ;Combine SWerr, SWcc
CurErrCond      equ word ptr SWcc       ;Combine SWcc, CURErr
LongControlWord equ dword ptr CWmask    ;Combine CWMask, CWcntl, ErrMask, dummy
ControlWord     equ word ptr CWmask     ;Combine CWMask, CWcntl

YFloatTemp      equ FloatTemp
YArgTemp        equ ArgTemp

.errnz (SWerr   - Einstall -1)
.errnz (SWcc    - Einstall -2)
.errnz (CURerr  - Einstall -3)
.errnz (CWcntl  - CWmask   -1)
.errnz (ErrMask - CWmask   -2)
.errnz (dummy   - CWmask   -3)


;*******************************************************************************
;
; Emulator stack area
;
;The top of stack pointer CURstk is initialized to the last register 
;in the list; on a real 8087, this corresponds to hardware register 0.
;The stack grows toward lower addresses, so the first push (which is
;hardware register 7) is stored into the second-to-last slot.  This gives
;the following relationship between hardware registers and memory
;locations:
;
; BEGstk --> |    reg 1    |  (lowest memory address)
; 	     |    reg 2    |
; 	     |    reg 3    |
; 	     |    reg 4    |
; 	     |    reg 5    |
; 	     |    reg 6    |
; 	     |    reg 7    |
; 	     |    reg 0    |  <-- Initial top of stack (empty)
; ENDstk -->
;
;This means that the wrap-around case on decrementing CURstk will not
;occur until the last (8th) item is pushed.
;
;Note that the physical register numbers are only used in regard to
;the tag word.  All other operations are relative the current top.


endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ex.h ===
/*++ BUILD Version: 0007    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ex.h

Abstract:

    Public executive data structures and procedure prototypes.

Author:

    Mark Lucovsky (markl) 23-Feb-1989

Revision History:

--*/

#ifndef _EX_
#define _EX_

//
// Empty struct def so we can forward reference ETHREAD
//

struct _ETHREAD;

//
// System Initialization procedure for EX subcomponent of NTOS (in exinit.c)
//

VOID
InitializePool(
    VOID
    );

// begin_ntddk begin_nthal begin_ntifs begin_wdm

NTKERNELAPI
PVOID
ExAllocatePool(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
NTAPI
ExAllocatePoolWithTag(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

#ifndef POOL_TAGGING
#define ExAllocatePoolWithTag(a,b) ExAllocatePool(a)
#endif //POOL_TAGGING

NTKERNELAPI
VOID
NTAPI
ExFreePool(
    IN PVOID P
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI                                     // ntifs
ULONG                                           // ntifs
ExQueryPoolBlockSize (                          // ntifs
    IN PVOID PoolBlock                          // ntifs
    );                                          // ntifs

//
// Interlocked support routine definitions.
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

// end_ntndis

NTKERNELAPI
LARGE_INTEGER
ExInterlockedAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

// begin_wdm begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
LONGLONG
FASTCALL
ExInterlockedCompareExchange64 (
    IN PLONGLONG Destination,
    IN PLONGLONG Exchange,
    IN PLONGLONG Comperand
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertHeadList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedInsertTailList (
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY ListEntry
    );

NTKERNELAPI
PLIST_ENTRY
FASTCALL
ExInterlockedRemoveHeadList (
    IN PLIST_ENTRY ListHead
    );

// begin_ntndis

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables MIPS, Alpha, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
// The PowerPc, however, must use a spinlock to synchronize access to the
// list.
//
// N.B. A spinlock must be specified with SLIST operations. However, it may
//      not actually be used.
//

/*++

VOID
ExInitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#define ExInitializeSListHead(_listhead_) (_listhead_)->Alignment = 0

/*++

USHORT
ExQueryDepthSList (
    IN PSLIST_HEADERT SListHead
    )

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#define ExQueryDepthSList(_listhead_) (USHORT)(_listhead_)->Depth

#if !defined(_WINBASE_)

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSINGLE_LIST_ENTRY ListEntry
    );

NTKERNELAPI
PSINGLE_LIST_ENTRY
FASTCALL
InterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#endif

// end_ntndis
// end_ntddk end_nthal end_ntifs end_wdm

//
// Timer Rundown
//

NTKERNELAPI
VOID
ExTimerRundown (
    VOID
    );

//
// Reader/writer lock.
//

typedef struct _ERWLOCK {
    LONG LockCount;
    ULONG WritersWaitingCount;
    ULONG ReadersWaitingCount;
    ULONG ReadersEntryCount;
    KEVENT WriterEvent;
    KSEMAPHORE ReaderSemaphore;
} ERWLOCK, *PERWLOCK;

NTKERNELAPI
VOID
ExInitializeReadWriteLock(
    IN PERWLOCK ReadWriteLock
    );

NTKERNELAPI
VOID
ExAcquireReadWriteLockExclusive(
    IN PERWLOCK ReadWriteLock
    );

NTKERNELAPI
VOID
ExAcquireReadWriteLockShared(
    IN PERWLOCK ReadWriteLock
    );

NTKERNELAPI
VOID
ExReleaseReadWriteLock(
    IN PERWLOCK ReadWriteLock
    );

#if DBG

#define ExDbgIsReadWriteLockLocked(ReadWriteLock) \
    ((ReadWriteLock)->LockCount >= 0)

#define ExDbgIsReadWriteLockExclusive(ReadWriteLock) \
    (ExDbgIsReadWriteLockLocked(ReadWriteLock) && ((ReadWriteLock)->ReadersEntryCount == 0))

#define ExDbgIsReadWriteLockShared(ReadWriteLock) \
    (ExDbgIsReadWriteLockLocked(ReadWriteLock) && ((ReadWriteLock)->ReadersEntryCount > 0))

#endif

//
// Raise exception from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseException (
    PEXCEPTION_RECORD ExceptionRecord
    );

// begin_ntddk begin_wdm begin_ntifs
//
// Raise status from kernel mode.
//

NTKERNELAPI
VOID
NTAPI
ExRaiseStatus (
    IN NTSTATUS Status
    );

// end_wdm end_ntddk end_ntifs

// begin_ntddk

//
// UUID Generation
//

typedef GUID UUID;

// end_ntddk

#endif /* _EX_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\bldr.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    bldr.h

Abstract:

    Header file for Xbox boot loader

--*/

#ifndef _BLDR_H
#define _BLDR_H

//
// size of romdec code
//
#define ROM_DEC_SIZE                0x200

//
// define the starting physical address where the ROM decrypts the boot loader
// must match BLDR_BOOT_ORIGIN in bldr.inc
//
#define BLDR_BOOT_ORIGIN            0x00090000

//
// define the starting physical address where the boot loader relocates itself
// must match BLDR_RELOCATED_ORIGIN in bldr.inc
//
#define BLDR_RELOCATED_ORIGIN       0x00400000

//
// size of the boot loader.  This is a fixed size that the RomDec code expects to decrypt
// must match ROMLDR_SIZE in bldr.inc
//
#define BLDR_BLOCK_SIZE             (24*1024)

//
// size of the preloader.  This is a fixed size that the romdec code expects to
// compute the hash of the preloader
//
#define PRELDR_BLOCK_SIZE           (21 * 512)

//
// location of the romdec pieces
//
#define ROMDEC_HASH                 88
#define ROMDEC_N                    100

//
// a signature that is checked by the romdec code
// must match ROMLDR_SIGNATURE in bldr.inc
//
#define BLDR_SIGNATURE              0x7854794A

//
// same as XC_DIGEST_LEN
//
#define XBOOT_DIGEST_LEN            20

typedef struct _XBOOT_PARAM
{
    ULONG       UncompressedKernelDataSize;
    ULONG       InitTableSize;

    //
    // The Signature field must be at the following byte offset.  Add new fields
    // to the front of this structure: the XBOOT_PARAM structure is placed at
    // the end of the boot loader image.
    //

    ULONG       Signature;
    ULONG       CompressedKernelSize;
    UCHAR       MainRomDigest[XBOOT_DIGEST_LEN];       // digest of main rom (kernel)
} XBOOT_PARAM, *PXBOOT_PARAM;

//
// constants for lzx compression
//
#define LZX_WINDOW_SIZE             (128*1024)
#define LZX_CHUNK_SIZE              (32*1024)
#define LZX_WORKSPACE               (256*1024)

//
// this structure is the header for each compression block
//
typedef struct _LZXBOX_BLOCK
{
    USHORT      CompressedSize;
    USHORT      UncompressedSize;

} LZXBOX_BLOCK, *PLZXBOX_BLOCK;

//
// this structures lives at PsNtosImageBase.IMAGE_DOS_HEADER.e_res2 (must be
// less than 10 USHORTs)
//
typedef struct _XDATA_SECTION_HEADER
{
    ULONG       SizeOfUninitializedData;
    ULONG       SizeOfInitializedData;
    ULONG       PointerToRawData;
    ULONG       VirtualAddress;
} XDATA_SECTION_HEADER, *PXDATA_SECTION_HEADER;

//
// Define a routine to reenter the boot loader in order to boot an alternate
// ROM at the supplied base physical address.
//

typedef
VOID
(__fastcall *PBLDR_LOAD_MEDIA_ROM_ROUTINE)(
    ULONG_PTR MediaROMBaseAddress
    );



#endif // _BLDR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\dm.h ===
/*
 *
 * dm.h
 *
 * Information for the debug monitor
 *
 */

#ifndef _DM_
#define _DM_

// Per thread debug monitor data
typedef struct _DMTD {
    ULONG LastError;
    PVOID WinSockData;
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ExceptionContext;
    ULONG ExceptionDr6;
    ULONG DebugFlags;
    union {
        PKSYSTEM_ROUTINE SystemStartupRoutine;
        PVOID FuncCallData;
    };
    ULONG UserData;
    PKEVENT DebugEvent;
// don't change anything above this line
    PVOID ExceptionStack;
    KEVENT DebugEventData;
} DMTD, *PDMTD;

// values for dmtd.DebugFlags
#define DMFLAG_HALTTHREAD 1 // halt this thread
#define DMFLAG_FCE 2 // stopped in first chance exception
#define DMFLAG_EXCEPTION 4 // continue exception processing
#define DMFLAG_STOPPED 8 // this thread is stopped
#define DMFLAG_DEBUGTHREAD 0x10 // this thread belongs to the debugger
#define DMFLAG_XAPITHREAD 0x20 // this is an XAPI thread
#define DMFLAG_KDEXCEPT 0x40 // send the current exception to KD
#define DMFLAG_STARTTHREAD 0x80 // this thread is starting up
#define DMFLAG_FUNCCALL 0x100 // going to execute a function call
#define DMFLAG_INFUNCCALL 0x200 // inside a function call

// Data shared between the debug monitor and XAPI
typedef struct _DMXAPI {
    BOOLEAN XapiStarted;
    ULONG LastErrorTlsOff;
    ULONG CurrentFiberTlsOff;
// don't change anything above this line
} DMXAPI, *PDMXAPI;

// Data shared between the debug monitor and the D3D driver
typedef struct D3DSurface D3DSurface;
typedef struct _DMGD {
    volatile ULONG *FrameCounter;
    volatile PULONG FlipCounter;
    D3DSurface *Surface;
    PVOID *RegisterBase;
    PVOID PerfCounters;
    volatile PULONG pdwOpcode;
    unsigned char **ppSnapshotBuffer;
// don't change anything above this line
} DMGD, *PDMGD;

// Opcode constants for handshake between DM and D3D
// Pixel shader snapshot handshake with DM goes like this:
//     DM                 D3D
//  --------------     ------------
//                     PSSNAP_IDLE
//  PSSNAP_REQUEST
//                     PSSNAP_BUSY
//                     PSSNAP_ACK
//  PSSNAP_DONE
//                     PSSNAP_IDLE

#define PSSNAP_IDLE     0x00000000
#define PSSNAP_REQUEST  0x01000000
#define PSSNAP_BUSY     0x02000000
#define PSSNAP_ACK      0x03000000
#define PSSNAP_ERROR    0x04000000
#define PSSNAP_DONE     0x05000000

#define VSSNAP_IDLE     0x00000000
#define VSSNAP_REQUEST  0x81000000
#define VSSNAP_BUSY     0x82000000
#define VSSNAP_ACK      0x83000000
#define VSSNAP_ERROR    0x84000000
#define VSSNAP_DONE     0x85000000

#define XRAY_IDLE       0x00000000
#define XRAY_BEGINREQ   0x11000000
#define XRAY_BEGINACK   0x12000000
#define XRAY_ENDREQ     0x13000000
#define XRAY_ENDACK     0x14000000
#define XRAY_ERROR      0x15000000


// System-wide global debug monitor state
typedef struct _DMINIT {
    PKDEBUG_ROUTINE *DebugRoutine;
    PLIST_ENTRY LoadedModuleList;
    ULONG Flags;
    PVOID *ClockIntRoutine;
    PVOID *ProfIntRoutine;
    ULONG (*TellRoutine)(ULONG code, PVOID data);
    PVOID *CtxSwapNotifyRoutine;
    PVOID XProfpDataPtr;
    PDMGD D3DDriverData;
    PDMXAPI XapiData;
    PBOOLEAN DisallowXbdm;
    void (*HalStartProfileRoutine)(ULONG);
    void (*HalStopProfileRoutine)(ULONG);
    void (*HalProfileIntervalRoutine)(ULONG);
    PVOID *DpcDispatchNotifyRoutine;
// don't change anything above this line
} DMINIT, *PDMINIT;

// values for dminit.Flags
#define DMIFLAG_BREAK 2 // break prior to calling xapi
#define DMIFLAG_BUGCHECK 4 // we're in a bugcheck
#define DMIFLAG_RUNSHELL 8 // we've launched the shell
#define DMIFLAG_CDBOOT  16 // we've booted from the CD

// No code outside XBDM should be accessing the DebugData field
#ifdef DEVKIT
#define DmGetCurrentDmtd() ((PDMTD)PsGetCurrentThread()->DebugData)
#endif

#define DmGetCurrentDmi() ((PDMINIT)KeGetCurrentPrcb()->DebugMonitorData)

FORCEINLINE PVOID DmGetCurrentValue(ULONG ulOff)
{
    PDMINIT pdmi = DmGetCurrentDmi();
    return pdmi ? *(PVOID*)((ULONG_PTR)pdmi + ulOff) : NULL;
}

#define DmiOffset(field) ((ULONG_PTR)&((PDMINIT)NULL)->field)
#define DmGetCurrentDmgd() ((PDMGD)DmGetCurrentValue(DmiOffset(D3DDriverData)))
#define DmGetCurrentXapi() ((PDMXAPI)DmGetCurrentValue(DmiOffset(XapiData)))

FORCEINLINE ULONG DmTell(ULONG ulCode, PVOID pvData)
{
    PDMINIT pdmi = DmGetCurrentDmi();
    if(pdmi)
        return pdmi->TellRoutine(ulCode, pvData);
    else
        return 0;
}

#define DMTELL_ENTERDEBUGGER    1
#define DMTELL_REBOOT           2
#define DMTELL_MAPDRIVE         3 // pointer to DMDRIVE
#define DMTELL_FRAMECOUNT       4 // pointer to D3D frame counter
#define DMTELL_GPUPERF          5 // pointer to d3d's global D3DPERF
#define DMTELL_REGISTERPERFCOUNTER 6 // pointer to a DMREGISTERPERFCOUNTERPARAMBLOCK
#define DMTELL_UNREGISTERPERFCOUNTER 7 // LPCCH szName name of counter to deregister
#define DMTELL_SETDBGIP         8
#define DMTELL_GETDBGIP         9

// Use DmTell_RegisterPerformanceCounter to register performance counters
// without having to link to xbdm.dll

typedef struct _DMREGISTERPERFCOUNTERPARAMBLOCK
{
    LPCCH szName;
    ULONG dwType;
    PVOID pvArg;
} DMREGISTERPERFCOUNTERPARAMBLOCK,*PDMREGISTERPERFCOUNTERPARAMBLOCK;


FORCEINLINE ULONG DmTell_RegisterPerformanceCounter(LPCCH szName, ULONG dwType, PVOID pvArg)
{
    DMREGISTERPERFCOUNTERPARAMBLOCK block;
    block.szName = szName;
    block.dwType = dwType;
    block.pvArg = pvArg;
    return DmTell(DMTELL_REGISTERPERFCOUNTER, &block);
}

FORCEINLINE ULONG DmTell_UnregisterPerformanceCounter(LPCCH szName)
{
    return DmTell(DMTELL_UNREGISTERPERFCOUNTER, (PVOID) szName);
}

typedef struct _DMDRIVE {
    OCHAR Drive;
    POSTR Path;
} DMDRIVE, *PDMDRIVE;

#endif // _DM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\exboosts.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exboosts.h

Abstract:

    This file contains all of the Priority boots numbers used by the NT
    executive.

Author:

    Steve Wood (stevewo) 03-Jun-1989

Revision History:

--*/

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment definitions.  The comment for each definition gives
// the names of the system services that use the definition when satisfying
// a wait.
//

//
// Priority increment used when satisfying a wait on an executive event
// (NtPulseEvent and NtSetEvent)
//

#define EVENT_INCREMENT                 1

// end_ntddk end_wdm end_ntifs
//
// Priority increment used when satisfying a wait on an executive event pair
//

#define EVENT_PAIR_INCREMENT            1

//
// Priority increment used when satisfying a wait on a semaphore used for
// LPC communication.
//

#define LPC_RELEASE_WAIT_INCREMENT      1

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment when no I/O has been done.  This is used by device
// and file system drivers when completing an IRP (IoCompleteRequest).
//

#define IO_NO_INCREMENT                 0

//
// Priority increment for completing CD-ROM I/O.  This is used by CD-ROM device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_CD_ROM_INCREMENT             1

//
// Priority increment for completing disk I/O.  This is used by disk device
// and file system drivers when completing an IRP (IoCompleteRequest)
//

#define IO_DISK_INCREMENT               1

// end_ntifs
//
// Priority increment for completing keyboard I/O.  This is used by keyboard
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_KEYBOARD_INCREMENT           6

// begin_ntifs
//
// Priority increment for completing mailslot I/O.  This is used by the mail-
// slot file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_MAILSLOT_INCREMENT           2

// end_ntifs
//
// Priority increment for completing mouse I/O.  This is used by mouse device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_MOUSE_INCREMENT              6

// begin_ntifs
//
// Priority increment for completing named pipe I/O.  This is used by the
// named pipe file system driver when completing an IRP (IoCompleteRequest).
//

#define IO_NAMED_PIPE_INCREMENT         2

//
// Priority increment for completing network I/O.  This is used by network
// device and network file system drivers when completing an IRP
// (IoCompleteRequest).
//

#define IO_NETWORK_INCREMENT            2

// end_ntifs
//
// Priority increment for completing parallel I/O.  This is used by parallel
// device drivers when completing an IRP (IoCompleteRequest)
//

#define IO_PARALLEL_INCREMENT           1

//
// Priority increment for completing serial I/O.  This is used by serial device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SERIAL_INCREMENT             2

//
// Priority increment for completing sound I/O.  This is used by sound device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_SOUND_INCREMENT              8

//
// Priority increment for completing video I/O.  This is used by video device
// drivers when completing an IRP (IoCompleteRequest)
//

#define IO_VIDEO_INCREMENT              1

// end_ntddk end_wdm
//
// Priority increment used when satisfying a wait on an executive mutant
// (NtReleaseMutant)
//

#define MUTANT_INCREMENT                1

// begin_ntddk begin_wdm begin_ntifs
//
// Priority increment used when satisfying a wait on an executive semaphore
// (NtReleaseSemaphore)
//

#define SEMAPHORE_INCREMENT             1

// end_ntddk end_wdm end_ntifs
//
// Priority increment used when queuing an APC for an executive timer.
//

#define TIMER_APC_INCREMENT             0

//
// Priority increment used to get slow exclusive eresource holders
// moving again.
//

#define ERESOURCE_INCREMENT             4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\i386.h ===
/*++ BUILD Version: 0014    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i386.h

Abstract:

    This module contains the i386 hardware specific header file.

Author:

    David N. Cutler (davec) 2-Aug-1989

Revision History:

    25-Jan-1990    shielint

                   Added definitions for 8259 ports and commands and
                   macros for 8259 irq# and system irql conversion.

--*/

#ifndef _i386_
#define _i386_

// begin_ntddk begin_wdm

#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1

// end_ntddk end_wdm

//
// Interrupt controller register addresses.
//

#define PIC1_PORT0 0x20         // master PIC
#define PIC1_PORT1 0x21
#define PIC2_PORT0 0x0A0        // slave PIC
#define PIC2_PORT1 0x0A1

//
// Commands for Interrupt Controller
//

#define PIC1_EOI_MASK 0x60
#define PIC2_EOI      0x62
#define OCW2_NON_SPECIFIC_EOI 0x20
#define OCW3_READ_ISR 0xb
#define OCW3_READ_IRR 0xa

//
// Length on interrupt object dispatch code in longwords.
//

#define NORMAL_DISPATCH_LENGTH 22                   // ntddk wdm
#define DISPATCH_LENGTH NORMAL_DISPATCH_LENGTH      // ntddk wdm

//
// Define constants to access the bits in CR0.
//

#define CR0_PG  0x80000000          // paging
#define CR0_ET  0x00000010          // extension type (80387)
#define CR0_TS  0x00000008          // task switched
#define CR0_EM  0x00000004          // emulate math coprocessor
#define CR0_MP  0x00000002          // math present
#define CR0_PE  0x00000001          // protection enable

//
// More CR0 bits; these only apply to the 80486.
//

#define CR0_CD  0x40000000          // cache disable
#define CR0_NW  0x20000000          // not write-through
#define CR0_AM  0x00040000          // alignment mask
#define CR0_WP  0x00010000          // write protect
#define CR0_NE  0x00000020          // numeric error

//
// CR4 bits;  These only apply to Pentium
//

#define CR4_VME 0x00000001          // V86 mode extensions
#define CR4_PVI 0x00000002          // Protected mode virtual interrupts
#define CR4_TSD 0x00000004          // Time stamp disable
#define CR4_DE  0x00000008          // Debugging Extensions
#define CR4_PSE 0x00000010          // Page size extensions
#define CR4_PAE 0x00000020          // Physical address extensions
#define CR4_MCE 0x00000040          // Machine check enable
#define CR4_PGE 0x00000080          // Page global enable
#define CR4_FXSR 0x00000200         // FXSR used by OS
#define CR4_XMMEXCPT 0x00000400     // XMMI used by OS

//
// Define constants to access ThNpxState
//

#define NPX_STATE_NOT_LOADED    (CR0_TS | CR0_MP)
#define NPX_STATE_LOADED        0

//
// External references to the labels defined in int.asm
//

extern ULONG KiInterruptTemplate[NORMAL_DISPATCH_LENGTH];
extern PULONG KiInterruptTemplateObject;
extern PULONG KiInterruptTemplateDispatch;
extern PULONG KiInterruptTemplate2ndDispatch;

// begin_ntddk begin_wdm
//
// Interrupt Request Level definitions
//

#define PASSIVE_LEVEL 0             // Passive release level
#define LOW_LEVEL 0                 // Lowest interrupt level
#define APC_LEVEL 1                 // APC interrupt level
#define DISPATCH_LEVEL 2            // Dispatcher level

#define SMBUS_LEVEL 15              // System Management Bus interrupt level
#define PROFILE_LEVEL 26            // Profiler timer interrupt level
#define SCI_LEVEL 27                // System Control Interrupt (SCI) level
#define CLOCK_LEVEL 28              // Interval clock interrupt level
#define IPI_LEVEL 29                // Interprocessor interrupt level
#define POWER_LEVEL 30              // Power failure level
#define HIGH_LEVEL 31               // Highest interrupt level
#define SYNCH_LEVEL (IPI_LEVEL-1)   // Synchronization level
// end_ntddk end_wdm

//
// Define constants used in selector tests.
//
//  RPL_MASK is the real value for extracting RPL values.  IT IS THE WRONG
//  CONSTANT TO USE FOR MODE TESTING.
//
//  MODE_MASK is the value for deciding the current mode.
//  WARNING:    MODE_MASK assumes that all code runs at either ring-0
//              or ring-3.  Ring-1 or Ring-2 support will require changing
//              this value and all of the code that refers to it.

#define MODE_MASK    1
#define RPL_MASK     3

//
// SEGMENT_MASK is used to throw away trash part of segment.  Part always
// pushes or pops 32 bits to/from stack, but if it's a segment value,
// high order 16 bits are trash.
//

#define SEGMENT_MASK    0xffff

//
// Startup count value for KeStallExecution.  This value is used
// until KiInitializeStallExecution can compute the real one.
// Pick a value long enough for very fast processors.
//

#define INITIAL_STALL_COUNT 100

//
// Macro to extract the high word of a long offset
//

#define HIGHWORD(l) \
    ((USHORT)(((ULONG)(l)>>16) & 0xffff))

//
// Macro to extract the low word of a long offset
//

#define LOWWORD(l) \
    ((USHORT)((ULONG)l & 0x0000ffff))

//
// Macro to combine two USHORT offsets into a long offset
//

#if !defined(MAKEULONG)

#define MAKEULONG(x, y) \
    (((((ULONG)(x))<<16) & 0xffff0000) | \
    ((ULONG)(y) & 0xffff))

#endif

//
// Request a software interrupt.
//

#define KiRequestSoftwareInterrupt(RequestIrql) \
    HalRequestSoftwareInterrupt( RequestIrql )

// begin_ntddk begin_wdm

//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTHALAPI
UCHAR
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTHALAPI
USHORT
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTHALAPI
ULONG
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

// end_ntddk end_wdm

//
// Define executive macros for acquiring and releasing executive spinlocks.
// These macros can ONLY be used by executive components and NOT by drivers.
// Drivers MUST use the kernel interfaces since they must be MP enabled on
// all systems.
//
// KeRaiseIrql is one instruction longer than KeAcquireSpinLock on x86 UP.
// KeLowerIrql and KeReleaseSpinLock are the same.
//

// begin_wdm begin_ntddk

#define ExAcquireSpinLock(Lock, OldIrql) KeAcquireSpinLock((Lock), (OldIrql))
#define ExReleaseSpinLock(Lock, OldIrql) KeReleaseSpinLock((Lock), (OldIrql))
#define ExAcquireSpinLockAtDpcLevel(Lock) KeAcquireSpinLockAtDpcLevel(Lock)
#define ExReleaseSpinLockFromDpcLevel(Lock) KeReleaseSpinLockFromDpcLevel(Lock)

// end_wdm end_ntddk

//
// The acquire and release fast lock macros disable and enable interrupts
// on UP nondebug systems. On MP or debug systems, the spinlock routines
// are used.
//
// N.B. Extreme caution should be observed when using these routines.
//

#if defined(_M_IX86) && !defined(USER_MODE_CODE)

#pragma warning(disable:4164)
#pragma intrinsic(_disable)
#pragma intrinsic(_enable)
#pragma warning(default:4164)

#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExAcquireFastLock(Lock, OldIrql) _disable()
#else
#define ExAcquireFastLock(Lock, OldIrql) \
    ExAcquireSpinLock(Lock, OldIrql)
#endif

#if defined(NT_UP) && !DBG && !defined(USER_MODE_CODE)
#define ExReleaseFastLock(Lock, OldIrql) _enable()
#else
#define ExReleaseFastLock(Lock, OldIrql) \
    ExReleaseSpinLock(Lock, OldIrql)
#endif

//
// The following function prototypes must be in this module so that the
// above macros can call them directly.
//

#if defined(NT_UP)

#define KiAcquireSpinLock(SpinLock)

#else

VOID
FASTCALL
KiAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

#if defined(NT_UP)

#define KiReleaseSpinLock(SpinLock)

#else

VOID
FASTCALL
KiReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#endif

//
// Define query system time macro.
//

#define KiQuerySystemTime(CurrentTime) \
    while (TRUE) {                                                    \
        (CurrentTime)->HighPart = KeSystemTime.High1Time;             \
        (CurrentTime)->LowPart = KeSystemTime.LowPart;                \
        if ((CurrentTime)->HighPart == KeSystemTime.High2Time) break; \
        _asm { rep nop }                                              \
    }

//
// Define query interrupt time macro.
//

#define KiQueryInterruptTime(CurrentTime) \
    while (TRUE) {                                                       \
        (CurrentTime)->HighPart = KeInterruptTime.High1Time;             \
        (CurrentTime)->LowPart = KeInterruptTime.LowPart;                \
        if ((CurrentTime)->HighPart == KeInterruptTime.High2Time) break; \
        _asm { rep nop }                                                 \
    }

//
//
// 386 hardware structures
//

//
// A Page Table Entry on an Intel 386/486 has the following definition.
//

typedef struct _HARDWARE_PTE {
    ULONG Valid : 1;
    ULONG Write : 1;
    ULONG Owner : 1;
    ULONG WriteThrough : 1;
    ULONG CacheDisable : 1;
    ULONG Accessed : 1;
    ULONG Dirty : 1;
    ULONG LargePage : 1;
    ULONG Global : 1;
    ULONG GuardOrEndOfAllocation : 1;   // software field
    ULONG PersistAllocation : 1;        // software field
    ULONG reserved : 1;                 // software field
    ULONG PageFrameNumber : 20;
} HARDWARE_PTE, *PHARDWARE_PTE;

//
// GDT Entry
//

typedef struct _KGDTENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} KGDTENTRY, *PKGDTENTRY;

#define TYPE_CODE   0x10  // 11010 = Code, Readable, NOT Conforming, Accessed
#define TYPE_DATA   0x12  // 10010 = Data, ReadWrite, NOT Expanddown, Accessed
#define TYPE_TSS    0x01  // 01001 = NonBusy TSS
#define TYPE_LDT    0x02  // 00010 = LDT

#define DPL_USER    3
#define DPL_SYSTEM  0

#define GRAN_BYTE   0
#define GRAN_PAGE   1

#define SELECTOR_TABLE_INDEX 0x04

//
// Entry of Interrupt Descriptor Table (IDTENTRY)
//

typedef struct _KIDTENTRY {
   USHORT Offset;
   USHORT Selector;
   USHORT Access;
   USHORT ExtendedOffset;
} KIDTENTRY;

typedef KIDTENTRY *PKIDTENTRY;

extern KGDTENTRY KiGDT[];
extern KIDTENTRY KiIDT[];

//
// TSS (Task switch segment) NT only uses to control stack switches.
//
//  The only fields we actually care about are Esp0, Ss0, the IoMapBase
//  and the IoAccessMaps themselves.
//
//
//  N.B.    Size of TSS must be <= 0xDFFF
//

//
// The interrupt direction bitmap is used on Pentium to allow
// the processor to emulate V86 mode software interrupts for us.
// There is one for each IOPM.  It is located by subtracting
// 32 from the IOPM base in the Tss.
//
#define INT_DIRECTION_MAP_SIZE   32
typedef UCHAR   KINT_DIRECTION_MAP[INT_DIRECTION_MAP_SIZE];

#define IOPM_COUNT      1           // Number of i/o access maps that
                                    // exist (in addition to
                                    // IO_ACCESS_MAP_NONE)

#define IOPM_SIZE           8192    // Size of map callers can set.

#define PIOPM_SIZE          8196    // Size of structure we must allocate
                                    // to hold it.

typedef UCHAR   KIO_ACCESS_MAP[IOPM_SIZE];

typedef KIO_ACCESS_MAP *PKIO_ACCESS_MAP;

typedef struct _KiIoAccessMap {
    KINT_DIRECTION_MAP DirectionMap;
    UCHAR IoMap[PIOPM_SIZE];
} KIIO_ACCESS_MAP;

typedef struct _KTSS {

    USHORT  Backlink;
    USHORT  Reserved0;

    ULONG   Esp0;
    USHORT  Ss0;
    USHORT  Reserved1;

    ULONG   Esp1;
    USHORT  Ss1;
    USHORT  Reserved2;

    ULONG   Esp2;
    USHORT  Ss2;
    USHORT  Reserved3;

    ULONG   CR3;

    ULONG   Eip;
    ULONG   EFlags;
    ULONG   Eax;
    ULONG   Ecx;
    ULONG   Edx;
    ULONG   Ebx;
    ULONG   Esp;
    ULONG   Ebp;
    ULONG   Esi;
    ULONG   Edi;

    USHORT  Es;
    USHORT  Reserved4;

    USHORT  Cs;
    USHORT  Reserved5;

    USHORT  Ss;
    USHORT  Reserved6;

    USHORT  Ds;
    USHORT  Reserved7;

    USHORT  Fs;
    USHORT  Reserved8;

    USHORT  Gs;
    USHORT  Reserved9;

    USHORT  LDT;
    USHORT  Reserved10;

    USHORT  Flags;

    USHORT  IoMapBase;

    KIIO_ACCESS_MAP IoMaps[IOPM_COUNT];

    //
    // This is the Software interrupt direction bitmap associated with
    // IO_ACCESS_MAP_NONE
    //
    KINT_DIRECTION_MAP IntDirectionMap;
} KTSS, *PKTSS;

// begin_windbgkd

#ifdef _X86_
//
// Special Registers for i386
//

typedef struct _DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} KDESCRIPTOR, *PKDESCRIPTOR;

typedef struct _KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    KDESCRIPTOR Gdtr;
    KDESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} KSPECIAL_REGISTERS, *PKSPECIAL_REGISTERS;

//
// Processor State frame: Before a processor freezes itself, it
// dumps the processor state to the processor state frame for
// debugger to examine.
//

typedef struct _KPROCESSOR_STATE {
    struct _CONTEXT ContextFrame;
    struct _KSPECIAL_REGISTERS SpecialRegisters;
} KPROCESSOR_STATE, *PKPROCESSOR_STATE;
#endif // _X86_
// end_windbgkd

//
// Processor Control Block (PRCB)
//

typedef struct _KPRCB {

    struct _KTHREAD *CurrentThread;
    struct _KTHREAD *NextThread;
    struct _KTHREAD *IdleThread;
    struct _KTHREAD *NpxThread;

    ULONG   InterruptCount;             // per processor counts
    ULONG   DpcTime;
    ULONG   InterruptTime;
    ULONG   DebugDpcTime;               // per dpc tick count

//
// Kernel performance counters.
//

    ULONG KeContextSwitches;

//
// DPC interrupt requested.
//

    ULONG DpcInterruptRequested;

//
// DPC list head, spinlock, and count.
//

    LIST_ENTRY DpcListHead;
    ULONG DpcRoutineActive;
    PVOID DpcStack;

//
// QuantumEnd indicator
//

    ULONG QuantumEnd;

//
// Npx save area
//
    FX_SAVE_AREA    NpxSaveArea;

//
// network stack handshaking for debug monitor
//
    VOID* DmEnetFunc;

//
// devkit specific data
//
// debugger global data
    VOID* DebugMonitorData;

#ifdef DEVKIT
// function for debug synchronization
    VOID* DebugHaltThread;

// double-fault handler
    VOID* DebugDoubleFault;
#endif // DEVKIT

} KPRCB, *PKPRCB, *RESTRICTED_POINTER PRKPRCB;

// begin_ntddk

//
// Processor Control Region Structure Definition
//

typedef struct _KPCR {

    NT_TIB  NtTib;
    struct _KPCR *SelfPcr;              // flat address of this PCR
    struct _KPRCB *Prcb;                // pointer to Prcb
    KIRQL   Irql;

// end_ntddk

    struct _KPRCB PrcbData;

// begin_ntddk
} KPCR;
typedef KPCR *PKPCR;

// end_ntddk

//
// If kernel mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, Interrupt, AlignCheck.
//
// If user mode, then
//      let caller specify Carry, Parity, AuxCarry, Zero, Sign, Trap,
//      Direction, Overflow, AlignCheck.
//      force Interrupts on.
//

#define EFLAGS_DF_MASK        0x00000400L
#define EFLAGS_INTERRUPT_MASK 0x00000200L
#define EFLAGS_V86_MASK       0x00020000L
#define EFLAGS_ALIGN_CHECK    0x00040000L
#define EFLAGS_IOPL_MASK      0x00003000L
#define EFLAGS_VIF            0x00080000L
#define EFLAGS_VIP            0x00100000L
#define EFLAGS_USER_SANITIZE  0x003e0dd7L

#define SANITIZE_FLAGS(eFlags) ((eFlags) & 0x003e0fd7)

//
// Masks for Dr7 and sanitize macros for various Dr registers.
//

#define DR6_LEGAL   0x0000e00f

#define DR7_LEGAL   0xffff0155  // R/W, LEN for Dr0-Dr4,
                                // Local enable for Dr0-Dr4,
                                // Le for "perfect" trapping

#define DR7_ACTIVE  0x00000055  // If any of these bits are set, a Dr is active

#define SANITIZE_DR6(Dr6) (Dr6 & DR6_LEGAL)

#define SANITIZE_DR7(Dr7) (Dr7 & DR7_LEGAL)

//
// Define macro to clear reserved bits from MXCSR so that we don't
// GP fault when doing an FRSTOR
//
#define SANITIZE_MXCSR(_mxcsr_) ((_mxcsr_) & 0xFFBF)

//
//
// Trap frame
//
//  NOTE - We deal only with 32bit registers, so the assembler equivalents
//         are always the extended forms.
//
//  NOTE - Unless you want to run like slow molasses everywhere in the
//         the system, this structure must be of DWORD length, DWORD
//         aligned, and its elements must all be DWORD aligned.
//
//  NOTE WELL   -
//
//      The i386 does not build stack frames in a consistent format, the
//      frames vary depending on whether or not a privilege transition
//      was involved.
//
//      In order to make NtContinue work for both user mode and kernel
//      mode callers, we must force a canonical stack.
//
//      If we're called from kernel mode, this structure is 8 bytes longer
//      than the actual frame!
//
//  WARNING:
//
//      KTRAP_FRAME_LENGTH needs to be 16byte integral (at present.)
//

typedef struct _KTRAP_FRAME {

//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.
} KTRAP_FRAME;


typedef KTRAP_FRAME *PKTRAP_FRAME;
typedef KTRAP_FRAME *PKEXCEPTION_FRAME;

#define KTRAP_FRAME_LENGTH  (sizeof(KTRAP_FRAME))
#define KTRAP_FRAME_ALIGN   (sizeof(ULONG))
#define KTRAP_FRAME_ROUND   (KTRAP_FRAME_ALIGN-1)

//
//  Bits forced to 0 in SegCs if Esp has been edited.
//

#define FRAME_EDITED        0xfff8

//
//  Switch Frame
//
//  386 doesn't have an "exception frame", and doesn't normally make
//  any use of nonvolatile context register structures.
//
//  However, swapcontext in ctxswap.c and KeInitializeThread in
//  thredini.c need to share common stack structure used at thread
//  startup and switch time.
//
//  This is that structure.
//

typedef struct _KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   Eflags;
    ULONG   RetAddr;
} KSWITCHFRAME, *PKSWITCHFRAME;

//
// Various 387 defines
//

#define I386_80387_NP_VECTOR    0x07    // trap 7 when hardware not present

// begin_ntddk begin_wdm
//
// The non-volatile 387 state
//

typedef struct _KFLOATING_SAVE {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;                 // Not used in wdm
    ULONG   DataSelector;
    ULONG   Cr0NpxState;
    ULONG   Spare1;                     // Not used in wdm
} KFLOATING_SAVE, *PKFLOATING_SAVE;

// end_ntddk end_wdm

//
// i386 Profile values
//

#define DEFAULT_PROFILE_INTERVAL    39063

//
// The minimum acceptable profiling interval is set to 1221 which is the
// fast RTC clock rate we can get.  If this
// value is too small, the system will run very slowly.
//

#define MINIMUM_PROFILE_INTERVAL    1221

//
// Define the value to program the 8254 timer with in order to fire an interrupt
// approximately every one millisecond.
//
// This is assuming a clock rate into the 8254 of 13.5 divided by 12.
//

#define CLOCK_ROLLOVER_COUNT        1125

//
// Define the number of 100ns units to add to the interrupt, system, and other
// timers on every clock interrupt.
//
// This is assuming a clock rate into the 8254 of 13.5 divided by 12.
//

#define CLOCK_TIME_INCREMENT        10000

// begin_ntddk begin_wdm
//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000
#define PAGE_SIZE_LARGE 0x400000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L
#define PAGE_SHIFT_LARGE 22L

// end_wdm

//
// Define the highest user address and user probe address.
//

// end_ntddk

#define MM_HIGHEST_USER_ADDRESS     (PVOID)0x7FFEFFFF
#define MM_SYSTEM_RANGE_START       (PVOID)KSEG0_BASE
#define MM_USER_PROBE_ADDRESS       (KSEG0_BASE - 0x10000)

// begin_ntddk
//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS (PVOID)0x10000

// end_ntddk

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT                   22

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT                   12

//
// Define page directory and page base addresses.
//

#define PDE_BASE                    0xc0300000
#define PTE_BASE                    0xc0000000

//
// Define virtual base and alternate virtual base of kernel.
//

#define KSEG0_BASE                  0x80000000

//
// Define virtual base addresses for physical memory windows.
//

#define MM_BYTES_IN_PHYSICAL_MAP    (256 * 1024 * 1024)
#define MM_PAGES_IN_PHYSICAL_MAP    (MM_BYTES_IN_PHYSICAL_MAP >> PAGE_SHIFT)
#define MM_SYSTEM_PHYSICAL_MAP      KSEG0_BASE

// begin_ntddk

//
// Result type definition for i386.  (Machine specific enumerate type
// which is return type for portable exinterlockedincrement/decrement
// procedures.)  In general, you should use the enumerated type defined
// in ex.h instead of directly referencing these constants.
//

// Flags loaded into AH by LAHF instruction

#define EFLAG_SIGN      0x8000
#define EFLAG_ZERO      0x4000
#define EFLAG_SELECT    (EFLAG_SIGN | EFLAG_ZERO)

#define RESULT_NEGATIVE ((EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_ZERO     ((~EFLAG_SIGN & EFLAG_ZERO) & EFLAG_SELECT)
#define RESULT_POSITIVE ((~EFLAG_SIGN & ~EFLAG_ZERO) & EFLAG_SELECT)

// begin_wdm

#define ExInterlockedInsertHeadList     ExfInterlockedInsertHeadList
#define ExInterlockedInsertTailList     ExfInterlockedInsertTailList
#define ExInterlockedRemoveHeadList     ExfInterlockedRemoveHeadList

// end_wdm

//
// Prototypes for architectural specific versions of Exi386 Api
//

NTKERNELAPI
LARGE_INTEGER
ExInterlockedExchangeAddLargeInteger (
    IN PLARGE_INTEGER Addend,
    IN LARGE_INTEGER Increment
    );

//
// Intrinsic interlocked functions
//

#if (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(NO_INTERLOCKED_INTRINSICS)) && !defined(_WINBASE_)

// begin_wdm

NTKERNELAPI
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    );

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)(Target), (LONG)(Value))

NTKERNELAPI
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    );

NTKERNELAPI
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

// end_wdm

#endif

// end_ntddk

//
// UP/MP versions of interlocked intrinsics for use within ntoskrnl.exe.
//
// N.B. FASTCALL does NOT work with inline functions.
//

#if !defined(_NTDDK_) && !defined(_NTIFS_) && !defined(_NTHAL_) && !defined(_WINBASE_)
#if defined(_M_IX86) && !defined(_CROSS_PLATFORM_)

#pragma warning(disable:4035)               // wdm re-enable below

#if !defined(MIDL_PASS) // wdm

#if !defined(NO_INTERLOCKED_INTRINSICS)
#if defined(NT_UP)

FORCEINLINE
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, 1
        mov     ecx, Addend
        xadd    [ecx], eax
        inc     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, -1
        mov     ecx, Addend
        xadd    [ecx], eax
        dec     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )
{
    __asm {
        mov     edx, Value
        mov     ecx, Target
        mov     eax, [ecx]
ie:     cmpxchg [ecx], edx
        jnz     short ie
    }
}

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
        xadd    [ecx], eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
        cmpxchg [ecx], edx
    }
}

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#else

FORCEINLINE
LONG
FASTCALL
InterlockedIncrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, 1
        mov     ecx, Addend
   lock xadd    [ecx], eax
        inc     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedDecrement(
    IN PLONG Addend
    )
{
    __asm {
        mov     eax, -1
        mov     ecx, Addend
   lock xadd    [ecx], eax
        dec     eax
    }
}

FORCEINLINE
LONG
FASTCALL
InterlockedExchange(
    IN OUT PLONG Target,
    IN LONG Value
    )
{
    __asm {
        mov     eax, Value
        mov     ecx, Target
        xchg    [ecx], eax
    }
}

#define InterlockedExchangePointer(Target, Value) \
   (PVOID)InterlockedExchange((PLONG)Target, (LONG)Value)

// begin_wdm

FORCEINLINE
LONG
FASTCALL
InterlockedExchangeAdd(
    IN OUT PLONG Addend,
    IN LONG Increment
    )
{
    __asm {
        mov     eax, Increment
        mov     ecx, Addend
   lock xadd    [ecx], eax
    }
}


// end_wdm

FORCEINLINE
LONG
FASTCALL
InterlockedCompareExchange(
    IN OUT PLONG Destination,
    IN LONG Exchange,
    IN LONG Comperand
    )
{
    __asm {
        mov     eax, Comperand
        mov     ecx, Destination
        mov     edx, Exchange
   lock cmpxchg [ecx], edx
    }
}

#define InterlockedCompareExchangePointer(Destination, ExChange, Comperand) \
    (PVOID)InterlockedCompareExchange((PLONG)Destination, (LONG)ExChange, (LONG)Comperand)

#endif      // wdm
#endif
#endif

#pragma warning(default:4035)   // wdm

#endif
#endif

// begin_ntddk begin_wdm

#if !defined(MIDL_PASS) && defined(_M_IX86)

//
// i386 function definitions
//

#pragma warning(disable:4035)               // re-enable below

// end_ntddk end_wdm

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE PKPCR KeGetPcr(VOID)
{
#if defined(_NTSYSTEM_)
    extern KPCR KiPCR;
    return (PKPCR)&KiPCR;
#else
    __asm {  mov eax, fs:[0] KPCR.SelfPcr }
#endif
}

//
// Get address of current processor block.
//
// WARNING: This inline macro can only be used by the kernel or hal
//
FORCEINLINE PKPRCB KeGetCurrentPrcb (VOID)
{
#if defined(_NTSYSTEM_)
    return &KeGetPcr()->PrcbData;
#else
    __asm {  mov eax, fs:[0] KPCR.Prcb }
#endif
}

// begin_ntddk begin_wdm

//
// Get current IRQL.
//
// On x86 this function resides in the HAL
//

FORCEINLINE KIRQL KeGetCurrentIrql(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetPcr()->Irql;
#else
    __asm {  movzx eax, byte ptr fs:[0] KPCR.Irql }
#endif
}    


// end_wdm end_ntddk
//
// Get address of current kernel thread object.
//

FORCEINLINE struct _KTHREAD *KeGetCurrentThread(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetCurrentPrcb()->CurrentThread;
#else
    __asm {  mov eax, fs:[0] KPCR.PrcbData.CurrentThread }
#endif
}

//
// If processor executing DPC?
//

FORCEINLINE ULONG KeIsExecutingDpc(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetCurrentPrcb()->DpcRoutineActive;
#else
    __asm {  mov eax, fs:[0] KPCR.PrcbData.DpcRoutineActive }
#endif
}

FORCEINLINE PVOID KeGetCurrentTlsDataTop(VOID)
{
#if defined(_NTSYSTEM_)
    return KeGetPcr()->NtTib.StackBase;
#else
    __asm {  mov eax, fs:[0] NT_TIB.StackBase }
#endif
}

// begin_ntddk begin_wdm

#endif // !defined(MIDL_PASS) && defined(_M_IX86)

// end_ntddk end_wdm

//
//
// Macro to set address of a trap/interrupt handler to IDT
//
#define KiSetHandlerAddressToIDT(Vector, HandlerAddress) \
    KiIDT[Vector].ExtendedOffset = HIGHWORD(HandlerAddress); \
    KiIDT[Vector].Offset = LOWWORD(HandlerAddress);

//
// Macro to return address of a trap/interrupt handler in IDT
//
#define KiReturnHandlerAddressFromIDT(Vector) \
   MAKEULONG(KiIDT[Vector].ExtendedOffset, KiIDT[Vector].Offset)

#pragma warning(default:4035)

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//--
#define KiIsThreadNumericStateSaved(a) \
    (a->NpxState != NPX_STATE_LOADED)

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--

#if defined(NT_UP)

//
// On UP x86 systems, FP state is lazy saved and loaded.  If this
// thread owns the current FP context, clear the ownership field
// so we will not try to save to this thread after it has been
// terminated.
//

#define KiRundownThread(a)                          \
    if (KeGetCurrentPrcb()->NpxThread == (a))   {   \
        KeGetCurrentPrcb()->NpxThread = NULL;       \
    }

#else

#define KiRundownThread(a)

#endif

//
// Procedures to support frame manipulation
//

ULONG
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    );

ULONG
KiSegSsFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiSegSsToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG SegSs
    );

// begin_ntddk begin_wdm

NTKERNELAPI
NTSTATUS
NTAPI
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     FloatSave
    );

NTKERNELAPI
NTSTATUS
NTAPI
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      FloatSave
    );

// end_ntddk end_wdm

VOID
KeClockInterrupt(
    VOID
    );

// begin_ntddk begin_wdm

#endif // defined(_X86_)

// end_ntddk end_wdm

//
// x86 functions for special instructions
//

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrRegister
    );

VOID
WRMSR (
    IN ULONG MsrRegister,
    IN ULONGLONG MsrValue
    );

//
// Define the address of the page directory page.
//

#define PAGE_DIRECTORY_PHYSICAL_ADDRESS ((ULONG_PTR)0x0000F000)

//
// Define the address in RAM where a shadow copy of the ROM is stored.
//

#define ROM_SHADOW_PHYSICAL_ADDRESS ((ULONG_PTR)0x7F00000)
#define ROM_SHADOW_SIZE ((ULONG_PTR)1024*1024)

//
// Microcode update data block.
//

#include <pshpack1.h>

typedef struct _MICROCODE_UPDATE_DATA_BLOCK {
    ULONG HeaderVersion;
    ULONG UpdateRevision;
    USHORT Year;
    UCHAR Day;
    UCHAR Month;
    ULONG Processor;
    ULONG Checksum;
    ULONG LoaderRevision;
    ULONG ProcessorFlags;
    UCHAR Reserved[20];
    UCHAR UpdateData[2000];
} MICROCODE_UPDATE_DATA_BLOCK, *PMICROCODE_UPDATE_DATA_BLOCK;

//
// The kernel tick counter is precisely one millisecond, so the result of
// NtGetTickCount, which must be in units of one millisecond, is equivalent to
// KeQueryTickCount.
//

#define NtGetTickCount() KeQueryTickCount()

#include <poppack.h>

#endif // _i386_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\heap.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    heap.h

Abstract:

    This is the header file that describes the constants and data
    structures used by the user mode heap manager, exported by ntdll.dll
    and ntrtl.lib

    Procedure prototypes are defined in ntrtl.h

Author:

    Steve Wood (stevewo) 21-Aug-1992

Revision History:

--*/

#ifndef _RTL_HEAP_
#define _RTL_HEAP_

#define HEAP_LARGE_TAG_MASK 0xFF000000

#define ROUND_UP_TO_POWER2( x, n ) (((ULONG_PTR)(x) + ((n)-1)) & ~((ULONG_PTR)(n)-1))
#define ROUND_DOWN_TO_POWER2( x, n ) ((ULONG_PTR)(x) & ~((ULONG_PTR)(n)-1))

typedef struct _HEAP_ENTRY {

    //
    //  This field gives the size of the current block in allocation
    //  granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    //  equals the size in bytes).
    //
    //  Except if this is part of a virtual alloc block then this
    //  value is the difference between the commit size in the virtual
    //  alloc entry and the what the user asked for.
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently these are:
    //
    //  0x01 - HEAP_ENTRY_BUSY
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x08 - HEAP_ENTRY_VIRTUAL_ALLOC
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //  0x20 - HEAP_ENTRY_SETTABLE_FLAG1
    //  0x40 - HEAP_ENTRY_SETTABLE_FLAG2
    //  0x80 - HEAP_ENTRY_SETTABLE_FLAG3
    //

    UCHAR Flags;

    //
    // This field contains the number of unused bytes at the end of this
    // block that were not actually allocated.  Used to compute exact
    // size requested prior to rounding requested size to allocation
    // granularity.  Also used for tail checking purposes.
    //

    UCHAR UnusedBytes;

    //
    // Small (8 bit) tag indexes can go here.
    //

    UCHAR SmallTagIndex;

#if defined(_WIN64) || defined(_XBOX)
    ULONGLONG Reserved1;
#endif

} HEAP_ENTRY, *PHEAP_ENTRY;


//
// This block describes extra information that might be at the end of a
// busy block.
//

typedef struct _HEAP_ENTRY_EXTRA {
    union {
        struct {
            //
            // This field is for debugging purposes.  It will normally contain a
            // stack back trace index of the allocator for x86 systems.
            //

            USHORT AllocatorBackTraceIndex;

            //
            // This field is currently unused, but is intended for storing
            // any encoded value that will give the that gives the type of object
            // allocated.
            //

            USHORT TagIndex;

            //
            // This field is a 32-bit settable value that a higher level heap package
            // can use.  The Win32 heap manager stores handle values in this field.
            //

            ULONG_PTR Settable;
        };
#if defined(_WIN64) || defined(_XBOX)
        struct {
            ULONGLONG ZeroInit;
            ULONGLONG ZeroInit1;
        };
#else
        ULONGLONG ZeroInit;
#endif
    };
} HEAP_ENTRY_EXTRA, *PHEAP_ENTRY_EXTRA;

//
// This structure is present at the end of a free block if HEAP_ENTRY_EXTRA_PRESENT
// is set in the Flags field of a HEAP_FREE_ENTRY structure.  It is used to save the
// tag index that was associated with the allocated block after it has been freed.
// Works best when coalesce on free is disabled, along with decommitment.
//

typedef struct _HEAP_FREE_ENTRY_EXTRA {
    USHORT TagIndex;
    USHORT FreeBackTraceIndex;
} HEAP_FREE_ENTRY_EXTRA, *PHEAP_FREE_ENTRY_EXTRA;

//
// This structure describes a block that lies outside normal heap memory
// as it was allocated with NtAllocateVirtualMemory and has the
// HEAP_ENTRY_VIRTUAL_ALLOC flag set.
//

typedef struct _HEAP_VIRTUAL_ALLOC_ENTRY {
    LIST_ENTRY Entry;
    HEAP_ENTRY_EXTRA ExtraStuff;
    SIZE_T CommitSize;
    SIZE_T ReserveSize;
    HEAP_ENTRY BusyBlock;
} HEAP_VIRTUAL_ALLOC_ENTRY, *PHEAP_VIRTUAL_ALLOC_ENTRY;

typedef struct _HEAP_FREE_ENTRY {
    //
    // This field gives the size of the current block in allocation
    // granularity units.  (i.e. Size << HEAP_GRANULARITY_SHIFT
    // equals the size in bytes).
    //

    USHORT Size;

    //
    // This field gives the size of the previous block in allocation
    // granularity units. (i.e. PreviousSize << HEAP_GRANULARITY_SHIFT
    // equals the size of the previous block in bytes).
    //

    USHORT PreviousSize;

    //
    // This field contains the index into the segment that controls
    // the memory for this block.
    //

    UCHAR SegmentIndex;

    //
    // This field contains various flag bits associated with this block.
    // Currently for free blocks these can be:
    //
    //  0x02 - HEAP_ENTRY_EXTRA_PRESENT
    //  0x04 - HEAP_ENTRY_FILL_PATTERN
    //  0x10 - HEAP_ENTRY_LAST_ENTRY
    //

    UCHAR Flags;

    //
    // Two fields to encode the location of the bit in FreeListsInUse
    // array in HEAP_SEGMENT for blocks of this size.
    //

    UCHAR Index;
    UCHAR Mask;

    //
    // Free blocks use these two words for linking together free blocks
    // of the same size on a doubly linked list.
    //
    LIST_ENTRY FreeList;

#if defined(_WIN64) || defined(_XBOX)
    ULONGLONG Reserved1;
#endif

} HEAP_FREE_ENTRY, *PHEAP_FREE_ENTRY;



#define HEAP_GRANULARITY            ((LONG) sizeof( HEAP_ENTRY ))
#if defined(_WIN64) || defined(_XBOX)
#define HEAP_GRANULARITY_SHIFT      4   // Log2( HEAP_GRANULARITY )
#else
#define HEAP_GRANULARITY_SHIFT      3   // Log2( HEAP_GRANULARITY )
#endif

#define HEAP_MAXIMUM_BLOCK_SIZE     (USHORT)(((0x10000 << HEAP_GRANULARITY_SHIFT) - PAGE_SIZE) >> HEAP_GRANULARITY_SHIFT)

#define HEAP_MAXIMUM_FREELISTS 128
#define HEAP_MAXIMUM_SEGMENTS 64

#define HEAP_ENTRY_BUSY             0x01
#define HEAP_ENTRY_EXTRA_PRESENT    0x02
#define HEAP_ENTRY_FILL_PATTERN     0x04
#define HEAP_ENTRY_VIRTUAL_ALLOC    0x08
#define HEAP_ENTRY_LAST_ENTRY       0x10
#define HEAP_ENTRY_SETTABLE_FLAG1   0x20
#define HEAP_ENTRY_SETTABLE_FLAG2   0x40
#define HEAP_ENTRY_SETTABLE_FLAG3   0x80
#define HEAP_ENTRY_SETTABLE_FLAGS   0xE0

//
// HEAP_SEGMENT defines the structure used to describe a range of
// contiguous virtual memory that has been set aside for use by
// a heap.
//

typedef struct _HEAP_UNCOMMMTTED_RANGE {
    struct _HEAP_UNCOMMMTTED_RANGE *Next;
    ULONG_PTR Address;
    SIZE_T Size;
    ULONG filler;
} HEAP_UNCOMMMTTED_RANGE, *PHEAP_UNCOMMMTTED_RANGE;

typedef struct _HEAP_SEGMENT {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    struct _HEAP *Heap;
    SIZE_T LargestUnCommittedRange;

    PVOID BaseAddress;
    ULONG NumberOfPages;
    PHEAP_ENTRY FirstEntry;
    PHEAP_ENTRY LastValidEntry;

    ULONG NumberOfUnCommittedPages;
    ULONG NumberOfUnCommittedRanges;
    PHEAP_UNCOMMMTTED_RANGE UnCommittedRanges;
    USHORT AllocatorBackTraceIndex;
    USHORT Reserved;
    PHEAP_ENTRY LastEntryInSegment;
} HEAP_SEGMENT, *PHEAP_SEGMENT;

#define HEAP_SEGMENT_SIGNATURE  0xFFEEFFEE
#define HEAP_SEGMENT_USER_ALLOCATED (ULONG)0x00000001

//
// HEAP defines the header for a heap.
//

typedef struct _HEAP_LOCK {
    union {
        RTL_CRITICAL_SECTION CriticalSection;
    } Lock;
} HEAP_LOCK, *PHEAP_LOCK;

typedef struct _HEAP_UCR_SEGMENT {
    struct _HEAP_UCR_SEGMENT *Next;
    SIZE_T ReservedSize;
    SIZE_T CommittedSize;
    ULONG filler;
} HEAP_UCR_SEGMENT, *PHEAP_UCR_SEGMENT;


typedef struct _HEAP_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
    USHORT TagIndex;
    USHORT CreatorBackTraceIndex;
    WCHAR TagName[ 24 ];
} HEAP_TAG_ENTRY, *PHEAP_TAG_ENTRY;     // sizeof( HEAP_TAG_ENTRY ) must divide page size evenly

typedef struct _HEAP_PSEUDO_TAG_ENTRY {
    ULONG Allocs;
    ULONG Frees;
    SIZE_T Size;
} HEAP_PSEUDO_TAG_ENTRY, *PHEAP_PSEUDO_TAG_ENTRY;


typedef struct _HEAP {
    HEAP_ENTRY Entry;

    ULONG Signature;
    ULONG Flags;
    ULONG ForceFlags;
    ULONG VirtualMemoryThreshold;

    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;

    SIZE_T TotalFreeSize;
    SIZE_T MaximumAllocationSize;
    USHORT ProcessHeapsListIndex;
    USHORT HeaderValidateLength;
    PVOID HeaderValidateCopy;

    USHORT NextAvailableTagIndex;
    USHORT MaximumTagIndex;
    PHEAP_TAG_ENTRY TagEntries;
    PHEAP_UCR_SEGMENT UCRSegments;
    PHEAP_UNCOMMMTTED_RANGE UnusedUnCommittedRanges;

    //
    //  The following two fields control the alignment for each new heap entry
    //  allocation.  The round is added to each size and the mask is used to
    //  align it.  The round value includes the heap entry and any tail checking
    //  space
    //

    ULONG AlignRound;
    ULONG AlignMask;

    LIST_ENTRY VirtualAllocdBlocks;

    PHEAP_SEGMENT Segments[ HEAP_MAXIMUM_SEGMENTS ];

    union {
        ULONG FreeListsInUseUlong[ HEAP_MAXIMUM_FREELISTS / 32 ];
        UCHAR FreeListsInUseBytes[ HEAP_MAXIMUM_FREELISTS / 8 ];
    } u;

    USHORT FreeListsInUseTerminate;
    USHORT AllocatorBackTraceIndex;
    ULONG Reserved1[2];
    PHEAP_PSEUDO_TAG_ENTRY PseudoTagEntries;

    LIST_ENTRY FreeLists[ HEAP_MAXIMUM_FREELISTS ];

    PHEAP_LOCK LockVariable;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;

    //
    //  The following field is used to manage the heap lookaside list.  The
    //  pointer is used to locate the lookaside list array.  If it is null
    //  then the lookaside list is not active.
    //
    //  The lock count is used to denote if the heap is locked.  A zero value
    //  means the heap is not locked.  Each lock operation increments the
    //  heap count and each unlock decrements the counter
    //

    PVOID Lookaside;
    ULONG LookasideLockCount;

} HEAP, *PHEAP;

#define HEAP_SIGNATURE                      (ULONG)0xEEFFEEFF
#define HEAP_LOCK_USER_ALLOCATED            (ULONG)0x80000000
#define HEAP_VALIDATE_PARAMETERS_ENABLED    (ULONG)0x40000000
#define HEAP_VALIDATE_ALL_ENABLED           (ULONG)0x20000000
#define HEAP_SKIP_VALIDATION_CHECKS         (ULONG)0x10000000
#define HEAP_CAPTURE_STACK_BACKTRACES       (ULONG)0x08000000

#define CHECK_HEAP_TAIL_SIZE HEAP_GRANULARITY
#define CHECK_HEAP_TAIL_FILL 0xAB
#define FREE_HEAP_FILL 0xFEEEFEEE
#define ALLOC_HEAP_FILL 0xBAADF00D

#define HEAP_MAXIMUM_SMALL_TAG              0xFF
#define HEAP_SMALL_TAG_MASK                 (HEAP_MAXIMUM_SMALL_TAG << HEAP_TAG_SHIFT)
#define HEAP_NEED_EXTRA_FLAGS ((HEAP_TAG_MASK ^ HEAP_SMALL_TAG_MASK)  | \
                               HEAP_CAPTURE_STACK_BACKTRACES          | \
                               HEAP_SETTABLE_USER_VALUE                 \
                              )
#define HEAP_NUMBER_OF_PSEUDO_TAG           (HEAP_MAXIMUM_FREELISTS+1)


#if (HEAP_ENTRY_SETTABLE_FLAG1 ^    \
     HEAP_ENTRY_SETTABLE_FLAG2 ^    \
     HEAP_ENTRY_SETTABLE_FLAG3 ^    \
     HEAP_ENTRY_SETTABLE_FLAGS      \
    )
#error Invalid HEAP_ENTRY_SETTABLE_FLAGS
#endif

#if ((HEAP_ENTRY_BUSY ^             \
      HEAP_ENTRY_EXTRA_PRESENT ^    \
      HEAP_ENTRY_FILL_PATTERN ^     \
      HEAP_ENTRY_VIRTUAL_ALLOC ^    \
      HEAP_ENTRY_LAST_ENTRY ^       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     ) !=                           \
     (HEAP_ENTRY_BUSY |             \
      HEAP_ENTRY_EXTRA_PRESENT |    \
      HEAP_ENTRY_FILL_PATTERN |     \
      HEAP_ENTRY_VIRTUAL_ALLOC |    \
      HEAP_ENTRY_LAST_ENTRY |       \
      HEAP_ENTRY_SETTABLE_FLAGS     \
     )                              \
    )
#error Conflicting HEAP_ENTRY flags
#endif

#if ((HEAP_SETTABLE_USER_FLAGS >> 4) ^ HEAP_ENTRY_SETTABLE_FLAGS)
#error HEAP_SETTABLE_USER_FLAGS in ntrtl.h conflicts with HEAP_ENTRY_SETTABLE_FLAGS in heap.h
#endif

typedef struct _HEAP_STOP_ON_TAG {
    union {
        ULONG HeapAndTagIndex;
        struct {
            USHORT TagIndex;
            USHORT HeapIndex;
        };
    };
} HEAP_STOP_ON_TAG, *PHEAP_STOP_ON_TAG;

typedef struct _HEAP_STOP_ON_VALUES {
    SIZE_T AllocAddress;
    HEAP_STOP_ON_TAG AllocTag;
    SIZE_T ReAllocAddress;
    HEAP_STOP_ON_TAG ReAllocTag;
    SIZE_T FreeAddress;
    HEAP_STOP_ON_TAG FreeTag;
} HEAP_STOP_ON_VALUES, *PHEAP_STOP_ON_VALUES;

#ifndef NTOS_KERNEL_RUNTIME

extern BOOLEAN RtlpDebugHeap;
extern BOOLEAN RtlpDebugPageHeap;
extern ULONG RtlpDebugPageHeapGlobalFlags;
extern BOOLEAN RtlpValidateHeapHdrsEnable; // Set to TRUE if headers are being corrupted
extern BOOLEAN RtlpValidateHeapTagsEnable; // Set to TRUE if tag counts are off and you want to know why
extern PHEAP RtlpGlobalTagHeap;
extern HEAP_STOP_ON_VALUES RtlpHeapStopOn;

BOOLEAN
RtlpHeapIsLocked(
    IN PVOID HeapHandle
    );

#endif // NTOS_KERNEL_RUNTIME

#endif //  _RTL_HEAP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\hal.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    hal.h

Abstract:

    This header file defines the Hardware Architecture Layer (HAL) interfaces
    that are exported by a system vendor to the NT system.

Author:

    David N. Cutler (davec) 25-Apr-1991


Revision History:

--*/

#ifndef _HAL_
#define _HAL_

VOID
HalInitSystemPhase0(
    VOID
    );

VOID
HalInitSystemPhase0Quick(
    VOID
    );

VOID
HalInitSystemPhase1(
    VOID
    );

VOID
HalPulseHardwareMonitorPin(
    VOID
    );

//
// Non maskable interrupt routine.
//

VOID
HalHandleNMI(
    VOID
    );

//
// Profiling functions.
//

NTHALAPI
ULONG_PTR
HalSetProfileInterval(
    IN ULONG Interval
    );

NTHALAPI
VOID
HalStartProfileInterrupt(
    ULONG unused
    );

NTHALAPI
VOID
HalStopProfileInterrupt(
    ULONG unused
    );

//
// Timer and interrupt functions.
//

NTHALAPI
BOOLEAN
HalQueryRealTimeClock(
    OUT PTIME_FIELDS TimeFields
    );

NTHALAPI
BOOLEAN
HalSetRealTimeClock(
    IN PTIME_FIELDS TimeFields
    );

NTHALAPI
VOID
FASTCALL
HalRequestSoftwareInterrupt(
    KIRQL RequestIrql
    );

//
// CMOS validity functions.
//

BOOLEAN
HalIsCmosValid(
    VOID
    );

VOID
HalMarkCmosValid(
    VOID
    );

//
// Firmware interface functions.
//

DECLSPEC_NORETURN
NTHALAPI
VOID
HalReturnToFirmware(
    IN FIRMWARE_REENTRY Routine
    );

//
// Shutdown notification support.
//

typedef
VOID
(*PHAL_SHUTDOWN_NOTIFICATION)(
    IN struct _HAL_SHUTDOWN_REGISTRATION *ShutdownRegistration
    );

typedef struct _HAL_SHUTDOWN_REGISTRATION {
    PHAL_SHUTDOWN_NOTIFICATION NotificationRoutine;
    LONG Priority;
    LIST_ENTRY ListEntry;
} HAL_SHUTDOWN_REGISTRATION, *PHAL_SHUTDOWN_REGISTRATION;

NTHALAPI
VOID
HalRegisterShutdownNotification(
    IN PHAL_SHUTDOWN_REGISTRATION ShutdownRegistration,
    IN BOOLEAN Register
    );

NTHALAPI
BOOLEAN
HalIsResetOrShutdownPending(
    VOID
    );

VOID
HalMustCompletePacketsFinished(
    VOID
    );

NTHALAPI
VOID
HalInitiateShutdown(
    VOID
    );

//
// System interrupts functions.
//

NTHALAPI
VOID
HalDisableSystemInterrupt(
    IN ULONG BusInterruptLevel
    );

NTHALAPI
VOID
HalEnableSystemInterrupt(
    IN ULONG BusInterruptLevel,
    IN KINTERRUPT_MODE InterruptMode
    );

// begin_ntddk
//
// I/O driver configuration functions.
//

NTHALAPI
VOID
HalReadWritePCISpace(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN ULONG RegisterNumber,
    IN PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN WritePCISpace
    );

#define HalReadPCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, FALSE)

#define HalWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length) \
    HalReadWritePCISpace(BusNumber, SlotNumber, RegisterNumber, Buffer, Length, TRUE)

NTHALAPI
ULONG
HalGetInterruptVector(
    IN ULONG BusInterruptLevel,
    OUT PKIRQL Irql
    );

#include <pshpack1.h>

typedef struct _PCI_DEVICE_ADDRESS {
    UCHAR     Type;  //CmResourceType
    UCHAR     Valid;
    UCHAR     Reserved[2];

    union {

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Port;

        struct {
            PVOID TranslatedAddress;
            ULONG Length;
        } Memory;

    } u;

} PCI_DEVICE_ADDRESS, *PPCI_DEVICE_ADDRESS;

typedef struct _PCI_DEVICE_DESCRIPTOR {
    ULONG     Bus;
    ULONG     Slot;
    USHORT    VendorID;
    USHORT    DeviceID;

    UCHAR     BaseClass;
    UCHAR     SubClass;
    UCHAR     ProgIf;
    UCHAR     Reserved[1];

    struct {

        PCI_DEVICE_ADDRESS Address[1];

        struct {
            ULONG Vector;
            ULONG Affinity;
            KIRQL Irql;         // KIRQL is uchar!

        } Interrupt;

    } ResourceData;

} PCI_DEVICE_DESCRIPTOR, *PPCI_DEVICE_DESCRIPTOR;

#include <poppack.h>

// end_ntddk

//
// The following function prototypes are for HAL routines with a prefix of Ke.
//
// begin_ntddk begin_wdm
//
// Performance counter function.
//

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceCounter(
    VOID
    );

NTHALAPI
LARGE_INTEGER
KeQueryPerformanceFrequency(
    VOID
    );

//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor(
    IN ULONG MicroSeconds
    );

// end_wdm

DECLSPEC_NORETURN
NTHALAPI
VOID
HalHaltSystem(
    VOID
    );

// end_ntddk

//
// SMBus functions.
//

NTHALAPI
NTSTATUS
HalReadSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN ReadWordValue,
    OUT ULONG *DataValue
    );

#define HalReadSMBusByte(SlaveAddress, CommandCode, DataValue) \
    HalReadSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalReadSMBusWord(SlaveAddress, CommandCode, DataValue) \
    HalReadSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

NTHALAPI
NTSTATUS
HalWriteSMBusValue(
    IN UCHAR SlaveAddress,
    IN UCHAR CommandCode,
    IN BOOLEAN WriteWordValue,
    IN ULONG DataValue
    );

#define HalWriteSMBusByte(SlaveAddress, CommandCode, DataValue) \
    HalWriteSMBusValue(SlaveAddress, CommandCode, FALSE, DataValue)

#define HalWriteSMBusWord(SlaveAddress, CommandCode, DataValue) \
    HalWriteSMBusValue(SlaveAddress, CommandCode, TRUE, DataValue)

VOID
HalWriteSMCLEDStates(
    IN ULONG LEDStates
    );

NTHALAPI
NTSTATUS
HalWriteSMCScratchRegister(
    IN ULONG ScratchRegister
    );

//
// Super I/O controller functions.
//

BOOLEAN
HalInitializeSuperIo(
    VOID
    );

//
// DVD tray functions.
//

NTHALAPI
NTSTATUS
HalReadSMCTrayState(
    OUT PULONG TrayState,
    OUT PULONG TrayStateChangeCount OPTIONAL
    );

BOOLEAN
HalEnableTrayEjectRequiresReboot(
    IN BOOLEAN EnterNonSecureMode
    );

NTHALAPI
VOID
HalEnableSecureTrayEject(
    VOID
    );

//
// AV pack functions.
//

VOID
HalBlockIfNoAVPack(
    VOID
    );

#if !defined(_NTSYSTEM_)
extern PULONG HalDiskCachePartitionCount;
extern PSTRING HalDiskModelNumber;
extern PSTRING HalDiskSerialNumber;
extern PULONG HalBootSMCVideoMode;
#else
extern ULONG HalDiskCachePartitionCount;
extern STRING HalDiskModelNumber;
extern STRING HalDiskSerialNumber;
extern ULONG HalBootSMCVideoMode;
#endif

#endif // _HAL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\fscache.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fscache.h

Abstract:

    This module contains the public data structures and procedure prototypes
    for the file system cache.

--*/

#ifndef _FSCACHE_
#define _FSCACHE_

#include <pshpack4.h>

//
// Structure to contain the per device extension data required by the file
// system cache module.
//

typedef struct _FSCACHE_EXTENSION {
    PDEVICE_OBJECT TargetDeviceObject;
    LARGE_INTEGER PartitionLength;
    ULONG SectorSize;
} FSCACHE_EXTENSION, *PFSCACHE_EXTENSION;

//
// Structure that describes a cache entry (exposed in this header for the kernel
// debugger).
//

typedef struct _FSCACHE_ELEMENT {
    ULONG BlockNumber;
    PFSCACHE_EXTENSION CacheExtension;
    union {
        struct {
            ULONG UsageCount : 8;
            ULONG ReadInProgress : 1;
            ULONG ReadWaiters : 1;
            ULONG DeletePending : 1;
            ULONG Reserved : 1;
            ULONG CacheBufferBits : 20;
        };
        PCHAR CacheBuffer;
    };
    LIST_ENTRY ListEntry;
} FSCACHE_ELEMENT, *PFSCACHE_ELEMENT;

//
// Define the maximum number of pages that can be allocated to the file system
// cache.
//

#define FSCACHE_MAXIMUM_NUMBER_OF_CACHE_PAGES   2048

//
// Define the number of page table entries that will be used for FscWriteFFs.
//

#define FSCACHE_NUMBER_OF_WRITE_FF_PTES         8

//
// Prototypes.
//

NTKERNELAPI
NTSTATUS
FscSetCacheSize(
    IN PFN_COUNT NumberOfCachePages
    );

NTKERNELAPI
PFN_COUNT
FscGetCacheSize(
    VOID
    );

NTSTATUS
FscMapBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN BOOLEAN MapAsReadWrite,
    OUT PVOID *CacheBuffer
    );

NTSTATUS
FscMapEmptyBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    OUT PVOID *CacheBuffer
    );

NTSTATUS
FscWriteBuffer(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength,
    IN PVOID CacheBuffer
    );

VOID
FscDiscardBuffer(
    PVOID CacheBuffer
    );

VOID
FscUnmapBuffer(
    PVOID CacheBuffer
    );

NTSTATUS
FscWriteFFs(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG WriteLength
    );

BOOLEAN
FscTestForFullyCachedIo(
    IN PIRP Irp,
    IN ULONG ByteOffsetLowPart,
    IN ULONG IoLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    );

NTSTATUS
FscCachedRead(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN PIRP Irp,
    IN ULONGLONG ByteOffset,
    IN ULONG ReadLength,
    IN BOOLEAN NonCachedEndOfFileTransfer
    );

VOID
FscInvalidateDevice(
    IN PFSCACHE_EXTENSION CacheExtension
    );

VOID
FscInvalidateByteRange(
    IN PFSCACHE_EXTENSION CacheExtension,
    IN ULONGLONG ByteOffset,
    IN ULONG Length
    );

NTKERNELAPI
VOID
FscInvalidateIdleBlocks(
    VOID
    );

#include <poppack.h>

#endif  // FSCACHE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\hal386.inc ===
;
;  Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00000H

;
;  Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 00001H
ATTEMPTED_FPU_USE_FROM_DPC equ 000F0H
ATTEMPTED_SWITCH_FROM_DPC equ 000B8H
DATA_BUS_ERROR equ 0002EH
DATA_COHERENCY_EXCEPTION equ 00055H
HAL1_INITIALIZATION_FAILED equ 00061H
INSTRUCTION_BUS_ERROR equ 0002FH
INSTRUCTION_COHERENCY_EXCEPTION equ 00056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 0003DH
INTERRUPT_UNWIND_ATTEMPTED equ 0003CH
INVALID_AFFINITY_SET equ 00003H
INVALID_DATA_ACCESS_TRAP equ 00004H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 0004AH
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
KMODE_EXCEPTION_NOT_HANDLED equ 0001EH
NMI_HARDWARE_FAILURE equ 00080H
NO_USER_MODE_CONTEXT equ 0000EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 00049H
PANIC_STACK_SWITCH equ 0002BH
SPIN_LOCK_INIT_FAILURE equ 00081H
SYSTEM_EXIT_OWNED_MUTEX equ 00039H
SYSTEM_SERVICE_EXCEPTION equ 0003BH
SYSTEM_UNWIND_PREVIOUS_USER equ 0003AH
TRAP_CAUSE_UNKNOWN equ 00012H
UNEXPECTED_KERNEL_MODE_TRAP equ 0007FH

;
;  Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 00001H

;
;  Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 00001H
EXCEPTION_UNWINDING equ 00002H
EXCEPTION_EXIT_UNWIND equ 00004H
EXCEPTION_STACK_INVALID equ 00008H
EXCEPTION_NESTED_CALL equ 00010H
EXCEPTION_TARGET_UNWIND equ 00020H
EXCEPTION_COLLIDED_UNWIND equ 00040H
EXCEPTION_UNWIND equ 00066H
EXCEPTION_EXECUTE_HANDLER equ 00001H
EXCEPTION_CONTINUE_SEARCH equ 00000H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH
EXCEPTION_CHAIN_END equ 0FFFFFFFFH

ExceptionContinueExecution equ 00000H
ExceptionContinueSearch equ 00001H
ExceptionNestedException equ 00002H
ExceptionCollidedUnwind equ 00003H

ErExceptionCode equ 00000H
ErExceptionFlags equ 00004H
ErExceptionRecord equ 00008H
ErExceptionAddress equ 0000CH
ErNumberParameters equ 00010H
ErExceptionInformation equ 00014H
ExceptionRecordLength equ 00050H

;
;  Interrupt Priority Request Level Definitions
;

PASSIVE_LEVEL equ 00000H
APC_LEVEL equ 00001H
DISPATCH_LEVEL equ 00002H
SCI_LEVEL equ 0001BH
SMBUS_LEVEL equ 0000FH
CLOCK_LEVEL equ 0001CH
IPI_LEVEL equ 0001DH
POWER_LEVEL equ 0001EH
PROFILE_LEVEL equ 0001AH
HIGH_LEVEL equ 0001FH
SYNCH_LEVEL equ 0001CH

;
;  Large Integer Structure Offset Definitions
;

LiLowPart equ 00000H
LiHighPart equ 00004H

;
;  List Entry Structure Offset Definitions
;

LsFlink equ 00000H
LsBlink equ 00004H

;
;  String Structure Offset Definitions
;

StrLength equ 00000H
StrMaximumLength equ 00002H
StrBuffer equ 00004H

;
;  System Time Structure Offset Definitions
;

StLowTime equ 00000H
StHigh1Time equ 00004H
StHigh2Time equ 00008H

;
;  Time Structure Offset Definitions
;

TmLowTime equ 00000H
TmHighTime equ 00004H

;
;  DPC object Structure Offset Definitions
;

DpType equ 00000H
DpInserted equ 00002H
DpDpcListEntry equ 00004H
DpDeferredRoutine equ 0000CH
DpDeferredContext equ 00010H
DpSystemArgument1 equ 00014H
DpSystemArgument2 equ 00018H
DpcObjectLength equ 0001CH

;
;  Processor Control Registers Structure Offset Definitions
;

PCR equ dword ptr [_KiPCR]
PCRB equ byte ptr [_KiPCR]
PcExceptionList equ 00000H
PcStackBase equ 00004H
PcStackLimit equ 00008H
PcSelfPcr equ 0001CH
PcPrcb equ 00020H
PcTeb equ 00018H
PcIrql equ 00024H
PcPrcbData equ 00028H

;
;  Tss Structure Offset Definitions
;

TssSs0 equ 00008H
TssEsp0 equ 00004H
TssEip equ 00020H
TssEFlags equ 00024H
TssEsp equ 00038H
TssCR3 equ 0001CH
TssCs equ 0004CH
TssSs equ 00050H
TssDs equ 00054H
TssEs equ 00048H
TssFs equ 00058H
TssGs equ 0005CH
TssIoMapBase equ 00066H
TssIoMaps equ 00068H
TssLength equ 020ACH

;
;  Gdt Descriptor Offset Definitions
;

KGDT_R0_CODE equ 00008H
KGDT_R0_DATA equ 00010H
KGDT_R0_PCR equ 00020H
KGDT_TSS equ 00018H

;
;  GdtEntry Offset Definitions
;

KgdtBaseLow equ 00002H
KgdtBaseMid equ 00004H
KgdtBaseHi equ 00007H
KgdtFlags1 equ 00005H
KgdtLimitHi equ 00006H
KgdtLimitLow equ 00000H
KgdtEntryLength equ 00008H


;
;  IdtEntry Offset Definitions
;

KidtOffset equ 00000H
KidtSelector equ 00002H
KidtAccess equ 00004H
KidtExtendedOffset equ 00006H
KidtEntryLength equ 00008H


;
;  Processor Block Structure Offset Definitions
;

PbCurrentThread equ 00000H
PbNextThread equ 00004H
PbIdleThread equ 00008H
PbDebugHaltThread equ 00254H
PbDebugMonitorData equ 00250H
PbDebugDoubleFault equ 00258H

;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0000AH
TfMinute equ 00008H
TfHour equ 00006H
TfWeekday equ 0000EH
TfDay equ 00004H
TfMonth equ 00002H
TfYear equ 00000H
TfMilliseconds equ 0000CH


;
;  constants for system irql and IDT vector conversion
;

MAXIMUM_IDTVECTOR equ 000FFH
MAXIMUM_PRIMARY_VECTOR equ 000FFH
PRIMARY_VECTOR_BASE equ 00030H

;
;  Flags in the CR0 register
;

CR0_PG equ 080000000H
CR0_ET equ 00010H
CR0_TS equ 00008H
CR0_EM equ 00004H
CR0_MP equ 00002H
CR0_PE equ 00001H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 00020H

;
;  Flags in the CR4 register
;

CR4_VME equ 00001H
CR4_PVI equ 00002H
CR4_TSD equ 00004H
CR4_DE equ 00008H
CR4_PSE equ 00010H
CR4_PAE equ 00020H
CR4_MCE equ 00040H
CR4_PGE equ 00080H
CR4_FXSR equ 00200H
CR4_XMMEXCPT equ 00400H

;
;  Miscellaneous Definitions
;

MAXIMUM_PROCESSORS equ 00020H
INITIAL_STALL_COUNT equ 00064H
IRQL_NOT_GREATER_OR_EQUAL equ 00009H
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
MUTEX_ALREADY_OWNED equ 000BFH
THREAD_NOT_MUTEX_OWNER equ 00011H

;
;  Trap Frame Offset Definitions and Length
;

TsExceptionList equ 00024H
TsEdi equ 00028H
TsEsi equ 0002CH
TsEbp equ 00034H
TsEbx equ 00030H
TsEdx equ 00018H
TsEcx equ 0001CH
TsEax equ 00020H
TsErrCode equ 00038H
TsEip equ 0003CH
TsSegCs equ 00040H
TsEflags equ 00044H
TsHardwareEsp equ 00048H
TsHardwareSegSs equ 0004CH
TsTempSegCs equ 00010H
TsTempEsp equ 00014H
TsDbgEbp equ 00000H
TsDbgEip equ 00004H
TsDbgArgMark equ 00008H
TsDbgArgPointer equ 0000CH
KTRAP_FRAME_LENGTH equ 00050H
KTRAP_FRAME_ALIGN equ 00004H
FRAME_EDITED equ 0FFF8H
EFLAGS_ALIGN_CHECK equ 040000H
EFLAGS_V86_MASK equ 020000H
EFLAGS_INTERRUPT_MASK equ 00200H
EFLAGS_VIF equ 080000H
EFLAGS_VIP equ 0100000H
EFLAGS_USER_SANITIZE equ 03E0DD7H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010007H
CONTEXT_DEBUG_REGISTERS equ 010010H
CONTEXT_CONTROL equ 010001H
CONTEXT_FLOATING_POINT equ 010008H
CONTEXT_INTEGER equ 010002H
CONTEXT_SEGMENTS equ 010004H

CsContextFlags equ 00000H
CsFloatSave equ 00004H
CsEdi equ 00208H
CsEsi equ 0020CH
CsEbp equ 00220H
CsEbx equ 00210H
CsEdx equ 00214H
CsEcx equ 00218H
CsEax equ 0021CH
CsEip equ 00224H
CsSegCs equ 00228H
CsEflags equ 0022CH
CsEsp equ 00230H
CsSegSs equ 00234H
ContextFrameLength equ 00240H
DR6_LEGAL equ 0E00FH
DR7_LEGAL equ 0FFFF0155H
DR7_ACTIVE equ 00055H
ErrHandler equ 00004H
ErrNext equ 00000H

;
;  Floating save area field offset definitions
;

FxControlWord equ 00000H
FxStatusWord equ 00002H
FxErrorOffset equ 00008H
FxErrorSelector equ 0000CH
FxDataOffset equ 00010H
FxDataSelector equ 00014H
FxMXCsr equ 00018H
FpCr0NpxState equ 00200H

NPX_FRAME_LENGTH equ 00210H

;
;  Processor State Frame Offset Definitions
;

PsContextFrame equ 00000H
PsSpecialRegisters equ 00238H
SrCr0 equ 00000H
SrCr2 equ 00004H
SrCr3 equ 00008H
SrCr4 equ 0000CH
SrKernelDr0 equ 00010H
SrKernelDr1 equ 00014H
SrKernelDr2 equ 00018H
SrKernelDr3 equ 0001CH
SrKernelDr6 equ 00020H
SrKernelDr7 equ 00024H
SrGdtr equ 0002AH
SrIdtr equ 00032H
SrTr equ 00038H
SrLdtr equ 0003AH
PsNT5ContextFrame equ 00000H
PsNT5SpecialRegisters equ 002CCH
SrNT5Cr0 equ 00000H
SrNT5Cr2 equ 00004H
SrNT5Cr3 equ 00008H
SrNT5Cr4 equ 0000CH
SrNT5KernelDr0 equ 00010H
SrNT5KernelDr1 equ 00014H
SrNT5KernelDr2 equ 00018H
SrNT5KernelDr3 equ 0001CH
SrNT5KernelDr6 equ 00020H
SrNT5KernelDr7 equ 00024H
SrNT5Gdtr equ 0002AH
SrNT5Idtr equ 00032H
SrNT5Tr equ 00038H
SrNT5Ldtr equ 0003AH

PAGE_SIZE equ 01000H

CLOCK_ROLLOVER_COUNT equ 00465H
CLOCK_TIME_INCREMENT equ 02710H

PAGE_DIRECTORY_PHYSICAL_ADDRESS equ 0F000H

ROM_SHADOW_PHYSICAL_ADDRESS equ 07F00000H
ROM_SHADOW_SIZE equ 0100000H

XDISK_UNPARTITIONED_SECTORS equ 00400H

MzXdataSectionHeader equ 080010028H
XdshSizeOfUninitializedData equ 00000H
XdshSizeOfInitializedData equ 00004H
XdshPointerToRawData equ 00008H
XdshVirtualAddress equ 0000CH

MudbProcessor equ 0000CH
MudbUpdateData equ 00030H
MudbStructureLength equ 00800H
XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0 equ 08000H
XPCICFG_LPCBRIDGE_IO_REGISTER_LENGTH_0 equ 00100H
XPCICFG_SMBUS_IO_REGISTER_BASE_1 equ 0C000H
XPCICFG_SMBUS_IO_REGISTER_LENGTH_1 equ 00010H
XPCICFG_GPU_MEMORY_REGISTER_BASE_0 equ 0FD000000H
XPCICFG_GPU_MEMORY_REGISTER_LENGTH_0 equ 01000000H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\init.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Header file for the INIT subcomponent of NTOS

Author:

    Steve Wood (stevewo) 31-Mar-1989

Revision History:

--*/

#ifndef _INIT_
#define _INIT_

//
// Define xbox kernel version structure.
//

typedef struct _XBOX_KRNL_VERSION {
    USHORT Major;
    USHORT Minor;
    USHORT Build;
    USHORT Qfe;
} XBOX_KRNL_VERSION, *PXBOX_KRNL_VERSION;

#if !defined(_NTSYSTEM_)
extern const PXBOX_KRNL_VERSION XboxKrnlVersion;
#else
extern const XBOX_KRNL_VERSION XboxKrnlVersion;
#endif

//
// Information about the current hardware that the system is running on
//
typedef struct _XBOX_HARDWARE_INFO {
    ULONG Flags;
    UCHAR GpuRevision;
    UCHAR McpRevision;
    UCHAR reserved[2];
} XBOX_HARDWARE_INFO;

#if !defined(_NTSYSTEM_)
extern const XBOX_HARDWARE_INFO* XboxHardwareInfo;
#else
extern XBOX_HARDWARE_INFO XboxHardwareInfo;
#endif

//
//  Define XboxHardwareFlags - a list of
//  flags indicating hardware differences
//  the title libraries must know about.
//
#define XBOX_HW_FLAG_INTERNAL_USB_HUB   0x00000001
#define XBOX_HW_FLAG_DEVKIT_KERNEL      0x00000002
#define XBOX_480P_MACROVISION_ENABLED   0x00000004
#define XBOX_HW_FLAG_ARCADE             0x00000008

//
// Boot flags
//
extern ULONG XboxBootFlags;

#define XBOX_BOOTFLAG_SHADOW            0x00000001
#define XBOX_BOOTFLAG_HDBOOT            0x00000002
#define XBOX_BOOTFLAG_CDBOOT            0x00000004
#define XBOX_BOOTFLAG_NONSECUREMODE     0x00000008
#define XBOX_BOOTFLAG_SHORTANIMATION    0x00000010
#define XBOX_BOOTFLAG_DISPLAYFATALERROR 0x00000020
#define XBOX_BOOTFLAG_TRAYEJECT         0x00000040
#define XBOX_BOOTFLAG_DASHBOARDBOOT     0x00000080

//
// Define the fatal error codes.  The bitmap of UEMs stored
// in EEPROM starts at HDD_NOT_LOCKED being at bit zero.  
// CORE_DIGITAL and BAD_RAM are values used by the SMC.
//

#define FATAL_ERROR_NONE                0x00
#define FATAL_ERROR_CORE_DIGITAL        0x01
#define FATAL_ERROR_BAD_EEPROM          0x02
#define FATAL_ERROR_UNUSED1             0x03    
#define FATAL_ERROR_BAD_RAM             0x04
#define FATAL_ERROR_HDD_NOT_LOCKED      0x05
#define FATAL_ERROR_HDD_CANNOT_UNLOCK   0x06
#define FATAL_ERROR_HDD_TIMEOUT         0x07
#define FATAL_ERROR_HDD_NOT_FOUND       0x08
#define FATAL_ERROR_HDD_BAD_CONFIG      0x09
#define FATAL_ERROR_DVD_TIMEOUT         0x0A
#define FATAL_ERROR_DVD_NOT_FOUND       0x0B
#define FATAL_ERROR_DVD_BAD_CONFIG      0x0C
#define FATAL_ERROR_XBE_DASH_GENERIC    0x0D
#define FATAL_ERROR_XBE_DASH_ERROR      0x0E
#define FATAL_ERROR_UNUSED2             0x0F
#define FATAL_ERROR_XBE_DASH_SETTINGS   0x10
#define FATAL_ERROR_UNUSED3             0x11
#define FATAL_ERROR_UNUSED4             0x12
#define FATAL_ERROR_UNUSED5             0x13
#define FATAL_ERROR_XBE_DASH_X2_PASS    0x14
#define FATAL_ERROR_REBOOT_ROUTINE      0x15
#define FATAL_ERROR_RESERVED            0xFF


VOID
KiSystemStartup(
    VOID
    );

VOID
Phase1Initialization(
    IN PVOID Context
    );

DECLSPEC_NORETURN
VOID 
ExDisplayFatalError(
    IN ULONG ErrorCode
    );

//
// Various Xbox encryption keys and game region
//
#define XBOX_KEY_LENGTH 16

typedef UCHAR XBOX_KEY_DATA[XBOX_KEY_LENGTH];
extern XBOX_KEY_DATA XboxCERTKey;
extern ULONG XboxGameRegion;

#if !defined(_NTSYSTEM_)
extern const XBOX_KEY_DATA* XboxEEPROMKey;
extern const XBOX_KEY_DATA* XboxHDKey;
extern const XBOX_KEY_DATA* XboxLANKey;
extern const XBOX_KEY_DATA* XboxSignatureKey;
extern const XBOX_KEY_DATA* XboxAlternateSignatureKeys[];
#else
extern XBOX_KEY_DATA XboxEEPROMKey;
extern XBOX_KEY_DATA XboxHDKey;
extern XBOX_KEY_DATA XboxLANKey;
extern XBOX_KEY_DATA XboxSignatureKey;
extern XBOX_KEY_DATA XboxAlternateSignatureKeys[];
#endif

#endif // _INIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\idexchan.h ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    idexchan.h

Abstract:

    This module contains the public definition of the IDEX channel object.

--*/

#ifndef _IDEXCHAN_
#define _IDEXCHAN_

#include <pshpack4.h>

//
// Function prototype for interrupt service routines.
//

typedef
VOID
(*PIDE_INTERRUPT_ROUTINE)(
    VOID
    );

//
// Function prototype for channel post interrupt or timeout DPC routines.
//

typedef
VOID
(*PIDE_FINISHIO_ROUTINE)(
    VOID
    );

//
// Function prototype for routines to poll if a device reset has completed.
//

typedef
BOOLEAN
(*PIDE_POLL_RESET_COMPLETE_ROUTINE)(
    VOID
    );

//
// Function prototype for timeout expired routines.
//

typedef
VOID
(*PIDE_TIMEOUT_EXPIRED_ROUTINE)(
    VOID
    );

//
// Function prototype for reset device routines.
//

typedef
VOID
(*PIDE_RESET_DEVICE_ROUTINE)(
    VOID
    );

//
// Function prototype for starting or queueing the supplied I/O request packet.
//

typedef
VOID
(*PIDE_START_PACKET_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//
// Function prototype for starting the next queued I/O request packet.
//

typedef
VOID
(*PIDE_START_NEXT_PACKET_ROUTINE)(
    VOID
    );

//
// Channel object.
//

typedef struct _IDE_CHANNEL_OBJECT {
    PIDE_INTERRUPT_ROUTINE InterruptRoutine;
    PIDE_FINISHIO_ROUTINE FinishIoRoutine;
    PIDE_POLL_RESET_COMPLETE_ROUTINE PollResetCompleteRoutine;
    PIDE_TIMEOUT_EXPIRED_ROUTINE TimeoutExpiredRoutine;
    PIDE_START_PACKET_ROUTINE StartPacketRoutine;
    PIDE_START_NEXT_PACKET_ROUTINE StartNextPacketRoutine;
    KIRQL InterruptIrql;
    BOOLEAN ExpectingBusMasterInterrupt;
    BOOLEAN StartPacketBusy;
    BOOLEAN StartPacketRequested;
    UCHAR Timeout;
    UCHAR IoRetries;
    UCHAR MaximumIoRetries;
    PIRP CurrentIrp;
    KDEVICE_QUEUE DeviceQueue;
    ULONG PhysicalRegionDescriptorTablePhysical;
    KDPC TimerDpc;
    KDPC FinishDpc;
    KTIMER Timer;
    KINTERRUPT InterruptObject;
} IDE_CHANNEL_OBJECT, *PIDE_CHANNEL_OBJECT;

//
// External symbols.
//

#if !defined(_NTSYSTEM_)
extern IDE_CHANNEL_OBJECT *IdexChannelObject;
#else
extern IDE_CHANNEL_OBJECT IdexChannelObject;
#endif

#include <poppack.h>

#endif  // IDEXCHAN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\io.h ===
/*++ BUILD Version: 0013    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    io.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 12-Apr-1989


Revision History:


--*/

#ifndef _IO_
#define _IO_

// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis
//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009

//
// Define the major function codes for IRPs.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CLOSE                    0x01
#define IRP_MJ_READ                     0x02
#define IRP_MJ_WRITE                    0x03
#define IRP_MJ_QUERY_INFORMATION        0x04
#define IRP_MJ_SET_INFORMATION          0x05
#define IRP_MJ_FLUSH_BUFFERS            0x06
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x07
#define IRP_MJ_DIRECTORY_CONTROL        0x08
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x09
#define IRP_MJ_DEVICE_CONTROL           0x0a
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0b
#define IRP_MJ_SHUTDOWN                 0x0c
#define IRP_MJ_CLEANUP                  0x0d
#define IRP_MJ_MAXIMUM_FUNCTION         0x0d

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

// end_ntndis

//
// Define option flags for IoCreateFile.  Note that these values must be
// exactly the same as the SL_... flags for a create function.  Note also
// that there are flags that may be passed to IoCreateFile that are not
// placed in the stack location for the create IRP.  These flags start in
// the next byte.
//

#define IO_FORCE_ACCESS_CHECK           0x0001
#define IO_OPEN_TARGET_DIRECTORY        0x0004
// end_ntddk end_wdm end_nthal

//
// Flags not passed to driver
//

// begin_ntddk begin_wdm
#define IO_NO_PARAMETER_CHECKING        0x0100

//
// Define Information fields for whether or not a REPARSE or a REMOUNT has
// occurred in the file system.
//

#define IO_REPARSE                      0x0
#define IO_REMOUNT                      0x1

// end_ntddk end_wdm

#define IO_CHECK_CREATE_PARAMETERS      0x0200

// end_ntifs

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define the structures used by the I/O system
//

//
// Define empty typedefs for the _IRP, _DEVICE_OBJECT, and _DRIVER_OBJECT
// structures so they may be referenced by function types before they are
// actually defined.
//
struct _DEVICE_DESCRIPTION;
struct _DEVICE_OBJECT;
struct _DMA_ADAPTER;
struct _DRIVER_OBJECT;
struct _DRIVE_LAYOUT_INFORMATION;
struct _DISK_PARTITION;
struct _FILE_OBJECT;
struct _IRP;
struct _SCSI_REQUEST_BLOCK;

// end_wdm

// begin_wdm begin_ntndis
//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver device object deletion routine type.
//

typedef
VOID
(*PDRIVER_DELETEDEVICE) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define driver dismount volume routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISMOUNTVOLUME) (
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
// Define Device Object (DO) flags
//
// end_wdm end_ntddk end_nthal end_ntifs

#define DO_RAW_MOUNT_ONLY               0x00000001
#define DO_EXCLUSIVE                    0x00000002      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000004      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000008      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000010      // ntddk nthal ntifs wdm
#define DO_SCATTER_GATHER_IO            0x00000040

//
// Define Device Object StartIo flags
//

#define DO_STARTIO_BUSY                 0x01
#define DO_STARTIO_REQUESTED            0x02
#define DO_STARTIO_REQUESTED_BYKEY      0x04

// begin_wdm begin_ntddk begin_nthal begin_ntifs
//
// Device Object structure definition
//

typedef struct _DEVICE_OBJECT {
    CSHORT Type;
    USHORT Size;
    LONG ReferenceCount;
    struct _DRIVER_OBJECT *DriverObject;
    struct _DEVICE_OBJECT *MountedOrSelfDevice;
    struct _IRP *CurrentIrp;
    ULONG Flags;                                // See above:  DO_...
    PVOID DeviceExtension;
    UCHAR DeviceType;
    UCHAR StartIoFlags;
    CCHAR StackSize;
    BOOLEAN DeletePending;
    ULONG SectorSize;
    ULONG AlignmentRequirement;
    KDEVICE_QUEUE DeviceQueue;
    KEVENT DeviceLock;
    ULONG StartIoKey;
} DEVICE_OBJECT;
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; // ntndis

typedef struct _DRIVER_OBJECT {

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PDRIVER_STARTIO DriverStartIo;
    PDRIVER_DELETEDEVICE DriverDeleteDevice;
    PDRIVER_DISMOUNTVOLUME DriverDismountVolume;
    PDRIVER_DISPATCH MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; // ntndis

//
// Define the format of a completion message.
//

typedef struct _IO_COMPLETION_CONTEXT {
    PVOID Port;
    PVOID Key;
} IO_COMPLETION_CONTEXT, *PIO_COMPLETION_CONTEXT;

//
// Define File Object (FO) flags
//

#define FO_SYNCHRONOUS_IO               0x00000001
#define FO_ALERTABLE_IO                 0x00000002
#define FO_NO_INTERMEDIATE_BUFFERING    0x00000004
#define FO_SEQUENTIAL_ONLY              0x00000008
#define FO_CLEANUP_COMPLETE             0x00000010
#define FO_HANDLE_CREATED               0x00000020
#define FO_RANDOM_ACCESS                0x00000040

#include "pshpack4.h"

typedef struct _FILE_OBJECT {
    CSHORT Type;
    BOOLEAN DeletePending : 1;
    BOOLEAN ReadAccess : 1;
    BOOLEAN WriteAccess : 1;
    BOOLEAN DeleteAccess : 1;
    BOOLEAN SharedRead : 1;
    BOOLEAN SharedWrite : 1;
    BOOLEAN SharedDelete : 1;
    BOOLEAN Reserved : 1;
    UCHAR Flags;
    PDEVICE_OBJECT DeviceObject;
    PVOID FsContext;
    PVOID FsContext2;
    NTSTATUS FinalStatus;
    LARGE_INTEGER CurrentByteOffset;
    struct _FILE_OBJECT *RelatedFileObject;
    PIO_COMPLETION_CONTEXT CompletionContext;
    LONG LockCount;
    KEVENT Lock;
    KEVENT Event;
} FILE_OBJECT;
typedef struct _FILE_OBJECT *PFILE_OBJECT; // ntndis

#include "poppack.h"

//
// Define I/O Request Packet (IRP) flags
//

#define IRP_NOCACHE                     0x00000001
#define IRP_MOUNT_COMPLETION            0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_CREATE_OPERATION            0x00000008
#define IRP_READ_OPERATION              0x00000010
#define IRP_WRITE_OPERATION             0x00000020
#define IRP_CLOSE_OPERATION             0x00000040
// end_wdm

#define IRP_DEFER_IO_COMPLETION         0x00000080
#define IRP_OB_QUERY_NAME               0x00000100
#define IRP_UNLOCK_USER_BUFFER          0x00000200
#define IRP_SCATTER_GATHER_OPERATION    0x00000400
#define IRP_UNMAP_SEGMENT_ARRAY         0x00000800
#define IRP_NO_CANCELIO                 0x00001000

// begin_wdm
//
// I/O Request Packet (IRP) definition
//

typedef struct _IRP {
    CSHORT Type;
    USHORT Size;

    //
    // Define the common fields used to control the IRP.
    //

    //
    // Flags word - used to remember various flags.
    //

    ULONG Flags;

    //
    // Thread list entry - allows queueing the IRP to the thread pending I/O
    // request packet list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // I/O status - final status of operation.
    //

    IO_STATUS_BLOCK IoStatus;

    //
    // Stack state information.
    //

    CHAR StackCount;
    CHAR CurrentLocation;

    //
    // Pending returned - TRUE if pending was initially returned as the
    // status for this packet.
    //

    BOOLEAN PendingReturned;

    //
    // Cancel - packet has been canceled.
    //

    BOOLEAN Cancel;

    //
    // User parameters.
    //

    PIO_STATUS_BLOCK UserIosb;
    PKEVENT UserEvent;
    union {
        struct {
            PIO_APC_ROUTINE UserApcRoutine;
            PVOID UserApcContext;
        } AsynchronousParameters;
        LARGE_INTEGER AllocationSize;
    } Overlay;

    //
    // Note that the UserBuffer parameter is outside of the stack so that I/O
    // completion can copy data back into the user's address space without
    // having to know exactly which service was being invoked.  The length
    // of the copy is stored in the second half of the I/O status block. If
    // the UserBuffer field is NULL, then no copy is performed.
    //

    PVOID UserBuffer;

    //
    // If this is a scatter/gather I/O request, then the individual pages for
    // the request can be obtained via this array.
    //

    PFILE_SEGMENT_ELEMENT SegmentArray;

    //
    // Stores the number of bytes that were locked down for direct I/O.
    //

    ULONG LockedBufferLength;

    //
    // Kernel structures
    //
    // The following section contains kernel structures which the IRP needs
    // in order to place various work information in kernel controller system
    // queues.  Because the size and alignment cannot be controlled, they are
    // placed here at the end so they just hang off and do not affect the
    // alignment of other fields in the IRP.
    //

    union {

        struct {

            union {

                //
                // DeviceQueueEntry - The device queue entry field is used to
                // queue the IRP to the device driver device queue.
                //

                KDEVICE_QUEUE_ENTRY DeviceQueueEntry;

                struct {

                    //
                    // The following are available to the driver to use in
                    // whatever manner is desired, while the driver owns the
                    // packet.
                    //

                    PVOID DriverContext[5];
                } ;
            } ;

            //
            // Thread - pointer to caller's Thread Control Block.
            //

            PETHREAD Thread;

            //
            // The following unnamed structure must be exactly identical
            // to the unnamed structure used in the minipacket header used
            // for completion queue entries.
            //

            struct {

                //
                // List entry - used to queue the packet to completion queue, among
                // others.
                //

                LIST_ENTRY ListEntry;

                union {

                    //
                    // Current stack location - contains a pointer to the current
                    // IO_STACK_LOCATION structure in the IRP stack.  This field
                    // should never be directly accessed by drivers.  They should
                    // use the standard functions.
                    //

                    struct _IO_STACK_LOCATION *CurrentStackLocation;

                    //
                    // Minipacket type.
                    //

                    ULONG PacketType;
                };
            };

            //
            // Original file object - pointer to the original file object
            // that was used to open the file.  This field is owned by the
            // I/O system and should not be used by any other drivers.
            //

            PFILE_OBJECT OriginalFileObject;

        } Overlay;

        //
        // APC - This APC control block is used for the special kernel APC as
        // well as for the caller's APC, if one was specified in the original
        // argument list.  If so, then the APC is reused for the normal APC for
        // whatever mode the caller was in and the "special" routine that is
        // invoked before the APC gets control simply deallocates the IRP.
        //

        KAPC Apc;

        //
        // CompletionKey - This is the key that is used to distinguish
        // individual I/O operations initiated on a single file handle.
        //

        PVOID CompletionKey;

    } Tail;

} IRP, *PIRP;

//
// Define completion routine types for use in stack locations in an IRP
//

typedef
NTSTATUS
(*PIO_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

//
// Define stack location control flags
//

#define SL_PENDING_RETURNED             0x01
#define SL_MUST_COMPLETE                0x02
#define SL_INVOKE_ON_CANCEL             0x20
#define SL_INVOKE_ON_SUCCESS            0x40
#define SL_INVOKE_ON_ERROR              0x80

//
// Define flags for various functions
//

//
// Create / Create Named Pipe
//
// The following flags must exactly match those in the IoCreateFile call's
// options.  The case sensitive flag is added in later, by the parse routine,
// and is not an actual option to open.  Rather, it is part of the object
// manager's attributes structure.
//

#define SL_FORCE_ACCESS_CHECK           0x01
#define SL_OPEN_TARGET_DIRECTORY        0x04

#define SL_CASE_SENSITIVE               0x80

//
// Read / Write
//

#define SL_OVERRIDE_VERIFY_VOLUME       0x02
#define SL_FSCACHE_REQUEST              0x80

//
// Device I/O Control
//
//
// Same SL_OVERRIDE_VERIFY_VOLUME as for read/write above.
//

//
// QueryDirectory / QueryEa / QueryQuota
//

#define SL_RESTART_SCAN                 0x01
#define SL_RETURN_SINGLE_ENTRY          0x02
#define SL_INDEX_SPECIFIED              0x04

//
// FileSystemControl
//
//    minor: mount/verify volume
//

#define SL_ALLOW_RAW_MOUNT              0x01

//
// Define I/O Request Packet (IRP) stack locations
//

#include "pshpack4.h"

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

typedef struct _IO_STACK_LOCATION {
    UCHAR MajorFunction;
    UCHAR MinorFunction;
    UCHAR Flags;
    UCHAR Control;

    //
    // The following user parameters are based on the service that is being
    // invoked.  Drivers and file systems can determine which set to use based
    // on the above major and minor function codes.
    //

    union {

        //
        // System service parameters for:  NtCreateFile
        //

        struct {
            ACCESS_MASK DesiredAccess;
            ULONG Options;
            USHORT POINTER_ALIGNMENT FileAttributes;
            USHORT ShareAccess;
            POBJECT_STRING RemainingName;
        } Create;

        //
        // System service parameters for:  NtReadFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Read;

        //
        // System service parameters for:  NtWriteFile
        //

        struct {
            ULONG Length;
            union {
                ULONG BufferOffset;
                PVOID CacheBuffer;
            };
            LARGE_INTEGER ByteOffset;
        } Write;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtQueryDirectoryFile
        //

        struct {
            ULONG Length;
            POBJECT_STRING FileName;
            FILE_INFORMATION_CLASS FileInformationClass;
        } QueryDirectory;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtQueryInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
        } QueryFile;

        //
        // System service parameters for:  NtSetInformationFile
        //

        struct {
            ULONG Length;
            FILE_INFORMATION_CLASS POINTER_ALIGNMENT FileInformationClass;
            PFILE_OBJECT FileObject;
        } SetFile;

        //
        // System service parameters for:  NtQueryVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } QueryVolume;

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtSetVolumeInformationFile
        //

        struct {
            ULONG Length;
            FS_INFORMATION_CLASS POINTER_ALIGNMENT FsInformationClass;
        } SetVolume;

        //
        // System service parameters for:  NtFsControlFile
        //
        // Note that the user's output buffer is stored in the UserBuffer field
        // and the user's input buffer is stored in the SystemBuffer field.
        //

        struct {
            ULONG OutputBufferLength;
            PVOID InputBuffer;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT FsControlCode;
        } FileSystemControl;

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtFlushBuffersFile
        //
        // No extra user-supplied parameters.
        //

// end_ntddk end_wdm end_nthal

        //
        // System service parameters for:  NtCancelIoFile
        //
        // No extra user-supplied parameters.
        //

// begin_ntddk begin_wdm begin_nthal

        //
        // System service parameters for:  NtDeviceIoControlFile
        //

        struct {
            ULONG OutputBufferLength;
            PVOID InputBuffer;
            ULONG POINTER_ALIGNMENT InputBufferLength;
            ULONG POINTER_ALIGNMENT IoControlCode;
        } DeviceIoControl;

        //
        // Parameters for Scsi with internal device contorl.
        //

        struct {
            struct _SCSI_REQUEST_BLOCK *Srb;
        } Scsi;

        //
        // Parameters for Cleanup
        //
        // No extra parameters supplied
        //

// end_ntddk end_wdm end_nthal

        //
        // Parameters for internally routed IDE IRPs.
        //

        struct {
            ULONG Length;
            PUCHAR Buffer;
            ULONG SectorNumber;
            ULONG BufferOffset;
        } IdexReadWrite;

// begin_ntddk begin_wdm begin_nthal

        //
        // Others - driver-specific
        //

        struct {
            PVOID Argument1;
            PVOID Argument2;
            PVOID Argument3;
            PVOID Argument4;
        } Others;

    } Parameters;

    //
    // Save a pointer to this device driver's device object for this request
    // so it can be passed to the completion routine if needed.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // The following location contains a pointer to the file object for this
    //

    PFILE_OBJECT FileObject;

    //
    // The following routine is invoked depending on the flags in the above
    // flags field.
    //

    PIO_COMPLETION_ROUTINE CompletionRoutine;

    //
    // The following is used to store the address of the context parameter
    // that should be passed to the CompletionRoutine.
    //

    PVOID Context;

} IO_STACK_LOCATION, *PIO_STACK_LOCATION;

#include "poppack.h"

//
// Define the share access structure used by file systems to determine
// whether or not another accessor may open the file.
//

typedef struct _SHARE_ACCESS {
    UCHAR OpenCount;
    UCHAR Readers;
    UCHAR Writers;
    UCHAR Deleters;
    UCHAR SharedRead;
    UCHAR SharedWrite;
    UCHAR SharedDelete;
} SHARE_ACCESS, *PSHARE_ACCESS;

// end_wdm end_ntddk end_nthal

// begin_ntddk begin_wdm begin_nthal
//
// Public I/O routine definitions
//

NTKERNELAPI
PIRP
IoAllocateIrp(
    IN CCHAR StackSize
    );

NTKERNELAPI
PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    );

NTKERNELAPI
PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#define IoCallDriver(a,b)   \
        IofCallDriver(a,b)

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI
VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    );

// begin_ntifs
// begin_ntddk begin_wdm begin_nthal

NTKERNELAPI
NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    );

NTKERNELAPI
VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );

#define IoCompleteRequest(a,b)  \
        IofCompleteRequest(a,b)

NTKERNELAPI
NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN POBJECT_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    );

// end_nthal

NTKERNELAPI
NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN ULONG Options
    );

// end_ntddk end_wdm

// begin_nthal begin_ntddk begin_wdm

NTKERNELAPI
NTSTATUS
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDeleteSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName
    );

NTKERNELAPI
NTSTATUS
IoDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
NTSTATUS
IoDismountVolumeByName(
    IN POBJECT_STRING DeviceName
    );

NTKERNELAPI
VOID
IoFreeIrp(
    IN PIRP Irp
    );

//++
//
// PIO_STACK_LOCATION
// IoGetCurrentIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the current stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the current stack location in the
//     packet.
//
//--

#define IoGetCurrentIrpStackLocation( Irp ) ( (Irp)->Tail.Overlay.CurrentStackLocation )

// end_nthal

//++
//
// ULONG
// IoGetFunctionCodeFromCtlCode(
//     IN ULONG ControlCode
//     )
//
// Routine Description:
//
//     This routine extracts the function code from IOCTL and FSCTL function
//     control codes.
//     This routine should only be used by kernel mode code.
//
// Arguments:
//
//     ControlCode - A function control code (IOCTL or FSCTL) from which the
//         function code must be extracted.
//
// Return Value:
//
//     The extracted function code.
//
// Note:
//
//     The CTL_CODE macro, used to create IOCTL and FSCTL function control
//     codes, is defined in ntioapi.h
//
//--

#define IoGetFunctionCodeFromCtlCode( ControlCode ) (\
    ( ControlCode >> 2) & 0x00000FFF )

// begin_nthal

//++
//
// PIO_STACK_LOCATION
// IoGetNextIrpStackLocation(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to return a pointer to the next stack location
//     in an I/O Request Packet (IRP).
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     The function value is a pointer to the next stack location in the packet.
//
//--

#define IoGetNextIrpStackLocation( Irp ) (\
    (Irp)->Tail.Overlay.CurrentStackLocation - 1 )

// end_ntddk end_wdm end_nthal

// begin_ntddk begin_wdm begin_nthal

NTKERNELAPI
VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI
BOOLEAN
IoInitSystem(
    VOID
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

NTKERNELAPI
NTSTATUS
IoInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

//++
//
// BOOLEAN
// IoIsErrorUserInduced(
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This routine is invoked to determine if an error was as a
//     result of user actions.  Typically these error are related
//     to removable media and will result in a pop-up.
//
// Arguments:
//
//     Status - The status value to check.
//
// Return Value:
//     The function value is TRUE if the user induced the error,
//     otherwise FALSE is returned.
//
//--
#define IoIsErrorUserInduced( Status ) ((BOOLEAN)  \
    (((Status) == STATUS_DEVICE_NOT_READY) ||      \
     ((Status) == STATUS_IO_TIMEOUT) ||            \
     ((Status) == STATUS_MEDIA_WRITE_PROTECTED) || \
     ((Status) == STATUS_NO_MEDIA_IN_DEVICE) ||    \
     ((Status) == STATUS_VERIFY_REQUIRED) ||       \
     ((Status) == STATUS_UNRECOGNIZED_MEDIA) ||    \
     ((Status) == STATUS_WRONG_VOLUME)))

// end_ntddk end_wdm end_nthal

//++
//
// BOOLEAN
// IoIsFileOpenedExclusively(
//     IN PFILE_OBJECT FileObject
//     )
//
// Routine Description:
//
//     This routine is invoked to determine whether the file open represented
//     by the specified file object is opened exclusively.
//
// Arguments:
//
//     FileObject - Pointer to the file object that represents the open instance
//         of the target file to be tested for exclusive access.
//
// Return Value:
//
//     The function value is TRUE if the open instance of the file is exclusive;
//     otherwise FALSE is returned.
//
//--

#define IoIsFileOpenedExclusively( FileObject ) (\
    (BOOLEAN) !((FileObject)->SharedRead || (FileObject)->SharedWrite || (FileObject)->SharedDelete))

VOID
IoLockUserBuffer(
    IN OUT PIRP Irp,
    IN ULONG Length
    );

// begin_ntddk begin_nthal

//  begin_wdm

NTKERNELAPI
VOID
IoMarkIrpMustComplete(
    IN OUT PIRP Irp
    );

//++
//
// VOID
// IoMarkIrpPending(
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine marks the specified I/O Request Packet (IRP) to indicate
//     that an initial status of STATUS_PENDING was returned to the caller.
//     This is used so that I/O completion can determine whether or not to
//     fully complete the I/O operation requested by the packet.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet to be marked pending.
//
// Return Value:
//
//     None.
//
//--

#define IoMarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED )

// end_ntddk end_wdm end_nthal end_ntifs

NTSTATUS
IoParseDevice(
    IN PVOID ParseObject,
    IN struct _OBJECT_TYPE *ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    );

// begin_ntifs

NTKERNELAPI
NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

NTKERNELAPI
NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    );

// end_ntifs

NTKERNELAPI                                             // ntsrv
VOID                                                    // ntsrv
IoQueueThreadIrp(                                       // ntsrv
    IN PIRP Irp                                         // ntsrv
    );                                                  // ntsrv

// begin_ntddk begin_nthal begin_ntifs

NTKERNELAPI
VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    );

//  begin_wdm

//++
//
// VOID
// IoSetCompletionRoutine(
//     IN PIRP Irp,
//     IN PIO_COMPLETION_ROUTINE CompletionRoutine,
//     IN PVOID Context,
//     IN BOOLEAN InvokeOnSuccess,
//     IN BOOLEAN InvokeOnError,
//     IN BOOLEAN InvokeOnCancel
//     )
//
// Routine Description:
//
//     This routine is invoked to set the address of a completion routine which
//     is to be invoked when an I/O packet has been completed by a lower-level
//     driver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet itself.
//
//     CompletionRoutine - Address of the completion routine that is to be
//         invoked once the next level driver completes the packet.
//
//     Context - Specifies a context parameter to be passed to the completion
//         routine.
//
//     InvokeOnSuccess - Specifies that the completion routine is invoked when the
//         operation is successfully completed.
//
//     InvokeOnError - Specifies that the completion routine is invoked when the
//         operation completes with an error status.
//
//     InvokeOnCancel - Specifies that the completion routine is invoked when the
//         operation is being canceled.
//
// Return Value:
//
//     None.
//
//--

#define IoSetCompletionRoutine( Irp, Routine, CompletionContext, Success, Error, Cancel ) { \
    PIO_STACK_LOCATION irpSp;                                               \
    ASSERT( (Success) | (Error) | (Cancel) ? (Routine) != NULL : TRUE );    \
    irpSp = IoGetNextIrpStackLocation( (Irp) );                             \
    irpSp->CompletionRoutine = (Routine);                                   \
    irpSp->Context = (CompletionContext);                                   \
    irpSp->Control = 0;                                                     \
    if ((Success)) { irpSp->Control = SL_INVOKE_ON_SUCCESS; }               \
    if ((Error)) { irpSp->Control |= SL_INVOKE_ON_ERROR; }                  \
    if ((Cancel)) { irpSp->Control |= SL_INVOKE_ON_CANCEL; } }

//++
//
// VOID
// IoSetNextIrpStackLocation (
//     IN OUT PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to set the current IRP stack location to
//     the next stack location, i.e. it "pushes" the stack.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet (IRP).
//
// Return Value:
//
//     None.
//
//--

#define IoSetNextIrpStackLocation( Irp ) {      \
    (Irp)->CurrentLocation--;                   \
    (Irp)->Tail.Overlay.CurrentStackLocation--; }

//++
//
// VOID
// IoCopyCurrentIrpStackLocationToNext(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to copy the IRP stack arguments and file
//     pointer from the current IrpStackLocation to the next
//     in an I/O Request Packet (IRP).
//
//     If the caller wants to call IoCallDriver with a completion routine
//     but does not wish to change the arguments otherwise,
//     the caller first calls IoCopyCurrentIrpStackLocationToNext,
//     then IoSetCompletionRoutine, then IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None.
//
//--

#define IoCopyCurrentIrpStackLocationToNext( Irp ) { \
    PIO_STACK_LOCATION irpSp; \
    PIO_STACK_LOCATION nextIrpSp; \
    irpSp = IoGetCurrentIrpStackLocation( (Irp) ); \
    nextIrpSp = IoGetNextIrpStackLocation( (Irp) ); \
    RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine)); \
    nextIrpSp->Control = 0; }

//++
//
// VOID
// IoSkipCurrentIrpStackLocation (
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine is invoked to increment the current stack location of
//     a given IRP.
//
//     If the caller wishes to call the next driver in a stack, and does not
//     wish to change the arguments, nor does he wish to set a completion
//     routine, then the caller first calls IoSkipCurrentIrpStackLocation
//     and the calls IoCallDriver.
//
// Arguments:
//
//     Irp - Pointer to the I/O Request Packet.
//
// Return Value:
//
//     None
//
//--

#define IoSkipCurrentIrpStackLocation( Irp ) \
    (Irp)->CurrentLocation++; \
    (Irp)->Tail.Overlay.CurrentStackLocation++;

NTKERNELAPI
VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    );

// end_ntddk end_wdm end_nthal end_ntifs

NTKERNELAPI
VOID
IoShutdownSystem(
    IN ULONG Phase
    );

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//++
//
// USHORT
// IoSizeOfIrp(
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Determines the size of an IRP given the number of stack locations
//     the IRP will have.
//
// Arguments:
//
//     StackSize - Number of stack locations for the IRP.
//
// Return Value:
//
//     Size in bytes of the IRP.
//
//--

#define IoSizeOfIrp( StackSize ) \
    ((USHORT) (sizeof( IRP ) + ((StackSize) * (sizeof( IO_STACK_LOCATION )))))

// end_ntifs


NTKERNELAPI
VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    );

NTKERNELAPI
VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL
    );

// begin_ntifs

// end_ntddk end_wdm end_nthal

NTKERNELAPI
NTSTATUS
IoSynchronousDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnedOutputBufferLength OPTIONAL,
    IN BOOLEAN InternalDeviceIoControl
    );

NTKERNELAPI
NTSTATUS
IoSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL
    );

// end_ntifs

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    );

//
// Common file system support routines.
//

typedef struct _DIRECTORY_ENUM_CONTEXT {
    ULONG QueryOffset;
    OBJECT_STRING TemplateFileName;
} DIRECTORY_ENUM_CONTEXT, *PDIRECTORY_ENUM_CONTEXT;

NTSTATUS
IoCreateDirectoryEnumContext(
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRECTORY_ENUM_CONTEXT *ReturnedDirectoryEnumContext
    );

BOOLEAN
IoIsNameInExpression(
    IN POBJECT_STRING TemplateFileName,
    IN POBJECT_STRING FileName
    );

extern ULONG IoPendingMustCompletePackets;

#endif // _IO_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ldr.h ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    ldr.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the XBE loader.

--*/

#ifndef _LDR_
#define _LDR_

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
XeLoadImage(
    IN PCOSTR ImageFileName,
    IN BOOLEAN LoadingDashboard,
    IN ULONG SettingsError
    );

VOID
XeLoadDashboardImage(
    VOID
    );

VOID
XeLoadDashboardImageWithReason(
    IN ULONG Reason,
    IN ULONG Parameter1
    );

VOID
XeLoadTitleImage(
    IN ULONG SettingsError
    );

VOID
XeLoadImageAfterTrayEjectBoot(
    VOID
    );

NTKERNELAPI
NTSTATUS
XeLoadSection(
    IN struct _XBEIMAGE_SECTION *Section
    );

NTKERNELAPI
NTSTATUS
XeUnloadSection(
    IN struct _XBEIMAGE_SECTION *Section
    );

//
// Macro to access the image header of an XBE image.
//

#define XeImageHeader() ((struct _XBEIMAGE_HEADER*)XBEIMAGE_STANDARD_BASE_ADDRESS)

//
// Macro to retrieve the size of the utility drive cluster size from the image
// header.
//

#define XeUtilityDriveClusterSize() (16384 << \
    ((XeImageHeader()->InitFlags & XINIT_UTILITY_DRIVE_CLUSTER_SIZE_MASK) >> \
    XINIT_UTILITY_DRIVE_CLUSTER_SIZE_SHIFT))

//
// Global that contains the NT object manager path of the current XBE image.
//

#if !defined(_NTSYSTEM_)
extern POBJECT_STRING XeImageFileName;
extern PUCHAR XePublicKeyData;
#else
extern OBJECT_STRING XeImageFileName;
extern UCHAR XePublicKeyData[];
extern ULONG XeCdRomMediaTitleID;
#endif

#ifdef __cplusplus
}
#endif

#endif // LDR
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\kd.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kd.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the Kernel Debugger sub-component of NTOS.

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#ifndef _KD_
#define _KD_

// begin_nthal
//
// Status Constants for reading data from comport
//

#define CP_GET_SUCCESS  0
#define CP_GET_NODATA   1
#define CP_GET_ERROR    2

// end_nthal

//
// Debug constants for FreezeFlag
//

#define FREEZE_BACKUP               0x0001
#define FREEZE_SKIPPED_PROCESSOR    0x0002
#define FREEZE_FROZEN               0x0004


//
// System Initialization procedure for KD subcomponent of NTOS
//

VOID
KdInitSystem(
    BOOLEAN InitializingSystem
    );

BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    );

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    );

BOOLEAN
KdPollBreakIn (
    VOID
    );

VOID
KdSetOwedBreakpoints(
    VOID
    );

VOID
KdDeleteAllBreakpoints(
    VOID
    );

//
// Data structure for passing information to KdpReportLoadSymbolsStateChange
// function via the debug trap
//

typedef struct _KD_SYMBOLS_INFO {
    IN PVOID BaseOfDll;
    IN ULONG_PTR ProcessId;
    IN ULONG CheckSum;
    IN ULONG SizeOfImage;
} KD_SYMBOLS_INFO, *PKD_SYMBOLS_INFO;


// begin_nthal
//
// Defines the debug port parameters for kernel debugger
//   CommunicationPort - specify which COM port to use as debugging port
//                       0 - use default; N - use COM N.
//   BaudRate - the baud rate used to initialize debugging port
//                       0 - use default rate.
//

typedef struct _DEBUG_PARAMETERS {
    ULONG CommunicationPort;
    ULONG BaudRate;
} DEBUG_PARAMETERS, *PDEBUG_PARAMETERS;

// end_nthal

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define external data.
// because of indirection for all drivers external to ntoskrnl these are actually ptrs
//

#if defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_WDMDDK_) || defined(_XBDM_)

extern PBOOLEAN KdDebuggerNotPresent;
extern PBOOLEAN KdDebuggerEnabled;

#else

extern BOOLEAN KdDebuggerNotPresent;
extern BOOLEAN KdDebuggerEnabled;

#endif



// end_ntddk end_wdm end_nthal end_ntifs

extern LIST_ENTRY KdLoadedModuleList;
extern DEBUG_PARAMETERS KdDebugParameters;

//
// This event is provided by the time service.  The debugger
// signals the event when the system time has slipped due
// to debugger activity.
//

VOID
KdUpdateTimeSlipEvent(
    PVOID Event
    );


// begin_ntddk begin_nthal begin_ntifs

typedef struct _DBGKD_DEBUG_DATA_HEADER64 *PDBGKD_DEBUG_DATA_HEADER64;

BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    );

VOID
KdDeregisterDebuggerDataBlock32(
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader
    );

// end_ntddk end_nthal end_ntifs

//
// DbgPrint strings will always be logged to a circular buffer,
// even if FLG_DISABLE_DBGPRINT is set.  This function may be called
// directly by the debugger service trap handler even when the debugger
// is not enabled.
//

#if DBG
#define KDPRINTBUFFERSIZE   16384
#else
#define KDPRINTBUFFERSIZE   4096
#endif

VOID
KdLogDbgPrint(
    IN PSTRING String
    );

#endif  // _KD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\memprint.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990  Microsoft Corporation

Module Name:

    memprint.h

Abstract:

    Include file for in-memory DbgPrint function.  Including this file
    will change DbgPrints to a routine which puts the display text in a
    circular buffer in memory.  By default, the text is then sent to the
    console via DbgPrint.  By changing the value of the MemPrintFlags
    flag, however, the text may be routed to a file instead, thereby
    significantly speeding up the DbgPrint operation.

Author:

    David Treadwell (davidtr) 05-Oct-1990

Revision History:

--*/

#ifndef _MEMPRINT_
#define _MEMPRINT_

#define MEM_PRINT_FLAG_CONSOLE     0x01
#define MEM_PRINT_FLAG_FILE        0x02
#define MEM_PRINT_FLAG_HEADER      0x04

extern ULONG MemPrintFlags;

#ifdef MIPS
#define MEM_PRINT_DEF_BUFFER_SIZE 16384
#else
#define MEM_PRINT_DEF_BUFFER_SIZE 65536
#endif

//
// The subbuffer count is the number of subbuffers within the circular
// buffer.  A subbuffer is the method used to buffer data between
// MemPrint and writing to disk--when a subbuffer is filled, its
// contents are written to the log file.  This value should be a power
// of two between two and sixty-four (two is necessary to allow writing
// to disk and RAM simultaneously, sixty-four is the maximum number of
// things a thread can wait on at once).
//
//

#define MEM_PRINT_DEF_SUBBUFFER_COUNT 16
#define MEM_PRINT_MAX_SUBBUFFER_COUNT 64

#define MEM_PRINT_LOG_FILE_NAME "\\SystemRoot\\Logfile"

//
// Exported routines.  MemPrintInitialize sets up the circular buffer
// and other memory, MemPrint writes text to the console and/or a
// log file, and MemPrintFlush writes the current subbuffer to disk
// whether or not it is full.
//

VOID
MemPrintInitialize (
    VOID
    );

VOID
MemPrint (
    CHAR *Format, ...
    );

VOID
MemPrintFlush (
    VOID
    );

#define DbgPrint MemPrint

#endif // def _MEMPRINT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\mm.h ===
/*-- BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mm.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for the memory management system.

Author:

    Lou Perazzoli (loup) 20-Mar-1989

Revision History:

--*/

#ifndef _MM_
#define _MM_

//
// The allocation granularity is 64k.
//

#define MM_ALLOCATION_GRANULARITY ((ULONG)0x10000)

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//++
//
// ULONG_PTR
// ROUND_TO_PAGES(
//     IN ULONG_PTR Size
//     )
//
// Routine Description:
//
//     The ROUND_TO_PAGES macro takes a size in bytes and rounds it up to a
//     multiple of the page size.
//
//     NOTE: This macro fails for values 0xFFFFFFFF - (PAGE_SIZE - 1).
//
// Arguments:
//
//     Size - Size in bytes to round up to a page multiple.
//
// Return Value:
//
//     Returns the size rounded up to a multiple of the page size.
//
//--

#define ROUND_TO_PAGES(Size)  (((ULONG_PTR)(Size) + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))

//++
//
// ULONG
// BYTES_TO_PAGES(
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The BYTES_TO_PAGES macro takes the size in bytes and calculates the
//     number of pages required to contain the bytes.
//
// Arguments:
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages required to contain the specified size.
//
//--

#define BYTES_TO_PAGES(Size)  ((ULONG)((ULONG_PTR)(Size) >> PAGE_SHIFT) + \
                               (((ULONG)(Size) & (PAGE_SIZE - 1)) != 0))

//++
//
// ULONG
// BYTE_OFFSET(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE - 1)))

//++
//
// ULONG
// BYTE_OFFSET_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The BYTE_OFFSET macro takes a virtual address and returns the byte offset
//     of that address within the large page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the byte offset portion of the virtual address.
//
//--

#define BYTE_OFFSET_LARGE(Va) ((ULONG)((LONG_PTR)(Va) & (PAGE_SIZE_LARGE - 1)))

//++
//
// PVOID
// PAGE_ALIGN(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)))

//++
//
// PVOID
// PAGE_ALIGN_LARGE(
//     IN PVOID Va
//     )
//
// Routine Description:
//
//     The PAGE_ALIGN macro takes a virtual address and returns a page-aligned
//     virtual address for that page.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns the page aligned virtual address.
//
//--

#define PAGE_ALIGN_LARGE(Va) ((PVOID)((ULONG_PTR)(Va) & ~(PAGE_SIZE_LARGE - 1)))

//++
//
// ULONG
// ADDRESS_AND_SIZE_TO_SPAN_PAGES(
//     IN PVOID Va,
//     IN ULONG Size
//     )
//
// Routine Description:
//
//     The ADDRESS_AND_SIZE_TO_SPAN_PAGES macro takes a virtual address and
//     size and returns the number of pages spanned by the size.
//
// Arguments:
//
//     Va - Virtual address.
//
//     Size - Size in bytes.
//
// Return Value:
//
//     Returns the number of pages spanned by the size.
//
//--

#define ADDRESS_AND_SIZE_TO_SPAN_PAGES(Va,Size) \
   (((((Size) - 1) >> PAGE_SHIFT) + \
   (((((ULONG)(Size-1)&(PAGE_SIZE-1)) + (PtrToUlong(Va) & (PAGE_SIZE -1)))) >> PAGE_SHIFT)) + 1L)

#define COMPUTE_PAGES_SPANNED(Va, Size) \
    ((ULONG)((((ULONG_PTR)(Va) & (PAGE_SIZE -1)) + (Size) + (PAGE_SIZE - 1)) >> PAGE_SHIFT))

// end_ntddk end_wdm end_nthal end_ntifs

//++
//
// BOOLEAN
// IS_SYSTEM_ADDRESS
//     IN PVOID Va,
//     )
//
// Routine Description:
//
//     This macro takes a virtual address and returns TRUE if the virtual address
//     is within system space, FALSE otherwise.
//
// Arguments:
//
//     Va - Virtual address.
//
// Return Value:
//
//     Returns TRUE is the address is in system space.
//
//--

#define IS_SYSTEM_ADDRESS(VA) ((VA) >= MM_SYSTEM_RANGE_START)

//
// Number of physical pages.
//

extern PFN_COUNT MmNumberOfPhysicalPages;

//
// Page frame number of the lowest physically addressable RAM page.
//

extern PFN_NUMBER MmLowestPhysicalPage;

//
// Page frame number of the highest physically addressable RAM page.
//

extern PFN_NUMBER MmHighestPhysicalPage;

//
// Memory management initialization routine.
//

VOID
MmInitSystem(
    VOID
    );

VOID
MmDiscardInitSection(
    VOID
    );

VOID
MmRelocatePersistentMemory(
    VOID
    );

VOID
MmPrepareToQuickRebootSystem(
    VOID
    );

#ifdef DEVKIT

VOID
MmReleaseDeveloperKitMemory(
    VOID
    );

#endif

//
// Shutdown routine - flushes dirty pages, etc for system shutdown.
//

BOOLEAN
MmShutdownSystem(
    VOID
    );

//
// Pool support routines to allocate complete pages, not for
// general consumption, these are only used by the executive pool allocator.
//

PVOID
MmAllocatePoolPages(
    IN SIZE_T NumberOfBytes
    );

ULONG
MmFreePoolPages(
    IN PVOID StartingAddress
    );

//
// First level fault routine.
//

NTSTATUS
MmAccessFault(
    IN BOOLEAN StoreInstruction,
    IN PVOID VirtualAddress,
    IN PVOID TrapInformation
    );

//
// Process Support Routines.
//

NTKERNELAPI
PVOID
MmCreateKernelStack(
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN DebuggerThread
    );

NTKERNELAPI
VOID
MmDeleteKernelStack(
    IN PVOID KernelStackBase,
    IN PVOID KernelStackLimit
    );

//
// Debugger support routines.
//

#define MmDbgReadCheck(VirtualAddress) (MmIsAddressValid(VirtualAddress) ? VirtualAddress : NULL)

NTKERNELAPI
PVOID
MmDbgWriteCheck(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    );

NTKERNELAPI
VOID
MmDbgReleaseAddress(
    IN PVOID VirtualAddress,
    IN PHARDWARE_PTE Opaque
    );

NTKERNELAPI
PVOID64
MmDbgTranslatePhysicalAddress64(
    IN PHYSICAL_ADDRESS PhysicalAddress
    );

NTKERNELAPI
PVOID
MmDbgAllocateMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
ULONG
MmDbgFreeMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PFN_COUNT
MmDbgQueryAvailablePages(
    VOID
    );

VOID
MmDbgAllocateDebugMonitorBase(
    PFN_COUNT NumberOfPages
    );

// begin_ntddk begin_ntifs begin_nthal

NTKERNELAPI
VOID
MmLockUnlockBufferPages(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN UnlockPages
    );

NTKERNELAPI
VOID
MmLockUnlockPhysicalPage(
    IN ULONG_PTR PhysicalAddress,
    IN BOOLEAN UnlockPage
    );

// begin_wdm

NTKERNELAPI
PVOID
MmMapIoSpace(
    IN ULONG_PTR PhysicalAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmUnmapIoSpace(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

// end_wdm end_ntddk end_ntifs

NTSTATUS
MmLockSelectedIoPages(
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN OUT PIRP Irp,
    IN BOOLEAN MapUserBuffer
    );

VOID
MmUnlockSelectedIoPages(
    IN PIRP Irp
    );

// begin_ntddk begin_ntifs

NTKERNELAPI
ULONG_PTR
MmGetPhysicalAddress(
    IN PVOID BaseAddress
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemory(
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
PVOID
MmAllocateContiguousMemoryEx(
    IN SIZE_T NumberOfBytes,
    IN ULONG_PTR LowestAcceptableAddress,
    IN ULONG_PTR HighestAcceptableAddress,
    IN ULONG_PTR Alignment,
    IN ULONG Protect
    );

NTKERNELAPI
VOID
MmFreeContiguousMemory(
    IN PVOID BaseAddress
    );

NTKERNELAPI
VOID
MmPersistContiguousMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes,
    IN BOOLEAN Persist
    );

NTKERNELAPI
PVOID
MmAllocateSystemMemory(
    IN SIZE_T NumberOfBytes,
    IN ULONG Protect
    );

NTKERNELAPI
ULONG
MmFreeSystemMemory(
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfBytes
    );

NTKERNELAPI
SIZE_T
MmQueryAllocationSize(
    IN PVOID BaseAddress
    );

NTKERNELAPI
ULONG
MmQueryAddressProtect(
    IN PVOID VirtualAddress
    );

NTKERNELAPI
VOID
MmSetAddressProtect(
    IN PVOID BaseAddress,
    IN ULONG NumberOfBytes,
    IN ULONG NewProtect
    );

NTKERNELAPI
BOOLEAN
MmIsAddressValid(
    IN PVOID VirtualAddress
    );

// end_ntddk end_nthal end_ntifs

//
// Memory manager statistics.
//

typedef struct _MM_STATISTICS {
    ULONG Length;
    ULONG TotalPhysicalPages;
    ULONG AvailablePages;
    ULONG VirtualMemoryBytesCommitted;
    ULONG VirtualMemoryBytesReserved;
    ULONG CachePagesCommitted;
    ULONG PoolPagesCommitted;
    ULONG StackPagesCommitted;
    ULONG ImagePagesCommitted;
} MM_STATISTICS, *PMM_STATISTICS;

NTKERNELAPI
NTSTATUS
MmQueryStatistics(
    IN OUT PMM_STATISTICS MemoryStatistics
    );

NTKERNELAPI
PVOID
MmClaimGpuInstanceMemory(
    IN SIZE_T NumberOfBytes,
    OUT SIZE_T *NumberOfPaddingBytes
    );

#endif  // MM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ntosdef.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntosdef.h

Abstract:

    Common type definitions for the NTOS component that are private to
    NTOS, but shared between NTOS sub-components.

Author:

    Steve Wood (stevewo) 08-May-1989

Revision History:

--*/

#ifndef _NTOSDEF_
#define _NTOSDEF_

//
// Declare the data sections used inside the kernel so that __declspec(allocate)
// will work.
//

#if (_MSC_VER >= 1300) && defined(_NTSYSTEM_)

#pragma data_seg(push)
#pragma data_seg("STICKY")
#pragma data_seg(".rdata")
#pragma data_seg("INIT_RW")
#pragma data_seg(pop)

#define DECLSPEC_STICKY     __declspec(allocate("STICKY"))
#define DECLSPEC_RDATA      __declspec(allocate(".rdata"))
#define DECLSPEC_INITDATA   __declspec(allocate("INIT_RW"))

#else

#define DECLSPEC_STICKY
#define DECLSPEC_RDATA
#define DECLSPEC_INITDATA

#endif

//
// Define interlocked sequenced list structure.
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntndis

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SINGLE_LIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

// end_ntddk end_wdm end_nthal end_ntifs end_ntndis

//
// Define the number of small pool lists.
//
// N.B. This value is used in pool.h and is used to allocate single entry
//      lookaside lists in the processor block of each processor.

#define POOL_SMALL_LISTS 8

// begin_ntddk begin_wdm begin_nthal begin_ntifs

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#define POOL_TAGGING 1

#ifndef DBG
#define DBG 0
#endif

#if DBG
#define IF_DEBUG if (TRUE)
#else
#define IF_DEBUG if (FALSE)
#endif

#if DEVL

// end_ntddk end_wdm end_nthal end_ntifs
//
// Global flag set by NtPartyByNumber(6) controls behaviour of
// NT.  See \nt\sdk\inc\ntexapi.h for flag definitions
//
// begin_ntddk begin_wdm begin_nthal begin_ntifs

extern ULONG NtGlobalFlag;

#define IF_NTOS_DEBUG( FlagName ) \
    if (NtGlobalFlag & (FLG_ ## FlagName))

#else
#define IF_NTOS_DEBUG( FlagName ) if (FALSE)
#endif

//
// Kernel definitions that need to be here for forward reference purposes
//

//
// APC function types
//

//
// Put in an empty definition for the KAPC so that the
// routines can reference it before it is declared.
//

struct _KAPC;

typedef
VOID
(*PKNORMAL_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
VOID
(*PKKERNEL_ROUTINE) (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

typedef
VOID
(*PKRUNDOWN_ROUTINE) (
    IN struct _KAPC *Apc
    );

typedef
BOOLEAN
(*PKSYNCHRONIZE_ROUTINE) (
    IN PVOID SynchronizeContext
    );

typedef
BOOLEAN
(*PKTRANSFER_ROUTINE) (
    VOID
    );

//
//
// Asynchronous Procedure Call (APC) object
//

typedef struct _KAPC {
    CSHORT Type;
    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;
    struct _KTHREAD *Thread;
    LIST_ENTRY ApcListEntry;
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;

    //
    // N.B. The following two members MUST be together.
    //

    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC, *PKAPC, *RESTRICTED_POINTER PRKAPC;

// begin_ntndis
//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    BOOLEAN Inserted;
    UCHAR Padding;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;

// end_ntndis
//
// switch to DBG when appropriate
//

#if DBG
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) { \
    KdPrint(( "EX: Pageable code called at IRQL %d\n", KeGetCurrentIrql() )); \
        ASSERT(FALSE); \
        }
#else
#define PAGED_CODE()
#endif

// end_ntddk end_wdm end_nthal end_ntifs


// begin_ntddk begin_wdm begin_nthal begin_ntndis begin_ntifs
//
// Define function decoration depending on whether a driver, a file system,
// or a kernel component is being built.
//
// end_wdm

#if !defined(_NTSYSTEM_)

#define NTKERNELAPI DECLSPEC_IMPORT         // wdm

#else

#define NTKERNELAPI

#endif

//
// Define function decoration depending on whether the HAL or other kernel
// component is being build.
//

#define NTHALAPI NTKERNELAPI

//
// Define a statically allocated object string.
//

#define INITIALIZED_OBJECT_STRING(ObjectString, Value)                      \
    OCHAR ObjectString##Buffer[] = Value;                                   \
    OBJECT_STRING ObjectString = {                                          \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

#define INITIALIZED_OBJECT_STRING_RDATA(ObjectString, Value)                \
    OCHAR DECLSPEC_RDATA ObjectString##Buffer[] = Value;                    \
    OBJECT_STRING DECLSPEC_RDATA ObjectString = {                           \
        sizeof(Value) - sizeof(OCHAR),                                      \
        sizeof(Value),                                                      \
        ObjectString##Buffer                                                \
    }

//
// Define a statically allocated list entry.
//

#define INITIALIZED_LIST_ENTRY(ListEntry)                       \
    LIST_ENTRY ListEntry = {                                    \
        &ListEntry, &ListEntry                                  \
    }

// end_ntddk end_nthal end_ntndis end_ntifs

#endif // _NTOSDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ke.h ===
/*++ BUILD Version: 0028    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ke.h

Abstract:

    This module contains the public (external) header file for the kernel.

Author:

    David N. Cutler (davec) 27-Feb-1989

Revision History:

--*/

#ifndef _KE_
#define _KE_

//
// Define the default quantum decrement values.
//

#define CLOCK_QUANTUM_DECREMENT 3
#define WAIT_QUANTUM_DECREMENT 10

//
// Define the default thread quantum value.
//

#define THREAD_QUANTUM 60

//
// Define the round trip decrement count.
//

#define ROUND_TRIP_DECREMENT_COUNT 16

//
// Public (external) constant definitions.
//

#define BASE_PRIORITY_THRESHOLD NORMAL_BASE_PRIORITY // fast path base threshold

//
// Define timer table size.
//

#define TIMER_TABLE_SIZE 32

//
// Enumerated kernel types
//
// Kernel object types.
//
//  N.B. There are really two types of event objects; NotificationEvent and
//       SynchronizationEvent. The type value for a notification event is 0,
//       and that for a synchronization event 1.
//
//  N.B. There are two types of new timer objects; NotificationTimer and
//       SynchronizationTimer. The type value for a notification timer is
//       8, and that for a synchronization timer is 9. These values are
//       very carefully chosen so that the dispatcher object type AND'ed
//       with 0x7 yields 0 or 1 for event objects and the timer objects.
//

#define DISPATCHER_OBJECT_TYPE_MASK 0x7

typedef enum _KOBJECTS {
    EventNotificationObject = 0,
    EventSynchronizationObject = 1,
    MutantObject = 2,
    ProcessObject = 3,
    QueueObject = 4,
    SemaphoreObject = 5,
    ThreadObject = 6,
    Spare1Object = 7,
    TimerNotificationObject = 8,
    TimerSynchronizationObject = 9,
    Spare2Object = 10,
    Spare3Object = 11,
    Spare4Object = 12,
    Spare5Object = 13,
    Spare6Object = 14,
    Spare7Object = 15,
    Spare8Object = 16,
    Spare9Object = 17,
    ApcObject,
    DpcObject,
    DeviceQueueObject,
    EventPairObject,
    InterruptObject,
    ProfileObject
    } KOBJECTS;

// begin_ntddk begin_wdm begin_ntminiport

//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

// end_ntddk end_wdm end_ntminiport

//
// Thread scheduling states.
//

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition
    } KTHREAD_STATE;

// begin_ntddk begin_wdm
//
// Wait reasons
//

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrFsCacheIn,
    WrFsCacheOut,
    Spare4,
    Spare5,
    Spare6,
    WrKernel,
    MaximumWaitReason
    } KWAIT_REASON;

// end_ntddk end_wdm

//
// Miscellaneous type definitions
//
// APC state
//

typedef struct _KAPC_STATE {
    LIST_ENTRY ApcListHead[MaximumMode];
    struct _KPROCESS *Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
    BOOLEAN ApcQueueable;
} KAPC_STATE, *PKAPC_STATE, *RESTRICTED_POINTER PRKAPC_STATE;

// begin_ntddk begin_wdm
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;

// end_ntddk end_wdm

//
// Wait block
//
// begin_ntddk begin_wdm

typedef struct _KWAIT_BLOCK {
    LIST_ENTRY WaitListEntry;
    struct _KTHREAD *RESTRICTED_POINTER Thread;
    PVOID Object;
    struct _KWAIT_BLOCK *RESTRICTED_POINTER NextWaitBlock;
    USHORT WaitKey;
    USHORT WaitType;
} KWAIT_BLOCK, *PKWAIT_BLOCK, *RESTRICTED_POINTER PRKWAIT_BLOCK;

// end_ntddk end_wdm

//
// Procedure type definitions
//
// Debug routine
//

typedef
BOOLEAN
(*PKDEBUG_ROUTINE) (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

typedef enum {
    ContinueError = FALSE,
    ContinueSuccess = TRUE,
    ContinueProcessorReselected,
    ContinueNextProcessor
} KCONTINUE_STATUS;

// begin_ntddk begin_wdm
//
// Thread start function
//

typedef
VOID
(*PKSTART_ROUTINE) (
    IN PVOID StartContext
    );

// end_wdm

//
// Thread system function
//

typedef
VOID
(*PKSYSTEM_ROUTINE) (
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

// begin_wdm
//
// Kernel object structure definitions
//

//
// Device Queue object and entry
//

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    UCHAR Size;
    BOOLEAN Busy;
    LIST_ENTRY DeviceListHead;
} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *RESTRICTED_POINTER PRKDEVICE_QUEUE;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *RESTRICTED_POINTER PRKDEVICE_QUEUE_ENTRY;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

// end_ntddk end_wdm   
// begin_ntddk begin_wdm 
//
// Define the interrupt service function type and the empty struct
// type.
//
// end_ntddk end_wdm 

struct _KINTERRUPT;

// begin_ntddk begin_wdm

typedef
BOOLEAN
(*PKSERVICE_ROUTINE) (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
    );

// end_ntddk end_wdm

//
// Interrupt object
//

typedef struct _KINTERRUPT {
    PKSERVICE_ROUTINE ServiceRoutine;
    PVOID ServiceContext;
    ULONG BusInterruptLevel;
    ULONG Irql;                         // zero extended
    BOOLEAN Connected;
    BOOLEAN ShareVector;
    UCHAR Mode;
    ULONG ServiceCount;
    ULONG DispatchCode[DISPATCH_LENGTH];
} KINTERRUPT;

typedef struct _KINTERRUPT *PKINTERRUPT, *RESTRICTED_POINTER PRKINTERRUPT; // ntndis

// begin_ntddk begin_wdm
//
// Mutant object
//

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *RESTRICTED_POINTER OwnerThread;
    BOOLEAN Abandoned;
} KMUTANT, *PKMUTANT, *RESTRICTED_POINTER PRKMUTANT;

// end_ntddk end_wdm
//
// Queue object
//

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE, *RESTRICTED_POINTER PRKQUEUE;

// begin_ntddk begin_wdm
//
//
// Semaphore object
//

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *RESTRICTED_POINTER PRKSEMAPHORE;

//
//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;

// end_ntddk end_wdm

//
// Thread object
//

typedef struct _KTHREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListHead;

    //
    // The following entries are referenced during clock interrupts.
    //

    ULONG KernelTime;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //

    PVOID StackBase;
    PVOID StackLimit;
    PVOID KernelStack;
    PVOID TlsData;
    UCHAR State;
    BOOLEAN Alerted[MaximumMode];
    BOOLEAN Alertable;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    UCHAR Padding;
    KAPC_STATE ApcState;
    ULONG ContextSwitches;

    //
    // The following fields are referenced during wait operations.
    //

    LONG_PTR WaitStatus;
    KIRQL WaitIrql;
    KPROCESSOR_MODE WaitMode;
    BOOLEAN WaitNext;
    UCHAR WaitReason;
    PRKWAIT_BLOCK WaitBlockList;
    LIST_ENTRY WaitListEntry;
    ULONG WaitTime;
    ULONG KernelApcDisable;
    LONG Quantum;
    SCHAR BasePriority;
    UCHAR DecrementCount;
    SCHAR PriorityDecrement;
    BOOLEAN DisableBoost;
    UCHAR NpxIrql;
    CCHAR SuspendCount;
    BOOLEAN Preempted;
    BOOLEAN HasTerminated;

    //
    // The following fields are referenced during queue operations.
    //

    PRKQUEUE Queue;
    LIST_ENTRY QueueListEntry;

    //
    // The following fields are referenced when the thread is blocking for a
    // timed interval.
    //

    KTIMER Timer;
    KWAIT_BLOCK TimerWaitBlock;

    //
    // The following fields are referenced when the thread is initialized
    // and very infrequently thereafter.
    //

    KAPC SuspendApc;
    KSEMAPHORE SuspendSemaphore;
    LIST_ENTRY ThreadListEntry;

} KTHREAD, *PKTHREAD, *RESTRICTED_POINTER PRKTHREAD;

//
// Process object structure definition
//

typedef struct _KPROCESS {
    LIST_ENTRY ReadyListHead;
    LIST_ENTRY ThreadListHead;
    ULONG StackCount;
    LONG ThreadQuantum;
    SCHAR BasePriority;
    BOOLEAN DisableBoost;
    BOOLEAN DisableQuantum;
} KPROCESS, *PKPROCESS, *RESTRICTED_POINTER PRKPROCESS;

//
// Kernel control object functions
//
// APC object
//

NTKERNELAPI
VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ProcessorMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    );

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

NTKERNELAPI
BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    );

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    );

// begin_ntddk begin_wdm  
//
// DPC object
//

NTKERNELAPI
VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    );

#define INITIALIZED_KDPC(_Dpc, _DeferredRoutine, _DeferredContext)  \
    KDPC _Dpc = {                                                   \
        DpcObject,                                                  \
        FALSE,                                                      \
        0,                                                          \
        NULL,                                                       \
        NULL,                                                       \
        _DeferredRoutine,                                           \
        _DeferredContext                                            \
    }

NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTKERNELAPI
BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    );

DECLSPEC_NORETURN
VOID
KeRetireDpcListLoop(
    VOID
    );

//
// Device queue object
//

NTKERNELAPI
VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

NTKERNELAPI
BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

NTKERNELAPI
PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    );

NTKERNELAPI
BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    );

// end_ntddk end_wdm

//
// Interrupt object
//

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeInitializeInterrupt (                             // nthal
    IN PKINTERRUPT Interrupt,                       // nthal
    IN PKSERVICE_ROUTINE ServiceRoutine,            // nthal
    IN PVOID ServiceContext,                        // nthal
    IN ULONG Vector,                                // nthal
    IN KIRQL Irql,                                  // nthal
    IN KINTERRUPT_MODE InterruptMode,               // nthal
    IN BOOLEAN ShareVector                          // nthal
    );                                              // nthal
                                                    // nthal
NTKERNELAPI                                         // nthal
BOOLEAN                                             // nthal
KeConnectInterrupt (                                // nthal
    IN PKINTERRUPT Interrupt                        // nthal
    );                                              // nthal
                                                    // nthal
NTKERNELAPI
BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    );

NTKERNELAPI                                         // ntddk wdm nthal
BOOLEAN                                             // ntddk wdm nthal
KeSynchronizeExecution (                            // ntddk wdm nthal
    IN PKINTERRUPT Interrupt,                       // ntddk wdm nthal
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,    // ntddk wdm nthal
    IN PVOID SynchronizeContext                     // ntddk wdm nthal
    );                                              // ntddk wdm nthal
                                                    // ntddk wdm nthal
// begin_ntddk begin_wdm
//
// Kernel dispatcher object functions
//
// Event Object
//

// end_wdm end_ntddk

#if defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)

// begin_wdm begin_ntddk

NTKERNELAPI
VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    );

// end_wdm end_ntddk

#else

#define KeInitializeEvent(_Event, _Type, _State)            \
    (_Event)->Header.Type = (UCHAR)_Type;                   \
    (_Event)->Header.Size =  sizeof(KEVENT) / sizeof(LONG); \
    (_Event)->Header.SignalState = _State;                  \
    InitializeListHead(&(_Event)->Header.WaitListHead)

#endif

#define INITIALIZED_KEVENT(_Event, _Type, _State)           \
    KEVENT _Event = {                                       \
        _Type,                                              \
        FALSE,                                              \
        sizeof(KEVENT) / sizeof(LONG),                      \
        FALSE,                                              \
        _State,                                             \
        &_Event.Header.WaitListHead,                        \
        &_Event.Header.WaitListHead                         \
    }

// begin_ntddk

#define KeClearEvent(Event) ((Event)->Header.SignalState = 0)

NTKERNELAPI
LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

#define KeReadStateEvent(Event) (Event)->Header.SignalState

// begin_wdm

NTKERNELAPI
LONG
KeResetEvent (
    IN PRKEVENT Event
    );

NTKERNELAPI
LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm

VOID
KeSetEventBoostPriority (
    IN PRKEVENT Event,
    IN PRKTHREAD *Thread OPTIONAL
    );

//
// Mutant object
//

NTKERNELAPI
VOID
KeInitializeMutant (
    IN PRKMUTANT Mutant,
    IN BOOLEAN InitialOwner
    );

#define KeReadStateMutant(Mutant) (Mutant)->Header.SignalState

NTKERNELAPI
LONG
KeReleaseMutant (
    IN PRKMUTANT Mutant,
    IN KPRIORITY Increment,
    IN BOOLEAN Abandoned,
    IN BOOLEAN Wait
    );

//
//
// Queue Object.
//

NTKERNELAPI
VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    );

#define KeReadStateQueue(Queue) (Queue)->Header.SignalState

NTKERNELAPI
LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    );

NTKERNELAPI
PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    );

// begin_ntddk begin_wdm
//
// Semaphore object
//

NTKERNELAPI
VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    );

#define KeReadStateSemaphore(Semaphore) (Semaphore)->Header.SignalState

NTKERNELAPI
LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    );

// end_ntddk end_wdm  

//
// Process object
//

VOID
KeInitializeProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY Priority
    );

NTKERNELAPI
KPRIORITY
KeSetPriorityProcess (
    IN PKPROCESS Process,
    IN KPRIORITY BasePriority
    );

LOGICAL
KeSetDisableQuantumProcess (
    IN PKPROCESS Process,
    IN LOGICAL Disable
    );

//
// Thread object
//

VOID
KeInitializeThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PKPROCESS Process
    );

NTKERNELAPI
BOOLEAN
KeAlertThread (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ProcessorMode
    );

NTKERNELAPI
ULONG
KeAlertResumeThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI
VOID
KeBoostCurrentThread (
    VOID
    );

VOID
KeBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    );

NTKERNELAPI                                         // ntddk wdm nthal ntifs
NTSTATUS                                            // ntddk wdm nthal ntifs
KeDelayExecutionThread (                            // ntddk wdm nthal ntifs
    IN KPROCESSOR_MODE WaitMode,                    // ntddk wdm nthal ntifs
    IN BOOLEAN Alertable,                           // ntddk wdm nthal ntifs
    IN PLARGE_INTEGER Interval                      // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
BOOLEAN
KeDisableApcQueuingThread (
    IN PKTHREAD Thread
    );

BOOLEAN
KeEnableApcQueuingThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI
LOGICAL
KeSetDisableBoostThread (
    IN PKTHREAD Thread,
    IN LOGICAL Disable
    );

ULONG
KeForceResumeThread (
    IN PKTHREAD Thread
    );

NTKERNELAPI
LONG
KeQueryBasePriorityThread (
    IN PKTHREAD Thread
    );

#define KeQueryPriorityThread(Thread) Thread->Priority

#define KeReadStateThread(Thread) ((BOOLEAN)(Thread)->Header.SignalState)

VOID
KeReadyThread (
    IN PKTHREAD Thread
    );

ULONG
KeResumeThread (
    IN PKTHREAD Thread
    );

VOID
KeRundownThread (
    VOID
    );

NTKERNELAPI                                         // ntddk nthal ntifs
LONG                                                // ntddk nthal ntifs
KeSetBasePriorityThread (                           // ntddk nthal ntifs
    IN PKTHREAD Thread,                             // ntddk nthal ntifs
    IN LONG Increment                               // ntddk nthal ntifs
    );                                              // ntddk nthal ntifs

NTKERNELAPI                                         // ntddk wdm nthal ntifs
KPRIORITY                                           // ntddk wdm nthal ntifs
KeSetPriorityThread (                               // ntddk wdm nthal ntifs
    IN PKTHREAD Thread,                             // ntddk wdm nthal ntifs
    IN KPRIORITY Priority                           // ntddk wdm nthal ntifs
    );                                              // ntddk wdm nthal ntifs
                                                    // ntddk wdm nthal ntifs
ULONG
KeSuspendThread (
    IN PKTHREAD Thread
    );

VOID
KeTerminateThread (
    VOID
    );

NTKERNELAPI
BOOLEAN
KeTestAlertThread (
    IN KPROCESSOR_MODE ProcessorMode
    );

//
// Define leave critical region macro used for inline and function code
// generation.
//
// Warning: assembly versions of this code are included directly in
// ntgdi assembly routines mutexs.s for MIPS and locka.asm for i386.
// Any changes made to KeEnterCriticalRegion/KeEnterCriticalRegion
// must be reflected in these routines.
//

#define KiLeaveCriticalRegion() {                                           \
    PKTHREAD Thread;                                                        \
    Thread = KeGetCurrentThread();                                          \
    if (((*((volatile ULONG *)&Thread->KernelApcDisable) += 1) == 0) &&     \
        (((volatile LIST_ENTRY *)&Thread->ApcState.ApcListHead[KernelMode])->Flink != \
         &Thread->ApcState.ApcListHead[KernelMode])) {                      \
        Thread->ApcState.KernelApcPending = TRUE;                           \
        KiRequestSoftwareInterrupt(APC_LEVEL);                              \
    }                                                                       \
}

// begin_ntddk

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_)) && !defined(_NTSYSTEM_DRIVER_)

// begin_wdm

NTKERNELAPI
VOID
KeEnterCriticalRegion (
    VOID
    );

NTKERNELAPI
VOID
KeLeaveCriticalRegion (
    VOID
    );

// end_wdm

#else

//++
//
// VOID
// KeEnterCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function disables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeEnterCriticalRegion() KeGetCurrentThread()->KernelApcDisable -= 1;

//++
//
// VOID
// KeLeaveCriticalRegion (
//    VOID
//    )
//
//
// Routine Description:
//
//    This function enables kernel APC's.
//
//    N.B. The following code does not require any interlocks. There are
//         two cases of interest: 1) On an MP system, the thread cannot
//         be running on two processors as once, and 2) if the thread is
//         is interrupted to deliver a kernel mode APC which also calls
//         this routine, the values read and stored will stack and unstack
//         properly.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//--

#define KeLeaveCriticalRegion() KiLeaveCriticalRegion()

#endif

// begin_wdm

//
// Timer object
//

#define KeInitializeTimer(Timer) KeInitializeTimerEx(Timer, NotificationTimer)

NTKERNELAPI
VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    );

#define INITIALIZED_KTIMER(_Timer, _Type)                   \
    KTIMER _Timer = {                                       \
        TimerNotificationObject + _Type,                    \
        FALSE,                                              \
        sizeof(KTIMER) / sizeof(LONG),                      \
        FALSE,                                              \
        FALSE,                                              \
        &_Timer.Header.WaitListHead,                        \
        &_Timer.Header.WaitListHead                         \
    }

NTKERNELAPI
BOOLEAN
KeCancelTimer (
    IN PKTIMER
    );

#define KeClearTimer(Timer) ((Timer)->Header.SignalState = 0)

#define KeReadStateTimer(Timer) ((BOOLEAN)(Timer)->Header.SignalState)

NTKERNELAPI
BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    );

NTKERNELAPI
BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    );

// end_ntddk end_wdm

PVOID
KeCheckForTimer(
    IN PVOID p,
    IN ULONG Size
    );

ULONGLONG
KeQueryTimerDueTime (
    IN PKTIMER Timer
    );

//
// Wait functions
//

// begin_ntddk begin_wdm

NTKERNELAPI
NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray
    );

NTKERNELAPI
NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

// end_ntddk end_wdm

//
// On Uni-processor systems there is no real Dispatcher Database Lock
// so raising to SYNCH won't help get the lock released any sooner.
// On X86, these functions are implemented in the HAL and don't use
// the KiSynchLevel variable, on other platforms, KiSynchLevel can
// be set appropriately.
//

#define KiLockDispatcherDatabase(OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

NTKERNELAPI
VOID
FASTCALL
KiUnlockDispatcherDatabase (
    IN KIRQL OldIrql
    );

#define KiLockDispatcherDatabaseAtDpcLevel() \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define KiUnlockDispatcherDatabaseFromDpcLevel() \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

VOID
FASTCALL
KiSetPriorityThread (
    IN PRKTHREAD Thread,
    IN KPRIORITY Priority
    );

// begin_ntddk begin_wdm
//
// spin lock functions
//

#define KeInitializeSpinLock(a)             *(a) = 0

#define KeAcquireSpinLockAtDpcLevel(a)      ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)
#define KeReleaseSpinLockFromDpcLevel(a)

#define KeAcquireSpinLock(a,b)              *(b) = KeRaiseIrqlToDpcLevel()
#define KeReleaseSpinLock(a,b)              KeLowerIrql(b)

#define KeTryToAcquireSpinLock(a,b)         (KeAcquireSpinLock(a,b),TRUE)

// end_wdm end_ntddk

//
// Raise and lower IRQL functions.
//

// begin_wdm begin_ntddk

#if defined(_X86_)

NTHALAPI
VOID
FASTCALL
KfLowerIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
FASTCALL
KfRaiseIrql (
    IN KIRQL NewIrql
    );

NTHALAPI
KIRQL
KeRaiseIrqlToDpcLevel(
    VOID
    );

NTHALAPI
KIRQL
KeRaiseIrqlToSynchLevel(
    VOID
    );

#define KeLowerIrql(a)      KfLowerIrql(a)
#define KeRaiseIrql(a,b)    *(b) = KfRaiseIrql(a)

#endif

//
// Miscellaneous kernel functions
//

// end_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
NTAPI
KeBugCheck (
    IN ULONG BugCheckCode
    );

// begin_wdm

NTKERNELAPI
DECLSPEC_NORETURN
VOID
KeBugCheckEx(
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    );

// end_wdm

NTKERNELAPI
VOID
KeEnterKernelDebugger (
    VOID
    );

// end_ntddk  

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    );

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags
    );

NTKERNELAPI                                         // nthal
VOID                                                // nthal
KeFlushCurrentTb (                                  // nthal
    VOID                                            // nthal
    );                                              // nthal
                                                    // nthal
VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    );

// begin_ntddk begin_wdm

NTKERNELAPI
ULONGLONG
KeQueryInterruptTime (
    VOID
    );

NTKERNELAPI
VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    );

#if !defined(_NTSYSTEM_)

#define KeQueryTickCount() *KeTickCount

#else

#define KeQueryTickCount() KeTickCount

#endif

#define KiQueryLowTickCount KeQueryTickCount

// end_wdm end_ntddk

//
// Define the firmware routine types
//

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalFatalErrorRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

//
// Quick reboot routine.
//

VOID
KeQuickRebootSystem(
    VOID
    );

//
// begin_ntddk
//
// Context swap notify routine.
//

typedef
VOID
(FASTCALL *PSWAP_CONTEXT_NOTIFY_ROUTINE)(
    IN HANDLE OldThreadId,
    IN HANDLE NewThreadId
    );

//
// Thread select notify routine.
//

typedef
LOGICAL
(FASTCALL *PTHREAD_SELECT_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId
    );

//
// Time update notify routine.
//

typedef
VOID
(FASTCALL *PTIME_UPDATE_NOTIFY_ROUTINE)(
    IN HANDLE ThreadId,
    IN KPROCESSOR_MODE Mode
    );

// end_ntddk

//
// External references to public kernel data structures
//

extern BOOLEAN KeHasQuickBooted;
extern LARGE_INTEGER KeBootTime;
extern ULONGLONG KeBootTimeBias;

#if !defined(_NTSYSTEM_)
extern const ULONG *KeTimeIncrement;
extern volatile PULONG KeTickCount;
extern volatile PKSYSTEM_TIME KeInterruptTime;
extern volatile PKSYSTEM_TIME KeSystemTime;
#else
extern const ULONG KeTimeIncrement;
extern volatile ULONG KeTickCount;
extern volatile KSYSTEM_TIME KeInterruptTime;
extern volatile KSYSTEM_TIME KeSystemTime;
#endif

#endif // _KE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ntos.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ntos.h

Abstract:

    Top level include file for the NTOS component.

Author:

    Steve Wood (stevewo) 28-Feb-1989


Revision History:

--*/

#ifndef _NTOS_
#define _NTOS_

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>

/* disable undesirable warnings at warning level 4 */
#pragma warning(disable:4214 4201 4115 4200 4100 4514 4057 4127)

#include "ntosdef.h"
#include "exboosts.h"
#include "bugcodes.h"
#include "init.h"

#ifdef _X86_
#include "i386.h"
#endif

#include "ke.h"
#include "kd.h"
#include "ex.h"
#include "ps.h"
#include "io.h"
#include "ob.h"
#include "mm.h"
#include "fscache.h"
#include "xpcicfg.h"
#include "hal.h"

#define _NTDDK_

//
// Temp. Until we define a header file for types
// Outside of the kernel these are exported by reference
//

#if !defined(_NTSYSTEM_)
extern POBJECT_TYPE ExEventObjectType;
extern POBJECT_TYPE ExMutantObjectType;
extern POBJECT_TYPE ExSemaphoreObjectType;
extern POBJECT_TYPE ExTimerObjectType;
extern POBJECT_TYPE PsProcessObjectType;
extern POBJECT_TYPE PsThreadObjectType;
extern POBJECT_TYPE IoCompletionObjectType;
extern POBJECT_TYPE IoDeviceObjectType;
extern POBJECT_TYPE IoFileObjectType;
extern POBJECT_TYPE ObDirectoryObjectType;
extern POBJECT_TYPE ObSymbolicLinkObjectType;
#else
extern OBJECT_TYPE ExEventObjectType;
extern OBJECT_TYPE ExMutantObjectType;
extern OBJECT_TYPE ExSemaphoreObjectType;
extern OBJECT_TYPE ExTimerObjectType;
extern OBJECT_TYPE PsProcessObjectType;
extern OBJECT_TYPE PsThreadObjectType;
extern OBJECT_TYPE IoCompletionObjectType;
extern OBJECT_TYPE IoDeviceObjectType;
extern OBJECT_TYPE IoFileObjectType;
extern OBJECT_TYPE ObDirectoryObjectType;
extern OBJECT_TYPE ObSymbolicLinkObjectType;
#endif

#ifdef __cplusplus
}
#endif

#endif // _NTOS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\miniport.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifndef __cplusplus
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_ALPHA) || defined(_M_IA64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT     __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

// end_winnt

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif

#if (_MSC_VER >= 1200) && defined(_M_IX86)
#define FORCEINLINE static __forceinline
#else
#define FORCEINLINE __inline
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR PCTSTR, LPCTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;


#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif


#ifdef _X86_

//
// Disable these two pramas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
#define CmResourceTypeAssignedResource    8   // BUGBUG--remove
#define CmResourceTypeSubAllocateFrom     9   // BUGBUG--remove
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the PASSIGNED_RESOURCE type
//

#ifndef PASSIGNED_RESOURCE_DEFINED
#define PASSIGNED_RESOURCE_DEFINED
typedef PVOID PASSIGNED_RESOURCE;
#endif // PASSIGNED_RESOURCE_DEFINED

// end_wdm

//
// Define the bit masks for Flags common for all CM_RESOURCE_TYPE
//
// BUGBUG--remove the following 3 flags...
//
#define CM_RESOURCE_COMMON_COMPUTE_LENGTH_FROM_DEPENDENTS   0x8000
#define CM_RESOURCE_COMMON_NOT_REASSIGNED                   0x4000
#define CM_RESOURCE_COMMON_SUBSTRACTIVE                     0x2000

// begin_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
// end_wdm
#define CM_RESOURCE_PORT_FORWARD_FIRST_256_OF_EACH_1024     0x0002  // BUGBUG--remove
// begin_wdm
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040
// end_wdm

//
// Define the bit masks for Flags when type is CmResourceTypeBusNumber
//

#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001  // BUGBUG--remove

//
// Define the bit masks for Flags when type is CmResourceTypeSubAllocateFrom
//

#define CM_RESOURCE_SUBALLOCATEFROM_FIXED_TRANSLATION   0x0001  // BUGBUG--remove
#define CM_RESOURCE_SUBALLOCATEFROM_WIRED_TRANSLATION   0x0002  // BUGBUG--remove


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

// end_wdm

        struct {
            PASSIGNED_RESOURCE AssignedResource;
        } AssignedResource;     // will be obsoleted

        struct {
            UCHAR Type;                 // use CM_RESOURCE_TYPE
            UCHAR Reserved[3];
            PASSIGNED_RESOURCE AssignedResource;
            PHYSICAL_ADDRESS Transformation;
        } SubAllocateFrom;      // will be obsoleted

// begin_wdm

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;


#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ob.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    ob.h

Abstract:

    This module contains the object manager structure public data
    structures and procedure prototypes to be used within the NT
    system.

--*/

#ifndef _OB_
#define _OB_

//
// Object manager handle table support.
//

#define OB_HANDLES_PER_TABLE_SHIFT      6
#define OB_HANDLES_PER_TABLE            (1 << OB_HANDLES_PER_TABLE_SHIFT)
#define OB_TABLES_PER_SEGMENT           8
#define OB_HANDLES_PER_SEGMENT          (OB_TABLES_PER_SEGMENT * OB_HANDLES_PER_TABLE)

typedef struct _OBJECT_HANDLE_TABLE {
    LONG HandleCount;
    LONG_PTR FirstFreeTableEntry;
    HANDLE NextHandleNeedingPool;
    PVOID **RootTable;
    PVOID *BuiltinRootTable[OB_TABLES_PER_SEGMENT];
} OBJECT_HANDLE_TABLE, *POBJECT_HANDLE_TABLE;

//
// Object type information structure.
//

typedef PVOID (*OB_ALLOCATE_METHOD)(
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef VOID (*OB_FREE_METHOD)(
    IN PVOID Pointer
    );

typedef VOID (*OB_CLOSE_METHOD)(
    IN PVOID Object,
    IN ULONG SystemHandleCount
    );

typedef VOID (*OB_DELETE_METHOD)(
    IN PVOID Object
    );

typedef NTSTATUS (*OB_PARSE_METHOD)(
    IN PVOID ParseObject,
    IN struct _OBJECT_TYPE *ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    );

typedef struct _OBJECT_TYPE {
    OB_ALLOCATE_METHOD AllocateProcedure;
    OB_FREE_METHOD FreeProcedure;
    OB_CLOSE_METHOD CloseProcedure;
    OB_DELETE_METHOD DeleteProcedure;
    OB_PARSE_METHOD ParseProcedure;
    PVOID DefaultObject;
    ULONG PoolTag;
} OBJECT_TYPE, *POBJECT_TYPE;

//
// Object header structure.
//

typedef struct _OBJECT_HEADER {
    LONG PointerCount;
    LONG HandleCount;
    POBJECT_TYPE Type;
    ULONG Flags;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define OB_FLAG_NAMED_OBJECT            0x01
#define OB_FLAG_PERMANENT_OBJECT        0x02
#define OB_FLAG_ATTACHED_OBJECT         0x04

#define OBJECT_TO_OBJECT_HEADER(Object) \
    CONTAINING_RECORD(Object, OBJECT_HEADER, Body)

#define OBJECT_TO_OBJECT_HEADER_NAME_INFO(Object) \
    ((POBJECT_HEADER_NAME_INFO)OBJECT_TO_OBJECT_HEADER(Object) - 1)

#define OBJECT_HEADER_NAME_INFO_TO_OBJECT_HEADER(ObjectHeaderNameInfo) \
    ((POBJECT_HEADER)((POBJECT_HEADER_NAME_INFO)(ObjectHeaderNameInfo) + 1))

#define OBJECT_HEADER_TO_OBJECT_HEADER_NAME_INFO(ObjectHeader) \
    ((POBJECT_HEADER_NAME_INFO)(ObjectHeader) - 1)

#define OBJECT_HEADER_NAME_INFO_TO_OBJECT(ObjectHeaderNameInfo) \
    (&OBJECT_HEADER_NAME_INFO_TO_OBJECT_HEADER(ObjectHeaderNameInfo)->Body)

typedef struct _OBJECT_HEADER_NAME_INFO {
    struct _OBJECT_HEADER_NAME_INFO *ChainLink;
    struct _OBJECT_DIRECTORY *Directory;
    OBJECT_STRING Name;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

//
// Object directory structure.
//

#define OB_NUMBER_HASH_BUCKETS          11

typedef struct _OBJECT_DIRECTORY {
    struct _OBJECT_HEADER_NAME_INFO *HashBuckets[OB_NUMBER_HASH_BUCKETS];
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

//
// Symbolic link object structure.
//

typedef struct _OBJECT_SYMBOLIC_LINK {
    PVOID LinkTargetObject;
    OBJECT_STRING LinkTarget;
} OBJECT_SYMBOLIC_LINK, *POBJECT_SYMBOLIC_LINK;

//
// The following global event can be used for types of objects that can never be
// signaled.
//

extern KEVENT ObpDefaultObject;

//
// Define the maximum number of KWAIT_BLOCKs that will be allocated on the stack
// for a NtWaitForMultipleObjectsEx call.
//
// This number is chosen such that:
//
// (OB_MAXIMUM_STACK_WAIT_BLOCKS * (sizeof(PVOID) + sizeof(KWAIT_BLOCK))) <=
//      sizeof(PVOID) * MAXIMUM_WAIT_OBJECTS
//

#define OB_MAXIMUM_STACK_WAIT_BLOCKS    9

//
// Define the predefined handle value for the \?? directory.
//

#define ObDosDevicesDirectory()         ((HANDLE)-3)

//
// Define the predefined handle value for the \Win32NamedObjects directory.
//

#define ObWin32NamedObjectsDirectory()  ((HANDLE)-4)

//
// Prototypes.
//

BOOLEAN
ObInitSystem(
    VOID
    );

VOID
ObDissectName (
    IN OBJECT_STRING Path,
    OUT POBJECT_STRING FirstName,
    OUT POBJECT_STRING RemainingName
    );

// begin_ntddk

NTKERNELAPI
NTSTATUS
ObCreateObject(
    IN POBJECT_TYPE ObjectType,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectBodySize,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObInsertObject(
    IN PVOID Object,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG ObjectPointerBias,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByHandle(
    IN HANDLE Handle,
    IN POBJECT_TYPE ObjectType OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByName(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObOpenObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType,
    OUT PHANDLE Handle
    );

NTKERNELAPI
NTSTATUS
ObReferenceObjectByName(
    IN POBJECT_STRING ObjectName,
    IN ULONG Attributes,
    IN POBJECT_TYPE ObjectType,
    IN OUT PVOID ParseContext OPTIONAL,
    OUT PVOID *Object
    );

NTKERNELAPI
VOID
ObMakeTemporaryObject(
    IN PVOID Object
    );

NTKERNELAPI
VOID
FASTCALL
ObfReferenceObject(
    IN PVOID Object
    );

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
NTSTATUS
ObReferenceObjectByPointer(
    IN PVOID Object,
    IN POBJECT_TYPE ObjectType
    );

NTKERNELAPI
VOID
FASTCALL
ObfDereferenceObject(
    IN PVOID Object
    );

#define ObDereferenceObject(Object) ObfDereferenceObject(Object)

// end_ntddk

#endif // OB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\pool.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1995  Microsoft Corporation

Module Name:

    pool.h

Abstract:

    Private executive data structures and procedure prototypes for pool
    allocation.


    There are three pool types:
        1. nonpaged,
        2. paged, and
        3. nonpagedmustsucceed.

    There is only one of each the nonpaged and nonpagedmustsucceed pools.

    There can be more than one paged pool.

Author:

    Lou Perazzoli (loup) 23-Feb-1989

Revision History:

--*/

#ifndef _POOL_
#define _POOL_

#if !DBG
#define NO_POOL_CHECKS
#endif

#if !DBG
#define NO_POOL_TAG_TRACKING
#endif

#define POOL_TYPE_MASK (3)

//
// The smallest pool block size must be a multiple of the page size.
//
// Define the block size as 32.
//

#define POOL_BLOCK_SHIFT 5

#define POOL_LIST_HEADS (PAGE_SIZE / (1 << POOL_BLOCK_SHIFT))

#define PAGE_ALIGNED(p) (!(((ULONG_PTR)p) & (PAGE_SIZE - 1)))

//
// Define page end macro.
//

#if defined(_ALPHA_) || defined(_IA64_)
#define PAGE_END(Address) (((ULONG_PTR)(Address) & (PAGE_SIZE - 1)) == (PAGE_SIZE - (1 << POOL_BLOCK_SHIFT)))
#else
#define PAGE_END(Address) (((ULONG_PTR)(Address) & (PAGE_SIZE - 1)) == 0)
#endif

//
// Define pool descriptor structure.
//

typedef struct _POOL_DESCRIPTOR {
    ULONG RunningAllocs;
    ULONG RunningDeAllocs;
    ULONG TotalPages;
    ULONG TotalBigPages;
    LIST_ENTRY ListHeads[POOL_LIST_HEADS];
} POOL_DESCRIPTOR, *PPOOL_DESCRIPTOR;

//
//      Caveat Programmer:
//
//              The pool header must be QWORD (8 byte) aligned in size.  If it
//              is not, the pool allocation code will trash the allocated
//              buffer
//
// The layout of the pool header is:
//
//         31              23         16 15             7            0
//         +----------------------------------------------------------+
//         | Current Size |  PoolType+1 |  Pool Index  |Previous Size |
//         +----------------------------------------------------------+
//         | PoolTag                                                  |
//         +----------------------------------------------------------+
//         | Zero or more longwords of pad such that the pool header  |
//         | is on a cache line boundary and the pool body is also    |
//         | on a cache line boundary.                                |
//         +----------------------------------------------------------+
//
//      PoolBody:
//
//         +----------------------------------------------------------+
//         | Used by allocator, or when free FLINK into sized list    |
//         +----------------------------------------------------------+
//         | Used by allocator, or when free BLINK into sized list    |
//         +----------------------------------------------------------+
//         ... rest of pool block...
//
//
// N.B. The size fields of the pool header are expressed in units of the
//      smallest pool block size.
//

typedef struct _POOL_HEADER {
    union {
        struct {
            UCHAR PreviousSize;
            UCHAR PoolIndex;
            UCHAR PoolType;
            UCHAR BlockSize;
        };
        ULONG Ulong1;                       // used for InterlockedCompareExchange required by Alpha
    };
    ULONG PoolTag;
} POOL_HEADER, *PPOOL_HEADER;

//
// Define size of pool block overhead.
//

#define POOL_OVERHEAD ((LONG)sizeof(POOL_HEADER))

//
// Define size of pool block overhead when the block is on a freelist.
//

#define POOL_FREE_BLOCK_OVERHEAD  (POOL_OVERHEAD + sizeof (LIST_ENTRY))

//
// Define dummy type so computation of pointers is simplified.
//

typedef struct _POOL_BLOCK {
    UCHAR Fill[1 << POOL_BLOCK_SHIFT];
} POOL_BLOCK, *PPOOL_BLOCK;

//
// Define size of smallest pool block.
//

#define POOL_SMALLEST_BLOCK (sizeof(POOL_BLOCK))

#define POOL_BUDDY_MAX  \
   (PAGE_SIZE - (POOL_OVERHEAD + POOL_SMALLEST_BLOCK ))

//++
//SIZE_T
//EX_REAL_POOL_USAGE (
//    IN SIZE_T SizeInBytes
//    );
//
// Routine Description:
//
//    This routine determines the real pool cost of the supplied allocation.
//
// Arguments
//
//    SizeInBytes - Supplies the allocation size in bytes.
//
// Return Value:
//
//    TRUE if unused segment trimming should be initiated, FALSE if not.
//
//--

#define EX_REAL_POOL_USAGE(SizeInBytes)                             \
        (((SizeInBytes) > POOL_BUDDY_MAX) ?                         \
            (ROUND_TO_PAGES(SizeInBytes)) :                         \
            (((SizeInBytes) + POOL_OVERHEAD + (POOL_SMALLEST_BLOCK - 1)) & ~(POOL_SMALLEST_BLOCK - 1)))

typedef struct _POOL_TRACKER_TABLE {
    ULONG Key;
    ULONG NonPagedAllocs;
    ULONG NonPagedFrees;
    SIZE_T NonPagedBytes;
} POOL_TRACKER_TABLE, *PPOOL_TRACKER_TABLE;

//
// N.B. The last entry of the pool tracker table is used for all overflow
//      table entries.
//

extern PPOOL_TRACKER_TABLE PoolTrackTable;

typedef struct _POOL_TRACKER_BIG_PAGES {
    PVOID Va;
    ULONG Key;
    ULONG NumberOfPages;
} POOL_TRACKER_BIG_PAGES, *PPOOL_TRACKER_BIG_PAGES;

//
// Pool specific lookaside list.
//

typedef struct _POOL_LOOKASIDE_LIST {
    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT Padding;
    ULONG TotalAllocates;
    ULONG AllocateHits;
} POOL_LOOKASIDE_LIST, *PPOOL_LOOKASIDE_LIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\pci.h ===
/*++

Module Name:

    pci.h

Abstract:

    This is the PCI bus specific header file used by device drivers.

Author:

Revision History:

--*/

#ifndef _PCI_
#define _PCI_

// begin_ntddk

//
// A PCI driver can read the complete 256 bytes of configuration
// information for any PCI device by calling:
//
//      ULONG
//      HalGetBusData (
//          IN BUS_DATA_TYPE        PCIConfiguration,
//          IN ULONG                PciBusNumber,
//          IN PCI_SLOT_NUMBER      VirtualSlotNumber,
//          IN PPCI_COMMON_CONFIG   &PCIDeviceConfig,
//          IN ULONG                sizeof (PCIDeviceConfig)
//      );
//
//      A return value of 0 means that the specified PCI bus does not exist.
//
//      A return value of 2, with a VendorID of PCI_INVALID_VENDORID means
//      that the PCI bus does exist, but there is no device at the specified
//      VirtualSlotNumber (PCI Device/Function number).
//
//

// begin_wdm begin_ntminiport begin_ntndis

typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;

// end_wdm end_ntminiport end_ntndis

        //
        // PCI to PCI Bridge
        //

        struct _PCI_HEADER_TYPE_1 {
            ULONG   BaseAddresses[PCI_TYPE1_ADDRESSES];
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            UCHAR   IOBase;
            UCHAR   IOLimit;
            USHORT  SecondaryStatus;
            USHORT  MemoryBase;
            USHORT  MemoryLimit;
            USHORT  PrefetchBase;
            USHORT  PrefetchLimit;
            ULONG   PrefetchBaseUpper32;
            ULONG   PrefetchLimitUpper32;
            USHORT  IOBaseUpper16;
            USHORT  IOLimitUpper16;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   ROMBaseAddress;
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type1;

        //
        // PCI to CARDBUS Bridge
        //

        struct _PCI_HEADER_TYPE_2 {
            ULONG   SocketRegistersBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved;
            USHORT  SecondaryStatus;
            UCHAR   PrimaryBus;
            UCHAR   SecondaryBus;
            UCHAR   SubordinateBus;
            UCHAR   SecondaryLatency;
            struct  {
                ULONG   Base;
                ULONG   Limit;
            }       Range[PCI_TYPE2_ADDRESSES-1];
            UCHAR   InterruptLine;
            UCHAR   InterruptPin;
            USHORT  BridgeControl;
        } type2;

// begin_wdm begin_ntminiport begin_ntndis

    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04


// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//

// end_ntminiport

// end_ntddk end_wdm

//
// PCI definitions for IOBase & IOLimit
// PCIBridgeIO2Base(a,b)  - convert IOBase  & IOBaseUpper16 to ULONG IOBase
// PCIBridgeIO2Limit(a,b) - convert IOLimit & IOLimitUpper6 to ULONG IOLimit
//

#define PciBridgeIO2Base(a,b)   \
        ( ((a >> 4) << 12) + (((a & 0xf) == 1) ? (b << 16) : 0) )

#define PciBridgeIO2Limit(a,b)  (PciBridgeIO2Base(a,b) | 0xfff)

#define PciBridgeMemory2Base(a)  (ULONG) ((a & 0xfff0) << 16)
#define PciBridgeMemory2Limit(a) (PciBridgeMemory2Base(a) | 0xfffff)

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1/2.BridgeControl
//

#define PCI_ENABLE_BRIDGE_PARITY_ERROR        0x0001
#define PCI_ENABLE_BRIDGE_SERR                0x0002
#define PCI_ENABLE_BRIDGE_ISA                 0x0004
#define PCI_ENABLE_BRIDGE_VGA                 0x0008
#define PCI_ENABLE_BRIDGE_MASTER_ABORT_SERR   0x0020
#define PCI_ASSERT_BRIDGE_RESET               0x0040

//
// Bit encodes for PCI_COMMON_CONFIG.u.type1.BridgeControl
//

#define PCI_ENABLE_BRIDGE_FAST_BACK_TO_BACK   0x0080

//
// Bit encodes for PCI_COMMON_CONFIG.u.type2.BridgeControl
//

#define PCI_ENABLE_CARDBUS_IRQ_ROUTING        0x0080
#define PCI_ENABLE_CARDBUS_MEM0_PREFETCH      0x0100
#define PCI_ENABLE_CARDBUS_MEM1_PREFETCH      0x0200
#define PCI_ENABLE_CARDBUS_WRITE_POSTING      0x0400

//
//  Definitions needed for Access to Hardware Type 1
//

#define PCI_TYPE1_ADDR_PORT     ((PULONG) 0xCF8)
#define PCI_TYPE1_DATA_PORT     0xCFC

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


//
//  Definitions needed for Access to Hardware Type 2
//

#define PCI_TYPE2_CSE_PORT              ((PUCHAR) 0xCF8)
#define PCI_TYPE2_FORWARD_PORT          ((PUCHAR) 0xCFA)
#define PCI_TYPE2_ADDRESS_BASE          0xC


typedef struct _PCI_TYPE2_CSE_BITS {
    union {
        struct {
            UCHAR   Enable:1;
            UCHAR   FunctionNumber:3;
            UCHAR   Key:4;
        } bits;
        UCHAR   AsUCHAR;
    } u;
} PCI_TYPE2_CSE_BITS, PPCI_TYPE2_CSE_BITS;


typedef struct _PCI_TYPE2_ADDRESS_BITS {
    union {
        struct {
            USHORT  RegisterNumber:8;
            USHORT  Agent:4;
            USHORT  AddressBase:4;
        } bits;
        USHORT  AsUSHORT;
    } u;
} PCI_TYPE2_ADDRESS_BITS, *PPCI_TYPE2_ADDRESS_BITS;


//
// Definitions for the config cycle format on the PCI bus.
//

typedef struct _PCI_TYPE0_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   Reserved2:21;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE0_CFG_CYCLE_BITS, *PPCI_TYPE0_CFG_CYCLE_BITS;

typedef struct _PCI_TYPE1_CFG_CYCLE_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:8;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_CYCLE_BITS, *PPCI_TYPE1_CFG_CYCLE_BITS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\phy.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    phy.h

Abstract:

    Interface to Ethernet transceiver code inside the ROM

Revision History:

    04/05/2001 davidx
        Created it.

--*/

#ifndef _PHY_H_
#define _PHY_H_

//
// Initialize the PHY
//
NTKERNELAPI
NTSTATUS
PhyInitialize(
    BOOL forceReset,
    VOID* param OPTIONAL
    );

//
// Get the current link state
//
NTKERNELAPI
DWORD
PhyGetLinkState(
    BOOL update
    );

#define BIT(n)                  (1u << (n))

//
// MII/PHY related declarations
//
#define MIIREG_CONTROL 0
#define MIIREG_STATUS  1
#define MIIREG_ANAR    4
#define MIIREG_LPANAR  5

#define MIICONTROL_RESET                        BIT(15)
#define MIICONTROL_LOOPBACK_ENABLED             BIT(14)
#define MIICONTROL_SPEED_SELECTION_BIT1         BIT(13)
#define MIICONTROL_ENABLE_AUTO_NEGOTIATION      BIT(12)
#define MIICONTROL_POWER_DOWN                   BIT(11)
#define MIICONTROL_ELECTRICALLY_ISOLATE_PHY     BIT(10)
#define MIICONTROL_RESTART_AUTO_NEGOTIATION     BIT(9)
#define MIICONTROL_FULL_DUPLEX_MODE             BIT(8)
#define MIICONTROL_ENABLE_COLLISION_SIGNAL_TEST BIT(7)
#define MIICONTROL_SPEED_SELECTION_BIT0         BIT(6)

#define MIISTATUS_100MBS_T4_CAPABLE             BIT(15)
#define MIISTATUS_100MBS_X_FULL_DUPLEX_CAPABLE  BIT(14)
#define MIISTATUS_100MBS_X_HALF_DUPLEX_CAPABLE  BIT(13)
#define MIISTATUS_10MBS_FULL_DUPLEX_CAPABLE     BIT(12)
#define MIISTATUS_10MBS_HALF_DUPLEX_CAPABLE     BIT(11)
#define MIISTATUS_100MBS_T2_FULL_DUPLEX_CAPABLE BIT(10)
#define MIISTATUS_100MBS_T2_HALF_DUPLEX_CAPABLE BIT(9)
#define MIISTATUS_EXTENDED_STATUS_AVAILABLE     BIT(8)
#define MIISTATUS_PREAMBLE_SUPPRESSED_FRAME_OK  BIT(6)
#define MIISTATUS_AUTO_NEGOTIATION_COMPLETE     BIT(5)
#define MIISTATUS_REMOTE_FAULT_DETECTED         BIT(4)
#define MIISTATUS_AUTO_NEGOTIATION_CAPABLE      BIT(3)
#define MIISTATUS_LINK_IS_UP                    BIT(2)
#define MIISTATUS_JABBER_DETECTED               BIT(1)
#define MIISTATUS_EXTENDED_CAPABILITIES_PRESENT BIT(0)

#define MII4_MULTIPLE_PAGES                     BIT(15)
#define MII4_REMOTE_FAULT                       BIT(13)
#define MII4_ASYMETRIC_PAUSE                    BIT(11)
#define MII4_PAUSE                              BIT(10)
#define MII4_100BASE_T4                         BIT(9)
#define MII4_100BASE_T_FULL_DUPLEX              BIT(8)
#define MII4_100BASE_T_HALF_DUPLEX              BIT(7)
#define MII4_10BASE_T_FULL_DUPLEX               BIT(6)
#define MII4_10BASE_T_HALF_DUPLEX               BIT(5)

#define XNET_ETHERNET_LINK_ACTIVE               0x01    // Ethernet cable is connected and active
#define XNET_ETHERNET_LINK_100MBPS              0x02    // Ethernet link is set to 100 Mbps
#define XNET_ETHERNET_LINK_10MBPS               0x04    // Ethernet link is set to 10 Mbps
#define XNET_ETHERNET_LINK_FULL_DUPLEX          0x08    // Ethernet link is in full duplex mode
#define XNET_ETHERNET_LINK_HALF_DUPLEX          0x10    // Ethernet link is in half duplex mode

typedef struct                              // base address 0xFEF00000
{
    DWORD intr;                             // 000
        // Interrupt register
        //  bit 7: reserved
        //  bit 6 (MINT): MII interrupt
        //  bit 5 (STINT): software timer interrupt
        //  bit 4 (TCINT): transmit complete w/o error interrupt
        //  bit 3 (TEINT): transmit complete with error interrupt
        //  bit 2 (MISS): missed a frame
        //  bit 1 (RCINT): receive complete w/o error interrupt
        //  bit 0 (REINT): receive complete with error interrupt

    #define INTR_MINT   BIT(6)
    #define INTR_STINT  BIT(5)
    #define INTR_TCINT  BIT(4)
    #define INTR_TEINT  BIT(3)
    #define INTR_MISS   BIT(2)
    #define INTR_RCINT  BIT(1)
    #define INTR_REINT  BIT(0)

    #define INTR_ALL    (INTR_MINT | \
                         INTR_TCINT | \
                         INTR_TEINT | \
                         INTR_MISS | \
                         INTR_RCINT | \
                         INTR_REINT)
    
    DWORD intr_mk;                          // 004
        // Master interrupt mask
        //  bit 7: reserved
        //  bit 6: MINT mask - 1 = enable and 0 = disable
        //  bit 5: STINT mask
        //  bit 4: TCINT mask
        //  bit 3: TEINT mask
        //  bit 2: MISS mask
        //  bit 1: RCINT mask
        //  bit 0: REINT mask

    DWORD swtr_cntl;                        // 008
        // Software timer control register
        //  bit 1 (STEN): software timer enable
        //  bit 0 (STREN): software timer reload enable

    DWORD swtr_itc;                         // 00c
        // Software timer register
        //  bit 31-16: current software timer count
        //  bit 15-0: software timer interval

    BYTE gap1[0x80 - 0x10];

    DWORD tx_cntl;                          // 080
        // Transmit control register
        //  bit 31-22: reserved
        //  bit 21 (UFLOM): underflow error mask
        //  bit 20 (TCOLM): transmit late collision mask
        //  bit 19 (LCARM): loss of carrier mask
        //  bit 18 (DEFM): deferred mask
        //  bit 17 (EXDEFM): excessive deferral mask
        //  bit 16 (RTRYM): retry error mask
        //  bit 15-12: reserved
        //  bit 11-8: maximum number of retries on collisions
        //  bit 7-6: MAC-PHY interface
        //  bit 5 (TDEFEN): two-part deferral enable
        //  bit 4 (FCSEN): FCS append enable
        //  bit 3 (PADEN): pad enable
        //  bit 2 (RTRYEN): retry enable
        //  bit 1 (HDEN): half-duplex enable
        //  bit 0: reserved
    
    #define TXCNTL_UFLOM    BIT(21)
    #define TXCNTL_TCOLM    BIT(20)
    #define TXCNTL_LCARM    BIT(19)
    #define TXCNTL_DEFM     BIT(18)
    #define TXCNTL_EXDEFM   BIT(17)
    #define TXCNTL_RTRYM    BIT(16)
    #define TXCNTL_RCSHIFT  8
    #define TXCNTL_PHYSHIFT 6
    #define TXCNTL_TDEFEN   BIT(5)
    #define TXCNTL_FCSEN    BIT(4)
    #define TXCNTL_PADEN    BIT(3)
    #define TXCNTL_RTRYEN   BIT(2)
    #define TXCNTL_HDEN     BIT(1)

    #define PHY_TYPE_MII    0
    #define TXCNTL_DEFAULT  (TXCNTL_UFLOM | \
                             TXCNTL_TCOLM | \
                             TXCNTL_LCARM | \
                             TXCNTL_EXDEFM | \
                             TXCNTL_RTRYM | \
                             TXCNTL_TDEFEN | \
                             TXCNTL_FCSEN | \
                             TXCNTL_PADEN | \
                             TXCNTL_RTRYEN | \
                             TXCNTL_HDEN | \
                             (PHY_TYPE_MII << TXCNTL_PHYSHIFT) | \
                             (15 << TXCNTL_RCSHIFT))

    DWORD tx_en;                            // 084
        // Transmit enable register
        //  bit 1: transmit enable

    #define TXEN_ENABLE     BIT(0)

    DWORD tx_sta;                           // 088
        // Transmit status register
        //  bit 31-22: reserved
        //  bit 21 (UFLO): underflow error
        //  bit 20 (TCOL): transmit late collision
        //  bit 19 (LCAR): loss of carrier
        //  bit 18 (DEF): deferred
        //  bit 17 (EXDEF): excessive deferral
        //  bit 16 (RTRY): retry error
        //  bit 15-1: reserved
        //  bit 0: transmit channel idle status
    
    #define TXSTA_UFLO      BIT(21)
    #define TXSTA_TCOL      BIT(20)
    #define TXSTA_LCAR      BIT(19)
    #define TXSTA_DEF       BIT(18)
    #define TXSTA_EXDEF     BIT(17)
    #define TXSTA_RTRY      BIT(16)
    #define TXSTA_BUSY      BIT(0)

    DWORD rx_cntl_0;                        // 08c
        // Receive control
        //  bit 31-23: reserved
        //  bit 22 (FRAMM): frame alignment error mask
        //  bit 21 (OFOLM): overflow error mask
        //  bit 20 (CRCM): FCS error mask
        //  bit 19 (LFERM): length error mask
        //  bit 18 (MAXM): maximum length error mask
        //  bit 17 (RLCOLM): receive late collision mask
        //  bit 16 (RUNTM): runt receive mask
        //  bit 15-9: reserved
        //  bit 8 (RDEFEN): receive deferral enable
        //  bit 7 (BRDIS): broadcast receive disable
        //  bit 6 (RUNTEN): runt packet receive enable
        //  bit 5 (AFEN): address filtering enable
        //  bit 4 (LBEN): loopback enable
        //  bit 3 (PAEN): pause enable
        //  bit 2 (FCSREN): FCS relay enable
        //  bit 1 (PADSEN): pad strip enable
        //  bit 0: reserved

    #define RXCNTL_FRAMM    BIT(22)
    #define RXCNTL_OFLOM    BIT(21)
    #define RXCNTL_CRCM     BIT(20)
    #define RXCNTL_LFERM    BIT(19)
    #define RXCNTL_MAXM     BIT(18)
    #define RXCNTL_RLCOLM   BIT(17)
    #define RXCNTL_RUNTM    BIT(16)
    #define RXCNTL_RDEFEN   BIT(8)
    #define RXCNTL_BRDIS    BIT(7)
    #define RXCNTL_RUNTEN   BIT(6)
    #define RXCNTL_AFEN     BIT(5)
    #define RXCNTL_LBEN     BIT(4)
    #define RXCNTL_PAEN     BIT(3)
    #define RXCNTL_FCSREN   BIT(2)
    #define RXCNTL_PADSEN   BIT(1)

    #define RXCNTL_DEFAULT  (RXCNTL_FRAMM | \
                             RXCNTL_OFLOM | \
                             RXCNTL_CRCM | \
                             RXCNTL_LFERM | \
                             RXCNTL_MAXM | \
                             RXCNTL_RLCOLM | \
                             RXCNTL_RUNTM | \
                             RXCNTL_AFEN)

    DWORD rx_cntl_1;                        // 090
        // Maximum receive frame size register

    DWORD rx_en;                            // 094
        // Receive enable register
        //  bit 1: receive enable

    #define RXEN_ENABLE     BIT(0)

    DWORD rx_sta;                           // 098
        // Receive status register
        //  bit 31-23: reserved
        //  bit 22 (FRAM): frame alignment error
        //  bit 21 (OFOL): overflow error
        //  bit 20 (CRC): FCS error
        //  bit 19 (LFER): length error
        //  bit 18 (MAX): maximum length error
        //  bit 17 (RLCOL): receive late collision
        //  bit 16 (RUNT): runt receive
        //  bit 15-1: reserved
        //  bit 0: receive channel idle status
    
    #define RXSTA_FRAM      BIT(22)
    #define RXSTA_OFLO      BIT(21)
    #define RXSTA_CRC       BIT(20)
    #define RXSTA_LFER      BIT(19)
    #define RXSTA_MAX       BIT(18)
    #define RXSTA_RLCOL     BIT(17)
    #define RXSTA_RUNT      BIT(16)
    #define RXSTA_BUSY      BIT(0)

    DWORD bkoff_cntl;                       // 09c
        // Backoff control register (for HomePNA)
        //  bit 31-16: reserved
        //  bit 15-8: slot time, 127 for IEEE 802.3
        //  bit 7-0: random seed

    #define BKOFFCNTL_RSSHIFT   0
    #define BKOFFCNTL_STSHIFT   8

    #define BKOFFCNTL_DEFAULT   ((8 << BKOFFCNTL_RSSHIFT) | \
                                 (127 << BKOFFCNTL_STSHIFT))

    DWORD tx_def;                           // 0a0
        // Transmit deferral timing register
        //  bit 31-24: reserved
        //  bit 23-16 (TIFG): number of clocks for inter-frame gap
        //      when two-part deferral is disabled
        //  bit 15-8 (TIFG2): number of clocks for the second part
        //      inter-frame gap for two-part deferral
        //  bit 7-0 (TIFG1): number of clocks for the first part
        //      inter-frame gap for two-part deferral

    #define TXDEF_GSHIFT    16
    #define TXDEF_G2SHIFT   8
    #define TXDEF_G1SHIFT   0

    // Default values for IEEE 802.3
    #define TXDEF_DEFAULT   ((15 << TXDEF_G1SHIFT) | \
                             (7 << TXDEF_G2SHIFT) | \
                             (22 << TXDEF_GSHIFT))

    DWORD rx_def;                           // 0a4
        // Receive deferral register
        //  bit 7-0 (RIFG): number of clocks for inter-frame gap
        //      when receive deferral is enabled

    #define RXDEF_DEFAULT   0x16

    DWORD uni0;                             // 0a8
        // Lower 32-bits of the unicast address

    DWORD uni1;                             // 0ac
        // Higher 16-bits of the unicast address

    DWORD mult0;                            // 0b0
        // Lower 32-bits of the multicast address

    DWORD mult1;                            // 0b4
        // Higher 16-bits of the multicast address

    DWORD mult_mk0;                         // 0b8
        // Lower 32-bits of the multicast address mask

    DWORD mult_mk1;                         // 0bc
        // Higher 16-bits of the multicast address mask

    BYTE gap2[0x100 - 0xc0];

    DWORD tx_dadr;                          // 100
        // Transmit descriptor ring physical address

    DWORD rx_dadr;                          // 104
        // Receive descriptor ring physical address

    DWORD dlen;                             // 108
        // Descriptor ring length register
        //  bit 31-26: reserved
        //  bit 25-16 (RDLEN): receive descriptor block length (-1)
        //  bit 15-10: reserved
        //  bit 9-0 (TDLEN): transmit descriptor block length (-1)

    DWORD tx_poll;                          // 10c
        // Transmit descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (TPEN): transmit poll enable
        //  bit 15-0: transmit poll interval

    DWORD rx_poll;                          // 110
        // Receive descriptor poll register
        //  bit 31-17: reserved
        //  bit 16 (RPEN): receive poll enable
        //  bit 15-0: receive poll interval
        //      this is measured in 66MHz / 15ns clock cycles

    #define RXPOLL_EN           BIT(16)
    #define RXPOLL_FREQ_100MPS  100
    #define RXPOLL_FREQ_10MPS   1000

    DWORD tx_pcnt;                          // 114
        // Current transmit poll count

    DWORD rx_pcnt;                          // 118
        // Current receive poll count

    DWORD tx_cur_dadr;                      // 11c
        // Current transmit descriptor physical address

    DWORD rx_cur_dadr;                      // 120
        // Current receive descriptor physical address

    DWORD tx_cur_prd0;                      // 124
        // Current transmit physical address

    DWORD tx_cur_prd1;                      // 128
        // bit 31-16: current status of actively transmited frame
        // bit 15-0: current number of bytes remaining

    DWORD rx_cur_prd0;                      // 12c
        // Current receive physical address

    DWORD rx_cur_prd1;                      // 130
        // bit 31-16: current status of actively received frame
        // bit 15-0: current number of bytes remaining

    DWORD tx_nxt_dadr;                      // 134
        // Next transmit descriptor physical address

    DWORD rx_nxt_dadr;                      // 138
        // Next receive descriptor physical address

    DWORD tx_fifo_wm;                       // 13c
        // Transmit FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define TXFIFOWM_HWSHIFT    16
    #define TXFIFOWM_LWSHIFT    0

    #define TXFIFOWM_DEFAULT    ((0x10 << TXFIFOWM_LWSHIFT) | \
                                 (0x30 << TXFIFOWM_HWSHIFT))

    DWORD rx_fifo_wm;                       // 140
        // Receive FIFO watermarks
        //  bit 31-24: reserved
        //  bit 23-16: High watermark
        //  bit 15-8: reserved
        //  bit 7-0: Low watermark

    #define RXFIFOWM_HWSHIFT    16
    #define RXFIFOWM_LWSHIFT    0

    #define RXFIFOWM_DEFAULT    ((0x10 << RXFIFOWM_LWSHIFT) | \
                                 (0x30 << RXFIFOWM_HWSHIFT))
    DWORD mode;                             // 144
        // Mode register
        //  bit 4: buffer management reset
        //      need to be set for >= 3.2us before it's cleared
        //  bit 3: there is no active DMA transfer in progress
        //  bit 2: disable DMA transfer
        //  bit 1 (RXDM): receive demand
        //  bit 0 (TXDM): transmit demand

    #define MODE_RESET_BUFFERS  BIT(4)
    #define MODE_DMA_IDLE       BIT(3)
    #define MODE_DISABLE_DMA    BIT(2)
    #define MODE_RXDM           BIT(1)
    #define MODE_TXDM           BIT(0)

    BYTE gap3[0x180 - 0x148];

    DWORD mintr;                            // 180
        // MII interrupt register
        //  bit 7-5: reserved
        //  bit 4 (MPDI): MII PHY detect interrupt
        //  bit 3 (MAPI): MII auto-polling interrupt
        //  bit 2 (MCCI): MII command complete interrupt
        //  bit 1 (MCCII): MII command complete internal interrupt
        //  bit 0 (MREI): MII read error interrupt
    
    #define MINTR_MPDI  BIT(4)
    #define MINTR_MAPI  BIT(3)
    #define MINTR_MCCI  BIT(2)
    #define MINTR_MCCII BIT(1)
    #define MINTR_MREI  BIT(0)

    DWORD mintr_mk;                         // 184
        // MII interrupt mask register
        //  bit 7-5: reserved
        //  bit 4: MPDI mask - 1 to enable and 0 to disable
        //  bit 3: MAPI mask
        //  bit 2: MCCI mask
        //  bit 1: MCCII mask
        //  bit 0: MREI mask

    DWORD mii_cs;                           // 188
        // MII control and status register
        //  bit 31-29: reserved
        //  bit 28-24: PHY address
        //  bit 23-21: reserved
        //  bit 20 (APEN): auto-polling enable
        //  bit 19-16 (APTI): auto-polling time interval
        //  bit 15 (T4): 100BASE-T4
        //  bit 14 (XFD): 100BASE-X full duplex
        //  bit 13 (XHD): 100BASE-X half duplex
        //  bit 12 (10FD): 10Mb/s full-duplex
        //  bit 11 (10HD): 10Mb/s half-duplex
        //  bit 10 (ET2FD): 100BASE-T2 full-duplex
        //  bit 9 (T2HD): 100BASE-T2 half-duplex
        //  bit 8 (EXST): extended status
        //  bit 7: reserved
        //  bit 6 (MFPS): MF preamble suppression
        //  bit 5 (ANC): auto negotiation complete
        //  bit 4 (RF): remote fault
        //  bit 3 (ANA): auto-negotiation ability
        //  bit 2 (LS): link status
        //  bit 1 (JD): Jabber detect
        //  bit 0 (EC): extended capability
    
    #define MIICS_PADRSHIFT 24
    #define MIICS_APEN      BIT(20)
    #define MIICS_APSHIFT   16
    #define MIICS_T4        BIT(15)
    #define MIICS_XFD       BIT(14)
    #define MIICS_XHD       BIT(13)
    #define MIICS_10FD      BIT(12)
    #define MIICS_10HD      BIT(11)
    #define MIICS_ET2FD     BIT(10)
    #define MIICS_T2HD      BIT(9)
    #define MIICS_EXST      BIT(8)
    #define MIICS_MFPS      BIT(6)
    #define MIICS_ANC       BIT(5)
    #define MIICS_RF        BIT(4)
    #define MIICS_ANA       BIT(3)
    #define MIICS_LS        BIT(2)
    #define MIICS_JD        BIT(1)
    #define MIICS_EC        BIT(0)

    #define PHY_ADDR        1
    #define MIICS_DEFAULT   ((PHY_ADDR << MIICS_PADRSHIFT) | \
                             (4 << MIICS_APSHIFT) | \
                             MIICS_APEN)

    DWORD mii_tm;                           // 18c
        // MII clock timer register
        //  bit 15: MII timer status
        //  bit 14-9: reserved
        //  bit 8: MII timer enable
        //  bit 7-0: MII timer interval

    #define MIITM_BUSY      BIT(15)
    #define MIITM_EN        BIT(8)
    #define MIITM_TISHIFT   0

    #define MIITM_INTERVAL  5
    #define MIITM_DEFAULT   ((MIITM_INTERVAL << MIITM_TISHIFT) | MIITM_EN)
    #define PHYRW_TIMEOUT   ((64*2*2*400*MIITM_INTERVAL/1000)*16)

    DWORD mdio_adr;                         // 190
        // MDIO address register
        //  bit 15 (MDLK): MDIO lock
        //  bit 14-11: reserved
        //  bit 10 (MDRW): MDIO read/write
        //  bit 9-5 (PHYADR): physical address of the PHY to be accessed
        //  bit 4-0 (PHYREG): register address of the PHY to be accessed

    #define MDIOADR_LOCK        BIT(15)
    #define MDIOADR_WRITE       BIT(10)
    #define MDIOADR_PHYSHIFT    5
    #define MDIOADR_REGSHIFT    0

    DWORD mdio_data;                        // 194
        // MDIO data register
        //  bit 15-0 (PHYD): data for the last PHY read/write access

    BYTE gap4[0x200 - 0x198];

    DWORD pm_cntl;                          // 200
        // Power management control register

    struct {
        DWORD crc;
        DWORD mask0;
        DWORD mask1;
        DWORD mask2;
        DWORD mask3;
    } pmc_crc[5];
        // Pattern match CRC registers

    DWORD pmc_alias;
        // PCI power management register 0 alias

    DWORD pmcsr_alias;
        // PCI power management register 1 alias
} volatile * PNICCSR;

#define PNicCsr() ((PNICCSR)XPCICFG_NIC_MEMORY_REGISTER_BASE_0)

#endif // !_PHY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\segalpc.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    segalpc.h

Abstract:

    This module defines the constants used for accessing the SEGA LPC register
    space.

--*/

#ifndef _SEGALPC_
#define _SEGALPC_

//
// Define the base address of the SEGA LPC register space.
//

#define SEGA_REGISTER_BASE                          0x4000

//
// Define the layout of the SEGA LPC register space.
//

#define SEGA_REGISTER_RUAP                          (SEGA_REGISTER_BASE + 0x00)
#define SEGA_REGISTER_RLAP                          (SEGA_REGISTER_BASE + 0x02)
#define SEGA_REGISTER_RDP                           (SEGA_REGISTER_BASE + 0x04)
#define SEGA_REGISTER_DMUAP                         (SEGA_REGISTER_BASE + 0x06)
#define SEGA_REGISTER_DMLAP                         (SEGA_REGISTER_BASE + 0x08)
#define SEGA_REGISTER_LAN_GR0                       (SEGA_REGISTER_BASE + 0x1E)
#define SEGA_REGISTER_LAN_GR1                       (SEGA_REGISTER_BASE + 0x20)
#define SEGA_REGISTER_LAN_GR2                       (SEGA_REGISTER_BASE + 0x22)
#define SEGA_REGISTER_LAN_GR3                       (SEGA_REGISTER_BASE + 0x24)
#define SEGA_REGISTER_LAN_CNT0                      (SEGA_REGISTER_BASE + 0x26)
#define SEGA_REGISTER_INTERRUPT_MASK                (SEGA_REGISTER_BASE + 0x80)
#define SEGA_REGISTER_LED                           (SEGA_REGISTER_BASE + 0x82)
#define SEGA_REGISTER_DIP_SWITCH                    (SEGA_REGISTER_BASE + 0x84)
#define SEGA_REGISTER_G1_PIO_CTRL                   (SEGA_REGISTER_BASE + 0x86)
#define SEGA_REGISTER_G1_DMA_CTRL                   (SEGA_REGISTER_BASE + 0x88)
#define SEGA_REGISTER_DMAAP_WRITE_MASK              (SEGA_REGISTER_BASE + 0x8A)
#define SEGA_REGISTER_INTERRUPT_SELECT              (SEGA_REGISTER_BASE + 0x8E)
#define SEGA_REGISTER_DIMM_RESET                    (SEGA_REGISTER_BASE + 0x90)
#define SEGA_REGISTER_CHIP_REVISION                 (SEGA_REGISTER_BASE + 0xF0)
#define SEGA_REGISTER_DIMM_SIZE                     (SEGA_REGISTER_BASE + 0xF4)

//
// Define the register masks for SEGA_REGISTER_CHIP_REVISION.
//

#define SEGA_CHIP_REVISION_CHIP_ID_MASK             0xFF00
#define SEGA_CHIP_REVISION_REVISION_ID_MASK         0x00FF

//
// Define the chip identifier codes.
//

#define SEGA_CHIP_REVISION_FPGA_CHIP_ID             0x0000
#define SEGA_CHIP_REVISION_ASIC_CHIP_ID             0x0100

//
// Define the register masks for SEGA_REGISTER_DIMM_SIZE.
//

#define SEGA_DIMM_SIZE_SIZE_MASK                    0x0003

//
// Define the memory size codes.
//

#define SEGA_DIMM_SIZE_128M                         0x0000
#define SEGA_DIMM_SIZE_256M                         0x0001
#define SEGA_DIMM_SIZE_512M                         0x0002
#define SEGA_DIMM_SIZE_1024M                        0x0003

#endif  // SEGALPC
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\shahmac.h ===
/*++

Copyright (c) Microsoft Corporation

Description:
	Definition of routines to calculate an SHA HMAC
	given a material key and a series of piecemeal 
	data blobs

Module Name:

	shahmac.h

--*/

#ifndef __SHAHMAC_H__
#define __SHAHMAC_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <xcrypt.h>

typedef BYTE XSHAHMAC_CONTEXT[XC_SERVICE_SHA_CONTEXT_SIZE];

XBOXAPI
VOID 
WINAPI 
XShaHmacInitialize(
	IN PBYTE				pbKey,
	IN DWORD				cbKey,
	IN OUT XSHAHMAC_CONTEXT	Shactx
	);

XBOXAPI
VOID
WINAPI 
XShaHmacUpdate(
	IN XSHAHMAC_CONTEXT	Shactx,
	IN PBYTE			pbData,
	IN DWORD			cbData
	);

XBOXAPI
VOID 
WINAPI 
XShaHmacComputeFinal(
	IN XSHAHMAC_CONTEXT	Shactx,
	IN PBYTE			pbKey,
	IN DWORD			cbKey,
	OUT PBYTE			pbHmac
	);

#ifdef __cplusplus
}
#endif

#endif // __SHAHMAC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\ps.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ps.h

Abstract:

    This module contains the process structure public data structures and
    procedure prototypes to be used within the NT system.

Author:

    Mark Lucovsky       16-Feb-1989

Revision History:

--*/

#ifndef _PS_
#define _PS_

//
// Specifies the base address of XBOXKRNL.EXE.
//

#define PsNtosImageBase ((PVOID)0x80010000)

//
// Thread Object
//
// Thread object body.  A pointer to this structure is returned when a handle
// to a thread object is referenced.  This structure contains a thread control
// block (TCB) which is the kernel's representation of a thread.
//
// If you remove a field from this structure, please also
// remove the reference to it from within the kernel debugger
// (nt\private\sdktools\ntsd\ntkext.c)
//

typedef struct _ETHREAD {
    KTHREAD Tcb;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER ExitTime;

    union {
        NTSTATUS ExitStatus;
        PVOID OfsChain;       // needed for the nt build of the C runtime
    };
    union {
        LIST_ENTRY ReaperListEntry;
        LIST_ENTRY ActiveTimerListHead;
    };
    HANDLE UniqueThread;
    PVOID StartAddress;

    //
    // Io
    //

    LIST_ENTRY IrpList;

#ifdef DEVKIT
    //
    // Dm
    //
    // keep this at the end so kd exts don't get confused
    //

    PVOID DebugData;
#endif
} ETHREAD, *PETHREAD;

//
// Global Variables
//

extern LIST_ENTRY PsReaperListHead;
extern KDPC PsReaperDpc;

BOOLEAN
PsInitSystem (
    VOID
    );

//
// Get Gurrent Prototypes
//

#define THREAD_TO_PROCESS(thread) ((thread)->Tcb.ApcState.Process)

#define PsGetCurrentProcess() (KeGetCurrentThread()->ApcState.Process)

#define PsGetCurrentThread() (CONTAINING_RECORD((KeGetCurrentThread()),ETHREAD,Tcb))

#define PsGetCurrentThreadId() (PsGetCurrentThread()->UniqueThread)

// begin_ntddk begin_wdm
//
// System Thread and Process Creation and Termination
//

NTKERNELAPI
NTSTATUS
PsCreateSystemThread(
    OUT PHANDLE ThreadHandle,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN DebuggerThread
    );

NTKERNELAPI
NTSTATUS
PsCreateSystemThreadEx(
    OUT PHANDLE ThreadHandle,
    IN SIZE_T ThreadExtensionSize,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    OUT PHANDLE ThreadId OPTIONAL,
    IN PKSTART_ROUTINE StartRoutine,
    IN PVOID StartContext,
    IN BOOLEAN CreateSuspended,
    IN BOOLEAN DebuggerThread,
    IN PKSYSTEM_ROUTINE SystemRoutine OPTIONAL
    );

DECLSPEC_NORETURN
NTKERNELAPI
VOID
PsTerminateSystemThread(
    IN NTSTATUS ExitStatus
    );

// end_ntddk end_wdm

// begin_ntddk

typedef
VOID
(*PCREATE_THREAD_NOTIFY_ROUTINE)(
    IN PETHREAD Thread,
    IN HANDLE ThreadId,
    IN BOOLEAN Create
    );

NTSTATUS
PsSetCreateThreadNotifyRoutine(
    IN PCREATE_THREAD_NOTIFY_ROUTINE NotifyRoutine
    );

// end_ntddk

//
// BOOLEAN
// PsIsThreadTerminating(
//   IN PETHREAD Thread
//   )
//
//  Returns TRUE if thread is in the process of terminating.
//

#define PsIsThreadTerminating(T)                                            \
    (T)->Tcb.HasTerminated

//
// Cid
//

#if !defined(_NTSYSTEM_)
#define PsLookupThreadByThreadId(ThreadId, Thread) \
    ObReferenceObjectByHandle(ThreadId, PsThreadObjectType, Thread);
#else
#define PsLookupThreadByThreadId(ThreadId, Thread) \
    ObReferenceObjectByHandle(ThreadId, &PsThreadObjectType, Thread);
#endif

//
// Process statistics.
//

typedef struct _PS_STATISTICS {
    ULONG Length;
    ULONG ThreadCount;
    ULONG HandleCount;
} PS_STATISTICS, *PPS_STATISTICS;

NTKERNELAPI
NTSTATUS
PsQueryStatistics(
    IN OUT PPS_STATISTICS ProcessStatistics
    );

#endif // _PS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\xapidrv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    xapidrv.h

Abstract:

    XAPI methods exposed for use of drivers.

--*/

#ifndef _XAPIDRV_H_
#define _XAPIDRV_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Define API decoration for direct importing of DLL references.
//

#if !defined(_XAPI_)
#define XAPIDRVAPI DECLSPEC_IMPORT
#else
#define XAPIDRVAPI
#endif

//---------------------------------------------------------------------------------------------------------------
//  XAPI Driver APIS for reporting USB devices
//---------------------------------------------------------------------------------------------------------------
XAPIDRVAPI
VOID XdReportDeviceInsertionRemoval(
    PXPP_DEVICE_TYPE XppDeviceType,
    ULONG PortBit,
    BOOLEAN fInserted
    );

#define XDEVICE_ILLEGAL_PORT 32

#ifdef __cplusplus
}
#endif

#endif //_XAPIDRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\videoagp.h ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    videoagp.h

Abstract:
    Video miniport AGP support.

Notes:

Revision History:

--*/

#ifndef __VIDEOAGP_H__
#define __VIDEOAGP_H__

typedef
PHYSICAL_ADDRESS
(*PAGP_RESERVE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN ULONG Pages,
    IN ULONG Caching,
    OUT PVOID *PhysicalReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext
    );

typedef
BOOLEAN
(*PAGP_COMMIT_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_PHYSICAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID PhysicalReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
PVOID
(*PAGP_RESERVE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN HANDLE ProcessHandle,
    IN PVOID PhysicalReserveContext,
    OUT PVOID *VirtualReserveContext
    );

typedef
VOID
(*PAGP_RELEASE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext
    );

typedef
PVOID
(*PAGP_COMMIT_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef
VOID
(*PAGP_FREE_VIRTUAL)(
    IN PVOID HwDeviceExtension,
    IN PVOID VirtualReserveContext,
    IN ULONG Pages,
    IN ULONG Offset
    );

typedef struct _VIDEO_PORT_AGP_SERVICES
{
    PAGP_RESERVE_PHYSICAL AgpReservePhysical;
    PAGP_RELEASE_PHYSICAL AgpReleasePhysical;
    PAGP_COMMIT_PHYSICAL  AgpCommitPhysical;
    PAGP_FREE_PHYSICAL    AgpFreePhysical;

    PAGP_RESERVE_VIRTUAL  AgpReserveVirtual;
    PAGP_RELEASE_VIRTUAL  AgpReleaseVirtual;
    PAGP_COMMIT_VIRTUAL   AgpCommitVirtual;
    PAGP_FREE_VIRTUAL     AgpFreeVirtual;
    ULONGLONG AllocationLimit;

} VIDEO_PORT_AGP_SERVICES, *PVIDEO_PORT_AGP_SERVICES;

BOOLEAN
VideoPortGetAgpServices(
    IN PVOID HwDeviceExtension,
    IN PVIDEO_PORT_AGP_SERVICES AgpServices
    );

#endif // ifndef __VIDEOAGP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\smcdef.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    smcdef.h

Abstract:

    This module defines the constants used for accessing the System Management
    Controller (SMC).

--*/

#ifndef _SMCDEF_
#define _SMCDEF_

//
// Define the SMBus slave address of the System Management Controller.
//

#define SMC_SLAVE_ADDRESS                           0x20

//
// Define the command codes for the System Management Controller.
//

#define SMC_COMMAND_FIRMWARE_REVISION               0x01
#define SMC_COMMAND_RESET                           0x02
#define SMC_COMMAND_TRAY_STATE                      0x03
#define SMC_COMMAND_VIDEO_MODE                      0x04
#define SMC_COMMAND_FAN_OVERRIDE                    0x05
#define SMC_COMMAND_REQUEST_FAN_SPEED               0x06
#define SMC_COMMAND_LED_OVERRIDE                    0x07
#define SMC_COMMAND_LED_STATES                      0x08
#define SMC_COMMAND_CPU_TEMPERATURE                 0x09
#define SMC_COMMAND_AIR_TEMPERATURE                 0x0A
#define SMC_COMMAND_AUDIO_CLAMP                     0x0B
#define SMC_COMMAND_DVD_TRAY_OPERATION              0x0C
#define SMC_COMMAND_OS_RESUME                       0x0D
#define SMC_COMMAND_WRITE_ERROR_CODE                0x0E
#define SMC_COMMAND_READ_ERROR_CODE                 0x0F
#define SMC_COMMAND_READ_FAN_SPEED                  0x10
#define SMC_COMMAND_INTERRUPT_REASON                0x11
#define SMC_COMMAND_WRITE_RAM_TEST_RESULTS          0x12
#define SMC_COMMAND_WRITE_RAM_TYPE                  0x13
#define SMC_COMMAND_READ_RAM_TEST_RESULTS           0x14
#define SMC_COMMAND_READ_RAM_TYPE                   0x15
#define SMC_COMMAND_LAST_REGISTER_WRITTEN           0x16
#define SMC_COMMAND_LAST_BYTE_WRITTEN               0x17
#define SMC_COMMAND_SOFTWARE_INTERRUPT              0x18
#define SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN     0x19
#define SMC_COMMAND_OS_READY                        0x1A
#define SMC_COMMAND_SCRATCH                         0x1B

//
// Define the register flags for SMC_COMMAND_RESET.
//

#define SMC_RESET_ASSERT_RESET                      0x01
#define SMC_RESET_ASSERT_POWERCYCLE                 0x40
#define SMC_RESET_ASSERT_SHUTDOWN                   0x80

//
// Define the register flags for SMC_COMMAND_TRAY_STATE.
//

#define SMC_TRAY_STATE_ACTIVITY                     0x01
#define SMC_TRAY_STATE_STATE_MASK                   0x70
#define SMC_TRAY_STATE_CLOSED                       0x00
#define SMC_TRAY_STATE_OPEN                         0x10
#define SMC_TRAY_STATE_UNLOADING                    0x20
#define SMC_TRAY_STATE_OPENING                      0x30
#define SMC_TRAY_STATE_NO_MEDIA                     0x40
#define SMC_TRAY_STATE_CLOSING                      0x50
#define SMC_TRAY_STATE_MEDIA_DETECT                 0x60
#define SMC_TRAY_STATE_RESET                        0x70

//
// Define the register flags for SMC_COMMAND_VIDEO_MODE.
//

#define SMC_VIDEO_MODE_VMODE_MASK                   0x07
#define SMC_VIDEO_MODE_VMODE0                       0x01
#define SMC_VIDEO_MODE_VMODE1                       0x02
#define SMC_VIDEO_MODE_VMODE2                       0x04
#define SMC_VIDEO_MODE_SCART                        0x00
#define SMC_VIDEO_MODE_HDTV                         0x01
#define SMC_VIDEO_MODE_VGA                          0x02
#define SMC_VIDEO_MODE_RFU                          0x03
#define SMC_VIDEO_MODE_SVIDEO                       0x04
#define SMC_VIDEO_MODE_STANDARD                     0x06
#define SMC_VIDEO_MODE_NONE                         0x07

//
// Define the register flags for SMC_COMMAND_FAN_OVERRIDE.
//

#define SMC_FAN_OVERRIDE_DEFAULT                    0x00
#define SMC_FAN_OVERRIDE_USE_REQUESTED_FAN_SPEED    0x01

//
// Define the register flags for SMC_COMMAND_LED_OVERRIDE.
//

#define SMC_LED_OVERRIDE_DEFAULT                    0x00
#define SMC_LED_OVERRIDE_USE_REQUESTED_LED_STATES   0x01

//
// Define the register flags for SMC_COMMAND_LED_STATES.
//

#define SMC_LED_STATES_GREEN_STATE0                 0x01
#define SMC_LED_STATES_GREEN_STATE1                 0x02
#define SMC_LED_STATES_GREEN_STATE2                 0x04
#define SMC_LED_STATES_GREEN_STATE3                 0x08
#define SMC_LED_STATES_RED_STATE0                   0x10
#define SMC_LED_STATES_RED_STATE1                   0x20
#define SMC_LED_STATES_RED_STATE2                   0x40
#define SMC_LED_STATES_RED_STATE3                   0x80

//
// Define the register flags for SMC_COMMAND_AUDIO_CLAMP.
//

#define SMC_AUDIO_CLAMP_RELEASE                     0x00
#define SMC_AUDIO_CLAMP_CLAMP                       0x01

//
// Define the register flags for SMC_COMMAND_DVD_TRAY_OPERATION.
//

#define SMC_DVD_TRAY_OPERATION_OPEN                 0x00
#define SMC_DVD_TRAY_OPERATION_CLOSE                0x01

//
// Define the register flags for SMC_COMMAND_OS_RESUME.
//

#define SMC_OS_RESUME_SHUTDOWN_COMPLETE             0x01
#define SMC_OS_RESUME_SHUTDOWN_IN_PROGRESS          0x02
#define SMC_OS_RESUME_RESUME                        0x04
#define SMC_OS_RESUME_REBOOT                        0x08

//
// Define the register flags for SMC_COMMAND_INTERRUPT_REASON.
//

#define SMC_INTERRUPT_REASON_SHUTDOWN               0x01
#define SMC_INTERRUPT_REASON_TRAY_DETECTED          0x02
#define SMC_INTERRUPT_REASON_TRAY_OPENED            0x04
#define SMC_INTERRUPT_REASON_NEW_AV_PACK            0x08
#define SMC_INTERRUPT_REASON_NO_AV_PACK             0x10
#define SMC_INTERRUPT_REASON_TRAY_EJECT             0x20
#define SMC_INTERRUPT_REASON_TRAY_CLOSED            0x40

//
// Define the register values for SMC_COMMAND_OVERRIDE_RESET_ON_TRAY_OPEN.
//

#define SMC_RESET_ON_TRAY_OPEN_SECURE_MODE          0x00
#define SMC_RESET_ON_TRAY_OPEN_NONSECURE_MODE       0x01

//
// Define the register flags for SMC_COMMAND_OS_READY.
//

#define SMC_OS_READY_READY                          0x01

//
// Define the register flags for SMC_COMMAND_SCRATCH.  This register is defined
// by the operating system, so these flags can be freely added to or modified.
//

#define SMC_SCRATCH_TRAY_EJECT_PENDING              0x01
#define SMC_SCRATCH_DISPLAY_FATAL_ERROR             0x02
#define SMC_SCRATCH_SHORT_ANIMATION                 0x04
#define SMC_SCRATCH_DASHBOARD_BOOT                  0x08

#endif  // SMCDEF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\vid.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    vid.h

Abstract:

    This module contains the public data structures and procedure
    prototypes for video APIs exported from NTOS


--*/

#ifndef _VID_H
#define _VID_H


#define VID_NVNOTIFICATION_SIZE               (16)
#define VID_NVNOTIFICATION_DMA_BUFFER_SIZE    (VID_NVNOTIFICATION_SIZE * 32)


//
// Structure to describe video mode information
//

typedef struct _VIDEO_MODE_DATA
{
    LONG  Width; 
    LONG  Height; 
    LONG  BitDepth;
    ULONG PushBase;
    ULONG PushLimit;
    ULONG NotificationBase; 
    ULONG NotificationLimit;
    ULONG HostMemoryBase;
    ULONG HostMemoryLimit;

    PVOID VidMemAddress;   // returned by VidSetVideoMode
    PVOID NvBase;          // returned by VidSetVideoMode

} VIDEO_MODE_DATA, *PVIDEO_MODE_DATA;



NTSTATUS
VidSetVideoMode(
    IN OUT PVIDEO_MODE_DATA ModeData,
    OUT PVOID* DevFlatDma
    );


#endif // _VID_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\xconfig.h ===
#ifndef _XCONFIG_H_
#define _XCONFIG_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  Define the FAT32 X-Box config sector
//
typedef struct _XBOX_CONFIG_SECTOR {
    ULONG SectorBeginSignature;                     // offset = 0x000   0
    ULONG Version;                                  // offset = 0x004   4
    ULONG SectorCount;                              // offset = 0x008   8
    UCHAR Data[492];                                // offset = 0x00c  12
    ULONG Checksum;                                 // offset = 0x1f8 504
    ULONG SectorEndSignature;                       // offset = 0x1fc 508
} XBOX_CONFIG_SECTOR, *PXBOX_CONFIG_SECTOR;

#define XBOX_CONFIG_SECTOR_BEGIN_SIGNATURE   0x79132568
#define XBOX_CONFIG_SECTOR_END_SIGNATURE     0xAA550000
#define XBOX_CONFIG_VERSION                  0x00000001
#define XBOX_CONFIG_SECTOR_COUNT             0x00000001

#define XBOX_CONFIG_DATA_SIZE      (sizeof(((PXBOX_CONFIG_SECTOR) 0)->Data))
#define XBOX_HD_SECTOR_SIZE        512

#define XBOX_BOOT_SECTOR_INDEX     0

#define XBOX_CACHE_DB_SECTOR_INDEX 4
#define XBOX_CONFIG_SECTOR_INDEX   8
#define XBOX_NUM_CONFIG_SECTORS    8

//
// Compute 32-bit 1's complement sum
//  NOTE: It'd be nice to make this a __fastcall.
//  But it doesn't work because of some compiler problems.
//
#pragma warning(push)
#pragma warning(disable:4035)
__inline ULONG XConfigChecksum(const VOID* data, ULONG count) {
    __asm {
        mov     ecx, data
        mov     edx, count
        xor     eax, eax
        xor     ebx, ebx
        shr     edx, 2      // count /= sizeof(ULONG)
        test    edx, edx
        jz      L2
    L1: add     eax, [ecx]  // eax += *data++
        adc     ebx, 0      // ebx += carry
        add     ecx, 4
        dec     edx
        jnz     L1          // while (--count)
    L2: add     eax, ebx    // take care of accumulated carries
        adc     eax, 0
    }
}
#pragma warning(pop)

//
// Refurb information sector
//
#define XBOX_REFURB_INFO_SECTOR_INDEX 3
#define XBOX_REFURB_INFO_SIGNATURE 'RFRB'

typedef struct _XBOX_REFURB_INFO {
    ULONG Signature;
    ULONG PowerCycleCount;
    LARGE_INTEGER FirstSetTime;
} XBOX_REFURB_INFO;

//
// Data layout of the non-volatile memory (EEPROM)
//
//  encrypted factory settings section:
//      programmed at factory and never changes
//      data is encrypted
//  factory settings section:
//      programmed at factory and never changes
//  user settings section:
//      can be modified by the user
//
// !!! NOTE:
//  Each section should start at 8-byte aligned EEPROM page boundary.
//  When you change the structures below in the future,
//  make sure you don't disturb the existing fields.
//
#include <PshPack1.h>

#define FIELD_SIZE(type, field) (sizeof(((type *) 0)->field))

typedef struct _XBOX_FACTORY_SETTINGS {
    ULONG Checksum;                         //  0 +  4
    UCHAR SerialNumber[12];                 //  4 + 12
    UCHAR EthernetAddr[6];                  // 16 +  6
    UCHAR Reserved1[2];                     // 22 +  2
    UCHAR OnlineKey[16];                    // 24 + 16
    ULONG AVRegion;                         // 40 +  4
    ULONG Reserved2;                        // 44 +  4
} XBOX_FACTORY_SETTINGS;                    // 48

// Compressed timezone date representation
// (4 bytes instead of 16 bytes for SYSTEMTIME)
typedef struct _XBOX_TIMEZONE_DATE {
    UCHAR Month;            // 0 = unspecified time zone info
    UCHAR Day;
    UCHAR DayOfWeek;
    UCHAR Hour;
} XBOX_TIMEZONE_DATE;

#define XC_TZNAMELEN 4
typedef struct _XBOX_USER_SETTINGS {
    ULONG Checksum;                         //  0 +  4
    LONG TimeZoneBias;                      //  4 +  4
    CHAR TimeZoneStdName[XC_TZNAMELEN];     //  8 +  4
    CHAR TimeZoneDltName[XC_TZNAMELEN];     // 12 +  4
    ULONG Reserved1[2];                     // 16 +  8
    XBOX_TIMEZONE_DATE TimeZoneStdDate;     // 24 +  4
    XBOX_TIMEZONE_DATE TimeZoneDltDate;     // 28 +  4
    ULONG Reserved2[2];                     // 32 +  8
    LONG TimeZoneStdBias;                   // 40 +  4
    LONG TimeZoneDltBias;                   // 44 +  4
    ULONG Language;                         // 48 +  4
    ULONG VideoFlags;                       // 52 +  4
    ULONG AudioFlags;                       // 56 +  4
    ULONG ParentalControlGames;             // 60 +  4
    ULONG ParentalControlPassword;          // 64 +  4
    ULONG ParentalControlMovies;            // 68 +  4
    ULONG OnlineIpAddress;                  // 72 +  4
    ULONG OnlineDnsAddress;                 // 76 +  4
    ULONG OnlineDefaultGatewayAddress;      // 80 +  4
    ULONG OnlineSubnetMask;                 // 84 +  4
    ULONG MiscFlags;                        // 88 +  4
    ULONG DvdRegion;                        // 92 +  4
} XBOX_USER_SETTINGS;                       // 96


typedef struct _XBOX_UEM_INFO {
    UCHAR  LastCode;
    UCHAR  Reserved1;
    USHORT History;
} XBOX_UEM_INFO;


#define EEPROM_ENCRYPTED_SECTION_START      FIELD_OFFSET(EEPROM_LAYOUT, EncryptedSection)
#define EEPROM_ENCRYPTED_SECTION_SIZE       48
#define EEPROM_FACTORY_SECTION_START        FIELD_OFFSET(EEPROM_LAYOUT, FactorySection)
#define EEPROM_FACTORY_SECTION_SIZE         sizeof(XBOX_FACTORY_SETTINGS)
#define EEPROM_USER_SECTION_START           FIELD_OFFSET(EEPROM_LAYOUT, UserConfigSection)
#define EEPROM_USER_SECTION_SIZE            sizeof(XBOX_USER_SETTINGS)
#define EEPROM_TOTAL_MEMORY_SIZE            256
#define EEPROM_PAGE_ALIGNMENT               8

typedef struct _EEPROM_LAYOUT {
    UCHAR EncryptedSection[EEPROM_ENCRYPTED_SECTION_SIZE];
    UCHAR FactorySection[EEPROM_FACTORY_SECTION_SIZE];
    UCHAR UserConfigSection[EEPROM_USER_SECTION_SIZE];
    UCHAR Unused[58];
    UCHAR UEMInfo[4];
    UCHAR Reserved1[2];   // Reserved for manufacturing
} EEPROM_LAYOUT;

// Check if the time zone information is invalid
#define XBOX_INVALID_TIMEZONE_SETTING(userSettings) \
        ((userSettings).TimeZoneStdName[0] == '\0')

// Convert the timezone name stored in the EEPROM to/from Unicode string
__inline VOID XboxTimeZoneNameToWstr(const CHAR* tzname, WCHAR* wstr)
{
    ULONG count = XC_TZNAMELEN;
    while (count--)
        *wstr++ = (WCHAR) ((UCHAR) *tzname++);
    *wstr = L'\0';
}

__inline VOID WstrToXboxTimeZoneName(const WCHAR* wstr, CHAR* tzname)
{
    ULONG count = XC_TZNAMELEN;
    while (count--)
        *tzname++ = (CHAR) *wstr++;
}

//
// Encrypted section of the EEPROM
//
typedef struct _XBOX_ENCRYPTED_SETTINGS {
    UCHAR Checksum[20];                     //  0 + 20
    UCHAR Confounder[8];                    // 20 +  8
    UCHAR HDKey[XBOX_KEY_LENGTH];           // 28 + 16
    ULONG GameRegion;                       // 44 +  4
} XBOX_ENCRYPTED_SETTINGS;                  // 48

//
// Duplicated constants from xboxp.h so that the kernel proper doesn't have to
// include XTL headers.
//

#define XC_GAME_REGION_NA             0x00000001
#define XC_GAME_REGION_JAPAN          0x00000002
#define XC_GAME_REGION_RESTOFWORLD    0x00000004
#define XC_GAME_REGION_INTERNAL_TEST  0x40000000
#define XC_GAME_REGION_MANUFACTURING  0x80000000

#include <PopPack.h>

//
// Private kernel functions for querying or saving non-volatile settings
//
NTSTATUS
ExQueryNonVolatileSetting(
    IN ULONG ValueIndex,
    OUT ULONG* Type,
    OUT VOID* Value,
    IN ULONG ValueLength,
    OUT ULONG* ResultLength
    );

NTSTATUS
ExSaveNonVolatileSetting(
    IN ULONG ValueIndex,
    IN ULONG Type,
    IN const VOID* Value,
    IN ULONG ValueLength
    );

//
// Private function for reading/writing refurb information
//
NTSTATUS
ExReadWriteRefurbInfo(
    OUT XBOX_REFURB_INFO* RefurbInfo,
    IN ULONG ValueLength,
    BOOLEAN DoWrite
    );

#ifdef __cplusplus
}
#endif

#endif // ! _XCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\xdisk.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xdisk.h

Abstract:

    This module defines the disk configuration for an XBOX hard disk.

--*/

#ifndef _XDISK_
#define _XDISK_

//
// Define the size of a sector on an XBOX hard disk.
//

#define XDISK_SECTOR_SIZE                   512

//
// Define the number of unpartitioned sectors reserved at the start of the disk.
// These sectors are used for various purposes such as storing data that should
// not be visible from the file system.
//

#define XDISK_UNPARTITIONED_SECTORS         1024
#define XDISK_UNPARTITIONED_SIZE            (XDISK_UNPARTITION_SECTORS * XDISK_SECTOR_SIZE)

//
// Define the number of sectors in the shell partition (partition 2).
//

#define XDISK_SHELL_PARTITION_SECTORS       1024000
#define XDISK_SHELL_PARTITION_SIZE          (XDISK_SHELL_PARTITION_SECTORS * XDISK_SECTOR_SIZE)

//
// Define the number of sectors in each cache partition (partitions 3 to N).
//

#define XDISK_CACHE_PARTITION_SECTORS       1536000
#define XDISK_CACHE_PARTITION_SIZE          (XDISK_CACHE_PARTITION_SECTORS * XDISK_SECTOR_SIZE)

//
// Define the formula used to compute the number of cache partitions given the
// number of user addressable sectors for the disk.
//

#define XDISK_NUMBER_OF_CACHE_PARTITIONS(UserAddressableSectors) \
    ((((UserAddressableSectors) / 200 * 73) - \
    (XDISK_UNPARTITIONED_SECTORS + XDISK_SHELL_PARTITION_SECTORS)) / \
    XDISK_CACHE_PARTITION_SECTORS)

//
// Define the static partition numbers.
//

#define XDISK_DATA_PARTITION                1
#define XDISK_SHELL_PARTITION               2
#define XDISK_FIRST_CACHE_PARTITION         3
#define XDISK_F_PARTITION					6
//
// Define the static number of sectors allowed for an XBOX hard disk.
//

#define XDISK_FIXED_SECTOR_COUNT            15633072

#endif  // XDISK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\v86emul.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989  Microsoft Corporation

Module Name:

    v86emul.h

Abstract:

    This module contains the V86 instruction emulator interface definitions
    used by kernel device drivers.

Author:

    Andre Vachon (andreva) 8-Jan-1992

Revision History:


--*/

#ifndef _V86EMUL_
#define _V86EMUL_


// begin_ntminiport

//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;

// end_ntminiport

//
// These are the various function prototypes of the routines that are
// provided by the kernel driver to hook out access to io ports.
//

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_UCHAR_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUCHAR Data,
    IN ULONG DataLength
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_USHORT_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PUSHORT Data,
    IN ULONG DataLength // number of words
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data
    );

typedef
NTSTATUS
(*PDRIVER_IO_PORT_ULONG_STRING ) (
    IN ULONG_PTR Context,
    IN ULONG Port,
    IN UCHAR AccessMode,
    IN OUT PULONG Data,
    IN ULONG DataLength  // number of dwords
    );

#endif // _V86EMUL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\xlaunch.h ===
#ifndef _XLAUNCH_H_
#define _XLAUNCH_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000
#endif  // ! PAGE_SIZE

#define MAX_LAUNCH_PATH       (260 + 100)
#define TITLE_PATH_DELIMITER  OTEXT(';')

//
// This is also defined in xbox.h
//

#define MAX_LAUNCH_DATA_SIZE 3072

#define LDT_LAUNCH_DASHBOARD 1
#define LDT_NONE             0xFFFFFFFF

#define LDF_HAS_BEEN_READ    0x00000001

typedef struct _LAUNCH_DATA_HEADER
{
    ULONG dwLaunchDataType;
    ULONG dwTitleId;
    CHAR  szLaunchPath[520];
    ULONG dwFlags;
} LAUNCH_DATA_HEADER, *PLAUNCH_DATA_HEADER;

typedef struct _LAUNCH_DATA_PAGE
{
    LAUNCH_DATA_HEADER Header;
    UCHAR Pad[PAGE_SIZE - MAX_LAUNCH_DATA_SIZE - sizeof(LAUNCH_DATA_HEADER)];
    UCHAR LaunchData[MAX_LAUNCH_DATA_SIZE];
} LAUNCH_DATA_PAGE, *PLAUNCH_DATA_PAGE;

#if !defined(_NTSYSTEM_)
extern PLAUNCH_DATA_PAGE *LaunchDataPage;
#else
extern PLAUNCH_DATA_PAGE LaunchDataPage;
#endif

#ifdef __cplusplus
}
#endif

#endif // ! _XLAUNCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\bldnum.c ===
#include <xboxverp.h>

#pragma data_seg(".XBLD$V")

#if DBG
unsigned short XboxKrnlBuildNumber[8] = { 'X' | ('B' << 8), 'O' | ('X' << 8), 'K' | ('R' << 8), 'N' | ('L' << 8),
                                           VER_PRODUCTVERSION | 0x8000 };
#else
unsigned short XboxKrnlBuildNumber[8] = { 'X' | ('B' << 8), 'O' | ('X' << 8), 'K' | ('R' << 8), 'N' | ('L' << 8),
                                           VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\xpcicfg.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    xpcicfg.h

Abstract:

    This module defines the static PCI configuration for an XBOX.

--*/

#ifndef _XPCICFG_
#define _XPCICFG_

//
// Note that the Advanced Programmable Interrupt Controller (APIC) defaults to
// location 0xFEE00000 and consumes one page.  The kernel turns off the APIC,
// but debugger extensions (VTune) may reenable it.
//

// Bus 0, device 0, function 0.
#define XPCICFG_HOSTBRIDGE_DEVICE_ID                        0
#define XPCICFG_HOSTBRIDGE_FUNCTION_ID                      0

// Bus 0, device 1, function 0.
#define XPCICFG_LPCBRIDGE_DEVICE_ID                         1
#define XPCICFG_LPCBRIDGE_FUNCTION_ID                       0
#define XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0                0x8000
#define XPCICFG_LPCBRIDGE_IO_REGISTER_LENGTH_0              0x0100

// Bus 0, device 1, function 1.
#define XPCICFG_SMBUS_DEVICE_ID                             1
#define XPCICFG_SMBUS_FUNCTION_ID                           1
#define XPCICFG_SMBUS_IO_REGISTER_BASE_1                    0xC000
#define XPCICFG_SMBUS_IO_REGISTER_LENGTH_1                  0x0010
#define XPCICFG_SMBUS_IO_REGISTER_BASE_2                    0xC200
#define XPCICFG_SMBUS_IO_REGISTER_LENGTH_2                  0x0020

// Bus 0, device 2, function 0.
#define XPCICFG_USB0_DEVICE_ID                              2
#define XPCICFG_USB0_FUNCTION_ID                            0
#define XPCICFG_USB0_IRQ                                    1
#define XPCICFG_USB0_MEMORY_REGISTER_BASE_0                 0xFED00000
#define XPCICFG_USB0_MEMORY_REGISTER_LENGTH_0               0x00001000

// Bus 0, device 3, function 0.
#define XPCICFG_USB1_DEVICE_ID                              3
#define XPCICFG_USB1_FUNCTION_ID                            0
#define XPCICFG_USB1_IRQ                                    9
#define XPCICFG_USB1_MEMORY_REGISTER_BASE_0                 0xFED08000
#define XPCICFG_USB1_MEMORY_REGISTER_LENGTH_0               0x00001000

// Bus 0, device 4, function 0.
#define XPCICFG_NIC_DEVICE_ID                               4
#define XPCICFG_NIC_FUNCTION_ID                             0
#define XPCICFG_NIC_IRQ                                     4
#define XPCICFG_NIC_MEMORY_REGISTER_BASE_0                  0xFEF00000
#define XPCICFG_NIC_MEMORY_REGISTER_LENGTH_0                0x00000400
#define XPCICFG_NIC_IO_REGISTER_BASE_1                      0xE000
#define XPCICFG_NIC_IO_REGISTER_LENGTH_1                    0x0008

// Bus 0, device 5, function 0.
#define XPCICFG_APU_DEVICE_ID                               5
#define XPCICFG_APU_FUNCTION_ID                             0
#define XPCICFG_APU_IRQ                                     5
#define XPCICFG_APU_MEMORY_REGISTER_BASE_0                  0xFE800000
#define XPCICFG_APU_MEMORY_REGISTER_LENGTH_0                0x00080000

// Bus 0, device 6, function 0.
#define XPCICFG_ACI_DEVICE_ID                               6
#define XPCICFG_ACI_FUNCTION_ID                             0
#define XPCICFG_ACI_IRQ                                     6
#define XPCICFG_ACI_IO_REGISTER_BASE_0                      0xD000
#define XPCICFG_ACI_IO_REGISTER_LENGTH_0                    0x0100
#define XPCICFG_ACI_IO_REGISTER_BASE_1                      0xD200
#define XPCICFG_ACI_IO_REGISTER_LENGTH_1                    0x0080
#define XPCICFG_ACI_MEMORY_REGISTER_BASE_2                  0xFEC00000
#define XPCICFG_ACI_MEMORY_REGISTER_LENGTH_2                0x00001000

// Bus 0, device 9, function 0.
#define XPCICFG_IDE_DEVICE_ID                               9
#define XPCICFG_IDE_FUNCTION_ID                             0
#define XPCICFG_IDE_IRQ                                     14
#define XPCICFG_IDE_IO_REGISTER_BASE_4                      0xFF60
#define XPCICFG_IDE_IO_REGISTER_LENGTH_4                    0x0010

// Bus 0, device 30, function 0.
#define XPCICFG_AGPBRIDGE_DEVICE_ID                         30
#define XPCICFG_AGPBRIDGE_FUNCTION_ID                       0

// Bus 1, device 0, device 0.
#define XPCICFG_GPU_DEVICE_ID                               0
#define XPCICFG_GPU_FUNCTION_ID                             0
#define XPCICFG_GPU_IRQ                                     3
#define XPCICFG_GPU_MEMORY_REGISTER_BASE_0                  0xFD000000
#define XPCICFG_GPU_MEMORY_REGISTER_LENGTH_0                0x01000000

// Map a device name to PCI slot number
#define XPCI_SLOT_NUMBER(device) \
        ((XPCICFG_##device##_DEVICE_ID) | ((XPCICFG_##device##_FUNCTION_ID) << 5))

#endif  // XPCICFG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=init

TARGETNAME=init
TARGETPATH=obj
TARGETTYPE=LIBRARY

TARGETPATH2=..\..\obj

SYNCHRONIZE_DRAIN=1
SYNCHRONIZE_BLOCK=1

INCLUDES=..;$(BASEDIR)\private\ntos\inc;$(BASEDIR)\private\genx\ntos\nls\$(O);$(BASEDIR)\private\inc\crypto;$(BASEDIR)\private\inc\aug01
GPSIZE=32

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

SOURCES=..\xboxkrnl.c \
        ..\init.c \
        ..\fatal.cpp

EXPORT_FILE=$(O)\$(NTTEST).exp

!IF defined(ARCADE)
KERNEL_LIB_SUFFIX=arc
!ELSE
KERNEL_LIB_SUFFIX=con
!ENDIF

KERNEL_LIBS = \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ex.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\halx.lib \
    $(TARGETPATH)\$(TARGET_DIRECTORY)\init.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\io.lib \
!IF !defined(NODEVKIT)
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\kd.lib \
!ELSE
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\kdlite.lib \
!ENDIF
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ke.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\mm$(KERNEL_LIB_SUFFIX).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ob.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ps.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ntosrtl.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\idex$(KERNEL_LIB_SUFFIX).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\raw.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\fatx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\gdfx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\udfx.lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\phy.lib \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\libcntpr$(D).lib \
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ldr$(KERNEL_LIB_SUFFIX).lib \
    $(BASEDIR)\private\lib\$(TARGET_DIRECTORY)\rsa32k.lib      \
    $(BASEDIR)\private\lib\$(TARGET_DIRECTORY)\xcryptk.lib     \
    $(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\randlibk.lib \
!IF !defined(ARCADE)
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\ani.lib \
!ENDIF
    $(TARGETPATH2)\$(TARGET_DIRECTORY)\av.lib

LINKLIBS = $(EXPORT_FILE)

!IF !defined(ARCADE)
LINKLIBS = $(LINKLIBS) \
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\d3d8ntpr$(D).lib \
    $(BASEDIR)\public\xdk\lib-aug01\xgraphics$(D).lib\
    $(BASEDIR)\private\lib\aug01\$(TARGET_DIRECTORY)\bootsnd$(D).lib
!ENDIF

LINKER_FLAGS=$(LINKER_FLAGS) /map
LINKER_FLAGS=$(LINKER_FLAGS) /merge:.edata=.text /merge:.XBLD=INIT
LINKER_FLAGS=$(LINKER_FLAGS) /merge:PAGER32C=.text /merge:PAGER32R=.rdata /merge:PAGER32D=.data
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\xboxkrnl.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    xboxkrnl.c

Abstract:

    Entry point for the kernel.

--*/

#include "ntos.h"
#include <bldr.h>

VOID
__cdecl
main(
    IN PUCHAR LoadOptions,
    IN const UCHAR* CryptKeys
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, main)
#endif

VOID
__cdecl
main(
    IN PUCHAR LoadOptions,
    IN const UCHAR* CryptKeys
    )
{
#ifdef DEVKIT
    //
    // Copy the load options from the boot loader to a local buffer and then
    // parse the various options and convert them to boot flags.
    //

    UCHAR buf[64];
    strncpy(buf, LoadOptions, 64);
    buf[63] = '\0';
    _strupr(buf);

    if (strstr(buf, "SHADOW") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_SHADOW;

    if (strstr(buf, "/HDBOOT") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_HDBOOT;

    if (strstr(buf, "/CDBOOT") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_CDBOOT;

    if (strstr(buf, "/DBBOOT") != NULL)
        XboxBootFlags |= XBOX_BOOTFLAG_DASHBOARDBOOT;
#endif

    //
    // Save the encryption keys that have been passed in from the boot loader.
    //

    RtlCopyMemory(XboxEEPROMKey, CryptKeys, XBOX_KEY_LENGTH);
    RtlCopyMemory(XboxCERTKey, CryptKeys + XBOX_KEY_LENGTH, XBOX_KEY_LENGTH);

    //
    // Zero out the memory used by the boot loader at its relocated origin.  The
    // original origin of the boot loader has already been overwritten by the
    // kernel image.
    //

    RtlZeroMemory((PUCHAR)MM_SYSTEM_RANGE_START + BLDR_RELOCATED_ORIGIN,
        BLDR_BLOCK_SIZE);

    //
    // Initialize the system.
    //

    KiSystemStartup();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\init.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    init.c

Abstract:

    Main source file the NTOS system initialization subcomponent.

--*/

#include "ntos.h"
#include <ntimage.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntverp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ldr.h>
#include <xbeimage.h>
#include <dm.h>
#include <xlaunch.h>
#include <ani.h>
#include <xprofp.h>
#include <bldr.h>
#include <rc4.h>
#include <xcrypt.h>
#include <smcdef.h>

#include <wtypes.h>
#include <xconfig.h>
#include <xbox.h>
#include <xboxp.h>

VOID
IdexChannelCreate(
    VOID
    );

#ifdef DEVKIT

VOID
ExpTryToBootMediaROM(
    VOID
    );

#endif

VOID
ExpDecryptEEPROM(
    VOID
    );

ULONG
ExpDetectSettingsError(
    VOID
    );

VOID
ExpCopyLastUEMError(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, ExpDecryptEEPROM)
#pragma alloc_text(INIT, ExpCopyLastUEMError)
#pragma alloc_text(INIT, ExpDetectSettingsError)
#ifdef DEVKIT
#pragma alloc_text(INIT, ExpTryToBootMediaROM)
#endif
#endif

//
// Define global static data used during initialization.
//

#if DBG
const XBOX_KRNL_VERSION XboxKrnlVersion = { VER_PRODUCTVERSION | 0x8000 };
#else
const XBOX_KRNL_VERSION XboxKrnlVersion = { VER_PRODUCTVERSION };
#endif

XBOX_HARDWARE_INFO XboxHardwareInfo;
DECLSPEC_STICKY PLAUNCH_DATA_PAGE LaunchDataPage = NULL;
DECLSPEC_STICKY ULONG XboxBootFlags;

#ifdef DEVKIT
PVOID KiDbgClockInt;
PVOID KiDbgProfInt;
PSWAP_CONTEXT_NOTIFY_ROUTINE KiDbgCtxSwapNotify;
PVOID KiDpcDispatchNotify;
DECLSPEC_STICKY BOOLEAN ExpDisableDebugMonitor;
XProfpGlobals ExpCallAttributedProfileData;

INITIALIZED_OBJECT_STRING_RDATA(ExpDVDXbdmDLL, "\\Device\\CdRom0\\xbdm.dll");
INITIALIZED_OBJECT_STRING_RDATA(ExpHDXbdmDLL, "\\Device\\Harddisk0\\Partition1\\xbdm.dll");
INITIALIZED_OBJECT_STRING_RDATA(ExpCdRomBootROMString, "\\Device\\CdRom0\\XBOXROM.BIN");
INITIALIZED_OBJECT_STRING_RDATA(ExpHardDiskBootROMString, "\\Device\\Harddisk0\\Partition1\\XBOXROM.BIN");
#endif // DEVKIT

//
// Various encryption keys used by Xbox:
//
//  EEPROM key -
//      This key is stored in the boot loader (encrypted by the master key in MCPX).
//      The boot loader passes it to the kernel on a cold reboot.
//      The kernel uses it to decrypt the encryption section of the EEPROM
//      and then throws it away (except that we need to let the manufacturing
//      program access it during the final system integration stage).
//
//  Hard disk key -
//      This key is stored in the EEPROM (encrypted by the EEPROM key above).
//
//  LAN key -
//      This key's raw data is stored in the first XBE that is run from a cold
//      boot and modified by the CERT key.
//
//  Signature key -
//      This key's raw data is stored in the first XBE that is run from a cold
//      boot and modified by the CERT key.
//
//  CERT key -
//      This key is stored in the boot loader (encrypted by the master key in MCPX).
//      The boot loader passes it to the kernel on a cold reboot.
//      It's used to decrypt keys in the title CERT header.
//
DECLSPEC_STICKY XBOX_KEY_DATA XboxEEPROMKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxHDKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxLANKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxSignatureKey;
DECLSPEC_STICKY XBOX_KEY_DATA XboxAlternateSignatureKeys[XBEIMAGE_ALTERNATE_TITLE_ID_COUNT];
DECLSPEC_STICKY XBOX_KEY_DATA XboxCERTKey;

//
// Game region setting is stored in the encrypted section
// of the EEPROM and is read into a global variable during the boot process.
//
DECLSPEC_STICKY ULONG XboxGameRegion = XC_GAME_REGION_MANUFACTURING;

VOID
ExpInitializeExecutive(
    VOID
    )
/*++

Routine Description:

    This routine is called from the kernel initialization routine during
    bootstrap to initialize the executive and all of its subcomponents.
    Each subcomponent is potentially called twice to perform phase 0, and
    then phase 1 initialization. During phase 0 initialization, the only
    activity that may be performed is the initialization of subcomponent
    specific data. Phase 0 initilaization is performed in the context of
    the kernel start up routine with initerrupts disabled. During phase 1
    initialization, the system is fully operational and subcomponents may
    do any initialization that is necessary.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the hardware information flags.
    //

#ifdef DEVKIT
    XboxHardwareInfo.Flags |= XBOX_HW_FLAG_DEVKIT_KERNEL;
#endif

#ifdef FOCUS
    XboxHardwareInfo.Flags |= XBOX_480P_MACROVISION_ENABLED;
#endif

#ifdef ARCADE
    XboxHardwareInfo.Flags |= XBOX_HW_FLAG_ARCADE;
#endif

    //
    // Initialize the Hardware Architecture Layer (HAL).
    //

    if (KeHasQuickBooted) {
        HalInitSystemPhase0Quick();
    } else {
        HalInitSystemPhase0();
    }

    //
    // Initialize the memory manager.
    //

    HalPulseHardwareMonitorPin();
    MmInitSystem();

    //
    // Initialize the object manager.
    //

    if (!ObInitSystem()) {
        KeBugCheck(OBJECT_INITIALIZATION_FAILED);
    }

    if (!PsInitSystem()) {
        KeBugCheck(PROCESS_INITIALIZATION_FAILED);
    }
}

VOID
ExpDecryptEEPROM(
    VOID
    )
{
    NTSTATUS Status;
    ULONG Type, Length;
    XBOX_ENCRYPTED_SETTINGS EncryptedSettings;
    ULONG Temp;

    ASSERT(sizeof(EncryptedSettings) == EEPROM_ENCRYPTED_SECTION_SIZE);
    ASSERT(sizeof(EncryptedSettings.Checksum) == XC_SERVICE_DIGEST_SIZE);

    //
    // Read the encrypted section of the EEPROM
    //
    Status = ExQueryNonVolatileSetting(
                XC_ENCRYPTED_SECTION,
                &Type,
                &EncryptedSettings,
                sizeof(EncryptedSettings),
                &Length);

    if (!NT_SUCCESS(Status)) {
        goto DecryptEEPROMError;
    }
//##### -- allow encrypted EEPROM on retail ^-^
//#ifdef DEVKIT
    //
    // On DEVKIT box, the data can be either encrypted or unencrypted.
    // On retail box, it's always encrypted.
    //
    // NOTE: We treat the EEPROM as unencrypted if the confounder
    // field is all 0's.
    //
    if (((PULONG) EncryptedSettings.Confounder)[0] | ((PULONG) EncryptedSettings.Confounder)[1])
//#endif
    {
        #define RC4_CONFOUNDER_LEN FIELD_SIZE(XBOX_ENCRYPTED_SETTINGS, Confounder)

        UCHAR Checksum[XC_SERVICE_DIGEST_SIZE];
        UCHAR Confounder[RC4_CONFOUNDER_LEN];
        UCHAR LocalKey[XC_SERVICE_DIGEST_SIZE];
        UCHAR Rc4KeyStruct[XC_SERVICE_RC4_KEYSTRUCT_SIZE];
        UCHAR* Data;
        ULONG DataSize;

        Data = EncryptedSettings.HDKey;
        DataSize = EEPROM_ENCRYPTED_SECTION_SIZE - FIELD_OFFSET(XBOX_ENCRYPTED_SETTINGS, HDKey);
        memcpy(Confounder, EncryptedSettings.Confounder, RC4_CONFOUNDER_LEN);

        //
        // HMAC the checksum into the key
        //
        XcHMAC(
            XboxEEPROMKey,
            XBOX_KEY_LENGTH,
            EncryptedSettings.Checksum,
            XC_SERVICE_DIGEST_SIZE,
            NULL,
            0,
            LocalKey);

        //
        // Use the generated key as the RC4 encryption key
        //
        XcRC4Key(Rc4KeyStruct, XC_SERVICE_DIGEST_SIZE, LocalKey);

        //
        // Decrypt confounder and data
        //
        XcRC4Crypt(Rc4KeyStruct, RC4_CONFOUNDER_LEN, Confounder);
        XcRC4Crypt(Rc4KeyStruct, DataSize, Data);

        //
        // Now verify the checksum.
        //
        XcHMAC(
            XboxEEPROMKey,
            XBOX_KEY_LENGTH,
            Confounder,
            RC4_CONFOUNDER_LEN,
            Data,
            DataSize,
            Checksum);

        //
        // Decrypt is successful only if checksum matches
        //
        if (memcmp(Checksum, EncryptedSettings.Checksum, XC_SERVICE_DIGEST_SIZE) != 0) {
            Status = STATUS_IMAGE_CHECKSUM_MISMATCH;
            goto DecryptEEPROMError;
        }
    }

    memcpy(XboxHDKey, EncryptedSettings.HDKey, XBOX_KEY_LENGTH);
    XboxGameRegion = EncryptedSettings.GameRegion;

//##### -- i see no reason not to do this here, but set american also ^-^
//#ifdef DEVKIT
    //
    // For now, force a valid game region
    //
    if (XboxGameRegion == 0) {
		//##### -- added american flag
        XboxGameRegion = XC_GAME_REGION_MANUFACTURING | XC_GAME_REGION_NA;
    }

//#endif

    //
    // Verify that only one game region bit is set, ignoring the manufacturing
    // region.
    //

    Temp = XboxGameRegion & (~XC_GAME_REGION_MANUFACTURING);
    if ((Temp & (Temp - 1)) != 0) {
        Status = STATUS_IMAGE_GAME_REGION_VIOLATION;
        goto DecryptEEPROMError;
    }

    return;

DecryptEEPROMError:
    KdPrint(("INIT: failed to decrypt EEPROM settings (status=%08x).\n", Status));

#ifndef DEVKIT
    //
    // Write LED state to indicate that there was a problem with the EEPROM
    //

    HalWriteSMCLEDStates(SMC_LED_STATES_RED_STATE1 | SMC_LED_STATES_RED_STATE3);

//##### -- never ever fail booting!!!  (the LED flashing is OK)
//    PsTerminateSystemThread(STATUS_SUCCESS);
#endif
}

#ifdef DEVKIT

DECLSPEC_INITDATA UCHAR ExpBldrEncryptionKey[] = {
    0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
    0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
};

VOID
ExpTryToBootMediaROM(
    VOID
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID RelocatedBootLoader;
    PVOID ROMShadow;
    struct RC4_KEYSTRUCT RC4KeyStruct;
    BOOLEAN LoadedFromCdRom;
    PUCHAR BootOptions;
    PBLDR_LOAD_MEDIA_ROM_ROUTINE LoadMediaROMRoutine;

    //
    // Attempt to open a ROM from the CD-ROM.
    //

    LoadedFromCdRom = TRUE;

    InitializeObjectAttributes(&ObjectAttributes, &ExpCdRomBootROMString,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&FileHandle, GENERIC_READ, &ObjectAttributes,
        &IoStatusBlock, 0, FILE_SYNCHRONOUS_IO_NONALERT |
        FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING);

    if (!NT_SUCCESS(status)) {

        //
        // Attempt to open a ROM from the hard drive.
        //

        LoadedFromCdRom = FALSE;

        ObjectAttributes.ObjectName = &ExpHardDiskBootROMString;

        status = NtOpenFile(&FileHandle, GENERIC_READ, &ObjectAttributes,
            &IoStatusBlock, 0, FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_NON_DIRECTORY_FILE | FILE_NO_INTERMEDIATE_BUFFERING);
    }

    //
    // If no ROM file was found, then use the current ROM to boot.
    //

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Allocate the boot loader memory at the boot loader's relocated base
    // physical address.
    //

    RelocatedBootLoader = MmAllocateContiguousMemoryEx(BLDR_BLOCK_SIZE,
        BLDR_RELOCATED_ORIGIN, BLDR_RELOCATED_ORIGIN + BLDR_BLOCK_SIZE - 1, 0,
        PAGE_READWRITE);

    if (RelocatedBootLoader == NULL) {
        DbgPrint("INIT: Failed to allocate boot loader memory.\n");
        NtClose(FileHandle);
        return;
    }

    //
    // Allocate the media ROM memory.  If we cannot allocate a block of this
    // size at this early phase of initialization, then something's wrong, but
    // we'll attempt to continue initializing the system.  We limit the top
    // address of the allocation so that we don't run into the bottom of the
    // PFN database where we may try to place a copy of the kernel's initialized
    // data section.
    //

    ROMShadow = MmAllocateContiguousMemoryEx(ROM_SHADOW_SIZE, 0, 48 * 1024 * 1024,
        0, PAGE_READWRITE);

    if (ROMShadow == NULL) {
        DbgPrint("INIT: Failed to allocate shadow ROM memory.\n");
        NtClose(FileHandle);
        return;
    }

    //
    // Read the media ROM into memory.  If this fails, we'll take our chances
    // and continue booting with the current ROM.
    //

    status = NtReadFile(FileHandle, NULL, NULL, NULL, &IoStatusBlock,
        ROMShadow, ROM_SHADOW_SIZE, NULL);

    NtClose(FileHandle);

    if (!NT_SUCCESS(status) || (IoStatusBlock.Information != ROM_SHADOW_SIZE)) {
        DbgPrint("INIT: Failed to read ROM from media.\n");
        MmFreeContiguousMemory(ROMShadow);
        MmFreeContiguousMemory(RelocatedBootLoader);
        return;
    }

    //
    // This is an ugly hack to prevent downgrading to the July release - we refuse
    // to load the xboxrom.bin on its CD based on the absence of a number in the
    // "trim values version" part of the init table (at DWORD 0x1B == offset 0x6C)
    //

    if (LoadedFromCdRom &&
        (((PULONG)ROMShadow)[0x1B] == 0x00000000)) {
        DbgPrint("INIT: Failed to load ROM from media because it is too old.\n");
        MmFreeContiguousMemory(ROMShadow);
        MmFreeContiguousMemory(RelocatedBootLoader);
        return;
    }

    //
    // Decrypt the boot loader in the media ROM image.
    //

    rc4_key(&RC4KeyStruct, sizeof(ExpBldrEncryptionKey), ExpBldrEncryptionKey);
    rc4(&RC4KeyStruct, BLDR_BLOCK_SIZE, (PUCHAR)ROMShadow + ROM_SHADOW_SIZE -
        ROM_DEC_SIZE - BLDR_BLOCK_SIZE);

    //
    // Copy the boot loader to its relocated base physical address.
    //

    RtlCopyMemory(RelocatedBootLoader, (PUCHAR)ROMShadow + ROM_SHADOW_SIZE -
        ROM_DEC_SIZE - BLDR_BLOCK_SIZE, BLDR_BLOCK_SIZE);

    //
    // Modify the load options to indicate where the media ROM was loaded from.
    //

    BootOptions = (PUCHAR)(KSEG0_BASE + BLDR_RELOCATED_ORIGIN + sizeof(ULONG));

    if (LoadedFromCdRom) {
        strcat(BootOptions, " /SHADOW /CDBOOT");
        DbgPrint("INIT: Loaded kernel image from CD-ROM.\n");
    } else {
        strcat(BootOptions, " /SHADOW /HDBOOT");
        DbgPrint("INIT: Loaded kernel image from hard disk.\n");
    }

    if ((XboxBootFlags & XBOX_BOOTFLAG_DASHBOARDBOOT) != 0) {
        strcat(BootOptions, " /DBBOOT");
    }

    //
    // Compute the address of the load media ROM routine.  The pointer to the
    // routine is located immediately before the start address of the boot
    // loader.
    //

    LoadMediaROMRoutine =
        *((PBLDR_LOAD_MEDIA_ROM_ROUTINE*)((PUCHAR)RelocatedBootLoader +
        (*((PULONG_PTR)RelocatedBootLoader) - BLDR_BOOT_ORIGIN -
        sizeof(ULONG_PTR))));
    LoadMediaROMRoutine = (PBLDR_LOAD_MEDIA_ROM_ROUTINE)
        (MM_SYSTEM_PHYSICAL_MAP + (ULONG_PTR)LoadMediaROMRoutine);

    //
    // Stop the boot animation.
    //

    AniSetLogo(NULL, 0);
    AniTerminateAnimation();

    //
    // Notify the debugger that we're "rebooting".
    //

    DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);

    //
    // Load the kernel from the media ROM.
    //

    LoadMediaROMRoutine(MmGetPhysicalAddress(ROMShadow));
}

NTSTATUS
ExpStartDebugMonitor(
    VOID
    )
/*++

Routine Description:

    This routine starts the debug monitor on a development kit system.

Arguments:

    None.

Return Value:

    Status of operation.

--*/
{
    PVOID pvBase;
    NTSTATUS st;
    DMINIT dminit;
    ULONG (__stdcall *EntryPoint)(PVOID, PVOID, ULONG);
    extern PKDEBUG_ROUTINE KiDebugRoutine;
    HANDLE h;
    OBJECT_ATTRIBUTES oa;
    FILE_NETWORK_OPEN_INFORMATION fni;
    IO_STATUS_BLOCK iosb;
    ULONG cPages;
    BOOLEAN fLoadCanFail;
    POBJECT_STRING postLoadFrom;

    memset(&dminit, 0, sizeof dminit);
    /* We insist on loading from the same location as the kernel.  If the
     * kernel loaded from ROM, we'll try to load from the HD, but we'll
     * allow the load to fail */
    if(XboxBootFlags & XBOX_BOOTFLAG_HDBOOT) {
        fLoadCanFail = FALSE;
        postLoadFrom = &ExpHDXbdmDLL;
    } else if(XboxBootFlags & XBOX_BOOTFLAG_CDBOOT) {
        dminit.Flags |= DMIFLAG_CDBOOT;
        fLoadCanFail = FALSE;
        postLoadFrom = &ExpDVDXbdmDLL;
    } else {
        fLoadCanFail = TRUE;
        postLoadFrom = &ExpHDXbdmDLL;
    }

    // Load the dm dll
    InitializeObjectAttributes(&oa, postLoadFrom, OBJ_CASE_INSENSITIVE, NULL,
        NULL);
    st = NtOpenFile(&h, FILE_EXECUTE, &oa, &iosb, 0,
        FILE_SYNCHRONOUS_IO_NONALERT);
    if(!NT_SUCCESS(st)) {
        goto ErrRet;
    }

    st = NtQueryInformationFile(h, &iosb, &fni, sizeof fni,
        FileNetworkOpenInformation);
    if(!NT_SUCCESS(st))
        goto ErrClose;
    pvBase = MmDbgAllocateMemory(fni.EndOfFile.LowPart, PAGE_READWRITE);
    if(pvBase == NULL) {
        st = STATUS_NO_MEMORY;
        goto ErrClose;
    }
    st = NtReadFile(h, NULL, NULL, NULL, &iosb, pvBase, fni.EndOfFile.LowPart,
        NULL);
    if(!NT_SUCCESS(st))
        goto ErrClose;
    try {
        st = LdrRelocateImage(pvBase, "xbdm", STATUS_SUCCESS,
            STATUS_CONFLICTING_ADDRESSES, STATUS_INVALID_IMAGE_FORMAT);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        st = GetExceptionCode();
    }
    if(!NT_SUCCESS(st)) {
        MmDbgFreeMemory(pvBase, fni.EndOfFile.LowPart);
ErrClose:
        NtClose(h);
ErrRet:
        if(fLoadCanFail) {
            DbgPrint("Failed to load any xbdm.dll!\n");
            return STATUS_SUCCESS;
        }
        return st;
    }
    NtClose(h);

    // The whole thing is finally loaded.  Set up the init parameters
    dminit.DebugRoutine = &KiDebugRoutine;
    dminit.LoadedModuleList = &KdLoadedModuleList;
    dminit.CtxSwapNotifyRoutine = (VOID**) &KiDbgCtxSwapNotify;
    dminit.DpcDispatchNotifyRoutine = (VOID**)&KiDpcDispatchNotify;
    dminit.XProfpDataPtr = &ExpCallAttributedProfileData;
    dminit.ClockIntRoutine = &KiDbgClockInt;
    dminit.ProfIntRoutine = &KiDbgProfInt;
    dminit.HalStartProfileRoutine = HalStartProfileInterrupt;
    dminit.HalStopProfileRoutine = HalStopProfileInterrupt;
    dminit.HalProfileIntervalRoutine = HalSetProfileInterval;
    dminit.DisallowXbdm = &ExpDisableDebugMonitor;

    EntryPoint = (PVOID)((ULONG_PTR) pvBase +
        RtlImageNtHeader(pvBase)->OptionalHeader.AddressOfEntryPoint);

    return (EntryPoint)(pvBase, &dminit, 0);
}

#endif // DEVKIT

ULONG
ExpDetectSettingsError(
    VOID
    )
/*++

Routine Description:

    Detect if clock/timezone/language settings are invalid

Arguments:

    None.

Return Value:

    0 if everything is ok
    Otherwise, a bit flag indicating which settings are bad

--*/
{
    ULONG errors = 0;
    NTSTATUS status;
    ULONG type, length;
    XBOX_USER_SETTINGS userSettings;

    //
    // Check if the CMOS data is valid.
    //
    if (!HalIsCmosValid()) {
        errors |= XLD_SETTINGS_CLOCK;
    } else {
        //
        // NOTE: Workaround for RTC hardware problem
        // Sometimes the clock would lose power but the flag bit isn't set.
        // We query the RTC time here and do a sanity check.
        // If the time is before 1/1/2001 or after 1/1/2101,
        // we'll assume the clock has gone bad.
        //
        LARGE_INTEGER time;
        KeQuerySystemTime(&time);
        if (time.QuadPart < 0x01c07385c89dc000i64 ||
            time.QuadPart > 0x02309034f02ac000i64) {
            KdPrint(("Bad real-time clock value: %08x%08x\n", time.HighPart, time.LowPart));
            errors |= XLD_SETTINGS_CLOCK;
        }
    }

    //
    // Read the user settings inside the EEPROM
    //
    status = ExQueryNonVolatileSetting(
                XC_MAX_OS,
                &type,
                &userSettings,
                sizeof(userSettings),
                &length);

    if (NT_SUCCESS(status)) {
        //
        // Check the language setting
        //
        if (userSettings.Language == XC_LANGUAGE_UNKNOWN)
            errors |= XLD_SETTINGS_LANGUAGE;

        //
        // Check the time zone setting
        //  NOTE: we assume the time zone isn't set if the name is empty.
        //
        if (XBOX_INVALID_TIMEZONE_SETTING(userSettings))
            errors |= XLD_SETTINGS_TIMEZONE;
    } else {
        //
        // Assume both language/timezone are invalid
        // if there is an EEPROM read error.
        //
        errors |= XLD_SETTINGS_TIMEZONE|XLD_SETTINGS_LANGUAGE;
    }

#if DBG
    if (errors) {
        DbgPrint("INIT: invalid clock/timezone/language settings - %x\n", errors);
    }
#endif

    return errors;
}


VOID
ExpCopyLastUEMError(
    VOID
    )
/*++

Routine Description:

    This rotutine copies the Last UEM error code from the EEPROM to the
    SMC error register.  This routine is called only when we are in the
    Manufacturing region.

Arguments:

    None.

Return Value:

    None

--*/
{
    EEPROM_LAYOUT EEPROMData;
    NTSTATUS Status;
    ULONG SettingType;
    ULONG SettingLength;
    XBOX_UEM_INFO* UEMInfo;

    UEMInfo = (XBOX_UEM_INFO*)&(EEPROMData.UEMInfo[0]);

    //
    // Read the EEPROM
    //

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &SettingType, &EEPROMData,
        sizeof(EEPROMData), &SettingLength);

    if (NT_SUCCESS(Status)) {

        //
        // If the last code is non-zero, write it to the SMC and then clear
        // it in the EEPROM
        //

        if (UEMInfo->LastCode != FATAL_ERROR_NONE) {

            HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_WRITE_ERROR_CODE, UEMInfo->LastCode);

            UEMInfo->LastCode = 0;

            ExSaveNonVolatileSetting(XC_MAX_ALL, SettingType, &EEPROMData, SettingLength);
        }
    }
}



VOID
Phase1Initialization(
    IN PVOID Context
    )
{
    NTSTATUS status;
    LARGE_INTEGER UniversalTime;
    LARGE_INTEGER CmosTime;
    LARGE_INTEGER OldTime;
    TIME_FIELDS TimeFields;
    ULONG SettingsError;

    //
    // Initialize the Hardware Architecture Layer (HAL).
    //

    HalInitSystemPhase1();

    //
    // Initialize the system time and set the time the system was booted.
    //
    // N.B. This cannot be done until after the phase one initialization
    //      of the HAL Layer.
    //

    if (HalQueryRealTimeClock(&TimeFields) != FALSE) {

        if(TimeFields.Year < 2000 || TimeFields.Year > 2100 ||
            !RtlTimeFieldsToTime(&TimeFields, &CmosTime))
        {
            // use a bogus time value to indicate bogus clock
            CmosTime.HighPart = 0x20000001;
            CmosTime.LowPart = 0;
        }
        UniversalTime = CmosTime;
        KeSetSystemTime(&UniversalTime, &OldTime);

        KeBootTime = UniversalTime;
        KeBootTimeBias = 0;
    }

    //
    // Read the MCPX revision number.
    //

    HalReadPCISpace(
        0,
        XPCI_SLOT_NUMBER(LPCBRIDGE),
        8,
        &XboxHardwareInfo.McpRevision,
        sizeof(XboxHardwareInfo.McpRevision));

    //
    // NOTE: NV2A revision number is not found in the PCI config space.
    // Rather, it's in the LSB of the very first NV2A register.
    //

    XboxHardwareInfo.GpuRevision = (UCHAR) *((ULONG*) XPCICFG_GPU_MEMORY_REGISTER_BASE_0);

    //
    // Set the USB flag based on the MCP revision.  If the MCP is B03 (rev=b3) or
    // earlier, we are using a USB daughterboard.  For later revs, we don't use it.
    //

    if (XboxHardwareInfo.McpRevision <= 0xB3) {
        XboxHardwareInfo.Flags |= XBOX_HW_FLAG_INTERNAL_USB_HUB;
    }

    //
    // If the kernel is cold-booting, then do some additional work before
    // initializing the rest of the kernel.
    //

    if (!KeHasQuickBooted) {

        //
        // Decrypt the encrypted section of the EEPROM and save the hard disk
        // key and the game region information into global variables.
        //

        HalPulseHardwareMonitorPin();
        ExpDecryptEEPROM();

        //
        // Block if no AV pack is attached to the system.
        //

        HalPulseHardwareMonitorPin();
        HalBlockIfNoAVPack();

        //
        // Display the fatal error message if we've been rebooted for that
        // purpose.
        //

        if ((XboxBootFlags & XBOX_BOOTFLAG_DISPLAYFATALERROR) != 0) {

            HalWriteSMCLEDStates(SMC_LED_STATES_GREEN_STATE0 | SMC_LED_STATES_RED_STATE1 |
                SMC_LED_STATES_RED_STATE2 | SMC_LED_STATES_RED_STATE3);

            ExDisplayFatalError(FATAL_ERROR_REBOOT_ROUTINE);
        }

        //
        // Start the boot animation if this isn't a shadow boot.
        //

        if ((XboxBootFlags & XBOX_BOOTFLAG_SHADOW) == 0) {
            HalPulseHardwareMonitorPin();
            AniStartAnimation((XboxBootFlags & XBOX_BOOTFLAG_SHORTANIMATION) != 0);
        }
    }

    //
    // Initialize the IDE driver.
    //

    IdexChannelCreate();

#ifdef DEVKIT
    //
    // Try to load a ROM from the media.  Only do this if we haven't already
    // tried in an earlier boot from the system's real ROM or if we haven't
    // already been loaded from a shadow ROM.
    //

    if (!KeHasQuickBooted && !(XboxBootFlags & XBOX_BOOTFLAG_SHADOW)) {
        ExpTryToBootMediaROM();
    }

    //
    // Start the debug monitor.
    //

    if (!ExpDisableDebugMonitor) {

        status = ExpStartDebugMonitor();

        if (!NT_SUCCESS(status)) {
            KdPrint(("INIT: Debug monitor failed to start (status=%08x).\n", status));
            KeBugCheckEx(PHASE1_INITIALIZATION_FAILED, status, 0, 0, 0);
        }
    }
#endif

    //
    // If the kernel is cold-booting, and we're not booting from a kernel loaded
    // from the CD-ROM and the console isn't configured for the manufacturing
    // content, then check if we should force a boot into the dashboard.  If we
    // detect a settinngs error, we'll try to bring up a title anyway, because
    // titles signed in the manufacturing region are allowed to run with
    // invalid settings; we'll fall back to the dash if we don't find such a
    // title.
    //

    if (!KeHasQuickBooted &&
        ((XboxBootFlags & XBOX_BOOTFLAG_CDBOOT) == 0) &&
        ((XboxGameRegion & XC_GAME_REGION_MANUFACTURING) == 0)) {

        HalPulseHardwareMonitorPin();

        if ((SettingsError = ExpDetectSettingsError()) != 0) {
            XeLoadTitleImage(SettingsError);
        } else if ((XboxBootFlags & XBOX_BOOTFLAG_DASHBOARDBOOT) != 0) {
            XeLoadDashboardImageWithReason(XLD_LAUNCH_DASHBOARD_BOOT, 0);
        } else if ((XboxBootFlags & XBOX_BOOTFLAG_TRAYEJECT) != 0) {
            XeLoadImageAfterTrayEjectBoot();
        } else if ((XboxBootFlags & XBOX_BOOTFLAG_NONSECUREMODE) != 0) {
            XeLoadDashboardImage();
        } else {
            XeLoadTitleImage(0);
        }

    } else {
        XeLoadTitleImage(0);
    }

    //
    // If the kernel is cold-booting, then do some additional work before
    // handing control over to the XBE image.
    //

    if (!KeHasQuickBooted) {

        HalPulseHardwareMonitorPin();

        //
        // Notify the SMC that we've finished initializing the system.  The SMC
        // uses this as a signal to know whether or not we need to be notified
        // when the user powers down the system.  After this point, we do need
        // to be notified because we may have I/O buffers that need to be
        // flushed.
        //

        HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_OS_READY,
            SMC_OS_READY_READY);

        //
        // Stop the boot animation.
        //

        AniTerminateAnimation();

        //
        // If we are in manufacturing mode and have not quickbooted, handle the
        // copying the last UEM error code from EEPROM to SMC error code register.
        //

        if (XboxGameRegion & XC_GAME_REGION_MANUFACTURING) {
            ExpCopyLastUEMError();
        }

        //
        // Discard the kernel's initialization code section.  All of the code in
        // the INIT section applies to a cold boot only.
        //

        MmDiscardInitSection();
    }

    //
    // Relocate persistent contiguous memory allocations in order to present
    // roughly the same physical memory layout to an XBE image.
    //

    MmRelocatePersistentMemory();

    //
    // Invoke the entry point of the XBE image.
    //

    XeImageHeader()->AddressOfEntryPoint();

    //
    // The XBE startup code runs the main title thread on a new thread, so
    // terminate this initialization thread.
    //

    PsTerminateSystemThread(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\inc\xprofp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xprofp.h

Abstract:

    Kernel profiler functions

--*/

#ifndef _XPROFP_H
#define _XPROFP_H

#ifdef __cplusplus
extern "C" {
#endif

NTSTATUS
XProfpControl(
    ULONG Action,
    ULONG Param
    );

#define XPROF_START             1
#define XPROF_STOP              2
#define XPROF_COMMENT           4
#define XPROF_THREAD_SWITCH     5
#define XPROF_DPC_BEGIN         6
#define XPROF_DPC_END           7

#define XPROF_DPC_ENABLED       0x80000000

/*
    action: XPROF_START
    param: size of profiling data buffer in MB, default = 32

    action: XPROF_STOP
    param: none

    action: XPROF_COMMENT
    param: user-defined parameter

 */

/*
 !!! Profiling data record format:
    timestamp: bits 63-32
    timestamp: bits 31-0
    type-specific data

    Bits 63-61 of the timestamp are used as flags.

    000 - fastcap start: just before calling a function
        caller function: ULONG
        callee function: ULONG

    001 - fastcap end: just after calling a function
        caller function: ULONG

    010 - _penter:
        caller function: ULONG
        ESP: ULONG

    011 - _pexit:
        caller function: ULONG
        ESP: ULONG

    100 - callcap start:
        caller function: ULONG

    101 - callcap exit:
        caller function: ULONG

    110 - reserved

    111 - control records:
        record type: ULONG
        param: ULONG

    If type is XPROF_START or XPROF_STOP, param is the current thread ID
    If type is XPROF_COMMENT, param is the user-defined parameter.
    If type is XPROF_THREAD_SWITCH, param is the new thread ID.
    If type is XPROF_DPC_START or XPROF_DPC_END, param is the DPC function address.

    We don't need to record thread ID in each record because we can always derive
    the current thread ID from the XPROF_START and XPROF_THREAD_SWITCH records.

 */

#define XPROFREC_TYPEMASK       0xE0000000
#define XPROFREC_FASTCAP_START  0x00000000
#define XPROFREC_FASTCAP_END    0x20000000
#define XPROFREC_PENTER         0x40000000
#define XPROFREC_PEXIT          0x60000000
#define XPROFREC_CALLCAP_START  0x80000000
#define XPROFREC_CALLCAP_END    0xA0000000
#define XPROFREC_CONTROL        0xE0000000

//
// Maximum size for all types of profile data records.
// Note that we're setting this to be a larger value than necessary
// in case we need to add new types of profiling data records
// in the future.
//
#define XPROFREC_MAXSIZE (32*sizeof(ULONG))

//
// Profile data file header
//
#define XPROF_FILE_VERSION 0x00000001
#define XPROF_FILE_HEADER_SIZE sizeof(XProfpFileHeader)
#define XPROF_MAX_MODULES 16
#define XPROF_MAX_MODULE_NAMELEN 48

typedef struct {
    ULONG version;                              // 0x000 + 0x004
    ULONG module_count;                         // 0x004 + 0x004
    struct {                                    // 0x008 + 0x010 * 0x040
        ULONG loadaddr;
        ULONG size;
        ULONG reserved[2];
        CHAR name[XPROF_MAX_MODULE_NAMELEN];
    } modules[XPROF_MAX_MODULES];
    UCHAR reserved[0x1000-0x408];               // ..... = 0x1000
} XProfpFileHeader;


//
// Global data structures maintained by the profiler
//
// NOTE: Do NOT change the first two fields of this structure,
// unless you also change the offsets in the assembly functions
// CAP_Start_Profiling and CAP_End_Profiling.
//
typedef struct {
    ULONG* bufnext;
        // Points to the next available space in the profiling data buffer

    ULONG* bufend;
        // End of profiling data buffer

    ULONG* bufnext_stopped;
        // Value of bufnext when the profiling session is stopped
        // NULL if profiling session is active or hasn't been stopped

    ULONG* bufstart;
        // Start of profiling data buffer
        // NULL if profiling session isn't active

    ULONG start_type;
        // Unused

    ULONG start_param;
        // Parameter that was passed to XPROF_START_x

    LONG lock;
        // Global access lock:
        //  0 if the lock is free
        //  otherwise, the lock is busy

    LONG reserved;
} XProfpGlobals;

//
// Retrieve kernel profiling global data structure
//
XProfpGlobals*
XProfpGetData();

//
// Runtime support function for sweeping BBT data into a file
//
NTSTATUS IrtSweep(HANDLE file);

#ifdef __cplusplus
}
#endif

#endif // !_XPROFP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\fatal.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    fatal.c

Abstract:

    This module implements the ExDisplayFatalError (aka UEM) and supporting routines.

--*/

#pragma code_seg("INIT")
#pragma data_seg("INIT_RW")
#pragma bss_seg("INIT_RW")
#pragma const_seg("INIT_RD")

#include "ntos.h"
#include "ani.h"

#include <xtl.h>
#include <xboxp.h>
#include <xconfig.h>
#include <smcdef.h>

#ifndef ARCADE

#pragma pack(1)

typedef struct _IMAGE_RUN1 {
    UINT fOne : 1;
    UINT Size : 3;
    UINT Intensity : 4;
} IMAGE_RUN1;

typedef struct _IMAGE_RUN2 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 10;
    UINT Intensity : 4;
} IMAGE_RUN2;

typedef struct _IMAGE_RUN3 {
    UINT fOne : 1;
    UINT fTwo : 1;
    UINT Size : 18;
    UINT Intensity : 4;
} IMAGE_RUN3;

typedef struct _LED_VERT_TYPE {
    float x,y,z; 
    float w;
    ULONG color; 
} LED_VERT_TYPE;


#pragma pack()

#include "image.h"

const struct TheVerts { float x,y,z,w; float u, v; } Verts[] =
{
    {  0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
    {640.0f, 480.0f, 0.5f, 1.0f, 320.0f, 240.0f},
    {  0.0f, 480.0f, 0.5f, 1.0f,   0.0f, 240.0f},
    {640.0f,   0.0f, 0.5f, 1.0f, 320.0f,   0.0f},
    {640.0f, 480.0f, 0.5f, 1.0f, 320.0f, 240.0f},
    {  0.0f,   0.0f, 0.5f, 1.0f,   0.0f,   0.0f},
};


//
// Macros to define LED line segments and characters
//

#define LEDSEGDEF(x1,y1,x2,y2)           ((x2<<6) | (y2<<4) | (x1<<2) | y1)
#define LEDCHARDEF(s0,s1,s2,s3,s4,s5,s6) ((s6 << 6) | (s5 << 5) | (s4 << 4) | (s3 << 3) | \
                                          (s2 << 2) | (s1 << 1) | s0)
                                          

//
// Define the line segments of the LED font
//
//   --0--
//   1   2
//   --3--
//   4   5
//   --6--
//

UCHAR LEDSegmentDef[] = {
    LEDSEGDEF(0,0, 1,0),
    LEDSEGDEF(0,0, 0,1),
    LEDSEGDEF(1,0, 1,1),
    LEDSEGDEF(0,1, 1,1),
    LEDSEGDEF(0,1, 0,2),
    LEDSEGDEF(1,1, 1,2),
    LEDSEGDEF(0,2, 1,2)
};

//
// Define the LED characters based on what line segments 
// should be turned on or off
//

UCHAR LEDCharDef[] = {
    LEDCHARDEF(1,1,1,0,1,1,1),    
    LEDCHARDEF(0,0,1,0,0,1,0),
    LEDCHARDEF(1,0,1,1,1,0,1),
    LEDCHARDEF(1,0,1,1,0,1,1),
    LEDCHARDEF(0,1,1,1,0,1,0),
    LEDCHARDEF(1,1,0,1,0,1,1),
    LEDCHARDEF(1,1,0,1,1,1,1),
    LEDCHARDEF(1,0,1,0,0,1,0),
    LEDCHARDEF(1,1,1,1,1,1,1),
    LEDCHARDEF(1,1,1,1,0,1,0)
};



IDirect3DDevice8* InitD3D(void)
{
    D3DPRESENT_PARAMETERS d3dpp;
    IDirect3DDevice8 *pDev;
    IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);

    if (pD3D == NULL)
    {
        return NULL;
    }

    pDev = NULL;
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.FullScreen_RefreshRateInHz      = 60;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    IDirect3D8_CreateDevice(pD3D,
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &pDev);

    IDirect3D8_Release(pD3D);

    return pDev;
}

BOOL InitVB(IDirect3DDevice8 *pDev)
{
    IDirect3DVertexBuffer8 *pVB;
    void *pVerts;

    if (FAILED(IDirect3DDevice8_CreateVertexBuffer(pDev,
            sizeof(Verts),
            D3DUSAGE_WRITEONLY,
            D3DFVF_XYZRHW | D3DFVF_TEX1,
            D3DPOOL_MANAGED,
            &pVB)))
    {
        return FALSE;
    }

    IDirect3DVertexBuffer8_Lock(pVB, 0, sizeof(Verts), (BYTE **)(&pVerts), 0);
    memcpy((void*)pVerts, (void*)Verts, sizeof(Verts));
    IDirect3DVertexBuffer8_Unlock(pVB);

    IDirect3DDevice8_SetStreamSource(pDev, 0, pVB, sizeof(Verts[0]));
    IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_TEX1);

    return TRUE;
}

COLORREF ColorFromIntensity(UINT intensity4bits)
{
    UINT BaseR = 0x00;
    UINT BaseG = 0xFF;
    UINT BaseB = 0x00;

    UINT r = (UINT)((BaseR * intensity4bits) / 15.0f + 0.5f);
    UINT g = (UINT)((BaseG * intensity4bits) / 15.0f + 0.5f);
    UINT b = (UINT)((BaseB * intensity4bits) / 15.0f + 0.5f);

    return D3DCOLOR_ARGB(0xFF, r, g, b);
}

BOOL InitTexture(IDirect3DDevice8 *pDev)
{
    IDirect3DTexture8* pTex;
    D3DLOCKED_RECT lock;
    UINT x = 0, i, j;
    DWORD dwLine;
    DWORD dwAddr;
    IMAGE_RUN1 *pRun1;
    IMAGE_RUN2 *pRun2;
    IMAGE_RUN3 *pRun3;
    UINT Size;
    UINT Intensity;

    if (FAILED(IDirect3DDevice8_CreateTexture(pDev,
            320,
            240,
            1,
            0,
            D3DFMT_LIN_X8R8G8B8,
            0,
            &pTex)))
    {
        return FALSE;
    }

    IDirect3DTexture8_LockRect(pTex, 0, &lock, NULL, 0);
    dwLine = (DWORD)lock.pBits;
    dwAddr = dwLine;
    i = 0;

    while(i < sizeof(g_Image))
    {
        pRun1 = (IMAGE_RUN1*)&g_Image[i];
        if (pRun1->fOne)
        {
            Size = pRun1->Size;
            Intensity = pRun1->Intensity;
            i += 1;
        }
        else
        {
            pRun2 = (IMAGE_RUN2*)&g_Image[i];
            if (pRun2->fTwo)
            {
                Size = pRun2->Size;
                Intensity = pRun2->Intensity;
                i += 2;
            }
            else
            {
                pRun3 = (IMAGE_RUN3*)&g_Image[i];
                Size = pRun3->Size;
                Intensity = pRun3->Intensity;
                i += 3;
            }
        }

        for (j = 0; j < Size; j++)
        {
            if (Intensity == 0)
            {
                *(DWORD*)dwAddr = 0xFF000000;
            }
            else
            {
                *(DWORD*)dwAddr = ColorFromIntensity(Intensity);
            }

            x++;

            if (x >= 320)
            {
                x = 0;
                dwLine += lock.Pitch;
                dwAddr = dwLine;
            }
            else
            {
                dwAddr += sizeof(DWORD);
            }
        }
    }

    IDirect3DTexture8_UnlockRect(pTex, 0);

    IDirect3DDevice8_SetTexture(pDev, 0, (D3DBaseTexture*)pTex);

    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

    return TRUE;
}

#endif

VOID
ExDisplayFatalError(
    IN ULONG ErrorCode
    )
/*++

Routine Description:

    This routine displays a fatal error message (AKA UEM).

Arguments:

    ErrorCode - The error code to be displayed 

Return Value:

    None.

--*/
{
    IDirect3DDevice8 *pDev;
    ULONG Segment;
    ULONG VertexNumber;
    UCHAR SegDef;
    UCHAR CharDef;
    ULONG Digit;
    ULONG Position;
    ULONG Scratch;
    EEPROM_LAYOUT EEPROMData;
    NTSTATUS Status;
    ULONG SettingType;
    ULONG SettingLength;
    XBOX_UEM_INFO* UEMInfo;
    BOOL PowerCycle;

    RtlZeroMemory(XboxCERTKey, XBOX_KEY_LENGTH);

    AniSetLogo(NULL, 0);
    AniTerminateAnimation();

    //
    // Read the EEPROM to get the UEM info
    //

    UEMInfo = (XBOX_UEM_INFO*)&(EEPROMData.UEMInfo[0]);

    Status = ExQueryNonVolatileSetting(XC_MAX_ALL, &SettingType, &EEPROMData,
        sizeof(EEPROMData), &SettingLength);

    if (NT_SUCCESS(Status)) {

        PowerCycle = FALSE;

        //
        // If the last UEM code stored in EEPROM is zero, write the current UEM
        // code (manufacturing only), set the matching bit in the UEM history,
        // and power cycle (manufacturing only).  Otherwise, clear the last code
        // and display the error.
        //

        if (UEMInfo->LastCode == FATAL_ERROR_NONE) {

            if (XboxGameRegion & XC_GAME_REGION_MANUFACTURING) {

                UEMInfo->LastCode = (UCHAR)ErrorCode;
                PowerCycle = TRUE;
            }

            //
            // Update the history bitmap for errors 5 and above
            //
            
            if (ErrorCode >= 5) {
                UEMInfo->History |= (1 << (ErrorCode - 5));
            }

        } else {

            UEMInfo->LastCode = FATAL_ERROR_NONE;
        }

        //
        // Write the EEPROM back out
        //

        ExSaveNonVolatileSetting(XC_MAX_ALL, SettingType, &EEPROMData, SettingLength);

        //
        // If a power cycle is required, ask the SMC to perform the power cycle
        //

        if (PowerCycle) {
            Status = HalWriteSMBusByte(SMC_SLAVE_ADDRESS, SMC_COMMAND_RESET,
                SMC_RESET_ASSERT_POWERCYCLE);
        }
    }

#ifndef ARCADE
    pDev = InitD3D();

    if (pDev != NULL) {
        if (InitVB(pDev) && InitTexture(pDev)) {

            IDirect3DDevice8_BeginScene(pDev);

            //
            // Display the texture with the multilingual text
            //

            IDirect3DDevice8_DrawPrimitive(pDev, D3DPT_TRIANGLELIST, 0,
                (sizeof(Verts) / sizeof(Verts[0])) / 3);

            //
            // Setup the state to display the error code
            //

            IDirect3DDevice8_SetVertexShader(pDev, D3DFVF_XYZRHW | D3DFVF_DIFFUSE);
            IDirect3DDevice8_SetTextureStageState(pDev, 0, D3DTSS_COLOROP, D3DTOP_SELECTARG2);
            
            //
            // Display the two digit error code
            //

            for (Digit = 0; Digit < 2; Digit++) {
                
                Position = 80 - Digit * 25;
                CharDef = LEDCharDef[ErrorCode % 10];

                for (Segment = 0; Segment < 7; Segment++) {
                    
                    SegDef = LEDSegmentDef[Segment];
                     
                    if ((CharDef & (1 << Segment)) != 0) {
                        
                        //
                        // Draw the line segment 
                        //

                        IDirect3DDevice8_Begin(pDev, D3DPT_LINELIST);

                        for (VertexNumber = 0; VertexNumber < 2; VertexNumber++) {
                            
                            IDirect3DDevice8_SetVertexData4f(pDev, D3DVSDE_VERTEX,  
                                (float)(Position + ((SegDef >> (VertexNumber * 4 + 2)) & 0x3) * 12),
                                (float)(50 + ((SegDef >> (VertexNumber * 4)) & 0x3) * 16),
                                0.5f, 2.0f);
                        }

                        IDirect3DDevice8_End(pDev);
                    }
                }

                ErrorCode /= 10;
            }

            IDirect3DDevice8_EndScene(pDev);

            IDirect3DDevice8_Present(pDev, NULL, NULL, NULL, NULL);

            IDirect3DDevice8_PersistDisplay(pDev);
        }
    }
#endif

    //
    // Keep the system alive so that we can continue to handle the tray eject
    // interrupt.
    //

    PsTerminateSystemThread(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\arcade\anistub.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    anistub.c

Abstract:

    This module implements empty boot animation stub routines for the ARCADE
    build.

--*/

#include <ntos.h>
#include <ani.h>
#include <av.h>
#include <avmode.h>
#include <xpcicfg.h>
#include <xtl.h>

#pragma code_seg("INIT")

VOID AniStartAnimation(BOOLEAN fShort)
{
    ULONG Step;

    //
    // D3D8.LIB assumes that D3D8NTPR.LIB initially set the display mode.  The
    // ARCADE kernel doesn't use D3D8NTPR.LIB, so we need to set the display
    // mode ourselves.  We set the display mode to OFF with the same D3DFORMAT
    // and pitch that the console boot animation would use.
    //

    Step = 0;

    do {
        Step = AvSetDisplayMode((PVOID)XPCICFG_GPU_MEMORY_REGISTER_BASE_0, 0,
            AV_MODE_OFF, D3DFMT_LIN_A8R8G8B8, 640 * 4, 0);
    } while (Step);
}

VOID AniTerminateAnimation()
{
    NOTHING;
}

VOID AniBlockOnAnimation()
{
    NOTHING;
}

VOID AniSetLogo(PVOID pv, ULONG Size)
{
    NOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\image.h ===
const BYTE g_Image[] =
{

0x7C, 0x7E, 0x00, 0xA3, 0x07, 0xA3, 0x4A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x96, 0x00, 0xA3, 0x92, 0x00, 0xA3, 0x62, 0x03, 0xA3, 0x07, 0xA3, 
0x4A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x92, 0x04, 0xA3, 0x03, 0xA3, 
0x05, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 0x0B, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA7, 0x03, 0xA5, 0x07, 0xA9, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA7, 0x03, 0xA5, 0x07, 0xA7, 0x0B, 0xA7, 0x05, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x42, 0x03, 
0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x22, 0x00, 0xA3, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x3E, 0x03, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x0F, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x05, 0xA5, 0x0D, 
0xA5, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x09, 0xA9, 0x3E, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x0F, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x4A, 0x03, 0xA3, 0x07, 0xA7, 0x07, 0xAB, 0x0D, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 
0xA7, 0x05, 0xA9, 0x05, 0xAB, 0x05, 0xA3, 0x07, 0xA7, 0x03, 0xA7, 0x0B, 
0xA7, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 
0xA7, 0x05, 0xA3, 0x16, 0x04, 0xA3, 0xFE, 0x04, 0xA3, 0xD2, 0x0D, 0xA7, 
0x05, 0xA3, 0x8A, 0x00, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x4E, 0x00, 0xA7, 0x32, 0x00, 0xA3, 0x76, 0x00, 0xA5, 0x6E, 0x00, 
0xA3, 0xAE, 0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x8A, 0x00, 0xA3, 0x05, 
0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 0xA3, 0x07, 0xA3, 
0x2E, 0x00, 0xA3, 0x72, 0x00, 0xA3, 0x05, 0xA3, 0x6A, 0x00, 0xA3, 0xAE, 
0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA7, 0x07, 0xA7, 
0x05, 0xA5, 0x0B, 0xA5, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x0D, 0xA5, 
0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 
0x07, 0xA3, 0x03, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA7, 0x03, 0xA5, 
0x07, 0xA5, 0x05, 0xA7, 0x09, 0xA3, 0x09, 0xA3, 0x07, 0xAB, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xAB, 0xAA, 0x02, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x0B, 0xA3, 0x0B, 0xA3, 0x07, 0xA5, 0x09, 
0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0xAE, 
0x02, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA9, 
0x07, 0xA3, 0x0B, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0D, 0xA5, 0x05, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x0B, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0xAE, 0x02, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0x0B, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0xAE, 0x02, 0xA3, 0x09, 0xA3, 0x07, 0xA7, 0x05, 0xA7, 0x03, 
0xA7, 0x07, 0xA7, 0x09, 0xA5, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 
0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x0B, 
0xA7, 0x07, 0xAF, 0x05, 0xA5, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x0F, 0xA5, 0x07, 0x22, 0xA0, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 0x9E, 0x04, 0xA3, 0x0B, 
0xA3, 0xE6, 0x04, 0xA3, 0x0B, 0xA3, 0xF4, 0x43, 0x00, 0xA3, 0x03, 0xA3, 
0x42, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x1A, 0x01, 0xA3, 0x0F, 0xA3, 
0x62, 0x00, 0xA3, 0xFE, 0x02, 0xA3, 0x03, 0xA3, 0x42, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x1A, 0x01, 0xA3, 0x0F, 0xA3, 0x62, 0x00, 0xA3, 0xFE, 
0x02, 0xA3, 0x03, 0xA9, 0x03, 0xA7, 0x05, 0xA5, 0x0D, 0xA5, 0x05, 0xA9, 
0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA7, 0x03, 0xA5, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA7, 0x0B, 0xA9, 0x03, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA9, 0x05, 0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 
0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA9, 
0x03, 0xA5, 0x05, 0xA9, 0xDA, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x05, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x09, 0xA3, 0x0F, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA9, 0x0B, 0xA5, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x07, 0xA5, 
0x0B, 0xA3, 0x07, 0xAB, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA7, 
0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xAB, 0x03, 0xA3, 
0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x0F, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x0D, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0D, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x09, 
0xA3, 0x07, 0xA3, 0xD6, 0x02, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xA7, 
0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xAF, 0x05, 0xA7, 0x0D, 0xA9, 
0x03, 0xA7, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA7, 0x03, 0xA5, 0x0B, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 
0x09, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0xDE, 0x03, 
0xA3, 0x07, 0xA3, 0xF2, 0x04, 0xA7, 0xBA, 0x0D, 0xA9, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x3A, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x4E, 0x00, 0xA3, 0x07, 0xA3, 0x3E, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 
0x03, 0xA3, 0x46, 0x00, 0xA3, 0x62, 0x00, 0xA5, 0xAE, 0x02, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x3A, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x4E, 0x00, 0xA3, 0x05, 0xA3, 0x42, 0x00, 0xA3, 0x3E, 
0x00, 0xA3, 0x4E, 0x00, 0xA3, 0x62, 0x00, 0xA3, 0xB2, 0x02, 0xA3, 0x07, 
0xA5, 0x05, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 0xA5, 0x05, 
0xA9, 0x0D, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xAB, 0x05, 0xA9, 0x05, 0xA5, 0x05, 
0xA9, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA5, 0x07, 0xA9, 0x05, 0xA7, 0x03, 
0xA5, 0x09, 0xA7, 0x05, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA7, 0x05, 
0xA5, 0x05, 0xA9, 0x86, 0x02, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x0D, 0xA5, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 
0x22, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x82, 0x02, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA9, 0x09, 0xA3, 0x07, 0xAB, 0x03, 0xA3, 
0x07, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x03, 0xA3, 0x03, 0xA9, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 
0x0D, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 
0x03, 0xA3, 0x07, 0xA3, 0x82, 0x02, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA5, 0x0D, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 
0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 
0xA3, 0x07, 0xA3, 0x82, 0x02, 0xA9, 0x03, 0xA3, 0x05, 0xA5, 0x03, 0xA5, 
0x05, 0xA7, 0x0B, 0xA9, 0x03, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 
0x07, 0xA3, 0x05, 0xAB, 0x07, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 
0x05, 0xA5, 0x0B, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xAB, 0x07, 0xA7, 
0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0xC0, 0x4A, 0x00, 0xA3, 0x76, 0x02, 
0xA3, 0x9A, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x96, 
0x00, 0xA3, 0x6E, 0x00, 0xA3, 0x0F, 0xA3, 0x46, 0x00, 0xA3, 0x26, 0x00, 
0xA3, 0x07, 0xA3, 0x3A, 0x00, 0xA3, 0x3E, 0x02, 0xA3, 0x9A, 0x00, 0xA3, 
0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x26, 0x01, 0xA3, 0x6E, 0x00, 
0xA3, 0x8A, 0x02, 0xA3, 0x07, 0xA7, 0x0D, 0xA5, 0x07, 0xA7, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA7, 0x05, 0xA3, 0x03, 0xA7, 0x0F, 0xA5, 0x05, 0xA9, 
0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA7, 0x05, 0xA5, 0x07, 0xAB, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x09, 0xA7, 
0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 
0x05, 0xA5, 0x05, 0xA3, 0x05, 0xA7, 0x09, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x1A, 0x02, 0xA3, 0x0D, 
0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x0F, 0xA3, 0x05, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x0D, 0xA3, 0x03, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x16, 0x02, 0xA3, 0x09, 0xA7, 0x09, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA9, 0x09, 0xA7, 
0x05, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x07, 0xA5, 0x09, 0xA3, 0x07, 0xA7, 0x07, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x0B, 0xA7, 0x16, 0x02, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x0D, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x16, 
0x02, 0xA9, 0x03, 0xA7, 0x0B, 0xA5, 0x07, 0xA7, 0x05, 0xA3, 0x07, 0xA9, 
0x07, 0xA7, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 
0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 0xA7, 0x05, 0xA9, 
0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x09, 0xA7, 0x09, 0xA7, 
0x03, 0xA7, 0x05, 0xA3, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 0x07, 0xA7, 0x07, 0xA5, 0x05, 0xA7, 
0x05, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA5, 0x07, 0xA7, 
0x05, 0xA3, 0x62, 0x03, 0xA3, 0xFE, 0x04, 0xA3, 0x82, 0x0D, 0xA3, 0x07, 
0xA3, 0x72, 0x00, 0xA3, 0x5A, 0x00, 0xA3, 0x0F, 0xA3, 0x36, 0x00, 0xA3, 
0x86, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x32, 
0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x22, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0xFA, 0x01, 0xA3, 0x07, 0xA3, 0x72, 0x00, 0xA3, 0xB2, 
0x00, 0xA3, 0x86, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 0x26, 0x00, 0xA3, 0x3A, 
0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x22, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0xFA, 0x01, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x05, 0xA7, 
0x03, 0xA5, 0x07, 0xA5, 0x0B, 0xA7, 0x05, 0xA3, 0x0B, 0xA7, 0x05, 0xA5, 
0x05, 0xA9, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x05, 0xA7, 
0x0B, 0xA9, 0x05, 0xA5, 0x0B, 0xA7, 0x05, 0xA7, 0x05, 0xA9, 0x05, 0xA7, 
0x05, 0xAB, 0x05, 0xA5, 0x0B, 0xA7, 0x05, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 
0x03, 0xA5, 0x0B, 0xA3, 0x03, 0xA7, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 
0x05, 0xA3, 0x05, 0xA3, 0xC2, 0x01, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x03, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 
0xA3, 0x09, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA5, 0xC6, 0x01, 0xA3, 0x07, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x03, 0xA9, 0x0B, 0xA7, 0x03, 0xA3, 0x0B, 0xA5, 0x05, 0xA9, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x09, 0xA5, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA9, 0x0B, 0xA7, 0x03, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 
0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA9, 0x09, 0xA3, 
0x07, 0xAB, 0x09, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x05, 0xA5, 0xC6, 0x01, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x0F, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x07, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x26, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x0F, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x0F, 0xA3, 
0x07, 0xA5, 0x0F, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0xC6, 0x01, 0xAB, 0x07, 
0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA7, 0x03, 
0xA3, 0x09, 0xA7, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x05, 0xA7, 0x0B, 0xA9, 0x05, 0xA7, 0x07, 0xA7, 0x07, 
0xA7, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA7, 0x0B, 
0xA7, 0x03, 0xA3, 0x0B, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 
0xA3, 0x07, 0xA7, 0x05, 0xA7, 0x0B, 0xA9, 0x03, 0xA7, 0x09, 0xA3, 0x05, 
0xA7, 0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x3E, 0x03, 0xA3, 0xFE, 0x04, 0xA3, 0xEC, 0x44, 0x00, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0x09, 
0xA3, 0x8E, 0x00, 0xA5, 0x76, 0x00, 0xA3, 0x46, 0x00, 0xA3, 0x02, 0x03, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x4A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0xA2, 
0x00, 0xA3, 0x7A, 0x00, 0xA3, 0x4E, 0x03, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA9, 0x03, 0xA7, 0x0B, 0xA9, 0x03, 0xA3, 
0x07, 0xA7, 0x05, 0xA7, 0x05, 0xA9, 0x03, 0xA9, 0x05, 0xA7, 0x0B, 0xAB, 
0x0B, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x03, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 
0x05, 0xA9, 0x05, 0xA5, 0xCE, 0x02, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0xC6, 
0x02, 0xA5, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 
0x0B, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA5, 
0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 
0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xAB, 0xC2, 0x02, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x0B, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x09, 
0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x07, 0xA3, 0x07, 0xA5, 0x0B, 0xA3, 0x05, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0xCE, 0x02, 0xA3, 0x05, 0xA3, 
0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 
0x03, 0xA7, 0x09, 0xA9, 0x03, 0xA3, 0x05, 0xA7, 0x07, 0xA7, 0x05, 0xA9, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x0B, 0xAB, 0x0B, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x03, 0xA5, 
0x05, 0xA7, 0x03, 0xA3, 0x07, 0xAB, 0x03, 0xA3, 0x05, 0xA7, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA7, 0x05, 0xA3, 0x92, 0x03, 0xA3, 0x07, 0xA3, 0xF2, 
0x04, 0xA7, 0x06, 0x0E, 0xA7, 0x03, 0xA3, 0x0B, 0xA3, 0x7E, 0x00, 0xA3, 
0x03, 0xA3, 0x07, 0xA3, 0x3A, 0x00, 0xA3, 0x0D, 0xA3, 0x6E, 0x00, 0xA7, 
0x03, 0xA3, 0x05, 0xA3, 0x32, 0x00, 0xA3, 0x05, 0xA3, 0x22, 0x00, 0xA5, 
0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0xC2, 0x02, 0xA3, 0x07, 0xA5, 0x96, 
0x00, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x52, 0x00, 0xA3, 0x6A, 
0x00, 0xA3, 0x07, 0xA5, 0x3E, 0x00, 0xA3, 0x2E, 0x00, 0xA3, 0x0D, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0xC2, 0x02, 0xA3, 0x09, 0xA9, 0x05, 0xA3, 0x03, 
0xA7, 0x07, 0xA7, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA7, 0x03, 0xA5, 0x0B, 
0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x09, 0xA7, 0x05, 0xA7, 0x03, 0xA3, 0x05, 
0xA7, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xAF, 0x0D, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x03, 0xA3, 0x0B, 
0xAB, 0x0D, 0xA5, 0x05, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x8A, 
0x02, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x09, 0xA3, 0x09, 0xA3, 
0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x07, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 
0x07, 0xA5, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x8E, 0x02, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x05, 
0xA9, 0x09, 0xA3, 0x09, 0xA7, 0x09, 0xA5, 0x07, 0xA5, 0x05, 0xA3, 0x05, 
0xA5, 0x05, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x07, 
0xA7, 0x0B, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x0D, 0xA5, 0x05, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x8E, 0x02, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x0F, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x03, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 
0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA5, 0x92, 0x02, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 0xA3, 0x07, 
0xA7, 0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x05, 0xA7, 0x05, 
0xA3, 0x03, 0xA7, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 
0xA9, 0x03, 0xA7, 0x0D, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x03, 0xA3, 0x0B, 0xAB, 0x0B, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x07, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x40, 
0x4D, 0x00, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x7A, 0x00, 0xA5, 0x46, 0x00, 0xA3, 0x05, 0xA3, 0x1E, 0x01, 
0xA3, 0x6A, 0x00, 0xA3, 0x22, 0x02, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x3A, 
0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 0xA3, 0x4A, 0x00, 0xA3, 
0x2A, 0x01, 0xA3, 0x6A, 0x00, 0xA3, 0x26, 0x02, 0xA3, 0x05, 0xA3, 0x03, 
0xA7, 0x05, 0xA5, 0x03, 0xA7, 0x03, 0xA5, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 
0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA9, 0x07, 0xA5, 0x09, 0xA5, 0x05, 
0xA7, 0x05, 0xA9, 0x05, 0xA5, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x03, 
0xA9, 0x05, 0xA9, 0x05, 0xA5, 0x0B, 0xA9, 0x03, 0xA7, 0x07, 0xA7, 0x0B, 
0xA5, 0x07, 0xA7, 0x03, 0xA7, 0x03, 0xA7, 0x03, 0xA5, 0x07, 0xA5, 0x05, 
0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA9, 0x05, 
0xA5, 0x22, 0x02, 0xA3, 0x05, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 
0x05, 0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 
0x05, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0F, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x26, 0x02, 0xA3, 0x05, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x05, 0xA9, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA5, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA9, 0x07, 0xA3, 0x05, 0xA3, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x09, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xAB, 0x09, 0xA3, 0x07, 0xA3, 0x03, 
0xA7, 0x05, 0xA5, 0x0B, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 
0xA9, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x2A, 0x02, 0xA5, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x22, 0x00, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0x09, 
0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x0F, 0xA3, 0x07, 0xA5, 0x05, 
0xA3, 0x09, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 
0xA3, 0x2A, 0x02, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 
0x0B, 0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 
0x07, 0xA3, 0x07, 0xA3, 0x05, 0xA7, 0x07, 0xA3, 0x07, 0xA7, 0x05, 0xA3, 
0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA5, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 
0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA7, 0x09, 0xA9, 0x05, 0xA7, 
0x03, 0xA7, 0x0D, 0xA5, 0x07, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x07, 0xA7, 
0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 
0x05, 0xA7, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA3, 0xCE, 0x03, 
0xA3, 0xFE, 0x04, 0xA3, 0x1E, 0x0A, 0xA3, 0xA2, 0x00, 0xA3, 0x5E, 0x02, 
0xA3, 0x09, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0x36, 0x00, 0xA3, 0x2E, 0x00, 0xA5, 0x6E, 0x00, 
0xA3, 0x0F, 0xA3, 0x09, 0xA3, 0x3A, 0x00, 0xA3, 0x05, 0xA3, 0x32, 0x00, 
0xA3, 0x09, 0xA3, 0x05, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x0E, 0x02, 0xA3, 0x09, 0xA3, 0x36, 0x00, 0xA3, 0x03, 0xA3, 0x7A, 0x00, 
0xA3, 0x32, 0x00, 0xA3, 0x36, 0x00, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 
0x6A, 0x00, 0xA3, 0x32, 0x00, 0xA3, 0x3A, 0x00, 0xA3, 0x3E, 0x00, 0xA3, 
0x0F, 0xA3, 0x2A, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x12, 0x02, 0xA3, 
0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x05, 0xA9, 0x09, 0xA5, 0x07, 0xA7, 0x03, 0xA9, 0x05, 0xA5, 
0x03, 0xA7, 0x07, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 0x07, 0xA3, 
0x05, 0xA5, 0x0D, 0xA3, 0x09, 0xA3, 0x07, 0xAB, 0x05, 0xA9, 0x05, 0xA7, 
0x05, 0xAB, 0x09, 0xA7, 0x09, 0xA3, 0x05, 0xA7, 0x0B, 0xA5, 0x05, 0xA3, 
0x05, 0xA3, 0x05, 0xA5, 0x05, 0xA9, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA3, 
0x05, 0xA5, 0x0F, 0xA5, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 
0xDA, 0x01, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x09, 
0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x0B, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 
0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x22, 0x00, 0xA3, 0x07, 0xA3, 0x0B, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA3, 
0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x0F, 0xA3, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 0xDE, 0x01, 
0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA9, 0x05, 0xA3, 0x0B, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x07, 
0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA3, 0x09, 0xA3, 0x05, 0xA9, 0x03, 
0xA3, 0x0B, 0xA3, 0x03, 0xA9, 0x22, 0x00, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 
0x07, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x0D, 0xA7, 0x07, 0xA3, 0x07, 0xA7, 0x07, 0xA3, 0x09, 0xA3, 0x05, 0xA3, 
0x03, 0xA9, 0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA9, 0x03, 0xA3, 
0x03, 0xA9, 0x0D, 0xA5, 0x05, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x05, 0xA5, 
0xE2, 0x01, 0xA5, 0x05, 0xA3, 0x09, 0xA3, 0x07, 0xA5, 0x05, 0xA3, 0x03, 
0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0D, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x05, 
0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x09, 0xA3, 0x0B, 0xA3, 0x03, 0xA3, 0x22, 
0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 
0x07, 0xA5, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 0x0B, 0xA3, 0x05, 0xA3, 
0x07, 0xA3, 0x05, 0xA3, 0x05, 0xA3, 0x07, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 
0x05, 0xA3, 0x03, 0xA3, 0x09, 0xA3, 0x07, 0xA3, 0x03, 0xA3, 0x05, 0xA3, 
0x09, 0xA3, 0x03, 0xA3, 0x22, 0x00, 0xA3, 0x05, 0xA3, 0x03, 0xA3, 0x07, 
0xA5, 0x07, 0xA3, 0x05, 0xA5, 0xE2, 0x01, 0xA5, 0x07, 0xA7, 0x05, 0xAB, 
0x05, 0xA3, 0x03, 0xA3, 0x07, 0xA7, 0x03, 0xA9, 0x09, 0xA5, 0x07, 0xA7, 
0x03, 0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x05, 0xA5, 0x05, 0xA5, 
0x05, 0xA7, 0x03, 0xA3, 0x0B, 0xA3, 0x05, 0xA7, 0x0D, 0xA5, 0x07, 0x22, 
0xA0, 0x05, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA5, 0x0B, 0xA7, 0x07, 
0xA3, 0x07, 0xA7, 0x09, 0xA5, 0x05, 0xA3, 0x05, 0xA3, 0x05, 0xA7, 0x03, 
0xA3, 0x07, 0xA3, 0x03, 0xA5, 0x05, 0xA7, 0x03, 0xA3, 0x05, 0xA7, 0x0B, 
0xA3, 0x05, 0xA3, 0x03, 0xA9, 0x05, 0xA7, 0x05, 0xA3, 0x05, 0xA3, 0x05, 
0xA3, 0x5A, 0x03, 0xA3, 0x0B, 0xA3, 0xE6, 0x04, 0xA3, 0x0B, 0xA3, 0x94, 
0x3F, 0x00, 0x2A, 0xA0, 0x09, 0xAD, 0x22, 0x00, 0xA5, 0x26, 0x00, 0xA5, 
0x05, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 
0xA5, 0x26, 0x00, 0xA5, 0x46, 0x00, 0xA5, 0x2E, 0x00, 0xA7, 0x09, 0xAF, 
0x56, 0x00, 0xA5, 0x22, 0x00, 0xA5, 0x05, 0xA7, 0x52, 0x02, 0xA5, 0x22, 
0x00, 0xA5, 0x05, 0xA5, 0x0F, 0xA9, 0x22, 0x00, 0xA5, 0x22, 0x00, 0xA5, 
0x03, 0xA5, 0x0F, 0xA5, 0x05, 0xA7, 0x05, 0xAD, 0x0B, 0xA5, 0x26, 0x00, 
0xA5, 0x46, 0x00, 0xA5, 0x05, 0xA5, 0x07, 0xAB, 0x22, 0x00, 0xA5, 0x03, 
0xA5, 0x0D, 0x26, 0xA0, 0x05, 0x26, 0xA0, 0x0B, 0xA5, 0x62, 0x02, 0xA5, 
0x26, 0x00, 0xAD, 0x0D, 0xA5, 0x05, 0xA5, 0x0B, 0xAB, 0x03, 0xA5, 0x09, 
0x26, 0xA0, 0x07, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x0F, 0xAD, 0x36, 
0x00, 0xAD, 0x03, 0xA5, 0x0B, 0xA5, 0x0D, 0x2A, 0xA0, 0x0F, 0xA5, 0x26, 
0x00, 0xA5, 0x0D, 0xAB, 0x03, 0xA5, 0x4E, 0x02, 0xAD, 0x0D, 0xA5, 0x05, 
0xA5, 0x09, 0x2A, 0xA0, 0x09, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 
0x05, 0xA5, 0x0F, 0xA5, 0x0F, 0xAF, 0x09, 0xA5, 0x26, 0x00, 0xA5, 0x46, 
0x00, 0xA5, 0x0F, 0x22, 0xA0, 0x07, 0x26, 0xA0, 0x0F, 0xA5, 0x03, 0xA7, 
0x09, 0xA9, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x46, 0x02, 0xA5, 0x03, 
0xA5, 0x03, 0xA5, 0x0B, 0xAD, 0x4A, 0x00, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 
0x0D, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA5, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 
0x03, 0xAB, 0x32, 0x00, 0xAD, 0x0D, 0xA5, 0x22, 0x00, 0xA9, 0x03, 0xA5, 
0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 
0xA5, 0x42, 0x02, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x3E, 0x00, 0x22, 0xA0, 
0x0B, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x07, 0x22, 0xA0, 0x09, 0xA5, 0x2A, 
0x00, 0xA5, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x46, 0x00, 0xA7, 0x07, 0xA5, 
0x03, 0x2A, 0xA0, 0x05, 0x26, 0xA0, 0x0D, 0xA5, 0x22, 0x00, 0xA5, 0x03, 
0xA5, 0x0F, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x52, 0x02, 0xA5, 0x0D, 0x2A, 
0xA0, 0x07, 0xA5, 0x09, 0xA5, 0x09, 0xA5, 0x05, 0xAB, 0x0D, 0xA5, 0x0F, 
0xA5, 0x07, 0xA5, 0x05, 0xAB, 0x0D, 0xA5, 0x07, 0xA5, 0x07, 0xA5, 0x22, 
0x00, 0xA5, 0x0D, 0xA9, 0x07, 0xA5, 0x0B, 0xA5, 0x0F, 0xA9, 0x03, 0xA5, 
0x0F, 0xA5, 0x26, 0x00, 0xA9, 0x0D, 0xA5, 0x05, 0xAB, 0x52, 0x02, 0xA5, 
0x22, 0x00, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x09, 0xA5, 0x09, 0xA5, 0x05, 
0xA5, 0x26, 0x00, 0xA5, 0x0F, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x05, 0xA7, 
0x0B, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x09, 0xA9, 0x0B, 0xAD, 
0x03, 0xA5, 0x0B, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA9, 0x0F, 0xA5, 0x2A, 
0x00, 0xA5, 0x0D, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x42, 0x02, 0xA5, 0x0F, 
0xA5, 0x09, 0xA5, 0x09, 0x22, 0xA0, 0x09, 0xAB, 0x0D, 0x2A, 0xA0, 0x09, 
0xA9, 0x09, 0xA9, 0x03, 0xA5, 0x0B, 0xA9, 0x09, 0xA5, 0x05, 0xAB, 0x05, 
0xA5, 0x0F, 0xA7, 0x03, 0xA7, 0x0B, 0xA7, 0x0D, 0xAD, 0x05, 0xA5, 0x0F, 
0xA7, 0x0B, 0xA9, 0x0F, 0xAB, 0x0F, 0xA5, 0x28, 0x25, 0x00, 0xA5, 0x4E, 
0x00, 0xA5, 0x8A, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA7, 
0x36, 0x00, 0xA5, 0x0F, 0xA5, 0x2E, 0x00, 0xA5, 0x0D, 0x2A, 0xA0, 0x46, 
0x00, 0xA5, 0x26, 0x00, 0xA5, 0x2A, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA5, 
0x0B, 0xA5, 0x2A, 0x00, 0xA5, 0x52, 0x01, 0xA5, 0x07, 0xA5, 0x03, 0xA5, 
0x5E, 0x00, 0xA5, 0x22, 0x00, 0xAF, 0x09, 0xAD, 0x05, 0x26, 0xA0, 0x4E, 
0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 0x03, 0xA7, 0x36, 0x00, 0xA5, 
0x0F, 0xA5, 0x03, 0xAD, 0x09, 0xA5, 0x05, 0xA5, 0x05, 0xA5, 0x03, 0xA9, 
0x03, 0xA5, 0x05, 0xA5, 0x32, 0x00, 0xA9, 0x22, 0x00, 0xA5, 0x2A, 0x00, 
0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x0D, 0xA5, 0x05, 0xA7, 0x0B, 0xA5, 0x07, 
0xA5, 0x42, 0x01, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x56, 0x00, 0x22, 0xA0, 
0x26, 0x00, 0xA5, 0x07, 0xA5, 0x07, 0xA5, 0x26, 0x00, 0xA5, 0x4A, 0x00, 
0x26, 0xA0, 0x07, 0x22, 0xA0, 0x3A, 0x00, 0xA5, 0x0F, 0xA5, 0x26, 0x00, 
0xAD, 0x03, 0xA5, 0x03, 0x2A, 0xA0, 0x05, 0xA5, 0x09, 0xA5, 0x0B, 0xA5, 
0x05, 0xA5, 0x0B, 0x22, 0xA0, 0x0D, 0xAF, 0x07, 0xA5, 0x0B, 0xAD, 0x0B, 
0x2A, 0xA0, 0x09, 0xA5, 0x2E, 0x01, 0xA7, 0x07, 0xA9, 0x07, 0xA9, 0x05, 
0xA5, 0x05, 0xA5, 0x0D, 0xA5, 0x05, 0xA5, 0x26, 0x00, 0xA5, 0x07, 0xA5, 
0x07, 0xA5, 0x22, 0x00, 0xA5, 0x52, 0x00, 0xA5, 0x05, 0xA5, 0x22, 0x00, 
0xA5, 0x46, 0x00, 0xA9, 0x0B, 0xA5, 0x2E, 0x00, 0xA5, 0x0D, 0xA5, 0x0D, 
0xA5, 0x05, 0xA5, 0x09, 0xA5, 0x07, 0x2A, 0xA0, 0x0B, 0xA7, 0x05, 0xA5, 
0x07, 0xA9, 0x05, 0xA5, 0x07, 0xA5, 0x22, 0x00, 0xA5, 0x2E, 0x00, 0xA5, 
0x05, 0xA5, 0x09, 0xA5, 0x2E, 0x01, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 0x03, 
0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x0F, 0xA5, 0x05, 0xA5, 0x22, 0x00, 0xA5, 
0x07, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x07, 0xA5, 0x05, 0xA5, 0x09, 0x22, 
0xA0, 0x26, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 0xA5, 0x07, 0x22, 
0xA0, 0x07, 0xA5, 0x03, 0xA7, 0x07, 0xA5, 0x2E, 0x00, 0xAD, 0x05, 0xA5, 
0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x46, 0x00, 0xA5, 0x07, 
0xA5, 0x0B, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x0F, 0xA5, 0x03, 0xAB, 0x0D, 
0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x2A, 0x01, 0xA7, 0x07, 0xA5, 0x03, 0xA5, 
0x03, 0xA5, 0x05, 0xA5, 0x07, 0xA5, 0x0F, 0xA5, 0x07, 0xA5, 0x0F, 0xA7, 
0x0F, 0xA7, 0x0B, 0xA9, 0x5A, 0x00, 0xA5, 0x05, 0xA5, 0x0D, 0xA9, 0x03, 
0xA5, 0x3A, 0x00, 0xA5, 0x0F, 0xA5, 0x2A, 0x00, 0xA7, 0x07, 0xA5, 0x03, 
0xA5, 0x03, 0xA9, 0x03, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x07, 0x22, 0xA0, 
0x0B, 0xA7, 0x07, 0xA5, 0x0B, 0xA5, 0x03, 0xA7, 0x09, 0xA5, 0x0D, 0xA5, 
0x26, 0x00, 0xAD, 0x03, 0xA5, 0x0B, 0xA5, 0x26, 0x01, 0xA5, 0x03, 0xA5, 
0x05, 0xA5, 0x03, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x05, 0xA9, 0x0D, 0xA5, 
0x07, 0xA5, 0x0D, 0xA5, 0x03, 0xA5, 0x0F, 0xA5, 0x0D, 0xA5, 0x6E, 0x00, 
0xA5, 0x0B, 0xA5, 0x03, 0xA5, 0x05, 0xA5, 0x36, 0x00, 0xA5, 0x0F, 0xA5, 
0x03, 0xA5, 0x0D, 0xA9, 0x07, 0xA5, 0x03, 0xA5, 0x03, 0xA9, 0x03, 0xA5, 
0x05, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x09, 0xA5, 0x09, 0xA9, 0x07, 0xA5, 
0x0B, 0xA5, 0x26, 0x00, 0xA5, 0x0B, 0xA5, 0x22, 0x00, 0xA5, 0x07, 0xA5, 
0x03, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x0E, 0x01, 0xA5, 0x07, 0xA5, 0x03, 
0xA9, 0x07, 0xA9, 0x05, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x07, 0xA5, 0x0B, 
0xA5, 0x07, 0xA5, 0x09, 0xAB, 0x0D, 0xA5, 0x66, 0x00, 0xA5, 0x0D, 0xA5, 
0x03, 0xA5, 0x05, 0xA5, 0x36, 0x00, 0xA5, 0x0F, 0xA5, 0x03, 0xAD, 0x05, 
0xAD, 0x03, 0xA5, 0x03, 0xA5, 0x0D, 0xA5, 0x05, 0xA5, 0x03, 0xA5, 0x0F, 
0xA5, 0x09, 0xA5, 0x0D, 0xA5, 0x07, 0xA5, 0x0B, 0xA5, 0x2A, 0x00, 0xA5, 
0x07, 0xA5, 0x05, 0xA5, 0x0B, 0xA5, 0x0D, 0xA5, 0x03, 0xA5, 0x0D, 0xA9, 
0x86, 0x01, 0xA5, 0x03, 0xA9, 0x09, 0xA7, 0x09, 0xA5, 0x05, 0xA7, 0x2A, 
0x00, 0xA5, 0x5E, 0x00, 0xA7, 0x26, 0x00, 0xA7, 0x46, 0x00, 0xA5, 0x0F, 
0xA5, 0x2A, 0x00, 0xA7, 0x03, 0xA7, 0x05, 0xA5, 0x0B, 0xA7, 0x07, 0xA7, 
0x22, 0x00, 0x22, 0xA0, 0x0D, 0xA5, 0x03, 0xA7, 0x0F, 0xAD, 0x0D, 0xA5, 
0x05, 0xA5, 0x05, 0xAB, 0x07, 0xAB, 0x07, 0xA7, 0x22, 0x00, 0xA5, 0x84, 
0x82, 0x00, 

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\arcade\makefile.inc ===
BOOTXFILES=..\..\obj\i386

obj\$(TARGET_DIRECTORY)\$(NTTEST).def: ..\ntoskrnl.src
    copy ..\ntoskrnl.src obj\$(TARGET_DIRECTORY)\$(NTTEST).pp
    $(TARGET_CPP) -nologo -EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(WIN32_DEFINE) $(C_DEFINES) obj\$(TARGET_DIRECTORY)\$(NTTEST).pp > obj\$(TARGET_DIRECTORY)\$(NTTEST).def
    -del obj\$(TARGET_DIRECTORY)\$(NTTEST).pp

$(O)\$(NTTEST).exp: obj\$(TARGET_DIRECTORY)\$(NTTEST).def \
        $(KERNEL_LIBS)
    -lib @<<
$(LINK_LIB_IGNORE_FLAG)
-def:obj\$(TARGET_DIRECTORY)\$(NTTEST).def
-debugtype:cv
-out:$(@R).lib
-machine:$(MACHINE_TYPE)
$(KERNEL_LIBS)
<<NOKEEP

..\init.c: $(BASEDIR)\private\inc\xboxverp.h

!IF DEFINED(RETAILXM3)
ROMBLDSYS=xm3
!ELSE
ROMBLDSYS=xdk
!ENDIF

obj\i386\arcdrom_dvt6.bin: obj\i386\arcdkrnl.exe $(BOOTXFILES)\inittbl_dvt6.bin $(BOOTXFILES)\xboxbldr.bin $(BOOTXFILES)\romdec32.bin
    rombld /config:<<
    /out:obj\i386\arcdrom_dvt6.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\arcdrom_dvt6_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(BOOTXFILES)\inittbl_dvt6.bin
    /bldr:$(BOOTXFILES)\xboxbldr.bin
    /preldr:$(BOOTXFILES)\xpreldr.bin
    /kernel:obj\i386\arcdkrnl.exe
    /romdec:$(BOOTXFILES)\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\arcdrom_dvt6_ext.bin
!ENDIF
!ENDIF

!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\arcdkrnl.map
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\init\console\makefile.inc ===
obj\$(TARGET_DIRECTORY)\$(NTTEST).def: ..\ntoskrnl.src
    copy ..\ntoskrnl.src obj\$(TARGET_DIRECTORY)\$(NTTEST).pp
    $(TARGET_CPP) -nologo -EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(WIN32_DEFINE) $(C_DEFINES) obj\$(TARGET_DIRECTORY)\$(NTTEST).pp > obj\$(TARGET_DIRECTORY)\$(NTTEST).def
    -del obj\$(TARGET_DIRECTORY)\$(NTTEST).pp

$(BASEDIR)\public\sdk\lib\$(TARGET_DIRECTORY)\xboxkrnl.lib : $(O)\xboxkrnl.lib
    copy $** $@

$(O)\$(NTTEST).lib $(O)\$(NTTEST).exp: obj\$(TARGET_DIRECTORY)\$(NTTEST).def $(O)\bldnum.obj \
        $(KERNEL_LIBS)
    -lib @<<
$(LINK_LIB_IGNORE_FLAG)
-def:obj\$(TARGET_DIRECTORY)\$(NTTEST).def
-debugtype:cv
-out:$(@R).lib
-machine:$(MACHINE_TYPE)
$(KERNEL_LIBS)
<<NOKEEP
    -lib -out:$(@R).lib @<<
$(@R).lib
$(O)\bldnum.obj
<<NOKEEP

..\init.c: $(BASEDIR)\private\inc\xboxverp.h

{}bldnum.c{$O\}bldnum.obj:
    @type <<$(ECHO_RSP)
$(ECHO_MSG)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$O/" $(USE_FC) $(USECXX_FLAG) $<
$(EX_C_COMPILER_FLAGS)
<<NOKEEP

$(XDK_LIB_PATH)\xboxkrnl.lib: $(SDK_LIB_PATH)\xboxkrnl.lib
    copy $** $@
    
!IF DEFINED(RETAILXM3)
ROMBLDSYS=xm3
!ELSE
ROMBLDSYS=xdk
!ENDIF

obj\i386\xboxrom_dvt4.bin: obj\i386\xboxkrnl.exe $(TARGETPATH2)\i386\inittbl_dvt4.bin $(TARGETPATH2)\i386\xboxbldr.bin $(TARGETPATH2)\i386\romdec32.bin
    hackedrombld /config:<<
    /out:obj\i386\xboxrom_dvt4.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\xboxrom_dvt4_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(TARGETPATH2)\i386\inittbl_dvt4.bin
    /bldr:$(TARGETPATH2)\i386\xboxbldr.bin
    /preldr:$(TARGETPATH2)\i386\xpreldr.bin
    /kernel:obj\i386\xboxkrnl.exe
    /romdec:$(TARGETPATH2)\i386\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxrom_dvt4_ext.bin
!ENDIF
!ENDIF


obj\i386\xboxrom_dvt6.bin: obj\i386\xboxkrnl.exe $(TARGETPATH2)\i386\inittbl_dvt6.bin $(TARGETPATH2)\i386\xboxbldr.bin $(TARGETPATH2)\i386\romdec32.bin
    hackedrombld /config:<<
    /out:obj\i386\xboxrom_dvt6.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\xboxrom_dvt6_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(TARGETPATH2)\i386\inittbl_dvt6.bin
    /bldr:$(TARGETPATH2)\i386\xboxbldr.bin
    /preldr:$(TARGETPATH2)\i386\xpreldr.bin
    /kernel:obj\i386\xboxkrnl.exe
    /romdec:$(TARGETPATH2)\i386\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxrom_dvt6_ext.bin
!ENDIF
!ENDIF


obj\i386\xboxrom_qt.bin: obj\i386\xboxkrnl.exe $(TARGETPATH2)\i386\inittbl_qt.bin $(TARGETPATH2)\i386\xboxbldr.bin $(TARGETPATH2)\i386\romdec32.bin
    hackedrombld /config:<<
    /out:obj\i386\xboxrom_qt.bin
!IF !DEFINED(NODEVKIT)
    /outext:obj\i386\xboxrom_qt_ext.bin
!ENDIF
    /sys:$(ROMBLDSYS)
    /inittbl:$(TARGETPATH2)\i386\inittbl_qt.bin
    /bldr:$(TARGETPATH2)\i386\xboxbldr.bin
    /preldr:$(TARGETPATH2)\i386\xpreldr.bin
    /kernel:obj\i386\xboxkrnl.exe
    /romdec:$(TARGETPATH2)\i386\romdec32.bin
!if $(FREEBUILD)
    /sizek:256
!else
    /sizek:512
!endif
<<NOKEEP
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!IF !DEFINED(NODEVKIT)
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxrom_qt_ext.bin
!ENDIF
!ENDIF


!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) obj\i386\xboxkrnl.map
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\devctrl.c ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    devctrl.c

Abstract:

    This module contains the code to implement the NtDeviceIoControlFile and
    NtFsControlFile system services for the NT I/O system.

Author:

    Darryl E. Havens (darrylh) 16-Oct-1989

Environment:

    Kernel mode only

Revision History:


--*/

#include "iop.h"

NTSTATUS
NtDeviceIoControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the device driver associated with the file
    handle.  It is up to the driver to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        device driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the device driver.  Whether or not the buffer is actually optional
        is dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    //
    // Simply invoke the common routine that implements both device and file
    // system I/O controls.
    //

    return IopXxxControlFile( FileHandle,
                              Event,
                              ApcRoutine,
                              ApcContext,
                              IoStatusBlock,
                              IoControlCode,
                              InputBuffer,
                              InputBufferLength,
                              OutputBuffer,
                              OutputBufferLength,
                              TRUE );
}

NTSTATUS
NtFsControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the file system associated with the file
    handle.  It is up to the file system to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        file system.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the file system.  Whether or not the buffer is actually optional
        is dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    //
    // Simply invoke the common routine that implements both device and file
    // system I/O controls.
    //

    return IopXxxControlFile( FileHandle,
                              Event,
                              ApcRoutine,
                              ApcContext,
                              IoStatusBlock,
                              IoControlCode,
                              InputBuffer,
                              InputBufferLength,
                              OutputBuffer,
                              OutputBufferLength,
                              FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\complete.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    complete.c

Abstract:

   This module implements the executive I/O completion object. Functions are
   provided to create, open, query, and wait for I/O completion objects.

Author:

    David N. Cutler (davec) 25-Feb-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "iop.h"

#define IopFreeMiniPacket(MiniPacket) ExFreePool(MiniPacket)

NTSTATUS
NtCreateIoCompletion (
    IN PHANDLE IoCompletionHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN ULONG Count OPTIONAL
    )

/*++

Routine Description:

    This function creates an I/O completion object, sets the maximum
    target concurrent thread count to the specified value, and opens
    a handle to the object with the specified desired access.

Arguments:

    IoCompletionHandle - Supplies a pointer to a variable that receives
        the I/O completion object handle.

    DesiredAccess - Supplies the desired types of access for the I/O
        completion object.

    ObjectAttributes - Supplies a pointer to an object attributes structure.

    Count - Supplies the target maximum  number of threads that should
        be concurrently active. If this parameter is not specified, then
        the number of processors is used.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    HANDLE Handle;
    PVOID IoCompletion;
    NTSTATUS Status;

    //
    // Allocate I/O completion object.
    //

    Status = ObCreateObject(&IoCompletionObjectType,
                            ObjectAttributes,
                            sizeof(KQUEUE),
                            (PVOID *)&IoCompletion);

    //
    // If the I/O completion object was successfully allocated, then
    // initialize the object and attempt to insert it in the handle
    // table of the current process.
    //

    if (NT_SUCCESS(Status)) {
        KeInitializeQueue((PKQUEUE)IoCompletion, Count);
        Status = ObInsertObject(IoCompletion,
                                ObjectAttributes,
                                0,
                                &Handle);

        //
        // If the I/O completion object was successfully inserted in
        // the handle table of the current process, then attempt to
        // write the handle value. If the write attempt fails, then
        // do not report an error. When the caller attempts to access
        // the handle value, an access violation will occur.
        //

        if (NT_SUCCESS(Status)) {
            *IoCompletionHandle = Handle;
        }
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtQueryIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PIO_COMPLETION_BASIC_INFORMATION IoCompletionInformation
    )

/*++

Routine Description:

    This function queries the state of an I/O completion object and returns
    the requested information in the specified record structure.

Arguments:

    IoCompletionHandle - Supplies a handle to an I/O completion object.

    IoCompletionInformation - Supplies a pointer to a record that receives
        the requested information.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PVOID IoCompletion;
    LONG Depth;
    NTSTATUS Status;

    //
    // Reference the I/O completion object by handle.
    //

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       &IoCompletionObjectType,
                                       &IoCompletion);

    //
    // If the reference was successful, then read the current state of
    // the I/O completion object, dereference the I/O completion object,
    // fill in the information structure, and return the structure length
    // if specified. If the write of the I/O completion information or
    // the return length fails, then do not report an error. When the
    // caller accesses the information structure or length an access
    // violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Depth = KeReadStateQueue((PKQUEUE)IoCompletion);
        ObDereferenceObject(IoCompletion);

        IoCompletionInformation->Depth = Depth;
    }

    //
    // Return service status.
    //

    return Status;
}

NTSTATUS
NtSetIoCompletion (
    IN HANDLE IoCompletionHandle,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    )
/*++

Routine Description:

    This function allows the caller to queue an Irp to an I/O completion
    port and specify all of the information that is returned out the other
    end using NtRemoveIoCompletion.

Arguments:

    IoCompletionHandle - Supplies a handle to the io completion port
        that the caller intends to queue a completion packet to

    KeyContext - Supplies the key context that is returned during a call
        to NtRemoveIoCompletion

    ApcContext - Supplies the apc context that is returned during a call
        to NtRemoveIoCompletion

    IoStatus - Supplies the IoStatus->Status data that is returned during
        a call to NtRemoveIoCompletion

    IoStatusInformation - Supplies the IoStatus->Information data that
        is returned during a call to NtRemoveIoCompletion

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{
    PVOID IoCompletion;
    NTSTATUS Status;

    PAGED_CODE();

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       &IoCompletionObjectType,
                                       &IoCompletion);

    if (NT_SUCCESS(Status)) {
        Status = IoSetIoCompletion(IoCompletion,
                                   KeyContext,
                                   ApcContext,
                                   IoStatus,
                                   IoStatusInformation);

        ObDereferenceObject(IoCompletion);
        }
    return Status;

}

NTSTATUS
NtRemoveIoCompletion (
    IN HANDLE IoCompletionHandle,
    OUT PVOID *KeyContext,
    OUT PVOID *ApcContext,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function removes an entry from an I/O completion object. If there
    are currently no entries available, then the calling thread waits for
    an entry.

Arguments:

    Completion - Supplies a handle to an I/O completion object.

    KeyContext - Supplies a pointer to a variable that receives the key
        context that was specified when the I/O completion object was
        assoicated with a file object.

    ApcContext - Supplies a pointer to a variable that receives the
        context that was specified when the I/O operation was issued.

    IoStatus - Supplies a pointer to a variable that receives the
        I/O completion status.

    Timeout - Supplies a pointer to an optional time out value.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PLARGE_INTEGER CapturedTimeout;
    PLIST_ENTRY Entry;
    PVOID IoCompletion;
    PIRP Irp;
    NTSTATUS Status;
    PVOID LocalApcContext;
    PVOID LocalKeyContext;
    IO_STATUS_BLOCK LocalIoStatusBlock;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;

    //
    // Get previous processor mode and probe the I/O context, status,
    // and timeout if necessary.
    //

    CapturedTimeout = NULL;
    if (ARGUMENT_PRESENT(Timeout)) {
        CapturedTimeout = Timeout;
    }

    //
    // Reference the I/O completion object by handle.
    //

    Status = ObReferenceObjectByHandle(IoCompletionHandle,
                                       &IoCompletionObjectType,
                                       &IoCompletion);

    //
    // If the reference was successful, then attempt to remove an entry
    // from the I/O completion object. If an entry is removed from the
    // I/O completion object, then capture the completion information,
    // release the associated IRP, and attempt to write the completion
    // inforamtion. If the write of the completion infomation fails,
    // then do not report an error. When the caller attempts to access
    // the completion information, an access violation will occur.
    //

    if (NT_SUCCESS(Status)) {
        Entry = KeRemoveQueue((PKQUEUE)IoCompletion,
                              KernelMode,
                              CapturedTimeout);

        //
        // N.B. The entry value returned can be the address of a list
        //      entry, STATUS_USER_APC, or STATUS_TIMEOUT.
        //

        if (((LONG_PTR)Entry == STATUS_TIMEOUT) ||
            ((LONG_PTR)Entry == STATUS_USER_APC)) {
            Status = (NTSTATUS)((LONG_PTR)Entry);

        } else {

            //
            // Set the completion status, capture the completion
            // information, deallocate the associated IRP, and
            // attempt to write the completion information.
            //

            Status = STATUS_SUCCESS;

            MiniPacket = CONTAINING_RECORD(Entry,
                                           IOP_MINI_COMPLETION_PACKET,
                                           ListEntry);

            if ( MiniPacket->PacketType == IopCompletionPacketIrp ) {
                Irp = CONTAINING_RECORD(Entry, IRP, Tail.Overlay.ListEntry);
                LocalApcContext = Irp->Overlay.AsynchronousParameters.UserApcContext;
                LocalKeyContext = (PVOID)Irp->Tail.CompletionKey;
                LocalIoStatusBlock = Irp->IoStatus;
                IoFreeIrp(Irp);

            } else {

                LocalApcContext = MiniPacket->ApcContext;
                LocalKeyContext = (PVOID)MiniPacket->KeyContext;
                LocalIoStatusBlock.Status = MiniPacket->IoStatus;
                LocalIoStatusBlock.Information = MiniPacket->IoStatusInformation;
                IopFreeMiniPacket(MiniPacket);
            }

            *ApcContext = LocalApcContext;
            *KeyContext = LocalKeyContext;
            *IoStatusBlock = LocalIoStatusBlock;
        }

        //
        // Deference I/O completion object.
        //

        ObDereferenceObject(IoCompletion);
    }

    //
    // Return service status.
    //

    return Status;
}

NTKERNELAPI
NTSTATUS
IoSetIoCompletion (
    IN PVOID IoCompletion,
    IN PVOID KeyContext,
    IN PVOID ApcContext,
    IN NTSTATUS IoStatus,
    IN ULONG_PTR IoStatusInformation
    )
/*++

Routine Description:

    This function allows the caller to queue an Irp to an I/O completion
    port and specify all of the information that is returned out the other
    end using NtRemoveIoCompletion.

Arguments:

    IoCompletion - Supplies a a pointer to the completion port that the caller
        intends to queue a completion packet to.

    KeyContext - Supplies the key context that is returned during a call
        to NtRemoveIoCompletion.

    ApcContext - Supplies the apc context that is returned during a call
        to NtRemoveIoCompletion.

    IoStatus - Supplies the IoStatus->Status data that is returned during
        a call to NtRemoveIoCompletion.

    IoStatusInformation - Supplies the IoStatus->Information data that
        is returned during a call to NtRemoveIoCompletion.

Return Value:

    STATUS_SUCCESS is returned if the function is success. Otherwise, an
    error status is returned.

--*/

{

    PIOP_MINI_COMPLETION_PACKET MiniPacket;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // Attempt to allocate the minpacket from the per processor lookaside list.
    //

    MiniPacket = ExAllocatePoolWithTag(sizeof(*MiniPacket), ' pcI');

    //
    // If a minipacket was successfully allocated, then initialize and
    // queue the packet to the specified I/O completion queue.
    //

    if (MiniPacket != NULL) {
        MiniPacket->PacketType = IopCompletionPacketMini;
        MiniPacket->KeyContext = KeyContext;
        MiniPacket->ApcContext = ApcContext;
        MiniPacket->IoStatus = IoStatus;
        MiniPacket->IoStatusInformation = IoStatusInformation;
        KeInsertQueue((PKQUEUE)IoCompletion, &MiniPacket->ListEntry);

        Status = STATUS_SUCCESS;

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

VOID
IopDeleteIoCompletion (
    IN PVOID Object
    )

/*++

Routine Description:

    This function is the delete routine for I/O completion objects. Its
    function is to release all the entries in the repsective completion
    queue and to rundown all threads that are current associated.

Arguments:

    Object - Supplies a pointer to an executive I/O completion object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY FirstEntry;
    PIRP Irp;
    PLIST_ENTRY NextEntry;
    PIOP_MINI_COMPLETION_PACKET MiniPacket;

    //
    // Rundown threads associated with the I/O completion object and get
    // the list of unprocessed I/O completion IRPs.
    //

    FirstEntry = KeRundownQueue((PKQUEUE)Object);
    if (FirstEntry != NULL) {
        NextEntry = FirstEntry;
        do {
            MiniPacket = CONTAINING_RECORD(NextEntry,
                                           IOP_MINI_COMPLETION_PACKET,
                                           ListEntry);

            NextEntry = NextEntry->Flink;
            if (MiniPacket->PacketType == IopCompletionPacketIrp) {
                Irp = CONTAINING_RECORD(MiniPacket, IRP, Tail.Overlay.ListEntry);
                IoFreeIrp(Irp);

            } else {
                IopFreeMiniPacket(MiniPacket);
            }

        } while (FirstEntry != NextEntry);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    create.c

Abstract

    This module contains the code to implement the NtCreateFile
    and NtOpenFile system services.

Author:

    Darryl E. Havens (darrylh) 14-Apr-1989

Environment:

    Kernel mode

Revision History:


--*/

#include "iop.h"

NTSTATUS
NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions
    )

/*++

Routine Description:

    This service opens or creates a file, or opens a device.  It is used to
    establish a file handle to the open device/file that can then be used
    in subsequent operations to perform I/O operations on.  For purposes of
    readability, files and devices are treated as "files" throughout the
    majority of this module and the system service portion of the I/O system.
    The only time a distinction is made is when it is important to determine
    which is really being accessed.  Then a distinction is also made in the
    comments.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.  This
        parameter only has an affect if the file is created.  Further, if
        not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    CreateDisposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to do the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         AllocationSize,
                         FileAttributes,
                         ShareAccess,
                         CreateDisposition,
                         CreateOptions,
                         0 );
}

NTSTATUS
NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )

/*++

Routine Description:

    This service opens a file or a device.  It is used to establish a file
    handle to the open device/file that can then be used in subsequent
    operations to perform I/O operations on.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    OpenOptions - Caller options for how to perform the open.

Return Value:

    The function value is the final completion status of the open/create
    operation.

--*/

{
    //
    // Simply invoke the common I/O file creation routine to perform the work.
    //

    PAGED_CODE();

    return IoCreateFile( FileHandle,
                         DesiredAccess,
                         ObjectAttributes,
                         IoStatusBlock,
                         (PLARGE_INTEGER) NULL,
                         0L,
                         ShareAccess,
                         FILE_OPEN,
                         OpenOptions,
                         0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\dir.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    dir.c

Abstract:

    This module contains the code to implement the NtQueryDirectoryFile
    system service for the NT I/O system.

--*/

#include "iop.h"

NTSTATUS
NtQueryDirectoryFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN POBJECT_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )

/*++

Routine Description:

    This service operates on a directory file specified by the FileHandle
    parameter.  The service returns information about files in the directory
    specified by the file handle.  The ReturnSingleEntry parameter specifies
    that only a single entry should be returned rather than filling the buffer.
    The actual number of files whose information is returned, is the smallest
    of the following:

        o  One entry, if the ReturnSingleEntry parameter is TRUE.

        o  The number of files whose information fits into the specified
           buffer.

        o  The number of files that exist.

        o  One entry if the optional FileName parameter is specified.

    If the optional FileName parameter is specified, then the only information
    that is returned is for that single file, if it exists.  Note that the
    file name may not specify any wildcard characters according to the naming
    conventions of the target file system.  The ReturnSingleEntry parameter is
    simply ignored.

    The information that is obtained about the files in the directory is based
    on the FileInformationClass parameter.  The legal values are as follows:

        o  FileNamesInformation

        o  FileDirectoryInformation

        o  FileFullDirectoryInformation

Arguments:

    FileHandle - Supplies a handle to the directory file for which information
        should be returned.

    Event - Supplies an optional event to be set to the Signaled state when
        the query is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        query is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the contents of the directory.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specfies the type of information that is to be
        returned about the files in the specified directory.

    ReturnSingleEntry - Supplies a BOOLEAN value that, if TRUE, indicates that
        only a single entry should be returned.

    FileName - Optionally supplies a file name within the specified directory.

    RestartScan - Supplies a BOOLEAN value that, if TRUE, indicates that the
        scan should be restarted from the beginning.  This parameter must be
        set to TRUE by the caller the first time the service is invoked.

Return Value:

    The status returned is success if the query operation was properly queued
    to the I/O system.  Once the operation completes, the status of the query
    can be determined by examining the Status field of the I/O status block.

--*/

{
    NTSTATUS status;
    BOOLEAN synchronousIo;
    PDEVICE_OBJECT deviceObject;
    PFILE_OBJECT fileObject;
    PIRP irp;
    PKEVENT eventObject = (PKEVENT) NULL;
    PIO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    irpSp->FileObject = fileObject;

    //
    // Pass the address of the user's buffer so the driver has access to
    // it.  It is now the driver's responsibility to do everything.
    //

    irp->UserBuffer = FileInformation;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryDirectory.Length = Length;
    irpSp->Parameters.QueryDirectory.FileInformationClass = FileInformationClass;
    irpSp->Parameters.QueryDirectory.FileName = FileName;
    if (RestartScan) {
        irpSp->Flags = SL_RESTART_SCAN;
    }

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\iodata.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    iodata.c

Abstract:

    This module contains the global read/write data for the I/O system.

Author:

    Darryl E. Havens (darrylh) April 27, 1989

Revision History:


--*/

#include "iop.h"

//
// The following are the global pointers for the Object Type Descriptors that
// are created when each of the I/O specific object types are created.
//

DECLSPEC_RDATA OBJECT_TYPE IoCompletionObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    IopDeleteIoCompletion,
    NULL,
    &ObpDefaultObject,
    'pmoC'
};

DECLSPEC_RDATA OBJECT_TYPE IoDeviceObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    NULL,
    NULL,
    IoParseDevice,
    &ObpDefaultObject,
    'iveD'
};

DECLSPEC_RDATA OBJECT_TYPE IoFileObjectType = {
    ExAllocatePoolWithTag,
    ExFreePool,
    IopCloseFile,
    IopDeleteFile,
    IopParseFile,
    (PVOID)FIELD_OFFSET(FILE_OBJECT, Event.Header),
    'eliF'
};

//
// The following array specifies the minimum length of the FileInformation
// buffer for an NtQueryInformationFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQueryOperationLength[] =
          {
            0,
            0,                                         //  1 FileDirectoryInformation
            0,                                         //  2 FileFullDirectoryInformation
            0,                                         //  3 FileBothDirectoryInformation
            sizeof( FILE_BASIC_INFORMATION ),          //  4 FileBasicInformation
            sizeof( FILE_STANDARD_INFORMATION ),       //  5 FileStandardInformation
            sizeof( FILE_INTERNAL_INFORMATION ),       //  6 FileInternalInformation
            sizeof( FILE_EA_INFORMATION ),             //  7 FileEaInformation
            0,                                         //  8 FileAccessInformation
            sizeof( FILE_NAME_INFORMATION ),           //  9 FileNameInformation
            0,                                         // 10 FileRenameInformation
            0,                                         // 11 FileLinkInformation
            0,                                         // 12 FileNamesInformation
            0,                                         // 13 FileDispositionInformation
            sizeof( FILE_POSITION_INFORMATION ),       // 14 FilePositionInformation
            0,                                         // 15 FileFullEaInformation
            sizeof( FILE_MODE_INFORMATION ),           // 16 FileModeInformation
            sizeof( FILE_ALIGNMENT_INFORMATION ),      // 17 FileAlignmentInformation
            sizeof( FILE_ALL_INFORMATION ),            // 18 FileAllInformation
            0,                                         // 19 FileAllocationInformation
            0,                                         // 20 FileEndOfFileInformation
            sizeof( FILE_NAME_INFORMATION ),           // 21 FileAlternateNameInformation
            sizeof( FILE_STREAM_INFORMATION ),         // 22 FileStreamInformation
            0,                                         // 23 FilePipeInformation
            0,                                         // 24 FilePipeLocalInformation
            0,                                         // 25 FilePipeRemoteInformation
            0,                                         // 26 FileMailslotQueryInformation
            0,                                         // 27 FileMailslotSetInformation
            0,                                         // 28 FileCompressionInformation
            0,                                         // 29 FileObjectIdInformation
            0,                                         // 30 FileCompletionInformation
            0,                                         // 31 FileMoveClusterInformation
            0,                                         // 32 FileQuotaInformation
            0,                                         // 33 FileReparsePointInformation
            sizeof( FILE_NETWORK_OPEN_INFORMATION),    // 34 FileNetworkOpenInformation
            sizeof( FILE_ATTRIBUTE_TAG_INFORMATION),   // 35 FileAttributeTagInformation
            0,                                         // 36 FileTrackingInformation
            0xff                                       //    FileMaximumInformation
          };

//
// The following array specifies the minimum length of the FileInformation
// buffer for an NtSetInformationFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopSetOperationLength[] =
          {
            0,
            0,                                       //  1 FileDirectoryInformation
            0,                                       //  2 FileFullDirectoryInformation
            0,                                       //  3 FileBothDirectoryInformation
            sizeof( FILE_BASIC_INFORMATION ),        //  4 FileBasicInformation
            0,                                       //  5 FileStandardInformation
            0,                                       //  6 FileInternalInformation
            0,                                       //  7 FileEaInformation
            0,                                       //  8 FileAccessInformation
            0,                                       //  9 FileNameInformation
            sizeof( FILE_RENAME_INFORMATION ),       // 10 FileRenameInformation
            sizeof( FILE_LINK_INFORMATION ),         // 11 FileLinkInformation
            0,                                       // 12 FileNamesInformation
            sizeof( FILE_DISPOSITION_INFORMATION ),  // 13 FileDispositionInformation
            sizeof( FILE_POSITION_INFORMATION ),     // 14 FilePositionInformation
            0,                                       // 15 FileFullEaInformation
            sizeof( FILE_MODE_INFORMATION ),         // 16 FileModeInformation
            0,                                       // 17 FileAlignmentInformation
            0,                                       // 18 FileAllInformation
            sizeof( FILE_ALLOCATION_INFORMATION ),   // 19 FileAllocationInformation
            sizeof( FILE_END_OF_FILE_INFORMATION ),  // 20 FileEndOfFileInformation
            0,                                       // 21 FileAlternateNameInformation
            0,                                       // 22 FileStreamInformation
            0,                                       // 23 FilePipeInformation
            0,                                       // 24 FilePipeLocalInformation
            0,                                       // 25 FilePipeRemoteInformation
            0,                                       // 26 FileMailslotQueryInformation
            0,                                       // 27 FileMailslotSetInformation
            0,                                       // 28 FileCompressionInformation
            0,                                       // 29 FileObjectIdInformation
            sizeof( FILE_COMPLETION_INFORMATION ),   // 30 FileCompletionInformation
            sizeof( FILE_MOVE_CLUSTER_INFORMATION ), // 31 FileMoveClusterInformation
            0,                                       // 32 FileQuotaInformation
            0,                                       // 33 FileReparsePointInformation
            0,                                       // 34 FileNetworkOpenInformation
            0,                                       // 35 FileAttributeTagInformation
            0,                                       // 36 FileTrackingInformation
            0xff                                     //    FileMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtQueryXxxFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FileInformationClass enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopQueryOperationAccess[] =
         {
            0,
            0,                    //  1 FileDirectoryInformation
            0,                    //  2 FileFullDirectoryInformation
            0,                    //  3 FileBothDirectoryInformation
            FILE_READ_ATTRIBUTES, //  4 FileBasicInformation
            0,                    //  5 FileStandardInformation
            0,                    //  6 FileInternalInformation
            0,                    //  7 FileEaInformation
            0,                    //  8 FileAccessInformation
            0,                    //  9 FileNameInformation
            0,                    // 10 FileRenameInformation
            0,                    // 11 FileLinkInformation
            0,                    // 12 FileNamesInformation
            0,                    // 13 FileDispositionInformation
            0,                    // 14 FilePositionInformation
            FILE_READ_EA,         // 15 FileFullEaInformation
            0,                    // 16 FileModeInformation
            0,                    // 17 FileAlignmentInformation
            FILE_READ_ATTRIBUTES, // 18 FileAllInformation
            0,                    // 19 FileAllocationInformation
            0,                    // 20 FileEndOfFileInformation
            0,                    // 21 FileAlternateNameInformation
            0,                    // 22 FileStreamInformation
            FILE_READ_ATTRIBUTES, // 23 FilePipeInformation
            FILE_READ_ATTRIBUTES, // 24 FilePipeLocalInformation
            FILE_READ_ATTRIBUTES, // 25 FilePipeRemoteInformation
            0,                    // 26 FileMailslotQueryInformation
            0,                    // 27 FileMailslotSetInformation
            0,                    // 28 FileCompressionInformation
            0,                    // 29 FileObjectIdInformation
            0,                    // 30 FileCompletionInformation
            0,                    // 31 FileMoveClusterInformation
            0,                    // 32 FileQuotaInformation
            0,                    // 33 FileReparsePointInformation
            FILE_READ_ATTRIBUTES, // 34 FileNetworkOpenInformation
            FILE_READ_ATTRIBUTES, // 35 FileAttributeTagInformation
            0,                    // 36 FileTrackingInformation
            0xffffffff            //    FileMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtSetXxxFile service.
//
// WARNING:  This array depends on the order of the values in the
//           FILE_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopSetOperationAccess[] =
         {
            0,
            0,                     //  1 FileDirectoryInformation
            0,                     //  2 FileFullDirectoryInformation
            0,                     //  3 FileBothDirectoryInformation
            FILE_WRITE_ATTRIBUTES, //  4 FileBasicInformation
            0,                     //  5 FileStandardInformation
            0,                     //  6 FileInternalInformation
            0,                     //  7 FileEaInformation
            0,                     //  8 FileAccessInformation
            0,                     //  9 FileNameInformation
            DELETE,                // 10 FileRenameInformation
            0,                     // 11 FileLinkInformation
            0,                     // 12 FileNamesInformation
            DELETE,                // 13 FileDispositionInformation
            0,                     // 14 FilePositionInformation
            FILE_WRITE_EA,         // 15 FileFullEaInformation
            0,                     // 16 FileModeInformation
            0,                     // 17 FileAlignmentInformation
            0,                     // 18 FileAllInformation
            FILE_WRITE_DATA,       // 19 FileAllocationInformation
            FILE_WRITE_DATA,       // 20 FileEndOfFileInformation
            0,                     // 21 FileAlternateNameInformation
            0,                     // 22 FileStreamInformation
            FILE_WRITE_ATTRIBUTES, // 23 FilePipeInformation
            0,                     // 24 FilePipeLocalInformation
            FILE_WRITE_ATTRIBUTES, // 25 FilePipeRemoteInformation
            0,                     // 26 FileMailslotQueryInformation
            0,                     // 27 FileMailslotSetInformation
            0,                     // 28 FileCompressionInformation
            0,                     // 29 FileObjectIdInformation
            0,                     // 30 FileCompletionInformation
            FILE_WRITE_DATA,       // 31 FileMoveClusterInformation
            0,                     // 32 FileQuotaInformation
            0,                     // 33 FileReparsePointInformation
            0,                     // 34 FileNetworkOpenInformation
            0,                     // 35 FileAttributeTagInformation
            FILE_WRITE_DATA,       // 36 FileTrackingInformation
            0xffffffff             //    FileMaximumInformation
          };

//
// The following array specifies the minimum length of the FsInformation
// buffer for an NtQueryVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const UCHAR IopQueryFsOperationLength[] =
          {
            0,
            sizeof( FILE_FS_VOLUME_INFORMATION ),    // 1 FileFsVolumeInformation
            0,                                       // 2 FileFsLabelInformation
            sizeof( FILE_FS_SIZE_INFORMATION ),      // 3 FileFsSizeInformation
            sizeof( FILE_FS_DEVICE_INFORMATION ),    // 4 FileFsDeviceInformation
            sizeof( FILE_FS_ATTRIBUTE_INFORMATION ), // 5 FileFsAttributeInformation
            sizeof( FILE_FS_CONTROL_INFORMATION ),   // 6 FileFsControlInformation
            sizeof( FILE_FS_FULL_SIZE_INFORMATION ), // 7 FileFsFullSizeInformation
            sizeof( FILE_FS_OBJECTID_INFORMATION ),  // 8 FileFsObjectIdInformation
            0xff                                     //   FileFsMaximumInformation
          };

//
// The following array specifies the required access mask for the caller to
// access information in an NtQueryVolumeInformation service.
//
// WARNING:  This array depends on the order of the values in the
//           FS_INFORMATION_CLASS enumerated type.  Note that the
//           enumerated type is one-based and the array is zero-based.
//

const ULONG IopQueryFsOperationAccess[] =
         {
            0,
            0,              // 1 FileFsVolumeInformation [any access to file or volume]
            0,              // 2 FileFsLabelInformation [query is invalid]
            0,              // 3 FileFsSizeInformation [any access to file or volume]
            0,              // 4 FileFsDeviceInformation [any access to file or volume]
            0,              // 5 FileFsAttributeInformation [any access to file or vol]
            FILE_READ_DATA, // 6 FileFsControlInformation [vol read access]
            0,              // 7 FileFsFullSizeInformation [any access to file or volume]
            0,              // 8 FileFsObjectIdInformation [any access to file or volume]
            0xffffffff      //   FileFsMaximumInformation
          };

DECLSPEC_RDATA GENERIC_MAPPING IopFileMapping = {
    STANDARD_RIGHTS_READ |
        FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE,
    STANDARD_RIGHTS_WRITE |
        FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA | SYNCHRONIZE,
    STANDARD_RIGHTS_EXECUTE |
        SYNCHRONIZE | FILE_READ_ATTRIBUTES | FILE_EXECUTE,
    FILE_ALL_ACCESS
};

ULONG IoPendingMustCompletePackets;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\internal.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    internal.c

Abstract:

    This module contains the internal subroutines used by the I/O system.

--*/

#include "iop.h"

VOID
IopUserRundown(
    IN PKAPC Apc
    );

NTSTATUS
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked internally by those system services that attempt
    to allocate an IRP and fail.  This routine cleans up the file object
    and any event object that has been references and releases any locks
    that were taken out.

Arguments:

    FileObject - Pointer to the file object being worked on.

    EventObject - Optional pointer to a referenced event to be dereferenced.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES.

--*/

{
    PAGED_CODE();

    //
    // Begin by dereferencing the event, if one was specified.
    //

    if (ARGUMENT_PRESENT( EventObject )) {
        ObDereferenceObject( EventObject );
    }

    //
    // Release the synchronization semaphore if it is currently held and
    // dereference the file object.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopReleaseFileObjectLock( FileObject );
    }

    ObDereferenceObject( FileObject );

    return STATUS_INSUFFICIENT_RESOURCES;
}

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine is invoked to allocate an IRP when there are no appropriate
    packets remaining on the look-aside list, and no memory was available
    from the general non-paged pool, and yet, the code path requiring the
    packet has no way of backing out and simply returning an error.  There-
    fore, it must allocate an IRP.  Hence, this routine is called to allocate
    that packet.

Arguments:

    StackSize - Supplies the number of IRP I/O stack locations that the
        packet must have when allocated.

Return Value:

    A pointer to the allocated I/O Request Packet.

--*/

{
    PIRP irp;
    LARGE_INTEGER interval;

    //
    // Keeping attemting to allocate the IRP normally.
    //

    irp = IoAllocateIrp(StackSize);
    while (!irp) {
        interval.QuadPart = -1000 * 1000 * 50; // 50 Msec.
        KeDelayExecutionThread(KernelMode, FALSE, &interval);
        irp = IoAllocateIrp(StackSize);
    }

    return irp;
}

VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine is invoked when the reference count on a device object
    transitions to a zero and the driver is mark for unload or device has
    been marked for delete. This means that it may be possible to actually
    unload the driver or delete the device object.  If all
    of the devices have a reference count of zero, then the driver is
    actually unloaded.  Note that in order to ensure that this routine is
    not invoked twice, at the same time, on two different processors, the
    I/O database spin lock is still held at this point.

Arguments:

    DeviceObject - Supplies a pointer to one of the driver's device objects,
        namely the one whose reference count just went to zero.

    Irql - Specifies the IRQL of the processor at the time that the I/O
        database lock was acquired.

Return Value:

    None.

--*/

{
    if (DeviceObject->DeletePending) {

        KeLowerIrql(Irql);

        //
        // Remove this device object from the driver object's list.
        //

        if (DeviceObject->DriverObject->DriverDeleteDevice != NULL) {

            DeviceObject->DriverObject->DriverDeleteDevice( DeviceObject );

        } else {

            //
            // Finally, dereference the object so it is deleted.
            //

            ObDereferenceObject( DeviceObject );
        }
    }
}

VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine executes as a special kernel APC routine in the context of
    the thread which originally requested the I/O operation which is now
    being completed.

    This routine performs the following tasks:

        o   A check is made to determine whether the specified request ended
            with an error status.  If so, and the error code qualifies as one
            which should be reported to an error port, then an error port is
            looked for in the thread/process.   If one exists, then this routine
            will attempt to set up an LPC to it.  Otherwise, it will attempt to
            set up an LPC to the system error port.

        o   Copy I/O status.

        o   Set event, if any and dereference if appropriate.

        o   Dequeue the IRP from the thread queue as pending I/O request.

        o   Queue APC to thread, if any.

        o   If no APC is to be queued, then free the packet now.


Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1 - Supplies a pointer to an argument that contains the
        address of the original file object for this I/O operation.

    SystemArgument2 - Supplies a pointer to an argument that contains an
        argument that is used by this routine only in the case of STATUS_REPARSE.

Return Value:

    None.

--*/
{
#define SynchronousIo( Irp, FileObject ) (  \
    (Irp->Flags & IRP_SYNCHRONOUS_API) ||   \
    (FileObject == NULL ? 0 : FileObject->Flags & FO_SYNCHRONOUS_IO) )

    PIRP irp;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    NTSTATUS    status;

    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );

    //
    // Begin by getting the address of the I/O Request Packet.  Also, get
    // the address of the current thread and the address of the original file
    // object for this I/O operation.
    //

    irp = CONTAINING_RECORD( Apc, IRP, Tail.Apc );
    thread = PsGetCurrentThread();
    fileObject = (PFILE_OBJECT) *SystemArgument1;

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( irp->IoStatus.Status != 0xffffffff );

    //
    // Check to see whether or not the I/O operation actually completed.  If
    // it did, then proceed normally.  Otherwise, cleanup everything and get
    // out of here.
    //

    if (!NT_ERROR( irp->IoStatus.Status ) ||
        (NT_ERROR( irp->IoStatus.Status ) &&
        irp->PendingReturned &&
        !SynchronousIo( irp, fileObject ))) {

        PVOID port = NULL;
        PVOID key;
        BOOLEAN createOperation = FALSE;

        //
        // If there is an I/O completion port object associated w/this request,
        // save it here so that the file object can be dereferenced.
        //

        if (fileObject && fileObject->CompletionContext) {
            port = fileObject->CompletionContext->Port;
            key = fileObject->CompletionContext->Key;
        }

        //
        // Copy the I/O status from the IRP into the caller's I/O status
        // block.
        //
        //
        // Since HasOverlappedIoCompleted and GetOverlappedResult only
        // look at the Status field of the UserIosb to determine if the
        // IRP has completed, the Information field must be written
        // before the Status field.
        //

        irp->UserIosb->Information = irp->IoStatus.Information;
        irp->UserIosb->Status = irp->IoStatus.Status;

        //
        // Determine whether the caller supplied an event that needs to be set
        // to the Signaled state.  If so, then set it; otherwise, set the event
        // in the file object to the Signaled state.
        //
        // It is possible for the event to have been specified as a PKEVENT if
        // this was an I/O operation hand-built for an FSP or an FSD, or
        // some other types of operations such as synchronous I/O APIs.  In
        // any of these cases, the event was not referenced since it is not an
        // object manager event, so it should not be dereferenced.
        //
        // Also, it is possible for there not to be a file object for this IRP.
        // This occurs when an FSP is doing I/O operations to a device driver on
        // behalf of a process doing I/O to a file.  The file object cannot be
        // dereferenced if this is the case.  If this operation was a create
        // operation then the object should not be dereferenced either.  This
        // is because the reference count must be one or it will go away for
        // the caller (not much point in making an object that just got created
        // go away).
        //

        if (irp->UserEvent) {
            (VOID) KeSetEvent( irp->UserEvent, 0, FALSE );
            if (fileObject) {
                if (!(irp->Flags & IRP_SYNCHRONOUS_API)) {
                    ObDereferenceObject( irp->UserEvent );
                }
                if (fileObject->Flags & FO_SYNCHRONOUS_IO && !(irp->Flags & IRP_OB_QUERY_NAME)) {
                    (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
                    fileObject->FinalStatus = irp->IoStatus.Status;
                }
                if (irp->Flags & IRP_CREATE_OPERATION) {
                    createOperation = TRUE;
                    irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
                }
            }
        } else if (fileObject) {
            (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
            fileObject->FinalStatus = irp->IoStatus.Status;
            if (irp->Flags & IRP_CREATE_OPERATION) {
                createOperation = TRUE;
                irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
            }
        }

        //
        // Dequeue the packet from the thread's pending I/O request list.
        //

        IopDequeueThreadIrp( irp );

        //
        // If the caller requested an APC, queue it to the thread.  If not, then
        // simply free the packet now.
        //

        if (irp->Overlay.AsynchronousParameters.UserApcRoutine) {
            KeInitializeApc( &irp->Tail.Apc,
                             &thread->Tcb,
                             IopUserCompletion,
                             (PKRUNDOWN_ROUTINE) IopUserRundown,
                             (PKNORMAL_ROUTINE) irp->Overlay.AsynchronousParameters.UserApcRoutine,
                             IopApcRoutineMode(irp->Overlay.AsynchronousParameters.UserApcRoutine),
                             irp->Overlay.AsynchronousParameters.UserApcContext );

            KeInsertQueueApc( &irp->Tail.Apc,
                              irp->UserIosb,
                              NULL,
                              2 );

        } else if (port && irp->Overlay.AsynchronousParameters.UserApcContext) {

            //
            // If there is a completion context associated w/this I/O operation,
            // send the message to the port. Tag completion packet as an Irp.
            //

            irp->Tail.CompletionKey = key;
            irp->Tail.Overlay.PacketType = IopCompletionPacketIrp;

            KeInsertQueue( (PKQUEUE) port,
                           &irp->Tail.Overlay.ListEntry );

        } else {

            //
            // Free the IRP now since it is no longer needed.
            //

            IoFreeIrp( irp );
        }

        if (fileObject && !createOperation) {

            //
            // Dereference the file object now.
            //

            ObDereferenceObject( fileObject );
        }

    } else {

        if (irp->PendingReturned && fileObject) {

            //
            // This is an I/O operation that completed as an error for
            // which a pending status was returned and the I/O operation
            // is synchronous.  For this case, the I/O system is waiting
            // on behalf of the caller.  If the reason that the I/O was
            // synchronous is that the file object was opened for synchronous
            // I/O, then the event associated with the file object is set
            // to the signaled state.  If the I/O operation was synchronous
            // because this is a synchronous API, then the event is set to
            // the signaled state.
            //
            // Note also that the status must be returned for both types
            // of synchronous I/O.  If this is a synchronous API, then the
            // I/O system supplies its own status block so it can simply
            // be written;  otherwise, the I/O system will obtain the final
            // status from the file object itself.
            //

            if (irp->Flags & IRP_SYNCHRONOUS_API) {
                *irp->UserIosb = irp->IoStatus;
                if (irp->UserEvent) {
                    (VOID) KeSetEvent( irp->UserEvent, 0, FALSE );
                } else {
                    (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
                }
            } else {
                fileObject->FinalStatus = irp->IoStatus.Status;
                (VOID) KeSetEvent( &fileObject->Event, 0, FALSE );
            }
        }

        //
        // The operation was incomplete.  Perform the general cleanup.  Note
        // that everything is basically dropped on the floor without doing
        // anything.  That is:
        //
        //     IoStatusBlock - Do nothing.
        //     Event - Dereference without setting to Signaled state.
        //     FileObject - Dereference without setting to Signaled state.
        //     ApcRoutine - Do nothing.
        //

        if (fileObject) {
            if (!(irp->Flags & IRP_CREATE_OPERATION)) {
                ObDereferenceObject( fileObject );
            }
        }

        if (irp->UserEvent &&
            fileObject &&
            !(irp->Flags & IRP_SYNCHRONOUS_API)) {
            ObDereferenceObject( irp->UserEvent );
        }

        IopDequeueThreadIrp( irp );
        IoFreeIrp( irp );
    }
}

VOID
IopDisassociateThreadIrp(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the I/O requests for a thread are being
    cancelled, but there is a packet at the end of the thread's queue that
    has not been completed for such a long period of time that it has timed
    out.  It is this routine's responsibility to try to disassociate that
    IRP with this thread.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KIRQL irql;
    KIRQL spIrql;
    PIRP irp;
    PETHREAD thread;
    PLIST_ENTRY entry;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;

    //
    // Begin by ensuring that the packet has not already been removed from
    // the thread's queue.
    //

    KeRaiseIrql( APC_LEVEL, &irql );

    thread = PsGetCurrentThread();

    //
    // If there are no packets on the IRP list, then simply return now.
    // All of the packets have been fully completed, so the caller will also
    // simply return to its caller.
    //

    if (IsListEmpty( &thread->IrpList )) {
        KeLowerIrql( irql );
        return;
    }

    //
    // Get a pointer to the first packet on the queue, and begin examining
    // it.  Note that because the processor is at raised IRQL, and because
    // the packet can only be removed in the context of the currently
    // executing thread, that it is not possible for the packet to be removed
    // from the list.  On the other hand, it IS possible for the packet to
    // be queued to the thread's APC list at this point, and this must be
    // blocked/synchronized in order to examine the request.
    //
    // Begin, therefore, by acquiring the I/O completion spinlock, so that
    // the packet can be safely examined.
    //

    spIrql = IopAcquireCompletionLock();

    //
    // Check to see whether or not the packet has been completed (that is,
    // queued to the current thread).  If not, change threads.
    //

    entry = thread->IrpList.Flink;
    irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );

    if (irp->CurrentLocation == irp->StackCount + 2) {

        //
        // The request has just gone through enough of completion that
        // queueing it to the thread is inevitable.  Simply release the
        // lock and return.
        //

        IopReleaseCompletionLock(spIrql);
        KeLowerIrql( irql );
        return;
    }

    //
    // The packet has been located, and it is not going through completion
    // at this point.  Switch threads, so that it will not complete through
    // this thread, remove the request from this thread's queue, and release
    // the spinlock.  Final processing of the IRP will occur when I/O
    // completion notices that there is no thread associated with the
    // request.  It will essentially drop the I/O on the floor.
    //
    // Also, while the request is still held, attempt to determine on which
    // device object the operation is being performed.
    //

    irp->Tail.Overlay.Thread = (PETHREAD) NULL;
    entry = RemoveHeadList( &thread->IrpList );

    // Initialize the thread entry. Otherwise the assertion in IoFreeIrp
    // called via IopDeadIrp will fail.
    InitializeListHead (&(irp)->ThreadListEntry);

    irpSp = IoGetCurrentIrpStackLocation( irp );
    if (irp->CurrentLocation <= irp->StackCount) {
        deviceObject = irpSp->DeviceObject;
    } else {
        deviceObject = (PDEVICE_OBJECT) NULL;
    }
    IopReleaseCompletionLock(spIrql);
    KeLowerIrql( irql );

    return;
}

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine attempts to drop everything about the specified IRP on the
    floor.

Arguments:

    Irp - Supplies the I/O Request Packet to be completed to the bit bucket.

    FileObject - Supplies the file object for which the I/O Request Packet was
        bound.

Return Value:

    None.

--*/

{
    //
    // Free the resources associated with the IRP.
    //

    if (Irp->UserEvent &&
        FileObject &&
        !(Irp->Flags & IRP_SYNCHRONOUS_API)) {
        ObDereferenceObject( Irp->UserEvent );
    }

    if (FileObject && !(Irp->Flags & IRP_CREATE_OPERATION)) {
        ObDereferenceObject( FileObject );
    }

    //
    // Finally, free the IRP itself.
    //

    IoFreeIrp( Irp );
}

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs generalized cleanup for the I/O system services when
    an exception occurs during caller parameter processing.  This routine
    performs the following steps:

        o   If a system buffer was allocated it is freed.

        o   If an MDL was allocated it is freed.

        o   The IRP is freed.

        o   If the file object is opened for synchronous I/O, the semaphore
            is released.

        o   If an event object was referenced it is dereferenced.

        o   The file object is dereferenced.

Arguments:

    FileObject - Pointer to the file object currently being worked on.

    Irp - Pointer to the IRP allocated to handle the I/O request.

    EventObject - Optional pointer to a referenced event object.

    KernelEvent - Optional pointer to an allocated kernel event.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Free the I/O Request Packet.
    //

    IoFreeIrp( Irp );

    //
    // Finally, release the synchronization semaphore if it is currently
    // held, dereference the event if one was specified, and dereference
    // the file object.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopReleaseFileObjectLock( FileObject );
    }

    if (ARGUMENT_PRESENT( EventObject )) {
        ObDereferenceObject( EventObject );
    }

    ObDereferenceObject( FileObject );

    return;
}

VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    The routine decrements the reference count on a device object.  If the
    reference count goes to zero and the device object is a candidate for deletion
    then IopCompleteUnloadOrDelete is called.  A device object is subject for
    deletion if the device object is pending deletion or the driver is pending
    unload.

Arguments:

    DeviceObject - Supplies the device object whose reference count is to be
                   decremented.

Return Value:

    None.

--*/
{
    KIRQL irql;

    //
    // Decrement the reference count on the device object.  If this is the last
    // last reason that this mini-file system recognizer needs to stay around,
    // then unload it.
    //

    irql = KeRaiseIrqlToDpcLevel();

    ASSERT( DeviceObject->ReferenceCount > 0 );

    DeviceObject->ReferenceCount--;

    if (!DeviceObject->ReferenceCount && DeviceObject->DeletePending) {
        IopCompleteUnloadOrDelete( DeviceObject, irql );
    } else {
        KeLowerIrql(irql);
    }
}

NTSTATUS
IopOpenRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PFILE_RENAME_INFORMATION RenameBuffer,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked by the rename code in the I/O system's
    NtSetInformationFile system service when the caller has specified a fully
    qualified file name as the target of a rename operation.  This routine
    attempts to open the parent of the specified file and checks the following:

        o   If the file itself exists, then the caller must have specified that
            the target is to be replaced, otherwise an error is returned.

        o   Ensures that the target file specification refers to the same volume
            upon which the source file exists.

Arguments:

    TargetHandle - Supplies the address of a variable to return the handle to
        the opened target file if no errors have occurred.

    Irp - Supplies a pointer to the IRP that represents the current rename
        request.

    RenameBuffer - Supplies a pointer to the system intermediate buffer that
        contains the caller's rename parameters.

    FileObject - Supplies a pointer to the file object representing the file
        being renamed.

Return Value:

    The function value is the final status of the operation.

Note:

    This function assumes that the layout of a rename, set link and set
    copy-on-write information structure are exactly the same.

--*/

{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;
    PIO_STACK_LOCATION irpSp;
    PFILE_OBJECT targetFileObject;

    PAGED_CODE();

    //
    // A fully qualified file name was specified.  Begin by attempting to open
    // the parent directory of the specified target file.
    //

    InitializeObjectAttributes( &objectAttributes,
                                &RenameBuffer->FileName,
                                OBJ_CASE_INSENSITIVE,
                                RenameBuffer->RootDirectory,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = IoCreateFile( &handle,
                           FILE_WRITE_DATA | SYNCHRONIZE,
                           &objectAttributes,
                           &ioStatus,
                           (PLARGE_INTEGER) NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_OPEN_FOR_BACKUP_INTENT,
                           IO_NO_PARAMETER_CHECKING |
                           IO_OPEN_TARGET_DIRECTORY |
                           IO_FORCE_ACCESS_CHECK );
    if (NT_SUCCESS( status )) {

        //
        // Everything up to this point is fine, so dereference the handle
        // to a pointer to the file object and ensure that the two file
        // specifications refer to the same device.
        //

        status = ObReferenceObjectByHandle( handle,
                                          &IoFileObjectType,
                                          (PVOID *) &targetFileObject );
        if (NT_SUCCESS( status )) {

            ObDereferenceObject( targetFileObject );

            if (targetFileObject->DeviceObject != FileObject->DeviceObject) {

                //
                // The two files refer to different devices.  Clean everything
                // up and return an appropriate error.
                //

                NtClose( handle );
                status = STATUS_NOT_SAME_DEVICE;

            } else {

                //
                // Otherwise, everything worked, so allow the rename operation
                // to continue.
                //

                irpSp = IoGetNextIrpStackLocation( Irp );
                irpSp->Parameters.SetFile.FileObject = targetFileObject;
                *TargetHandle = handle;
                status = STATUS_SUCCESS;
            }

        } else {

            //
            // There was an error referencing the handle to what should
            // have been the target directory.  This generally means that
            // there was a resource problem or the handle was invalid, etc.
            // Simply attempt to close the handle and return the error.
            //

            NtClose( handle );
        }
    }

    //
    // Return the final status of the operation.
    //

    return status;
}

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file
    or volume.  The information returned is determined by the class that
    is specified, and it is placed into the caller's output buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the file/volume.

    Length - Supplies the length of the buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the buffer.

    FileInformation - Boolean that indicates whether the information requested
        is for a file or a volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    KEVENT event;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object here so that no special checks need be made
    // in I/O completion to determine whether or not to dereference the file
    // object.
    //

    ObReferenceObject( FileObject );

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then initialize the local event.
    //

    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(FileObject);
        KeClearEvent( &FileObject->Event );
        synchronousIo = TRUE;
    } else {
        KeInitializeEvent( &event, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = FileObject->DeviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( FileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = FileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = Information;
    if (!synchronousIo) {
        irp->UserEvent = &event;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->UserIosb = &localIoStatus;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)(FileInformation ? IRP_MJ_QUERY_INFORMATION :
        IRP_MJ_QUERY_VOLUME_INFORMATION);
    irpSp->FileObject = FileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    if (FileInformation) {
        irpSp->Parameters.QueryFile.Length = Length;
        irpSp->Parameters.QueryFile.FileInformationClass = InformationClass;
    } else {
        irpSp->Parameters.QueryVolume.Length = Length;
        irpSp->Parameters.QueryVolume.FsInformationClass = InformationClass;
    }

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (synchronousIo) {
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &FileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );
            status = FileObject->FinalStatus;
        }
        IopReleaseFileObjectLock( FileObject );

    } else {

        //
        // This is a normal synchronous I/O operation, as opposed to a
        // serialized synchronous I/O operation.  For this case, wait
        // for the local event and copy the final status information
        // back to the caller.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
            status = localIoStatus.Status;
        }
    }

    *ReturnedLength = (ULONG) localIoStatus.Information;
    return status;
}

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine is invoked when a synchronous API is invoked for a file
    that has been opened for asynchronous I/O.  This function synchronizes
    the completion of the I/O operation on the file.

Arguments:

    ReturnedStatus - Supplies the status that was returned from the call to
        IoCallDriver.

    Event - Address of the stack allocated kernel event to be used for
        synchronization of the I/O operation.

    Irp - Address of the I/O Request Packet submitted to the driver.

    LocalIoStatus - Address of the I/O status block used to capture the final
        status by the service itself.

    IoStatusBlock - Address of the I/O status block supplied by the caller of
        the system service.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // This is a normal synchronous I/O operation, as opposed to a
    // serialized synchronous I/O operation.  For this case, wait for
    // the local event and copy the final status information back to
    // the caller.
    //

    status = ReturnedStatus;

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );

        status = LocalIoStatus->Status;
    }

    *IoStatusBlock = *LocalIoStatus;

    return status;
}

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN BOOLEAN SynchronousIo
    )

/*++

Routine Description:

    This routine is invoked to complete the operation of a system service.
    It queues the IRP to the thread's queue, updates the transfer count,
    calls the driver, and finally synchronizes completion of the I/O.

Arguments:

    DeviceObject - Device on which the I/O is to occur.

    Irp - I/O Request Packet representing the I/O operation.

    FileObject - File object for this open instantiation.

    DeferredIoCompletion - Indicates whether deferred completion is possible.

    SynchronousIo - Indicates whether the operation is to be synchronous.

Return Value:

    The function value is the final status of the operation.

--*/

{
    NTSTATUS status;

    PAGED_CODE();

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( Irp );

    //
    // Now simply invoke the driver at its dispatch entry with the IRP.
    //

    status = IoCallDriver( DeviceObject, Irp );

    //
    // If deferred I/O completion is possible, check for pending returned
    // from the driver.  If the driver did not return pending, then the
    // packet has not actually been completed yet, so complete it here.
    //

    if (DeferredIoCompletion) {

        if (status != STATUS_PENDING) {

            //
            // The I/O operation was completed without returning a status of
            // pending.  This means that at this point, the IRP has not been
            // fully completed.  Complete it now.
            //

            PKNORMAL_ROUTINE normalRoutine;
            PVOID normalContext;
            KIRQL irql;

            ASSERT( !Irp->PendingReturned );

            KeRaiseIrql( APC_LEVEL, &irql );
            IopCompleteRequest( &Irp->Tail.Apc,
                                &normalRoutine,
                                &normalContext,
                                (PVOID *) &FileObject,
                                &normalContext );
            KeLowerIrql( irql );
        }
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (SynchronousIo) {

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject( &FileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = FileObject->FinalStatus;
        }

        IopReleaseFileObjectLock( FileObject );
    }

    return status;
}

VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    )

/*++

Routine Description:

    This routine is invoked in the final processing of an IRP.  Everything has
    been completed except that the caller's APC routine must be invoked.  The
    system will do this as soon as this routine exits.  The only processing
    remaining to be completed by the I/O system is to free the I/O Request
    Packet itself.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

    NormalRoutine - Supplies a pointer to a pointer to the normal function
        that was specified when the APC was initialied.

    NormalContext - Supplies a pointer to a pointer to an arbitrary data
        structure that was specified when the APC was initialized.

    SystemArgument1, SystemArgument2 - Supplies a set of two pointers to
        two arguments that contain untyped data.

Return Value:

    None.

Note:

    If no other processing is ever needed, and the APC can be placed at the
    beginning of the IRP, then this routine could be replaced by simply
    specifying the address of the pool deallocation routine in the APC instead
    of the address of this routine.

Caution:

    This routine is also invoked as a general purpose rundown routine for APCs.
    Should this code ever need to directly access any of the other parameters
    other than Apc, this routine will need to be split into two separate
    routines.  The rundown routine should perform exactly the following code's
    functionality.

--*/

{
    UNREFERENCED_PARAMETER( NormalRoutine );
    UNREFERENCED_PARAMETER( NormalContext );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

    PAGED_CODE();

    //
    // Free the packet.
    //

    IoFreeIrp( CONTAINING_RECORD( Apc, IRP, Tail.Apc ) );
}

VOID
IopUserRundown(
    IN PKAPC Apc
    )

/*++

Routine Description:

    This routine is invoked during thread termination as the rundown routine
    for it simply calls IopUserCompletion.

Arguments:

    Apc - Supplies a pointer to kernel APC structure.

Return Value:

    None.


--*/

{
    PAGED_CODE();

    //
    // Free the packet.
    //

    IoFreeIrp( CONTAINING_RECORD( Apc, IRP, Tail.Apc ) );
}

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    )

/*++

Routine Description:

    This service builds descriptors or MDLs for the supplied buffer(s) and
    passes the untyped data to the driver associated with the file handle.
    handle.  It is up to the driver to check the input data and function
    IoControlCode for validity, as well as to make the appropriate access
    checks.

Arguments:

    FileHandle - Supplies a handle to the file on which the service is being
        performed.

    Event - Supplies an optional event to be set to the Signaled state when
        the service is complete.

    ApcRoutine - Supplies an optional APC routine to be executed when the
        service is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine,
        if an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    IoControlCode - Subfunction code to determine exactly what operation is
        being performed.

    InputBuffer - Optionally supplies an input buffer to be passed to the
        driver.  Whether or not the buffer is actually optional is dependent
        on the IoControlCode.

    InputBufferLength - Length of the InputBuffer in bytes.

    OutputBuffer - Optionally supplies an output buffer to receive information
        from the driver.  Whether or not the buffer is actually optional is
        dependent on the IoControlCode.

    OutputBufferLength - Length of the OutputBuffer in bytes.

    DeviceIoControl - Determines whether this is a Device or File System
        Control function.

Return Value:

    The status returned is success if the control operation was properly
    queued to the I/O system.   Once the operation completes, the status
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PKEVENT eventObject = (PKEVENT) NULL;
    PIO_STACK_LOCATION irpSp;
    ULONG method;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // If this file has an I/O completion port associated w/it, then ensure
    // that the caller did not supply an APC routine, as the two are mutually
    // exclusive methods for I/O completion notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here, too, that if
    // the handle does not refer to an event, or if the event cannot be
    // written, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.

    irp = IoAllocateIrp( deviceObject->StackSize );

    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = OutputBuffer;
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = (UCHAR)(DeviceIoControl ? IRP_MJ_DEVICE_CONTROL :
        IRP_MJ_FILE_SYSTEM_CONTROL);
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all three methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBuffer = InputBuffer;

    //
    // Based on the method that the buffer are being passed, lock down the
    // output buffer.
    //

    if (OutputBufferLength != 0) {

        method = IoControlCode & 3;

        if ((method == METHOD_IN_DIRECT) || (method == METHOD_OUT_DIRECT)) {
            IoLockUserBuffer(irp, OutputBufferLength);
        }
    }

    //
    // Defer I/O completion for FSCTL requests, but not for IOCTL requests,
    // since file systems set pending properly but device driver do not.
    //

    if (!DeviceIoControl) {
        irp->Flags |= IRP_DEFER_IO_COMPLETION;
    }

    //
    // Queue the packet, call the driver, and synchronize appropriately with
    // I/O completion.
    //

    return IopSynchronousServiceTail( deviceObject,
                                      irp,
                                      fileObject,
                                      (BOOLEAN)!DeviceIoControl,
                                      synchronousIo );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\fsrtl.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    fsrtl.c

Abstract:

    This module implements shared file system driver routines.

--*/

#include "iop.h"

BOOLEAN
IopCopyTemplateFileName(
    IN POBJECT_STRING TargetTemplateFileName,
    OUT POBJECT_STRING SourceTemplateFileName
    )
/*++

Routine Description:

    This routine copies the template file name from the source to the
    destination and validates that the template string is valid (for example,
    an asterisk must be followed by the end of the string or a period).

Arguments:

    TargetTemplateFileName - Specifies the target template file name.

    SourceTemplateFileName - Specifies the source template file name.

Return Value:

    Returns TRUE if the source template file name is valid, else FALSE.

--*/
{
    BOOLEAN SeenAsterisk;
    POSTR SourceTemplateFileNameCurrent;
    POSTR SourceTemplateFileNameEnd;
    POSTR TargetTemplateFileNameCurrent;
    OCHAR Char;

    SeenAsterisk = FALSE;

    SourceTemplateFileNameCurrent = SourceTemplateFileName->Buffer;
    SourceTemplateFileNameEnd = (POSTR)((PUCHAR)SourceTemplateFileNameCurrent +
        SourceTemplateFileName->Length);
    TargetTemplateFileNameCurrent = TargetTemplateFileName->Buffer;

    while (SourceTemplateFileNameCurrent < SourceTemplateFileNameEnd) {

        Char = *SourceTemplateFileNameCurrent++;

        //
        // Force an asterisk to be followed by a period.
        //

        if (SeenAsterisk) {

            if (Char != OTEXT('.')) {
                return FALSE;
            }

            SeenAsterisk = FALSE;
        }

        if (Char == OTEXT('*')) {
            SeenAsterisk = TRUE;
        } else if (Char >= OTEXT('a') && Char <= OTEXT('z')) {
            Char = (OCHAR)(Char - (OTEXT('a') - OTEXT('A')));
        }

        *TargetTemplateFileNameCurrent++ = Char;
    }

    return TRUE;
}

NTSTATUS
IoCreateDirectoryEnumContext(
    IN POBJECT_STRING TemplateFileName,
    OUT PDIRECTORY_ENUM_CONTEXT *ReturnedDirectoryEnumContext
    )
/*++

Routine Description:

    This routine allocates and prepares a directory enumeration context given
    the supplied template file name.  The template file name is also validated.

Arguments:

    TemplateFileName - Specifies the template file name for the enumeration.

    ReturnedDirectoryEnumContext - Specifies the location to receive the
        allocated directory enumeration context.

Return Value:

    Status of operation.

--*/
{
    ULONG TemplateFileNameLength;
    PDIRECTORY_ENUM_CONTEXT DirectoryEnumContext;

    if ((TemplateFileName == NULL) || (TemplateFileName->Length == 0) ||
        (TemplateFileName->Length == sizeof(OCHAR)) &&
            (TemplateFileName->Buffer[0] == OTEXT('*'))) {

        //
        // No template name was specified or else "*" was specified, so we'll
        // match all file names.
        //

        TemplateFileNameLength = 0;

    } else {
        TemplateFileNameLength = TemplateFileName->Length;
    }

    //
    // Allocate and zero initialize the directory enumeration context.
    //

    DirectoryEnumContext = (PDIRECTORY_ENUM_CONTEXT)ExAllocatePoolWithTag(
        sizeof(DIRECTORY_ENUM_CONTEXT) + TemplateFileNameLength, 'eDoI');

    if (DirectoryEnumContext == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(DirectoryEnumContext, sizeof(DIRECTORY_ENUM_CONTEXT));

    if (TemplateFileNameLength != 0) {

        //
        // A template name was specified.  Convert the name to uppercase and
        // store it in the directory enumeration context.
        //

        DirectoryEnumContext->TemplateFileName.Length =
            (USHORT)TemplateFileNameLength;
        DirectoryEnumContext->TemplateFileName.MaximumLength =
            (USHORT)TemplateFileNameLength;
        DirectoryEnumContext->TemplateFileName.Buffer =
            (POSTR)((PUCHAR)DirectoryEnumContext +
            sizeof(DIRECTORY_ENUM_CONTEXT));

        if (!IopCopyTemplateFileName(&DirectoryEnumContext->TemplateFileName,
            TemplateFileName)) {
            ExFreePool(DirectoryEnumContext);
            return STATUS_INVALID_PARAMETER;
        }
    }

    *ReturnedDirectoryEnumContext = DirectoryEnumContext;

    return STATUS_SUCCESS;
}

BOOLEAN
IoIsNameInExpression(
    IN POBJECT_STRING TemplateFileName,
    IN POBJECT_STRING FileName
    )
/*++

Routine Description:

    This routine checks if the supplied file name matches the supplied search
    specification template.

Arguments:

    TemplateFileName - Specifies the search specification.

    FileName - Specifies the file name to match against the template.

Return Value:

    Returns TRUE if the file name matches the template file name, else FALSE.

--*/
{
    POSTR TemplateFileNameCurrent;
    POSTR TemplateFileNameEnd;
    POSTR FileNameCurrent;
    POSTR FileNameEnd;
    OCHAR Char;
    OCHAR TemplateChar;

    ASSERT(TemplateFileName->Length > 0);

    //
    // If we somehow get a name with no characters in it, reject it.
    //

    if (FileName->Length == 0) {
        return FALSE;
    }

    TemplateFileNameCurrent = TemplateFileName->Buffer;
    TemplateFileNameEnd = (POSTR)((PUCHAR)TemplateFileNameCurrent +
        TemplateFileName->Length);
    FileNameCurrent = FileName->Buffer;
    FileNameEnd = (POSTR)((PUCHAR)FileNameCurrent + FileName->Length);

    while (TemplateFileNameCurrent < TemplateFileNameEnd) {

        TemplateChar = *TemplateFileNameCurrent++;

        if (TemplateChar == OTEXT('*')) {

            //
            // If the asterisk is the last character in the string, then consume
            // the rest of the file name.
            //

            if (TemplateFileNameCurrent == TemplateFileNameEnd) {
                return TRUE;
            }

            //
            // Only allow an asterisk to be followed by the start of an
            // extension.  This has already been verified by
            // IoCopyTemplateFileName.
            //

            ASSERT(*TemplateFileNameCurrent == OTEXT('.'));
            TemplateFileNameCurrent++;

            //
            // Consume characters from the file name until we find the start of
            // an extension or the end of the string.
            //

            do {

                if (FileNameCurrent == FileNameEnd) {
                    break;
                }

                Char = *FileNameCurrent++;

            } while (Char != OTEXT('.'));

            continue;
        }

        //
        // If we're out of characters to match in the file name, then the
        // template is longer than the name, so fail the match.
        //

        if (FileNameCurrent == FileNameEnd) {
            return FALSE;
        }

        Char = *FileNameCurrent++;

        if (TemplateChar != OTEXT('?')) {

            //
            // Upcase the character if necessary.
            //

            if (Char >= OTEXT('a') && Char <= OTEXT('z')) {
                Char = (OCHAR)(Char - (OTEXT('a') - OTEXT('A')));
            }

            //
            // If the character doesn't match the template, then we're done.
            //

            if (Char != TemplateChar) {
                return FALSE;
            }
        }
    }

    //
    // We ran out of characters in the template.  If we consumed the entire
    // file name, then this is a match.
    //

    return (BOOLEAN)(FileNameCurrent == FileNameEnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\misc.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module contains the code to implement the NtFlushBuffersFile,
    NtSetNewSizeFile, and NtCancelIoFile system services for the NT I/O system.

--*/

#include "iop.h"

//
// Local copies of the Win32 types that are defined in terms of the NT types.
// Needed for NtUserIoApcDispatcher.
//

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    ULONG   Offset;
    ULONG   OffsetHigh;
    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef
VOID
(NTAPI *LPOVERLAPPED_COMPLETION_ROUTINE)(
    ULONG dwErrorCode,
    ULONG dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

NTSTATUS
NtDeleteFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )

/*++

Routine Description:

    This service deletes the specified file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    HANDLE handle;

    PAGED_CODE();

    //
    // Build a parse open packet that tells the parse method to open the file
    // for open for delete access w/the delete bit set, and then close it.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.CreateOptions = FILE_DELETE_ON_CLOSE;
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.DeleteOnly = TRUE;
    openPacket.LocalFileObject = &localFileObject;
    openPacket.DesiredAccess = DELETE;

    //
    // Open the object by its name.  Because of the special DeleteOnly flag
    // set in the open packet, the parse routine will open the file, and
    // then realize that it is only deleting the file, and will therefore
    // immediately dereference the file.  This will cause the cleanup and
    // the close to be sent to the file system, thus causing the file to
    // be deleted.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 &IoFileObjectType,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        return openPacket.FinalStatus;
    }
}

NTSTATUS
NtFlushBuffersFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This service causes all buffered data to the file to be written.

Arguments:

    FileHandle - Supplies a handle to the file whose buffers should be flushed.

    IoStatusBlock - Address of the caller's I/O status block.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An exception was incurred while attempting to allocate the IRP.
        // Cleanup and return an appropriate error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }

    //
    // Get a pointer to the stack location for the first driver.  This is used
    // to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    irpSp->FileObject = fileObject;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        FALSE,
                                        synchronousIo );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               &localEvent,
                                               irp,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}

NTSTATUS
NtQueryFullAttributesFile(
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )

/*++

Routine Description:

    This service queries the network attributes information for a specified
    file.

Arguments:

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    FileInformation - Supplies an output buffer to receive the returned file
        attributes information.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    NTSTATUS status;
    OPEN_PACKET openPacket;
    DUMMY_FILE_OBJECT localFileObject;
    HANDLE handle;

    PAGED_CODE();

    //
    // Build a parse open packet that tells the parse method to open the file,
    // query the file's full attributes, and close the file.
    //

    RtlZeroMemory( &openPacket, sizeof( OPEN_PACKET ) );

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ShareAccess = (USHORT) FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    openPacket.Disposition = FILE_OPEN;
    openPacket.QueryOnly = TRUE;
    openPacket.LocalFileObject = &localFileObject;
    openPacket.NetworkInformation = FileInformation;
    openPacket.DesiredAccess = FILE_READ_ATTRIBUTES;

    //
    // Open the object by its name.  Because of the special QueryOnly flag set
    // in the open packet, the parse routine will open the file, and then
    // realize that it is only performing a query.  It will therefore perform
    // the query, and immediately close the file.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 &IoFileObjectType,
                                 &openPacket,
                                 &handle );

    //
    // The operation is successful if the parse check field of the open packet
    // indicates that the parse routine was actually invoked, and the final
    // status field of the packet is set to success.
    //

    if (openPacket.ParseCheck != OPEN_PACKET_PATTERN) {
        return status;
    } else {
        status = openPacket.FinalStatus;
    }

    return status;
}

VOID
NtUserIoApcDispatcher(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved
    )
/*++

Routine Description:

    This procedure is called to complete ReadFileEx and WriteFileEx
    asynchronous I/O. Its primary function is to extract the
    appropriate information from the passed IoStatusBlock and call the
    users completion routine.

    The users completion routine is called as:

        Routine Description:

            When an outstanding I/O completes with a callback, this
            function is called.  This function is only called while the
            thread is in an alertable wait (SleepEx,
            WaitForSingleObjectEx, or WaitForMultipleObjectsEx with the
            bAlertable flag set to TRUE).  Returning from this function
            allows another pendiong I/O completion callback to be
            processed.  If this is the case, this callback is entered
            before the termination of the thread's wait with a return
            code of WAIT_IO_COMPLETION.

            Note that each time your completion routine is called, the
            system uses some of your stack.  If you code your completion
            logic to do additional ReadFileEx's and WriteFileEx's within
            your completion routine, AND you do alertable waits in your
            completion routine, you may grow your stack without ever
            trimming it back.

        Arguments:

            dwErrorCode - Supplies the I/O completion status for the
                related I/O.  A value of 0 indicates that the I/O was
                successful.  Note that end of file is indicated by a
                non-zero dwErrorCode value of ERROR_HANDLE_EOF.

            dwNumberOfBytesTransfered - Supplies the number of bytes
                transfered during the associated I/O.  If an error
                occured, a value of 0 is supplied.

            lpOverlapped - Supplies the address of the OVERLAPPED
                structure used to initiate the associated I/O.  The
                hEvent field of this structure is not used by the system
                and may be used by the application to provide additional
                I/O context.  Once a completion routine is called, the
                system will not use the OVERLAPPED structure.  The
                completion routine is free to deallocate the overlapped
                structure.

Arguments:

    ApcContext - Supplies the users completion routine. The format of
        this routine is an LPOVERLAPPED_COMPLETION_ROUTINE.

    IoStatusBlock - Supplies the address of the IoStatusBlock that
        contains the I/O completion status. The IoStatusBlock is
        contained within the OVERLAPPED structure.

    Reserved - Not used; reserved for future use.

Return Value:

    None.

--*/
{
    LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine;
    ULONG dwErrorCode;
    ULONG dwNumberOfBytesTransfered;
    LPOVERLAPPED lpOverlapped;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    dwErrorCode = 0;

    if ( NT_ERROR(IoStatusBlock->Status) ) {
        dwErrorCode = RtlNtStatusToDosError(IoStatusBlock->Status);
        dwNumberOfBytesTransfered = 0;
        }
    else {
        dwErrorCode = 0;
        dwNumberOfBytesTransfered = (ULONG)IoStatusBlock->Information;
        }

    CompletionRoutine = (LPOVERLAPPED_COMPLETION_ROUTINE)(ULONG_PTR)ApcContext;
    lpOverlapped = (LPOVERLAPPED)CONTAINING_RECORD(IoStatusBlock,OVERLAPPED,Internal);

    (CompletionRoutine)(dwErrorCode,dwNumberOfBytesTransfered,lpOverlapped);

    UNREFERENCED_PARAMETER( Reserved );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\objsup.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    objsup.c

Abstract:

    This module contains the object support routine for the NT I/O system.

--*/

#include "iop.h"

VOID
IopCloseFile(
    IN PVOID Object,
    IN ULONG SystemHandleCount
    )

/*++

Routine Description:

    This routine is invoked whenever a handle to a file is deleted.  If the
    handle being deleted is the last handle to the file (the ProcessHandleCount
    parameter is one), then all locks for the file owned by the specified
    process must be released.

    Likewise, if the SystemHandleCount is one then this is the last handle
    for this for file object across all processes.  For this case, the file
    system is notified so that it can perform any necessary cleanup on the
    file.

Arguments:

    Object - A pointer to the file object that the handle referenced.

    SystemHandleCount - Count of handles outstanding to the object for the
        entire system.  If the count is one then this is the last handle
        to this file in the system.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    KEVENT event;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    PAGED_CODE();

    fileObject = (PFILE_OBJECT) Object;

    if (SystemHandleCount == 1) {

        //
        // The last handle to this file object for all of the processes in the
        // system has just been closed, so invoke the driver's "cleanup" handler
        // for this file.  This is the file system's opportunity to remove any
        // share access information for the file, to indicate that if the file
        // is opened for a caching operation and this is the last file object
        // to the file, then it can do whatever it needs with memory management
        // to cleanup any information.
        //
        // Begin by getting the address of the target device object.
        //

        deviceObject = fileObject->DeviceObject;

        //
        // Ensure that the I/O system believes that this file has a handle
        // associated with it in case it doesn't actually get one from the
        // Object Manager.  This is done because sometimes the Object Manager
        // actually creates a handle, but the I/O system never finds out
        // about it so it attempts to send two cleanups for the same file.
        //

        fileObject->Flags |= FO_HANDLE_CREATED;

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now. The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopAcquireFileObjectLock(fileObject);
        }

        //
        // Initialize the local event that will be used to synchronize access
        // to the driver completing this I/O operation.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->UserEvent = &event;
        irp->UserIosb = &irp->IoStatus;
        irp->Overlay.AsynchronousParameters.UserApcRoutine = (PIO_APC_ROUTINE) NULL;
        irp->Flags = IRP_SYNCHRONOUS_API | IRP_CLOSE_OPERATION;

        //
        // Get a pointer to the stack location for the first driver.  This will
        // be used to pass the original function codes and parameters.  No
        // function-specific parameters are required for this operation.
        //

        irpSp = IoGetNextIrpStackLocation( irp );
        irpSp->MajorFunction = IRP_MJ_CLEANUP;
        irpSp->FileObject = fileObject;

        //
        // Insert the packet at the head of the IRP list for the thread.
        //

        IopQueueThreadIrp( irp );

        //
        // Invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );

        //
        // If no error was incurred, wait for the I/O operation to complete.
        //

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          UserRequest,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // The following code tears down the IRP by hand since it may not
        // either be possible to it to be completed (because this code was
        // invoked as APC_LEVEL in the first place - or because the reference
        // count on the object cannot be incremented due to this routine
        // being invoked by the delete file procedure below).  Cleanup IRPs
        // therefore use close sematics (the close operation flag is set
        // in the IRP) so that the I/O complete request routine itself sets
        // the event to the Signaled state.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        //
        // Also, free the IRP.
        //

        IoFreeIrp( irp );

        //
        // If this operation was a synchronous I/O operation, release the
        // semaphore so that the file can be used by other threads.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return;
}

VOID
IopDeleteFile(
    IN PVOID Object
    )

/*++

Routine Description:

    This routine is invoked when the last handle to a specific file handle is
    being closed and the file object is going away.  It is the responsibility
    of this routine to perform the following functions:

        o  Notify the device driver that the file object is open on that the
           file is being closed.

        o  Dereference the user's error port for the file object, if there
           is one associated with the file object.

        o  Decrement the device object reference count.

Arguments:

    Object - Pointer to the file object being deleted.

Return Value:

    None.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT deviceObject;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL irql;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    KEVENT event;

    //
    // Obtain a pointer to the file object.
    //

    fileObject = (PFILE_OBJECT) Object;

    //
    // Get a pointer to the first device driver which should be notified that
    // this file is going away.  If the device driver field is NULL, then this
    // file is being shut down due to an error attempting to get it open in the
    // first place, so do not do any further processing.
    //

    if (fileObject->DeviceObject) {

        deviceObject = fileObject->DeviceObject;

        //
        // If this file has never had a file handle created for it, and yet
        // it exists, invoke the close file procedure so that the file system
        // gets the cleanup IRP it is expecting before sending the close IRP.
        //

        if (!(fileObject->Flags & FO_HANDLE_CREATED)) {
            IopCloseFile( Object, 1 );
        }

        //
        // If this file is open for synchronous I/O, wait until this thread
        // owns it exclusively since there may still be a thread using it.
        // This occurs when a system service owns the file because it owns
        // the semaphore, but the I/O completion code has already dereferenced
        // the file object itself.  Without waiting here for the same semaphore
        // there would be a race condition in the service who owns it now.  The
        // service needs to be able to access the object w/o it going away after
        // its wait for the file event is satisfied.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            IopAcquireFileObjectLock(fileObject);
        }

        //
        // Reset a local event that can be used to wait for the device driver
        // to close the file.
        //

        KeInitializeEvent( &event, SynchronizationEvent, FALSE );

        //
        // Reset the event in the file object.
        //

        KeClearEvent( &fileObject->Event );

        //
        // Allocate and initialize the I/O Request Packet (IRP) for this
        // operation.
        //

        irp = IopAllocateIrpMustSucceed( deviceObject->StackSize );

        //
        // Get a pointer to the stack location for the first driver.  This is
        // where the function codes and parameters are placed.
        //

        irpSp = IoGetNextIrpStackLocation( irp );

        //
        // Fill in the IRP, indicating that this file object is being deleted.
        //

        irpSp->MajorFunction = IRP_MJ_CLOSE;
        irpSp->FileObject = fileObject;
        irp->UserIosb = &ioStatusBlock;
        irp->UserEvent = &event;
        irp->Tail.Overlay.OriginalFileObject = fileObject;
        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Flags = IRP_CLOSE_OPERATION | IRP_SYNCHRONOUS_API;

        //
        // Place this packet in the thread's I/O pending queue.
        //

        IopQueueThreadIrp( irp );

        //
        // Give the device driver the packet.  If this request does not work,
        // there is nothing that can be done about it.  This is unfortunate
        // because the driver may have had problems that it was about to
        // report about other operations (e.g., write behind failures, etc.)
        // that it can no longer report.  The reason is that this routine
        // is really initially invoked by NtClose, which has already closed
        // the caller's handle, and that's what the return status from close
        // indicates:  the handle has successfully been closed.
        //

        status = IoCallDriver( deviceObject, irp );

        if (status == STATUS_PENDING) {
            (VOID) KeWaitForSingleObject( &event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          (PLARGE_INTEGER) NULL );
        }

        //
        // Perform any completion operations that need to be performed on
        // the IRP that was used for this request.  This is done here as
        // as opposed to in normal completion code because there is a race
        // condition between when this routine executes if it was invoked
        // from a special kernel APC (e.g., some IRP was just completed and
        // dereferenced this file object for the last time), and when the
        // special kernel APC because of this packet's completion executing.
        //
        // This problem is solved by not having to queue a special kernel
        // APC routine for completion of this packet.  Rather, it is treated
        // much like a synchronous paging I/O operation, except that the
        // packet is not even freed during I/O completion.  This is because
        // the packet is still in this thread's queue, and there is no way
        // to get it out except at APC_LEVEL.  Unfortunately, the part of
        // I/O completion that needs to dequeue the packet is running at
        // DISPATCH_LEVEL.
        //
        // Hence, the packet must be removed from the queue (synchronized,
        // of course), and then it must be freed.
        //

        KeRaiseIrql( APC_LEVEL, &irql );
        IopDequeueThreadIrp( irp );
        KeLowerIrql( irql );

        IoFreeIrp( irp );

        //
        // If there was an completion port associated w/this file object, dereference
        // it now, and deallocate the completion context pool.
        //

        if (fileObject->CompletionContext) {
            ObDereferenceObject( fileObject->CompletionContext->Port );
            ExFreePool( fileObject->CompletionContext );
        }

        //
        // Decrement the reference count on the device object.  Note that
        // if the driver has been marked for an unload operation, and the
        // reference count goes to zero, then the driver may need to be
        // unloaded at this point.
        //

        IopDecrementDeviceObjectRef( deviceObject );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\parse.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    parse.c

Abstract:

    This module contains the code to implement the device object parse routine.

--*/

#include "iop.h"

//
// Define external procedures not in common header files
//

NTSTATUS
RawxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FatxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
GdfxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
UdfxMountVolume(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IopMountVolume(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN AllowRawMount
    )

/*++

Routine Description:

    This routine is used to mount a volume on the specified device.

Arguments:

    DeviceObject - Pointer to device object on which the volume is to be
        mounted.

    AllowRawMount - This parameter tells us if we should continue our
        filesystem search to include the Raw file system.  This flag will
        only be passed in as TRUE as a result of a DASD open.

Return Value:

    The function value is a successful status code if a volume was successfully
    mounted on the device.  Otherwise, an error code is returned.

--*/

{
    NTSTATUS status;

    //
    // Obtain the lock for the device to be mounted.  This guarantees that
    // only one thread is attempting to mount this particular device at a time.
    //

    status = KeWaitForSingleObject( &DeviceObject->DeviceLock,
                                    Executive,
                                    KernelMode,
                                    FALSE,
                                    (PLARGE_INTEGER) NULL );

    //
    // Check if the device is still in the unmounted state.
    //

    if (DeviceObject->MountedOrSelfDevice == NULL) {

        //
        // Check if the device supports high level file systems and if so,
        // attempt to mount an appropriate file system.
        //

        if ((DeviceObject->Flags & DO_RAW_MOUNT_ONLY) == 0) {

            if (DeviceObject->DeviceType == FILE_DEVICE_CD_ROM) {

                status = GdfxMountVolume(DeviceObject);

                if (status == STATUS_UNRECOGNIZED_VOLUME) {
                    status = UdfxMountVolume(DeviceObject);
                }

            } else {
                status = FatxMountVolume(DeviceObject);
            }

        } else {
            status = STATUS_UNRECOGNIZED_VOLUME;
        }

        //
        // If the volume hasn't been recognized yet and we're allowed to mount
        // the volume as a RAW device, then do so.
        //

        if (!NT_SUCCESS(status) && AllowRawMount) {
            status = RawxMountVolume(DeviceObject);
        }

    } else {

        //
        // The volume for this device has already been mounted.  Return a
        // success code.
        //

        status = STATUS_SUCCESS;
    }

    //
    // Release the synchronization event for the device.
    //

    KeSetEvent( &DeviceObject->DeviceLock, 0, FALSE );

    return status;
}

NTSTATUS
IoParseDevice(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and the
    name translates to a device object.  This routine is specified as the parse
    routine for all device objects.

    In the normal case of an NtCreateFile, the user specifies either the name
    of a device or of a file.  In the former situation, this routine is invoked
    with a pointer to the device and a null ("") string.  For this case, the
    routine simply allocates an IRP, fills it in, and passes it to the driver
    for the device.  The driver will then perform whatever rudimentary functions
    are necessary and will return a status code indicating whether an error was
    incurred.  This status code is remembered in the Open Packet (OP).

    In the latter situation, the name string to be opened/created is non-null.
    That is, it contains the remainder of the pathname to the file that is to
    be opened or created.  For this case, the routine allocates an IRP, fills
    it in, and passes it to the driver for the device.  The driver may then
    need to take further action or it may complete the request immediately.  If
    it needs to perform some work asynchronously, then it can queue the request
    and return a status of STATUS_PENDING.  This allows this routine and its
    caller to return to the user so that he can continue.  Otherwise, the open/
    create is basically finished.

    If the driver supports symbolic links, then it is also possible for the
    driver to return a new name.  This name will be returned to the Object
    Manager as a new name to look up.  The parsing will then begin again from
    the start.

    It is also the responsibility of this routine to create a file object for
    the file, if the name specifies a file.  The file object's address is
    returned to the NtCreateFile service through the OP.

Arguments:

    ParseObject - Pointer to the device object the name translated into.

    ObjectType - Type of the object being opened.

    AccessState - Running security access state information for operation.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{

    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    POPEN_PACKET op;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT parseDeviceObject;
    PDUMMY_FILE_OBJECT localFileObject;
    LOGICAL realFileObjectRequired;
    KIRQL OldIrql;

    PAGED_CODE();

    //
    // Assume failure by setting the returned object pointer to NULL.
    //

    *Object = (PVOID) NULL;

    //
    // Get the address of the Open Packet (OP).
    //

    op = Context;

    //
    // If no open packet was specified and there's no more name to parse, then
    // return the device object itself.
    //
    // We hit this path if somebody calls ObReferenceObjectByName (or
    // equivalent).  This allows the client to access a device object without
    // going through a file system.
    //

    if (op == NULL && RemainingName->Length == 0) {
        ObReferenceObject(ParseObject);
        *Object = ParseObject;
        return STATUS_SUCCESS;
    }

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {

        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    //
    // Obtain a pointer to the parse object as a device object, which is the
    // actual type of the object anyway.
    //

    parseDeviceObject = (PDEVICE_OBJECT) ParseObject;

    //
    // If this is a relative open, then get the device on which the file
    // is really being opened from the related file object and use that for
    // the remainder of this function and for all operations performed on
    // the file object that is about to be created.
    //

    if (op->RelatedFileObject) {
        parseDeviceObject = op->RelatedFileObject->DeviceObject;
    }

    //
    // Make sure that the device and its driver are really there.
    //
    // Note that it is possible to "open" an exclusive device more than once
    // provided that the caller is performing a relative open.  This feature
    // is how users "allocate" a device, and then use it to perform operations.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    if (parseDeviceObject->DeletePending ||
        parseDeviceObject->Flags & DO_DEVICE_INITIALIZING) {

        status = STATUS_NO_SUCH_DEVICE;

    } else if (parseDeviceObject->Flags & DO_EXCLUSIVE &&
               parseDeviceObject->ReferenceCount != 0 &&
               op->RelatedFileObject == NULL) {

        status = STATUS_ACCESS_DENIED;

    } else {

        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(status)) {
        KeLowerIrql(OldIrql);
        return op->FinalStatus = status;
    }

    //
    // Get the address of the mounted or self device object.  If the pointer
    // is null, then the device has not been mounted yet, so do it now.
    //

    while ((deviceObject = parseDeviceObject->MountedOrSelfDevice) == NULL) {

        KeLowerIrql(OldIrql);

        status = IopMountVolume( parseDeviceObject,
                                 (BOOLEAN) (!RemainingName->Length && !op->RelatedFileObject));

        if (!NT_SUCCESS(status)) {
            return op->FinalStatus = status;
        }

        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    deviceObject->ReferenceCount++;
    KeLowerIrql(OldIrql);

    //
    // After this point, we shouldn't touch parseDeviceObject.  The device that
    // we're going to send the IRP_MJ_CREATE to is deviceObject.  That may be a
    // file system device.  A file system device could be unmounted by another
    // thread while we're trying to create a file.  We have a stable reference
    // to the file system device, but the link between the original
    // parseDeviceObject and deviceObject may no longer exist.
    //

    parseDeviceObject = NULL;

    //
    // Since ObOpenObjectByName is called without being passed
    // any object type information, we need to map the generic
    // bits in the DesiredAccess mask here.
    //

    RtlMapGenericMask( &op->DesiredAccess, &IopFileMapping );

    //
    // Allocate and fill in the I/O Request Packet (IRP) to use in interfacing
    // to the driver.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {
        IopDecrementDeviceObjectRef(deviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    irp->Flags = IRP_CREATE_OPERATION | IRP_SYNCHRONOUS_API | IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This is where
    // the original function codes and parameters are passed.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // This is a normal file open or create function.
    //

    irpSp->MajorFunction = IRP_MJ_CREATE;
    irpSp->Flags = (UCHAR) op->Options;
    if (!(Attributes & OBJ_CASE_INSENSITIVE)) {
        irpSp->Flags |= SL_CASE_SENSITIVE;
    }

    //
    // Also fill in the NtCreateFile service's caller's parameters.
    //

    irp->Overlay.AllocationSize = op->AllocationSize;
    irpSp->Parameters.Create.Options = (op->Disposition << 24) | (op->CreateOptions & 0x00ffffff);
    irpSp->Parameters.Create.FileAttributes = op->FileAttributes;
    irpSp->Parameters.Create.ShareAccess = op->ShareAccess;
    irpSp->Parameters.Create.DesiredAccess = op->DesiredAccess;
    irpSp->Parameters.Create.RemainingName = RemainingName;

    //
    // Fill in local parameters so this routine can determine when the I/O is
    // finished, and the normal I/O completion code will not get any errors.
    //

    irp->UserIosb = &ioStatus;

    //
    // Allocate and initialize the file object that will be used in dealing
    // with the device for the remainder of this session with the user.  How
    // the file object is allocated is based on whether or not a real file
    // object is actually required.  It is not required for the query and
    // delete only operations.
    //

    realFileObjectRequired = !(op->QueryOnly || op->DeleteOnly);

    if (realFileObjectRequired) {

        OBJECT_ATTRIBUTES objectAttributes;

        //
        // A real, full-blown file object is actually required.
        //

        InitializeObjectAttributes( &objectAttributes,
                                    (POBJECT_STRING) NULL,
                                    Attributes,
                                    (HANDLE) NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                  );

        status = ObCreateObject( &IoFileObjectType,
                                 &objectAttributes,
                                 (ULONG) sizeof( FILE_OBJECT ),
                                 (PVOID *) &fileObject );

        if (!NT_SUCCESS( status )) {
            IoFreeIrp( irp );
            IopDecrementDeviceObjectRef(deviceObject);
            return op->FinalStatus = status;
        }

        RtlZeroMemory( fileObject, sizeof( FILE_OBJECT ) );
        fileObject->Type = IO_TYPE_FILE;
        fileObject->RelatedFileObject = op->RelatedFileObject;
        if (op->CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) {
            fileObject->Flags = FO_SYNCHRONOUS_IO;
            if (op->CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) {
                fileObject->Flags |= FO_ALERTABLE_IO;
            }
        }

        //
        // Now fill in the file object as best is possible at this point and set
        // a pointer to it in the IRP so everyone else can find it.
        //

        if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
            fileObject->LockCount = -1;
            KeInitializeEvent( &fileObject->Lock, SynchronizationEvent, FALSE );
        }
        if (op->CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING) {
            fileObject->Flags |= FO_NO_INTERMEDIATE_BUFFERING;
        }
        if (op->CreateOptions & FILE_SEQUENTIAL_ONLY) {
            fileObject->Flags |= FO_SEQUENTIAL_ONLY;
        }
        if (op->CreateOptions & FILE_RANDOM_ACCESS) {
            fileObject->Flags |= FO_RANDOM_ACCESS;
        }

    } else {

        //
        // This is either a quick delete or query operation.  For these cases,
        // it is possible to optimize the Object Manager out of the picture by
        // simply putting together something that "looks" like a file object,
        // and then operating on it.
        //

        localFileObject = op->LocalFileObject;
        RtlZeroMemory( localFileObject, sizeof( DUMMY_FILE_OBJECT ) );
        fileObject = (PFILE_OBJECT) &localFileObject->ObjectHeader.Body;
        localFileObject->ObjectHeader.Type = &IoFileObjectType;
        localFileObject->ObjectHeader.PointerCount = 1;
    }

    fileObject->Type = IO_TYPE_FILE;
    fileObject->RelatedFileObject = op->RelatedFileObject;
    fileObject->DeviceObject = deviceObject;

    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irpSp->FileObject = fileObject;

    //
    // Finally, initialize the file object's event to the Not Signaled state
    // and remember that a file object was created.
    //

    KeInitializeEvent( &fileObject->Event, NotificationEvent, FALSE );
    op->FileObject = fileObject;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Now invoke the driver itself to open the file.
    //

    status = IoCallDriver( deviceObject, irp );

    //
    // One of three things may have happened when the driver was invoked:
    //
    //    1.  The I/O operation is pending (Status == STATUS_PENDING).  This can
    //        occur on devices which need to perform some sort of device
    //        manipulation (such as opening a file for a file system).
    //
    //    2.  The driver returned an error (Status < 0). This occurs when either
    //        a supplied parameter was in error, or the device or file system
    //        incurred or discovered an error.
    //
    //    3.  The operation is complete and was successful (Status ==
    //        STATUS_SUCCESS).  Note that for this case the only action is to
    //        return a pointer to the file object.
    //

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &fileObject->Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;

    } else {

        //
        // The I/O operation was completed without returning a status of
        // pending.  This means that at this point, the IRP has not been
        // fully completed.  Complete it now.
        //

        KIRQL irql;

        ASSERT( !irp->PendingReturned );

        KeRaiseIrql( APC_LEVEL, &irql );

        //
        // Note that normally the system would simply call IopCompleteRequest
        // here to complete the packet.  However, because this is a create
        // operation, several assumptions can be made that make it much faster
        // to perform the couple of operations that completing the request
        // would perform.  These include:  copying the I/O status block,
        // dequeueing the IRP and freeing it, and setting the file object's
        // event to the signalled state.  The latter is done here by hand,
        // since it is known that it is not possible for any thread to be
        // waiting on the event.
        //

        ioStatus = irp->IoStatus;
        status = ioStatus.Status;

        fileObject->Event.Header.SignalState = 1;

        IopDequeueThreadIrp( irp );

        IoFreeIrp( irp );

        KeLowerIrql( irql );
    }

    ASSERT(status != STATUS_REPARSE);

    //
    // Copy the information field of the I/O status block back to the
    // original caller in case it is required.
    //

    op->Information = ioStatus.Information;

    if (!NT_SUCCESS( status )) {

        //
        // The operation ended in an error.  Kill the file object, dereference
        // the device object, and return a null pointer.
        //

        fileObject->DeviceObject = (PDEVICE_OBJECT) NULL;

        if (realFileObjectRequired) {
            ObDereferenceObject( fileObject );
        }
        op->FileObject = (PFILE_OBJECT) NULL;

        IopDecrementDeviceObjectRef(deviceObject);

        return op->FinalStatus = status;
    }

    //
    // The operation was successful. If this is not a query or a delete,
    // but rather a normal open/create, return the address of the
    // FileObject to the caller and set the information returned in the
    // original requestor's I/O status block. Also set the value of the
    // parse check field in the open packet to a value which will let
    // the caller know that this routine was successful in creating the
    // file object. Finally, return the status of the operation to the
    // caller.
    //

    if (realFileObjectRequired) {

        *Object = fileObject;
        op->ParseCheck = OPEN_PACKET_PATTERN;

        //
        // Add a reference so the file object cannot go away before
        // the create routine gets chance to flag the object for handle
        // create.
        //

        ObReferenceObject( fileObject );

        return op->FinalStatus = ioStatus.Status;

    } else {

        //
        // This is either a quick query or delete operation.  Determine
        // which it is and quickly perform the operation.
        //

        if (op->QueryOnly) {

            ULONG returnedLength;

            //
            // This is a full attribute query.  Attempt to obtain the
            // full network attributes for the file.  This includes
            // both the basic and standard information about the
            // file.
            //

            status = IoQueryFileInformation(
                        fileObject,
                        FileNetworkOpenInformation,
                        sizeof( FILE_NETWORK_OPEN_INFORMATION ),
                        op->NetworkInformation,
                        &returnedLength
                        );

        } else {

            //
            // There is nothing to do for a quick delete since the caller
            // set the FILE_DELETE_ON_CLOSE CreateOption so it is already
            // set in the file system.
            //

            NOTHING;
        }

        op->ParseCheck = OPEN_PACKET_PATTERN;
        IopDeleteFile( fileObject );
        op->FileObject = (PFILE_OBJECT) NULL;
        op->FinalStatus = status;

        //
        // Return an error code here so that the object manager doesn't
        // think that we actually created an object.  The query and delete
        // code end up looking at the open packet to determine whether or
        // not the operation actually worked.
        //

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }
}

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    )

/*++

Routine Description:

    This routine interfaces to the NT Object Manager.  It is invoked when
    the object system is given the name of an entity to create or open and is
    also given a handle to a directory file object that the operation is to be
    performed relative to.  This routine is specified as the parse routine for
    all file objects.

    This routine simply invokes the parse routine for the appropriate device
    that is associated with the file object.  It is the responsibility of that
    routine to perform the operation.

Arguments:

    ParseObject - Pointer to the file object that the name is to be opened or
        created relative to.

    ObjectType - Type of the object being opened.

    Attributes - Attributes to be applied to the object.

    CompleteName - Complete name of the object.

    RemainingName - Remaining name of the object.

    Context - Pointer to an Open Packet (OP) from NtCreateFile service.

    Object - The address of a variable to receive the created file object, if
        any.

Return Value:

    The function return value is one of the following:

        a)  Success - This indicates that the function succeeded and the object
            parameter contains the address of the created file object.

        b)  Error - This indicates that the file was not found or created and
            no file object was created.

        c)  Reparse - This indicates that the remaining name string has been
            replaced by a new name that is to be parsed.

--*/

{
    PFILE_OBJECT fileObject;
    POPEN_PACKET op;

    PAGED_CODE();

    //
    // Get the address of the Open Packet (OP).
    //

    op = (POPEN_PACKET) Context;

    //
    // Ensure that this routine is actually being invoked because someone is
    // attempting to open a device or a file through NtCreateFile.  This code
    // must be invoked from there (as opposed to some other random object
    // create or open routine).
    //

    if (op == NULL ||
        op->Type != IO_TYPE_OPEN_PACKET ||
        op->Size != sizeof( OPEN_PACKET )) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    fileObject = (PFILE_OBJECT) ParseObject;

    //
    // Pass the related file object to the device object parse routine.
    //

    op->RelatedFileObject = fileObject;

    //
    // Open or create the specified file.
    //

    return IoParseDevice( fileObject->DeviceObject,
                          ObjectType,
                          Attributes,
                          CompleteName,
                          RemainingName,
                          Context,
                          Object );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\qsfs.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    qsfs.c

Abstract:

    This module contains the code to implement the NtQueryVolumeInformationFile
    and NtSetVolumeInformationFile system services for the NT I/O system.

--*/

#include "iop.h"

NTSTATUS
NtQueryVolumeInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FsInformation,
    IN ULONG Length,
    IN FS_INFORMATION_CLASS FsInformationClass
    )

/*++

Routine Description:

    This service returns information about the volume associated with the
    FileHandle parameter.  The information returned in the buffer is defined
    by the FsInformationClass parameter.  The legal values for this parameter
    are as follows:

        o  FileFsVolumeInformation

        o  FileFsSizeInformation

        o  FileFsDeviceInformation

        o  FileFsAttributeInformation

Arguments:

    FileHandle - Supplies a handle to an open volume, directory, or file
        for which information about the volume is returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the volume.

    Length - Supplies the length, in bytes, of the FsInformation buffer.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Ensure that the FsInformationClass parameter is legal for querying
    // information about the volume.
    //

    if ((ULONG) FsInformationClass >= FileFsMaximumInformation ||
        IopQueryFsOperationLength[FsInformationClass] == 0) {
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    // Finally, ensure that the supplied buffer is large enough to contain
    // the information associated with the specified query operation that
    // is to be performed.
    //

    if (Length < (ULONG) IopQueryFsOperationLength[FsInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject);
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if ((IopQueryFsOperationAccess[FsInformationClass] & FILE_READ_DATA) &&
        !fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
        IopAcquireFileObjectLock(fileObject);
        synchronousIo = TRUE;
    } else {
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Get a pointer to the device object for the target device.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // If this I/O operation is not being performed as synchronous I/O,
    // then allocate an event that will be used to synchronize the
    // completion of this operation.  That is, this system service is
    // a synchronous API being invoked for a file that is opened for
    // asynchronous I/O.
    //

    if (!(fileObject->Flags & FO_SYNCHRONOUS_IO)) {
        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
    }

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this
    // operation.  The allocation is performed with an exception handler
    // in case the caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an
        // appropriate error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = FsInformation;
    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryVolume.Length = Length;
    irpSp->Parameters.QueryVolume.FsInformationClass = FsInformationClass;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    //
    // If the file for this operation was not opened for synchronous I/O, then
    // synchronization of completion of the I/O operation has not yet occurred
    // since the allocated event must be used for synchronous APIs on files
    // opened for asynchronous I/O.  Synchronize the completion of the I/O
    // operation now.
    //

    if (!synchronousIo) {

        status = IopSynchronousApiServiceTail( status,
                                               &localEvent,
                                               irp,
                                               &localIoStatus,
                                               IoStatusBlock );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\iosubs.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    iosubs.c

Abstract:

    This module contains the subroutines for the I/O system.

--*/

#include "iop.h"

PIRP
IoAllocateIrp(
    IN CCHAR StackSize
    )

/*++

Routine Description:

    This routine allocates an I/O Request Packet from the system nonpaged pool.
    The packet will be allocated to contain StackSize stack locations.  The IRP
    will also be initialized.

Arguments:

    StackSize - Specifies the maximum number of stack locations required.

Return Value:

    The function value is the address of the allocated/initialized IRP,
    or NULL if one could not be allocated.

--*/

{
    USHORT packetSize;
    PIRP irp;

    packetSize = IoSizeOfIrp(StackSize);

    //
    // Attempt to allocate the IRP from non-paged pool.
    //

    irp = ExAllocatePoolWithTag(packetSize, ' prI');

    if (!irp) {
        return NULL;
    }

    //
    // Initialize the packet.
    //

    IopInitializeIrp(irp, packetSize, StackSize);

    return irp;
}

PIRP
IoBuildAsynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PIO_STATUS_BLOCK IoStatusBlock OPTIONAL
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    IoStatusBlock - Pointer to the I/O status block for completion status
        information.  This parameter is optional since most asynchronous FSD
        requests will be synchronized by using completion routines, and so the
        I/O status block will not be written.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    //
    // Begin by allocating the IRP for this request.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize );
    if (!irp) {
        return irp;
    }
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code.
    //

    irpSp->MajorFunction = (UCHAR) MajorFunction;

    if (MajorFunction != IRP_MJ_FLUSH_BUFFERS &&
        MajorFunction != IRP_MJ_SHUTDOWN) {

        irp->UserBuffer = Buffer;

        //
        // Now determine whether or not we should automatically lock the user's
        // buffer for direct I/O.
        //

        if ((DeviceObject->Flags & DO_DIRECT_IO) && (Length != 0)) {
            IoLockUserBuffer(irp, Length);
        }

        //
        // Set the parameters according to whether this is a read or a write
        // operation.  Notice that these parameters must be set even if the
        // driver has not specified buffered or direct I/O.
        //

        if (MajorFunction == IRP_MJ_WRITE) {
            irpSp->Parameters.Write.Length = Length;
            irpSp->Parameters.Write.ByteOffset = *StartingOffset;
        } else {
            irpSp->Parameters.Read.Length = Length;
            irpSp->Parameters.Read.ByteOffset = *StartingOffset;
        }
    }

    //
    // Finally, set the address of the I/O status block and return a pointer
    // to the IRP.
    //

    irp->UserIosb = IoStatusBlock;
    return irp;
}

PIRP
IoBuildDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) that can be used to
    perform a synchronous internal or normal device I/O control function.

Arguments:

    IoControlCode - Specifies the device I/O control code that is to be
        performed by the target device driver.

    DeviceObject - Specifies the target device on which the I/O control
        function is to be performed.

    InputBuffer - Optional pointer to an input buffer that is to be passed
        to the device driver.

    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-
        Buffer parameter is not passed, this parameter must be zero.

    OutputBuffer - Optional pointer to an output buffer that is to be passed
        to the device driver.

    OutputBufferLength - Length of the OutputBuffer in bytes.  If the
        OutputBuffer parameter is not passed, this parameter must be zero.

    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether
        the packet that gets generated should have a major function code
        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or
        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).

    Event - Supplies a pointer to a kernel event that is to be set to the
        Signaled state when the I/O operation is complete.  Note that the
        Event must already be set to the Not-Signaled state.

    IoStatusBlock - Supplies a pointer to an I/O status block that is to
        be filled in with the final status of the operation once it
        completes.

Return Value:

    The function value is a pointer to the generated IRP suitable for calling
    the target device driver.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    ULONG method;
    NTSTATUS status;

    //
    // Begin by allocating the IRP for this request.
    //

    irp = IoAllocateIrp( DeviceObject->StackSize );
    if (!irp) {
        return irp;
    }
    irp->UserBuffer = OutputBuffer;

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and the parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation( irp );

    //
    // Set the major function code based on the type of device I/O control
    // function the caller has specified.
    //

    if (InternalDeviceIoControl) {
        irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    } else {
        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP for those parameters that are the same for all four methods.
    //

    irpSp->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
    irpSp->Parameters.DeviceIoControl.InputBuffer = InputBuffer;

    //
    // Based on the method that the buffer are being passed, lock down the
    // output buffer.
    //

    if (OutputBufferLength != 0) {

        method = IoControlCode & 3;

        if ((method == METHOD_IN_DIRECT) || (method == METHOD_OUT_DIRECT)) {
            IoLockUserBuffer(irp, OutputBufferLength);
        }
    }

    //
    // Finally, set the address of the I/O status block and the address of
    // the kernel event object.  Note that I/O completion will not attempt
    // to dereference the event since there is no file object associated
    // with this operation.
    //

    irp->UserIosb = IoStatusBlock;
    irp->UserEvent = Event;

    //
    // Also set the address of the current thread in the packet so the
    // completion code will have a context to execute in.  The IRP also
    // needs to be queued to the thread since the caller is going to set
    // the file object pointer.
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();
    IopQueueThreadIrp( irp );

    //
    // Simply return a pointer to the packet.
    //

    return irp;
}

PIRP
IoBuildSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL,
    IN PKEVENT Event,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    )

/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver.
    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

    This routine provides a simple, fast interface to the device driver w/o
    having to put the knowledge of how to build an IRP into all of the FSDs
    (and device drivers) in the system.

    The IRP created by this function causes the I/O system to complete the
    request by setting the specified event to the Signaled state.

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    Event - Pointer to a kernel event structure for synchronization.  The event
        will be set to the Signaled state when the I/O has completed.

    IoStatusBlock - Pointer to I/O status block for completion status info.

Return Value:

    The function value is a pointer to the IRP representing the specified
    request.

--*/

{
    PIRP irp;

    //
    // Do all of the real work in real IRP build routine.
    //

    irp = IoBuildAsynchronousFsdRequest( MajorFunction,
                                         DeviceObject,
                                         Buffer,
                                         Length,
                                         StartingOffset,
                                         IoStatusBlock );
    if (irp == NULL) {
        return irp;
    }

    //
    // Now fill in the event to the completion code will do the right thing.
    // Notice that because there is no FileObject, the I/O completion code
    // will not attempt to dereference the event.
    //

    irp->UserEvent = Event;

    //
    // There will be a file object associated w/this packet, so it must be
    // queued to the thread.
    //

    IopQueueThreadIrp( irp );
    return irp;
}

NTSTATUS
FASTCALL
IofCallDriver(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked to pass an I/O Request Packet (IRP) to another
    driver at its dispatch routine.

Arguments:

    DeviceObject - Pointer to device object to which the IRP should be passed.

    Irp - Pointer to IRP for request.

Return Value:

    Return status from driver's dispatch routine.

--*/

{
    PIO_STACK_LOCATION irpSp;
    PDRIVER_OBJECT driverObject;
    NTSTATUS status;

    //
    // Ensure that this is really an I/O Request Packet.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Update the IRP stack to point to the next location.
    //
    Irp->CurrentLocation--;

    if (Irp->CurrentLocation <= 0) {
        KeBugCheckEx( NO_MORE_IRP_STACK_LOCATIONS, (ULONG_PTR) Irp, 0, 0, 0 );
    }

    irpSp = IoGetNextIrpStackLocation( Irp );
    Irp->Tail.Overlay.CurrentStackLocation = irpSp;

    //
    // Save a pointer to the device object for this request so that it can
    // be used later in completion.
    //

    irpSp->DeviceObject = DeviceObject;

    //
    // Invoke the driver at its dispatch routine entry point.
    //

    driverObject = DeviceObject->DriverObject;

    status = driverObject->MajorFunction[irpSp->MajorFunction]( DeviceObject,
                                                              Irp );

    return status;
}

VOID
IoCancelThreadIo(
    IN PETHREAD Thread
    )

/*++

Routine Description:

    This routine cancels all of the I/O operations for the specified thread.
    This is accomplished by walking the list of IRPs in the thread IRP list
    and canceling each one individually.  No other I/O operations can be
    started for the thread since this routine has control of the thread itself.

Arguments:

    Tcb - Pointer to the Thread Control Block for the thread.

Return Value:

    None.

--*/

{
    PLIST_ENTRY header;
    PLIST_ENTRY entry;
    KIRQL irql;
    PIRP irp;
    ULONG count;
    LARGE_INTEGER interval;

    PAGED_CODE();

    //
    // Raise the IRQL so that the IrpList cannot be modified by a completion
    // APC and so that we can mark all of the IRPs as canceled without being
    // interrupted by IofCompleteRequest.
    //

    irql = KeRaiseIrqlToDpcLevel();

    header = &Thread->IrpList;
    entry = Thread->IrpList.Flink;

    //
    // Walk the list of pending IRPs, canceling each of them.
    //

    while (header != entry) {
        irp = CONTAINING_RECORD( entry, IRP, ThreadListEntry );
        irp->Cancel = TRUE;
        entry = entry->Flink;
    }

    //
    // Wait for the requests to complete.  Note that waiting may eventually
    // timeout, in which case more work must be done.
    //

    count = 0;
    interval.QuadPart = -10 * 1000 * 100;

    while (!IsListEmpty( &Thread->IrpList )) {

        //
        // Lower the IRQL so that the thread APC can fire which will complete
        // the requests.  Delay execution for a time and let the request
        // finish.  The delay time is 100ms.
        //

        KeLowerIrql( irql );
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        if (count++ > 3000) {

            //
            // This I/O request has timed out, as it has not been completed
            // for a full 5 minutes. Attempt to remove the packet's association
            // with this thread.  Note that by not resetting the count, the
            // next time through the loop the next packet, if there is one,
            // which has also timed out, will be dealt with, although it
            // will be given another 100ms to complete.
            //

            IopDisassociateThreadIrp();
        }

        KeRaiseIrql( APC_LEVEL, &irql );
    }

    KeLowerIrql( irql );
}

NTSTATUS
IoCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not a new accessor to
    a file actually has shared access to it.  The check is made according
    to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    If the open should succeed, then the access information about how the
    file is currently opened is updated, according to the Update parameter.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes how
        the file is currently being accessed.

    Update - Specifies whether or not the share access information for the
        file is to be updated.

Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,
    STATUS_SHARING_VIOLATION is returned.

Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    UCHAR ocount;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // Now check to see whether or not the desired accesses are compatible
        // with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ( (ocount == MAXUCHAR)
             ||
             (FileObject->ReadAccess && (ShareAccess->SharedRead < ocount))
             ||
             (FileObject->WriteAccess && (ShareAccess->SharedWrite < ocount))
             ||
             (FileObject->DeleteAccess && (ShareAccess->SharedDelete < ocount))
             ||
             ((ShareAccess->Readers != 0) && !FileObject->SharedRead)
             ||
             ((ShareAccess->Writers != 0) && !FileObject->SharedWrite)
             ||
             ((ShareAccess->Deleters != 0) && !FileObject->SharedDelete)
           ) {

            //
            // The check failed.  Simply return to the caller indicating that the
            // current open cannot access the file.
            //

            return STATUS_SHARING_VIOLATION;

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        } else if (Update) {

            ShareAccess->OpenCount++;

            ShareAccess->Readers += FileObject->ReadAccess;
            ShareAccess->Writers += FileObject->WriteAccess;
            ShareAccess->Deleters += FileObject->DeleteAccess;

            ShareAccess->SharedRead += FileObject->SharedRead;
            ShareAccess->SharedWrite += FileObject->SharedWrite;
            ShareAccess->SharedDelete += FileObject->SharedDelete;
        }
    }
    return STATUS_SUCCESS;
}

VOID
FASTCALL
IofCompleteRequest(
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    )

/*++

Routine Description:

    This routine is invoked to complete an I/O request.  It is invoked by the
    driver in its DPC routine to perform the final completion of the IRP.  The
    functions performed by this routine are as follows.

        1.  A check is made to determine whether the packet's stack locations
            have been exhausted.  If not, then the stack location pointer is set
            to the next location and if there is a routine to be invoked, then
            it will be invoked.  This continues until there are either no more
            routines which are interested or the packet runs out of stack.

            If a routine is invoked to complete the packet for a specific driver
            which needs to perform work a lot of work or the work needs to be
            performed in the context of another process, then the routine will
            return an alternate success code of STATUS_MORE_PROCESSING_REQUIRED.
            This indicates that this completion routine should simply return to
            its caller because the operation will be "completed" by this routine
            again sometime in the future.

        2.  A check is made to determine whether this IRP is an associated IRP.
            If it is, then the count on the master IRP is decremented.  If the
            count for the master becomes zero, then the master IRP will be
            completed according to the steps below taken for a normal IRP being
            completed.  If the count is still non-zero, then this IRP (the one
            being completed) will simply be deallocated.

        3.  If this is paging I/O or a close operation, then simply write the
            I/O status block and set the event to the signaled state, and
            dereference the event.  If this is paging I/O, deallocate the IRP
            as well.

        4.  Unlock the pages, if any, specified by the MDL by calling
            MmUnlockPages.

        5.  A check is made to determine whether or not completion of the
            request can be deferred until later.  If it can be, then this
            routine simply exits and leaves it up to the originator of the
            request to fully complete the IRP.  By not initializing and queueing
            the special kernel APC to the calling thread (which is the current
            thread by definition), a lot of interrupt and queueing processing
            can be avoided.

        6.  The final rundown routine is invoked to queue the request packet to
            the target (requesting) thread as a special kernel mode APC.

Arguments:

    Irp - Pointer to the I/O Request Packet to complete.

    PriorityBoost - Supplies the amount of priority boost that is to be given
        to the target thread when the special kernel APC is queued.

Return Value:

    None.

--*/

#define ZeroIrpStackLocation( IrpSp ) {         \
    (IrpSp)->MinorFunction = 0;                 \
    (IrpSp)->Flags = 0;                         \
    (IrpSp)->Control = 0 ;                      \
    (IrpSp)->Parameters.Others.Argument1 = 0;   \
    (IrpSp)->Parameters.Others.Argument2 = 0;   \
    (IrpSp)->Parameters.Others.Argument3 = 0;   \
    (IrpSp)->Parameters.Others.Argument4 = 0;   \
    (IrpSp)->FileObject = (PFILE_OBJECT) NULL; }

{
    NTSTATUS status;
    PIO_STACK_LOCATION stackPointer;
    PETHREAD thread;
    PFILE_OBJECT fileObject;
    KIRQL irql;

    //
    // Begin by ensuring that this packet has not already been completed
    // by someone.
    //

    if (Irp->CurrentLocation > (CCHAR) (Irp->StackCount + 1) ||
        Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }

    //
    // Ensure that the packet being completed really is still an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    //
    // Ensure that the packet is not being completed with a thoroughly
    // confusing status code.  Actually completing a packet with a pending
    // status probably means that someone forgot to set the real status in
    // the packet.
    //

    ASSERT( Irp->IoStatus.Status != STATUS_PENDING );

    //
    // Ensure that the packet is not being completed with a minus one.  This
    // is apparently a common problem in some drivers, and has no meaning
    // as a status code.
    //

    ASSERT( Irp->IoStatus.Status != 0xffffffff );

    //
    // Now check to see whether this is the last driver that needs to be
    // invoked for this packet.  If not, then bump the stack and check to
    // see whether the driver wishes to see the completion.  As each stack
    // location is examined, invoke any routine which needs to be invoked.
    // If the routine returns STATUS_MORE_PROCESSING_REQUIRED, then stop the
    // processing of this packet.
    //

    for (stackPointer = IoGetCurrentIrpStackLocation( Irp ),
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++;
         Irp->CurrentLocation <= (CCHAR) (Irp->StackCount + 1);
         stackPointer++,
         Irp->CurrentLocation++,
         Irp->Tail.Overlay.CurrentStackLocation++) {

        //
        // Check if the stack location is marked as a must complete packet.  If
        // so, decrement the number of pending must complete packets.
        //

        if (stackPointer->Control & SL_MUST_COMPLETE) {

            ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

            if ((--IoPendingMustCompletePackets == 0) &&
                HalIsResetOrShutdownPending()) {
                HalMustCompletePacketsFinished();
            }
        }

        //
        // A stack location was located.  Check to see whether or not it
        // has a completion routine and if so, whether or not it should be
        // invoked.
        //
        // Begin by saving the pending returned flag in the current stack
        // location in the fixed part of the IRP.
        //

        Irp->PendingReturned = (BOOLEAN)(stackPointer->Control & SL_PENDING_RETURNED);

        if ( (NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_SUCCESS) ||
             (!NT_SUCCESS( Irp->IoStatus.Status ) &&
             stackPointer->Control & SL_INVOKE_ON_ERROR)
           ) {

            //
            // This driver has specified a completion routine.  Invoke the
            // routine passing it a pointer to its device object and the
            // IRP that is being completed.
            //

            ZeroIrpStackLocation( stackPointer );

            status = stackPointer->CompletionRoutine( (PDEVICE_OBJECT) (Irp->CurrentLocation == (CCHAR) (Irp->StackCount + 1) ?
                                                      (PDEVICE_OBJECT) NULL :
                                                      IoGetCurrentIrpStackLocation( Irp )->DeviceObject),
                                                      Irp,
                                                      stackPointer->Context );

            if (status == STATUS_MORE_PROCESSING_REQUIRED) {

                //
                // Note:  Notice that if the driver has returned the above
                //        status value, it may have already DEALLOCATED the
                //        packet!  Therefore, do NOT touch any part of the
                //        IRP in the following code.
                //

                return;
            }

        } else {
            if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount) {
                IoMarkIrpPending( Irp );
            }
            ZeroIrpStackLocation( stackPointer );
        }
    }

    //
    // Check to see if this is paging I/O or a close operation.  If either,
    // then special processing must be performed.  The reasons that special
    // processing must be performed is different based on the type of
    // operation being performed.  The biggest reasons for special processing
    // on paging operations are that using a special kernel APC for an in-
    // page operation cannot work since the special kernel APC can incur
    // another pagefault.  Likewise, all paging I/O uses MDLs that belong
    // to the memory manager, not the I/O system.
    //
    // Close operations are special because the close may have been invoked
    // because of a special kernel APC (some IRP was completed which caused
    // the reference count on the object to become zero while in the I/O
    // system's special kernel APC routine).  Therefore, a special kernel APC
    // cannot be used since it cannot execute until the close APC finishes.
    //
    // The special steps are as follows for a synchronous paging operation
    // and close are:
    //
    //     1.  Copy the I/O status block (it is in SVAS, nonpaged).
    //     2.  Signal the event
    //     3.  If paging I/O, deallocate the IRP
    //
    // The special steps taken for asynchronous paging operations (out-pages)
    // are as follows:
    //
    //     1.  Initialize a special kernel APC just for page writes.
    //     1.  Queue the special kernel APC.
    //
    // It should also be noted that the logic for completing a Mount request
    // operation is exactly the same as a Page Read.  No assumptions should be
    // made here about this being a Page Read operation w/o carefully checking
    // to ensure that they are also true for a Mount.  That is:
    //
    //     IRP_PAGING_IO  and  IRP_MOUNT_COMPLETION
    //
    // are the same flag in the IRP.
    //
    // Also note that the last time the IRP is touched for a close operation
    // must be just before the event is set to the signaled state.  Once this
    // occurs, the IRP can be deallocated by the thread waiting for the event.
    //

    if (Irp->Flags & (IRP_MOUNT_COMPLETION | IRP_CLOSE_OPERATION)) {
        ULONG flags;
        flags = Irp->Flags & IRP_MOUNT_COMPLETION;
        *Irp->UserIosb = Irp->IoStatus;
        KeSetEvent( Irp->UserEvent, PriorityBoost, FALSE );
        if (flags) {
            IoFreeIrp( Irp );
        }
        return;
    }

    //
    // Check to see whether any pages need to be unlocked.
    //

    if ((Irp->Flags & IRP_UNLOCK_USER_BUFFER) != 0) {
        MmLockUnlockBufferPages(Irp->UserBuffer, Irp->LockedBufferLength, TRUE);
        Irp->Flags &= ~IRP_UNLOCK_USER_BUFFER;
    } else if (Irp->SegmentArray != NULL) {
        MmUnlockSelectedIoPages(Irp);
    }

    //
    // Make a final check here to determine whether or not this is a
    // synchronous I/O operation that is being completed in the context
    // of the original requestor.  If so, then an optimal path through
    // I/O completion can be taken.
    //

    if (Irp->Flags & IRP_DEFER_IO_COMPLETION && !Irp->PendingReturned) {
        return;
    }

    //
    // Finally, initialize the IRP as an APC structure and queue the special
    // kernel APC to the target thread.
    //

    thread = Irp->Tail.Overlay.Thread;
    fileObject = Irp->Tail.Overlay.OriginalFileObject;

    if (!Irp->Cancel) {

        KeInitializeApc( &Irp->Tail.Apc,
                         &thread->Tcb,
                         IopCompleteRequest,
                         (PKRUNDOWN_ROUTINE) NULL,
                         (PKNORMAL_ROUTINE) NULL,
                         KernelMode,
                         (PVOID) NULL );

        (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                 fileObject,
                                 (PVOID) NULL,
                                 PriorityBoost );
    } else {

        //
        // This request has been cancelled.  Ensure that access to the thread
        // is synchronized, otherwise it may go away while attempting to get
        // through the remainder of completion for this request.  This happens
        // when the thread times out waiting for the request to be completed
        // once it has been cancelled.
        //
        // Note that it is safe to capture the thread pointer above, w/o having
        // the lock because the cancel flag was not set at that point, and
        // the code that disassociates IRPs must set the flag before looking to
        // see whether or not the packet has been completed, and this packet
        // will appear to be completed because it no longer belongs to a driver.
        //

        irql = IopAcquireCompletionLock();

        thread = Irp->Tail.Overlay.Thread;

        if (thread) {

            KeInitializeApc( &Irp->Tail.Apc,
                             &thread->Tcb,
                             IopCompleteRequest,
                             (PKRUNDOWN_ROUTINE) NULL,
                             (PKNORMAL_ROUTINE) NULL,
                             KernelMode,
                             (PVOID) NULL );

            (VOID) KeInsertQueueApc( &Irp->Tail.Apc,
                                     fileObject,
                                     (PVOID) NULL,
                                     PriorityBoost );

            IopReleaseCompletionLock(irql);

        } else {

            //
            // This request has been aborted from completing in the caller's
            // thread.  This can only occur if the packet was cancelled, and
            // the driver did not complete the request, so it was timed out.
            // Attempt to drop things on the floor, since the originating thread
            // has probably exited at this point.
            //

            IopReleaseCompletionLock(irql);

            ASSERT( Irp->Cancel );

            //
            // Drop the IRP on the floor.
            //

            IopDropIrp( Irp, fileObject );
        }
    }
}

NTSTATUS
IoCreateDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN ULONG DeviceExtensionSize,
    IN POBJECT_STRING DeviceName OPTIONAL,
    IN DEVICE_TYPE DeviceType,
    IN BOOLEAN Exclusive,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    This routine creates a device object and links it into the I/O database.

Arguments:

    DriverObject - A pointer to the driver object for this device.

    DeviceExtensionSize - Size, in bytes, of extension to device object;
        i.e., the size of the driver-specific data for this device object.

    DeviceName - The name that should be associated with this device.

    DeviceType - The type of device that the device object should represent.

    Exclusive - Indicates that the device object should be created with using
        the exclusive object attribute.

        NOTE: This flag should not be used for WDM drivers.  Since only the
        PDO is named, it is the only device object in a devnode attachment
        stack that is openable.  However, since this device object is created
        by the underlying bus driver (which has no knowledge about what type
        of device this is), there is no way to know whether this flag should
        be set.  Therefore, this parameter should always be FALSE for WDM
        drivers.  Drivers attached to the PDO (e.g., the function driver) must
        enforce any exclusivity rules.

    DeviceObject - Pointer to the device object pointer we will return.

Return Value:

    The function value is the final status of the operation.


--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    PDEVICE_OBJECT deviceObject;
    HANDLE handle;
    BOOLEAN deviceHasName;
    ULONG RoundedSize;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Remember whether or not this device was created with a name so that
    // it can be deallocated later.
    //

    deviceHasName = (BOOLEAN) (ARGUMENT_PRESENT( DeviceName ) ? TRUE : FALSE);

    //
    // Initialize the object attributes structure in preparation for creating
    // device object.  Note that the device may be created as an exclusive
    // device so that only one open can be done to it at a time.  This saves
    // single user devices from having drivers that implement special code to
    // make sure that only one connection is ever valid at any given time.
    //

    InitializeObjectAttributes( &objectAttributes,
                                DeviceName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );


    if (Exclusive) {
        objectAttributes.Attributes |= OBJ_EXCLUSIVE;
    } else {
        objectAttributes.Attributes |= 0;
    }

    if (deviceHasName) {
        objectAttributes.Attributes |= OBJ_PERMANENT;
    }

    //
    // Create the device object itself.
    //

    RoundedSize = (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize)
                   % sizeof (LONGLONG);
    if (RoundedSize) {
        RoundedSize = sizeof (LONGLONG) - RoundedSize;
    }

    RoundedSize += DeviceExtensionSize;

    status = ObCreateObject( &IoDeviceObjectType,
                             &objectAttributes,
                             (ULONG) sizeof( DEVICE_OBJECT ) +
                                     RoundedSize,
                             (PVOID *) &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        // Creating the device object was not successful.  Clean everything
        // up and indicate that the object was not created.
        //

        deviceObject = (PDEVICE_OBJECT) NULL;

    } else {

        //
        // The device was successfully created.  Initialize the object so
        // that it can be inserted into the object table.  Begin by zeroing
        // the memory for the device object.
        //

        RtlZeroMemory( deviceObject,
                       sizeof( DEVICE_OBJECT ) + RoundedSize );

        //
        // Set the type and size of this device object.
        //

        deviceObject->Type = IO_TYPE_DEVICE;
        deviceObject->Size = (USHORT) (sizeof( DEVICE_OBJECT ) + DeviceExtensionSize);

        //
        // The device type field in the device object was shrunk to a single
        // byte.  All of the valid types defined in devioctl.h fall well below
        // this limit.
        //

        ASSERT(DeviceType == (DEVICE_TYPE)(UCHAR)DeviceType);

        //
        // Set the device type field in the object so that later code can
        // check the type.  Likewise, set the device characteristics.
        //

        deviceObject->DeviceType = (UCHAR)DeviceType;

        //
        // If this device is a storage device, set the MountedOrSelfDevice field
        // to NULL so that IoParseDevice forces a mount for the device.  All
        // other devices do not require a mount, so set the MountedOrSelfDevice
        // field to the device itself.
        //

        if ((DeviceType == FILE_DEVICE_DISK) ||
            (DeviceType == FILE_DEVICE_MEMORY_UNIT) ||
            (DeviceType == FILE_DEVICE_CD_ROM) ||
            (DeviceType == FILE_DEVICE_MEDIA_BOARD)) {

            KeInitializeEvent( &deviceObject->DeviceLock,
                               SynchronizationEvent,
                               TRUE );

            deviceObject->MountedOrSelfDevice = NULL;

        } else {

            deviceObject->MountedOrSelfDevice = deviceObject;
        }

        //
        // Initialize the remainder of the device object.
        //
        deviceObject->AlignmentRequirement = 0;
        deviceObject->Flags = DO_DEVICE_INITIALIZING;

        if (Exclusive) {
            deviceObject->Flags |= DO_EXCLUSIVE;
        }
        if (deviceHasName) {
            deviceObject->Flags |= DO_DEVICE_HAS_NAME;
        }

        if(DeviceExtensionSize) {
            deviceObject->DeviceExtension = deviceObject + 1;
        } else {
            deviceObject->DeviceExtension = NULL;
        }

        deviceObject->StackSize = 1;

        //
        // This is a real device of some sort.  Allocate a spin lock
        // and initialize the device queue object in the device object.
        //

        KeInitializeDeviceQueue( &deviceObject->DeviceQueue );

        //
        // Insert the device object into the table.
        //

        status = ObInsertObject( deviceObject,
                                 &objectAttributes,
                                 1,
                                 &handle );

        if (NT_SUCCESS( status )) {

            //
            // The insert completed successfully.  Link the device object
            // and driver objects together.  Close the handle so that if
            // the driver is unloaded, the device object can go away.
            //

            deviceObject->DriverObject = DriverObject;

            NtClose( handle );

        } else {

            //
            // The insert operation failed.  Fortunately it dropped the
            // reference count on the device - since that was the last one
            // all the cleanup should be done for us.
            //

            //
            // indicate that no device object was created.
            //

            deviceObject = (PDEVICE_OBJECT) NULL;
        }
    }

    *DeviceObject = deviceObject;
    return status;
}

NTSTATUS
IoCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG Disposition,
    IN ULONG CreateOptions,
    IN ULONG Options
    )

/*++

Routine Description:

    This is the common routine for both NtCreateFile and NtOpenFile to allow
    a user to create or open a file.  This procedure is also used internally
    by kernel mode components, such as the network server, to perform the
    same type of operation, but allows kernel mode code to force checking
    arguments and access to the file, rather than bypassing these checks
    because the code is running in kernel mode.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open
        file.

    DesiredAccess - Supplies the types of access that the caller would like
        to the file.

    ObjectAttributes - Supplies the attributes to be used for the file object
        (name, SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.
        This parameter only has an affect if the file is created.  Further,
        if not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would
        like to the file.

    Disposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    Options - Specifies the options that are to be used during generation
        of the create IRP.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    NTSTATUS status;
    HANDLE handle;
    OPEN_PACKET openPacket;
    BOOLEAN SuccessfulIoParse;
    LARGE_INTEGER initialAllocationSize;

    PAGED_CODE();

    if (Options & IO_CHECK_CREATE_PARAMETERS) {

        //
        // Check for any invalid parameters.
        //

        if (

            //
            // Check that no invalid file attributes flags were specified.
            //

//          (FileAttributes & ~FILE_ATTRIBUTE_VALID_SET_FLAGS)
            (FileAttributes & ~FILE_ATTRIBUTE_VALID_FLAGS)

            ||

            //
            // Check that no invalid share access flags were specified.
            //

            (ShareAccess & ~FILE_SHARE_VALID_FLAGS)

            ||

            //
            // Ensure that the disposition value is in range.
            //

            (Disposition > FILE_MAXIMUM_DISPOSITION)

            ||

            //
            // Check that no invalid create options were specified.
            //

            (CreateOptions & ~FILE_VALID_OPTION_FLAGS)

            ||

            //
            // If the caller specified synchronous I/O, then ensure that
            // (s)he also asked for synchronize desired access to the
            // file.
            //

            (CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT) &&
            (!(DesiredAccess & SYNCHRONIZE)))

            ||

            //
            // Also, if the caller specified that the file is to be deleted
            // on close, then ensure that delete is specified as one of the
            // desired accesses requested.
            //

            (CreateOptions & FILE_DELETE_ON_CLOSE &&
            (!(DesiredAccess & DELETE)))

            ||

            //
            // Likewise, ensure that if one of the synchronous I/O modes
            // is specified that the other one is not specified as well.
            //

            ((CreateOptions & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)) ==
                              (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT))

            ||

            //
            // If this create or open is for a directory operation, check
            // that all of the other flags, dispositions, and desired
            // access parameters were also specified correctly.
            //
            // These are as follows:
            //
            //     o  No other flags other than the synchronous I/O flags,
            //        write-through, or open by file ID are set.
            //
            //     o  The disposition value is one of create, open, or
            //        open-if.
            //
            //     o  No non-directory accesses have been specified.
            //

            ((CreateOptions & FILE_DIRECTORY_FILE)
             && !(CreateOptions & FILE_NON_DIRECTORY_FILE)
             && ((CreateOptions & ~(FILE_DIRECTORY_FILE |
                                    FILE_SYNCHRONOUS_IO_ALERT |
                                    FILE_SYNCHRONOUS_IO_NONALERT |
                                    FILE_WRITE_THROUGH |
                                    FILE_COMPLETE_IF_OPLOCKED |
                                    FILE_OPEN_FOR_BACKUP_INTENT |
                                    FILE_DELETE_ON_CLOSE |
                                    FILE_OPEN_FOR_FREE_SPACE_QUERY |
                                    FILE_OPEN_BY_FILE_ID |
                                    FILE_OPEN_REPARSE_POINT))
                 || ((Disposition != FILE_CREATE)
                     && (Disposition != FILE_OPEN)
                     && (Disposition != FILE_OPEN_IF))
                )
            )

            ||

            //
            //  FILE_COMPLETE_IF_OPLOCK and FILE_RESERVE_OPFILTER are
            //  incompatible options.
            //

            ((CreateOptions & FILE_COMPLETE_IF_OPLOCKED) &&
             (CreateOptions & FILE_RESERVE_OPFILTER))

            ||

            //
            // Finally, if the no intermediate buffering option was
            // specified, ensure that the caller did not also request
            // append access to the file.
            //

            (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING &&
            (DesiredAccess & FILE_APPEND_DATA)) ) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // The caller's mode is kernel.  Copy the input parameters to their
    // expected locations for later use.
    //

    if (ARGUMENT_PRESENT( AllocationSize )) {
        initialAllocationSize = *AllocationSize;
    } else {
        initialAllocationSize.QuadPart = 0;
    }

    //
    // Now fill in an Open Packet (OP) to be used in calling the device object
    // parse routine.  This packet will allow information to be passed between
    // this routine and the parse routine so that a common context may be kept.
    // For most services this would be done with an I/O Request Packet (IRP),
    // but this cannot be done here because the number of stack entries which
    // need to be allocated in the IRP is not yet known.
    //

    openPacket.Type = IO_TYPE_OPEN_PACKET;
    openPacket.Size = sizeof( OPEN_PACKET );
    openPacket.ParseCheck = 0L;
    openPacket.AllocationSize = initialAllocationSize;
    openPacket.CreateOptions = CreateOptions;
    openPacket.FileAttributes = (USHORT) FileAttributes;
    openPacket.ShareAccess = (USHORT) ShareAccess;
    openPacket.Disposition = Disposition;
    openPacket.QueryOnly = FALSE;
    openPacket.DeleteOnly = FALSE;
    openPacket.Options = Options;
    openPacket.RelatedFileObject = (PFILE_OBJECT) NULL;
    openPacket.DesiredAccess = DesiredAccess;

    //
    // Assume that the operation is going to be successful.
    //

    openPacket.FinalStatus = STATUS_SUCCESS;

    //
    // Zero the file object field in the OP so the parse routine knows that
    // this is the first time through.  For reparse operations it will continue
    // to use the same file object that it allocated the first time.
    //

    openPacket.FileObject = (PFILE_OBJECT) NULL;

    //
    // Attempt to open the file object by name.  This will yield the handle
    // that the user is to use as his handle to the file in all subsequent
    // calls, if it works.
    //
    // This call performs a whole lot of the work for actually getting every-
    // thing set up for the I/O system.  The object manager will take the name
    // of the file and will translate it until it reaches a device object (or
    // it fails).  If the former, then it will invoke the parse routine set up
    // by the I/O system for device objects.  This routine will actually end
    // up creating the file object, allocating an IRP, filling it in, and then
    // invoking the driver's dispatch routine with the packet.
    //

    status = ObOpenObjectByName( ObjectAttributes,
                                 (POBJECT_TYPE) NULL,
                                 &openPacket,
                                 &handle );

    //
    // Check the status of the open.  If it was not successful, cleanup and
    // get out.  Notice that it is also possible, because this code does not
    // explicitly request that a particular type of object (because the Object
    // Manager does not check when a parse routine is present and because the
    // name first refers to a device object and then a file object), a check
    // must be made here to ensure that what was returned was really a file
    // object.  The check is to see whether the device object parse routine
    // believes that it successfully returned a pointer to a file object.  If
    // it does, then OK;  otherwise, something went wrong somewhere.
    //

    SuccessfulIoParse = (BOOLEAN) (openPacket.ParseCheck == OPEN_PACKET_PATTERN);

    if (!NT_SUCCESS( status ) || !SuccessfulIoParse) {

        if (NT_SUCCESS( status )) {

            //
            // The operation was successful as far as the object system is
            // concerned, but the I/O system device parse routine was never
            // successfully completed so this operation has actually completed
            // with an error because of an object mismatch.  Therefore, this is
            // the wrong type of object so dereference whatever was actually
            // referenced by closing the handle that was created for it.
            // We have to do a NtClose as this handle can be a kernel handle if
            // IoCreateFile was called by a driver.
            //

            NtClose( handle );
            status = STATUS_OBJECT_TYPE_MISMATCH;
        }

        //
        // If the final status according to the device parse routine
        // indicates that the operation was not successful, then use that
        // routine's final status because it is more descriptive than the
        // status which was returned by the object manager.
        //

        if (!NT_SUCCESS( openPacket.FinalStatus )) {
            status = openPacket.FinalStatus;

            if (NT_WARNING( status )) {

                IoStatusBlock->Status = openPacket.FinalStatus;
                IoStatusBlock->Information = openPacket.Information;
            }

        } else if (openPacket.FileObject != NULL && !SuccessfulIoParse) {

            //
            // Otherwise, one of two things occurred:
            //
            //     1)  The parse routine was invoked at least once and a
            //         reparse was performed but the parse routine did not
            //         actually complete.
            //
            //     2)  The parse routine was successful so everything worked
            //         but the object manager incurred an error after the
            //         parse routine completed.
            //
            // For case #1, there is an outstanding file object that still
            // exists.  This must be cleaned up.
            //
            // For case #2, nothing must be done as the object manager has
            // already dereferenced the file object.  Note that this code is
            // not invoked if the parse routine completed with a successful
            // status return (SuccessfulIoParse is TRUE).
            //

            openPacket.FileObject->DeviceObject = (PDEVICE_OBJECT) NULL;
            ObDereferenceObject( openPacket.FileObject );
        }

    } else {

        //
        // At this point, the open/create operation has been successfully
        // completed.  There is a handle to the file object, which has been
        // created, and the file object has been signaled.
        //
        // The remaining work to be done is to complete the operation.  This is
        // performed as follows:
        //
        //    1.  The file object has been signaled, so no work needs to be done
        //        for it.
        //
        //    2.  The file handle is returned to the user.
        //
        //    3.  The I/O status block is written with the final status.
        //

        openPacket.FileObject->Flags |= FO_HANDLE_CREATED;

        ASSERT( openPacket.FileObject->Type == IO_TYPE_FILE );

        //
        // Return the file handle.
        //

        *FileHandle = handle;

        //
        // Write the I/O status into the caller's buffer.
        //

        IoStatusBlock->Information = openPacket.Information;
        IoStatusBlock->Status = openPacket.FinalStatus;
        status = openPacket.FinalStatus;
    }

    //
    // If the parse routine successfully created a file object then
    // derefence it here.
    //

    if (SuccessfulIoParse && openPacket.FileObject != NULL) {
        ObDereferenceObject( openPacket.FileObject );
    }

    return status;
}

NTSTATUS
IoCreateSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName,
    IN POBJECT_STRING DeviceName
    )

/*++

Routine Description:

    This routine is invoked to assign a symbolic link name to a device.

Arguments:

    SymbolicLinkName - Supplies the symbolic link name as a Unicode string.

    DeviceName - Supplies the name to which the symbolic link name refers.

Return Value:

    The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_PERMANENT | OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Note that the following assignment can fail (because it is not system
    // initialization time and therefore the \ARCname directory does not
    // exist - if this is really a call to IoAssignArcName), but that is fine.
    //

    status = NtCreateSymbolicLinkObject( &linkHandle,
                                         &objectAttributes,
                                         DeviceName );
    if (NT_SUCCESS( status )) {
        NtClose( linkHandle );
    }

    return status;
}

VOID
IoDeleteDevice(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine deletes the specified device object from the system so that
    it may no longer be referenced.  It is invoked when either the device
    driver is being unloaded from the system, or the driver's initialization
    routine failed to properly initialize the device or a fatal driver
    initialization error was encountered, or when the device is being removed
    from the system.

Arguments:

    DeviceObject - Pointer to the device object that is to be deleted.

Return Value:

    None.

--*/

{
    KIRQL irql;

    //
    // If this device has a name, then mark the
    // object as temporary so that when it is dereferenced it will be
    // deleted.
    //

    if (DeviceObject->Flags & DO_DEVICE_HAS_NAME) {
        ObMakeTemporaryObject( DeviceObject );
    }

    //
    // Mark the device object as deleted.
    //

    irql = KeRaiseIrqlToDpcLevel();

    DeviceObject->DeletePending = TRUE;

    if (!DeviceObject->ReferenceCount) {
        IopCompleteUnloadOrDelete( DeviceObject, irql );
    } else {
        KeLowerIrql(irql);
    }
}

NTSTATUS
IoDeleteSymbolicLink(
    IN POBJECT_STRING SymbolicLinkName
    )

/*++

Routine Description:

    This routine is invoked to remove a symbolic link from the system.  This
    generally occurs whenever a driver that has assigned a symbolic link needs
    to exit.  It can also be used when a driver no longer needs to redirect
    a name.

Arguments:

    SymbolicLinkName - Provides the Unicode name string to be deassigned.

Return Values:

    Status of operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE linkHandle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Begin by initializing the object attributes for the symbolic link.
    //

    InitializeObjectAttributes( &objectAttributes,
                                SymbolicLinkName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Open the symbolic link itself so that it can be marked temporary and
    // closed.
    //

    status = NtOpenSymbolicLinkObject( &linkHandle,
                                       &objectAttributes );
    if (NT_SUCCESS( status )) {

        //
        // The symbolic link was successfully opened.  Attempt to make it a
        // temporary object, and then close the handle.  This will cause the
        // object to go away.
        //

        status = NtMakeTemporaryObject( linkHandle );
        if (NT_SUCCESS( status )) {
            NtClose( linkHandle );
        }
    }


    return status;
}

NTSTATUS
IoDismountVolume(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine dismounts the file system volume attached to the supplied
    device.

Arguments:

    DeviceObject - Specifies the device to be dismounted.

Return Value:

    Status of operation.

--*/

{
    NTSTATUS status;
    KIRQL OldIrql;
    PDEVICE_OBJECT MountedDeviceObject;

    //
    // Synchronize access to MountedOrSelfDevice with IoParseDevice by raising
    // to DISPATCH_LEVEL.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    MountedDeviceObject = DeviceObject->MountedOrSelfDevice;

    if (MountedDeviceObject != NULL) {

        if (MountedDeviceObject->DriverObject->DriverDismountVolume != NULL) {
            MountedDeviceObject->ReferenceCount++;
            status = STATUS_SUCCESS;
        } else {
            MountedDeviceObject = NULL;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

    } else {
        status = STATUS_VOLUME_DISMOUNTED;
    }

    KeLowerIrql(OldIrql);

    //
    // If the supplied device has been mounted by a device with a dismount
    // volume routine, then invoke that routine.
    //

    if (MountedDeviceObject != NULL) {
        status = MountedDeviceObject->DriverObject->DriverDismountVolume(MountedDeviceObject);
        IopDecrementDeviceObjectRef(MountedDeviceObject);
    }

    return status;
}

NTSTATUS
IoDismountVolumeByName(
    IN POBJECT_STRING DeviceName
    )

/*++

Routine Description:

    This routine dismounts the file system volume attached to the device with
    supplied name.

Arguments:

    DeviceName - Specifies the name of the device to be dismounted.

Return Value:

    Status of operation.

--*/

{
    NTSTATUS status;
    PVOID DeviceObject;

    status = ObReferenceObjectByName(DeviceName, 0, &IoDeviceObjectType, NULL,
        &DeviceObject);

    if (NT_SUCCESS(status)) {
        status = IoDismountVolume((PDEVICE_OBJECT)DeviceObject);
        ObDereferenceObject(DeviceObject);
    }

    return status;
}

VOID
IoFreeIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine deallocates the specified I/O Request Packet.

Arguments:

    Irp - I/O Request Packet to deallocate.

Return Value:

    None.

--*/

{
    //
    // Ensure that the data structure being freed is really an IRP.
    //

    ASSERT( Irp->Type == IO_TYPE_IRP );

    if (Irp->Type != IO_TYPE_IRP) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) Irp, __LINE__, 0, 0 );
    }

    ASSERT(IsListEmpty(&(Irp)->ThreadListEntry));
    Irp->Type = 0;

    //
    // Ensure that all of the owners of the IRP have at least been notified
    // that the request is going away.
    //

    ASSERT( Irp->CurrentLocation >= Irp->StackCount );

    //
    // Deallocate the IRP.
    //

    ExFreePool( Irp );
}

VOID
IoInitializeIrp(
    IN OUT PIRP Irp,
    IN USHORT PacketSize,
    IN CCHAR StackSize
    )

/*++

Routine Description:

    Initializes an IRP.

Arguments:

    Irp - a pointer to the IRP to initialize.

    PacketSize - length, in bytes, of the IRP.

    StackSize - Number of stack locations in the IRP.

Return Value:

    None.

--*/

{
    IopInitializeIrp(Irp, PacketSize, StackSize);
}

NTSTATUS
IoInvalidDeviceRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is the default dispatch routine for all driver entries
    not implemented by drivers that have been loaded into the system.  Its
    responsibility is simply to set the status in the packet to indicate
    that the operation requested is invalid for this device type, and then
    complete the packet.

Arguments:

    DeviceObject - Specifies the device object for which this request is
        bound.  Ignored by this routine.

    Irp - Specifies the address of the I/O Request Packet (IRP) for this
        request.

Return Value:

    The final status is always STATUS_INVALID_DEVICE_REQUEST.


--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Simply store the appropriate status, complete the request, and return
    // the same status stored in the packet.
    //

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_INVALID_DEVICE_REQUEST;
}

VOID
IoLockUserBuffer(
    IN OUT PIRP Irp,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine locks Irp->UserBuffer using MmLockUnlockBufferPages and marks
    the IRP so that on packet cleanup, the buffer is unlocked.

Arguments:

    Irp - Pointer to IRP that describes the buffer to be locked.

    Length - Length, in bytes, of the buffer to be locked.

Return Value:

    None.

--*/

{
    ASSERT(Length != 0);

    //
    // If this is a scatter/gather operation or if the user buffer has already
    // been locked down, then we don't need to do anything.
    //

    if ((Irp->Flags & (IRP_SCATTER_GATHER_OPERATION | IRP_UNLOCK_USER_BUFFER)) == 0) {

        //
        // This isn't a scatter/gather operation, so the user buffer should have
        // been set to a valid pointer.
        //

        ASSERT(Irp->UserBuffer != NULL);

        MmLockUnlockBufferPages(Irp->UserBuffer, Length, FALSE);

        Irp->LockedBufferLength = Length;
        Irp->Flags |= IRP_UNLOCK_USER_BUFFER;

    } else {

        ASSERT(Irp->LockedBufferLength == Length);
    }
}

VOID
IoMarkIrpMustComplete(
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine marks the IRP as a must complete packet.  Must complete packets
    delay a system reset or shutdown until they are complete.

    This routine can only be called as DISPATCH_LEVEL.  The HAL code that relies
    on this variable only runs as a DPC.

Arguments:

    Irp - Pointer to IRP.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Only mark the current stack location once.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    if ((IrpSp->Control & SL_MUST_COMPLETE) == 0) {

        //
        // Mark the IRP so that we know that on completion of this IRP that the
        // must complete packet should be decremented.
        //

        IrpSp->Control |= SL_MUST_COMPLETE;

        //
        // Increment the number of must complete packets.
        //

        IoPendingMustCompletePackets++;
    }
}

NTSTATUS
IoQueryFileInformation(
    IN PFILE_OBJECT FileObject,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FileInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FileInformationClass,
                                   Length,
                                   FileInformation,
                                   ReturnedLength,
                                   TRUE );
}

NTSTATUS
IoQueryVolumeInformation(
    IN PFILE_OBJECT FileObject,
    IN FS_INFORMATION_CLASS FsInformationClass,
    IN ULONG Length,
    OUT PVOID FsInformation,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine returns the requested information about a specified volume.
    The information returned is determined by the FsInformationClass that
    is specified, and it is placed into the caller's FsInformation buffer.

Arguments:

    FileObject - Supplies a pointer to the file object about which the requested
        information is returned.

    FsInformationClass - Specifies the type of information which should be
        returned about the volume.

    Length - Supplies the length of the FsInformation buffer in bytes.

    FsInformation - Supplies a buffer to receive the requested information
        returned about the file.  This buffer must not be pageable and must
        reside in system space.

    ReturnedLength - Supplies a variable that is to receive the length of the
        information written to the FsInformation buffer.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PAGED_CODE();

    //
    // Simply invoke the common routine to perform the query operation.
    //

    return IopQueryXxxInformation( FileObject,
                                   FsInformationClass,
                                   Length,
                                   FsInformation,
                                   ReturnedLength,
                                   FALSE );
}

VOID
IoQueueThreadIrp(
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine queues the specified I/O Request Packet (IRP) to the current
    thread's IRP pending queue.  This queue locates all of the outstanding
    I/O requests for the thread.

Arguments:

    Irp - Pointer to the I/O Request Packet (IRP) to be queued.

Return Value:

    None.

--*/

{
    //
    // Simply queue the packet using the internal queueing routine.
    //

    IopQueueThreadIrp( Irp );
}

VOID
IoRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    FileObject - Pointer to the file object of the current access being closed.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        //
        // For each access type, decrement the appropriate count in the Share
        // Access structure.
        //

        if (FileObject->ReadAccess) {
            ShareAccess->Readers--;
        }

        if (FileObject->WriteAccess) {
            ShareAccess->Writers--;
        }

        if (FileObject->DeleteAccess) {
            ShareAccess->Deleters--;
        }

        //
        // For each shared access type, decrement the appropriate count in the
        // Share Access structure.
        //

        if (FileObject->SharedRead) {
            ShareAccess->SharedRead--;
        }

        if (FileObject->SharedWrite) {
            ShareAccess->SharedWrite--;
        }

        if (FileObject->SharedDelete) {
            ShareAccess->SharedDelete--;
        }
    }
}

VOID
IoSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess
    )

/*++

Routine Description:

    This routine is invoked to set the access and share access information
    in a file system Share Access structure for the first open.

Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    FileObject - Pointer to the file object of the current open request.

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    //

    FileObject->ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE
        | FILE_READ_DATA)) != 0);
    FileObject->WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA
        | FILE_APPEND_DATA)) != 0);
    FileObject->DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);

    //
    // Check to see whether the current file opener would like to read,
    // write, or delete the file.  If so, account for it in the share access
    // structure; otherwise, skip it.
    //

    if (FileObject->ReadAccess ||
        FileObject->WriteAccess ||
        FileObject->DeleteAccess) {

        //
        // Only update the share modes if the user wants to read, write or
        // delete the file.
        //

        FileObject->SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);
        FileObject->SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);
        FileObject->SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);

        //
        // Set the Share Access structure open count.
        //

        ShareAccess->OpenCount = 1;

        //
        // Set the number of readers, writers, and deleters in the Share Access
        // structure.
        //

        ShareAccess->Readers = FileObject->ReadAccess;
        ShareAccess->Writers = FileObject->WriteAccess;
        ShareAccess->Deleters = FileObject->DeleteAccess;

        //
        // Set the number of shared readers, writers, and deleters in the Share
        // Access structure.
        //

        ShareAccess->SharedRead = FileObject->SharedRead;
        ShareAccess->SharedWrite = FileObject->SharedWrite;
        ShareAccess->SharedDelete = FileObject->SharedDelete;

    } else {

        //
        // No read, write, or delete access has been requested.  Simply zero
        // the appropriate fields in the structure so that the next accessor
        // sees a consistent state.
        //

        ShareAccess->OpenCount = 0;
        ShareAccess->Readers = 0;
        ShareAccess->Writers = 0;
        ShareAccess->Deleters = 0;
        ShareAccess->SharedRead = 0;
        ShareAccess->SharedWrite = 0;
        ShareAccess->SharedDelete = 0;
    }
}

VOID
IopStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.  If the Cancelable paramter is TRUE, then the update of
    current IRP is synchronized using the cancel spinlock.

Arguments:

    DeviceObject - Pointer to device object itself.

    Cancelable - Indicates that IRPs in the device queue may be cancelable.

Return Value:

    None.

--*/

{
    PIRP irp;
    PKDEVICE_QUEUE_ENTRY packet;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Remove the next packet from the head of the queue.  If a packet was
    // found, then process it.
    //

    packet = KeRemoveDeviceQueue( &DeviceObject->DeviceQueue );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was located so make it the current packet for this
        // device.
        //

        DeviceObject->CurrentIrp = irp;

        //
        // Mark the device object as busy so that nested calls to
        // IoStartNextPacket(ByKey) cause the requested to be deferred until
        // we're out of this StartIo call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_BUSY;

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

        //
        // The device object's start I/O routine is no longer busy.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_BUSY;
    }
}

VOID
IopStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    PIRP                 irp;
    PKDEVICE_QUEUE_ENTRY packet;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Clear the current IRP field before starting another request.
    //

    DeviceObject->CurrentIrp = (PIRP) NULL;

    //
    // Attempt to remove the indicated packet according to the key from the
    // device queue.  If one is found, then process it.
    //

    packet = KeRemoveByKeyDeviceQueue( &DeviceObject->DeviceQueue, Key );

    if (packet) {
        irp = CONTAINING_RECORD( packet, IRP, Tail.Overlay.DeviceQueueEntry );

        //
        // A packet was successfully located.  Make it the current packet
        // and invoke the driver's start I/O routine for it.
        //

        DeviceObject->CurrentIrp = irp;

        //
        // Mark the device object as busy so that nested calls to
        // IoStartNextPacket(ByKey) cause the requested to be deferred until
        // we're out of this StartIo call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_BUSY;

        //
        // Invoke the driver's start I/O routine for this packet.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, irp );

        //
        // The device object's start I/O routine is no longer busy.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_BUSY;
    }
}

VOID
IopStartNextPacketDeferred(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.

    This routine is invoked for deferred requests.  Deferred StartIo requests
    are used to prevent stack overflows that can occur when a StartIo routine
    calls IoStartNextPacket(ByKey) which recursively calls the StartIo routine.
    The nested IoStartNextPacket(ByKey) call is deferred until the topmost
    IoStartPacket or IoStartNextPacket(ByKey) is finished.

Arguments:

    DeviceObject - Pointer to device object itself.

Return Value:

    None.

--*/

{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_BUSY));
    ASSERT(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED);

    do {

        //
        // Clear the request for a deferred StartIo call.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_REQUESTED;

        //
        // Make the deferred StartIo call.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED_BYKEY) {
            IopStartNextPacketByKey(DeviceObject, DeviceObject->StartIoKey);
        } else {
            IopStartNextPacket(DeviceObject);
        }

    } while (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED);
}

VOID
IoStartNextPacket(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue and invoke the device driver's start I/O
    routine for it.

Arguments:

    DeviceObject - Pointer to device object itself.

Return Value:

    None.

--*/

{
    //
    // Check if we're nested inside a IoStartPacket or IoStartNextPacket(ByKey)
    // call.
    //

    if (!(DeviceObject->StartIoFlags & DO_STARTIO_BUSY)) {

        //
        // Any requests for a StartIo call should have already been handled in
        // the exit path for IoStartPacket and IoStartNextPacket(ByKey).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // We're not nested.  Start the next packet now.
        //

        IopStartNextPacket(DeviceObject);

        //
        // If IoStartNextPacket(ByKey) was called while we were in the above
        // call, then process the deferred StartIo request.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED) {
            IopStartNextPacketDeferred(DeviceObject);
        }

    } else {

        //
        // A device can only call IoStartNextPacket(ByKey) once per StartIo
        // call (there can only be one current IRP).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // Set up the StartIo flags for a deferred call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_REQUESTED;
        DeviceObject->StartIoFlags &= ~DO_STARTIO_REQUESTED_BYKEY;
    }
}

VOID
IoStartNextPacketByKey(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG Key
    )

/*++

Routine Description:

    This routine is invoked to dequeue the next packet (IRP) from the
    specified device work queue by key and invoke the device driver's start
    I/O routine for it.

Arguments:

    DeviceObject - Pointer to device object itself.

    Key - Specifics the Key used to remove the entry from the queue.

Return Value:

    None.

--*/

{
    //
    // Check if we're nested inside a IoStartPacket or IoStartNextPacket(ByKey)
    // call.
    //

    if (!(DeviceObject->StartIoFlags & DO_STARTIO_BUSY)) {

        //
        // Any requests for a StartIo call should have already been handled in
        // the exit path for IoStartPacket and IoStartNextPacket(ByKey).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // We're not nested.  Start the next packet now.
        //

        IopStartNextPacketByKey(DeviceObject, Key);

        //
        // If IoStartNextPacket(ByKey) was called while we were in the above
        // call, then process the deferred StartIo request.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED) {
            IopStartNextPacketDeferred(DeviceObject);
        }

    } else {

        //
        // A device can only call IoStartNextPacket(ByKey) once per StartIo
        // call (there can only be one current IRP).
        //

        ASSERT(!(DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED));

        //
        // Set up the StartIo flags for a deferred call.
        //

        DeviceObject->StartIoFlags |= (DO_STARTIO_REQUESTED |
            DO_STARTIO_REQUESTED_BYKEY);

        DeviceObject->StartIoKey = Key;
    }
}

VOID
IoStartPacket(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PULONG Key OPTIONAL
    )

/*++

Routine Description:

    This routine attempts to start the specified packet request (IRP) on the
    specified device.  If the device is already busy, then the packet is
    simply queued to the device queue.

Arguments:

    DeviceObject - Pointer to device object itself.

    Irp - I/O Request Packet which should be started on the device.

    Key - Key to be used in inserting packet into device queue;  optional
        (if not specified, then packet is inserted at the tail).

Return Value:

    None.

--*/

{
    KIRQL oldIrql;
    BOOLEAN i;

    //
    // Raise the IRQL of the processor to dispatch level for synchronization.
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    // If a key parameter was specified, then insert the request into the
    // work queue according to the key;  otherwise, simply insert it at the
    // tail.
    //

    if (Key) {
        i = KeInsertByKeyDeviceQueue( &DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry,
                                      *Key );
    } else {
        i = KeInsertDeviceQueue( &DeviceObject->DeviceQueue,
                                 &Irp->Tail.Overlay.DeviceQueueEntry );
    }

    //
    // If the packet was not inserted into the queue, then this request is
    // now the current packet for this device.  Indicate so by storing its
    // address in the current IRP field, and begin processing the request.
    //

    if (!i) {

        DeviceObject->CurrentIrp = Irp;

        //
        // Mark the device object as busy so that nested calls to
        // IoStartNextPacket(Ex) cause the requested to be deferred until we're
        // out of this StartIo call.
        //

        DeviceObject->StartIoFlags |= DO_STARTIO_BUSY;

        //
        // Invoke the driver's start I/O routine to get the request going on the device.
        //

        DeviceObject->DriverObject->DriverStartIo( DeviceObject, Irp );

        //
        // The device object's start I/O routine is no longer busy.
        //

        DeviceObject->StartIoFlags &= ~DO_STARTIO_BUSY;

        //
        // If IoStartNextPacket(ByKey) was called while we were in the above
        // call, then process the deferred StartIo request.
        //

        if (DeviceObject->StartIoFlags & DO_STARTIO_REQUESTED) {
            IopStartNextPacketDeferred(DeviceObject);
        }
    }

    //
    // Restore the IRQL back to its value upon entry to this function before
    // returning to the caller.
    //

    KeLowerIrql( oldIrql );
}

NTSTATUS
IoSynchronousDeviceIoControlRequest(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    OUT PULONG ReturnedOutputBufferLength OPTIONAL,
    IN BOOLEAN InternalDeviceIoControl
    )
/*++

Routine Description:

    This routine builds an IRP for a device I/O control function and sends it
    to the supplied device object.

Arguments:

    IoControlCode - Specifies the device I/O control code that is to be
        performed by the target device driver.

    DeviceObject - Specifies the target device on which the I/O control
        function is to be performed.

    InputBuffer - Optional pointer to an input buffer that is to be passed
        to the device driver.

    InputBufferLength - Length of the InputBuffer in bytes.  If the Input-
        Buffer parameter is not passed, this parameter must be zero.

    OutputBuffer - Optional pointer to an output buffer that is to be passed
        to the device driver.

    OutputBufferLength - Length of the OutputBuffer in bytes.  If the
        OutputBuffer parameter is not passed, this parameter must be zero.

    InternalDeviceIoControl - A BOOLEAN parameter that specifies whether
        the packet that gets generated should have a major function code
        of IRP_MJ_INTERNAL_DEVICE_CONTROL (the parameter is TRUE), or
        IRP_MJ_DEVICE_CONTROL (the parameter is FALSE).

Return Value:

    The function value is the final status of the operation.

--*/
{
    NTSTATUS status;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP Irp;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(IoControlCode, DeviceObject, InputBuffer,
        InputBufferLength, OutputBuffer, OutputBufferLength,
        InternalDeviceIoControl, &Event, &IoStatusBlock);

    if (Irp != NULL) {

        status = IoCallDriver(DeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            status = IoStatusBlock.Status;
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (ReturnedOutputBufferLength != NULL) {
        *ReturnedOutputBufferLength = IoStatusBlock.Information;
    }

    return status;
}

NTSTATUS
IoSynchronousFsdRequest(
    IN ULONG MajorFunction,
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN PLARGE_INTEGER StartingOffset OPTIONAL
    )
/*++

Routine Description:

    This routine builds an I/O Request Packet (IRP) suitable for a File System
    Driver (FSD) to use in requesting an I/O operation from a device driver
    and sends it to the supplied device object.

    The request must be one of the following request codes:

        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_FLUSH_BUFFERS
        IRP_MJ_SHUTDOWN

Arguments:

    MajorFunction - Function to be performed;  see previous list.

    DeviceObject - Pointer to device object on which the I/O will be performed.

    Buffer - Pointer to buffer to get data from or write data into.  This
        parameter is required for read/write, but not for flush or shutdown
        functions.

    Length - Length of buffer in bytes.  This parameter is required for
        read/write, but not for flush or shutdown functions.

    StartingOffset - Pointer to the offset on the disk to read/write from/to.
        This parameter is required for read/write, but not for flush or
        shutdown functions.

    OverrideVerifyVolume - A BOOLEAN parmeter that specifies whether the packet
        that gets generated should have the SL_OVERRIDE_VERIFY_VOLUME flag set.

Return Value:

    The function value is the final status of the operation.

--*/
{
    NTSTATUS status;
    KEVENT Event;
    IO_STATUS_BLOCK IoStatusBlock;
    PIRP Irp;

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    Irp = IoBuildSynchronousFsdRequest(MajorFunction, DeviceObject, Buffer,
        Length, StartingOffset, &Event, &IoStatusBlock);

    if (Irp != NULL) {

        status = IoCallDriver(DeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
            status = IoStatusBlock.Status;
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\iop.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    iop.h

Abstract:

    This module contains the private structure definitions and APIs used by
    the NT I/O system.

--*/

#ifndef _IOP_
#define _IOP_

#ifndef FAR
#define FAR
#endif

#include "ntos.h"

//
// Define the global data for the I/O system.
//

extern GENERIC_MAPPING IopFileMapping;

//
// Define a dummy file object for use on stack for fast open operations.
//

typedef struct _DUMMY_FILE_OBJECT {
    OBJECT_HEADER ObjectHeader;
    CHAR FileObjectBody[ sizeof( FILE_OBJECT ) ];
} DUMMY_FILE_OBJECT, *PDUMMY_FILE_OBJECT;

//
// Define the structures private to the I/O system.
//

#define OPEN_PACKET_PATTERN  0xbeaa0251

//
// Define an Open Packet (OP).  An OP is used to communicate information
// between the NtCreateFile service executing in the context of the caller
// and the device object parse routine.  It is the parse routine who actually
// creates the file object for the file.
//

typedef struct _OPEN_PACKET {
    CSHORT Type;
    CSHORT Size;
    PFILE_OBJECT FileObject;
    NTSTATUS FinalStatus;
    ULONG_PTR Information;
    ULONG ParseCheck;
    PFILE_OBJECT RelatedFileObject;

    //
    // The following are the open-specific parameters.  Notice that the desired
    // access field is passed through to the parse routine via the object
    // management architecture, so it does not need to be repeated here.  Also
    // note that the same is true for the file name.
    //

    LARGE_INTEGER AllocationSize;
    ULONG CreateOptions;
    USHORT FileAttributes;
    USHORT ShareAccess;
    ULONG Options;
    ULONG Disposition;
    ULONG DesiredAccess;

    //
    // The following is used when performing a fast network query during open
    // to get back the network file attributes for a file.
    //

    PFILE_NETWORK_OPEN_INFORMATION NetworkInformation;

    //
    // The following pointer is used when a fast open operation for a fast
    // delete or fast query attributes call is being made rather than a
    // general file open.  The dummy file object is actually stored on the
    // the caller's stack rather than allocated pool to speed things up.
    //

    PDUMMY_FILE_OBJECT LocalFileObject;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of querying its attributes.  This causes a considerable
    // number of shortcuts to be taken in the parse, query, and close paths.
    //

    BOOLEAN QueryOnly;

    //
    // The following is used to indicate that a file is being opened for the
    // sole purpose of deleting it.  This causes a considerable number of
    // shortcurs to be taken in the parse and close paths.
    //

    BOOLEAN DeleteOnly;

} OPEN_PACKET, *POPEN_PACKET;

//
// Define I/O completion packet types.
//

typedef enum _COMPLETION_PACKET_TYPE {
    IopCompletionPacketIrp,
    IopCompletionPacketMini
} COMPLETION_PACKET_TYPE, *PCOMPLETION_PACKET_TYPE;

//
// Define the type for completion packets inserted onto completion ports when
// there is no full I/O request packet that was used to perform the I/O
// operation.  This occurs when the fast I/O path is used, and when the user
// directly inserts a completion message.
//
typedef struct _IOP_MINI_COMPLETION_PACKET {

    //
    // The following unnamed structure must be exactly identical
    // to the unnamed structure used in the IRP overlay section used
    // for completion queue entries.
    //

    struct {

        //
        // List entry - used to queue the packet to completion queue, among
        // others.
        //

        LIST_ENTRY ListEntry;

        union {

            //
            // Current stack location - contains a pointer to the current
            // IO_STACK_LOCATION structure in the IRP stack.  This field
            // should never be directly accessed by drivers.  They should
            // use the standard functions.
            //

            struct _IO_STACK_LOCATION *CurrentStackLocation;

            //
            // Minipacket type.
            //

            ULONG PacketType;
        };
    };

    PVOID KeyContext;
    PVOID ApcContext;
    NTSTATUS IoStatus;
    ULONG_PTR IoStatusInformation;
} IOP_MINI_COMPLETION_PACKET, *PIOP_MINI_COMPLETION_PACKET;

extern const UCHAR IopQueryOperationLength[];
extern const UCHAR IopSetOperationLength[];
extern const ULONG IopQueryOperationAccess[];
extern const ULONG IopSetOperationAccess[];
extern const UCHAR IopQueryFsOperationLength[];
extern const ULONG IopQueryFsOperationAccess[];

#define IopAcquireCompletionLock()          KeRaiseIrqlToDpcLevel()
#define IopReleaseCompletionLock(OldIrql)   KeLowerIrql(OldIrql)

//
// Define routines private to the I/O system.
//

VOID
FASTCALL
IopAcquireFileObjectLock(
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopAllocateIrpCleanup(
    IN PFILE_OBJECT FileObject,
    IN PKEVENT EventObject OPTIONAL
    );

PIRP
IopAllocateIrpMustSucceed(
    IN CCHAR StackSize
    );

VOID
IopCloseFile(
    IN PVOID Object,
    IN ULONG SystemHandleCount
    );

VOID
IopCompleteUnloadOrDelete(
    IN PDEVICE_OBJECT DeviceObject,
    IN KIRQL Irql
    );

VOID
IopCompleteRequest(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

VOID
IopDecrementDeviceObjectRef(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IopDeleteFile(
    IN PVOID Object
    );

VOID
IopDeleteIoCompletion(
    IN PVOID Object
    );

//+
//
// VOID
// IopDequeueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine dequeues the specified I/O Request Packet (IRP) from the
//     thread IRP queue which it is currently queued.
//
//     In checked we set Flink == Blink so we can assert free's of queue'd IRPs
//
// Arguments:
//
//     Irp - Specifies the IRP that is dequeued.
//
// Return Value:
//
//     None.
//
//-

#define IopDequeueThreadIrp( Irp ) \
   { \
   RemoveEntryList( &Irp->ThreadListEntry ); \
   InitializeListHead( &Irp->ThreadListEntry ) ; \
   }


#ifdef  _WIN64
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT((ULONG_PTR)(ApcRoutine) & ~1)
#else
#define IopApcRoutinePresent(ApcRoutine)    ARGUMENT_PRESENT((ULONG_PTR)(ApcRoutine))
#endif

#define IopApcRoutineMode(ApcRoutine) \
    ((KPROCESSOR_MODE)((ApcRoutine == NtUserIoApcDispatcher) ? UserMode : KernelMode))

VOID
IopDisassociateThreadIrp(
    VOID
    );

VOID
IopDropIrp(
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

VOID
IopExceptionCleanup(
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PKEVENT EventObject OPTIONAL
    );

NTSTATUS
IopGetFileName(
    IN PFILE_OBJECT FileObject,
    IN ULONG Length,
    OUT PVOID FileInformation,
    OUT PULONG ReturnedLength
    );

//++
//
// VOID
// IopInitializeIrp(
//     IN OUT PIRP Irp,
//     IN USHORT PacketSize,
//     IN CCHAR StackSize
//     )
//
// Routine Description:
//
//     Initializes an IRP.
//
// Arguments:
//
//     Irp - a pointer to the IRP to initialize.
//
//     PacketSize - length, in bytes, of the IRP.
//
//     StackSize - Number of stack locations in the IRP.
//
// Return Value:
//
//     None.
//
//--

#define IopInitializeIrp( Irp, PacketSize, StackSize ) {          \
    RtlZeroMemory( (Irp), (PacketSize) );                         \
    (Irp)->Type = (CSHORT) IO_TYPE_IRP;                           \
    (Irp)->Size = (USHORT) ((PacketSize));                        \
    (Irp)->StackCount = (CCHAR) ((StackSize));                    \
    (Irp)->CurrentLocation = (CCHAR) ((StackSize) + 1);           \
    InitializeListHead (&(Irp)->ThreadListEntry);                 \
    (Irp)->Tail.Overlay.CurrentStackLocation =                    \
        ((PIO_STACK_LOCATION) ((UCHAR *) (Irp) +                  \
            sizeof( IRP ) +                                       \
            ( (StackSize) * sizeof( IO_STACK_LOCATION )))); }

NTSTATUS
IopOpenRenameTarget(
    OUT PHANDLE TargetHandle,
    IN PIRP Irp,
    IN PFILE_RENAME_INFORMATION RenameBuffer,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopParseFile(
    IN PVOID ParseObject,
    IN POBJECT_TYPE ObjectType,
    IN ULONG Attributes,
    IN OUT POBJECT_STRING CompleteName,
    IN OUT POBJECT_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    OUT PVOID *Object
    );

NTSTATUS
IopQueryName(
    IN PVOID Object,
    IN BOOLEAN HasObjectName,
    OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
    IN ULONG Length,
    OUT PULONG ReturnLength
    );

NTSTATUS
IopQueryXxxInformation(
    IN PFILE_OBJECT FileObject,
    IN ULONG InformationClass,
    IN ULONG Length,
    OUT PVOID Information,
    OUT PULONG ReturnedLength,
    IN BOOLEAN FileInformation
    );

//+
// VOID
// IopQueueThreadIrp(
//     IN PIRP Irp
//     )
//
// Routine Description:
//
//     This routine queues the specified I/O Request Packet (IRP) to the thread
//     whose TCB address is stored in the packet.
//
// Arguments:
//
//     Irp - Supplies the IRP to be queued for the specified thread.
//
// Return Value:
//
//     None.
//
//-

#define IopQueueThreadIrp( Irp ) {                      \
    KIRQL irql;                                         \
    KeRaiseIrql( APC_LEVEL, &irql );                    \
    InsertHeadList( &Irp->Tail.Overlay.Thread->IrpList, \
                    &Irp->ThreadListEntry );            \
    KeLowerIrql( irql );                                \
    }

BOOLEAN
FASTCALL
IopReleaseFileObjectLock(
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
IopSynchronousApiServiceTail(
    IN NTSTATUS ReturnedStatus,
    IN PKEVENT Event,
    IN PIRP Irp,
    IN PIO_STATUS_BLOCK LocalIoStatus,
    OUT PIO_STATUS_BLOCK IoStatusBlock
    );

NTSTATUS
IopSynchronousServiceTail(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN DeferredIoCompletion,
    IN BOOLEAN SynchronousIo
    );

VOID
IopUserCompletion(
    IN PKAPC Apc,
    IN PKNORMAL_ROUTINE *NormalRoutine,
    IN PVOID *NormalContext,
    IN PVOID *SystemArgument1,
    IN PVOID *SystemArgument2
    );

NTSTATUS
IopXxxControlFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN DeviceIoControl
    );

#endif // _IOP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\qsinfo.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    qsinfo.c

Abstract:

    This module contains the code to implement the NtQueryInformationFile and
    NtSetInformationFile system services for the NT I/O system.

--*/

#include "iop.h"

//
// Create local definitions for long flag names to make code slightly more
// readable.
//

#define FSIO_A  FILE_SYNCHRONOUS_IO_ALERT
#define FSIO_NA FILE_SYNCHRONOUS_IO_NONALERT

ULONG
IopGetModeInformation(
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This encapsulates extracting and translating the mode bits from
    the passed file object, to be returned from a query information call.

Arguments:

    FileObject - Specifies the file object for which to return Mode info.

Return Value:

    The translated mode information is returned.

--*/

{
    ULONG mode = 0;

    if (FileObject->Flags & FO_SEQUENTIAL_ONLY) {
        mode |= FILE_SEQUENTIAL_ONLY;
    }
    if (FileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        mode |= FILE_NO_INTERMEDIATE_BUFFERING;
    }
    if (FileObject->Flags & FO_SYNCHRONOUS_IO) {
        if (FileObject->Flags & FO_ALERTABLE_IO) {
            mode |= FILE_SYNCHRONOUS_IO_ALERT;
        } else {
            mode |= FILE_SYNCHRONOUS_IO_NONALERT;
        }
    }
    return mode;
}

NTSTATUS
NtQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file about which the requested
        information should be returned.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    BOOLEAN synchronousIo;
    BOOLEAN skipDriver;

    PAGED_CODE();

    //
    // The caller's mode is kernel.  Ensure that at least the information
    // class and lengths are appropriate.
    //

    if ((ULONG) FileInformationClass >= FileMaximumInformation ||
        !IopQueryOperationLength[FileInformationClass]) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (Length < (ULONG) IopQueryOperationLength[FileInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );

    if (!NT_SUCCESS( status )) {
        return status;
    }

    if ((IopQueryOperationAccess[FileInformationClass] & FILE_READ_DATA) &&
        !fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to query the file position pointer.  If so, then
        // return it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested the current file position context
            // information.  This is a relatively frequent call, so it is
            // optimized here to cut through the normal IRP path.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;

            //
            // Return the current position information.
            //

            fileInformation->CurrentByteOffset = fileObject->CurrentByteOffset;

            //
            // Write the I/O status block.
            //

            IoStatusBlock->Status = STATUS_SUCCESS;
            IoStatusBlock->Information = sizeof( FILE_POSITION_INFORMATION );

            //
            // Note that the state of the event in the file object has not yet
            // been reset, so it need not be set either.  Therefore, simply
            // cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = FileInformation;
    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // is device independent.  If this is the case, then the request can
    // be satisfied here without having to have all of the drivers implement
    // the same code.  Note that having the IRP is still necessary since
    // the I/O completion code requires it.
    //

    skipDriver = FALSE;

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Return the mode information for this file.
        //

        modeBuffer->Mode = IopGetModeInformation( fileObject );

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_MODE_INFORMATION );
        skipDriver = TRUE;

    } else if (FileInformationClass == FileAlignmentInformation) {

        PFILE_ALIGNMENT_INFORMATION alignmentInformation = FileInformation;

        //
        // Return the alignment information for this file.
        //

        alignmentInformation->AlignmentRequirement = deviceObject->AlignmentRequirement;

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Information = sizeof( FILE_ALIGNMENT_INFORMATION );
        skipDriver = TRUE;
    }

    if (skipDriver) {

        //
        // The requested operation has already been performed.  Simply
        // set the final status in the packet and the return state.
        //

        status = STATUS_SUCCESS;
        irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        //
        // This is not a request that can be [completely] performed here, so
        // invoke the driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            KeWaitForSingleObject( &fileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            KeWaitForSingleObject( &localEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = localIoStatus.Status;

            *IoStatusBlock = localIoStatus;
        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    return status;
}

NTSTATUS
NtSetInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    )

/*++

Routine Description:

    This service changes the provided information about a specified file.  The
    information that is changed is determined by the FileInformationClass that
    is specified.  The new information is taken from the FileInformation buffer.

Arguments:

    FileHandle - Supplies a handle to the file whose information should be
        changed.

    IoStatusBlock - Address of the caller's I/O status block.

    FileInformation - Supplies a buffer containing the information which should
        be changed on the file.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        changed about the file.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    KEVENT localEvent;
    IO_STATUS_BLOCK localIoStatus;
    HANDLE targetHandle = (HANDLE) NULL;
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // The caller's mode is kernel.  Ensure that at least the information
    // class and lengths are appropriate.
    //

    if ((ULONG) FileInformationClass >= FileMaximumInformation ||
        FileInformationClass == FileTrackingInformation ||
        !IopSetOperationLength[FileInformationClass]) {
        return STATUS_INVALID_INFO_CLASS;
    }

    if (Length < (ULONG) IopSetOperationLength[FileInformationClass]) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // Negative file offsets are illegal.
    //

    ASSERT((FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION, EndOfFile) |
            FIELD_OFFSET(FILE_ALLOCATION_INFORMATION, AllocationSize) |
            FIELD_OFFSET(FILE_POSITION_INFORMATION, CurrentByteOffset)) == 0);

    if (((FileInformationClass == FileEndOfFileInformation) ||
         (FileInformationClass == FileAllocationInformation) ||
         (FileInformationClass == FilePositionInformation)) &&
        (((PFILE_POSITION_INFORMATION)FileInformation)->CurrentByteOffset.HighPart < 0)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // There were no blatant errors so far, so reference the file object so
    // the target device object can be found.  Note that if the handle does
    // not refer to a file object, or if the caller does not have the required
    // access to the file, then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if ((IopSetOperationAccess[FileInformationClass] & FILE_WRITE_DATA) &&
        !fileObject->WriteAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If this is not a (serialized) synchronous I/O
    // operation, then allocate and initialize the local event.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        //
        // Make a special check here to determine whether or not the caller
        // is attempting to set the file position pointer information.  If so,
        // then set it immediately and get out.
        //

        if (FileInformationClass == FilePositionInformation) {

            //
            // The caller has requested setting the current file position
            // context information.  This is a relatively frequent call, so
            // it is optimized here to cut through the normal IRP path.
            //
            // Begin by checking to see whether the file was opened with no
            // intermediate buffering.  If so, then the file pointer must be
            // set in a manner consistent with the alignment requirement of
            // read and write operations to a non-buffered file.
            //

            PFILE_POSITION_INFORMATION fileInformation = FileInformation;
            LARGE_INTEGER currentByteOffset;

            //
            // Attempt to read the position information from the buffer.
            //

            currentByteOffset.QuadPart = fileInformation->CurrentByteOffset.QuadPart;

            if ((fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING &&
                 (deviceObject->SectorSize &&
                 (currentByteOffset.LowPart &
                 (deviceObject->SectorSize - 1)))) ||
                 currentByteOffset.HighPart < 0) {

                    status = STATUS_INVALID_PARAMETER;

            } else {

                //
                // Set the current file position information.
                //

                fileObject->CurrentByteOffset.QuadPart = currentByteOffset.QuadPart;

                //
                // Write the I/O status block.
                //

                IoStatusBlock->Status = STATUS_SUCCESS;
                IoStatusBlock->Information = 0;
            }

            //
            // Note that the file object's event has not yet been reset,
            // so it is not necessary to set it to the Signaled state, since
            // that is it's state at this point by definition.  Therefore,
            // simply cleanup and return.
            //

            IopReleaseFileObjectLock( fileObject );
            ObDereferenceObject( fileObject );
            return status;
        }
        synchronousIo = TRUE;
    } else {

        //
        // This is a synchronous API being invoked for a file that is opened
        // for asynchronous I/O.  This means that this system service is
        // to synchronize the completion of the operation before returning
        // to the caller.  A local event is used to do this.
        //

        KeInitializeEvent( &localEvent, SynchronizationEvent, FALSE );
        synchronousIo = FALSE;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    // The allocation is performed with an exception handler in case the
    // caller does not have enough quota to allocate the packet.

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, (PKEVENT) NULL );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = FileInformation;
    if (synchronousIo) {
        irp->UserIosb = IoStatusBlock;
    } else {
        irp->UserEvent = &localEvent;
        irp->UserIosb = &localIoStatus;
        irp->Flags = IRP_SYNCHRONOUS_API;
    }
    irp->Flags |= IRP_DEFER_IO_COMPLETION;

    //
    // Get a pointer to the stack location for the first driver.  This will
    // be used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_SET_INFORMATION;
    irpSp->FileObject = fileObject;

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.SetFile.Length = Length;
    irpSp->Parameters.SetFile.FileInformationClass = FileInformationClass;

    //
    // Insert the packet at the head of the IRP list for the thread.
    //

    IopQueueThreadIrp( irp );

    //
    // Everything is now set to invoke the device driver with this request.
    // However, it is possible that the information that the caller wants
    // to set is device independent.  If this is the case, then the request
    // can be satisfied here without having to have all of the drivers
    // implement the same code.  Note that having the IRP is still necessary
    // since the I/O completion code requires it.
    //

    if (FileInformationClass == FileModeInformation) {

        PFILE_MODE_INFORMATION modeBuffer = FileInformation;

        //
        // Set the various flags in the mode field for the file object, if
        // they are reasonable.  There are 4 different invalid combinations
        // that the caller may not specify:
        //
        //     1)  An invalid flag was set in the mode field.  Not all Create/
        //         Open options may be changed.
        //
        //     2)  The caller set one of the synchronous I/O flags (alert or
        //         nonalert), but the file is not opened for synchronous I/O.
        //
        //     3)  The file is opened for synchronous I/O but the caller did
        //         not set either of the synchronous I/O flags (alert or non-
        //         alert).
        //
        //     4)  The caller set both of the synchronous I/O flags (alert and
        //         nonalert).
        //

        if ((modeBuffer->Mode & ~FILE_VALID_SET_FLAGS) ||
            ((modeBuffer->Mode & (FSIO_A | FSIO_NA)) && (!(fileObject->Flags & FO_SYNCHRONOUS_IO))) ||
            ((!(modeBuffer->Mode & (FSIO_A | FSIO_NA))) && (fileObject->Flags & FO_SYNCHRONOUS_IO)) ||
            (((modeBuffer->Mode & FSIO_A) && (modeBuffer->Mode & FSIO_NA) ))) {
            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Set or clear the appropriate flags in the file object.
            //

            if (modeBuffer->Mode & FILE_SEQUENTIAL_ONLY) {
                fileObject->Flags |= FO_SEQUENTIAL_ONLY;
            } else {
                fileObject->Flags &= ~FO_SEQUENTIAL_ONLY;
            }

            if (fileObject->Flags & FO_SYNCHRONOUS_IO) {
                if (modeBuffer->Mode & FSIO_A) {
                    fileObject->Flags |= FO_ALERTABLE_IO;
                } else {
                    fileObject->Flags &= ~FO_ALERTABLE_IO;
                }
            }

            status = STATUS_SUCCESS;
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0L;

    } else if (FileInformationClass == FileRenameInformation) {

        PFILE_RENAME_INFORMATION renameBuffer = FileInformation;

        //
        // Check to see whether or not a fully qualified pathname was
        // supplied.  If so, then more processing is required.
        //

        if ((renameBuffer->FileName.Length > 0 &&
            renameBuffer->FileName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) ||
            renameBuffer->RootDirectory != NULL) {

            //
            // A fully qualified file name was specified as the target of
            // the rename operation.  Attempt to open the target file and
            // ensure that the replacement policy for the file is consistent
            // with the caller's request, and ensure that the file is on the
            // same volume.
            //

            status = IopOpenRenameTarget( &targetHandle,
                                          irp,
                                          renameBuffer,
                                          fileObject );
            if (!NT_SUCCESS( status )) {
                irp->IoStatus.Status = status;

            } else {

                //
                // The fully qualified file name specifies a file on the
                // same volume and if it exists, then the caller specified
                // that it should be replaced.
                //

                status = IoCallDriver( deviceObject, irp );
            }

        } else {

            //
            // This is a simple rename operation, so call the driver and
            // let it perform the rename operation within the same directory
            // as the source file.
            //

            status = IoCallDriver( deviceObject, irp );
        }

    } else if (FileInformationClass == FileCompletionInformation) {

        PFILE_COMPLETION_INFORMATION completion = FileInformation;
        PIO_COMPLETION_CONTEXT context;
        PVOID portObject;

        //
        // It is an error if this file object already has an LPC port associated
        // with it.
        //

        if (fileObject->CompletionContext || fileObject->Flags & FO_SYNCHRONOUS_IO) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            //
            // Attempt to reference the port object by its handle and convert it
            // into a pointer to the port object itself.
            //

            status = ObReferenceObjectByHandle( completion->Port,
                                                &IoCompletionObjectType,
                                                (PVOID *) &portObject );
            if (NT_SUCCESS( status )) {

                //
                // Allocate the memory to be associated w/this file object
                //

                context = ExAllocatePoolWithTag( sizeof( IO_COMPLETION_CONTEXT ),
                                                 'cCoI' );
                if (!context) {

                    ObDereferenceObject( portObject );
                    status = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Everything was successful.  Capture the completion port
                    // and the key.
                    //

                    context->Port = portObject;
                    context->Key = completion->Key;

                    if (!InterlockedCompareExchangePointer( &fileObject->CompletionContext, context, NULL )) {

                        status = STATUS_SUCCESS;

                    } else {

                        //
                        // Someone set the completion context after the check.
                        // Simply drop everything on the floor and return an
                        // error.
                        //

                        ExFreePool( context );
                        ObDereferenceObject( portObject );
                        status = STATUS_INVALID_PARAMETER;
                    }
                }
            }
        }

        //
        // Complete the I/O operation.
        //

        irp->IoStatus.Status = status;
        irp->IoStatus.Information = 0;

    } else {

        //
        // This is not a request that can be performed here, so invoke the
        // driver at its appropriate dispatch entry with the IRP.
        //

        status = IoCallDriver( deviceObject, irp );
    }

    //
    // If this operation was a synchronous I/O operation, check the return
    // status to determine whether or not to wait on the file object.  If
    // the file object is to be waited on, wait for the operation to complete
    // and obtain the final status from the file object itself.
    //

    if (status == STATUS_PENDING) {

        if (synchronousIo) {

            KeWaitForSingleObject( &fileObject->Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            status = fileObject->FinalStatus;

            IopReleaseFileObjectLock( fileObject );

        } else {

            //
            // This is a normal synchronous I/O operation, as opposed to a
            // serialized synchronous I/O operation.  For this case, wait for
            // the local event and copy the final status information back to
            // the caller.
            //

            status = KeWaitForSingleObject( &localEvent,
                                            Executive,
                                            KernelMode,
                                            FALSE,
                                            (PLARGE_INTEGER) NULL );

            status = localIoStatus.Status;

            *IoStatusBlock = localIoStatus;
        }

    } else {

        //
        // The I/O operation finished without return a status of pending.
        // This means that the operation has not been through I/O completion,
        // so it must be done here.
        //

        PKNORMAL_ROUTINE normalRoutine;
        PVOID normalContext;
        KIRQL irql;

        if (!synchronousIo) {

            //
            // This is not a synchronous I/O operation, it is a synchronous
            // I/O API to a file opened for asynchronous I/O.  Since this
            // code path need never wait on the allocated and supplied event,
            // get rid of it so that it doesn't have to be set to the
            // Signaled state by the I/O completion code.
            //

            irp->UserEvent = (PKEVENT) NULL;
        }

        irp->UserIosb = IoStatusBlock;
        KeRaiseIrql( APC_LEVEL, &irql );
        IopCompleteRequest( &irp->Tail.Apc,
                            &normalRoutine,
                            &normalContext,
                            (PVOID *) &fileObject,
                            &normalContext );
        KeLowerIrql( irql );

        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
    }

    //
    // If there was a target handle generated because of a rename operation,
    // close it now.
    //

    if (targetHandle) {
        NtClose( targetHandle );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\read.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    read.c

Abstract:

    This module contains the code to implement the NtReadFile system service.

--*/

#include "iop.h"

NTSTATUS
NtReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    Buffer.  If the end of the file is reached before Length bytes have
    been read, then the operation will terminate.  The actual length of
    the data read from the file will be returned in the second longword
    of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    Buffer - Address of buffer to receive the data read from the file.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    LARGE_INTEGER fileOffset = {0,0};

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = Buffer;
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether or not we should automatically lock the user's
    // buffer for direct I/O.
    //

    if ((deviceObject->Flags & DO_DIRECT_IO) && (Length != 0)) {
        IoLockUserBuffer(irp, Length);
    }

    //
    // If this read operation is supposed to be performed with caching disabled
    // set the disable flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.BufferOffset = 0;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status =  IopSynchronousServiceTail( deviceObject,
                                         irp,
                                         fileObject,
                                         TRUE,
                                         synchronousIo );

    return status;
}

NTSTATUS
NtReadFileScatter(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service reads Length bytes of data from the file associated with
    FileHandle starting at ByteOffset and puts the data into the caller's
    buffer segments.  The buffer segments are not virtually contiguous,
    but are 8 KB in length and alignment. If the end of the file is reached
    before Length bytes have been read, then the operation will terminate.
    The actual length of the data read from the file will be returned in
    the second longword of the IoStatusBlock.

Arguments:

    FileHandle - Supplies a handle to the file to be read.

    Event - Optionally supplies an event to be signaled when the read operation
        is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the read
        operation is complete.

    ApcContext - Supplies a context parameter to be passed to the ApcRoutine, if
        an ApcRoutine was specified.

    IoStatusBlock - Address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be placed.

    Length - Supplies the length, in bytes, of the data to read from the file.

    ByteOffset - Optionally specifies the starting byte offset within the file
        to begin the read operation.  If not specified and the file is open
        for synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is an error.

Return Value:

    The status returned is success if the read operation was properly queued
    to the I/O system.  Once the read completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:

    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found.  Note
    // that if the caller does not have read access to the file, the operation
    // will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->ReadAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Verify this is a valid scatter read request.  In particular it must be
    // non-cached and and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES(Length);

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an one was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        if (!ARGUMENT_PRESENT( ByteOffset ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1)) {
            fileOffset = fileObject->CurrentByteOffset;
        }

        synchronousIo = TRUE;

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    } else {
        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0) {
        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;
    irp->Flags |= IRP_NOCACHE | IRP_READ_OPERATION | IRP_DEFER_IO_COMPLETION |
        IRP_SCATTER_GATHER_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_READ;
    irpSp->FileObject = fileObject;

    //
    // This is a direct I/O operation.  Lock down and clone the pages in the
    // segment array.  If the target device doesn't support scatter/gather I/O,
    // then also map a virtual buffer that describes the pages.
    //

    if (Length != 0) {

        status = MmLockSelectedIoPages(SegmentArray, Length, irp,
            (BOOLEAN)((deviceObject->Flags & DO_SCATTER_GATHER_IO) == 0));

        if (!NT_SUCCESS(status)) {
            IopExceptionCleanup(fileObject, irp, eventObject);
            return status;
        }
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Read.Length = Length;
    irpSp->Parameters.Read.BufferOffset = 0;
    irpSp->Parameters.Read.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\i386\filelock.asm ===
TITLE   "File Object Lock Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     filelock.asm
;
;  Abstract:
;
;     This module implements functions to support locking FILE_OBJECTs for
;     synchronous I/O operations.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

        EXTRNP  _KeSetEvent,3
        EXTRNP  _KeWaitForSingleObject,5

_TEXT SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; FASTCALL
; IopAcquireFileObjectLock(
;     IN PFILE_OBJECT FileObject
;     )
;
; Routine Description:
;
;     This function acquires a file object's synchronous I/O lock.
;
; Arguments:
;
;     FileObject - Specifies the file object to lock.
;
; Return Value:
;
;     None.
;
;--
cPublicFastCall IopAcquireFileObjectLock, 1

;
; Increment the lock count.  If the count doesn't transition from negative one
; to zero, then another thread already owns the lock and we need to block.
;

        inc     dword ptr FoLockCount[ecx]
        jnz     AcquireContention
        fstRET  IopAcquireFileObjectLock

AcquireContention:
        xor     eax, eax
        add     ecx, FoLock
.errnz (WrExecutive - 0)
        stdCall _KeWaitForSingleObject,<ecx,eax,eax,eax,eax>
        fstRET  IopAcquireFileObjectLock

fstENDP IopAcquireFileObjectLock

;++
;
; VOID
; FASTCALL
; IopReleaseFileObjectLock(
;     IN PFILE_OBJECT FileObject
;     )
;
; Routine Description:
;
;     This function releases a file object's synchronous I/O lock.
;
; Arguments:
;
;     FileObject - Specifies the file object to unlock.
;
; Return Value:
;
;     None.
;
;--
cPublicFastCall IopReleaseFileObjectLock, 1

;
; Decrement the lock count.  If the lock count is greater than or equal to zero,
; then there are waiters for this lock, so release a waiter.
;

        dec     dword ptr FoLockCount[ecx]
        jge     ReleaseWaiter
        fstRET  IopReleaseFileObjectLock

ReleaseWaiter:
        add     ecx, FoLock
        stdCall _KeSetEvent,<ecx,0,0>
        fstRET  IopReleaseFileObjectLock

fstENDP IopReleaseFileObjectLock

_TEXT ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdapi.c

Abstract:

    Implementation of Kernel Debugger portable remote APIs.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

    John Vert (jvert) 28-May-1991

        Added APIs for reading and writing physical memory
        (KdpReadPhysicalMemory and KdpWritePhysicalMemory)

    Wesley Witt (wesw) 18-Aug-1993

        Added KdpGetVersion, KdpWriteBreakPointEx, & KdpRestoreBreakPointEx


--*/

#include "kdp.h"
#include <ntverp.h>

extern LARGE_INTEGER Magic10000;
#define SHIFT10000   13
#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

//
// Define forward referenced function prototypes.
//

VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    );

VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    );

LOGICAL
KdpSearchPhysicalPageRange (
    VOID
    );


#if i386
VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

ULONG_PTR
KdpGetReturnAddress(
    IN PCONTEXT ContextRecord
    );

ULONG_PTR
KdpGetCallNextOffset (
    ULONG_PTR Pc,
    IN PCONTEXT ContextRecord
    );

LONG
KdpLevelChange (
    ULONG_PTR Pc,
    PCONTEXT ContextRecord,
    IN OUT PBOOLEAN SpecialCall
    );

#endif // i386

#if DBG
VOID
KdpDprintf(
    IN PCHAR f,
    ...
    )
/*++

Routine Description:

    Printf routine for the debugger that is safer than DbgPrint.  Calls
    the packet driver instead of reentering the debugger.

Arguments:

    f - Supplies printf format

Return Value:

    None

--*/
{
    char    buf[100];
    STRING  Output;
    va_list mark;

    va_start(mark, f);
    _vsnprintf(buf, 100, f, mark);
    va_end(mark);

    Output.Buffer = buf;
    Output.Length = (USHORT)strlen(Output.Buffer);
    KdpPrintString(&Output);
}
#endif // DBG

BOOLEAN
KdEnterDebugger(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function is used to enter the kernel debugger. Its purpose
    is to freeze all other processors and aqcuire the kernel debugger
    comm port.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to an exception frame that
        describes the trap.

Return Value:

    Returns the previous interrupt enable.

--*/

{

    BOOLEAN Enable;
    TIME_FIELDS TimeFields;

    //
    // HACKHACK - do some crude timer support
    //            but not if called from KdSetOwedBreakpoints()
    //

    if (TrapFrame) {
        KdTimerStop = KdpQueryPerformanceCounter (TrapFrame);
        KdTimerDifference.QuadPart = KdTimerStop.QuadPart - KdTimerStart.QuadPart;
    } else {
        KdTimerStop.QuadPart = 0;
    }

    //
    // Freeze all other processors, raise IRQL to HIGH_LEVEL, and save debug
    // port state.  We lock the port so that KdPollBreakin and a debugger
    // operation don't interfere with each other.
    //

    Enable = KiDisableInterrupts();

    KdpPortLock();
    KdEnteredDebugger = TRUE;

    return Enable;
}

VOID
KdExitDebugger(
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function is used to exit the kernel debugger. It is the reverse
    of KdEnterDebugger.

Arguments:

    Enable - Supplies the previous interrupt enable which is to be restored.

Return Value:

    None.

--*/

{
    ULONG ElapsedTime;
    ULARGE_INTEGER TimeDifference;
    TIME_FIELDS TimeFields;
    ULONG Pending;

    //
    // restore stuff and exit
    //

    KdpPortUnlock();

    //
    // Flush the current TB.
    //

    KeFlushCurrentTb();

    //
    // Lower IRQL and restore interrupt enable
    //

    KiRestoreInterrupts(Enable);

    //
    // Do some crude timer support.  If KdEnterDebugger didn't
    // Query the performance counter, then don't do it here either.
    //

    if (KdTimerStop.QuadPart == 0) {
        KdTimerStart = KdTimerStop;
    } else {
        KdTimerStart = KeQueryPerformanceCounter();
    }

    return;
}

#if i386
VOID
InternalBreakpointCheck (
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    LARGE_INTEGER dueTime;
    ULONG i;

    UNREFERENCED_PARAMETER(Dpc);
    UNREFERENCED_PARAMETER(DeferredContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
    dueTime.HighPart = -1;

    KeSetTimer(
        &InternalBreakpointTimer,
        dueTime,
        &InternalBreakpointCheckDpc
        );

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {

            PDBGKD_INTERNAL_BREAKPOINT b = KdpInternalBPs + i;
            ULONG callsThisPeriod;

            callsThisPeriod = b->Calls - b->CallsLastCheck;
            if ( callsThisPeriod > b->MaxCallsPerPeriod ) {
                b->MaxCallsPerPeriod = callsThisPeriod;
            }
            b->CallsLastCheck = b->Calls;
        }
    }

    return;

} // InternalBreakpointCheck

VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function sets an internal breakpoint.  "Internal breakpoint"
    means one in which control is not returned to the kernel debugger at
    all, but rather just update internal counting routines and resume.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    ULONG savedFlags;

    for ( i = 0 ; i < KdpNumInternalBreakpoints; i++ ) {
        if ( KdpInternalBPs[i].Addr ==
                            m->u.SetInternalBreakpoint.BreakpointAddress ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
            if ( KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
                bp = &KdpInternalBPs[i];
                break;
            }
        }
    }

    if ( !bp ) {
        if ( KdpNumInternalBreakpoints >= DBGKD_MAX_INTERNAL_BREAKPOINTS ) {
            return; // no space.  Probably should report error.
        }
        bp = &KdpInternalBPs[KdpNumInternalBreakpoints++];
        bp->Flags |= DBGKD_INTERNAL_BP_FLAG_INVALID; // force initialization
    }

    if ( bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID ) {
        if ( m->u.SetInternalBreakpoint.Flags &
                                        DBGKD_INTERNAL_BP_FLAG_INVALID ) {
            return; // tried clearing a non-existant BP.  Ignore the request
        }
        bp->Calls = bp->MaxInstructions = bp->TotalInstructions = 0;
        bp->CallsLastCheck = bp->MaxCallsPerPeriod = 0;
        bp->MinInstructions = 0xffffffff;
        bp->Handle = 0;
        bp->Thread = 0;
    }

    savedFlags = bp->Flags;
    bp->Flags = m->u.SetInternalBreakpoint.Flags; // this could possibly invalidate the BP
    bp->Addr = m->u.SetInternalBreakpoint.BreakpointAddress;

    if ( bp->Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                      DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {

        if ( (bp->Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
             (bp->Thread != 0) ) {
            // The breakpoint is active; defer its deletion
            bp->Flags &= ~DBGKD_INTERNAL_BP_FLAG_INVALID;
            bp->Flags |= DBGKD_INTERNAL_BP_FLAG_DYING;
        }

        // This is really a CLEAR bp request.

        if ( bp->Handle != 0 ) {
            KdpDeleteBreakpoint( bp->Handle );
        }
        bp->Handle = 0;

        return;
    }

    // now set the real breakpoint and remember its handle.

    if ( savedFlags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                       DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) {
        // breakpoint was invalid; activate it now
        bp->Handle = KdpAddBreakpoint( (PVOID)bp->Addr );
    }

    if ( BreakpointsSuspended ) {
        KdpSuspendBreakpoint( bp->Handle );
    }

} // KdSetInternalBreakpoint

NTSTATUS
KdGetTraceInformation(
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    in a buffer provided for it.  It is designed to be called from
    NTQuerySystemInformation.  It is morally equivalent to GetInternalBP
    except that it communicates locally, and returns all the breakpoints
    at once.

Arguments:

    SystemInforamtion - the buffer into which to write the result.
    SystemInformationLength - the maximum length to write
    RetrunLength - How much data was really written

Return Value:

    None.

--*/

{
    ULONG numEntries = 0;
    ULONG i = 0;
    PDBGKD_GET_INTERNAL_BREAKPOINT64 outPtr;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            numEntries++;
        }
    }

    *ReturnLength = numEntries * sizeof(DBGKD_GET_INTERNAL_BREAKPOINT64);
    if ( *ReturnLength > SystemInformationLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    //
    // We've got enough space.  Copy it in.
    //

    outPtr = (PDBGKD_GET_INTERNAL_BREAKPOINT64)SystemInformation;
    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) ) {
            outPtr->BreakpointAddress = KdpInternalBPs[i].Addr;
            outPtr->Flags = KdpInternalBPs[i].Flags;
            outPtr->Calls = KdpInternalBPs[i].Calls;
            outPtr->MaxCallsPerPeriod = KdpInternalBPs[i].MaxCallsPerPeriod;
            outPtr->MinInstructions = KdpInternalBPs[i].MinInstructions;
            outPtr->MaxInstructions = KdpInternalBPs[i].MaxInstructions;
            outPtr->TotalInstructions = KdpInternalBPs[i].TotalInstructions;
            outPtr++;
        }
    }

    return STATUS_SUCCESS;

} // KdGetTraceInformation

VOID
KdGetInternalBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function gets data about an internal breakpoint and returns it
    to the calling debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    ULONG i;
    PDBGKD_INTERNAL_BREAKPOINT bp = NULL;
    STRING messageHeader;

    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    for ( i = 0; i < KdpNumInternalBreakpoints; i++ ) {
        if ( !(KdpInternalBPs[i].Flags & (DBGKD_INTERNAL_BP_FLAG_INVALID |
                                          DBGKD_INTERNAL_BP_FLAG_SUSPENDED)) &&
             (KdpInternalBPs[i].Addr ==
                        m->u.GetInternalBreakpoint.BreakpointAddress) ) {
            bp = &KdpInternalBPs[i];
            break;
        }
    }

    if ( !bp ) {
        m->u.GetInternalBreakpoint.Flags = DBGKD_INTERNAL_BP_FLAG_INVALID;
        m->u.GetInternalBreakpoint.Calls = 0;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = 0;
        m->u.GetInternalBreakpoint.MinInstructions = 0;
        m->u.GetInternalBreakpoint.MaxInstructions = 0;
        m->u.GetInternalBreakpoint.TotalInstructions = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->u.GetInternalBreakpoint.Flags = bp->Flags;
        m->u.GetInternalBreakpoint.Calls = bp->Calls;
        m->u.GetInternalBreakpoint.MaxCallsPerPeriod = bp->MaxCallsPerPeriod;
        m->u.GetInternalBreakpoint.MinInstructions = bp->MinInstructions;
        m->u.GetInternalBreakpoint.MaxInstructions = bp->MaxInstructions;
        m->u.GetInternalBreakpoint.TotalInstructions = bp->TotalInstructions;
        m->ReturnStatus = STATUS_SUCCESS;
    }

    m->ApiNumber = DbgKdGetInternalBreakPointApi;

    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                    &messageHeader,
                    NULL
                    );

    return;

} // KdGetInternalBreakpoint
#endif // i386

KCONTINUE_STATUS
KdpSendWaitContinue (
    IN ULONG OutPacketType,
    IN PSTRING OutMessageHeader,
    IN PSTRING OutMessageData OPTIONAL,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sends a packet, and then waits for a continue message.
    BreakIns received while waiting will always cause a resend of the
    packet originally sent out.  While waiting, manipulate messages
    will be serviced.

    A resend always resends the original event sent to the debugger,
    not the last response to some debugger command.

Arguments:

    OutPacketType - Supplies the type of packet to send.

    OutMessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    OutMessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    ContextRecord - Exception context

Return Value:

    A value of TRUE is returned if the continue message indicates
    success, Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_MANIPULATE_STATE64 ManipulateState;
    ULONG ReturnCode;
    NTSTATUS Status;
    KCONTINUE_STATUS ContinueStatus;

    //
    // Loop servicing state manipulation message until a continue message
    // is received.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)&ManipulateState;
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;
    MessageData.Buffer = (PCHAR)KdpMessageBuffer;

ResendPacket:

    //
    // Send event notification packet to debugger on host.  Come back
    // here any time we see a breakin sequence.
    //

    KdpSendPacket(
                  OutPacketType,
                  OutMessageHeader,
                  OutMessageData
                  );

    //
    // After sending packet, if there is no response from debugger
    // AND the packet is for reporting symbol (un)load, the debugger
    // will be declared to be not present.  Note If the packet is for
    // reporting exception, the KdpSendPacket will never stop.
    //

    if (KdDebuggerNotPresent) {
        return ContinueSuccess;
    }

    while (TRUE) {

        //
        // Wait for State Manipulate Packet without timeout.
        //

        do {

            ReturnCode = KdpReceivePacket(
                            PACKET_TYPE_KD_STATE_MANIPULATE,
                            &MessageHeader,
                            &MessageData,
                            &Length
                            );
            if (ReturnCode == (USHORT)KDP_PACKET_RESEND) {
                goto ResendPacket;
            }
        } while (ReturnCode == KDP_PACKET_TIMEOUT);

        //
        // Switch on the return message API number.
        //

        switch (ManipulateState.ApiNumber) {

        case DbgKdReadVirtualMemoryApi:
            KdpReadVirtualMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteVirtualMemoryApi:
            KdpWriteVirtualMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdCheckLowMemoryApi:
            KdpCheckLowMemory (&ManipulateState);
            break;

        case DbgKdReadPhysicalMemoryApi:
            KdpReadPhysicalMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdWritePhysicalMemoryApi:
            KdpWritePhysicalMemory(&ManipulateState,&MessageData);
            break;

        case DbgKdGetContextApi:
            KdpGetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdSetContextApi:
            KdpSetContext(&ManipulateState,&MessageData,ContextRecord);
            break;

        case DbgKdWriteBreakPointApi:
            KdpWriteBreakpoint(&ManipulateState,&MessageData);
            break;

        case DbgKdRestoreBreakPointApi:
            KdpRestoreBreakpoint(&ManipulateState,&MessageData);
            break;

        case DbgKdReadControlSpaceApi:
            KdpReadControlSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteControlSpaceApi:
            KdpWriteControlSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdReadIoSpaceApi:
            KdpReadIoSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteIoSpaceApi:
            KdpWriteIoSpace(&ManipulateState,&MessageData);
            break;

        case DbgKdContinueApi:
            if (NT_SUCCESS(ManipulateState.u.Continue.ContinueStatus) != FALSE) {
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdContinueApi2:
            if (NT_SUCCESS(ManipulateState.u.Continue2.ContinueStatus) != FALSE) {
                KdpGetStateChange(&ManipulateState,ContextRecord);
                return ContinueSuccess;
            } else {
                return ContinueError;
            }
            break;

        case DbgKdRebootApi:
            HalReturnToFirmware(HalKdRebootRoutine);
            break;

#if i386
        case DbgKdReadMachineSpecificRegister:
            KdpReadMachineSpecificRegister(&ManipulateState,&MessageData);
            break;

        case DbgKdWriteMachineSpecificRegister:
            KdpWriteMachineSpecificRegister(&ManipulateState,&MessageData);
            break;

        case DbgKdSetSpecialCallApi:
            KdSetSpecialCall(&ManipulateState,ContextRecord);
            break;

        case DbgKdClearSpecialCallsApi:
            KdClearSpecialCalls();
            break;

        case DbgKdSetInternalBreakPointApi:
            KdSetInternalBreakpoint(&ManipulateState);
            break;

        case DbgKdGetInternalBreakPointApi:
            KdGetInternalBreakpoint(&ManipulateState);
            break;
#endif

        case DbgKdGetVersionApi:
            KdpGetVersion(&ManipulateState);
            break;

        case DbgKdCauseBugCheckApi:
            KdpCauseBugCheck(&ManipulateState);
            break;

        case DbgKdPageInApi:
            KdpNotSupported(&ManipulateState);
            break;

        case DbgKdWriteBreakPointExApi:
            Status = KdpWriteBreakPointEx(&ManipulateState,&MessageData);
            if (Status) {
                ManipulateState.ApiNumber = DbgKdContinueApi;
                ManipulateState.u.Continue.ContinueStatus = Status;
                return ContinueError;
            }
            break;

        case DbgKdRestoreBreakPointExApi:
            KdpRestoreBreakPointEx(&ManipulateState,&MessageData);
            break;

        case DbgKdSwitchProcessor:
            return ContinueProcessorReselected;

        case DbgKdSearchMemoryApi:
            KdpSearchMemory(&ManipulateState, &MessageData);
            break;

            //
            // Invalid message.
            //

        default:
            MessageData.Length = 0;
            ManipulateState.ReturnStatus = STATUS_UNSUCCESSFUL;
            KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE, &MessageHeader, &MessageData);
            break;
        }
    }
}

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response to a read virtual memory 32-bit
    state manipulation message. Its function is to read virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to read.

Return Value:

    None.

--*/

{
    ULONG Length;
    STRING MessageHeader;

    //
    // Trim the transfer count to fit in a single message.
    //

    Length = m->u.ReadMemory.TransferCount;
    if (Length > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    }

    //
    // Move the data to the destination buffer.
    //

    AdditionalData->Length = (USHORT)KdpMoveMemory(AdditionalData->Buffer,
                                                   (PVOID)m->u.ReadMemory.TargetBaseAddress,
                                                   Length);

    //
    // If all the data is read, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes read, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.ReadMemory.ActualBytesRead = AdditionalData->Length;

    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData);

    return;
}

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write virtual memory 32-bit
    state manipulation message. Its function is to write virtual memory
    and return.

Arguments:

    m - Supplies a pointer to the state manipulation message.

    AdditionalData - Supplies a pointer to a descriptor for the data to write.

Return Value:

    None.

--*/

{

    ULONG Length;
    STRING MessageHeader;
    HARDWARE_PTE Opaque;

    //
    // Move the data to the destination buffer.
    //

    Length = KdpMoveMemory((PVOID)m->u.WriteMemory.TargetBaseAddress,
                           AdditionalData->Buffer,
                           AdditionalData->Length);

    //
    // If all the data is written, then return a success status. Otherwise,
    // return an unsuccessful status.
    //

    m->ReturnStatus = STATUS_SUCCESS;
    if (Length != AdditionalData->Length) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    //
    // Set the actual number of bytes written, initialize the message header,
    // and send the reply packet to the host debugger.
    //

    m->u.WriteMemory.ActualBytesWritten = Length;
    MessageHeader.Length = sizeof(DBGKD_MANIPULATE_STATE64);
    MessageHeader.Buffer = (PCHAR)m;
    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL);

    return;
}

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a get context state
    manipulation message.  Its function is to return the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_GET_CONTEXT a = &m->u.GetContext;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (m->Processor >= (USHORT)1) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        AdditionalData->Length = sizeof(*Context);
        KdpQuickMoveMemory(AdditionalData->Buffer, (PCHAR)Context, sizeof(*Context));
    }

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );
}

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    )

/*++

Routine Description:

    This function is called in response of a set context state
    manipulation message.  Its function is set the current
    context.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_SET_CONTEXT a = &m->u.SetContext;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == sizeof(*Context));

    if (m->Processor >= (USHORT)1) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    } else {
        m->ReturnStatus = STATUS_SUCCESS;
        KdpQuickMoveMemory((PCHAR)Context, AdditionalData->Buffer, sizeof(*Context));
    }

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state
    manipulation message.  Its function is to write a breakpoint
    and return a handle to the breakpoint.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_BREAKPOINT64 a = &m->u.WriteBreakPoint;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    a->BreakPointHandle = KdpAddBreakpoint((PVOID)a->BreakPointAddress);
    if (a->BreakPointHandle != 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state
    manipulation message.  Its function is to restore a breakpoint
    using the specified handle.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_RESTORE_BREAKPOINT a = &m->u.RestoreBreakPoint;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);
    if (KdpDeleteBreakpoint(a->BreakPointHandle)) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }
    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

#if i386
long
SymNumFor(
    ULONG pc
    )
{
    ULONG index;

    for (index = 0; index < NumTraceDataSyms; index++) {
        if ((TraceDataSyms[index].SymMin <= pc) &&
            (TraceDataSyms[index].SymMax > pc)) return(index);
    }
    return(-1);
}

void PotentialNewSymbol (ULONG pc)
{
    if (!TraceDataBufferFilled &&
        -1 != SymNumFor(pc)) {     // we've already seen this one
        return;
    }

    TraceDataBufferFilled = FALSE;

    // OK, we've got to start up a TraceDataRecord
    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange = 0;

    if (-1 != SymNumFor(pc)) {
        int sym = SymNumFor(pc);
        TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) sym;
        KdpCurrentSymbolStart = TraceDataSyms[sym].SymMin;
        KdpCurrentSymbolEnd = TraceDataSyms[sym].SymMax;

        return;  // we've already seen this one
    }

    TraceDataSyms[NextTraceDataSym].SymMin = KdpCurrentSymbolStart;
    TraceDataSyms[NextTraceDataSym].SymMax = KdpCurrentSymbolEnd;

    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = NextTraceDataSym;

    // Bump the "next" pointer, wrapping if necessary.  Also bump the
    // "valid" pointer if we need to.
    NextTraceDataSym = (NextTraceDataSym + 1) % 256;
    if (NumTraceDataSyms < NextTraceDataSym) {
        NumTraceDataSyms = NextTraceDataSym;
    }

}

void DumpTraceData(PSTRING MessageData)
{

 TraceDataBuffer[0].LongNumber = TraceDataBufferPosition;
 MessageData->Length = (USHORT)(sizeof(TraceDataBuffer[0]) * TraceDataBufferPosition);
 MessageData->Buffer = (PVOID)TraceDataBuffer;
 TraceDataBufferPosition = 1;
}

BOOLEAN
TraceDataRecordCallInfo(
    ULONG InstructionsTraced,
    LONG CallLevelChange,
    ULONG pc
    )
{
    // We've just exited a symbol scope.  The InstructionsTraced number goes
    // with the old scope, the CallLevelChange goes with the new, and the
    // pc fills in the symbol for the new TraceData record.

    long SymNum = SymNumFor(pc);

    if (KdpNextCallLevelChange != 0) {
        TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =
                                                (char) KdpNextCallLevelChange;
        KdpNextCallLevelChange = 0;
    }


    if (InstructionsTraced >= TRACE_DATA_INSTRUCTIONS_BIG) {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           TRACE_DATA_INSTRUCTIONS_BIG;
       TraceDataBuffer[TraceDataBufferPosition+1].LongNumber =
           InstructionsTraced;
       TraceDataBufferPosition += 2;
    } else {
       TraceDataBuffer[TraceDataBufferPosition].s.Instructions =
           (unsigned short)InstructionsTraced;
       TraceDataBufferPosition++;
    }

    if ((TraceDataBufferPosition + 2 >= TRACE_DATA_BUFFER_MAX_SIZE) ||
        (-1 == SymNum)) {
        if (TraceDataBufferPosition +2 >= TRACE_DATA_BUFFER_MAX_SIZE) {
            TraceDataBufferFilled = TRUE;
        }
       KdpNextCallLevelChange = CallLevelChange;
       return FALSE;
    }

    TraceDataBuffer[TraceDataBufferPosition].s.LevelChange =(char)CallLevelChange;
    TraceDataBuffer[TraceDataBufferPosition].s.SymbolNumber = (UCHAR) SymNum;
    KdpCurrentSymbolStart = TraceDataSyms[SymNum].SymMin;
    KdpCurrentSymbolEnd = TraceDataSyms[SymNum].SymMax;

    return TRUE;
}

BOOLEAN
SkippingWhichBP (
    PVOID thread,
    PULONG BPNum
    )

/*
 * Return TRUE iff the pc corresponds to an internal breakpoint
 * that has just been replaced for execution.  If TRUE, then return
 * the breakpoint number in BPNum.
 */

{
    ULONG index;

    if (!IntBPsSkipping) return FALSE;

    for (index = 0; index < KdpNumInternalBreakpoints; index++) {
        if (!(KdpInternalBPs[index].Flags & DBGKD_INTERNAL_BP_FLAG_INVALID) &&
            (KdpInternalBPs[index].Thread == thread)) {
            *BPNum = index;
            return TRUE;
        }
    }
    return FALSE; // didn't match any
}

NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    ULONG Length,
    PULONG RequiredLength
    )
{
    *RequiredLength = sizeof(DBGKD_MANIPULATE_STATE64) +
                        (sizeof(ULONG) * KdNumberOfSpecialCalls);

    if ( Length < *RequiredLength ) {
        return STATUS_INFO_LENGTH_MISMATCH;
    }

    m->u.QuerySpecialCalls.NumberOfSpecialCalls = KdNumberOfSpecialCalls;
        RtlCopyMemory(
        m + 1,
        KdSpecialCalls,
        sizeof(ULONG) * KdNumberOfSpecialCalls
        );

    return STATUS_SUCCESS;

} // KdQuerySpecialCalls

VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    This function sets the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.
--*/

{
    if ( KdNumberOfSpecialCalls >= DBGKD_MAX_SPECIAL_CALLS ) {
        return; // too bad
    }

    KdSpecialCalls[KdNumberOfSpecialCalls++] = (ULONG_PTR)m->u.SetSpecialCall.SpecialCall;

    NextTraceDataSym = 0;
    NumTraceDataSyms = 0;
    KdpNextCallLevelChange = 0;
    if (ContextRecord && !InstrCountInternal) {
        InitialSP = ContextRecord->Esp;
    }

} // KdSetSpecialCall

VOID
KdClearSpecialCalls (
    VOID
    )

/*++

Routine Description:

    This function clears the addresses of the "special" call addresses
    that the watchtrace facility pushes back to the kernel debugger
    rather than stepping through.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KdNumberOfSpecialCalls = 0;
    return;

} // KdClearSpecialCalls

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    )
{
    ULONG pc = (ULONG)CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    LONG BpNum;
    ULONG SkippedBPNum;
    BOOLEAN AfterSC = FALSE;

    if (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) {
        if (WatchStepOverSuspended) {
            //
            //  For background, see the comment below where WSOThread is
            //  wrong.  We've now stepped over the breakpoint in the non-traced
            //  thread, and need to replace it and restart the non-traced
            //  thread at full speed.
            //

            WatchStepOverHandle = KdpAddBreakpoint((PVOID)WatchStepOverBreakAddr);
            WatchStepOverSuspended = FALSE;
            ContextRecord->EFlags &= ~0x100L; /* clear trace flag */
            return TRUE; // resume non-traced thread at full speed
        }

        if ((!SymbolRecorded) && (KdpCurrentSymbolStart != 0) && (KdpCurrentSymbolEnd != 0)) {
            //
            //  We need to use oldpc here, because this may have been
            //  a 1 instruction call.  We've ALREADY executed the instruction
            //  that the new symbol is for, and if the pc has moved out of
            //  range, we might screw up.  Hence, use the pc from when
            //  SymbolRecorded was set.  Yuck.
            //

            PotentialNewSymbol(oldpc);
            SymbolRecorded = TRUE;
        }

        if (!InstrCountInternal &&
            SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum)) {

            //
            //  We just single-stepped over a temporarily removed internal
            //  breakpoint.
            //  If it's a COUNTONLY breakpoint:
            //      Put the breakpoint instruction back and resume
            //      regular execution.
            //

            if (KdpInternalBPs[SkippedBPNum].Flags &
                DBGKD_INTERNAL_BP_FLAG_COUNTONLY) {

                IntBPsSkipping --;

                KdpRestoreAllBreakpoints();

                ContextRecord->EFlags &= ~0x100L;  // Clear trace flag
                KdpInternalBPs[SkippedBPNum].Thread = 0;

                if (KdpInternalBPs[SkippedBPNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_DYING) {
                    KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                    KdpInternalBPs[SkippedBPNum].Flags |=
                            DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
                }

                return TRUE;
            }

            //
            //  If it's not:
            //      set up like it's a ww, by setting Begin and KdpCurrentSymbolEnd
            //      and bop off into single step land.  We probably ought to
            //      disable all breakpoints here, too, so that we don't do
            //      anything foul like trying two non-COUNTONLY's at the
            //      same time or something...
            //

            KdpCurrentSymbolEnd = 0;
            KdpCurrentSymbolStart = (ULONG_PTR) KdpInternalBPs[SkippedBPNum].ReturnAddress;

            ContextRecord->EFlags |= 0x100L; /* Trace on. */
            InitialSP = ContextRecord->Esp;

            InstructionsTraced = 1;  /* Count the initial call instruction. */
            InstrCountInternal = TRUE;
        }

    } /* if single step */
    else if (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) {
        if (WatchStepOver && pc == WatchStepOverBreakAddr) {
            //
            //  This is a breakpoint after completion of a "special call"
            //

            if ((WSOThread != (PVOID)KeGetCurrentThread()) ||
                (WSOEsp + 0x20 < ContextRecord->Esp) ||
                (ContextRecord->Esp + 0x20 < WSOEsp)) {
                //
                //  Here's the story up to this point: the traced thread
                //  cruised along until it it a special call.  The tracer
                //  placed a breakpoint on the instruction immediately after
                //  the special call returns and restarted the traced thread
                //  at full speed.  Then, some *other* thread hit the
                //  breakpoint.  So, to correct for this, we're going to
                //  remove the breakpoint, single step the non-traced
                //  thread one instruction, replace the breakpoint,
                //  restart the non-traced thread at full speed, and wait
                //  for the traced thread to get to this breakpoint, just
                //  like we were when this happened.  The assumption
                //  here is that the traced thread won't hit the breakpoint
                //  while it's removed, which I believe to be true, because
                //  I don't think a context switch can occur during a single
                //  step operation.
                //
                //  For extra added fun, it's possible to execute interrupt
                //  routines IN THE SAME THREAD!!!  That's why we need to keep
                //  the stack pointer as well as the thread address: the APC
                //  code can result in pushing on the stack and doing a call
                //  that's really part on an interrupt service routine in the
                //  context of the current thread.  Lovely, isn't it?
                //

                WatchStepOverSuspended = TRUE;
                KdpDeleteBreakpoint(WatchStepOverHandle);
                ContextRecord->EFlags |= 0x100L; // Set trace flag
                return TRUE; // single step "non-traced" thread
            }

            //
            //  we're in the thread we started in; resume in single-step mode
            //  to continue the trace.
            //

            WatchStepOver = FALSE;
            KdpDeleteBreakpoint(WatchStepOverHandle);
            ContextRecord->EFlags |= 0x100L; // back to single step mode
            AfterSC = TRUE; // put us into the regular watchStep code

        } else {

            for ( BpNum = 0; BpNum < (LONG) KdpNumInternalBreakpoints; BpNum++ ) {
                if ( !(KdpInternalBPs[BpNum].Flags &
                       (DBGKD_INTERNAL_BP_FLAG_INVALID |
                        DBGKD_INTERNAL_BP_FLAG_SUSPENDED) ) &&
                     (KdpInternalBPs[BpNum].Addr == pc) ) {
                    break;
                }
            }

            if ( BpNum < (LONG) KdpNumInternalBreakpoints ) {

                //
                //  This is an internal monitoring breakpoint.
                //  Restore the instruction and start in single-step
                //  mode so that we can retore the breakpoint once the
                //  instruction executes, or continue stepping if this isn't
                //  a COUNTONLY breakpoint.
                //

                KdpProcessInternalBreakpoint( BpNum );
                KdpInternalBPs[BpNum].Thread = (PVOID)KeGetCurrentThread();
                IntBPsSkipping ++;

                KdpSuspendAllBreakpoints();

                ContextRecord->EFlags |= 0x100L;  // Set trace flag
                if (!(KdpInternalBPs[BpNum].Flags &
                        DBGKD_INTERNAL_BP_FLAG_COUNTONLY)) {
                    KdpInternalBPs[BpNum].ReturnAddress =
                                    KdpGetReturnAddress( ContextRecord );
                }
                return TRUE;
            }
        }
    } /* if breakpoint */

//  if (AfterSC) {
//      DPRINT(( "1: KdpCurrentSymbolStart %x  KdpCurrentSymbolEnd %x\n", KdpCurrentSymbolStart, KdpCurrentSymbolEnd ));
//  }

    if ((AfterSC || ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP) &&
        KdpCurrentSymbolStart != 0 &&
        ((KdpCurrentSymbolEnd == 0 && ContextRecord->Esp <= InitialSP) ||
         (KdpCurrentSymbolStart <= pc && pc < KdpCurrentSymbolEnd))) {
        ULONG lc;
        BOOLEAN IsSpecialCall;

        //
        //  We've taken a step trace, but are still executing in the current
        //  function.  Remember that we executed an instruction and see if the
        //  instruction changes the call level.
        //

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced++;
        CallLevelChange += lc;

        //
        //  See if instruction is a transfer to a special routine, one that we
        //  cannot trace through since it may swap contexts
        //

        if (IsSpecialCall) {

//  DPRINT( ("2: pc=%x, level change %d\n", pc, lc) );

            //
            //  We are about to transfer to a special call routine.  Since we
            //  cannot trace through this routine, we execute it atomically by
            //  setting a breakpoint at the next logical offset.
            //
            //  Note in the case of an indirect jump to a special call routine, the
            //  level change will be -1 and the next offset will be the ULONG that's
            //  on the top of the stack.
            //
            //  However, we've already adjusted the level based on this
            //  instruction.  We need to undo this except for the magic -1 call.
            //

            if (lc != -1) {
                CallLevelChange -= lc;
            }

            //
            //  Set up for stepping over a procedure
            //

            WatchStepOver = TRUE;
            WatchStepOverBreakAddr = KdpGetCallNextOffset( pc, ContextRecord );
            WSOThread = (PVOID)KeGetCurrentThread( );
            WSOEsp = ContextRecord->Esp;

            //
            //  Establish the breakpoint
            //

            WatchStepOverHandle = KdpAddBreakpoint( (PVOID)WatchStepOverBreakAddr );


            //
            //  Note that we are continuing rather than tracing and rely on hitting
            //  the breakpoint in the current thread context to resume the watch
            //  action.
            //

            ContextRecord->EFlags &= ~0x100L;
            return TRUE;
        }

        //
        //  Resume execution with the trace flag set.  Avoid going over the wire to
        //  the remote debugger.
        //

        ContextRecord->EFlags |= 0x100L;  // Set trace flag

        return TRUE;
    }

    if ((AfterSC || (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)) &&
        (KdpCurrentSymbolStart != 0)) {
        //
        // We're WatchTracing, but have just changed symbol range.
        // Fill in the call record and return to the debugger if
        // either we're full or the pc is outside of the known
        // symbol scopes.  Otherwise, resume stepping.
        //
        int lc;
        BOOLEAN IsSpecialCall;

        InstructionsTraced++; // don't forget to count the call/ret instruction.

//  if (AfterSC) {
//      DPRINT(( "3: InstrCountInternal: %x\n", InstrCountInternal ));
//  }

        if (InstrCountInternal) {

            // We've just finished processing a non-COUNTONLY breakpoint.
            // Record the appropriate data and resume full speed execution.

            SkippingWhichBP((PVOID)KeGetCurrentThread(),&SkippedBPNum);

            KdpInternalBPs[SkippedBPNum].Calls++;


            if (KdpInternalBPs[SkippedBPNum].MinInstructions > InstructionsTraced) {
                KdpInternalBPs[SkippedBPNum].MinInstructions = InstructionsTraced;
            }
            if (KdpInternalBPs[SkippedBPNum].MaxInstructions < InstructionsTraced) {
                KdpInternalBPs[SkippedBPNum].MaxInstructions = InstructionsTraced;
            }
            KdpInternalBPs[SkippedBPNum].TotalInstructions += InstructionsTraced;

            KdpInternalBPs[SkippedBPNum].Thread = 0;

            IntBPsSkipping--;
            InstrCountInternal = FALSE;
            KdpCurrentSymbolStart = 0;
            KdpRestoreAllBreakpoints();

            if (KdpInternalBPs[SkippedBPNum].Flags &
                    DBGKD_INTERNAL_BP_FLAG_DYING) {
                KdpDeleteBreakpoint(KdpInternalBPs[SkippedBPNum].Handle);
                KdpInternalBPs[SkippedBPNum].Flags |=
                        DBGKD_INTERNAL_BP_FLAG_INVALID; // bye, bye
            }

            ContextRecord->EFlags &= ~0x100L; // clear trace flag
            return TRUE; // Back to normal execution.
        }

        if (TraceDataRecordCallInfo( InstructionsTraced, CallLevelChange, pc)) {

            //
            //  Everything was cool internally.  We can keep executing without
            //  going back to the remote debugger.
            //
            //  We have to compute lc after calling
            //  TraceDataRecordCallInfo, because LevelChange relies on
            //  KdpCurrentSymbolStart and KdpCurrentSymbolEnd corresponding to
            //  the pc.
            //

            lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
            InstructionsTraced = 0;
            CallLevelChange = lc;

            //
            //  See if instruction is a transfer to a special routine, one that we
            //  cannot trace through since it may swap contexts
            //

            if (IsSpecialCall) {

//  DPRINT(( "4: pc=%x, level change %d\n", pc, lc));

                //
                //  We are about to transfer to a special call routine.  Since we
                //  cannot trace through this routine, we execute it atomically by
                //  setting a breakpoint at the next logical offset.
                //
                //  Note in the case of an indirect jump to a special call routine, the
                //  level change will be -1 and the next offset will be the ULONG that's
                //  on the top of the stack.
                //
                //  However, we've already adjusted the level based on this
                //  instruction.  We need to undo this except for the magic -1 call.
                //

                if (lc != -1) {
                    CallLevelChange -= lc;
                }

                //
                //  Set up for stepping over a procedure
                //

                WatchStepOver = TRUE;
                WSOThread = (PVOID)KeGetCurrentThread();

                //
                //  Establish the breakpoint
                //

                WatchStepOverHandle =
                    KdpAddBreakpoint( (PVOID)KdpGetCallNextOffset( pc, ContextRecord ));

                //
                //  Resume execution with the trace flag set.  Avoid going over the wire to
                //  the remote debugger.
                //

                ContextRecord->EFlags &= ~0x100L;
                return TRUE;
            }

            ContextRecord->EFlags |= 0x100L; // Set trace flag
            return TRUE; // Off we go
        }

        lc = KdpLevelChange( pc, ContextRecord, &IsSpecialCall );
        InstructionsTraced = 0;
        CallLevelChange = lc;

        // We need to go back to the remote debugger.  Just fall through.

        if ((lc != 0) && IsSpecialCall) {
            // We're hosed
            DPRINT(( "Special call on first entry to symbol scope @ %x\n", pc ));
        }
    }

    SymbolRecorded = FALSE;
    oldpc = pc;

    return FALSE;
}
#endif // i386

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine sends an exception state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{
    STRING MessageData;
    STRING MessageHeader;
    X86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        KdpSetStateChange(&WaitStateChange,
                            ExceptionRecord,
                            ContextRecord,
                            SecondChance
                            );

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

#if i386
        //
        // Construct the wait state change data and data descriptor.
        //

        DumpTraceData(&MessageData);
#else
        MessageData.Length = 0;
#endif

        //
        // Send packet to the kernel debugger on the host machine,
        // wait for answer.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    &MessageData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected) ;

    return (BOOLEAN) Status;
}

BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine sends a load symbols state change packet to the kernel
    debugger and waits for a manipulate state message.

Arguments:

    PathName - Supplies a pointer to the pathname of the image whose
        symbols are to be loaded.

    BaseOfDll - Supplies the base address where the image was loaded.

    ProcessId - Unique 32-bit identifier for process that is using
        the symbols.  -1 for system process.

    CheckSum - Unique 32-bit identifier from image header.

    UnloadSymbol - TRUE if the symbols that were previously loaded for
        the named image are to be unloaded from the debugger.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise, a
    value of FALSE is returned.

--*/

{

    PSTRING AdditionalData;
    STRING MessageData;
    STRING MessageHeader;
    X86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange;
    KCONTINUE_STATUS Status;

    do {

        //
        // Construct the wait state change message and message descriptor.
        //

        WaitStateChange.NewState = DbgKdLoadSymbolsStateChange;
        WaitStateChange.ProcessorLevel = 6;
        WaitStateChange.Processor = (USHORT)0;
        WaitStateChange.NumberProcessors = (ULONG)1;
        WaitStateChange.Thread = (ULONG64)(LONG64)(LONG_PTR) KeGetCurrentThread();
        WaitStateChange.ProgramCounter = (ULONG64)(LONG64)(LONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
        KdpSetLoadState(&WaitStateChange, ContextRecord);
        WaitStateChange.u.LoadSymbols.UnloadSymbols = UnloadSymbols;
        WaitStateChange.u.LoadSymbols.BaseOfDll = (ULONG64)SymbolInfo->BaseOfDll;
        WaitStateChange.u.LoadSymbols.ProcessId = (ULONG) SymbolInfo->ProcessId;
        WaitStateChange.u.LoadSymbols.CheckSum = SymbolInfo->CheckSum;
        WaitStateChange.u.LoadSymbols.SizeOfImage = SymbolInfo->SizeOfImage;
        if (ARGUMENT_PRESENT( PathName )) {
            WaitStateChange.u.LoadSymbols.PathNameLength =
                KdpMoveMemory(
                    (PCHAR)KdpPathBuffer,
                    (PCHAR)PathName->Buffer,
                    PathName->Length
                    ) + 1;

            MessageData.Buffer = KdpPathBuffer;
            MessageData.Length = (USHORT)WaitStateChange.u.LoadSymbols.PathNameLength;
            MessageData.Buffer[MessageData.Length-1] = '\0';
            AdditionalData = &MessageData;
        } else {
            WaitStateChange.u.LoadSymbols.PathNameLength = 0;
            AdditionalData = NULL;
        }

        MessageHeader.Length = sizeof(WaitStateChange);
        MessageHeader.Buffer = (PCHAR)&WaitStateChange;

        //
        // Send packet to the kernel debugger on the host machine, wait
        // for the reply.
        //

        Status = KdpSendWaitContinue(
                    PACKET_TYPE_KD_STATE_CHANGE64,
                    &MessageHeader,
                    AdditionalData,
                    ContextRecord
                    );

    } while (Status == ContinueProcessorReselected);

    return (BOOLEAN) Status;
}

VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response to a read physical memory
    state manipulation message. Its function is to read physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID64 VirtualAddress;
    PHYSICAL_ADDRESS Source;
    UCHAR UNALIGNED *Destination;
    ULONG NumberBytes;
    ULONG BytesLeft;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // make sure that nothing but a read memory message was transmitted
    //

    ASSERT(AdditionalData->Length == 0);

    //
    // Trim transfer count to fit in a single message
    //

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }

    //
    // Since the MmDbgTranslatePhysicalAddress64 only maps in one physical
    // page at a time (on non-alpha systems),
    // we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  It is important that we
    // access physical memory on naturally-aligned boundaries and with the
    // largest size possible.  (We could be accessing memory-mapped I/O
    // space).  These rules allow kdexts to read physical memory reliably.
    //

    Source.QuadPart = a->TargetBaseAddress;
    Destination = AdditionalData->Buffer;
    while (Length > 0) {
        VirtualAddress = MmDbgTranslatePhysicalAddress64(Source);
        if (VirtualAddress == NULL64) {
            break;
        }
        NumberBytes = PAGE_SIZE - BYTE_OFFSET(Source.LowPart);
        if (NumberBytes > Length) {
            NumberBytes = Length;
        }

        KdpMoveMemory(Destination, VirtualAddress, NumberBytes);
        Destination += NumberBytes;

        Source.QuadPart += NumberBytes;
        Length -= NumberBytes;
        AdditionalData->Length += (USHORT)NumberBytes;
    }

    if (Length == 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    a->ActualBytesRead = AdditionalData->Length;

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );
}

VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response to a write physical memory
    state manipulation message. Its function is to write physical memory
    and return.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    STRING MessageHeader;
    ULONG Length;
    PVOID64 VirtualAddress;
    PHYSICAL_ADDRESS Destination;
    UCHAR UNALIGNED *Source;
    ULONG NumberBytes;
    ULONG BytesLeft;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;


    Length = a->TransferCount;

    //
    // The following code depends on the existence of the
    // MmDbgTranslatePhysicalAddress64() routine.  This has only been
    // implemented for Alpha.
    //

    //
    // Since the MmDbgTranslatePhysicalAddress64 only maps in one physical
    // page at a time, we need to break the memory move up into smaller
    // moves which don't cross page boundaries.  It is important that we
    // access physical memory on naturally-aligned boundaries and with the
    // largest size possible.  (We could be accessing memory-mapped I/O
    // space).  These rules allow kdexts to write physical memory reliably.
    //

    Source = AdditionalData->Buffer;
    Destination.QuadPart = a->TargetBaseAddress;
    while (Length > 0) {
        VirtualAddress = MmDbgTranslatePhysicalAddress64(Destination);
        if (VirtualAddress == NULL64) {
            break;
        }
        NumberBytes = PAGE_SIZE - BYTE_OFFSET(Destination.LowPart);
        if (NumberBytes > Length) {
            NumberBytes = Length;
        }

        KdpMoveMemory(VirtualAddress, Source, NumberBytes);
        Source += NumberBytes;

        Destination.QuadPart += NumberBytes;
        Length -= NumberBytes;
        a->ActualBytesWritten += NumberBytes;
    }

    if (Length == 0) {
        m->ReturnStatus = STATUS_SUCCESS;
    } else {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
    }

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  NULL
                  );
}

#if i386
VOID
KdpProcessInternalBreakpoint (
    ULONG BreakpointNumber
    )
{
    static BOOLEAN timerStarted = FALSE;
    LARGE_INTEGER dueTime;

    if ( !(KdpInternalBPs[BreakpointNumber].Flags &
           DBGKD_INTERNAL_BP_FLAG_COUNTONLY) ) {
        return;     // We only deal with COUNTONLY breakpoints
    }

    //
    // We've hit a real internal breakpoint; make sure the timeout is
    // kicked off.
    //

    if ( !timerStarted ) { // ok, maybe there's a prettier way to do this.
        dueTime.LowPart = (ULONG)(-1 * 10 * 1000 * 1000);
        dueTime.HighPart = -1;
        KeInitializeDpc(
            &InternalBreakpointCheckDpc,
            &InternalBreakpointCheck,
            NULL
            );
        KeInitializeTimer( &InternalBreakpointTimer );
        KeSetTimer(
            &InternalBreakpointTimer,
            dueTime,
            &InternalBreakpointCheckDpc
            );
        timerStarted = TRUE;
    }

    KdpInternalBPs[BreakpointNumber].Calls++;

} // KdpProcessInternalBreakpoint
#endif

VOID
KdpGetVersion(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This function returns to the caller a general information packet
    that contains useful information to a debugger.  This packet is also
    used for a debugger to determine if the writebreakpointex and
    readbreakpointex apis are available.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{
    STRING                   messageHeader;


    messageHeader.Length = sizeof(*m);
    messageHeader.Buffer = (PCHAR)m;

    RtlZeroMemory(&m->u.GetVersion64, sizeof(m->u.GetVersion64));
    //
    // the current build number (0x0100 in the major version marks us as xbox)
    //
    m->u.GetVersion64.MinorVersion = VER_PRODUCTBUILD;
#if DBG
    m->u.GetVersion64.MajorVersion = (0x000C | 0x0100);
#else  // DBG
    m->u.GetVersion64.MajorVersion = (0x000F | 0x0100);
#endif // DBG

    //
    // kd protocol version number.  this should be incremented if the
    // protocol changes.
    //
    m->u.GetVersion64.ProtocolVersion = 5;
    m->u.GetVersion64.Flags = DBGKD_VERS_FLAG_DATA;

#if !defined(NT_UP)
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_MP;
#endif

#if defined(_M_IX86)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_I386;
#elif defined(_M_MRX000)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_R4000;
#elif defined(_M_ALPHA)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_ALPHA;
#if defined(_AXP64_)
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;
#endif
#elif defined(_M_PPC)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_POWERPC;
#elif defined(_M_IA64)
    m->u.GetVersion64.MachineType = IMAGE_FILE_MACHINE_IA64;
    m->u.GetVersion64.Flags |= DBGKD_VERS_FLAG_PTR64;
#else
#error( "unknown target machine" );
#endif

    //
    // address of the loader table
    //
    m->u.GetVersion64.PsLoadedModuleList = (ULONG64)(LONG64)(LONG_PTR)&KdLoadedModuleList;

    m->u.GetVersion64.KernBase = (ULONG64)(LONG64)(LONG_PTR)PsNtosImageBase;

    m->u.GetVersion64.DebuggerDataList = (ULONG64)(LONG64)(LONG_PTR)&KdpDebuggerDataListHead;

    //
    // the usual stuff
    //
    m->ReturnStatus = STATUS_SUCCESS;
    m->ApiNumber = DbgKdGetVersionApi;

    KdpSendPacket(PACKET_TYPE_KD_STATE_MANIPULATE,
                  &messageHeader,
                  NULL
                 );

    return;
} // KdGetVersion

NTSTATUS
KdpNotSupported(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine returns STATUS_UNSUCCESSFUL to the debugger

Arguments:

    m - Supplies a DBGKD_MANIPULATE_STATE64 struct to answer with

Return Value:

    0, to indicate that the system should not continue

--*/

{
    STRING          MessageHeader;

    //
    // setup packet
    //
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;
    m->ReturnStatus = STATUS_UNSUCCESSFUL;

    //
    // send back our response
    //
    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return 0;
} // KdpNotSupported

VOID
KdpCauseBugCheck(
    IN PDBGKD_MANIPULATE_STATE64 m
    )

/*++

Routine Description:

    This routine causes a bugcheck.  It is used for testing the debugger.

Arguments:

    m - Supplies the state manipulation message.

Return Value:

    None.

--*/

{

    KeBugCheckEx( MANUALLY_INITIATED_CRASH, 0, 0, 0, 0 );

} // KdCauseBugCheck

NTSTATUS
KdpWriteBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write breakpoint state 'ex'
    manipulation message.  Its function is to clear breakpoints, write
    new breakpoints, and continue the target system.  The clearing of
    breakpoints is conditional based on the presence of breakpoint handles.
    The setting of breakpoints is conditional based on the presence of
    valid, non-zero, addresses.  The continueing of the target system
    is conditional based on a non-zero continuestatus.

    This api allows a debugger to clear breakpoints, add new breakpoint,
    and continue the target system all in one api packet.  This reduces the
    amount of traffic across the wire and greatly improves source stepping.


Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX       a = &m->u.BreakPointEx;
    PDBGKD_WRITE_BREAKPOINT64 b;
    STRING                    MessageHeader;
    ULONG                     i;
    DBGKD_WRITE_BREAKPOINT64  BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
                         a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdpSendPacket(
                      PACKET_TYPE_KD_STATE_MANIPULATE,
                      &MessageHeader,
                      AdditionalData
                      );
        return m->ReturnStatus;
    }

    KdpMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    //
    // assume success
    //
    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointHandle) {
            if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
            b->BreakPointHandle = 0;
        }
    }

    //
    // loop thru the breakpoint addesses passed in from the debugger and
    // add any new breakpoints that have a non-zero address
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (b->BreakPointAddress) {
            b->BreakPointHandle = KdpAddBreakpoint( (PVOID)b->BreakPointAddress );
            if (!b->BreakPointHandle) {
                m->ReturnStatus = STATUS_UNSUCCESSFUL;
            }
        }
    }

    //
    // send back our response
    //

    KdpMoveMemory(AdditionalData->Buffer,
                  (PUCHAR)BpBuf,
                  a->BreakPointCount*sizeof(DBGKD_WRITE_BREAKPOINT64));

    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );

    //
    // return the caller's continue status value.  if this is a non-zero
    // value the system is continued using this value as the continuestatus.
    //
    return a->ContinueStatus;
}

VOID
KdpRestoreBreakPointEx(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a restore breakpoint state 'ex'
    manipulation message.  Its function is to clear a list of breakpoints.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_BREAKPOINTEX         a = &m->u.BreakPointEx;
    PDBGKD_RESTORE_BREAKPOINT   b;
    STRING                      MessageHeader;
    ULONG                       i;
    DBGKD_RESTORE_BREAKPOINT    BpBuf[BREAKPOINT_TABLE_SIZE];


    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    //
    // verify that the packet size is correct
    //
    if (AdditionalData->Length !=
                       a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT)) {
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        KdpSendPacket(
                      PACKET_TYPE_KD_STATE_MANIPULATE,
                      &MessageHeader,
                      AdditionalData
                      );
        return;
    }

    KdpMoveMemory((PUCHAR)BpBuf,
                  AdditionalData->Buffer,
                  a->BreakPointCount*sizeof(DBGKD_RESTORE_BREAKPOINT));

    //
    // assume success
    //
    m->ReturnStatus = STATUS_SUCCESS;

    //
    // loop thru the breakpoint handles passed in from the debugger and
    // clear any breakpoint that has a non-zero handle
    //
    b = BpBuf;
    for (i=0; i<a->BreakPointCount; i++,b++) {
        if (!KdpDeleteBreakpoint(b->BreakPointHandle)) {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
    }

    //
    // send back our response
    //
    KdpSendPacket(
                  PACKET_TYPE_KD_STATE_MANIPULATE,
                  &MessageHeader,
                  AdditionalData
                  );
}

VOID
KdpSearchMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function implements a memory pattern searcher.  This will
    find an instance of a pattern that begins in the range
    SearchAddress..SearchAddress+SearchLength.  The pattern may
    end outside of the range.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies the pattern to search for

Return Value:

    None.

--*/

{
    PUCHAR Pattern = AdditionalData->Buffer;
    ULONG_PTR StartAddress = (ULONG_PTR)m->u.SearchMemory.SearchAddress;
    ULONG_PTR EndAddress = (ULONG_PTR)(StartAddress + m->u.SearchMemory.SearchLength);
    ULONG PatternLength = m->u.SearchMemory.PatternLength;

    STRING MessageHeader;
    ULONG MaskIndex;
    PUCHAR PatternTail;
    PUCHAR DataTail;
    ULONG TailLength;
    ULONG Data;
    ULONG FirstWordPattern[4];
    ULONG FirstWordMask[4];


    //
    // On failure, return STATUS_NO_MORE_ENTRIES.  DON'T RETURN
    // STATUS_UNSUCCESSFUL!  That return status indicates that the
    // operation is not supported, and the debugger will fall back
    // to a debugger-side search.
    //

    m->ReturnStatus = STATUS_NO_MORE_ENTRIES;

    //
    // Do a fast search for the beginning of the pattern
    //

    if (PatternLength > 3) {
        FirstWordMask[0] = 0xffffffff;
    } else {
        FirstWordMask[0] = 0xffffffff >> (8*(4-PatternLength));
    }

    FirstWordMask[1] = FirstWordMask[0] << 8;
    FirstWordMask[2] = FirstWordMask[1] << 8;
    FirstWordMask[3] = FirstWordMask[2] << 8;

    FirstWordPattern[0] = 0;
    KdpQuickMoveMemory((PVOID)FirstWordPattern,
                       Pattern,
                       PatternLength < 5 ? PatternLength : 4);

    FirstWordPattern[1] = FirstWordPattern[0] << 8;
    FirstWordPattern[2] = FirstWordPattern[1] << 8;
    FirstWordPattern[3] = FirstWordPattern[2] << 8;


/*
{
    int i;
    for (i = 0; i < (int)PatternLength; i++) {
        KdpDprintf("%08x: %02x\n", &Pattern[i], Pattern[i]);
    }
    for (i = 0; i < 4; i++) {
        KdpDprintf("%d: %08x %08x\n", i, FirstWordPattern[i], FirstWordMask[i]);
    }
}
*/



    //
    // Get starting mask
    //

    MaskIndex = (ULONG) (StartAddress & 3);
    StartAddress = StartAddress & ~3;

    //
    // check that the starting page is available
    //

    if (MmDbgReadCheck((PVOID)StartAddress) == NULL) {
        StartAddress = (StartAddress + PAGE_SIZE) & ~(PAGE_SIZE-1);
        MaskIndex = 0;
    }

    while (StartAddress < EndAddress) {

        //
        // check when starting a new page
        //
        if ((StartAddress & (PAGE_SIZE-1)) == 0) {
            if (MmDbgReadCheck((PVOID)StartAddress) == NULL) {
                StartAddress = StartAddress + PAGE_SIZE;
                continue;
            }
        }

        //
        // search for a match in each of the 4 starting positions
        //

        Data = *(ULONG*)StartAddress;
//KdpDprintf("\n%08x: %08x ", StartAddress, Data);

        for ( ; MaskIndex < 4; MaskIndex++) {
//KdpDprintf(" %d", MaskIndex);

            if ( (Data & FirstWordMask[MaskIndex]) == FirstWordPattern[MaskIndex]) {

                //
                // first word matched
                //

                if ( (4-MaskIndex) >= PatternLength ) {

                    //
                    // string is all in this word; good match
                    //
//KdpDprintf(" %d hit, complete\n", MaskIndex);

                    m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                    m->ReturnStatus = STATUS_SUCCESS;
                    goto done;

                } else {

                    //
                    // string is longer; see if tail matches
                    //
//KdpDprintf(" %d hit, check tail\n", MaskIndex);

                    PatternTail = Pattern + 4 - MaskIndex;
                    DataTail = (PUCHAR)StartAddress + 4;
                    TailLength = PatternLength - 4 + MaskIndex;

//KdpDprintf("Pattern == %08x\n", Pattern);
//KdpDprintf("PatternTail == %08x\n", PatternTail);
//KdpDprintf("DataTail == %08x\n", DataTail);

                    while (TailLength) {
                        if ( ((ULONG_PTR)DataTail & (PAGE_SIZE-1)) == 0 &&
                             MmDbgReadCheck(DataTail) == FALSE) {
//KdpDprintf("Tail failed: page not present at %08x\n", DataTail);
                            break;
                        } else
{
//KdpDprintf("D: %02x  P: %02x\n", *DataTail, *PatternTail);

                        if (*DataTail != *PatternTail) {
//KdpDprintf("Tail failed at %08x\n", DataTail);
                            break;
                        } else {
                            DataTail++;
                            PatternTail++;
                            TailLength--;
                        }
}
                    }

                    if (TailLength == 0) {

                        //
                        // A winner
                        //

                        m->u.SearchMemory.FoundAddress = StartAddress + MaskIndex;
                        m->ReturnStatus = STATUS_SUCCESS;
                        goto done;

                    }
                }
            }
        }

        StartAddress += 4;
        MaskIndex = 0;
    }

done:
//KdpDprintf("\n");
    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );

}


VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 Message
    )

/*++

Routine Description:


Arguments:

    Message - Supplies the state manipulation message.

Return Value:

    None.

Description:

    This function gets called when the !chklowmem
    debugger extension is used.

--*/

{
//+silviuc: move to a header
#if defined (_X86PAE_)
    LOGICAL
        MiCheckPhysicalPagePattern (
        PFN_NUMBER Page,
        PULONG CorruptionOffset
        );

    extern PFN_NUMBER MmLowestPhysicalPage;
    extern PFN_NUMBER MmHighestPhysicalPage;
    extern LOGICAL MiNoLowMemory;
#endif // #if defined (_X86PAE_)
//-silviuc

    STRING MessageHeader;
    PFN_NUMBER Page;
    PHYSICAL_ADDRESS P;
    PVOID64 VirtualAddress;
    ULONG CorruptionOffset;

    Message->ReturnStatus = STATUS_SUCCESS;
    MessageHeader.Length = sizeof(*Message);
    MessageHeader.Buffer = (PCHAR)Message;

    if (KdpSearchPhysicalMemoryRequested()) {

        //
        // This is a !search kd extension call.
        //

        KdpSearchPhysicalPageRange();
    }
    else {

        //
        // Check PAE low physical memory
        //

#if defined (_X86PAE_)

        if (MiNoLowMemory) {

            for (Page = MmLowestPhysicalPage;
                Page < MmHighestPhysicalPage && Page < 1024 * 1024;
                Page += 1) {


                if (! MiCheckPhysicalPagePattern (Page, &CorruptionOffset)) {
                    Message->ReturnStatus = Page;
                    break;
                }
            }
        }

#endif // #if defined (_X86PAE_)
    }

    //
    // Acknowledge the packet received.
    //

    KdpSendPacket (
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

//
// !search support routines
//

ULONG
KdpSearchHammingDistance (
    ULONG_PTR Left,
    ULONG_PTR Right
    )
/*++

Routine Description:

    This routine computes the Hamming distance (# of positions where the
    values are different).

    If this function becomes a bottleneck we should switch to a function
    table version.

Arguments:

    Left, Right operand.

Return Value:

    Hamming distance.

Environment:

    Any.

--*/

{
    ULONG_PTR Value;
    ULONG Index;
    ULONG Distance;

    Value = Left ^ Right;
    Distance = 0;

    for (Index = 0; Index < 8 * sizeof(ULONG_PTR); Index++) {

        if ((Value & (ULONG_PTR)0x01)) {

            Distance += 1;
        }

        Value >>= 1;
    }

    return Distance;
}

LOGICAL
KdpSearchPhysicalPage (
    IN PFN_NUMBER PageFrameIndex,
    ULONG_PTR RangeStart,
    ULONG_PTR RangeEnd,
    ULONG Flags
    )
/*++

Routine Description:

    This routine searches the physical page corresponding to a
    certain PFN index for any ULONG_PTR values in range [Start..End].

Arguments:

    PageFrameIndex - PFN index

    RangeStart - lowest possible value searched for

    RangeEnd - highest possible value searched for

    Flags - flags to control the search

Return Value:

    TRUE if a hit has been found, FALSE otherwise.
    The function stops after the first hit in the page is
    encountered and the infromation related to the hit (PFN index,
    offset, corrsponding VA) is registered in the hit database.

Environment:

    Call triggered only from Kd extension.

--*/

{
    PCHAR Va;
    ULONG Index;
    PHYSICAL_ADDRESS Pa;
    ULONG_PTR Value;

    //
    // Map the physical page using the debug PTE.
    //

    Pa.QuadPart = ((ULONGLONG)PageFrameIndex) << PAGE_SHIFT;

    Va = (PCHAR) MmDbgTranslatePhysicalAddress64 (Pa);

    for (Index = 0; Index < PAGE_SIZE - sizeof(ULONG_PTR); Index += 1, Va += 1) {

        Value = *((PULONG_PTR)Va);

        if ((Value >= RangeStart && Value <= RangeEnd)
            || KdpSearchHammingDistance(Value, RangeStart) == 1) {

            if (KdpSearchPageHitIndex < SEARCH_PAGE_HIT_DATABASE_SIZE) {

                KdpSearchPageHits[KdpSearchPageHitIndex] = PageFrameIndex;
                KdpSearchPageHitOffsets[KdpSearchPageHitIndex] = Index;

                KdpSearchPageHitIndex += 1;
            }

            if ((Flags & KDP_SEARCH_ALL_OFFSETS_IN_PAGE)) {

                continue;
            }
            else {

                return TRUE;
            }
        }
    }

    return FALSE;
}

LOGICAL
KdpSearchPhysicalMemoryRequested (
    VOID
    )
/*++

Routine Description:

    This routine determines if a physical range search has been
    requested. This is controlled by a global variable set in
    the `!search' debug extension.

Arguments:

    None

Return Value:

    TRUE if physical range search was requested.


Environment:

    Call triggered only from Kd extension.

--*/
{
    if (KdpSearchInProgress) {

        return TRUE;
    }
    else {

        return FALSE;
    }
}

LOGICAL
KdpSearchPhysicalPageRange (
    VOID
    )
/*++

Routine Description:

    This routine will start a search in a range of physical pages in case
    `KdpSearchInProgress' is true. the parameters for the search are picked up
    from global vairiables that are set inside a kernel debugger extension.

Arguments:

    None

Return Value:

    TRUE if the function executed a search and FALSE otherwise.
    The results of the search are specified in the KdpSearchPageHits
    and related variables. this global variables offers the mechanism
    for the debugger extension to pickup the results of the search.


Environment:

    Call triggered only from Kd extension.

    Note. The !search extension make sure that the range requested
    is part of the system memory therefore we do not have to
    worry about sparse PFN databases here.

--*/

{
    PFN_NUMBER CurrentFrame;
    ULONG Flags;

    //
    // The debugger extension is supposed to set KdpSearchInProgress
    // to TRUE if a search is requested.
    //

    if (!KdpSearchInProgress) {

        return FALSE;
    }


    Flags = 0;

    //
    // If the search range is only one page we will give all
    // hits inside a page. By default we get only the first hit inside
    // a page.
    //

    if (KdpSearchEndPageFrame == KdpSearchStartPageFrame) {

        KdpSearchEndPageFrame += 1;

        Flags |= KDP_SEARCH_ALL_OFFSETS_IN_PAGE;
    }

    for (CurrentFrame = KdpSearchStartPageFrame;
         CurrentFrame < KdpSearchEndPageFrame;
         CurrentFrame += 1) {

        KdpSearchPhysicalPage (CurrentFrame,
                              KdpSearchAddressRangeStart,
                              KdpSearchAddressRangeEnd,
                              Flags);

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\io\write.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module contains the code to implement the NtWriteFile system service.

--*/

#include "iop.h"

NTSTATUS
NtWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's Buffer to the
    file associated with FileHandle starting at StartingBlock|ByteOffset.
    The actual number of bytes written to the file will be returned in the
    second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    Buffer - Supplies the address of the buffer containing data to be written
        to the file.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN synchronousIo;
    PKEVENT eventObject = (PKEVENT) NULL;
    LARGE_INTEGER fileOffset = {0,0};

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->WriteAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserBuffer = Buffer;
    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;

    //
    // Now determine whether or not we should automatically lock the user's
    // buffer for direct I/O.
    //

    if ((deviceObject->Flags & DO_DIRECT_IO) && (Length != 0)) {
        IoLockUserBuffer(irp, Length);
    }

    //
    // If this write operation is to be performed without any caching, set the
    // appropriate flag in the IRP so no caching is performed.
    //

    if (fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) {
        irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    } else {
        irp->Flags |= IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION;
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.BufferOffset = 0;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}

NTSTATUS
NtWriteFileGather(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PFILE_SEGMENT_ELEMENT SegmentArray,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL
    )

/*++

Routine Description:

    This service writes Length bytes of data from the caller's segment
    buffers to the file associated with FileHandle starting at
    StartingBlock|ByteOffset. The actual number of bytes written to the file
    will be returned in the second longword of the IoStatusBlock.

    If the writer has the file open for APPEND access, then the data will be
    written to the current EOF mark.  The StartingBlock and ByteOffset are
    ignored if the caller has APPEND access.

Arguments:

    FileHandle - Supplies a handle to the file to be written.

    Event - Optionally supplies an event to be set to the Signaled state when
        the write operation is complete.

    ApcRoutine - Optionally supplies an APC routine to be executed when the
        write operation is complete.

    ApcContext - Supplies a context parameter to be passed to the APC routine
        when it is invoked, if an APC routine was specified.

    IoStatusBlock - Supplies the address of the caller's I/O status block.

    SegmentArray - An array of buffer segment pointers that specify
        where the data should be read from.

    Length - Length, in bytes, of the data to be written to the file.

    ByteOffset - Specifies the starting byte offset within the file to begin
        the write operation.  If not specified and the file is open for
        synchronous I/O, then the current file position is used.  If the
        file is not opened for synchronous I/O and the parameter is not
        specified, then it is in error.

Return Value:

    The status returned is success if the write operation was properly queued
    to the I/O system.  Once the write completes the status of the operation
    can be determined by examining the Status field of the I/O status block.

Notes:
    This interface is only supported for no buffering and asynchronous I/O.

--*/

{
    PIRP irp;
    NTSTATUS status;
    PFILE_OBJECT fileObject;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpSp;
    PKEVENT eventObject = (PKEVENT) NULL;
    ULONG elementCount;
    LARGE_INTEGER fileOffset = {0,0};
    BOOLEAN synchronousIo;

    PAGED_CODE();

    //
    // Reference the file object so the target device can be found and the
    // access rights mask can be used in the following checks for callers in
    // user mode.  Note that if the handle does not refer to a file object,
    // then it will fail.
    //

    status = ObReferenceObjectByHandle( FileHandle,
                                        &IoFileObjectType,
                                        (PVOID *) &fileObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    if (!fileObject->WriteAccess) {
        ObDereferenceObject( fileObject );
        return STATUS_ACCESS_DENIED;
    }

    //
    // Get the address of the target device object.
    //

    deviceObject = fileObject->DeviceObject;

    //
    // Verify this is a valid gather write request.  In particular it must
    // be non-cached and directed at a file system device.
    //

    if (!(fileObject->Flags & FO_NO_INTERMEDIATE_BUFFERING) ||
        (deviceObject->DeviceType != FILE_DEVICE_DISK_FILE_SYSTEM &&
         deviceObject->DeviceType != FILE_DEVICE_CD_ROM_FILE_SYSTEM)) {

        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    elementCount = BYTES_TO_PAGES( Length );

    //
    // If this file has an I/O completion port associated w/it, then
    // ensure that the caller did not supply an APC routine, as the
    // two are mutually exclusive methods for I/O completion
    // notification.
    //

    if (fileObject->CompletionContext && IopApcRoutinePresent( ApcRoutine )) {
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT( ByteOffset )) {
        fileOffset = *ByteOffset;
    }

    //
    // Get the address of the event object and set the event to the Not-
    // Signaled state, if an event was specified.  Note here too, that if
    // the handle does not refer to an event, then the reference will fail.
    //

    if (ARGUMENT_PRESENT( Event )) {
        status = ObReferenceObjectByHandle( Event,
                                            &ExEventObjectType,
                                            (PVOID *) &eventObject );
        if (!NT_SUCCESS( status )) {
            ObDereferenceObject( fileObject );
            return status;
        } else {
            KeClearEvent( eventObject );
        }
    }

    //
    // Make a special check here to determine whether this is a synchronous
    // I/O operation.  If it is, then wait here until the file is owned by
    // the current thread.  If the wait terminates with an alerted status,
    // then cleanup and return the alerted status.  This allows the caller
    // specify FILE_SYNCHRONOUS_IO_ALERT as a synchronous I/O option.
    //
    // If everything works, then check to see whether a ByteOffset parameter
    // was supplied.  If not, or if it was and it is set to the "use file
    // pointer position", then initialize the file offset to be whatever
    // the current byte offset into the file is according to the file pointer
    // context information in the file object.
    //

    if (fileObject->Flags & FO_SYNCHRONOUS_IO) {

        IopAcquireFileObjectLock(fileObject);

        synchronousIo = TRUE;

        if ((!ARGUMENT_PRESENT( ByteOffset ) && !fileOffset.LowPart ) ||
            (fileOffset.LowPart == FILE_USE_FILE_POINTER_POSITION &&
            fileOffset.HighPart == -1 )) {
            fileOffset = fileObject->CurrentByteOffset;
        }

    } else if (!ARGUMENT_PRESENT( ByteOffset )) {

        //
        // The file is not open for synchronous I/O operations, but the
        // caller did not specify a ByteOffset parameter.  This is an error
        // situation, so cleanup and return with the appropriate status.
        //

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;

    } else {

        //
        // This is not a synchronous I/O operation.
        //

        synchronousIo = FALSE;
    }

    //
    //  Negative file offsets are illegal.
    //

    if (fileOffset.HighPart < 0 &&
        (fileOffset.HighPart != -1 ||
        fileOffset.LowPart != FILE_WRITE_TO_END_OF_FILE)) {

        if (eventObject) {
            ObDereferenceObject( eventObject );
        }
        if (synchronousIo) {
            IopReleaseFileObjectLock( fileObject );
        }
        ObDereferenceObject( fileObject );
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Set the file object to the Not-Signaled state.
    //

    KeClearEvent( &fileObject->Event );

    //
    // Allocate and initialize the I/O Request Packet (IRP) for this operation.
    //

    irp = IoAllocateIrp( deviceObject->StackSize );
    if (!irp) {

        //
        // An IRP could not be allocated.  Cleanup and return an appropriate
        // error status code.
        //

        return IopAllocateIrpCleanup( fileObject, eventObject );
    }
    irp->Tail.Overlay.OriginalFileObject = fileObject;
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Fill in the service independent parameters in the IRP.
    //

    irp->UserEvent = eventObject;
    irp->UserIosb = IoStatusBlock;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = ApcRoutine;
    irp->Overlay.AsynchronousParameters.UserApcContext = ApcContext;
    irp->Flags |= IRP_NOCACHE | IRP_WRITE_OPERATION | IRP_DEFER_IO_COMPLETION |
        IRP_SCATTER_GATHER_OPERATION;

    //
    // Get a pointer to the stack location for the first driver.  This will be
    // used to pass the original function codes and parameters.
    //

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->MajorFunction = IRP_MJ_WRITE;
    irpSp->FileObject = fileObject;

    //
    // This is a direct I/O operation.  Lock down and clone the pages in the
    // segment array.  If the target device doesn't support scatter/gather I/O,
    // then also map a virtual buffer that describes the pages.
    //

    if (Length != 0) {

        status = MmLockSelectedIoPages(SegmentArray, Length, irp,
            (BOOLEAN)((deviceObject->Flags & DO_SCATTER_GATHER_IO) == 0));

        if (!NT_SUCCESS(status)) {
            IopExceptionCleanup(fileObject, irp, eventObject);
            return status;
        }
    }

    //
    // Copy the caller's parameters to the service-specific portion of the
    // IRP.
    //

    irpSp->Parameters.Write.Length = Length;
    irpSp->Parameters.Write.BufferOffset = 0;
    irpSp->Parameters.Write.ByteOffset = fileOffset;

    //
    // Queue the packet, call the driver, and synchronize appopriately with
    // I/O completion.
    //

    status = IopSynchronousServiceTail( deviceObject,
                                        irp,
                                        fileObject,
                                        TRUE,
                                        synchronousIo );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdcomio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcomio.c

Abstract:

    This module implements the I/O comunications for the portable kernel
    debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"

ULONG
KdpComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine computes the checksum for the string passed in.

Arguments:

    Buffer - Supplies a pointer to the string.

    Length - Supplies the length of the string.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/

{

    ULONG Checksum = 0;

    while (Length > 0) {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }
    return Checksum;
}

USHORT
KdpReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    )

/*++

Routine Description:

    This routine waits for a packet header leader.

Arguments:

    PacketType - supplies the type of packet we are expecting.

    PacketLeader - supplies a pointer to a ulong variable to receive
                   packet leader bytes.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input, PreviousByte = 0;
    ULONG PacketId = 0;
    ULONG Index;
    ULONG ReturnCode;
    BOOLEAN BreakinDetected = FALSE;

    //
    // NOTE - With all the interrupts being off, it is very hard
    // to implement the actual timeout code. (Maybe, by reading the CMOS.)
    // Here we use a loop count to wait about 3 seconds.  The CpGetByte
    // will return with error code = CP_GET_NODATA if it cannot find data
    // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
    //

    Index = 0;
    do {
        ReturnCode = KdPortGetByte(&Input);
        if (ReturnCode == CP_GET_NODATA) {
            if (BreakinDetected) {
                KdpControlCPending = TRUE;
                return KDP_PACKET_RESEND;
            } else {
                return KDP_PACKET_TIMEOUT;
            }
        } else if (ReturnCode == CP_GET_ERROR) {
            Index = 0;
            continue;
        } else {                    // if (ReturnCode == CP_GET_SUCCESS)
            if ( Input == PACKET_LEADER_BYTE ||
                 Input == CONTROL_PACKET_LEADER_BYTE ) {
                if ( Index == 0 ) {
                    PreviousByte = Input;
                    Index++;
                } else if (Input == PreviousByte ) {
                    Index++;
                } else {
                    PreviousByte = Input;
                    Index = 1;
                }
            } else {

                //
                // If we detect breakin character, we need to verify it
                // validity.  (It is possible that we missed a packet leader
                // and the breakin character is simply a data byte in the
                // packet.)
                // Since kernel debugger send out breakin character ONLY
                // when it is waiting for State Change packet.  The breakin
                // character should not be followed by any other character
                // except packet leader byte.
                //

                if ( Input == BREAKIN_PACKET_BYTE ) {
                    BreakinDetected = TRUE;
                } else {

                    //
                    // The following statement is ABSOLUTELY necessary.
                    //

                    BreakinDetected = FALSE;
                }
                Index = 0;
            }
        }
    } while ( Index < 4 );

    if (BreakinDetected) {
        KdpControlCPending = TRUE;
    }

    //
    // return the packet leader and FALSE to indicate no resend is needed.
    //

    if ( Input == PACKET_LEADER_BYTE ) {
        *PacketLeader = PACKET_LEADER;
    } else {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }

    KdDebuggerNotPresent = FALSE;
    return KDP_PACKET_RECEIVED;
}

ULONG
KdpReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads a string from the kernel debugger port.

Arguments:

    Destination - Supplies a pointer to the input string.

    Length - Supplies the length of the string to be read.

Return Value:

    CP_GET_SUCCESS is returned if string is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{

    UCHAR Input;
    ULONG ReturnCode;

    //
    // Read bytes until either a error is encountered or the entire string
    // has been read.
    //
    while (Length > 0) {
        ReturnCode = KdPortGetByte(&Input);
        if (ReturnCode != CP_GET_SUCCESS) {
            return ReturnCode;
        } else {
            *Destination++ = Input;
            Length -= 1;
        }
    }
    return CP_GET_SUCCESS;
}

VOID
KdpSendString (
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes a string to the kernel debugger port.

Arguments:

    Source - Supplies a pointer to the output string.

    Length - Supplies the length of the string to be written.

Return Value:

    None.

--*/

{

    UCHAR Output;

    //
    // Write bytes to the kernel debugger port.
    //

    while (Length > 0) {
        Output = *Source++;
        KdPortPutByte(Output);
        Length -= 1;
    }
    return;
}

VOID
KdpSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) PacketId )) {
        PacketHeader.PacketId = PacketId;
    }
    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;
    KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

    return;
}

ULONG
KdpReceivePacket (
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    )

/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is KdPrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input;
    ULONG MessageLength;
    KD_PACKET PacketHeader;
    ULONG ReturnCode;
    ULONG Checksum;

WaitForPacketLeader:

    //
    // Read Packet Leader
    //

    ReturnCode = KdpReceivePacketLeader(PacketType, &PacketHeader.PacketLeader);

    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //

    if (ReturnCode != KDP_PACKET_TIMEOUT) {
        KdpNumberRetries = KdpRetryCount;
    }
    if (ReturnCode != KDP_PACKET_RECEIVED) {
        return ReturnCode;
    }

    //
    // Read packet type.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketType,
                                  sizeof(PacketHeader.PacketType));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

            //
            // If read error and it is for a control packet, simply
            // preptend that we have not seen this packet.  Hopefully
            // we will receive the packet we desire which automatically acks
            // the packet we just sent.
            //

            goto WaitForPacketLeader;
        } else {

            //
            // if read error while reading data packet, we have to ask
            // kernel debugger to resend us the packet.
            //

            goto SendResendPacket;
        }
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //

    if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {
        return KDP_PACKET_RESEND;
    }

    //
    // Read data length.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.ByteCount,
                                  sizeof(PacketHeader.ByteCount));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read Packet Id.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketId,
                                  sizeof(PacketHeader.PacketId));

    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read packet checksum.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.Checksum,
                                  sizeof(PacketHeader.Checksum));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // A complete packet header is received.  Check its validity and
    // perform appropriate action depending on packet type.
    //

    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {
        if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (PacketHeader.PacketId !=
                (KdpNextPacketIdToSend & ~SYNC_PACKET_ID))  {
                goto WaitForPacketLeader;
            } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {
                KdpNextPacketIdToSend ^= 1;
                return KDP_PACKET_RECEIVED;
            } else {
                goto WaitForPacketLeader;
            }
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            KdpNextPacketIdToSend = INITIAL_PACKET_ID;
            KdpPacketIdExpected = INITIAL_PACKET_ID;
            KdpSendControlPacket(PACKET_TYPE_KD_RESET, 0L);
            return KDP_PACKET_RESEND;
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {
            return KDP_PACKET_RESEND;
        } else {

            //
            // Invalid packet header, ignore it.
            //

            goto WaitForPacketLeader;
        }

    //
    // The packet header is for data packet (not control packet).
    //

    } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

        //
        // if we are waiting for ACK packet ONLY
        // and we receive a data packet header, check if the packet id
        // is what we expected.  If yes, assume the acknowledge is lost (but
        // sent), ask sender to resend and return with PACKET_RECEIVED.
        //

        if (PacketHeader.PacketId == KdpPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdpNextPacketIdToSend ^= 1;
            return KDP_PACKET_RECEIVED;
        } else {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    //
    // Check ByteCount received is valid
    //

    MessageLength = MessageHeader->MaximumLength;
    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {
        goto SendResendPacket;
    }
    *DataLength = PacketHeader.ByteCount - MessageLength;

    //
    // Read the message header.
    //

    ReturnCode = KdpReceiveString(MessageHeader->Buffer, MessageLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Read the message data.
    //

    ReturnCode = KdpReceiveString(MessageData->Buffer, *DataLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageData->Length = (USHORT)*DataLength;

    //
    // Read packet trailing byte
    //

    ReturnCode = KdPortGetByte(&Input);
    if (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE) {
        goto SendResendPacket;
    }

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType != PacketHeader.PacketType) {
        KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                             PacketHeader.PacketId
                             );
        goto WaitForPacketLeader;
    }

    //
    // Check PacketId is valid.
    //

    if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {
        if (PacketHeader.PacketId != KdpPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    } else {
        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //

    Checksum = KdpComputeChecksum(
                            MessageHeader->Buffer,
                            MessageHeader->Length
                            );

    Checksum += KdpComputeChecksum(
                            MessageData->Buffer,
                            MessageData->Length
                            );
    if (Checksum != PacketHeader.Checksum) {
        goto SendResendPacket;
    }

    //
    // Send Acknowledge byte and the Id of the packet received.
    // Then, update the ExpectId for next incoming packet.
    //

    KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                         PacketHeader.PacketId
                         );

    //
    // We have successfully received the packet so update the
    // packet control variables and return sucess.
    //

    KdpPacketIdExpected ^= 1;
    return KDP_PACKET_RECEIVED;

SendResendPacket:
    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
}

VOID
KdpSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    )

/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;
    ULONG MessageDataLength;
    ULONG ReturnCode;
    PDBGKD_DEBUG_IO DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64 StateChange;

    if ( ARGUMENT_PRESENT(MessageData) ) {
        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = KdpComputeChecksum(
                                        MessageData->Buffer,
                                        MessageData->Length
                                        );
    } else {
        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += KdpComputeChecksum (
                                    MessageHeader->Buffer,
                                    MessageHeader->Length
                                    );

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;
    KdpNumberRetries = KdpRetryCount;
    do {
        if (KdpNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //

            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {
                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;
                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {
                    KdDebuggerNotPresent = TRUE;
                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdpPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {
                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;
                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {
                    KdDebuggerNotPresent = TRUE;
                    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdpPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            }
        }

        //
        // Setting PacketId has to be in the do loop in case Packet Id was
        // reset.
        //

        PacketHeader.PacketId = KdpNextPacketIdToSend;
        KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

        //
        // Output message header.
        //

        KdpSendString(MessageHeader->Buffer, MessageHeader->Length);

        //
        // Output message data.
        //

        if ( MessageDataLength ) {
            KdpSendString(MessageData->Buffer, MessageData->Length);
        }

        //
        // Output a packet trailing byte
        //

        KdPortPutByte(PACKET_TRAILING_BYTE);

        //
        // Wait for the Ack Packet
        //

        ReturnCode = KdpReceivePacket(
                         PACKET_TYPE_KD_ACKNOWLEDGE,
                         NULL,
                         NULL,
                         NULL
                         );
        if (ReturnCode == KDP_PACKET_TIMEOUT) {
            KdpNumberRetries--;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);

    //
    // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
    //

    KdpNextPacketIdToSend &= ~SYNC_PACKET_ID;

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //

    KdpRetryCount = MAXIMUM_RETRIES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kddata.c ===
/*++

Copyright (c) 1990-2002  Microsoft Corporation

Module Name:

    kddata.c

Abstract:

    This module contains global data for the portable kernel debgger.

--*/

#include "kdp.h"
#include "mi.h"
#include "pool.h"

//
// Miscellaneous data from all over the kernel
//

extern ULONG KiBugCheckData[];

extern POBJECT_DIRECTORY ObpRootDirectoryObject;
extern POBJECT_HANDLE_TABLE ObpObjectHandleTable;

extern SIZE_T PoolTrackTableSize;
extern PPOOL_TRACKER_TABLE PoolTrackTable;
extern POOL_DESCRIPTOR NonPagedPoolDescriptor;

extern PMMPFN MmPfnDatabase;

extern LIST_ENTRY FscLruList;

//
// Highest user address.
//

PVOID KdHighestUserAddress = MM_HIGHEST_USER_ADDRESS;

//
// Start of system address range.
//

PVOID KdSystemRangeStart = MM_SYSTEM_RANGE_START;

//
// User probe address.
//

ULONG_PTR KdUserProbeAddress = MM_USER_PROBE_ADDRESS;

//
// Lowest physical page number in the system.
//

PFN_NUMBER KdLowestPhysicalPage = MM_LOWEST_PHYSICAL_PAGE;

//
// Pointer to the default system process.
//

PKPROCESS KdActiveProcessHead = &KiSystemProcess;

//
// Storage for the processor state.
//

X86_NT5_KPROCESSOR_STATE KdProcessorState;

//
// This block of data needs to always be present because crashdumps
// need the information.  Otherwise, things like PAGE_SIZE are not available
// in crashdumps, and extensions like !pool fail.
//

KDDEBUGGER_DATA64 KdDebuggerDataBlock = {
    {0},                                    //  DBGKD_DEBUG_DATA_HEADER Header;
    (ULONG64)0,
    (ULONG64)RtlpBreakWithStatusInstruction,
    (ULONG64)0,
    (USHORT)0,                                      //  USHORT  ThCallbackStack;
    (USHORT)0,                                      //  USHORT  NextCallback;
    (USHORT)0,                                      //  USHORT  FramePointer;
    (USHORT)0,                                      //  USHORT  PaeEnabled;

    (ULONG64)NULL,
    (ULONG64)0,

    (ULONG64)&KdLoadedModuleList,
    (ULONG64)&KdActiveProcessHead,
    (ULONG64)NULL,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,

    (ULONG64)&KeTimeIncrement,
    (ULONG64)NULL,
    (ULONG64)KiBugCheckData,

    (ULONG64)NULL,

    (ULONG64)&ObpRootDirectoryObject,
    (ULONG64)NULL,

    (ULONG64)&KeSystemTime,
    (ULONG64)&KeInterruptTime,
    (ULONG64)&KiTimerTableListHead,

    (ULONG64)&MmPfnDatabase,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,

    (ULONG64)&KdLowestPhysicalPage,
    (ULONG64)&MmHighestPhysicalPage,
    (ULONG64)&MmNumberOfPhysicalPages,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)PAGE_SIZE,
    (ULONG64)NULL,

    (ULONG64)MmAllocatedPagesByUsage,
    (ULONG64)&ObpObjectHandleTable,
    (ULONG64)&MmVadRoot,
    (ULONG64)&FscLruList,
    (ULONG64)&FscNumberOfCachePages,
    (ULONG64)&FscElementArray,
    (ULONG64)NULL,

    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)NULL,
    (ULONG64)&MmAvailablePages,

#ifdef NO_POOL_TAG_TRACKING
    (ULONG64)NULL,
    (ULONG64)NULL,
#else
    (ULONG64)&PoolTrackTableSize,
    (ULONG64)&PoolTrackTable,
#endif
    (ULONG64)&NonPagedPoolDescriptor,

    (ULONG64)&KdHighestUserAddress,
    (ULONG64)&KdSystemRangeStart,
    (ULONG64)&KdUserProbeAddress,

    (ULONG64)KdPrintCircularBuffer,
    (ULONG64)KdPrintCircularBuffer+sizeof(KdPrintCircularBuffer),

    (ULONG64)&KdPrintWritePointer,
    (ULONG64)&KdPrintRolloverCount,

    (ULONG64)NULL,
};

UCHAR  KdPrintCircularBuffer[KDPRINTBUFFERSIZE];
PUCHAR KdPrintWritePointer = KdPrintCircularBuffer;
ULONG  KdPrintRolloverCount;

BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE];
UCHAR KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE];
UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE];
DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS];

LARGE_INTEGER  KdPerformanceCounterRate;
LARGE_INTEGER  KdTimerStart;
LARGE_INTEGER  KdTimerStop;
LARGE_INTEGER  KdTimerDifference;

ULONG_PTR KdpCurrentSymbolStart;
ULONG_PTR KdpCurrentSymbolEnd;
LONG      KdpNextCallLevelChange;   // used only over returns to the debugger.

ULONG_PTR KdSpecialCalls[DBGKD_MAX_SPECIAL_CALLS];
ULONG     KdNumberOfSpecialCalls;
ULONG_PTR InitialSP;
ULONG     KdpNumInternalBreakpoints;
KTIMER    InternalBreakpointTimer;
KDPC      InternalBreakpointCheckDpc;


DBGKD_TRACE_DATA TraceDataBuffer[TRACE_DATA_BUFFER_MAX_SIZE];
ULONG            TraceDataBufferPosition = 1; // Element # to write next
                                   // Recall elt 0 is a length

TRACE_DATA_SYM   TraceDataSyms[256];
BOOLEAN TraceDataBufferFilled;
UCHAR NextTraceDataSym;     // what's the next one to be replaced
UCHAR NumTraceDataSyms;     // how many are valid?

ULONG IntBPsSkipping;       // number of exceptions that are being skipped now

BOOLEAN   WatchStepOver;
PVOID     WSOThread;                // thread doing stepover
ULONG_PTR WSOEsp;                   // stack pointer of thread doing stepover (yes, we need it)
ULONG     WatchStepOverHandle;
ULONG_PTR WatchStepOverBreakAddr;   // where the WatchStepOver break is set
BOOLEAN   WatchStepOverSuspended;
ULONG     InstructionsTraced;
BOOLEAN   SymbolRecorded;
LONG      CallLevelChange;
LONG_PTR  oldpc;
BOOLEAN   InstrCountInternal;       // Processing a non-COUNTONLY?

BOOLEAN   BreakpointsSuspended;

//
// KdpRetryCount controls the number of retries before we give up and
//   assume kernel debugger is not present.
// KdpNumberRetries is the number of retries left.  Initially, it is set
//   to 5 such that booting NT without debugger won't be delayed to long.
//

ULONG KdpRetryCount = 5;
ULONG KdpNumberRetries = 5;
BOOLEAN KdpControlCPending;
BOOLEAN KdpControlCPressed;

KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
ULONG KdpNextPacketIdToSend;
ULONG KdpPacketIdExpected;

//
// KdDebugParameters contains the debug port address and baud rate
//     used to initialize kernel debugger port.
//
// (They both get initialized to zero to indicate using default settings.)
// If SYSTEM hive contains the parameters, i.e. port and baud rate, system
// init code will fill in these variable with the values stored in the hive.
//

DEBUG_PARAMETERS KdDebugParameters;

LIST_ENTRY      KdpDebuggerDataListHead;

//
// !search support variables (page hit database)
//

PFN_NUMBER KdpSearchPageHits [SEARCH_PAGE_HIT_DATABASE_SIZE];
ULONG KdpSearchPageHitOffsets [SEARCH_PAGE_HIT_DATABASE_SIZE];
ULONG KdpSearchPageHitIndex;

LOGICAL KdpSearchInProgress;

PFN_NUMBER KdpSearchStartPageFrame;
PFN_NUMBER KdpSearchEndPageFrame;

ULONG_PTR KdpSearchAddressRangeStart;
ULONG_PTR KdpSearchAddressRangeEnd;

ULONG KdpSearchCheckPoint = KDP_SEARCH_SYMBOL_CHECK;

BOOLEAN KdDebuggerNotPresent;
BOOLEAN KdDebuggerEnabled;
BOOLEAN KdpDebuggerStructuresInitialized;
ULONG KdpOweBreakpoint;
ULONG KdEnteredDebugger;
ULONG KdGlobalFlag;

//
// Static loader data table entry for XBOXKRNL.EXE.
//
LDR_DATA_TABLE_ENTRY KdpNtosDataTableEntry;

//
// List of modules that have been loaded.
//
INITIALIZED_LIST_ENTRY(KdLoadedModuleList);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kddbgio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kddbgio.c

Abstract:

    This module implements kernel debugger based Dbg I/O. This
    is the foundation for DbgPrint and DbgPrompt.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    )

/*++

Routine Description:

    This routine prints a string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

Return Value:

    TRUE if Control-C present in input buffer after print is done.
    FALSE otherwise.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;

    //
    // Move the output string to the message buffer.
    //

    Length = KdpMoveMemory(
                (PCHAR)KdpMessageBuffer,
                (PCHAR)Output->Buffer,
                Output->Length
                );

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the print string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdPrintStringApi;
    DebugIo.ProcessorLevel = 6;
    DebugIo.Processor = (USHORT)0;
    DebugIo.u.PrintString.LengthOfString = Length;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the print string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdpSendPacket(
                  PACKET_TYPE_KD_DEBUG_IO,
                  &MessageHeader,
                  &MessageData
                  );

    return KdpPollBreakInWithPortLock();
}

BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    )

/*++

Routine Description:

    This routine prints a string, then reads a reply string.

Arguments:

    Output - Supplies a pointer to a string descriptor for the output string.

    Input - Supplies a pointer to a string descriptor for the input string.
            (Length stored/returned in Input->Length)

Return Value:

    TRUE - A Breakin sequence was seen, caller should breakpoint and retry
    FALSE - No Breakin seen.

--*/

{

    ULONG Length;
    STRING MessageData;
    STRING MessageHeader;
    DBGKD_DEBUG_IO DebugIo;
    ULONG ReturnCode;

    //
    // Move the output string to the message buffer.
    //

    Length = KdpMoveMemory(
                (PCHAR)KdpMessageBuffer,
                (PCHAR)Output->Buffer,
                Output->Length
                );

    //
    // If the total message length is greater than the maximum packet size,
    // then truncate the output string.
    //

    if ((sizeof(DBGKD_DEBUG_IO) + Length) > PACKET_MAX_SIZE) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_DEBUG_IO);
    }

    //
    // Construct the prompt string message and message descriptor.
    //

    DebugIo.ApiNumber = DbgKdGetStringApi;
    DebugIo.ProcessorLevel = 6;
    DebugIo.Processor = (USHORT)0;
    DebugIo.u.GetString.LengthOfPromptString = Length;
    DebugIo.u.GetString.LengthOfStringRead = Input->MaximumLength;
    MessageHeader.Length = sizeof(DBGKD_DEBUG_IO);
    MessageHeader.Buffer = (PCHAR)&DebugIo;

    //
    // Construct the prompt string data and data descriptor.
    //

    MessageData.Length = (USHORT)Length;
    MessageData.Buffer = KdpMessageBuffer;

    //
    // Send packet to the kernel debugger on the host machine.
    //

    KdpSendPacket(
                  PACKET_TYPE_KD_DEBUG_IO,
                  &MessageHeader,
                  &MessageData
                  );


    //
    // Receive packet from the kernel debugger on the host machine.
    //

    MessageHeader.MaximumLength = sizeof(DBGKD_DEBUG_IO);
    MessageData.MaximumLength = KDP_MESSAGE_BUFFER_SIZE;

    do {
        ReturnCode = KdpReceivePacket(
                                      PACKET_TYPE_KD_DEBUG_IO,
                                      &MessageHeader,
                                      &MessageData,
                                      &Length
                                      );
        if (ReturnCode == KDP_PACKET_RESEND) {
            return TRUE;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);


    if (Length > Input->MaximumLength) {
        Length = Input->MaximumLength;
    }

    Input->Length = (USHORT)KdpMoveMemory(
                                (PCHAR)Input->Buffer,
                                (PCHAR)KdpMessageBuffer,
                                Length
                                );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdbreak.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdbreak.c

Abstract:

    This module implements machine dependent functions to add and delete
    breakpoints from the kernel debugger breakpoint table.

Author:

    David N. Cutler 2-Aug-1990

Revision History:

--*/

#include "kdp.h"

ULONG
KdpAddBreakpoint (
    IN PVOID Address
    )

/*++

Routine Description:

    This routine adds an entry to the breakpoint table and returns a handle
    to the breakpoint table entry.

Arguments:

    Address - Supplies the address where to set the breakpoint.

Return Value:

    A value of zero is returned if the specified address is already in the
    breakpoint table, there are no free entries in the breakpoint table, the
    specified address is not correctly aligned, or the specified address is
    not valid. Otherwise, the index of the assigned breakpoint table entry
    plus one is returned as the function value.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    ULONG Index;
    HARDWARE_PTE Opaque;
    PVOID AccessAddress;

    //DPRINT(("KD: Setting breakpoint at 0x%08x\n", Address));

    //
    // If the specified address is not properly aligned, then return zero.
    //

    if (((ULONG_PTR)Address & KDP_BREAKPOINT_ALIGN) != 0) {
        return 0;
    }


    //
    // Don't allow setting the same breakpoint twice.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) != 0 &&
            KdpBreakpointTable[Index].Address == Address) {

            if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) != 0) {

                //
                // Breakpoint was set, the page was written out and was not
                // accessible when the breakpoint was cleared.  Now the breakpoint
                // is being set again.  Just clear the defer flag:
                //
                KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
                return Index + 1;

            } else {

                DPRINT(("KD: Attempt to set breakpoint %08x twice!\n", Address));
                return 0;

            }
        }
    }

    //
    // Search the breakpoint table for a free entry.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags == 0) {
            break;
        }
    }

    //
    // If a free entry was found, then write breakpoint and return the handle
    // value plus one. Otherwise, return zero.
    //

    if (Index == BREAKPOINT_TABLE_SIZE) {
        DPRINT(("KD: ran out of breakpoints!\n"));
        return 0;
    }


    //DPRINT(("KD: using Index %d\n", Index));

    //
    // Get the instruction to be replaced. If the instruction cannot be read,
    // then mark breakpoint as not accessible.
    //

    if (KdpMoveMemory(
            (PCHAR)&Content,
            (PCHAR)Address,
            sizeof(KDP_BREAKPOINT_TYPE) ) != sizeof(KDP_BREAKPOINT_TYPE)) {
        AccessAddress = NULL;
        //DPRINT(("KD: memory inaccessible\n"));
    } else {
        //DPRINT(("KD: memory readable...\n"));

        //
        // If the specified address is not write accessible, then return zero.
        // All references must be made through AccessAddress.
        //

        AccessAddress = MmDbgWriteCheck((PVOID)Address, &Opaque);
        if (AccessAddress == NULL) {
            DPRINT(("KD: memory not writable!\n"));
            return 0;
        }
    }

    if ( AccessAddress != NULL ) {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Content = Content;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
        if (KdpMoveMemory(
                (PCHAR)AccessAddress,
                (PCHAR)&KdpBreakpointInstruction,
                sizeof(KDP_BREAKPOINT_TYPE)
                ) != sizeof(KDP_BREAKPOINT_TYPE)) {

            DPRINT(("KD: KdpMoveMemory failed writing BP!\n"));
        }
        MmDbgReleaseAddress(AccessAddress, &Opaque);
    } else {
        KdpBreakpointTable[Index].Address = Address;
        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE | KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        //DPRINT(("KD: breakpoint write deferred\n"));
    }

    return Index + 1;

}

VOID
KdSetOwedBreakpoints(
    VOID
    )

/*++

Routine Description:

    This function is called after returning from memory management calls
    that may cause an inpage.  Its purpose is to store pending
    breakpoints in pages just made valid.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KDP_BREAKPOINT_TYPE Content;
    BOOLEAN Enable;
    LONG Index;
    HARDWARE_PTE Opaque;
    PVOID AccessAddress;

    //
    // If we don't owe any breakpoints then return
    //

    if ( !KdpOweBreakpoint ) {
        return;
    }

    //
    // Freeze all other processors, disable interrupts, and save debug
    // port state.
    //

    Enable = KdEnterDebugger(NULL, NULL);
    KdpOweBreakpoint = FALSE;
    AccessAddress = NULL;

    //
    // Search the breakpoint table for breakpoints that need to be
    // written or replaced.
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
        if (KdpBreakpointTable[Index].Flags &
                (KD_BREAKPOINT_NEEDS_WRITE | KD_BREAKPOINT_NEEDS_REPLACE) ) {

            //
            // Breakpoint needs to be written
            //
            //DPRINT(("KD: Breakpoint %d at 0x%08x: trying to %s after page in.\n",
            //    Index,
            //    KdpBreakpointTable[Index].Address,
            //    (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) ?
            //        "set" : "clear"));

            //
            // Check to see if we have write access to the memory
            //

            AccessAddress = MmDbgWriteCheck((PVOID)KdpBreakpointTable[Index].Address, &Opaque);

            if (AccessAddress == NULL) {
                KdpOweBreakpoint = TRUE;
                //DPRINT(("KD: address not writeable.\n"));
                break;
            }

            //
            // Breakpoint is global, or its directory base matches
            //

            if (KdpMoveMemory(
                    (PCHAR)&Content,
                    (PCHAR)AccessAddress,
                    sizeof(KDP_BREAKPOINT_TYPE)
                    ) != sizeof(KDP_BREAKPOINT_TYPE)) {

                //
                // Memory is still inaccessible (is this possible after
                // the call above to MmDbgWriteCheck?)
                //

                DPRINT(("KD: read from 0x%08x failed\n", KdpBreakpointTable[Index].Address));

                KdpOweBreakpoint = TRUE;

            } else {
                if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {
                    KdpBreakpointTable[Index].Content = Content;
                    if (KdpMoveMemory(
                            (PCHAR)AccessAddress,
                            (PCHAR)&KdpBreakpointInstruction,
                            sizeof(KDP_BREAKPOINT_TYPE)
                            ) != sizeof(KDP_BREAKPOINT_TYPE)) {
                        KdpOweBreakpoint = TRUE;
                        DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                    } else {
                        KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_IN_USE;
                        DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                    }
                } else {
                    if (KdpMoveMemory(
                            (PCHAR)AccessAddress,
                            (PCHAR)&KdpBreakpointTable[Index].Content,
                            sizeof(KDP_BREAKPOINT_TYPE)
                            ) != sizeof(KDP_BREAKPOINT_TYPE)) {
                        KdpOweBreakpoint = TRUE;
                        DPRINT(("KD: write to 0x%08x failed\n", KdpBreakpointTable[Index].Address));
                    } else {
                        //DPRINT(("KD: write to 0x%08x ok\n", KdpBreakpointTable[Index].Address));
                        if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
                            KdpBreakpointTable[Index].Flags = KD_BREAKPOINT_SUSPENDED | KD_BREAKPOINT_IN_USE;
                        } else {
                            KdpBreakpointTable[Index].Flags = 0;
                        }
                    }
                }
            }

            if (AccessAddress != NULL) {
                MmDbgReleaseAddress(
                        AccessAddress,
                        &Opaque
                        );
                AccessAddress = NULL;
            }
        }
    }

    if (AccessAddress != NULL) {
        MmDbgReleaseAddress(
                AccessAddress,
                &Opaque
                );
    }

    KdExitDebugger(Enable);
    return;
}

BOOLEAN
KdpLowWriteContent (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to replace the code that a breakpoint is
    written over.  This routine, KdpAddBreakpoint,
    KdpLowRestoreBreakpoint and KdSetOwedBreakpoints are responsible
    for getting data written as requested.  Callers should not
    examine or use KdpOweBreakpoints, and they should not set the
    NEEDS_WRITE or NEEDS_REPLACE flags.

    Callers must still look at the return value from this function,
    however: if it returns FALSE, the breakpoint record must not be
    reused until KdSetOwedBreakpoints has finished with it.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be deleted.

Return Value:

    Returns TRUE if the breakpoint was removed, FALSE if it was deferred.

--*/

{
    //
    // Do the contents need to be replaced at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_WRITE) {

        //
        // The breakpoint was never written out.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        //DPRINT(("KD: Breakpoint at 0x%08x never written; flag cleared.\n",
        //    KdpBreakpointTable[Index].Address));
        return TRUE;
    }

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        //DPRINT(("KD: Breakpoint at 0x%08x; instr is really BP; flag cleared.\n",
        //    KdpBreakpointTable[Index].Address));

        return TRUE;
    }

    //
    // Restore the instruction contents.
    //

    if (KdpMoveMemory( (PCHAR)KdpBreakpointTable[Index].Address,
                        (PCHAR)&KdpBreakpointTable[Index].Content,
                        sizeof(KDP_BREAKPOINT_TYPE) ) != sizeof(KDP_BREAKPOINT_TYPE)) {

        KdpOweBreakpoint = TRUE;
        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_REPLACE;
        //DPRINT(("KD: Breakpoint at 0x%08x; unable to clear, flag set.\n",
            //KdpBreakpointTable[Index].Address));
        return FALSE;
    } else {
        //DPRINT(("KD: Breakpoint at 0x%08x cleared.\n",
            //KdpBreakpointTable[Index].Address));
        return TRUE;
    }
}

BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    )

/*++

Routine Description:

    This routine deletes an entry from the breakpoint table.

Arguments:

    Handle - Supplies the index plus one of the breakpoint table entry
        which is to be deleted.

Return Value:

    A value of FALSE is returned if the specified handle is not a valid
    value or the breakpoint cannot be deleted because the old instruction
    cannot be replaced. Otherwise, a value of TRUE is returned.

--*/

{
    ULONG Index = Handle - 1;

    //
    // If the specified handle is not valid, then return FALSE.
    //

    if ((Handle == 0) || (Handle > BREAKPOINT_TABLE_SIZE)) {
        DPRINT(("KD: Breakpoint %d invalid.\n", Index));
        return FALSE;
    }

    //
    // If the specified breakpoint table entry is not valid, then return FALSE.
    //

    if (KdpBreakpointTable[Index].Flags == 0) {
        //DPRINT(("KD: Breakpoint %d already clear.\n", Index));
        return FALSE;
    }

    //
    // If the breakpoint is already suspended, just delete it from the table.
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) {
        //DPRINT(("KD: Deleting suspended breakpoint %d \n", Index));
        if ( !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) ) {
            //DPRINT(("KD: already clear.\n"));
            KdpBreakpointTable[Index].Flags = 0;
            return TRUE;
        }
    }

    //
    // Replace the instruction contents.
    //

    if (KdpLowWriteContent(Index)) {

        //
        // Delete breakpoint table entry
        //

        //DPRINT(("KD: Breakpoint %d deleted successfully.\n", Index));
        KdpBreakpointTable[Index].Flags = 0;
    }

    return TRUE;
}

BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    )

/*++

Routine Description:

    This routine deletes all breakpoints falling in a given range
    from the breakpoint table.

Arguments:

    Lower - inclusive lower address of range from which to remove BPs.

    Upper - include upper address of range from which to remove BPs.

Return Value:

    TRUE if any breakpoints removed, FALSE otherwise.

--*/

{
    ULONG   Index;
    BOOLEAN ReturnStatus = FALSE;

    //
    // Examine each entry in the table in turn
    //

    for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++)
    {
        if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
             ((KdpBreakpointTable[Index].Address >= Lower) &&
              (KdpBreakpointTable[Index].Address <= Upper)) )
        {

            //
            // Breakpoint is in use and falls in range, clear it.
            //

            if (KdpDeleteBreakpoint(Index+1))
            {
                ReturnStatus = TRUE;
            }
        }
    }

    return ReturnStatus;

}

VOID
KdpSuspendBreakpoint (
    ULONG Handle
    )
{
    ULONG Index = Handle - 1;

    if ( (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
        !(KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_SUSPENDED;
        KdpLowWriteContent(Index);
    }

    return;

} // KdpSuspendBreakpoint

VOID
KdpSuspendAllBreakpoints (
    VOID
    )
{
    ULONG Handle;

    BreakpointsSuspended = TRUE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpSuspendBreakpoint(Handle);
    }

    return;

} // KdpSuspendAllBreakpoints

BOOLEAN
KdpLowRestoreBreakpoint (
    IN ULONG Index
    )

/*++

Routine Description:

    This routine attempts to write a breakpoint instruction.
    The old contents must have already been stored in the
    breakpoint record.

Arguments:

    Index - Supplies the index of the breakpoint table entry
        which is to be written.

Return Value:

    Returns TRUE if the breakpoint was written, FALSE if it was
    not and has been marked for writing later.

--*/

{
    KDP_BREAKPOINT_TYPE Content;

    //
    // Does the breakpoint need to be written at all?
    //

    if (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_NEEDS_REPLACE) {

        //
        // The breakpoint was never removed.  Clear the flag
        // and we are done.
        //

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_REPLACE;
        return TRUE;
    }

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }

    //
    // Replace the instruction contents.
    //

    if (KdpBreakpointTable[Index].Content == KdpBreakpointInstruction) {

        //
        // The instruction is a breakpoint anyway.
        //

        return TRUE;
    }

    //
    // Replace the instruction contents.
    //

    if (KdpMoveMemory( (PCHAR)KdpBreakpointTable[Index].Address,
                       (PCHAR)&KdpBreakpointInstruction,
                       sizeof(KDP_BREAKPOINT_TYPE) ) != sizeof(KDP_BREAKPOINT_TYPE)) {

        KdpBreakpointTable[Index].Flags |= KD_BREAKPOINT_NEEDS_WRITE;
        KdpOweBreakpoint = TRUE;
        return FALSE;

    } else {

        KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_NEEDS_WRITE;
        return TRUE;
    }
}

VOID
KdpRestoreAllBreakpoints (
    VOID
    )
{
    ULONG Index;

    BreakpointsSuspended = FALSE;

    for ( Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index++ ) {

        if ((KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_IN_USE) &&
            (KdpBreakpointTable[Index].Flags & KD_BREAKPOINT_SUSPENDED) ) {

            KdpBreakpointTable[Index].Flags &= ~KD_BREAKPOINT_SUSPENDED;
            KdpLowRestoreBreakpoint(Index);
        }
    }

    return;

} // KdpRestoreAllBreakpoints

VOID
KdDeleteAllBreakpoints(
    VOID
    )
{
    ULONG Handle;

    if (KdDebuggerEnabled == FALSE) {
        return;
    }

    BreakpointsSuspended = FALSE;

    for ( Handle = 1; Handle <= BREAKPOINT_TABLE_SIZE; Handle++ ) {
        KdpDeleteBreakpoint(Handle);
    }

    return;
} // KdDeleteAllBreakpoints
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdmove.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdmove.c

Abstract:

    This module contains code to implement the portable kernel debugger
    memory mover.

Author:

    Mark Lucovsky (markl) 31-Aug-1990

Revision History:

--*/

#include "kdp.h"

ULONG
KdpMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine moves data to or from the message buffer and returns the
    actual length of the information that was moved. As data is moved, checks
    are made to ensure that the data is resident in memory and a page fault
    will not occur. If a page fault would occur, then the move is truncated.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    The actual length of the move is returned as the fucntion value.

--*/

{

    PVOID Address1;
    PVOID Address2;
    ULONG ActualLength;
    HARDWARE_PTE Opaque;

    //
    // If the length is greater than the size of the message buffer, then
    // reduce the length to the size of the message buffer.
    //

    if (Length > KDP_MESSAGE_BUFFER_SIZE) {
        Length = KDP_MESSAGE_BUFFER_SIZE;
    }

    //
    // Move the source information to the destination address.
    //

    ActualLength = Length;
    Address1 = NULL;

    while (((ULONG_PTR)Source & 3) && (Length > 0)) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = MmDbgWriteCheck((PVOID)Destination, &Opaque);
        Address2 = MmDbgReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }
        *(PCHAR)Address1 = *(PCHAR)Address2;
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;

        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    if (Address1 != NULL) {
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;
    }

    while (Length > 3) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = MmDbgWriteCheck((PVOID)Destination, &Opaque);
        Address2 = MmDbgReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }
        *(ULONG UNALIGNED *)Address1 = *(PULONG)Address2;
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;

        Destination += 4;
        Source += 4;
        Length -= 4;

    }

    if (Address1 != NULL) {
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;
    }

    while (Length > 0) {

    //
    // Check to determine if the move will succeed before actually performing
    // the operation.
    //

        Address1 = MmDbgWriteCheck((PVOID)Destination, &Opaque);
        Address2 = MmDbgReadCheck((PVOID)Source);
        if ((Address1 == NULL) || (Address2 == NULL)) {
            break;
        }
        *(PCHAR)Address1 = *(PCHAR)Address2;
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;

        Destination += 1;
        Source += 1;
        Length -= 1;
    }

    if (Address1 != NULL) {
        MmDbgReleaseAddress(Address1, &Opaque);
        Address1 = NULL;
    }

    return ActualLength - Length;
}

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine does the exact same thing as RtlMoveMemory, BUT it is
    private to the debugger.  This allows folks to set breakpoints and
    watch points in RtlMoveMemory without risk of recursive debugger
    entry and the accompanying hang.

    N.B.  UNLIKE KdpMoveMemory, this routine does NOT check for accessability
      and may fault!  Use it ONLY in the debugger and ONLY where you
      could use RtlMoveMemory.

Arguments:

    Destination  - Supplies a pointer to destination of the move operation.

    Source - Supplies a pointer to the source of the move operation.

    Length - Supplies the length of the move operation.

Return Value:

    None.

--*/
{
    while (Length > 0) {
        *Destination = *Source;
        Destination++;
        Source++;
        Length--;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdlock.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    kdlock.c

Abstract:

    This module contains code to synchronize the usage of the port
    used by the kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

--*/

#include "kdp.h"
#include "dm.h"

BOOLEAN
KdPollBreakIn(
    VOID
    )

/*++

Routine Description:

    This procedure raises IRQL to high_level, seizes the Debug port
    spinlock, and checks to see if a breakin packet is pending.
    If a packet is present, return TRUE, else FALSE.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{
    BOOLEAN BreakIn;
    BOOLEAN Enable;
    UCHAR   Input;
    KIRQL   OldIrql;
    ULONG   Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        Enable = KiDisableInterrupts();
#ifndef _X86_
        KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif
        if (KdpControlCPending != FALSE) {
            KdpControlCPressed = TRUE;
            BreakIn = TRUE;
            KdpControlCPending = FALSE;

        } else {
            KdpPortLock();
            Status = KdPortPollByte(&Input);
            if ((Status == CP_GET_SUCCESS) &&
                (Input == BREAKIN_PACKET_BYTE)) {
                BreakIn = TRUE;
                KdpControlCPressed = TRUE;
            }
            KdpPortUnlock();
        }

#ifndef _X86_
        KeLowerIrql(OldIrql);
#endif
        KiRestoreInterrupts(Enable);
    }

    if(BreakIn)
        /* We can probably assume that the debugger is reconnected */
        KdDebuggerNotPresent = FALSE;

#ifdef DEVKIT
    /* If we're going to break in, give the debug monitor a chance to do its
     * own version of break in */
    if(BreakIn && KeGetCurrentPrcb())
        DmTell(DMTELL_ENTERDEBUGGER, NULL);
#endif

    return BreakIn;
}

BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    )

/*++

Routine Description:

    This procedure same as KdPollBreakIn, but assumes the caller
    already holds the port lock.  Returns TRUE if a breakin packet
    is pending.

    A packet is present if:

    There is a valid character which matches BREAK_CHAR.

    N.B.    Interrupts must be OFF around this call

Return Value:

    TRUE if breakin sequence present, caller should execute int-3.
    FALSE if no breakin seen.

--*/

{

    BOOLEAN BreakIn;
    BOOLEAN Enable;
    UCHAR Input;
    ULONG Status;

    //
    // If the debugger is enabled, see if a breakin by the kernel
    // debugger is pending.
    //

    BreakIn = FALSE;
    if (KdDebuggerEnabled != FALSE) {
        if (KdpControlCPending != FALSE) {
            BreakIn = TRUE;
            KdpControlCPending = FALSE;

        } else {
            Status = KdPortPollByte(&Input);
            if ((Status == CP_GET_SUCCESS) &&
                (Input == BREAKIN_PACKET_BYTE)) {
                BreakIn = TRUE;
            }
        }
    }

    return BreakIn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdp.h

Abstract:

    Private include file for the Kernel Debugger subcomponent
    of the NTOS project

Author:

    Mike O'Leary (mikeol) 29-June-1989

Revision History:

--*/

#include "ntos.h"
#include "ki.h"
#include "string.h"
#include "stdlib.h"

//
// Put all of the kernel debugger code in one section and the read-write data
// into another section.  Do this before including wdbgexts.h and ntdbg.h as
// these declare inline functions that shouldn't be placed in the normal code
// section.
//
// The kernel debugger data section needs to be merged into the main data
// section so that it's properly reinitialized across a quick reboot.
//

#pragma code_seg("KDCODE")
#pragma const_seg("KDDATA_RD")
#pragma data_seg("KDDATA_RW")
#pragma bss_seg("KDDATA_URW")
#pragma comment(linker, "/merge:KDDATA_RD=KDCODE")
#pragma comment(linker, "/merge:KDDATA_RW=.data")
#pragma comment(linker, "/merge:KDDATA_URW=.bss")

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"

#define KDP_BREAKPOINT_TYPE  UCHAR
#define KDP_BREAKPOINT_ALIGN 0
#define KDP_BREAKPOINT_VALUE 0xcc

//
// Define constants.
//

//
// Addresses above GLOBAL_BREAKPOINT_LIMIT are either in system space
// or part of dynlink, so we treat them as global.
//

#define GLOBAL_BREAKPOINT_LIMIT 1610612736L // 1.5gigabytes

//
// Define breakpoint table entry structure.
//

#define KD_BREAKPOINT_IN_USE        0x00000001
#define KD_BREAKPOINT_NEEDS_WRITE   0x00000002
#define KD_BREAKPOINT_SUSPENDED     0x00000004
#define KD_BREAKPOINT_NEEDS_REPLACE 0x00000008
// IA64 specific defines
#define KD_BREAKPOINT_STATE_MASK    0x0000000f

//
// status Constants for Packet waiting
//

#define KDP_PACKET_RECEIVED 0
#define KDP_PACKET_TIMEOUT 1
#define KDP_PACKET_RESEND 2


typedef struct _BREAKPOINT_ENTRY {
    UCHAR Flags;
    KDP_BREAKPOINT_TYPE Content;
    PVOID Address;
} BREAKPOINT_ENTRY, *PBREAKPOINT_ENTRY;


//
// Misc defines
//

#define MAXIMUM_RETRIES 20

#define DBGKD_MAX_SPECIAL_CALLS 10

typedef struct _TRACE_DATA_SYM {
    ULONG SymMin;
    ULONG SymMax;
} TRACE_DATA_SYM, *PTRACE_DATA_SYM;

//
//
//

typedef struct _X86_NT5_DBGKD_WAIT_STATE_CHANGE64 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
    } u;
    DBGKD_CONTROL_REPORT ControlReport;
    X86_NT5_CONTEXT Context;
} X86_NT5_DBGKD_WAIT_STATE_CHANGE64, *PX86_NT5_DBGKD_WAIT_STATE_CHANGE64;

//
// Kernel debugger port functions.
//

BOOLEAN
KdPortInitialize (
    PDEBUG_PARAMETERS DebugParameters,
    BOOLEAN Initialize
    );

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    );

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    );

VOID
KdPortPutByte (
    IN UCHAR Output
    );

//
// Define function prototypes.
//

BOOLEAN
KdpPrintString (
    IN PSTRING Output
    );

BOOLEAN
KdpPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

ULONG
KdpAddBreakpoint (
    IN PVOID Address
    );

BOOLEAN
KdpDeleteBreakpoint (
    IN ULONG Handle
    );

BOOLEAN
KdpDeleteBreakpointRange (
    IN PVOID Lower,
    IN PVOID Upper
    );

#if i386

NTSTATUS
KdGetTraceInformation (
    OUT PVOID TraceInformation,
    IN ULONG TraceInformationLength,
    OUT PULONG RequiredLength
    );

VOID
KdSetInternalBreakpoint (
    IN PDBGKD_MANIPULATE_STATE64 m
    );

#endif

NTSTATUS
KdQuerySpecialCalls (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN ULONG Length,
    OUT PULONG RequiredLength
    );

VOID
KdSetSpecialCall (
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdClearSpecialCalls (
    VOID
    );

ULONG
KdpMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
KdpQuickMoveMemory (
    IN PCHAR Destination,
    IN PCHAR Source,
    IN ULONG Length
    );

ULONG
KdpReceivePacket (
    IN ULONG ExpectedPacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength
    );

VOID
KdpSetLoadState(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdpSetStateChange(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdpSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL
    );

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord64,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    );

BOOLEAN
KdpReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN BOOLEAN UnloadSymbols,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    );

KCONTINUE_STATUS
KdpSendWaitContinue(
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PX86_NT5_CONTEXT ContextRecord
    );

VOID
KdpReadVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteVirtualMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadPhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWritePhysicalMemory(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpCheckLowMemory(
    IN PDBGKD_MANIPULATE_STATE64 m
    );

VOID
KdpGetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    );

VOID
KdpSetContext(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData,
    IN PX86_NT5_CONTEXT Context
    );

VOID
KdpWriteBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpRestoreBreakpoint(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    );

VOID
KdpSuspendBreakpoint (
    ULONG Handle
    );

VOID
KdpSuspendAllBreakpoints (
    VOID
    );

VOID
KdpRestoreAllBreakpoints (
    VOID
    );

VOID
KdpSaveProcessorControlState (
    IN PX86_NT5_KPROCESSOR_STATE ProcessorState
    );

VOID
KdpRestoreProcessorControlState (
    IN PX86_NT5_KPROCESSOR_STATE ProcessorState
    );

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    );

//
// Define dummy prototype so the address of the standard breakpoint instruction
// can be captured.
//
// N.B. This function is NEVER called.
//

VOID
RtlpBreakWithStatusInstruction (
    VOID
    );

//
// Define external references.
//

#define KDP_MESSAGE_BUFFER_SIZE 4096

extern BREAKPOINT_ENTRY KdpBreakpointTable[BREAKPOINT_TABLE_SIZE];
extern BOOLEAN KdpControlCPending;
extern PKDEBUG_ROUTINE KiDebugRoutine;
extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern UCHAR KdpMessageBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern UCHAR KdpPathBuffer[KDP_MESSAGE_BUFFER_SIZE];
extern ULONG KdpOweBreakpoint;
extern ULONG KdpNextPacketIdToSend;
extern ULONG KdpPacketIdExpected;

extern LARGE_INTEGER KdPerformanceCounterRate;
extern LARGE_INTEGER KdTimerStart;
extern LARGE_INTEGER KdTimerStop;
extern LARGE_INTEGER KdTimerDifference;

extern BOOLEAN BreakpointsSuspended;
extern LIST_ENTRY KdpDebuggerDataListHead;

typedef struct {
    ULONG64 Addr;                 // pc address of breakpoint
    ULONG Flags;                // Flags bits
    ULONG Calls;                // # of times traced routine called
    ULONG CallsLastCheck;       // # of calls at last periodic (1s) check
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;      // largest number of instructions for 1 call
    ULONG MaxInstructions;      // smallest # of instructions for 1 call
    ULONG TotalInstructions;    // total instructions for all calls
    ULONG Handle;               // handle in (regular) bpt table
    PVOID Thread;               // Thread that's skipping this BP
    ULONG64 ReturnAddress;        // return address (if not COUNTONLY)
} DBGKD_INTERNAL_BREAKPOINT, *PDBGKD_INTERNAL_BREAKPOINT;


#define DBGKD_MAX_INTERNAL_BREAKPOINTS 20
extern DBGKD_INTERNAL_BREAKPOINT KdpInternalBPs[DBGKD_MAX_INTERNAL_BREAKPOINTS];

extern X86_NT5_KPROCESSOR_STATE KdProcessorState;

extern ULONG_PTR   KdpCurrentSymbolStart;
extern ULONG_PTR   KdpCurrentSymbolEnd;
extern LONG    KdpNextCallLevelChange;
extern ULONG_PTR   KdSpecialCalls[];
extern ULONG   KdNumberOfSpecialCalls;
extern ULONG_PTR   InitialSP;
extern ULONG   KdpNumInternalBreakpoints;
extern KTIMER  InternalBreakpointTimer;
extern KDPC    InternalBreakpointCheckDpc;
extern LARGE_INTEGER   KdpTimeEntered;

extern DBGKD_TRACE_DATA TraceDataBuffer[];
extern ULONG            TraceDataBufferPosition;
extern TRACE_DATA_SYM   TraceDataSyms[];
extern BOOLEAN          TraceDataBufferFilled;
extern UCHAR NextTraceDataSym;
extern UCHAR NumTraceDataSyms;
extern ULONG IntBPsSkipping;
extern BOOLEAN WatchStepOver;
extern PVOID WSOThread;
extern ULONG_PTR WSOEsp;
extern ULONG WatchStepOverHandle;
extern ULONG_PTR WatchStepOverBreakAddr;
extern BOOLEAN WatchStepOverSuspended;
extern ULONG InstructionsTraced;
extern BOOLEAN SymbolRecorded;
extern LONG CallLevelChange;
extern LONG_PTR oldpc;
extern BOOLEAN InstrCountInternal;
extern BOOLEAN BreakpointsSuspended;
extern BOOLEAN KdpControlCPending;
extern BOOLEAN KdpControlCPressed;
extern ULONG KdpRetryCount;
extern ULONG KdpNumberRetries;

extern KDP_BREAKPOINT_TYPE KdpBreakpointInstruction;
extern ULONG KdpOweBreakpoint;
extern ULONG KdpNextPacketIdToSend;
extern ULONG KdpPacketIdExpected;
extern UCHAR  KdPrintCircularBuffer[KDPRINTBUFFERSIZE];
extern PUCHAR KdPrintWritePointer;
extern ULONG  KdPrintRolloverCount;
extern DEBUG_PARAMETERS KdDebugParameters;
extern LIST_ENTRY KdpDebuggerDataListHead;
extern KDDEBUGGER_DATA64 KdDebuggerDataBlock;
extern BOOLEAN KdpDebuggerStructuresInitialized;
extern ULONG KdEnteredDebugger;
extern ULONG KdGlobalFlag;

extern LDR_DATA_TABLE_ENTRY KdpNtosDataTableEntry;

//
// !search support (page hit database)
//

//
// Hit database where search results are stored (kddata.c). 
// The debugger extensions know how to extract the information 
// from here.
//
// Note that the size of the hit database is large enough to
// accomodate any searches because the !search extension works
// in batches of pages < PAGE_SIZE and for every page we register only 
// one hit.
//

#define SEARCH_PAGE_HIT_DATABASE_SIZE PAGE_SIZE

extern PFN_NUMBER KdpSearchPageHits[SEARCH_PAGE_HIT_DATABASE_SIZE];
extern ULONG KdpSearchPageHitOffsets[SEARCH_PAGE_HIT_DATABASE_SIZE];

extern ULONG KdpSearchPageHitIndex;

//
// Set to true while a physical memory search is in progress.
// Reset at the end of the search. This is done in the debugger
// extension and it is a flag used by KdpCheckLowMemory to get
// onto a different code path.
//

extern LOGICAL KdpSearchInProgress;

//
// These variables store the current state of the search operation.
// They can be used to restore an interrupted search.
//

extern PFN_NUMBER KdpSearchStartPageFrame;
extern PFN_NUMBER KdpSearchEndPageFrame;

extern ULONG_PTR KdpSearchAddressRangeStart;
extern ULONG_PTR KdpSearchAddressRangeEnd;

//
// Checkpoint variable used to test if we have the right
// debugging symbols.
//

#define KDP_SEARCH_SYMBOL_CHECK 0xABCDDCBA

extern ULONG KdpSearchCheckPoint;

//
// Page search flags
//

#define KDP_SEARCH_ALL_OFFSETS_IN_PAGE 0x0001


//
// Define macros to lock and unlock the debug port.  The caller must have the
// proper IRQL before using these macros.
//

#define KdpPortLock()                   NOTHING
#define KdpPortUnlock()                 NOTHING


//
// Private procedure prototypes
//

VOID
KdpInitCom(
    VOID
    );

BOOLEAN
KdpPollBreakInWithPortLock(
    VOID
    );

USHORT
KdpReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader
    );

#if DBG

#define DPRINT(s) KdpDprintf s

VOID
KdpDprintf(
    IN PCHAR f,
    ...
    );

#else

#define DPRINT(s)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\ixkdcom.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.h

Abstract:

    This module contains the header file for a very simple com port package.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 19-Jul-1991
        Moved into HAL
--*/

#define COM1_PORT   0x03f8
#define COM2_PORT   0x02f8
#define COM3_PORT   0x03e8
#define COM4_PORT   0x02e8

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_56000    56000
#define BD_57600    57600

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01


//
// This bit controls the loopback testing mode of the device.  Basically
// the outputs are connected to the inputs (and vice versa).
//
#define SERIAL_MCR_LOOP     0x10

//
// This bit is used for general purpose output.
//
#define SERIAL_MCR_OUT1     0x04

//
// This bit contains the (complemented) state of the clear to send
// (CTS) line.
//
#define SERIAL_MSR_CTS      0x10

//
// This bit contains the (complemented) state of the data set ready
// (DSR) line.
//
#define SERIAL_MSR_DSR      0x20

//
// This bit contains the (complemented) state of the ring indicator
// (RI) line.
//
#define SERIAL_MSR_RI       0x40

//
// This bit contains the (complemented) state of the data carrier detect
// (DCD) line.
//
#define SERIAL_MSR_DCD      0x80

#define SERIAL_LSR_NOT_PRESENT  0xff

typedef struct _CPPORT {
    PUCHAR  Address;
    ULONG  Baud;
    USHORT  Flags;
    TIME_FIELDS     CarrierLostTime;
//    ULONG   LockVar;
//    KSPIN_LOCK Lock;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default

VOID
CpInitialize (
    PCPPORT  Port,
    PUCHAR  Address,
    ULONG Rate
    );

VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG  Rate
    );

USHORT
CpQueryBaud (
    PCPPORT  Port
    );

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    );

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR  Byte,
    BOOLEAN WaitForData
    );

VOID
CpLockPort (
    PCPPORT Port
    );

VOID
CpUnlockPort (
    PCPPORT Port
    );

VOID
CpStallExecution (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\kdcmsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcmsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

--*/

#include "kdp.h"

LARGE_INTEGER
KdpQueryPerformanceCounter (
    IN PKTRAP_FRAME TrapFrame
    )
/*++

    Routine Description:

        This function optionaly calls KeQueryPerformanceCounter for
        the debugger.  If the trap had interrupts off, then no call
        to KeQueryPerformanceCounter is possible and a NULL is returned.

    Return Value:

        returns KeQueryPerformanceCounter if possible.
        otherwise 0
--*/
{

    if (!(TrapFrame->EFlags & EFLAGS_INTERRUPT_MASK)) {
        LARGE_INTEGER LargeIntegerZero;

        LargeIntegerZero.QuadPart = 0;
        return LargeIntegerZero;
    } else {
        return KeQueryPerformanceCounter();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\kdinit.c ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    kdinit.c

Abstract:

    This module implements the initialization for the portable kernel debgger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdp.h"

#define ROM_BASE_ADDRESS            0xFFF00000
#define ROM_VERSION_OFFSET          30 // In DWORDs (0x78 is the absolute offset)
#define ROM_VERSION_KDDELAY_FLAG    0x80000000

VOID
KdInitSystem(
    BOOLEAN InitializingSystem
    )
/*++

Routine Description:

    This routine initializes the portable kernel debugger.

Arguments:

    InitializingSystem - Supplies a boolean value that determines whether we're
        called in the context of system initialization or bugcheck code.

Return Value:

    None.

--*/

{

    ULONG Index;
    BOOLEAN SuperIoInitialized;
    BOOLEAN Initialize;
    STRING NameString;

    //
    // If kernel debugger is already initialized, then return.
    //

    if (KdDebuggerEnabled != FALSE) {
        return;
    }

    KiDebugRoutine = KdpStub;

    //
    // Determine whether or not the debugger should be enabled.
    //
    // Note that if InitializingSystem == FALSE, then KdInitSystem was called
    // from BugCheck code. For this case the debugger is always enabled
    // to report the bugcheck if possible.
    //

    if (InitializingSystem) {

        //
        // Initialize the loader data table entry for XBOXKRNL.EXE and attach it
        // to the loaded module list.
        //

        KdpNtosDataTableEntry.DllBase = PsNtosImageBase;
        KdpNtosDataTableEntry.SizeOfImage =
            RtlImageNtHeader(PsNtosImageBase)->OptionalHeader.SizeOfImage;
        KdpNtosDataTableEntry.LoadedImports = (PVOID)MAXULONG_PTR;
        RtlInitUnicodeString(&KdpNtosDataTableEntry.FullDllName, L"xboxkrnl.exe");
        RtlInitUnicodeString(&KdpNtosDataTableEntry.BaseDllName, L"xboxkrnl.exe");

        InsertTailList(&KdLoadedModuleList, &KdpNtosDataTableEntry.InLoadOrderLinks);

        //
        // Initialize the debugger data block list when called at startup time.
        //

        InitializeListHead(&KdpDebuggerDataListHead);

        //
        // Fill in and register the debugger's debugger data block.
        // Most fields are already initialized, some fields will not be
        // filled in until later.
        //

        KdDebuggerDataBlock.KernBase = (ULONG_PTR) PsNtosImageBase;

        KdRegisterDebuggerDataBlock(KDBG_TAG,
                                    &KdDebuggerDataBlock.Header,
                                    sizeof(KdDebuggerDataBlock));

        //
        // Always initialize the kernel debugger if the system has a super I/O
        // controller that we can communicate with.
        //

        HalPulseHardwareMonitorPin();
        Initialize = HalInitializeSuperIo();

    } else {
        Initialize = TRUE;
    }

    if ((KdPortInitialize(&KdDebugParameters, Initialize) == FALSE) ||
        (Initialize == FALSE)) {
        return;
    }

    //
    // If we're going to delay the kernel debugger setup, then mark the debugger
    // as not present for now.
    //

    if (((PULONG)ROM_BASE_ADDRESS)[ROM_VERSION_OFFSET] & ROM_VERSION_KDDELAY_FLAG) {
        KdDebuggerNotPresent = TRUE;
    }

    //
    // Set address of kernel debugger trap routine.
    //

    KiDebugRoutine = KdpTrap;

    if (!KdpDebuggerStructuresInitialized) {

        KdpBreakpointInstruction = KDP_BREAKPOINT_VALUE;
        KdpOweBreakpoint = FALSE;

        //
        // Initialize the breakpoint table.
        //

        for (Index = 0; Index < BREAKPOINT_TABLE_SIZE; Index += 1) {
            KdpBreakpointTable[Index].Flags = 0;
            KdpBreakpointTable[Index].Address = NULL;
        }

        KdpDebuggerStructuresInitialized = TRUE ;
    }

    //
    //  Initialize timer facility - HACKHACK
    //

    KdPerformanceCounterRate = KeQueryPerformanceFrequency();
    KdTimerStart.HighPart = 0L;
    KdTimerStart.LowPart = 0L;

    //
    // Initialize ID for NEXT packet to send and Expect ID of next incoming
    // packet.
    //

    KdpNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
    KdpPacketIdExpected = INITIAL_PACKET_ID;

    //
    // Mark debugger enabled.
    //
    KdDebuggerEnabled = TRUE;

    //
    // Notify the debugger that XBOXKRNL.EXE is loaded.
    //

    if (InitializingSystem) {
        RtlInitAnsiString(&NameString, "xboxkrnl.exe");
        DbgLoadImageSymbols(&NameString, PsNtosImageBase, (ULONG)-1);
    }
}

BOOLEAN
KdRegisterDebuggerDataBlock(
    IN ULONG Tag,
    IN PDBGKD_DEBUG_DATA_HEADER64 DataHeader,
    IN ULONG Size
    )
/*++

Routine Description:

    This routine is called by a component or driver to register a
    debugger data block.  The data block is made accessible to the
    kernel debugger, thus providing a reliable method of exposing
    random data to debugger extensions.

Arguments:

    Tag - Supplies a unique 4 byte tag which is used to identify the
            data block.

    DataHeader - Supplies the address of the debugger data block header.
            The OwnerTag field must contain a unique value, and the Size
            field must contain the size of the data block, including the
            header.  If this block is already present, or there is
            already a block with the same value for OwnerTag, this one
            will not be inserted.  If Size is incorrect, this code will
            not notice, but the usermode side of the debugger might not
            function correctly.

    Size - Supplies the size of the data block, including the header.

Return Value:

    TRUE if the block was added to the list, FALSE if not.

--*/
{
    KIRQL OldIrql;
    PLIST_ENTRY List;
    PDBGKD_DEBUG_DATA_HEADER64 Header;

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Look for a record with the same tag or address
    //

    List = KdpDebuggerDataListHead.Flink;

    while (List != &KdpDebuggerDataListHead) {

        Header = CONTAINING_RECORD(List, DBGKD_DEBUG_DATA_HEADER64, List);

        List = List->Flink;

        if ((Header == DataHeader) || (Header->OwnerTag == Tag)) {
            KeLowerIrql(OldIrql);
            return FALSE;
        }
    }

    //
    // It wasn't already there, so add it.
    //

    DataHeader->OwnerTag = Tag;
    DataHeader->Size = Size;

    InsertTailList(&KdpDebuggerDataListHead, (PLIST_ENTRY)(&DataHeader->List));

    KeLowerIrql(OldIrql);

    return TRUE;
}

VOID
KdLogDbgPrint(
    IN PSTRING String
    )
{
    KIRQL OldIrql;
    ULONG Length;
    ULONG LengthCopied;

    KeRaiseIrql (HIGH_LEVEL, &OldIrql);

    if (KdPrintCircularBuffer) {
        Length = String->Length;
        //
        // truncate ridiculous strings
        //
        if (Length > KDPRINTBUFFERSIZE) {
            Length = KDPRINTBUFFERSIZE;
        }

        if (KdPrintWritePointer + Length <= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
            LengthCopied = KdpMoveMemory(KdPrintWritePointer, String->Buffer, Length);
            KdPrintWritePointer += LengthCopied;
            if (KdPrintWritePointer >= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
                KdPrintWritePointer = KdPrintCircularBuffer;
                KdPrintRolloverCount++;
            }
        } else {
            ULONG First = (ULONG)(KdPrintCircularBuffer + KDPRINTBUFFERSIZE - KdPrintWritePointer);
            LengthCopied = KdpMoveMemory(KdPrintWritePointer,
                                         String->Buffer,
                                         First);
            if (LengthCopied == First) {
                LengthCopied += KdpMoveMemory(KdPrintCircularBuffer,
                                              String->Buffer + First,
                                              Length - First);
            }
            if (LengthCopied > First) {
                KdPrintWritePointer = KdPrintCircularBuffer + LengthCopied - First;
                KdPrintRolloverCount++;
            } else {
                KdPrintWritePointer += LengthCopied;
                if (KdPrintWritePointer >= KdPrintCircularBuffer+KDPRINTBUFFERSIZE) {
                    KdPrintWritePointer = KdPrintCircularBuffer;
                    KdPrintRolloverCount++;
                }
            }
        }
    }

    KeLowerIrql(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\kdcpuapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcpuapi.c

Abstract:

    This module implements CPU specific remote debug APIs.

Author:

    Mark Lucovsky (markl) 04-Sep-1990

Revision History:

    24-sep-90   bryanwi

        Port to the x86.

--*/

#include "kdp.h"
#define END_OF_CONTROL_SPACE

extern ULONG KdpCurrentSymbolStart, KdpCurrentSymbolEnd;
extern ULONG KdSpecialCalls[];
extern ULONG KdNumberOfSpecialCalls;

BOOLEAN
KdpIsSpecialCall (
    ULONG Pc,
    PCONTEXT ContextRecord,
    UCHAR opcode,
    UCHAR ModRM
    );

/**** KdpIsTryFinallyReturn - detect finally optimization
*
*  Input:
*       pc - program counter of instruction to check
*       ContextRecord - machine specific context
*
*  Output:
*       returns TRUE if this is a try-finally returning to the same
*       scope
***************************************************************************/


BOOLEAN
KdpIsTryFinallyReturn (
    ULONG Pc,
    PCONTEXT ContextRecord
    )
{
    ULONG retaddr;
    ULONG calldisp;
    UCHAR inst;

    //
    //  The complier generates code for a try-finally that involves having
    //  a ret instruction that does not match with a call instruction.
    //  This ret never returns a value (ie, it's a c3 return and not a
    //  c2).  It always returns into the current symbol scope.  It is never
    //  preceeded by a leave, which (hopefully) should differentiate it
    //  from recursive returns.  Check for this, and if we find it count
    //  it as *0* level change.
    //
    //  As an optimization, the compiler will often change:
    //      CALL
    //      RET
    //  into:
    //      JMP
    //  In either case, we figure out the return address.  It's the first 4 bytes
    //  on the stack.
    //

    KdpMoveMemory( (PCHAR)&retaddr, (PCHAR)ContextRecord->Esp, 4 );

//  DPRINT(( "Start %x return %x end %x\n", KdpCurrentSymbolStart, retaddr, KdpCurrentSymbolEnd ));

    if ( (KdpCurrentSymbolStart < retaddr) && (retaddr < KdpCurrentSymbolEnd) ) {

        //
        //  Well, things aren't this nice.  We may have transferred but not yet
        //  updated the start/end.  This case occurs in a call to a thunk.  We
        //  look to see if the instruction before the return address is a call.
        //  Gross and not 100% reliable.
        //

        KdpMoveMemory( (PCHAR)&inst, (PCHAR)retaddr - 5, 1 );
        KdpMoveMemory( (PCHAR)&calldisp, (PCHAR)retaddr - 4, 4 );

        if (inst == 0xe8 && calldisp + retaddr == Pc) {
//  DPRINT(( "call to thunk @ %x\n", Pc ));
            return FALSE;
        }

        //
        //  returning to the current function.  Either a finally
        //  or a recursive return.  Check for a leave.  This is not 100%
        //  reliable since we are betting on an instruction longer than a byte
        //  and not ending with 0xc9.
        //

        KdpMoveMemory( (PCHAR)&inst, (PCHAR)Pc-1, 1 );

        if ( inst != 0xc9 ) {
            // not a leave.  Assume a try-finally.
//  DPRINT(( "transfer at %x is try-finally\n", Pc ));
            return TRUE;
        }
    }

    //
    //  This appears to be a true RET instruction
    //

    return FALSE;
}

/**** KdpLevelChange - say how the instruction affects the call level
*
*  Input:
*       pc - program counter of instruction to check
*       ContextRecord - machine specific context
*       SpecialCall - pointer to returned boolean indicating if the
*           instruction is a transfer to a special routine
*
*  Output:
*       returns -1 for a level pop, 1 for a push and 0 if it is
*       unchanged.
*  NOTE: This function belongs in some other file.  I should move it.
***************************************************************************/


LONG
KdpLevelChange (
    ULONG Pc,
    PCONTEXT ContextRecord,
    PBOOLEAN SpecialCall
    )
{
    UCHAR membuf[2];
    ULONG Addr;

    KdpMoveMemory( (PCHAR)membuf, (PCHAR)Pc, 2 );

    switch (membuf[0]) {
    case 0xe8:  //  CALL direct w/32 bit displacement
        //
        //  For try/finally, the compiler may, in addition to the push/ret trick
        //  below, use a call to the finally thunk.  Since we treat a RET to
        //  within the same symbol scope as not changing levels, we will also
        //  treat such a call as not changing levels either
        //

        KdpMoveMemory( (PCHAR)&Addr, (PCHAR)Pc+1, 4 );
        Addr += Pc + 5;

        if ((KdpCurrentSymbolStart <= Addr) && (Addr < KdpCurrentSymbolEnd)) {
            *SpecialCall = FALSE;
            return 0;
        }


    case 0x9a:  //  CALL segmented 16:32

        *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );
        return 1;

    case 0xff:
        //
        //  This is a compound instruction.  Dispatch on operation
        //
        switch (membuf[1] & 0x38) {
        case 0x10:  //  CALL with mod r/m
            *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );
            return 1;
        case 0x20:  //  JMP with mod r/m
            *SpecialCall = KdpIsSpecialCall( Pc, ContextRecord, membuf[0], membuf[1] );

            //
            //  If this is a try/finally, we'd like to treat it as call since the
            //  return inside the destination will bring us back to this context.
            //  However, if it is a jmp to a special routine, we must treat it
            //  as a no-level change operation since we won't see the special
            //  routines's return.
            //
            //  If it is not a try/finally, we'd like to treat it as a no-level
            //  change, unless again, it is a transfer to a special call which
            //  views this as a level up.
            //

            if (KdpIsTryFinallyReturn( Pc, ContextRecord )) {
                if (*SpecialCall) {
                    //
                    //  We won't see the return, so pretend it is just
                    //  inline code
                    //

                    return 0;

                } else {
                    //
                    //  The destinations return will bring us back to this
                    //  context
                    //

                    return 1;
                }
            } else if (*SpecialCall) {
                //
                //  We won't see the return but we are, indeed, doing one.
                //
                return -1;
            } else {
                return 0;
            }

        default:
            *SpecialCall = FALSE;
            return 0;
        }

    case 0xc3:  //  RET

        //
        //  If we are a try/finally ret, then we indicate that it is NOT a level
        //  change
        //

        if (KdpIsTryFinallyReturn( Pc, ContextRecord )) {
            *SpecialCall = FALSE;
            return 0;
        }

    case 0xc2:  //  RET  w/16 bit esp change
    case 0xca:  //  RETF w/16 bit esp change
    case 0xcb:  //  RETF
        *SpecialCall = FALSE;
        return -1;

    default:
        *SpecialCall = FALSE;
        return 0;
    }

} // KdpLevelChange

LONG
regValue(
    UCHAR reg,
    PCONTEXT ContextRecord
    )
{
    switch (reg) {
    case 0x0:
        return(ContextRecord->Eax);
        break;
    case 0x1:
        return(ContextRecord->Ecx);
        break;
    case 0x2:
        return(ContextRecord->Edx);
        break;
    case 0x3:
        return(ContextRecord->Ebx);
        break;
    case 0x4:
        return(ContextRecord->Esp);
        break;
    case 0x5:
        return(ContextRecord->Ebp);
        break;
    case 0x6:
        return(ContextRecord->Esi);
        break;
    case 0x7:
        return(ContextRecord->Edi);
        break;
    }

    return 0; // we should never get here.

}

BOOLEAN
KdpIsSpecialCall (
    ULONG Pc,
    PCONTEXT ContextRecord,
    UCHAR opcode,
    UCHAR modRM
    )

/*++

Routine Description:

    Check to see if the instruction at pc is a call to one of the
    SpecialCall routines.

Argument:

    Pc - program counter of instruction in question.

--*/
{
    UCHAR sib;
    USHORT twoBytes;
    ULONG callAddr;
    ULONG addrAddr;
    LONG offset;
    ULONG i;
    char d8;

    if ( opcode == 0xe8 ) {

        //
        // Signed offset from pc
        //

        KdpMoveMemory( (PCHAR)&offset, (PCHAR)Pc+1, 4 );

        callAddr = Pc + offset + 5; // +5 for instr len.

    } else if ( opcode == 0xff ) {

        if ( ((modRM & 0x38) != 0x10) && ((modRM & 0x38) != 0x20) ) {
            // not call or jump
            return FALSE;
        }
        if ( (modRM & 0x08) == 0x08 ) {
            // m16:16 or m16:32 -- we don't handle this
            return FALSE;
        }

        if ( (modRM & 0xc0) == 0xc0 ) {

            /* Direct register addressing */
            callAddr = regValue( (UCHAR)(modRM&0x7), ContextRecord );

        } else if ( (modRM & 0xc7) == 0x05 ) {
            //
            // Calls across dll boundaries involve a call into a jump table,
            // wherein the jump address is set to the real called routine at DLL
            // load time.  Check to see if we're calling such an instruction,
            // and if so, compute its target address and set callAddr there.
            //
            //  ff15 or ff25 -- call or jump indirect with disp32.  Get
            //  address of address
            //
            KdpMoveMemory( (PCHAR)&addrAddr, (PCHAR)Pc+2, 4 );

            //
            //  Get real destination address
            //
            KdpMoveMemory( (PCHAR)&callAddr, (PCHAR)addrAddr, 4 );
//  DPRINT(( "Indirect call/jmp @ %x\n", Pc ));
        } else if ( (modRM & 0x7) == 0x4 ) {

            LONG indexValue;

            /* sib byte present */
            KdpMoveMemory( (PCHAR)&sib, (PCHAR)Pc+2, 1 );
            indexValue = regValue( (UCHAR)((sib & 0x31) >> 3), ContextRecord );
            switch ( sib&0xc0 ) {
            case 0x0:  /* x1 */
                break;
            case 0x40:
                indexValue *= 2;
                break;
            case 0x80:
                indexValue *= 4;
                break;
            case 0xc0:
                indexValue *= 8;
                break;
            } /* switch */

            switch ( modRM & 0xc0 ) {

            case 0x0: /* no displacement */
                if ( (sib & 0x7) == 0x5 ) {
//                  DPRINT(("funny call #1 at %x\n", Pc));
                    return FALSE;
                }
                callAddr = indexValue + regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0x40:
                if ( (sib & 0x6) == 0x4 ) {
//                  DPRINT(("Funny call #2\n")); /* calling into the stack */
                    return FALSE;
                }
                KdpMoveMemory( &d8, (PCHAR)Pc+3,1 );
                callAddr = indexValue + d8 +
                                    regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0x80:
                if ( (sib & 0x6) == 0x4 ) {
//                  DPRINT(("Funny call #3\n")); /* calling into the stack */
                    return FALSE;
                }
                KdpMoveMemory( (PCHAR)&offset, (PCHAR)Pc+3, 4 );
                callAddr = indexValue + offset +
                                    regValue((UCHAR)(sib&0x7), ContextRecord );
                break;

            case 0xc0:
                ASSERT( FALSE );
                break;

            }

        } else {
            //KdPrint(( "undecoded call at %x\n",
            //            CONTEXT_TO_PROGRAM_COUNTER(ContextRecord) ));
            return FALSE;
        }

    } else if ( opcode == 0x9a ) {

        /* Absolute address call (best I can tell, cc doesn't generate this) */
        KdpMoveMemory( (PCHAR)&callAddr, (PCHAR)Pc+1, 4 );

    } else {
        return FALSE;
    }

    //
    // Calls across dll boundaries involve a call into a jump table,
    // wherein the jump address is set to the real called routine at DLL
    // load time.  Check to see if we're calling such an instruction,
    // and if so, compute its target address and set callAddr there.
    //

#if 0
    KdpMoveMemory( (PCHAR)&twoBytes, (PCHAR)callAddr, 2 );
    if ( twoBytes == 0x25ff ) { /* i386 is little-Endian; really 0xff25 */

        //
        // This is a 'jmp dword ptr [mem]' instruction, which is the sort of
        // jump used for a dll-boundary crossing call.  Fixup callAddr.
        //

        KdpMoveMemory( (PCHAR)&addrAddr, (PCHAR)callAddr+2, 4 );
        KdpMoveMemory( (PCHAR)&callAddr, (PCHAR)addrAddr, 4 );
    }
#endif

    for ( i = 0; i < KdNumberOfSpecialCalls; i++ ) {
        if ( KdSpecialCalls[i] == callAddr ) {
            return TRUE;
        }
    }
    return FALSE;

}

VOID
KdpSetLoadState(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record for the load symbol case.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{

    ULONG Count;
    PVOID End;

    //
    // Store the special x86 register into the control report structure.
    //

    WaitStateChange->ControlReport.Dr6 = KdProcessorState.SpecialRegisters.KernelDr6;
    WaitStateChange->ControlReport.Dr7 = KdProcessorState.SpecialRegisters.KernelDr7;

    //
    // Copy the immediate instruction stream into the control report structure.
    //

    Count = KdpMoveMemory((PCHAR)(&(WaitStateChange->ControlReport.InstructionStream[0])),
                          (PCHAR)(WaitStateChange->ProgramCounter),
                          DBGKD_MAXSTREAM);

    WaitStateChange->ControlReport.InstructionCount = (USHORT)Count;

    //
    // Clear breakpoints in the copied instruction stream. If any breakpoints
    // are cleared, then recopy the instruction stream.
    //

    End = (PVOID)((PUCHAR)(WaitStateChange->ProgramCounter) + Count - 1);
    if (KdpDeleteBreakpointRange((PVOID)WaitStateChange->ProgramCounter, End) != FALSE) {
        KdpMoveMemory(&WaitStateChange->ControlReport.InstructionStream[0],
                      (PVOID)WaitStateChange->ProgramCounter,
                      Count);
    }

    //
    // Store the segment registers into the control report structure and set the
    // control flags.
    //

    WaitStateChange->ControlReport.SegCs = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegEs = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegFs = KGDT_R0_PCR;
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;
    WaitStateChange->ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;

    //
    //  Copy context record into wait state change structure.
    //

    KdpMoveMemory((PCHAR)(&WaitStateChange->Context),
                  (PCHAR)ContextRecord,
                  sizeof(*ContextRecord));

    return;
}

VOID
KdpSetStateChange(
    IN PX86_NT5_DBGKD_WAIT_STATE_CHANGE64 WaitStateChange,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PX86_NT5_CONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    Fill in the Wait_State_Change message record.

Arguments:

    WaitStateChange - Supplies pointer to record to fill in

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    SecondChance - Supplies a boolean value that determines whether this is
        the first or second chance for the exception.

Return Value:

    None.

--*/

{
    BOOLEAN status;

    //
    //  Set up description of event, including exception record
    //

    WaitStateChange->NewState = DbgKdExceptionStateChange;
    WaitStateChange->ProcessorLevel = 6;
    WaitStateChange->Processor = (USHORT)0;
    WaitStateChange->NumberProcessors = (ULONG)1;
    WaitStateChange->Thread = (ULONG64)(LONG64)(LONG_PTR) KeGetCurrentThread();
    WaitStateChange->ProgramCounter = (ULONG64)(LONG64)(LONG_PTR) CONTEXT_TO_PROGRAM_COUNTER(ContextRecord);
    if (sizeof(EXCEPTION_RECORD) == sizeof(WaitStateChange->u.Exception.ExceptionRecord)) {
        KdpQuickMoveMemory((PCHAR)&WaitStateChange->u.Exception.ExceptionRecord,
                           (PCHAR)ExceptionRecord,
                           sizeof(EXCEPTION_RECORD));
    } else {
        ExceptionRecord32To64((PEXCEPTION_RECORD32)ExceptionRecord,
                              &WaitStateChange->u.Exception.ExceptionRecord
                              );
    }
    WaitStateChange->u.Exception.FirstChance = !SecondChance;

    //
    //  Copy instruction stream immediately following location of event
    //

    WaitStateChange->ControlReport.InstructionCount =
        (USHORT)KdpMoveMemory(
            (PCHAR)(&(WaitStateChange->ControlReport.InstructionStream[0])),
            (PCHAR)(WaitStateChange->ProgramCounter),
            DBGKD_MAXSTREAM
            );

    //
    //  Copy context record immediately following instruction stream
    //

    KdpMoveMemory(
        (PCHAR)(&WaitStateChange->Context),
        (PCHAR)ContextRecord,
        sizeof(*ContextRecord)
        );

    //
    //  Clear breakpoints in copied area
    //

    status = KdpDeleteBreakpointRange(
        (PVOID)WaitStateChange->ProgramCounter,
        (PVOID)((PUCHAR)WaitStateChange->ProgramCounter +
            WaitStateChange->ControlReport.InstructionCount - 1)
        );

    //
    //  If there were any breakpoints cleared, recopy the area without them
    //

    if (status == TRUE) {
        KdpMoveMemory(
            (PUCHAR) &(WaitStateChange->ControlReport.InstructionStream[0]),
            (PUCHAR) WaitStateChange->ProgramCounter,
            WaitStateChange->ControlReport.InstructionCount
            );
    }

    //
    //  Special registers for the x86
    //

    WaitStateChange->ControlReport.Dr6 =
        KdProcessorState.SpecialRegisters.KernelDr6;

    WaitStateChange->ControlReport.Dr7 =
        KdProcessorState.SpecialRegisters.KernelDr7;

    WaitStateChange->ControlReport.SegCs  = (USHORT)(ContextRecord->SegCs);
    WaitStateChange->ControlReport.SegDs  = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegEs  = KGDT_R0_DATA;
    WaitStateChange->ControlReport.SegFs  = KGDT_R0_PCR;
    WaitStateChange->ControlReport.EFlags = ContextRecord->EFlags;

    WaitStateChange->ControlReport.ReportFlags = REPORT_INCLUDES_SEGS;

}

VOID
KdpGetStateChange(
    IN PDBGKD_MANIPULATE_STATE64 ManipulateState,
    IN PX86_NT5_CONTEXT ContextRecord
    )

/*++

Routine Description:

    Extract continuation control data from Manipulate_State message

Arguments:

    ManipulateState - supplies pointer to Manipulate_State packet

    ContextRecord - Supplies a pointer to a context record.

Return Value:

    None.

--*/

{
    if (NT_SUCCESS(ManipulateState->u.Continue2.ContinueStatus) == TRUE) {

        //
        // If NT_SUCCESS returns TRUE, then the debugger is doing a
        // continue, and it makes sense to apply control changes.
        // Otherwise the debugger is saying that it doesn't know what
        // to do with this exception, so control values are ignored.
        //

        if (ManipulateState->u.Continue2.ControlSet.TraceFlag == TRUE) {
            ContextRecord->EFlags |= 0x100L;

        } else {
            ContextRecord->EFlags &= ~0x100L;

        }

        KdProcessorState.SpecialRegisters.KernelDr7 =
            ManipulateState->u.Continue2.ControlSet.Dr7;
        KdProcessorState.SpecialRegisters.KernelDr6 = 0L;

        if (ManipulateState->u.Continue2.ControlSet.CurrentSymbolStart != 1) {
            KdpCurrentSymbolStart = ManipulateState->u.Continue2.ControlSet.CurrentSymbolStart;
            KdpCurrentSymbolEnd = ManipulateState->u.Continue2.ControlSet.CurrentSymbolEnd;
        }
    }
}

VOID
KdpReadControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a read control space state
    manipulation message.  Its function is to read implementation
    specific system data.

    IMPLEMENTATION NOTE:

        On the X86, control space is defined as follows:

            0:  Base of KPROCESSOR_STATE structure. (KPRCB.ProcessorState)
                    This includes CONTEXT record,
                    followed by a SPECIAL_REGISTERs record

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

    Context - Supplies the current context.

Return Value:

    None.

--*/

{
    PDBGKD_READ_MEMORY64 a = &m->u.ReadMemory;
    STRING MessageHeader;
    ULONG Length, t;
    PVOID StartAddr;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    if (a->TransferCount > (PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64))) {
        Length = PACKET_MAX_SIZE - sizeof(DBGKD_MANIPULATE_STATE64);
    } else {
        Length = a->TransferCount;
    }
    if ((a->TargetBaseAddress < (ULONG64)(sizeof(KdProcessorState))) &&
        (m->Processor < (USHORT)1)) {
        t = (ULONG)(sizeof(KdProcessorState)) - (ULONG)(a->TargetBaseAddress);
        if (t < Length) {
            Length = t;
        }
        StartAddr = (PVOID)((ULONG)a->TargetBaseAddress +
                            (ULONG)&KdProcessorState);
        AdditionalData->Length = (USHORT)KdpMoveMemory(
                                    AdditionalData->Buffer,
                                    StartAddr,
                                    Length
                                    );

        if (Length == AdditionalData->Length) {
            m->ReturnStatus = STATUS_SUCCESS;
        } else {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
        a->ActualBytesRead = AdditionalData->Length;

    } else {
        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesRead = 0;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData
        );
}

VOID
KdpWriteControlSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write control space state
    manipulation message.  Its function is to write implementation
    specific system data.

    Control space for x86 is as defined above.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_WRITE_MEMORY64 a = &m->u.WriteMemory;
    ULONG Length;
    STRING MessageHeader;
    PVOID StartAddr;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    if ((((PUCHAR)a->TargetBaseAddress + a->TransferCount) <=
        (PUCHAR)(sizeof(KdProcessorState))) && (m->Processor < (USHORT)1)) {

        StartAddr = (PVOID)((ULONG)a->TargetBaseAddress +
                            (ULONG)&KdProcessorState);

        Length = KdpMoveMemory(
                            StartAddr,
                            AdditionalData->Buffer,
                            AdditionalData->Length
                            );

        if (Length == AdditionalData->Length) {
            m->ReturnStatus = STATUS_SUCCESS;
        } else {
            m->ReturnStatus = STATUS_UNSUCCESSFUL;
        }
        a->ActualBytesWritten = Length;

    } else {
        AdditionalData->Length = 0;
        m->ReturnStatus = STATUS_UNSUCCESSFUL;
        a->ActualBytesWritten = 0;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        AdditionalData
        );
}

VOID
KdpReadIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a read io space state
    manipulation message.  Its function is to read system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    //
    // Check Size and Alignment
    //

    switch ( a->DataSize ) {
        case 1:
            a->DataValue = (ULONG)(UCHAR)_inp((PUCHAR)a->IoAddress);
            break;
        case 2:
            if ((ULONG)a->IoAddress & 1 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                a->DataValue = (ULONG)(USHORT)_inpw((PUSHORT)a->IoAddress);
            }
            break;
        case 4:
            if ((ULONG)a->IoAddress & 3 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                a->DataValue = _inpd((PULONG)a->IoAddress);
            }
            break;
        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

VOID
KdpWriteIoSpace(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write io space state
    manipulation message.  Its function is to write to system io
    locations.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_IO64 a = &m->u.ReadWriteIo;
    STRING MessageHeader;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    //
    // Check Size and Alignment
    //

    switch ( a->DataSize ) {
        case 1:
            _outp((PUCHAR)a->IoAddress, (UCHAR)a->DataValue);
            break;
        case 2:
            if ((ULONG)a->IoAddress & 1 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                _outpw((PUSHORT)a->IoAddress, (USHORT)a->DataValue);
            }
            break;
        case 4:
            if ((ULONG)a->IoAddress & 3 ) {
                m->ReturnStatus = STATUS_DATATYPE_MISALIGNMENT;
            } else {
                _outpd((PULONG)a->IoAddress, a->DataValue);
            }
            break;
        default:
            m->ReturnStatus = STATUS_INVALID_PARAMETER;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

VOID
KdpReadMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a read MSR
    manipulation message.  Its function is to read the MSR.

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    LARGE_INTEGER l;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    try {
        l.QuadPart = RDMSR(a->Msr);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        l.QuadPart = 0;
        m->ReturnStatus = STATUS_NO_SUCH_DEVICE;
    }

    a->DataValueLow  = l.LowPart;
    a->DataValueHigh = l.HighPart;

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

VOID
KdpWriteMachineSpecificRegister(
    IN PDBGKD_MANIPULATE_STATE64 m,
    IN PSTRING AdditionalData
    )

/*++

Routine Description:

    This function is called in response of a write of a MSR
    manipulation message.  Its function is to write to the MSR

Arguments:

    m - Supplies the state manipulation message.

    AdditionalData - Supplies any additional data for the message.

Return Value:

    None.

--*/

{
    PDBGKD_READ_WRITE_MSR a = &m->u.ReadWriteMsr;
    STRING MessageHeader;
    LARGE_INTEGER l;

    MessageHeader.Length = sizeof(*m);
    MessageHeader.Buffer = (PCHAR)m;

    ASSERT(AdditionalData->Length == 0);

    m->ReturnStatus = STATUS_SUCCESS;

    l.HighPart = a->DataValueHigh;
    l.LowPart = a->DataValueLow;

    try {
        WRMSR (a->Msr, l.QuadPart);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        m->ReturnStatus = STATUS_NO_SUCH_DEVICE;
    }

    KdpSendPacket(
        PACKET_TYPE_KD_STATE_MANIPULATE,
        &MessageHeader,
        NULL
        );
}

/*
 * Find the return address of the current function.  Only works when
 * locals haven't yet been pushed (ie, on the first instruction of the
 * function).
 */

ULONG
KdpGetReturnAddress (
    PCONTEXT ContextRecord
    )
{
    ULONG retaddr;

    KdpMoveMemory((PCHAR)(&retaddr), (PCHAR)(ContextRecord->Esp), 4 );
    return retaddr;

} // KdpGetReturnAddress

/*** KdpGetCallNextOffset - compute "next" instruction on a call-like instruction
*
*   Purpose:
*       Compute how many bytes are in a call-type instruction
*       so that a breakpoint can be set upon this instruction's
*       return.  Treat indirect jmps as if they were call/ret/ret
*
*   Returns:
*       offset to "next" instruction, or 0 if it wasn't a call instruction.
*
*************************************************************************/

ULONG
KdpGetCallNextOffset (
    ULONG Pc,
    PCONTEXT ContextRecord
    )
{
    UCHAR membuf[2];
    UCHAR opcode;
    ULONG sib;
    ULONG disp;

    KdpMoveMemory( membuf, (PVOID)Pc, 2 );
    opcode = membuf[0];

    if ( opcode == 0xe8 ) {         //  CALL 32 bit disp
        return Pc+5;
    } else if ( opcode == 0x9a ) {  //  CALL 16:32
        return Pc+7;
    } else if ( opcode == 0xff ) {
        if ( membuf[1] == 0x25) {   //  JMP indirect
            return KdpGetReturnAddress( ContextRecord );
        }
        sib = ((membuf[1] & 0x07) == 0x04) ? 1 : 0;
        disp = (membuf[1] & 0xc0) >> 6;
        switch (disp) {
        case 0:
            if ( (membuf[1] & 0x07) == 0x05 ) {
                disp = 4; // disp32 alone
            } else {
                // disp = 0; // no displacement with reg or sib
            }
            break;
        case 1:
            // disp = 1; // disp8 with reg or sib
            break;
        case 2:
            disp = 4; // disp32 with reg or sib
            break;
        case 3:
            disp = 0; // direct register addressing (e.g., call esi)
            break;
        }
        return Pc + 2 + sib + disp;
    }

    return 0;

} // KdpGetCallNextOffset
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\ixkdcom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.c

Abstract:

    This module contains a very simply package to do com I/O on machines
    with standard AT com-ports.  It is C code derived from the debugger's
    com code.  Likely does not work on a PS/2.  (Only rewrote the thing
    into C so we wouldn't have to deal with random debugger macros.)

    Procedures to init a com object, set and query baud rate, output
    character, input character.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 12-Jun-1991
        Added ability to check for com-port's existence and hook onto the
        highest com-port available.

    John Vert (jvert) 19-Jul-1991
        Moved into HAL

--*/

#include    "kdp.h"
#include    "ixkdcom.h"
// timeout was 1024 * 500, but at 115200 baud, this should be enough
#define     TIMEOUT_COUNT  1024 * 100

UCHAR CpReadLsr (PCPPORT, UCHAR);

BOOLEAN KdDbgPortsPresent = TRUE;
UCHAR   KdDbgErrorCount;

#define DBG_ACCEPTABLE_ERRORS   25

VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR  Address,
    ULONG  Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{
    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    _outp(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    _outp(hwport, ier);
}

VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG   Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{
    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = (UCHAR)_inp(hwport);

    lcr |= LC_DLAB;
    _outp(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    _outp(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    _outp(hwport, (UCHAR)(divisorlatch & 0xff));


    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    _outp(hwport, 3);


    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR   waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/
{
    UCHAR   lsr;

    lsr = (UCHAR)_inp(Port->Address + COM_LSR);

    //
    // Check to see if the port still exists.
    //
    if (lsr == SERIAL_LSR_NOT_PRESENT) {

        KdDbgErrorCount++;

        if (KdDbgErrorCount >= DBG_ACCEPTABLE_ERRORS) {
            KdDbgPortsPresent = FALSE;
            KdDbgErrorCount = 0;
        }
        return SERIAL_LSR_NOT_PRESENT;
    }

    if (lsr & waiting) {
        return lsr;
    }

    return lsr;
}

VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{
    if (KdDbgPortsPresent == FALSE) {
        return;
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    _outp(Port->Address + COM_DAT, Byte);
}

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.

    Return Value:

        CP_GET_SUCCESS if data returned.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{
    UCHAR   lsr;
    UCHAR   value;
    ULONG   limitcount;

    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //

    if (Port->Address == NULL) {
        return(CP_GET_NODATA);
    }

    if (KdDbgPortsPresent == FALSE) {

        if (CpReadLsr(Port, COM_DATRDY) == SERIAL_LSR_NOT_PRESENT) {

            return(CP_GET_NODATA);
        } else {

            CpSetBaud(Port, Port->Baud);
            KdDbgPortsPresent = TRUE;
        }
    }

    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);

        if (lsr == SERIAL_LSR_NOT_PRESENT) {
            return(CP_GET_NODATA);
        }

        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //
            if (lsr & (COM_FE | COM_PE | COM_OE)) {
                *Byte = 0;
                return(CP_GET_ERROR);
            }

            //
            // fetch the byte
            //

            value = (UCHAR)_inp(Port->Address + COM_DAT);

            *Byte = value & (UCHAR)0xff;
            return CP_GET_SUCCESS;
        }
    }

    CpReadLsr (Port, 0);
    return CP_GET_NODATA;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\apcobj.c ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    apcobj.c

Abstract:

    This module implements the kernel APC object. Functions are provided
    to initialize, flush, insert, and remove APC objects.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input apc is
// really a kapc and not something else, like deallocated pool.
//

#define ASSERT_APC(E) {             \
    ASSERT((E)->Type == ApcObject); \
}


VOID
KeInitializeApc (
    IN PRKAPC Apc,
    IN PRKTHREAD Thread,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine OPTIONAL,
    IN PKNORMAL_ROUTINE NormalRoutine OPTIONAL,
    IN KPROCESSOR_MODE ApcMode OPTIONAL,
    IN PVOID NormalContext OPTIONAL
    )

/*++

Routine Description:

    This function initializes a kernel APC object. The thread, kernel
    routine, and optionally a normal routine, processor mode, and normal
    context parameter are stored in the APC object.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelRoutine - Supplies a pointer to a function that is to be
        executed at IRQL APC_LEVEL in kernel mode.

    RundownRoutine - Supplies an optional pointer to a function that is to be
        called if the APC is in a thread's APC queue when the thread terminates.

    NormalRoutine - Supplies an optional pointer to a function that is
        to be executed at IRQL 0 in the specified processor mode. If this
        parameter is not specified, then the ProcessorMode and NormalContext
        parameters are ignored.

    ApcMode - Supplies the processor mode in which the function specified
        by the NormalRoutine parameter is to be executed.

    NormalContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the NormalRoutine parameter.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    Apc->Type = ApcObject;

    //
    // Initialize the APC environment, thread address, kernel routine address,
    // rundown routine address, normal routine address, processor mode, and
    // normal context parameter. If the normal routine address is null, then
    // the processor mode is defaulted to KernelMode and the APC is a special
    // APC. Otherwise, the processor mode is taken from the argument list.
    //

    Apc->Thread = Thread;
    Apc->KernelRoutine = KernelRoutine;
    Apc->RundownRoutine = RundownRoutine;
    Apc->NormalRoutine = NormalRoutine;
    if (ARGUMENT_PRESENT(NormalRoutine)) {
        Apc->ApcMode = ApcMode;
        Apc->NormalContext = NormalContext;

    } else {
        Apc->ApcMode = KernelMode;
        Apc->NormalContext = NIL;
    }

    Apc->Inserted = FALSE;
    return;
}

PLIST_ENTRY
KeFlushQueueApc (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE ApcMode
    )

/*++

Routine Description:

    This function flushes the APC queue selected by the specified processor
    mode for the specified thread. An APC queue is flushed by removing the
    listhead from the list, scanning the APC entries in the list, setting
    their inserted variables to FALSE, and then returning the address of the
    doubly linked list as the function value.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    ApcMode - Supplies the processor mode of the APC queue that is to
        be flushed.

Return Value:

    The address of the first entry in the list of APC objects that were flushed
    from the specified APC queue.

--*/

{

    PKAPC Apc;
    PLIST_ENTRY FirstEntry;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and
    // lock the APC queue.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // Get address of first APC in the list and check if the list is
    // empty or contains entries that should be flushed. If entries
    // should be flushed, then scan the list of APC objects and set their
    // inserted state to FALSE.
    //

    FirstEntry = Thread->ApcState.ApcListHead[ApcMode].Flink;
    if (FirstEntry == &Thread->ApcState.ApcListHead[ApcMode]) {
        FirstEntry = (PLIST_ENTRY)NULL;

    } else {
        RemoveEntryList(&Thread->ApcState.ApcListHead[ApcMode]);
        NextEntry = FirstEntry;
        do {
            Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
            Apc->Inserted = FALSE;
            NextEntry = NextEntry->Flink;
        } while (NextEntry != FirstEntry);
    }

    //
    // Unlock the APC queue, unlock the dispatcher database, lower IRQL to
    // its previous value, and return address of first entry in list of APC
    // objects that were flushed.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return FirstEntry;
}

BOOLEAN
KeInsertQueueApc (
    IN PRKAPC Apc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into the APC queue specifed by the
    thread and processor mode fields of the APC object. If the APC object
    is already in an APC queue or APC queuing is disabled, then no operation
    is performed. Otherwise the APC object is inserted in the specified queue
    and appropriate scheduling decisions are made.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    SystemArgument1, SystemArgument2 - Supply a set of two arguments that
        contain untyped data provided by the executive.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue or APC queuing is disabled,
    then a value of FALSE is returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If APC queuing is disabled, then set inserted to FALSE. Else save
    // system parameter values in APC object, and attempt to queue APC.
    //

    Thread = Apc->Thread;
    if (Thread->ApcState.ApcQueueable == FALSE) {
        Inserted = FALSE;

    } else {
        Apc->SystemArgument1 = SystemArgument1;
        Apc->SystemArgument2 = SystemArgument2;
        Inserted = KiInsertQueueApc(Apc, Increment);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value,
    // and return whether APC object was inserted in APC queue.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}

BOOLEAN
KeRemoveQueueApc (
    IN PKAPC Apc
    )

/*++

Routine Description:

    This function removes an APC object from an APC queue. If the APC object
    is not in an APC queue, then no operation is performed. Otherwise the
    APC object is removed from its current queue and its inserted state is
    set FALSE.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

Return Value:

    If the APC object is not in an APC queue, then a value of FALSE is returned.
    Otherwise a value of TRUE is returned.

--*/

{

    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    ASSERT_APC(Apc);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and
    // lock the APC queue.
    //

    Thread = Apc->Thread;
    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // If the APC object is in an APC queue, then remove it from the queue
    // and set its inserted state to FALSE. If the queue becomes empty, set
    // the APC pending state to FALSE.
    //

    Inserted = Apc->Inserted;
    if (Inserted != FALSE) {
        Apc->Inserted = FALSE;
        ApcState = &Thread->ApcState;
        RemoveEntryList(&Apc->ApcListEntry);
        if (IsListEmpty(&ApcState->ApcListHead[Apc->ApcMode]) != FALSE) {
            if (Apc->ApcMode == KernelMode) {
                ApcState->KernelApcPending = FALSE;

            } else {
                ApcState->UserApcPending = FALSE;
            }
        }
    }

    //
    // Unlock the APC queue, unlock the dispatcher database, lower IRQL to
    // its previous value, and return whether an APC object was removed from
    // the APC queue.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kdlite\kdlitep.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    kdlitep.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the Xbox lite kernel debugger.

--*/

#ifndef _KDLITEP_
#define _KDLITEP_

#include <ntos.h>
#include "ki.h"

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

//
// Define the base address of the serial port.
//

#define KDLITE_DEBUG_BASE_ADDRESS   0x3F8

//
// Define the baud rate for transmission over the serial port.
//

#define KDLITE_DEBUG_BAUD_RATE      19200

//
// Define various constants related to the serial port.
//

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// External symbols.
//

extern PKDEBUG_ROUTINE KiDebugRoutine;

#endif  // KDLITEP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\procstat.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    procstat.asm
;
; Abstract:
;
;    This module implements procedures for saving and restoring
;    processor control state, and processor run&control state.
;    These procedures support debugging of UP and MP systems.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 30-Aug-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.586p
        .xlist
include ks386.inc
include callconv.inc
        .list

        page ,132
KDCODE  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page    ,132
        subttl  "Save Processor Control State"
;++
;
; KdpSaveProcessorControlState(
;       PX86_NT5_KPROCESSOR_STATE   ProcessorState
;       );
;
; Routine Description:
;
;    This routine saves the control subset of the processor state.
;    (Saves the same information as KdpSaveProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT saved.)
;    Called by the debug subsystem, and KdpSaveProcessorState()
;
;   N.B.  This procedure will save Dr7, and then 0 it.  This prevents
;         recursive hardware trace breakpoints and allows debuggers
;         to work.
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KdpSaveProcessorControlState   ,1

        mov     edx, [esp+4]                    ; ProcessorState

;
; Save special registers for debugger
;
        xor     ecx,ecx

        mov     eax, cr0
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr0, eax
        mov     eax, cr2
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr2, eax
        mov     eax, cr3
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr3, eax
        mov     eax, cr4
        mov     [edx].PsNT5SpecialRegisters.SrNT5Cr4, eax

        mov     eax,dr0
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr0,eax
        mov     eax,dr1
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr1,eax
        mov     eax,dr2
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr2,eax
        mov     eax,dr3
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr3,eax
        mov     eax,dr6
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr6,eax

        mov     eax,dr7
        mov     dr7,ecx
        mov     [edx].PsNT5SpecialRegisters.SrNT5KernelDr7,eax

        sgdt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Gdtr
        sidt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Idtr

        str     word ptr [edx].PsNT5SpecialRegisters.SrNT5Tr
        sldt    word ptr [edx].PsNT5SpecialRegisters.SrNT5Ldtr

        stdRET    _KdpSaveProcessorControlState

stdENDP _KdpSaveProcessorControlState

        page    ,132
        subttl  "Restore Processor Control State"
;++
;
; KdpRestoreProcessorControlState(
;       PX86_NT5_KPROCESSOR_STATE   ProcessorState
;       );
;
; Routine Description:
;
;    This routine restores the control subset of the processor state.
;    (Restores the same information as KdpRestoreProcessorState EXCEPT that
;     data in TrapFrame/ExceptionFrame=Context record is NOT restored.)
;    Called by the debug subsystem, and KdpRestoreProcessorState()
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KdpRestoreProcessorControlState,1

        mov     edx, [esp+4]                    ; (edx)->ProcessorState

;
; Restore special registers for debugger
;

        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr0
        mov     cr0, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr2
        mov     cr2, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr3
        mov     cr3, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Cr4
        mov     cr4, eax

        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr0
        mov     dr0, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr1
        mov     dr1, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr2
        mov     dr2, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr3
        mov     dr3, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr6
        mov     dr6, eax
        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5KernelDr7
        mov     dr7, eax

        lgdt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Gdtr
        lidt    fword ptr [edx].PsNT5SpecialRegisters.SrNT5Idtr

;
; Force the TSS descriptor into a non-busy state, so we don't fault
; when we load the TR.
;

        mov     eax, [edx].PsNT5SpecialRegisters.SrNT5Gdtr+2  ; (eax)->GDT base
        xor     ecx, ecx
        mov     cx,  word ptr [edx].PsNT5SpecialRegisters.SrNT5Tr
        add     eax, 5
        add     eax, ecx                                ; (eax)->TSS Desc. Byte
        and     byte ptr [eax],NOT 2
        ltr     word ptr [edx].PsNT5SpecialRegisters.SrNT5Tr

        lldt    word ptr [edx].PsNT5SpecialRegisters.SrNT5Ldtr

        stdRET    _KdpRestoreProcessorControlState

stdENDP _KdpRestoreProcessorControlState

KDCODE  ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\xxkdsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xxkdsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

    John Vert (jvert) 11-Jul-1991
        Moved from KD/i386 to HAL

--*/

#include "kdp.h"
#include "ixkdcom.h"

//
// This MUST be initialized to zero so we know not to do anything when
// CpGetByte is called when the kernel debugger is disabled.
//

CPPORT KdPort = {NULL, 0, PORT_DEFAULTRATE };

//
// Remember the debugger port information
//

CPPORT KdPortInformation = {NULL, 0, PORT_DEFAULTRATE};

BOOLEAN
KdPortInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    BOOLEAN Initialize
    )

/*++

Routine Description:

    This procedure checks for which COM port should be used by kernel
    debugger.  If DebugParameter specifies a COM port, we will use it
    even if we can not find it (we trust user).  Otherwise, if COM2
    is present and there is no mouse attaching to it, we use COM2.
    If COM2 is not availabe, we check COM1.  If both COM1 and COM2 are
    not present, we give up and return false.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    Initialize - Specifies a boolean value that determines whether the
        debug port is initialized or just the debug port parameters
        are captured.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    ULONG i;
    ULONG BaudRate = 115200;
    PUCHAR PortAddress = (PUCHAR)COM1_PORT;

    //
    // Check if Port and baudrate have been determined.
    //

    if (KdPortInformation.Address == NULL) {

        //
        // Initialize the port structure.
        //

        KdPortInformation.Address = PortAddress;
        KdPortInformation.Baud = BaudRate;
    }

    if (Initialize == TRUE) {
        CpInitialize(&KdPort,
                     KdPortInformation.Address,
                     KdPortInformation.Baud
                     );
    }
    return(TRUE);
}

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&KdPort, Input, TRUE);
}

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    return CpGetByte(&KdPort, Input, FALSE);
}

VOID
KdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the debug port.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    CpPutByte(&KdPort, Output);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kd64\i386\kdtrap.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdtrap.c

Abstract:

    This module contains code to implement the target side of the portable
    kernel debugger.

Author:

    Bryan M. Willman (bryanwi) 25-Sep-90

Revision History:

--*/

#include "kdp.h"

VOID
KdpContextToNt5Context(
    IN PCONTEXT Context,
    OUT PX86_NT5_CONTEXT Nt5Context
    );

VOID
KdpContextFromNt5Context(
    OUT PCONTEXT Context,
    IN PX86_NT5_CONTEXT Nt5Context
    );

BOOLEAN
KdpCheckTracePoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

BOOLEAN
KdpTrap (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    BOOLEAN Completion = FALSE;
    BOOLEAN Enable;
    BOOLEAN UnloadSymbols = FALSE;
    ULONG   RetValue;
    STRING  String, AssertString, ReplyString;
    PUCHAR  Buffer;
    PKD_SYMBOLS_INFO SymbolInfo;
    PVOID   SavedEsp;
    ULONG   OldEip;
	char	AssertBuffer[2];

    _asm {
        //
        // Save esp on ebp frame so c-runtime registers are restored correctly
        //

        mov     SavedEsp, esp
    }

    //
    // Print, Prompt, Load symbols, Unload symbols, are all special
    // cases of STATUS_BREAKPOINT
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_BREAK)) {

        //
        // We have one of the support functions.
        //

        if (KdDebuggerNotPresent  &&
            ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_PROMPT &&
            ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_RTLASSERT &&
            ExceptionRecord->ExceptionInformation[0] != BREAKPOINT_RIP) {
            ContextRecord->Eip++;
            return(TRUE);
        }


        //
        // Since some of these functions can be entered from user mode,
        // we hold off entering the debugger until the user mode buffers
        // are copied.  (Because they may not be present in memory, and
        // they must be paged in before we raise Irql to the
        // Highest level.)
        //
        //

        OldEip = ContextRecord->Eip;

        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            //  ExceptionInformation[1] is PSTRING to print
            //

            case BREAKPOINT_KDPRINT:
            case BREAKPOINT_PRINT:
                String = *((PSTRING)ExceptionRecord->ExceptionInformation[1]);

                KdLogDbgPrint(&String);

                if ((KdGlobalFlag & FLG_DISABLE_DBGPRINT) == 0) {
                    Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
                    if (KdpPrintString(&String)) {
                        ContextRecord->Eax = (ULONG)(STATUS_BREAKPOINT);
                    } else {
                        ContextRecord->Eax = STATUS_SUCCESS;
                    }
                    KdExitDebugger(Enable);
                }

                Completion = TRUE;
                break;

			//
			// ExceptionInformation[1] is the string to print as the assert
			//   message
			//

            case BREAKPOINT_RTLASSERT:
                String = *((PSTRING)ExceptionRecord->ExceptionInformation[1]);
				RtlInitAnsiString(&AssertString,
					"Break, Ignore, or Terminate Thread (bit)? ");
				ReplyString.Buffer = AssertBuffer;
				ReplyString.MaximumLength = 2;

				Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
				KdpPrintString(&String);
				do {
					RetValue = KdpPromptString(&AssertString, &ReplyString);
				} while (RetValue == TRUE);

				ContextRecord->Eax = AssertBuffer[0];
				KdExitDebugger(Enable);

                Completion = TRUE;
                break;

			//
			// ExceptionInformation[1] is the null-terminated string to
			// send
			//

			case BREAKPOINT_RIP:
				{
				char szRipText[] = "\n***RIP: ";
				char szNL[] = "\n";

				String.Buffer = szRipText;
				String.Length = sizeof szRipText - 1;
				String.MaximumLength = sizeof szRipText;
				KdpPrintString(&String);

				String.Buffer = (LPSTR)ExceptionRecord->ExceptionInformation[1];
				String.Length = (USHORT)strlen(String.Buffer);
				String.MaximumLength = String.Length + 1;
				KdpPrintString(&String);

				String.Buffer = szNL;
				String.Length = 1;
				String.MaximumLength = 2;
				KdpPrintString(&String);

				// now we stop as if at a breakpoint
	            Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
				goto RipBreak;
				}

            //
            //  ExceptionInformation[1] is prompt string,
            //  ExceptionInformation[2] is return string
            //

            case BREAKPOINT_PROMPT:
                String = *((PSTRING)ExceptionRecord->ExceptionInformation[1]);
                ReplyString = *((PSTRING)ExceptionRecord->ExceptionInformation[2]);

                //
                // Prompt, keep prompting until no breakin seen.
                //

                KdLogDbgPrint(&String);

                Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);
                do {
                    RetValue = KdpPromptString(&String, &ReplyString);
                } while (RetValue == TRUE);

                ContextRecord->Eax = ReplyString.Length;
                KdExitDebugger(Enable);

                Completion = TRUE;
                break;

            //
            //  ExceptionInformation[1] is file name of new module
            //  ExceptionInformaiton[2] is the base of the dll
            //

            case BREAKPOINT_UNLOAD_SYMBOLS:
                UnloadSymbols = TRUE;

                //
                // Fall through
                //

            case BREAKPOINT_LOAD_SYMBOLS:

                Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

                //
                // Save and restore the processor context in case the
                // kernel debugger has been configured to stop on dll
                // loads.
                //

                KdpSaveProcessorControlState(&KdProcessorState);
                KdpContextToNt5Context(ContextRecord, &KdProcessorState.ContextFrame);

                SymbolInfo = (PKD_SYMBOLS_INFO)ExceptionRecord->ExceptionInformation[2];
                Completion =
                    KdpReportLoadSymbolsStateChange((PSTRING)ExceptionRecord->ExceptionInformation[1],
                                                    SymbolInfo,
                                                    UnloadSymbols,
                                                    &KdProcessorState.ContextFrame);

                KdpContextFromNt5Context(ContextRecord, &KdProcessorState.ContextFrame);
                KdpRestoreProcessorControlState(&KdProcessorState);

                KdExitDebugger(Enable);
                break;

            case BREAKPOINT_LOAD_XESECTION:
            case BREAKPOINT_UNLOAD_XESECTION:
            case BREAKPOINT_CREATE_FIBER:
            case BREAKPOINT_DELETE_FIBER:
                // we don't actually pay attention to these
                Completion = TRUE;
                break;

            //
            //  Unknown command
            //

            default:
                // return FALSE
                break;
        }
        //
        // If the kernel debugger did not update the EIP, then increment
        // past the breakpoint instruction.
        //

        if (ContextRecord->Eip == OldEip) {
            ContextRecord->Eip++;
        }


    } else {

        if  ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) ||
             (ExceptionRecord->ExceptionCode == STATUS_SINGLE_STEP)  ||
             (KdGlobalFlag & FLG_STOP_ON_EXCEPTION) ||
             SecondChance) {

            if (!SecondChance &&
                (ExceptionRecord->ExceptionCode == STATUS_PORT_DISCONNECTED ||
                 NT_SUCCESS( ExceptionRecord->ExceptionCode )
                )
               ) {
                //
                // User does not really want to see these either.
                // so do NOT report it to debugger.
                //

                return FALSE;
                }

            //
            // Report state change to kernel debugger on host
            //

            Enable = KdEnterDebugger(TrapFrame, ExceptionFrame);

            Completion = KdpCheckTracePoint(ExceptionRecord,ContextRecord);
            if (!Completion) {

RipBreak:
                KdpSaveProcessorControlState(&KdProcessorState);
                KdpContextToNt5Context(ContextRecord, &KdProcessorState.ContextFrame);

                Completion =
                    KdpReportExceptionStateChange(ExceptionRecord,
                                                  &KdProcessorState.ContextFrame,
                                                  SecondChance);

                KdpContextFromNt5Context(ContextRecord, &KdProcessorState.ContextFrame);
                KdpRestoreProcessorControlState(&KdProcessorState);
            }

            KdExitDebugger(Enable);

            KdpControlCPressed = FALSE;

        } else {

            //
            // This is real exception that user doesn't want to see,
            // so do NOT report it to debugger.
            //

            // return FALSE;
        }
    }

    _asm {
        mov     esp, SavedEsp
    }
    return Completion;
}

BOOLEAN
KdpStub (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine to catch debug
    prints in a checked system when the kernel debugger is not active.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{
    PULONG  SymbolArgs;
    //
    // If the breakpoint is a debug print, then return TRUE. Otherwise,
    // return FALSE.
    //

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_KDPRINT)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {

        ContextRecord->Eip++;
        return(TRUE);
    } else if (KdDebuggerEnabled == FALSE) {
        return(FALSE);
    } else {
        return(KdpCheckTracePoint(ExceptionRecord,ContextRecord));
    }
}

#define NUMBER_OF_FP_REGISTERS  8
#define BYTES_PER_FP_REGISTER   10
#define BYTES_PER_FX_REGISTER   16

VOID
KdpContextToNt5Context(
    IN PCONTEXT Context,
    OUT PX86_NT5_CONTEXT Nt5Context
    )
{
    ULONG i;

    Nt5Context->ContextFlags = Context->ContextFlags;

    //
    // CONTEXT_CONTROL
    //

    Nt5Context->Ebp = Context->Ebp;
    Nt5Context->Eip = Context->Eip;
    Nt5Context->SegCs = Context->SegCs;
    Nt5Context->EFlags = Context->EFlags;
    Nt5Context->Esp = Context->Esp;
    Nt5Context->SegSs = Context->SegSs;

    //
    // CONTEXT_SEGMENTS
    //

    Nt5Context->SegGs = 0;
    Nt5Context->SegFs = KGDT_R0_PCR;
    Nt5Context->SegEs = KGDT_R0_DATA;
    Nt5Context->SegDs = KGDT_R0_DATA;

    //
    // CONTEXT_INTEGER
    //

    Nt5Context->Edi = Context->Edi;
    Nt5Context->Esi = Context->Esi;
    Nt5Context->Ebx = Context->Ebx;
    Nt5Context->Edx = Context->Edx;
    Nt5Context->Ecx = Context->Ecx;
    Nt5Context->Eax = Context->Eax;

    //
    // CONTEXT_EXTENDED_REGISTERS
    //

    RtlCopyMemory(Nt5Context->ExtendedRegisters, &Context->FloatSave,
        MAXIMUM_SUPPORTED_EXTENSION);

    //
    // CONTEXT_FLOATING_POINT
    //

    Nt5Context->FloatSave.ControlWord = (USHORT)Context->FloatSave.ControlWord;
    Nt5Context->FloatSave.StatusWord = (USHORT)Context->FloatSave.StatusWord;
    Nt5Context->FloatSave.TagWord = (USHORT)Context->FloatSave.TagWord;
    Nt5Context->FloatSave.ErrorOffset = Context->FloatSave.ErrorOffset;
    Nt5Context->FloatSave.ErrorSelector = Context->FloatSave.ErrorSelector;
    Nt5Context->FloatSave.DataOffset = Context->FloatSave.DataOffset;
    Nt5Context->FloatSave.DataSelector = Context->FloatSave.DataSelector;
    Nt5Context->FloatSave.Cr0NpxState = Context->FloatSave.Cr0NpxState;

    for (i = 0; i < NUMBER_OF_FP_REGISTERS; i++) {
        RtlCopyMemory(&Nt5Context->FloatSave.RegisterArea[i*BYTES_PER_FP_REGISTER],
            &Context->FloatSave.RegisterArea[i*BYTES_PER_FX_REGISTER],
            BYTES_PER_FP_REGISTER);
    }
}

VOID
KdpContextFromNt5Context(
    OUT PCONTEXT Context,
    IN PX86_NT5_CONTEXT Nt5Context
    )
{
    ULONG i;

    Context->ContextFlags = Nt5Context->ContextFlags;

    //
    // CONTEXT_CONTROL
    //

    Context->Ebp = Nt5Context->Ebp;
    Context->Eip = Nt5Context->Eip;
    Context->SegCs = Nt5Context->SegCs;
    Context->EFlags = Nt5Context->EFlags;
    Context->Esp = Nt5Context->Esp;
    Context->SegSs = Nt5Context->SegSs;

    //
    // CONTEXT_INTEGER
    //

    Context->Edi = Nt5Context->Edi;
    Context->Esi = Nt5Context->Esi;
    Context->Ebx = Nt5Context->Ebx;
    Context->Edx = Nt5Context->Edx;
    Context->Ecx = Nt5Context->Ecx;
    Context->Eax = Nt5Context->Eax;

    //
    // CONTEXT_EXTENDED_REGISTERS
    //

    RtlCopyMemory(&Context->FloatSave, Nt5Context->ExtendedRegisters,
        MAXIMUM_SUPPORTED_EXTENSION);

    //
    // CONTEXT_FLOATING_POINT
    //

    Context->FloatSave.ControlWord = (USHORT)Nt5Context->FloatSave.ControlWord;
    Context->FloatSave.StatusWord = (USHORT)Nt5Context->FloatSave.StatusWord;
    Context->FloatSave.TagWord = (USHORT)Nt5Context->FloatSave.TagWord;
    Context->FloatSave.ErrorOffset = Nt5Context->FloatSave.ErrorOffset;
    Context->FloatSave.ErrorSelector = Nt5Context->FloatSave.ErrorSelector;
    Context->FloatSave.DataOffset = Nt5Context->FloatSave.DataOffset;
    Context->FloatSave.DataSelector = Nt5Context->FloatSave.DataSelector;
    Context->FloatSave.Cr0NpxState = Nt5Context->FloatSave.Cr0NpxState;

    for (i = 0; i < NUMBER_OF_FP_REGISTERS; i++) {
        RtlCopyMemory(&Context->FloatSave.RegisterArea[i*BYTES_PER_FX_REGISTER],
            &Nt5Context->FloatSave.RegisterArea[i*BYTES_PER_FP_REGISTER],
            BYTES_PER_FP_REGISTER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\kdlite\kdlite.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    kdlite.c

Abstract:

    This module implements the Xbox lite kernel debugger.

--*/

#include "kdlitep.h"

//
// Stores whether or not the debugger is enabled.  The debugger is only enabled
// if a super I/O controller is present.
//
DECLSPEC_STICKY BOOLEAN KdDebuggerEnabled;

//
// Hardwired to TRUE, since a real debugger is never really present.
//
BOOLEAN KdDebuggerNotPresent = TRUE;

//
// Local support.
//

VOID
KdpConfigureSerialPort(
    VOID
    );

VOID
KdpInitializeLoadedModuleList(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, KdpConfigureSerialPort)
#endif

VOID
KdpConfigureSerialPort(
    VOID
    )
/*++

Routine Description:

    This routine configures the serial port for the desired baud rate and port
    options.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG DivisorLatch;

    DivisorLatch = CLOCK_RATE / KDLITE_DEBUG_BAUD_RATE;

    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_LCR, 0x83);
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_DLM, (UCHAR)(DivisorLatch >> 8));
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_DLL, (UCHAR)(DivisorLatch));
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_LCR, 0x03);

    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_MCR, MC_DTRRTS);
    _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_IEN, 0);
}

VOID
KdpPrintString(
    IN PSTRING String
    )
/*++

Routine Description:

    This routine prints out the supplied string to the serial port.

Arguments:

    String - Specifies the string to be printed to the serial port.

Return Value:

    None.

--*/
{
    BOOLEAN Restore;
    ULONG Length;
    PUCHAR Buffer;

    //
    // If the debugger isn't enabled, don't do anything.
    //

    if (!KdDebuggerEnabled) {
        return;
    }

    //
    // Write out each character to the serial port.  Synchronize by disabling
    // interrupts.
    //

    Restore = KiDisableInterrupts();

    Length = String->Length;
    Buffer = String->Buffer;

    while (Length > 0) {

        while (!(_inp(KDLITE_DEBUG_BASE_ADDRESS + COM_LSR) & COM_OUTRDY));
        _outp(KDLITE_DEBUG_BASE_ADDRESS + COM_DAT, *Buffer);

        Length--;
        Buffer++;
    }

    KiRestoreInterrupts(Restore);
}

BOOLEAN
KdpTrap(
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN SecondChance
    )
/*++

Routine Description:

    This routine is called whenever a exception is dispatched.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that describes the
        trap.

    ExceptionFrame - Supplies a pointer to a exception frame that describes
        the trap.

    ExceptionRecord - Supplies a pointer to an exception record that
        describes the exception.

    ContextRecord - Supplies the context at the time of the exception.

    SecondChance - Supplies a boolean value that determines whether this is
        the second chance (TRUE) that the exception has been raised.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/
{
    BOOLEAN Handled = FALSE;

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->NumberParameters > 0) &&
        ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_SYMBOLS)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_LOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_UNLOAD_XESECTION)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_KDPRINT)||
         (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT))) {

        if ((ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_KDPRINT)||
            (ExceptionRecord->ExceptionInformation[0] == BREAKPOINT_PRINT)) {
            KdpPrintString((PSTRING)ExceptionRecord->ExceptionInformation[1]);
            ContextRecord->Eax = STATUS_SUCCESS;
        }

        ContextRecord->Eip++;
        Handled = TRUE;
    }

    return Handled;
}

VOID
KdInitSystem(
    BOOLEAN InitializingSystem
    )
/*++

Routine Description:

    This routine initializes the lite kernel debugger.

Arguments:

    InitializingSystem - Supplies a boolean value that determines whether we're
        called in the context of system initialization or bugcheck code.

Return Value:

    None.

--*/
{
    if (InitializingSystem) {

        //
        // If the kernel is cold-booting, then determine whether or not a super
        // I/O controller is attached to the system so that we know whether or
        // not to output debug spew through the serial port.
        //

        if (!KeHasQuickBooted) {

            HalPulseHardwareMonitorPin();
            KdDebuggerEnabled = HalInitializeSuperIo();

            if (KdDebuggerEnabled) {
                KdpConfigureSerialPort();
            }
        }

        //
        // Set the debug routine to point at our trap handler.
        //

        KiDebugRoutine = KdpTrap;

#ifdef DEVKIT
        //
        // For DEVKIT builds of this library, we still need to initialize the
        // module list so that the debug monitor will continue to function.
        //

        KdpInitializeLoadedModuleList();
#endif
    }
}

#ifdef DEVKIT

//
// The following code and data are present for DEVKIT builds to enable testing
// of the lite kernel debugger on a DEVKIT platform.  None of this code is used
// by a retail build of the system.
//

//
// Set to TRUE if the are any breakpoints that need to be applied to pages that
// are not inpaged.  Always FALSE since this implementation never applies
// breakpoints.
//
BOOLEAN KdpOweBreakpoint;

//
// Static loader data table entry for XBOXKRNL.EXE.
//
LDR_DATA_TABLE_ENTRY KdpNtosDataTableEntry;

//
// List of modules that have been loaded.
//
INITIALIZED_LIST_ENTRY(KdLoadedModuleList);

VOID
KdpInitializeLoadedModuleList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the static loader data table entry for the kernel
    and attaches it to the loaded module list.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Initialize the loader data table entry for XBOXKRNL.EXE and attach it
    // to the loaded module list.
    //

    KdpNtosDataTableEntry.DllBase = PsNtosImageBase;
    KdpNtosDataTableEntry.SizeOfImage =
        RtlImageNtHeader(PsNtosImageBase)->OptionalHeader.SizeOfImage;
    KdpNtosDataTableEntry.LoadedImports = (PVOID)MAXULONG_PTR;
    RtlInitUnicodeString(&KdpNtosDataTableEntry.FullDllName, L"xboxkrnl.exe");
    RtlInitUnicodeString(&KdpNtosDataTableEntry.BaseDllName, L"xboxkrnl.exe");

    InsertTailList(&KdLoadedModuleList, &KdpNtosDataTableEntry.InLoadOrderLinks);
}

BOOLEAN
KdPollBreakIn(
    VOID
    )
/*++

Routine Description:

    This routine checks if a breakin packet is pending.

Arguments:

    None.

Return Value:

    Returns FALSE to indicate that no breakin packet is pending.

--*/
{
    return FALSE;
}

VOID
KdSetOwedBreakpoints(
    VOID
    )
/*++

Routine Description:

    This routine is called by the page fault handler to store pending
    breakpoints for pages that may have been just made valid.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // This routine should never be called because this implementation never
    // applies breakpoints and never sets KdpOweBreakpoint to TRUE.
    //

    KeBugCheck(0);
}

VOID
KdDeleteAllBreakpoints(
    VOID
    )
/*++

Routine Description:

    This routine is called to delete all breakpoints from the system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\apcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    apcsup.c

Abstract:

    This module contains the support routines for the APC object. Functions
    are provided to insert in an APC queue and to deliver user and kernel
    mode APC's.

Author:

    David N. Cutler (davec) 14-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiDeliverApc (
    VOID
    )

/*++

Routine Description:

    This function is called from the APC interrupt code and when one or
    more of the APC pending flags are set at system exit and the previous
    IRQL is zero. All special kernel APC's are delivered first, followed
    by normal kernel APC's if one is not already in progress. On entry
    to this routine IRQL is set to APC_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKAPC Apc;
    PKKERNEL_ROUTINE KernelRoutine;
    PLIST_ENTRY NextEntry;
    PVOID NormalContext;
    PKNORMAL_ROUTINE NormalRoutine;
    KIRQL OldIrql;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;

    //
    // Raise IRQL to dispatcher level and lock the APC queue.
    //

    Thread = KeGetCurrentThread();
    KiLockApcQueue(Thread, &OldIrql);

    //
    // Get address of current thread object, clear kernel APC pending, and
    // check if any kernel mode APC's can be delivered.
    //

    Thread->ApcState.KernelApcPending = FALSE;
    while (IsListEmpty(&Thread->ApcState.ApcListHead[KernelMode]) == FALSE) {
        NextEntry = Thread->ApcState.ApcListHead[KernelMode].Flink;
        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
        KernelRoutine = Apc->KernelRoutine;
        NormalRoutine = Apc->NormalRoutine;
        NormalContext = Apc->NormalContext;
        SystemArgument1 = Apc->SystemArgument1;
        SystemArgument2 = Apc->SystemArgument2;
        if (NormalRoutine == (PKNORMAL_ROUTINE)NULL) {

            //
            // First entry in the kernel APC queue is a special kernel APC.
            // Remove the entry from the APC queue, set its inserted state
            // to FALSE, release dispatcher database lock, and call the kernel
            // routine. On return raise IRQL to dispatcher level and lock
            // dispatcher database lock.
            //

            RemoveEntryList(NextEntry);
            Apc->Inserted = FALSE;
            KiUnlockApcQueue(Thread, OldIrql);
            (KernelRoutine)(Apc, &NormalRoutine, &NormalContext,
                            &SystemArgument1, &SystemArgument2);

#if DBG

                if (KeGetCurrentIrql() != OldIrql) {
                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                 KeGetCurrentIrql() << 16 | OldIrql << 8,
                                 (ULONG_PTR)KernelRoutine,
                                 (ULONG_PTR)Apc,
                                 (ULONG_PTR)NormalRoutine);
                }

#endif

            KiLockApcQueue(Thread, &OldIrql);

        } else {

            //
            // First entry in the kernel APC queue is a normal kernel APC.
            // If there is not a normal kernel APC in progress and kernel
            // APC's are not disabled, then remove the entry from the APC
            // queue, set its inserted state to FALSE, release the APC queue
            // lock, call the specified kernel routine, set kernel APC in
            // progress, lower the IRQL to zero, and call the normal kernel
            // APC routine. On return raise IRQL to dispatcher level, lock
            // the APC queue, and clear kernel APC in progress.
            //

            if ((Thread->ApcState.KernelApcInProgress == FALSE) &&
               (Thread->KernelApcDisable == 0)) {
                RemoveEntryList(NextEntry);
                Apc->Inserted = FALSE;
                KiUnlockApcQueue(Thread, OldIrql);
                (KernelRoutine)(Apc, &NormalRoutine, &NormalContext,
                                &SystemArgument1, &SystemArgument2);

#if DBG

                if (KeGetCurrentIrql() != OldIrql) {
                    KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                                 KeGetCurrentIrql() << 16 | OldIrql << 8 | 1,
                                 (ULONG_PTR)KernelRoutine,
                                 (ULONG_PTR)Apc,
                                 (ULONG_PTR)NormalRoutine);
                }

#endif

                if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) {
                    Thread->ApcState.KernelApcInProgress = TRUE;
                    KeLowerIrql(0);
                    (NormalRoutine)(NormalContext, SystemArgument1,
                                    SystemArgument2);
                    KeRaiseIrql(APC_LEVEL, &OldIrql);
                }

                KiLockApcQueue(Thread, &OldIrql);
                Thread->ApcState.KernelApcInProgress = FALSE;

            } else {
                KiUnlockApcQueue(Thread, OldIrql);
                return;
            }
        }
    }

    KiUnlockApcQueue(Thread, OldIrql);
    return;
}

VOID
KiDeliverUserApc (
    VOID
    )

/*++

Routine Description:

    This function is called from wait routines after a user APC has been
    detected. All user mode APC's are delivered. On entry to this routine
    IRQL is set to PASSIVE_LEVEL.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKAPC Apc;
    PKKERNEL_ROUTINE KernelRoutine;
    PLIST_ENTRY NextEntry;
    PVOID NormalContext;
    PKNORMAL_ROUTINE NormalRoutine;
    KIRQL OldIrql;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PKTHREAD Thread;

    //
    // Raise IRQL to dispatcher level and lock the APC queue.
    //

    Thread = KeGetCurrentThread();
    KiLockApcQueue(Thread, &OldIrql);

    Thread->ApcState.UserApcPending = FALSE;
    while (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) == FALSE) {
        NextEntry = Thread->ApcState.ApcListHead[UserMode].Flink;
        Apc = CONTAINING_RECORD(NextEntry, KAPC, ApcListEntry);
        KernelRoutine = Apc->KernelRoutine;
        NormalRoutine = Apc->NormalRoutine;
        NormalContext = Apc->NormalContext;
        SystemArgument1 = Apc->SystemArgument1;
        SystemArgument2 = Apc->SystemArgument2;
        RemoveEntryList(NextEntry);
        Apc->Inserted = FALSE;
        KiUnlockApcQueue(Thread, OldIrql);
        (KernelRoutine)(Apc, &NormalRoutine, &NormalContext,
                        &SystemArgument1, &SystemArgument2);

#if DBG
        if (KeGetCurrentIrql() != OldIrql) {
            KeBugCheckEx(IRQL_UNEXPECTED_VALUE,
                         KeGetCurrentIrql() << 16 | OldIrql << 8 | 1,
                         (ULONG_PTR)KernelRoutine,
                         (ULONG_PTR)Apc,
                         (ULONG_PTR)NormalRoutine);
        }

        ASSERT(OldIrql == PASSIVE_LEVEL);
#endif
        if (NormalRoutine != (PKNORMAL_ROUTINE)NULL) {
            (NormalRoutine)(NormalContext, SystemArgument1, SystemArgument2);
        }

        KiLockApcQueue(Thread, &OldIrql);
    }

    KiUnlockApcQueue(Thread, OldIrql);
    return;
}

BOOLEAN
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function inserts an APC object into a thread's APC queue. The address
    of the thread object, the APC queue, and the type of APC are all derived
    from the APC object. If the APC object is already in an APC queue, then
    no opertion is performed and a function value of FALSE is returned. Else
    the APC is inserted in the specified APC queue, its inserted state is set
    to TRUE, and a function value of TRUE is returned. The APC will actually
    be delivered when proper enabling conditions exist.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    Increment - Supplies the priority increment that is to be applied if
        queuing the APC causes a thread wait to be satisfied.

Return Value:

    If the APC object is already in an APC queue, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    KPROCESSOR_MODE ApcMode;
    PKAPC ApcEntry;
    PKAPC_STATE ApcState;
    BOOLEAN Inserted;
    PLIST_ENTRY ListEntry;
    PKTHREAD Thread;

    //
    // If the APC object is already in an APC queue, then set inserted to
    // FALSE. Else insert the APC object in the proper queue, set the APC
    // inserted state to TRUE, check to determine if the APC should be delivered
    // immediately, and set inserted to TRUE.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that kernel APC disable count is incremented before checking whether
    // the kernel APC queue is nonempty.
    //
    // See KeLeaveCriticalRegion().
    //

    Thread = Apc->Thread;
    KiLockApcQueueAtDpcLevel(Thread);
    if (Apc->Inserted) {
        Inserted = FALSE;

    } else {
        ApcState = &Thread->ApcState;

        //
        // Insert the APC after all other special APC entries selected by
        // the processor mode if the normal routine value is null. Else
        // insert the APC object at the tail of the APC queue selected by
        // the processor mode.
        //

        ApcMode = Apc->ApcMode;
        if (Apc->NormalRoutine != NULL) {
            InsertTailList(&ApcState->ApcListHead[ApcMode],
                           &Apc->ApcListEntry);

        } else {
            ListEntry = ApcState->ApcListHead[ApcMode].Flink;
            while (ListEntry != &ApcState->ApcListHead[ApcMode]) {
                ApcEntry = CONTAINING_RECORD(ListEntry, KAPC, ApcListEntry);
                if (ApcEntry->NormalRoutine != NULL) {
                    break;
                }

                ListEntry = ListEntry->Flink;
            }

            ListEntry = ListEntry->Blink;
            InsertHeadList(ListEntry, &Apc->ApcListEntry);
        }

        Apc->Inserted = TRUE;

        //
        // If the processor mode of the APC is kernel, then check if
        // the APC should either interrupt the thread or sequence the
        // thread out of a Waiting state. Else check if the APC should
        // sequence the thread out of an alertable Waiting state.
        //

        if (ApcMode == KernelMode) {
            Thread->ApcState.KernelApcPending = TRUE;
            if (Thread->State == Running) {
                KiRequestApcInterrupt();

            } else if ((Thread->State == Waiting) &&
                      (Thread->WaitIrql == 0) &&
                      ((Apc->NormalRoutine == NULL) ||
                      ((Thread->KernelApcDisable == 0) &&
                      (Thread->ApcState.KernelApcInProgress == FALSE)))) {
                KiUnwaitThread(Thread, STATUS_KERNEL_APC, Increment);
            }

        } else if ((Thread->State == Waiting) &&
                  (Thread->WaitMode == UserMode) &&
                  (Thread->Alertable)) {
            Thread->ApcState.UserApcPending = TRUE;
            KiUnwaitThread(Thread, STATUS_USER_APC, Increment);
        }

        Inserted = TRUE;
    }

    //
    // Unlock the APC queue lock, and return whether the APC object was
    // inserted in an APC queue.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    return Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\bugcheck.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    bugcheck.c

Abstract:

    This module implements bug check and system shutdown code.

Author:

    Mark Lucovsky (markl) 30-Aug-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "dm.h"

//
// Define bug count recursion counter and a context buffer.
//

#ifdef DEVKIT
ULONG KeBugCheckCount = 1;
#endif

ULONG_PTR KiBugCheckData[5];

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/
{
    KeBugCheckEx(BugCheckCode,0,0,0,0);
}

VOID
KiBugCheckDebugBreak (
    IN ULONG    BreakStatus
    )
{
    do {
        try {

            //
            // Issue a breakpoint
            //

            DbgBreakPointWithStatus (BreakStatus);

        } except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // Failure to issue breakpoint, halt the system
            //

            try {

                HalHaltSystem();

            } except(EXCEPTION_EXECUTE_HANDLER) {

                for (;;) {
                }
            }

            for (;;) {
            }
        }
    } while (BreakStatus != DBG_STATUS_BUGCHECK_FIRST);
}

VOID
KeBugCheckEx (
    IN ULONG BugCheckCode,
    IN ULONG_PTR BugCheckParameter1,
    IN ULONG_PTR BugCheckParameter2,
    IN ULONG_PTR BugCheckParameter3,
    IN ULONG_PTR BugCheckParameter4
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

    BugCheckParameter1-4 - Supplies additional bug check information

Return Value:

    None.

--*/

{
    KIRQL OldIrql;

#if defined(i386)
    KiSetHardwareTrigger();
#else
    KiHardwareTrigger = 1;
#endif

    KiBugCheckData[0] = BugCheckCode;
    KiBugCheckData[1] = BugCheckParameter1;
    KiBugCheckData[2] = BugCheckParameter2;
    KiBugCheckData[3] = BugCheckParameter3;
    KiBugCheckData[4] = BugCheckParameter4;

#ifdef DEVKIT
    //
    // Once we bugcheck, the debug monitor isn't going to have much luck with
    // anything, so we'll tell it to disable itself.
    //

    if (DmGetCurrentDmi() != NULL) {
        DmGetCurrentDmi()->Flags |= DMIFLAG_BUGCHECK;
    }
#endif

    //
    // If the user manually crashed the machine, skips the DbgPrints and
    // go to the crashdump.
    // Trying to do DbgPrint causes us to reeeter the debugger which causes
    // some problems.
    //
    // Otherwise, if the debugger is enabled, print out the information and
    // stop.
    //

    if ((BugCheckCode != MANUALLY_INITIATED_CRASH) &&
        (KdDebuggerEnabled)) {

        DbgPrint("\n*** Fatal System Error: 0x%08lx\n"
                 "                       (0x%p,0x%p,0x%p,0x%p)\n\n",
                 BugCheckCode,
                 BugCheckParameter1,
                 BugCheckParameter2,
                 BugCheckParameter3,
                 BugCheckParameter4);

        //
        // If the debugger is not actually connected, or the user manually
        // crashed the machine by typing .crash in the debugger, proceed to
        // "blue screen" the system.
        //
        // The call to DbgPrint above will have set the state of
        // KdDebuggerNotPresent if the debugger has become disconnected
        // since the system was booted.
        //

        if (KdDebuggerNotPresent == FALSE) {
            KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_FIRST);
        }
    }

#ifdef DEVKIT
    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KiDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    if (InterlockedDecrement (&KeBugCheckCount) == 0) {
        if (KdDebuggerEnabled == FALSE) {
            KdInitSystem(FALSE);
        }
    }

    //
    // Attempt to enter the kernel debugger.
    //

    KiBugCheckDebugBreak (DBG_STATUS_BUGCHECK_SECOND);
#else
    //
    // Halt the system.  If a real debugger is not attached, then we cannot
    // safely use KiBugCheckDebugBreak.  That routine will generate a breakpoint
    // exception inside an exception handler.  RtlDispatchException will check
    // if the exception handler is within the bounds of the current thread's
    // stack.  If we entered this routine as a result of a fault from a stack
    // overflow exception, or a non-maskable interrupt, then we'll be executing
    // on a different stack.  RtlDispatchException will not be able to dispatch
    // the exception and will raise another bug check.
    //

    HalHaltSystem();
#endif
}

#ifdef DEVKIT

VOID
KeEnterKernelDebugger (
    VOID
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner attempting
    to invoke the kernel debugger.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(i386)
    KIRQL OldIrql;
#endif

    //
    // Freeze execution of the system by disabling interrupts and looping.
    //

    KiHardwareTrigger = 1;
    KiDisableInterrupts();
#if !defined(i386)
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
#endif
    if (InterlockedDecrement (&KeBugCheckCount) == 0) {
        if (KdDebuggerEnabled == FALSE) {
            KdInitSystem(FALSE);
        }
    }

    KiBugCheckDebugBreak (DBG_STATUS_FATAL);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\devquobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    devquobj.c

Abstract:

    This module implements the kernel device queue object. Functions are
    provided to initialize a device queue object and to insert and remove
    device queue entries in a device queue object.

Author:

    David N. Cutler (davec) 1-Apr-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input device queue
// is really a kdevice_queue and not something else, like deallocated pool.
//

#define ASSERT_DEVICE_QUEUE(E) {            \
    ASSERT((E)->Type == DeviceQueueObject); \
}

//
// Define macros to lock and unlock the device queue.
//

#define KiAcquireDeviceQueueLock(QUEUE, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToDpcLevel()

#define KiReleaseDeviceQueueLock(QUEUE, OldIrql) \
    KeLowerIrql(OldIrql)

#define KiAcquireDeviceQueueLockAtDpcLevel(QUEUE) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define KiReleaseDeviceQueueLockFromDpcLevel(QUEUE) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)


VOID
KeInitializeDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function initializes a kernel device queue object.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device
        queue.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    DeviceQueue->Type = DeviceQueueObject;
    DeviceQueue->Size = sizeof(KDEVICE_QUEUE);

    //
    // Initialize the device queue list head, spin lock, and busy indicator.
    //

    InitializeListHead(&DeviceQueue->DeviceListHead);
    DeviceQueue->Busy = FALSE;
    return;
}

BOOLEAN
KeInsertDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function inserts a device queue entry at the tail of the specified
    device queue. If the device is not busy, then it is set busy and the entry
    is not placed in the device queue. Otherwise the specified entry is placed
    at the end of the device queue.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    //
    // Insert the specified device queue entry at the end of the device queue
    // if the device queue is busy. Otherwise set the device queue busy and
    // don't insert the device queue entry.
    //

    if (DeviceQueue->Busy == TRUE) {
        Inserted = TRUE;
        InsertTailList(&DeviceQueue->DeviceListHead,
                       &DeviceQueueEntry->DeviceListEntry);
    } else {
        DeviceQueue->Busy = TRUE;
        Inserted = FALSE;
    }
    DeviceQueueEntry->Inserted = Inserted;
    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return Inserted;
}

BOOLEAN
KeInsertByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function inserts a device queue entry into the specified device
    queue according to a sort key. If the device is not busy, then it is
    set busy and the entry is not placed in the device queue. Otherwise
    the specified entry is placed in the device queue at a position such
    that the specified sort key is greater than or equal to its predecessor
    and less than its successor.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry.

    SortKey - Supplies the sort key by which the position to insert the device
        queue entry is to be determined.

Return Value:

    If the device is not busy, then a value of FALSE is returned. Otherwise a
    value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    PLIST_ENTRY NextEntry;
    PKDEVICE_QUEUE_ENTRY QueueEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    //
    // Insert the specified device queue entry in the device queue at the
    // position specified by the sort key if the device queue is busy.
    // Otherwise set the device queue busy an don't insert the device queue
    // entry.
    //

    DeviceQueueEntry->SortKey = SortKey;
    if (DeviceQueue->Busy == TRUE) {
        Inserted = TRUE;
        NextEntry = DeviceQueue->DeviceListHead.Flink;
        while (NextEntry != &DeviceQueue->DeviceListHead) {
            QueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                           DeviceListEntry);
            if (SortKey < QueueEntry->SortKey) {
                break;
            }
            NextEntry = NextEntry->Flink;
        }
        NextEntry = NextEntry->Blink;
        InsertHeadList(NextEntry, &DeviceQueueEntry->DeviceListEntry);
    } else {
        DeviceQueue->Busy = TRUE;
        Inserted = FALSE;
    }
    DeviceQueueEntry->Inserted = Inserted;
    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return Inserted;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    )

/*++

Routine Description:

    This function removes an entry from the head of the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the next entry is removed
    from the head of the device queue and the address of device queue entry
    is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    ASSERT(DeviceQueue->Busy == TRUE);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;
        DeviceQueueEntry = (PKDEVICE_QUEUE_ENTRY)NULL;
    } else {
        NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
        DeviceQueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);
        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Release device queue spin lock and return address of device queue
    // entry.
    //

    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return DeviceQueueEntry;
}

PKDEVICE_QUEUE_ENTRY
KeRemoveByKeyDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN ULONG SortKey
    )

/*++

Routine Description:

    This function removes an entry from the specified device
    queue. If the device queue is empty, then the device is set Not-Busy
    and a NULL pointer is returned. Otherwise the an entry is removed
    from the device queue and the address of device queue entry
    is returned.  The queue is search for the first entry which has a value
    greater than or equal to the SortKey.  If no such entry is found then the
    first entry of the queue is returned.

    N.B. This function can only be called from DISPATCH_LEVEL.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    SortKey - Supplies the sort key by which the position to remove the device
        queue entry is to be determined.

Return Value:

    A NULL pointer is returned if the device queue is empty. Otherwise a
    pointer to a device queue entry is returned.

--*/

{

    PKDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    PLIST_ENTRY NextEntry;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Lock specified device queue.
    //

    KiAcquireDeviceQueueLockAtDpcLevel(DeviceQueue);

    ASSERT(DeviceQueue->Busy == TRUE);

    //
    // If the device queue is not empty, then remove the first entry from
    // the queue. Otherwise set the device queue not busy.
    //

    if (IsListEmpty(&DeviceQueue->DeviceListHead) == TRUE) {
        DeviceQueue->Busy = FALSE;
        DeviceQueueEntry = (PKDEVICE_QUEUE_ENTRY)NULL;
    } else {
        NextEntry = DeviceQueue->DeviceListHead.Flink;
        while (NextEntry != &DeviceQueue->DeviceListHead) {
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                           DeviceListEntry);
            if (SortKey <= DeviceQueueEntry->SortKey) {
                break;
            }
            NextEntry = NextEntry->Flink;
        }

        if (NextEntry != &DeviceQueue->DeviceListHead) {
            RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);

        } else {
            NextEntry = RemoveHeadList(&DeviceQueue->DeviceListHead);
            DeviceQueueEntry = CONTAINING_RECORD(NextEntry, KDEVICE_QUEUE_ENTRY,
                                             DeviceListEntry);
        }

        DeviceQueueEntry->Inserted = FALSE;
    }

    //
    // Release device queue spin lock and return address of device queue
    // entry.
    //

    KiReleaseDeviceQueueLockFromDpcLevel(DeviceQueue);
    return DeviceQueueEntry;
}

BOOLEAN
KeRemoveEntryDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN PKDEVICE_QUEUE_ENTRY DeviceQueueEntry
    )

/*++

Routine Description:

    This function removes a specified entry from the the specified device
    queue. If the device queue entry is not in the device queue, then no
    operation is performed. Otherwise the specified device queue entry is
    removed from the device queue and its inserted status is set to FALSE.

Arguments:

    DeviceQueue - Supplies a pointer to a control object of type device queue.

    DeviceQueueEntry - Supplies a pointer to a device queue entry which is to
        be removed from its device queue.

Return Value:

    A value of TRUE is returned if the device queue entry is removed from its
    device queue. Otherwise a value of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Removed;

    ASSERT_DEVICE_QUEUE(DeviceQueue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock specified device queue.
    //

    KiAcquireDeviceQueueLock(DeviceQueue, &OldIrql);

    //
    // If the device queue entry is not in a device queue, then no operation
    // is performed. Otherwise remove the specified device queue entry from its
    // device queue.
    //

    Removed = DeviceQueueEntry->Inserted;
    if (Removed == TRUE) {
        DeviceQueueEntry->Inserted = FALSE;
        RemoveEntryList(&DeviceQueueEntry->DeviceListEntry);
    }

    //
    // Unlock specified device queue, lower IRQL to its previous level, and
    // return whether the device queue entry was removed from its queue.
    //

    KiReleaseDeviceQueueLock(DeviceQueue, OldIrql);
    return Removed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\dpcobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpcobj.c

Abstract:

    This module implements the kernel DPC object. Functions are provided
    to initialize, insert, and remove DPC objects.

Author:

    David N. Cutler (davec) 6-Mar-1989

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"


//
// The following assert macro is used to check that an input dpc is
// really a kdpc and not something else, like deallocated pool.
//

#define ASSERT_DPC(E) {             \
    ASSERT((E)->Type == DpcObject); \
}

VOID
KeInitializeDpc (
    IN PRKDPC Dpc,
    IN PKDEFERRED_ROUTINE DeferredRoutine,
    IN PVOID DeferredContext
    )

/*++

Routine Description:

    This function initializes a kernel DPC object. The deferred routine
    and context parameter are stored in the DPC object.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    DeferredRoutine - Supplies a pointer to a function that is called when
        the DPC object is removed from the current processor's DPC queue.

    DeferredContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the DeferredRoutine parameter.

Return Value:

    None.

--*/

{

    //
    // Initialize standard control object header.
    //

    Dpc->Type = DpcObject;

    //
    // Initialize deferred routine address and deferred context parameter.
    //

    Dpc->DeferredRoutine = DeferredRoutine;
    Dpc->DeferredContext = DeferredContext;
    Dpc->Inserted = FALSE;
    return;
}

BOOLEAN
KeInsertQueueDpc (
    IN PRKDPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function inserts a DPC object into the DPC queue. If the DPC object
    is already in the DPC queue, then no operation is performed. Otherwise,
    the DPC object is inserted in the DPC queue and a dispatch interrupt is
    requested.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

    SystemArgument1, SystemArgument2  - Supply a set of two arguments that
        contain untyped data provided by the executive.

Return Value:

    If the DPC object is already in a DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;
    PKPRCB Prcb;

    ASSERT_DPC(Dpc);

    //
    // Disable interrupts.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // If the DPC object is not in a DPC queue, then store the system
    // arguments, insert the DPC object in the DPC queue, increment the
    // number of DPCs queued to the target processor, increment the DPC
    // queue depth, set the address of the DPC target DPC spinlock, and
    // request a dispatch interrupt if appropriate.
    //

    Inserted = Dpc->Inserted;
    if (!Inserted) {

        Dpc->Inserted = TRUE;
        Dpc->SystemArgument1 = SystemArgument1;
        Dpc->SystemArgument2 = SystemArgument2;

        //
        // Insert the DPC at the end of the DPC queue.
        //

        Prcb = KeGetCurrentPrcb();
        InsertTailList(&Prcb->DpcListHead, &Dpc->DpcListEntry);

        //
        // If a DPC routine is not active on the target processor, then
        // request a dispatch interrupt if appropriate.
        //

        if ((Prcb->DpcRoutineActive == FALSE) &&
            (Prcb->DpcInterruptRequested == FALSE)) {

            //
            // Request a dispatch interrupt on the current processor.
            //

            Prcb->DpcInterruptRequested = TRUE;
            KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
        }
     }

     //
     // Release the DPC lock, enable interrupts, and return whether the
     // DPC was queued or not.
     //

     KeLowerIrql(OldIrql);
     return (BOOLEAN)!Inserted;
}

BOOLEAN
KeRemoveQueueDpc (
    IN PRKDPC Dpc
    )

/*++

Routine Description:

    This function removes a DPC object from the DPC queue. If the DPC object
    is not in the DPC queue, then no operation is performed. Otherwise, the
    DPC object is removed from the DPC queue and its inserted state is set
    FALSE.

Arguments:

    Dpc - Supplies a pointer to a control object of type DPC.

Return Value:

    If the DPC object is not in the DPC queue, then a value of FALSE is
    returned. Otherwise a value of TRUE is returned.

--*/

{

    BOOLEAN Inserted;

    ASSERT_DPC(Dpc);

    //
    // If the DPC object is in the DPC queue, then remove it from the queue
    // and set its inserted state to FALSE.
    //

    _disable();
    Inserted = Dpc->Inserted;
    if (Inserted) {

        //
        // If the specified DPC is still in the DPC queue, then remove it.
        //

        RemoveEntryList(&Dpc->DpcListEntry);
        Dpc->Inserted = FALSE;
    }

    //
    // Enable interrupts and return whether the DPC was removed from a DPC
    // queue.
    //

    _enable();
    return (BOOLEAN)Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\genxx.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    genxx.h

Abstract:

    This file contains macros (some of them destined for the M4 preprocessor)
    to aid in the generation of ks & hal header files.  This is used by
    ke\xxx\genxxx.c, as well as sdktools\genxx.

Author:

    Forrest C. Foltz (forrestf) 23-Jan-1998

Revision History:

--*/



//
// Structure element definitions.  
//

#define MAX_ELEMENT_NAME_LEN 127    // big enough for comments too
typedef struct _STRUC_ELEMENT {

//
// Flags is one or more SEF_xxx, defined below.
//

    UINT64 Flags;

//
// Note that Equate is used to store a pointer in the case of bitfield
// processing.
//

    UINT64 Equate;

//
// Name should be quite long, as it is used to hold comments as well.
//

    CHAR Name[ MAX_ELEMENT_NAME_LEN + 1 ];
} STRUC_ELEMENT, *PSTRUC_ELEMENT;

#define SEF_ENABLE_MASK     0x0000FF00      
#define SEF_HAL             0x00000100
#define SEF_KERNEL          0x00000200

#define SEF_INC_FORMAT_MASK 0x00010000
#define SEF_H_FORMAT        0x00000000
#define SEF_INC_FORMAT      0x00010000

//
// Types.  Note that SETMASK, CLRMASK has no effect on te BITFLD types.  BITFLD
// types have SEF_HAL | SEF_KERNEL set in the type.
//

#define SEF_TYPE_MASK       0x000000FF
#define SEF_EQUATE          0x00000000
#define SEF_EQUATE64        0x00000001
#define SEF_COMMENT         0x00000002      
#define SEF_STRING          0x00000003      // Equate is vararg to printf
#define SEF_BITFLD          0x00000004
#define SEF_BITALIAS        0x00000005
#define SEF_STRUCTURE       0x00000006
#define SEF_SETMASK         0x00000010      // Equate is the mask
#define SEF_CLRMASK         0x00000011      // Equate is the mask
#define SEF_END             0x00000012
#define SEF_START           0x00000013
#define SEF_PATH            0x00000014

//
// Note that BITFLD entries have per-entry hal|kernel flags
//


//
// Define architecture specific generation macros.
//

#define SEF_FLAGS 0
#define HAL SEF_HAL
#define KERNEL SEF_KERNEL

#ifndef ULONG_MAX
#define ULONG_MAX 0xFFFFFFFF
#endif

#ifdef _WIN64_
#define SEF_UINT SEF_EQUATE64
#else
#define SEF_UINT SEF_EQUATE
#endif

//
// genDef(Pc, KPCR, MinorVersion)
//
// -> #define PcMinorVersion 0x0
//

#define genDef(Prefix, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Prefix #Member },

//
// genAlt( PbAlignmentFixupCount, KPRCB, KeAlignmentFixupCount )
//
// -> #define PbAlignmentFixupCount 0x2f4
// 

#define genAlt(Name, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Name },

//
// genCom("This is a comment")
//
//    //
// -> // This is a comment
//    //
//

#define genCom(Comment) \
    { SEF_COMMENT, 0, Comment },

//
// genNam(PCR_MINOR_VERSION)
//
// -> #define PCR_MINOR_VERSION 0x1
//

#define genNam(Name) \
    { SEF_EQUATE, (ULONG)(Name), #Name },

//
// genNamUint(KSEG0_BASE)
//
// -> #define KSE0_BASE 0xffffffff80000000
//

#define genNamUint(Name) \
    { SEF_UINT, (UINT64)(Name), #Name },

//
// genVal(FirmwareFrameLength, FIRMWARE_FRAME_LENGTH)
//
// -> #define FirmwareFrameLength 0x250
//
// Note: if the value is 64-bit when _WIN64_ is enabled, use genValUint()
//

#define genVal(Name, Value) \
    { SEF_EQUATE, (ULONG)(Value), #Name },

//
// genValUint(KiPcr, KIPCR)
//
// -> #define KiPcr 0xe0000000ffffe000
//

#define genValUint(Name, Value) \
    { SEF_UINT, (UINT64)(Value), #Name },

//
// genSpc()
//
// ->
//

#define genSpc() \
    { SEF_STRING, 0, "\n" },

//
// genStr("    PCR equ ds:[0%lXH]\n", KIP0PCRADDRESS)
//
// ->     PCR equ ds:[0FFDFF000H]
//

#define genStr(String, Value) \
    { SEF_STRING, (ULONG_PTR)(Value), String },

//
// genTxt("ifdef NT_UP\n")
//
// -> ifdef NT_UP
//

#define genTxt(String) \
    { SEF_STRING, 0, String },

#define DisableInc( x ) \
    { SEF_CLRMASK, x, "" },

#define EnableInc( x ) \
    { SEF_SETMASK, x, "" },

#define MARKER_STRING "This is the genxx marker string."

//
// Source file can specify the _NTDRIVE\_NTROOT - relative output path.
// 'f' is the set of enable-flags that should be routed to this file.
// Use '0' if there is only a single output file.
//
// 'f' should also contain one of SEF_H_FORMAT or SEF_INC_FORMAT to
// indicate whether the generated file is in 'header file' or 'include file'
// format.
//

#define setPath( p, f ) \
    { SEF_PATH | f, 0, p },

//
// START_LIST defines the first element in ElementList.  This element contains
// a (possibly truncated) pointer to the ElementList array.  This is used to
// determine the fixup RA bias.
//

#define START_LIST \
    { SEF_START, (ULONG_PTR)ElementList, MARKER_STRING },

#define END_LIST \
    { SEF_END, 0, "" }

//
// Preprocessor assertion.  Do something here to make the compiler generate
// an error if x != y.
//

#define ASSERT_SAME( x, y )

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#ifndef OFFSET

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif

//
// Following are some M4 macros to help with bitfields.  
//

#ifndef SKIP_M4

//
// First, define the makezeros(n) macro that will generate a string with
// n pairs of ',0'.  This is a recursively defined macro.
//

define(`makezeros',`ifelse(eval($1),0,,`0,makezeros(eval($1-1))')')

//
// Define a concatenation macro.
//

define(`cat',`$1$2')

//
// The following example bitfield declaration uses HARDWARE_PTE as an
// example, which is declared (for alpha) as follows:
//
// typedef struct _HARDWARE_PTE {
//     ULONG Valid: 1;
//     ULONG Owner: 1;
//     ULONG Dirty: 1;
//     ULONG reserved: 1;
//     ULONG Global: 1;
//     ULONG GranularityHint: 2;
//     ULONG Write: 1;
//     ULONG CopyOnWrite: 1;
//     ULONG PageFrameNumber: 23;
// } HARDWARE_PTE, *PHARDWARE_PTE;
//
//
// // First, startBitStruc() is invoked with the structure name.
//
// startBitStruc( HARDWARE_PTE, SEF_HAL | SEF_KERNEL )
//
// //
// // Now, suppose we wanted to expose seven of the fields in an assembly
// // include file:
// //
//
// genBitField( Valid, PTE_VALID )
// genBitField( Owner, PTE_OWNER )
// genBitField( Dirty, PTE_DIRTY )
// genBitField( reserved )
// genBitField( Global, PTE_GLOBAL )
// genBitField( GranularityHint )
// genBitField( Write, PTE_WRITE )
// genBitField( CopyOnWrite, PTE_COPYONWRITE )
// genBitField( PageFrameNumber, PTE_PFN )
//
// Note that fields that are not used (in this case 'reserved' and
// 'GranularityHint') must still appear in the list.
//
// The above will generate a bunch of static, initialized copies of HARDWARE_PTE
// like so:
//
// HARDWARE_PTE HARDWARE_PTE_Valid = {
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Owner = {
//     0,   // Valid
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Dirty = {
//     0,   // Valid
//     0,   // Owner
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Global = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Write = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_CopyOnWrite = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_PageFrameNumber = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0,   // CopyOnWrite
//     0xFFFFFFFF };
//
// Then, as part of processing the END_LIST macro, these structures are
// generated:
//
// { SEF_BITFLD, &HARDWARE_PTE_Valid,           "PTE_VALID" },
// { SEF_BITFLD, &HARDWARE_PTE_Owner,           "PTE_OWNER" },
// { SEF_BITFLD, &HARDWARE_PTE_Dirty,           "PTE_DIRTY" },
// { SEF_BITFLD, &HARDWARE_PTE_Global,          "PTE_GLOBAL" },
// { SEF_BITFLD, &HARDWARE_PTE_Write,           "PTE_WRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_CopyOnWrite,     "PTE_COPYONWRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_PageFrameNumber, "PTE_PFN" },
// { SEF_END,    0,                             "" }
//
//
// ... and that's what gets compiled by the target compiler into the .obj.
// Now, the final stage: genxx.exe is run against this target .obj, and
// would generate the following:
//
// #define PTE_VALID_MASK 0x1
// #define PTE_VALID 0x0
// #define PTE_OWNER_MASK 0x2
// #define PTE_OWNER 0x1
// #define PTE_DIRTY_MASK 0x4
// #define PTE_DIRTY 0x2
// #define PTE_GLOBAL_MASK 0x10
// #define PTE_GLOBAL 0x4
// #define PTE_WRITE_MASK 0x80
// #define PTE_WRITE 0x7
// #define PTE_COPYONWRITE_MASK 0x100
// #define PTE_COPYONWRITE 0x8
// #define PTE_PFN_MASK 0xfffffe00
// #define PTE_PFN 0x9
//

//
// BITFIELD_STRUCS accumulates array element initializations.  END_LIST will
// dump these into the definition array.
// 

define(`BITFIELD_STRUCS',`')

//
// startBitStruc( <strucname>, <whichfile> )
// sets BIT_STRUC_NAME = <strucname> and resets the ZERO_FIELDS count to 0.
// It also sets the WHICH_FILE macro.
//

define(`startBitStruc', `define(`BIT_STRUC_NAME',`$1')
                         define(`BITFIELD_STRUCS',
                                 BITFIELD_STRUCS
                                 )
                         define(`ZERO_FIELDS',0)
                         define(`SEF_TYPE',$2)
                        ')

//
// genBitField( <fldname>, <generatedname> ) declares a structure of type
// <strucname> and initializes the <fldname> bitfield within it.
//
// Note that I used "cma" instead of an actual comma, this gets changed to
// a comma by END_LIST, below.  If I were more proficient with M4 I would know
// how to get around this.
//

define(`genBitField', `define(`VAR_NAME', cat(cat(BIT_STRUC_NAME,`_'),$1))
                      `#'define `def_'VAR_NAME
                      BIT_STRUC_NAME VAR_NAME = {'
                      `makezeros(ZERO_FIELDS)'
                      `(ULONG_PTR)-1 };'
                      `define(`PAD_VAR_NAME', cat(cat(BIT_STRUC_NAME,`p'),$1))'
                      `ULONG_PTR PAD_VAR_NAME = 0;'
                      `define(`ZERO_FIELDS',incr(ZERO_FIELDS))'
                      `define(`FIELD_NAME', $1)'
                      `define(`FIELD_ASMNAME', $2)'
                      `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `dec_'VAR_NAME
                               `#de'fine `dec_'VAR_NAME
                               { SEF_BITFLD | SEF_TYPE cma (ULONG_PTR)&VAR_NAME cma "FIELD_ASMNAME" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                      )

define(`genBitAlias', `define(`BITFIELD_STRUCS',
                               BITFIELD_STRUCS
                               `#i'fdef `def_'VAR_NAME
                               `#i'fndef `deca_'VAR_NAME
                               `#de'fine `deca_'VAR_NAME
                               { SEF_BITALIAS | SEF_TYPE cma 0 cma "$1" } cma
                               `#e'ndif
                               `#e'ndif
                               )'
                    )

//
// END_LIST dumps the array initializers accumulated by BITFIELD_STRUCS, after
// replacing each 'cma' with an actual comma.
//

define(`DUMP_BITFIELDS',`define(`cma',`,') BITFIELD_STRUCS')

#endif  // SKIP_M4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\eventobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eventobj.c

Abstract:

    This module implements the kernel event objects. Functions are
    provided to initialize, pulse, read, reset, and set event objects.

Author:

    David N. Cutler (davec) 27-Feb-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_EVENT(E) {                             \
    ASSERT((E)->Header.Type == NotificationEvent ||   \
           (E)->Header.Type == SynchronizationEvent); \
}

#undef KeInitializeEvent

VOID
KeInitializeEvent (
    IN PRKEVENT Event,
    IN EVENT_TYPE Type,
    IN BOOLEAN State
    )

/*++

Routine Description:

    This function initializes a kernel event object. The initial signal
    state of the object is set to the specified value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Type - Supplies the type of event; NotificationEvent or
        SynchronizationEvent.

    State - Supplies the initial signal state of the event object.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header, set initial signal
    // state of event object, and set the type of event object.
    //

    Event->Header.Type = (UCHAR)Type;
    Event->Header.Size = sizeof(KEVENT) / sizeof(LONG);
    Event->Header.SignalState = State;
    InitializeListHead(&Event->Header.WaitListHead);
    return;
}

LONG
KePulseEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function atomically sets the signal state of an event object to
    Signaled, attempts to satisfy as many Waits as possible, and then resets
    the signal state of the event object to Not-Signaled. The previous signal
    state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the current state of the event object is Not-Signaled and
    // the wait queue is not empty, then set the state of the event
    // to Signaled, satisfy as many Waits as possible, and then reset
    // the state of the event to Not-Signaled.
    //

    OldState = Event->Header.SignalState;
    if ((OldState == 0) && (IsListEmpty(&Event->Header.WaitListHead) == FALSE)) {
        Event->Header.SignalState = 1;
        KiWaitTest(Event, Increment);
    }

    Event->Header.SignalState = 0;

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to the
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitIrql = OldIrql;
        Thread->WaitNext = Wait;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeResetEvent (
    IN PRKEVENT Event
    )

/*++

Routine Description:

    This function resets the signal state of an event object to
    Not-Signaled. The previous state of the event object is returned
    as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of event object and then reset
    // the state of the event object to Not-Signaled.
    //

    OldState = Event->Header.SignalState;
    Event->Header.SignalState = 0;

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

LONG
KeSetEvent (
    IN PRKEVENT Event,
    IN KPRIORITY Increment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function sets the signal state of an event object to Signaled
    and attempts to satisfy as many Waits as possible. The previous
    signal state of the event object is returned as the function value.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Increment - Supplies the priority increment that is to be applied
       if setting the event causes a Wait to be satisfied.

    Wait - Supplies a boolean value that signifies whether the call to
       KePulseEvent will be immediately followed by a call to one of the
       kernel Wait functions.

Return Value:

    The previous signal state of the event object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;

    ASSERT_EVENT(Event);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Collect call data.
    //

#if defined(_COLLECT_SET_EVENT_CALLDATA_)

    RECORD_CALL_DATA(&KiSetEventCallData);

#endif

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the wait list is empty, then set the state of the event to signaled.
    // Otherwise, check if the wait can be satisfied immediately.
    //

    OldState = Event->Header.SignalState;
    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // If the event is a notification event or the wait is not a wait any,
        // then set the state of the event to signaled and attempt to satisfy
        // as many waits as possible. Otherwise, the wait can be satisfied by
        // directly unwaiting the thread.
        //

        WaitBlock = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                      KWAIT_BLOCK,
                                      WaitListEntry);

        if ((Event->Header.Type == NotificationEvent) ||
            (WaitBlock->WaitType != WaitAny)) {
            if (OldState == 0) {
                Event->Header.SignalState = 1;
                KiWaitTest(Event, Increment);
            }

        } else {
            KiUnwaitThread(WaitBlock->Thread, (NTSTATUS)WaitBlock->WaitKey, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
       Thread = KeGetCurrentThread();
       Thread->WaitNext = Wait;
       Thread->WaitIrql = OldIrql;

    } else {
       KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of event object.
    //

    return OldState;
}

VOID
KeSetEventBoostPriority (
    IN PRKEVENT Event,
    IN PRKTHREAD *Thread OPTIONAL
    )

/*++

Routine Description:

    This function conditionally sets the signal state of an event object
    to Signaled, and attempts to unwait the first waiter, and optionally
    returns the thread address of the unwatied thread.

    N.B. This function can only be called with synchronization events
         and is primarily for the purpose of implementing fast mutexes.
         It is assumed that the waiter is NEVER waiting on multiple
         objects.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type event.

    Thread - Supplies an optional pointer to a variable that receives
        the address of the thread that is awakened.

Return Value:

    None.

--*/

{

    KPRIORITY Increment;
    KIRQL OldIrql;
    PRKTHREAD WaitThread;

    ASSERT(Event->Header.Type == SynchronizationEvent);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the the wait list is not empty, then satisfy the wait of the
    // first thread in the wait list. Otherwise, set the signal state
    // of the event object.
    //
    // N.B. This function is only called for fast mutexes and exclusive
    //      access to resources. All waits MUST be wait for single object.
    //

    if (IsListEmpty(&Event->Header.WaitListHead) != FALSE) {
        Event->Header.SignalState = 1;

    } else {

        //
        // Get the address of the waiting thread.
        //

        WaitThread = CONTAINING_RECORD(Event->Header.WaitListHead.Flink,
                                       KWAIT_BLOCK,
                                       WaitListEntry)->Thread;

        //
        // If specified, return the address of the thread that is awakened.
        //

        if (ARGUMENT_PRESENT(Thread)) {
            *Thread = WaitThread;
        }

        //
        // Give the new owner of the resource/fast mutex (the only callers) a
        // full quantum, and unwait the thread with a standard event increment
        // unless the system is a server system, in which case no boost if given.
        //

        WaitThread->Quantum = WaitThread->ApcState.Process->ThreadQuantum;
        Increment = EVENT_INCREMENT;

        KiUnwaitThread(WaitThread, STATUS_SUCCESS, Increment);
    }

    //
    // Unlock dispatcher database lock and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\kernldat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kernldat.c

Abstract:

    This module contains the declaration and allocation of kernel data
    structures.

Author:

    David N. Cutler (davec) 12-Mar-1989

Revision History:

--*/
#include "ki.h"

//
// The following data is read/write data that is grouped together for
// performance. The layout of this data is important and must not be
// changed.
//
// KiDispatcherReadyListHead - This is an array of type list entry. The
//      elements of the array are indexed by priority. Each element is a list
//      head for a set of threads that are in a ready state for the respective
//      priority. This array is used by the find next thread code to speed up
//      search for a ready thread when a thread becomes unrunnable. See also
//      KiReadySummary.
//

LIST_ENTRY KiDispatcherReadyListHead[MAXIMUM_PRIORITY];

//
// KiIdleSummary - This is the set of processors that are idle. It is used by
//      the ready thread code to speed up the search for a thread to preempt
//      when a thread becomes runnable.
//

KAFFINITY KiIdleSummary;

//
// KiReadySummary - This is the set of dispatcher ready queues that are not
//      empty. A member is set in this set for each priority that has one or
//      more entries in its respective dispatcher ready queues.
//

ULONG KiReadySummary;

//
// KiTimerTableListHead - This is a array of list heads that anchor the
//      individual timer lists.
//

LIST_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];

//
// KeBootTime - This is the absolute time when the system was booted.
//

LARGE_INTEGER KeBootTime;

//
// KeBootTimeBias - The time for which KeBootTime has ever been biased
//

ULONGLONG KeBootTimeBias;

//
// KeTimeIncrement - This is the nominal number of 100ns units that are to
//      be added to the system time at each interval timer interupt. This
//      value is set by the HAL and is used to compute the dure time for
//      timer table entries.
//

const ULONG KeTimeIncrement = CLOCK_TIME_INCREMENT;

//
// KiMaximumSearchCount - this is the maximum number of timers entries that
//      have had to be examined to insert in the timer tree.
//

ULONG KiMaximumSearchCount;

//
// KiDebugRoutine - This is the address of the kernel debugger. Initially
//      this is filled with the address of a routine that just returns. If
//      the system debugger is present in the system, then it sets this
//      location to the address of the systemn debugger's routine.
//

PKDEBUG_ROUTINE KiDebugRoutine;

//
// KiFindLeftNibbleBitTable - This a table that is used to find the left most bit in
//      a 4-bit nibble.
//

const UCHAR KiFindLeftNibbleBitTable[] = {0, 0, 1, 1, 2, 2, 2, 2,
                                          3, 3, 3, 3, 3, 3, 3, 3};

//
// KiTimerExpireDpc - This is the Deferred Procedure Call (DPC) object that
//      is used to process the timer queue when a timer has expired.
//

KDPC KiTimerExpireDpc;

//
// KiTimeIncrementReciprocal - This is the reciprocal fraction of the time
//      increment value that is specified by the HAL when the system is
//      booted.
//
// The following is the number for a CLOCK_TIME_INCREMENT of 10000.
//

const LARGE_INTEGER KiTimeIncrementReciprocal = { 0xE219652C, 0xD1B71758 };

//
// KiTimeIncrementShiftCount - This is the shift count that corresponds to
//      the time increment reciprocal value.
//
// The following is the number for a CLOCK_TIME_INCREMENT of 10000.
//

const CCHAR KiTimeIncrementShiftCount = 13;

//
// KiWaitInListHead - This is a list of threads that are waiting with a
//      resident kernel stack.
//

LIST_ENTRY KiWaitInListHead;

//
// KiHardwareTrigger -
//

ULONG KiHardwareTrigger;

//
// KeTickCount - This is the number of clock ticks that have occurred since
//      the system was booted. This count is used to compute a millisecond
//      tick counter.
//

volatile ULONG KeTickCount;

//
// KeInterruptTime -
//

volatile KSYSTEM_TIME KeInterruptTime;

//
// KeSystemTime -
//

volatile KSYSTEM_TIME KeSystemTime;

//
// KeHasQuickBooted - This indicates that the system is initializing or has
//      initialized due to a quick boot.
//

BOOLEAN KeHasQuickBooted;

//
// KiIdleProcess - This is the process that holds the idle thread.
//

KPROCESS KiIdleProcess;

//
// KiSystemProcess - This is the process that holds all of the other threads.
//

KPROCESS KiSystemProcess;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\dpcsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    dpcsup.c

Abstract:

    This module contains the support routines for the system DPC objects.
    Functions are provided to process quantum end, the power notification
    queue, and timer expiration.

Author:

    David N. Cutler (davec) 22-Apr-1989

Environment:

    Kernel mode only, IRQL DISPATCH_LEVEL.

Revision History:

--*/

#include "ki.h"


//
// Define DPC entry structure and maximum DPC List size.
//

#define MAXIMUM_DPC_LIST_SIZE 16

typedef struct _DPC_ENTRY {
    PRKDPC Dpc;
    PKDEFERRED_ROUTINE Routine;
    PVOID Context;
} DPC_ENTRY, *PDPC_ENTRY;


PRKTHREAD
KiQuantumEnd (
    VOID
    )

/*++

Routine Description:

    This function is called when a quantum end event occurs on the current
    processor. Its function is to determine whether the thread priority should
    be decremented and whether a redispatch of the processor should occur.

Arguments:

    None.

Return Value:

    The next thread to be schedule on the current processor is returned as
    the function value. If this value is not NULL, then the return is with
    the dispatcher database locked. Otherwise, the dispatcher database is
    unlocked.

--*/

{

    KPRIORITY NewPriority;
    PKPRCB Prcb;
    KPRIORITY Priority;
    PKPROCESS Process;
    PRKTHREAD Thread;
    PRKTHREAD NextThread;

    //
    // Acquire the dispatcher database lock.
    //

    Prcb = KeGetCurrentPrcb();
    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabaseAtDpcLevel();

    //
    // If the quantum has expired for the current thread, then update its
    // quantum and priority.
    //

    if (Thread->Quantum <= 0) {

        //
        // If quantum runout is disabled for the thread's process and
        // the thread is running at a realtime priority, then set the
        // thread quantum to the highest value and do not round robin
        // at the thread's priority level. Otherwise, reset the thread
        // quantum and decay the thread's priority as appropriate.
        //

        Process = Thread->ApcState.Process;
        if ((Process->DisableQuantum != FALSE) &&
            (Thread->Priority >= LOW_REALTIME_PRIORITY)) {
            Thread->Quantum = MAXLONG;

        } else {
            Thread->Quantum = Process->ThreadQuantum;

            //
            // Decrement the thread's current priority if the thread is not
            // running in a realtime priority class and check to determine
            // if the processor should be redispatched.
            //

            Priority = Thread->Priority;
            if (Priority < LOW_REALTIME_PRIORITY) {
                NewPriority = Priority - Thread->PriorityDecrement - 1;
                if (NewPriority < Thread->BasePriority) {
                    NewPriority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;

            } else {
                NewPriority = Priority;
            }

            //
            // If the new thread priority is different that the current thread
            // priority, then the thread does not run at a realtime level and
            // its priority should be set. Otherwise, attempt to round robin
            // at the current level.
            //

            if (Priority != NewPriority) {
                KiSetPriorityThread(Thread, NewPriority);

            } else {
                if (Prcb->NextThread == NULL) {
                    NextThread = KiFindReadyThread(Priority);

                    if (NextThread != NULL) {
                        NextThread->State = Standby;
                        Prcb->NextThread = NextThread;
                    }

                } else {
                    Thread->Preempted = FALSE;
                }
            }
        }
    }

    //
    // If a thread was scheduled for execution on the current processor,
    // then return the address of the thread with the dispatcher database
    // locked. Otherwise, return NULL with the dispatcher data unlocked.
    //

    NextThread = Prcb->NextThread;
    if (NextThread == NULL) {
        KiUnlockDispatcherDatabaseFromDpcLevel();
    }

    return NextThread;
}

#if DBG


VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER CurrentTime
    )

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;

    //
    // Raise IRQL to highest level and scan timer table for timers that
    // have expired.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            NextEntry = NextEntry->Flink;
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {
                DbgBreakPoint();
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);

    //
    // Lower IRQL to the previous level.
    //

    KeLowerIrql(OldIrql);
    return;
}

#endif


VOID
KiTimerExpiration (
    IN PKDPC TimerDpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called when the clock interupt routine discovers that
    a timer has expired.

Arguments:

    TimerDpc - Supplies a pointer to a control object of type DPC.

    DeferredContext - Not used.

    SystemArgument1 - Supplies the starting timer table index value to
        use for the timer table scan.

    SystemArgument2 - Not used.

Return Value:

    None.

--*/

{
    ULARGE_INTEGER CurrentTime;
    LIST_ENTRY ExpiredListHead;
    LONG HandLimit;
    LONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKTIMER Timer;

    //
    // Acquire the dispatcher database lock and read the current interrupt
    // time to determine which timers have expired.
    //

    KiLockDispatcherDatabaseAtDpcLevel();
    KiQueryInterruptTime((PLARGE_INTEGER)&CurrentTime);

    //
    // If the timer table has not wrapped, then start with the specified
    // timer table index value, and scan for timer entries that have expired.
    // Otherwise, start with the first entry in the timer table and scan the
    // entire table for timer entries that have expired.
    //
    // N.B. This later condition exists when DPC processing is blocked for a
    //      period longer than one round trip throught the timer table.
    //

    HandLimit = (LONG)KiQueryLowTickCount();
    if (((ULONG)(HandLimit - PtrToLong(SystemArgument1))) >= TIMER_TABLE_SIZE) {
        Index = - 1;
        HandLimit = TIMER_TABLE_SIZE - 1;

    } else {
        Index = (PtrToLong(SystemArgument1) - 1) & (TIMER_TABLE_SIZE - 1);
        HandLimit &= (TIMER_TABLE_SIZE - 1);
    }

    InitializeListHead(&ExpiredListHead);
    do {
        Index = (Index + 1) & (TIMER_TABLE_SIZE - 1);
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            if (Timer->DueTime.QuadPart <= CurrentTime.QuadPart) {

                //
                // The next timer in the current timer list has expired.
                // Remove the entry from the timer list and insert the
                // timer in the expired list.
                //

                RemoveEntryList(&Timer->TimerListEntry);
                InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
                NextEntry = ListHead->Flink;

            } else {
                break;
            }
        }

    } while(Index != HandLimit);

#if DBG

    if (PtrToUlong(SystemArgument2) == 0) {
        KiCheckTimerTable(CurrentTime);
    }

#endif

    //
    // Process the expired timer list.
    //
    // N.B. The following function returns with the dispatcher database
    //      unlocked.
    //

    KiTimerListExpire(&ExpiredListHead, DISPATCH_LEVEL);
    return;
}

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function is called to process a list of timers that have expired.

    N.B. This function is called with the dispatcher database locked and
        returns with the dispatcher database unlocked.

Arguments:

    ExpiredListHead - Supplies a pointer to a list of timers that have
        expired.

    OldIrql - Supplies the previous IRQL.

Return Value:

    None.

--*/

{

    LONG Count;
    PKDPC Dpc;
    DPC_ENTRY DpcList[MAXIMUM_DPC_LIST_SIZE];
    LONG Index;
    LARGE_INTEGER Interval;
    LARGE_INTEGER SystemTime;
    PKTIMER Timer;

    //
    // Capture the timer expiration time.
    //

    KiQuerySystemTime(&SystemTime);

    //
    // Remove the next timer from the expired timer list, set the state of
    // the timer to signaled, reinsert the timer in the timer tree if it is
    // periodic, and optionally call the DPC routine if one is specified.
    //

RestartScan:
    Count = 0;
    while (ExpiredListHead->Flink != ExpiredListHead) {
        Timer = CONTAINING_RECORD(ExpiredListHead->Flink, KTIMER, TimerListEntry);
        KiRemoveTreeTimer(Timer);
        Timer->Header.SignalState = 1;
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            KiWaitTest(Timer, TIMER_EXPIRE_INCREMENT);
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer in the table. If this happens,
        //      try again.
        //
        if (Timer->Period != 0) {
            Interval.QuadPart = Int32x32To64(Timer->Period, - 10 * 1000);
            while (!KiInsertTreeTimer(Timer, Interval)) {
                ;
            }
        }

        if (Timer->Dpc != NULL) {
            Dpc = Timer->Dpc;

            //
            // If the DPC is explicitly targeted to another processor, then
            // queue the DPC to the target processor. Otherwise, capture the
            // DPC parameters for execution on the current processor.
            //

            DpcList[Count].Dpc = Dpc;
            DpcList[Count].Routine = Dpc->DeferredRoutine;
            DpcList[Count].Context = Dpc->DeferredContext;
            Count += 1;
            if (Count == MAXIMUM_DPC_LIST_SIZE) {
                break;
            }
        }
    }

    //
    // Unlock the dispacher database and process DPC list entries.
    //

    if (Count != 0) {
        KiUnlockDispatcherDatabase(DISPATCH_LEVEL);
        Index = 0;
        do {

#if DBG && (defined(i386) || defined(ALPHA))

            //
            // Reset the dpc tick count. If the tick count handler,
            // which increments this value, detects that it has crossed
            // a certain threshold, a breakpoint will be generated.
            //

            KeGetCurrentPrcb()->DebugDpcTime = 0;
#endif

            (DpcList[Index].Routine)(DpcList[Index].Dpc,
                                     DpcList[Index].Context,
                                     ULongToPtr(SystemTime.LowPart),
                                     ULongToPtr(SystemTime.HighPart));

            Index += 1;
        } while (Index < Count);

        //
        // If processing of the expired timer list was terminated because
        // the DPC List was full, then process any remaining entries.
        //

        if (Count == MAXIMUM_DPC_LIST_SIZE) {
            KiLockDispatcherDatabaseAtDpcLevel();
            goto RestartScan;
        }

        KeLowerIrql(OldIrql);

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\ki.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ki.h

Abstract:

    This module contains the private (internal) header file for the
    kernel.

Author:

    David N. Cutler (davec) 28-Feb-1989

Revision History:

--*/

#ifndef _KI_
#define _KI_
#include "ntos.h"
#include "stdio.h"
#include "stdlib.h"
#include "zwapi.h"

//
// Private (internal) constant definitions.
//
// Priority increment value definitions
//

#define ALERT_INCREMENT 2           // Alerted unwait priority increment
#define BALANCE_INCREMENT 10        // Balance set priority increment
#define RESUME_INCREMENT 0          // Resume thread priority increment
#define TIMER_EXPIRE_INCREMENT 0    // Timer expiration priority increment

//
// Define time critical priority class base.
//

#define TIME_CRITICAL_PRIORITY_BOUND 14

//
// Define NIL pointer value.
//

#define NIL (PVOID)NULL             // Null pointer to void

//
// Define macros which are used in the kernel only
//
// Clear member in set
//

#define ClearMember(Member, Set) \
    Set = Set & (~(1 << (Member)))

//
// Set member in set
//

#define SetMember(Member, Set) \
    Set = Set | (1 << (Member))

#define FindFirstSetLeftMember(Set, Member) {                          \
    ULONG _Bit;                                                        \
    ULONG _Mask;                                                       \
    ULONG _Offset = 16;                                                \
    if ((_Mask = Set >> 16) == 0) {                                    \
        _Offset = 0;                                                   \
        _Mask = Set;                                                   \
    }                                                                  \
    if (_Mask >> 8) {                                                  \
        _Offset += 8;                                                  \
    }                                                                  \
    if ((_Bit = Set >> _Offset) & 0xf0) {                              \
        _Bit >>= 4;                                                    \
        _Offset += 4;                                                  \
    }                                                                  \
    *(Member) = KiFindLeftNibbleBitTable[_Bit] + _Offset;              \
}

//
// Lock and unlock APC queue lock.
//

#define KiLockApcQueue(Thread, OldIrql) \
    *(OldIrql) = KeRaiseIrqlToSynchLevel()

#define KiLockApcQueueAtDpcLevel(Thread) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

#define KiUnlockApcQueue(Thread, OldIrql) KeLowerIrql((OldIrql))

#define KiUnlockApcQueueFromDpcLevel(Thread) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL)

// VOID
// KiBoostPriorityThread (
//    IN PKTHREAD Thread,
//    IN KPRIORITY Increment
//    )
//
//*++
//
// Routine Description:
//
//    This function boosts the priority of the specified thread using
//    the same algorithm used when a thread gets a boost from a wait
//    operation.
//
// Arguments:
//
//    Thread  - Supplies a pointer to a dispatcher object of type thread.
//
//    Increment - Supplies the priority increment that is to be applied to
//        the thread's priority.
//
// Return Value:
//
//    None.
//
//--*

#define KiBoostPriorityThread(Thread, Increment) {              \
    KPRIORITY NewPriority;                                      \
    PKPROCESS Process;                                          \
                                                                \
    if ((Thread)->Priority < LOW_REALTIME_PRIORITY) {           \
        if ((Thread)->PriorityDecrement == 0) {                 \
            NewPriority = (Thread)->BasePriority + (Increment); \
            if (NewPriority > (Thread)->Priority) {             \
                if (NewPriority >= LOW_REALTIME_PRIORITY) {     \
                    NewPriority = LOW_REALTIME_PRIORITY - 1;    \
                }                                               \
                                                                \
                Process = (Thread)->ApcState.Process;           \
                (Thread)->Quantum = Process->ThreadQuantum;     \
                KiSetPriorityThread((Thread), NewPriority);     \
            }                                                   \
        }                                                       \
    }                                                           \
}

// VOID
// KiInsertWaitList (
//    IN KPROCESSOR_MODE WaitMode,
//    IN PKTHREAD Thread
//    )
//
//*++
//
// Routine Description:
//
//    This function inserts the specified thread in the appropriate
//    wait list.
//
// Arguments:
//
//    WaitMode - Supplies the processor mode of the wait operation.
//
//    Thread - Supplies a pointer to a dispatcher object of type
//        thread.
//
// Return Value:
//
//    None.
//
//--*

#define KiInsertWaitList(_WaitMode, _Thread) {                  \
    PLIST_ENTRY _ListHead;                                      \
    _ListHead = &KiWaitInListHead;                              \
    InsertTailList(_ListHead, &(_Thread)->WaitListEntry);       \
}

//
// Private (internal) structure definitions.
//
// APC Parameter structure.
//

typedef struct _KAPC_RECORD {
    PKNORMAL_ROUTINE NormalRoutine;
    PVOID NormalContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
} KAPC_RECORD, *PKAPC_RECORD;

//
// Executive initialization.
//

VOID
ExpInitializeExecutive (
    VOID
    );

//
// Private (internal) function definitions.
//

VOID
FASTCALL
KiActivateWaiterQueue (
    IN PRKQUEUE Queue
    );

VOID
KiApcInterrupt (
    VOID
    );

#if DBG

VOID
KiCheckTimerTable (
    IN ULARGE_INTEGER SystemTime
    );

#endif

ULONG
KiComputeTimerTableIndex (
    IN LARGE_INTEGER Interval,
    IN LARGE_INTEGER CurrentCount,
    IN PRKTIMER Timer
    );

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    );

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
KiDeliverApc (
    VOID
    );

VOID
KiDeliverUserApc (
    VOID
    );

BOOLEAN
KiDisableInterrupts (
    VOID
    );

VOID
KiRestoreInterrupts (
    IN BOOLEAN Enable
    );

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    );

VOID
KiDispatchInterrupt (
    VOID
    );

PKTHREAD
FASTCALL
KiFindReadyThread (
    KPRIORITY LowPriority
    );

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN SIZE_T ThreadLocalStorageSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    );

VOID
KiInitializeKernel (
    VOID
    );

VOID
KiInitSystem (
    VOID
    );

BOOLEAN
KiInitMachineDependent (
    VOID
    );

LONG
FASTCALL
KiInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry,
    IN BOOLEAN Head
    );

BOOLEAN
FASTCALL
KiInsertQueueApc (
    IN PKAPC Apc,
    IN KPRIORITY Increment
    );

LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PRKTIMER Timer,
    IN LARGE_INTEGER Interval
    );

VOID
KiInterruptDispatch (
    VOID
    );

VOID
KiLevelInterruptDispatch (
    VOID
    );

#if defined(i386)

VOID
KiInitializePcr (
    IN PKPCR    Pcr,
    IN PKTHREAD Thread,
    IN PVOID DpcStack
    );

VOID
KiFlushNPXState (
    VOID
    );

VOID
KiSetHardwareTrigger (
    VOID
    );

#ifdef DBGMP
VOID
KiPollDebugger (
    VOID
    );
#endif

#endif

KIRQL
KiLockDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue
    );

PRKTHREAD
KiQuantumEnd (
    VOID
    );

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    );

VOID
FASTCALL
KiReadyThread (
    IN PRKTHREAD Thread
    );

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PRKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    );

#if DBG

#define KiRemoveTreeTimer(Timer)               \
    (Timer)->Header.Inserted = FALSE;          \
    RemoveEntryList(&(Timer)->TimerListEntry); \
    (Timer)->TimerListEntry.Flink = NULL;      \
    (Timer)->TimerListEntry.Blink = NULL

#else

#define KiRemoveTreeTimer(Timer)               \
    (Timer)->Header.Inserted = FALSE;          \
    RemoveEntryList(&(Timer)->TimerListEntry)

#endif

#define KiRequestApcInterrupt() KiRequestSoftwareInterrupt(APC_LEVEL)

#define KiRequestDispatchInterrupt()

PRKTHREAD
FASTCALL
KiSelectNextThread (
    IN PRKTHREAD Thread
    );

VOID
KiSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    );

VOID
KiSuspendNop (
    IN struct _KAPC *Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    );

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

LONG_PTR
FASTCALL
KiSwapThread (
    VOID
    );

VOID
KiThreadStartup (
    IN PVOID StartContext
    );

VOID
KiTimerExpiration (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FASTCALL
KiTimerListExpire (
    IN PLIST_ENTRY ExpiredListHead,
    IN KIRQL OldIrql
    );

VOID
KiUnexpectedInterrupt (
    VOID
    );

VOID
KiUnlockDeviceQueue (
    IN PKDEVICE_QUEUE DeviceQueue,
    IN KIRQL OldIrql
    );

VOID
FASTCALL
KiUnwaitThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment
    );

VOID
FASTCALL
KiWaitSatisfyAll (
    IN PRKWAIT_BLOCK WaitBlock
    );

//
// VOID
// FASTCALL
// KiWaitSatisfyAny (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object and performs
//    any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyAny(_Object_, _Thread_) {                               \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    } else if ((_Object_)->Header.Type == MutantObject) {                    \
        (_Object_)->Header.SignalState -= 1;                                 \
        if ((_Object_)->Header.SignalState == 0) {                           \
            (_Object_)->OwnerThread = (_Thread_);                            \
            if ((_Object_)->Abandoned == TRUE) {                             \
                (_Object_)->Abandoned = FALSE;                               \
                (_Thread_)->WaitStatus = STATUS_ABANDONED;                   \
            }                                                                \
                                                                             \
            InsertHeadList((_Thread_)->MutantListHead.Blink,                 \
                           &(_Object_)->MutantListEntry);                    \
        }                                                                    \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyMutant (
//    IN PKMUTANT Object,
//    IN PKTHREAD Thread
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for a mutant object.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
//    Thread - Supplies a pointer to a dispatcher object of type thread.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyMutant(_Object_, _Thread_) {                            \
    (_Object_)->Header.SignalState -= 1;                                     \
    if ((_Object_)->Header.SignalState == 0) {                               \
        (_Object_)->OwnerThread = (_Thread_);                                \
        if ((_Object_)->Abandoned == TRUE) {                                 \
            (_Object_)->Abandoned = FALSE;                                   \
            (_Thread_)->WaitStatus = STATUS_ABANDONED;                       \
        }                                                                    \
                                                                             \
        InsertHeadList((_Thread_)->MutantListHead.Blink,                     \
                       &(_Object_)->MutantListEntry);                        \
    }                                                                        \
}

//
// VOID
// FASTCALL
// KiWaitSatisfyOther (
//    IN PKMUTANT Object
//    )
//
//
// Routine Description:
//
//    This function satisfies a wait for any type of object except a mutant
//    and performs any side effects that are necessary.
//
// Arguments:
//
//    Object - Supplies a pointer to a dispatcher object.
//
// Return Value:
//
//    None.
//

#define KiWaitSatisfyOther(_Object_) {                                       \
    if (((_Object_)->Header.Type & DISPATCHER_OBJECT_TYPE_MASK) == EventSynchronizationObject) { \
        (_Object_)->Header.SignalState = 0;                                  \
                                                                             \
    } else if ((_Object_)->Header.Type == SemaphoreObject) {                 \
        (_Object_)->Header.SignalState -= 1;                                 \
                                                                             \
    }                                                                        \
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    );

#endif // _KI_

//
// External references to private kernel data structures
//

extern PKDEBUG_ROUTINE KiDebugRoutine;
extern LIST_ENTRY KiDispatcherReadyListHead[MAXIMUM_PRIORITY];
extern ULONG_PTR KiHardwareTrigger;
extern KAFFINITY KiIdleSummary;
extern const UCHAR KiFindLeftNibbleBitTable[];
extern ULONG KiReadySummary;
extern const LARGE_INTEGER KiTimeIncrementReciprocal;
extern const CCHAR KiTimeIncrementShiftCount;
extern LIST_ENTRY KiTimerTableListHead[TIMER_TABLE_SIZE];
extern KDPC KiTimerExpireDpc;
extern LIST_ENTRY KiWaitInListHead;
extern KPROCESS KiIdleProcess;
extern KPROCESS KiSystemProcess;

#if defined(i386)

VOID
KeFlushCurrentTbAndInvalidateAllCaches (
    VOID
    );

VOID
KeInvalidateAllCaches (
    VOID
    );

#endif

#if DBG

extern ULONG KiMaximumSearchCount;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\genxx.inc ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    genxx.inc

Abstract:

    This file contains common code to generate assembler definitions.

Author:

    David N. Cutler (davec) 9-Aug-1995

Revision History:

    Forrest C. Foltz (forrestf) 26-Jan-1998

        Modified for use with genxx.exe utility

--*/

    //
    // Size of a pointer in bytes.
    //

    genCom("Pointer size in bytes")

    genVal(SizeofPointer, sizeof(PVOID))

    //
    // Thread state enumerated type definitions.
    //

    genCom("Thread State Enumerated Type Values")

    genVal(Initialized, Initialized)
    genVal(Ready, Ready)
    genVal(Running, Running)
    genVal(Standby, Standby)
    genVal(Terminated, Terminated)
    genVal(Waiting, Waiting)

    //
    // Wait reason and wait type enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Wait Reason and Wait Type Enumerated Type Values")

    genVal(WrExecutive, Executive)

    DisableInc(HAL)

    genVal(WrEventPair, WrEventPair)
    genVal(WaitAny, WaitAny)
    genVal(WaitAll, WaitAll)

    //
    // APC state structure offset definitions.
    //

    genCom("Apc State Structure Offset Definitions")

    genDef(As, KAPC_STATE, ApcListHead)
    genDef(As, KAPC_STATE, Process)
    genDef(As, KAPC_STATE, KernelApcInProgress)
    genDef(As, KAPC_STATE, KernelApcPending)
    genDef(As, KAPC_STATE, UserApcPending)
    genDef(As, KAPC_STATE, ApcQueueable)

    //
    // Bug check code definitions
    //

    EnableInc(HAL)

    genCom("Bug Check Code Definitions")

    genVal(APC_INDEX_MISMATCH, APC_INDEX_MISMATCH)
    genVal(ATTEMPTED_FPU_USE_FROM_DPC, ATTEMPTED_FPU_USE_FROM_DPC)
    genVal(ATTEMPTED_SWITCH_FROM_DPC, ATTEMPTED_SWITCH_FROM_DPC)
    genVal(DATA_BUS_ERROR, DATA_BUS_ERROR)
    genVal(DATA_COHERENCY_EXCEPTION, DATA_COHERENCY_EXCEPTION)
    genVal(HAL1_INITIALIZATION_FAILED, HAL1_INITIALIZATION_FAILED)
    genVal(INSTRUCTION_BUS_ERROR, INSTRUCTION_BUS_ERROR)
    genVal(INSTRUCTION_COHERENCY_EXCEPTION, INSTRUCTION_COHERENCY_EXCEPTION)
    genVal(INTERRUPT_EXCEPTION_NOT_HANDLED, INTERRUPT_EXCEPTION_NOT_HANDLED)
    genVal(INTERRUPT_UNWIND_ATTEMPTED, INTERRUPT_UNWIND_ATTEMPTED)
    genVal(INVALID_AFFINITY_SET, INVALID_AFFINITY_SET)
    genVal(INVALID_DATA_ACCESS_TRAP, INVALID_DATA_ACCESS_TRAP)
    genVal(IRQL_GT_ZERO_AT_SYSTEM_SERVICE, IRQL_GT_ZERO_AT_SYSTEM_SERVICE)
    genVal(IRQL_NOT_LESS_OR_EQUAL, IRQL_NOT_LESS_OR_EQUAL)
    genVal(KMODE_EXCEPTION_NOT_HANDLED, KMODE_EXCEPTION_NOT_HANDLED)
    genVal(NMI_HARDWARE_FAILURE, NMI_HARDWARE_FAILURE)
    genVal(NO_USER_MODE_CONTEXT, NO_USER_MODE_CONTEXT)
    genVal(PAGE_FAULT_WITH_INTERRUPTS_OFF, PAGE_FAULT_WITH_INTERRUPTS_OFF)
    genVal(PANIC_STACK_SWITCH, PANIC_STACK_SWITCH)
    genVal(SPIN_LOCK_INIT_FAILURE, SPIN_LOCK_INIT_FAILURE)
    genVal(SYSTEM_EXIT_OWNED_MUTEX, SYSTEM_EXIT_OWNED_MUTEX)
    genVal(SYSTEM_SERVICE_EXCEPTION, SYSTEM_SERVICE_EXCEPTION)
    genVal(SYSTEM_UNWIND_PREVIOUS_USER, SYSTEM_UNWIND_PREVIOUS_USER)
    genVal(TRAP_CAUSE_UNKNOWN, TRAP_CAUSE_UNKNOWN)
    genVal(UNEXPECTED_KERNEL_MODE_TRAP, UNEXPECTED_KERNEL_MODE_TRAP)

    DisableInc(HAL)

    //
    // Breakpoint types
    //

    EnableInc(HAL)

    genCom("Breakpoint type definitions")

    genVal(DBG_STATUS_CONTROL_C, DBG_STATUS_CONTROL_C)

    DisableInc(HAL)

    //
    // Client Id structure offset definitions.
    //

    genCom("Client Id Structure Offset Definitions")

    genDef(Cid, CLIENT_ID, UniqueProcess)
    genDef(Cid, CLIENT_ID, UniqueThread)

    //
    // Critical section structure offset definitions.
    //

    genCom("Critical Section Structure Offset Definitions")

    genDef(Cs, RTL_CRITICAL_SECTION, LockCount)
    genDef(Cs, RTL_CRITICAL_SECTION, RecursionCount)
    genDef(Cs, RTL_CRITICAL_SECTION, OwningThread)

    //
    // File object strucutre offset definitions.
    //

    genCom("File Object Structure Offset Definitions")

    genDef(Fo, FILE_OBJECT, LockCount)
    genDef(Fo, FILE_OBJECT, Lock)

    //
    // Exception record offset, flag, and enumerated type definitions.
    //

    EnableInc(HAL)

    genCom("Exception Record Offset, Flag, and Enumerated Type Definitions")

    genVal(EXCEPTION_NONCONTINUABLE, EXCEPTION_NONCONTINUABLE)
    genVal(EXCEPTION_UNWINDING, EXCEPTION_UNWINDING)
    genVal(EXCEPTION_EXIT_UNWIND, EXCEPTION_EXIT_UNWIND)
    genVal(EXCEPTION_STACK_INVALID, EXCEPTION_STACK_INVALID)
    genVal(EXCEPTION_NESTED_CALL, EXCEPTION_NESTED_CALL)
    genVal(EXCEPTION_TARGET_UNWIND, EXCEPTION_TARGET_UNWIND)
    genVal(EXCEPTION_COLLIDED_UNWIND, EXCEPTION_COLLIDED_UNWIND)
    genVal(EXCEPTION_UNWIND, EXCEPTION_UNWIND)
    genVal(EXCEPTION_EXECUTE_HANDLER, EXCEPTION_EXECUTE_HANDLER)
    genVal(EXCEPTION_CONTINUE_SEARCH, EXCEPTION_CONTINUE_SEARCH)
    genVal(EXCEPTION_CONTINUE_EXECUTION, EXCEPTION_CONTINUE_EXECUTION)

#if defined(_X86_)

    genVal(EXCEPTION_CHAIN_END, (ULONG)EXCEPTION_CHAIN_END)

#endif

    genSpc()

    genVal(ExceptionContinueExecution, ExceptionContinueExecution)
    genVal(ExceptionContinueSearch, ExceptionContinueSearch)
    genVal(ExceptionNestedException, ExceptionNestedException)
    genVal(ExceptionCollidedUnwind, ExceptionCollidedUnwind)

    genSpc()

    genDef(Er, EXCEPTION_RECORD, ExceptionCode)
    genDef(Er, EXCEPTION_RECORD, ExceptionFlags)
    genDef(Er, EXCEPTION_RECORD, ExceptionRecord)
    genDef(Er, EXCEPTION_RECORD, ExceptionAddress)
    genDef(Er, EXCEPTION_RECORD, NumberParameters)
    genDef(Er, EXCEPTION_RECORD, ExceptionInformation)
    genVal(ExceptionRecordLength, (sizeof(EXCEPTION_RECORD) + 15) & (~15))

    DisableInc(HAL)

    //
    // Fast Mutex structure offset definitions.
    //

    EnableInc(HAL)

    //
    // Interrupt priority request level definitions
    //

    genCom("Interrupt Priority Request Level Definitions")

    genVal(PASSIVE_LEVEL, PASSIVE_LEVEL)
    genVal(APC_LEVEL, APC_LEVEL)
    genVal(DISPATCH_LEVEL, DISPATCH_LEVEL)

#if defined(_X86_)

    genVal(SCI_LEVEL, SCI_LEVEL)
    genVal(SMBUS_LEVEL, SMBUS_LEVEL)
    genVal(CLOCK_LEVEL, CLOCK_LEVEL)

#endif

    genVal(IPI_LEVEL, IPI_LEVEL)
    genVal(POWER_LEVEL, POWER_LEVEL)
    genVal(PROFILE_LEVEL, PROFILE_LEVEL)
    genVal(HIGH_LEVEL, HIGH_LEVEL)
    genVal(SYNCH_LEVEL, SYNCH_LEVEL)

    //
    // Large integer structure offset definitions.
    //

    genCom("Large Integer Structure Offset Definitions")

    genDef(Li, LARGE_INTEGER, LowPart)
    genDef(Li, LARGE_INTEGER, HighPart)

    //
    // List entry structure offset definitions.
    //

    genCom("List Entry Structure Offset Definitions")

    genDef(Ls, LIST_ENTRY, Flink)
    genDef(Ls, LIST_ENTRY, Blink)

    //
    // String structure offset definitions.
    //

    genCom("String Structure Offset Definitions")

    genDef(Str, STRING, Length)
    genDef(Str, STRING, MaximumLength)
    genDef(Str, STRING, Buffer)

    //
    // System time structure offset definitions.
    //

#if defined(_MIPS_) || defined(_PPC_) || defined(_X86_)

    genCom("System Time Structure Offset Definitions")

    genAlt(StLowTime, KSYSTEM_TIME, LowPart)
    genDef(St, KSYSTEM_TIME, High1Time)
    genDef(St, KSYSTEM_TIME, High2Time)

#endif

    //
    // Time structure offset definitions.
    //

    genCom("Time Structure Offset Definitions")

    genAlt(TmLowTime, LARGE_INTEGER, LowPart)
    genAlt(TmHighTime, LARGE_INTEGER , HighPart)

    DisableInc(HAL)

    //
    // Status code definitions
    //

    genCom("Status Code Definitions")

    genVal(STATUS_ACCESS_VIOLATION, STATUS_ACCESS_VIOLATION)
    genVal(STATUS_ALERTED, STATUS_ALERTED)
    genVal(STATUS_ARRAY_BOUNDS_EXCEEDED, STATUS_ARRAY_BOUNDS_EXCEEDED)
    genVal(STATUS_BAD_COMPRESSION_BUFFER, STATUS_BAD_COMPRESSION_BUFFER)
    genVal(STATUS_BREAKPOINT, STATUS_BREAKPOINT)
    genVal(STATUS_DATATYPE_MISALIGNMENT, STATUS_DATATYPE_MISALIGNMENT)
    genVal(STATUS_DEVICE_PROTOCOL_ERROR, STATUS_DEVICE_PROTOCOL_ERROR)
    genVal(STATUS_FLOAT_DENORMAL_OPERAND, STATUS_FLOAT_DENORMAL_OPERAND)
    genVal(STATUS_FLOAT_DIVIDE_BY_ZERO, STATUS_FLOAT_DIVIDE_BY_ZERO)
    genVal(STATUS_FLOAT_INEXACT_RESULT, STATUS_FLOAT_INEXACT_RESULT)
    genVal(STATUS_FLOAT_INVALID_OPERATION, STATUS_FLOAT_INVALID_OPERATION)
    genVal(STATUS_FLOAT_OVERFLOW, STATUS_FLOAT_OVERFLOW)
    genVal(STATUS_FLOAT_STACK_CHECK, STATUS_FLOAT_STACK_CHECK)
    genVal(STATUS_FLOAT_UNDERFLOW, STATUS_FLOAT_UNDERFLOW)
    genVal(STATUS_FLOAT_MULTIPLE_FAULTS, STATUS_FLOAT_MULTIPLE_FAULTS)
    genVal(STATUS_FLOAT_MULTIPLE_TRAPS, STATUS_FLOAT_MULTIPLE_TRAPS)
    genVal(STATUS_GUARD_PAGE_VIOLATION, STATUS_GUARD_PAGE_VIOLATION)
    genVal(STATUS_ILLEGAL_FLOAT_CONTEXT, STATUS_ILLEGAL_FLOAT_CONTEXT)
    genVal(STATUS_ILLEGAL_INSTRUCTION, STATUS_ILLEGAL_INSTRUCTION)
    genVal(STATUS_INSTRUCTION_MISALIGNMENT, STATUS_INSTRUCTION_MISALIGNMENT)
    genVal(STATUS_INVALID_HANDLE, STATUS_INVALID_HANDLE)
    genVal(STATUS_INVALID_LOCK_SEQUENCE, STATUS_INVALID_LOCK_SEQUENCE)
    genVal(STATUS_INVALID_OWNER, STATUS_INVALID_OWNER)
    genVal(STATUS_INVALID_PARAMETER, STATUS_INVALID_PARAMETER)
    genVal(STATUS_INVALID_PARAMETER_1, STATUS_INVALID_PARAMETER_1)
    genVal(STATUS_INVALID_SYSTEM_SERVICE, STATUS_INVALID_SYSTEM_SERVICE)
    genVal(STATUS_INTEGER_DIVIDE_BY_ZERO, STATUS_INTEGER_DIVIDE_BY_ZERO)
    genVal(STATUS_INTEGER_OVERFLOW, STATUS_INTEGER_OVERFLOW)
    genVal(STATUS_IN_PAGE_ERROR, STATUS_IN_PAGE_ERROR)
    genVal(STATUS_IO_DEVICE_ERROR, STATUS_IO_DEVICE_ERROR)
    genVal(STATUS_IO_TIMEOUT, STATUS_IO_TIMEOUT)
    genVal(STATUS_KERNEL_APC, STATUS_KERNEL_APC)
    genVal(STATUS_LONGJUMP, STATUS_LONGJUMP)
    genVal(STATUS_NO_CALLBACK_ACTIVE, STATUS_NO_CALLBACK_ACTIVE)
    genVal(STATUS_NO_EVENT_PAIR, STATUS_NO_EVENT_PAIR)
    genVal(STATUS_NO_MEMORY, STATUS_NO_MEMORY)
    genVal(STATUS_PRIVILEGED_INSTRUCTION, STATUS_PRIVILEGED_INSTRUCTION)
    genVal(STATUS_SINGLE_STEP, STATUS_SINGLE_STEP)
    genVal(STATUS_STACK_OVERFLOW, STATUS_STACK_OVERFLOW)
    genVal(STATUS_SUCCESS, STATUS_SUCCESS)
    genVal(STATUS_THREAD_IS_TERMINATING, STATUS_THREAD_IS_TERMINATING)
    genVal(STATUS_TIMEOUT, STATUS_TIMEOUT)
    genVal(STATUS_UNWIND, STATUS_UNWIND)
    genVal(STATUS_WAKE_SYSTEM_DEBUGGER, STATUS_WAKE_SYSTEM_DEBUGGER)

    //
    // Define kernel object structure definitions.
    //
    // APC object structure defintions.
    //

    genCom("APC Object Structure Offset Definitions")

    genDef(Ap, KAPC, Type)
    genDef(Ap, KAPC, ApcMode)
    genDef(Ap, KAPC, Inserted)
    genDef(Ap, KAPC, Thread)
    genDef(Ap, KAPC, ApcListEntry)
    genDef(Ap, KAPC, KernelRoutine)
    genDef(Ap, KAPC, RundownRoutine)
    genDef(Ap, KAPC, NormalRoutine)
    genDef(Ap, KAPC, NormalContext)
    genDef(Ap, KAPC, SystemArgument1)
    genDef(Ap, KAPC, SystemArgument2)
    genVal(ApcObjectLength, sizeof(KAPC))

    //
    // DPC Object structure definitions.
    //

    EnableInc(HAL)

    genCom("DPC object Structure Offset Definitions")

    genDef(Dp, KDPC, Type)
    genDef(Dp, KDPC, Inserted)
    genDef(Dp, KDPC, DpcListEntry)
    genDef(Dp, KDPC, DeferredRoutine)
    genDef(Dp, KDPC, DeferredContext)
    genDef(Dp, KDPC, SystemArgument1)
    genDef(Dp, KDPC, SystemArgument2)
    genVal(DpcObjectLength, sizeof(KDPC))

    DisableInc(HAL)

    //
    // Device queue object structure definitions.
    //

    genCom("Device Queue Object Structure Offset Definitions")

    genDef(Dv, KDEVICE_QUEUE, Type)
    genDef(Dv, KDEVICE_QUEUE, Size)
    genDef(Dv, KDEVICE_QUEUE, Busy)
    genDef(Dv, KDEVICE_QUEUE, DeviceListHead)
    genVal(DeviceQueueObjectLength, sizeof(KDEVICE_QUEUE))

    //
    // Device object entry structure definitions.
    //

    genCom("Device Queue Entry Structure Offset Definitions")

    genDef(De, KDEVICE_QUEUE_ENTRY, DeviceListEntry)
    genDef(De, KDEVICE_QUEUE_ENTRY, SortKey)
    genDef(De, KDEVICE_QUEUE_ENTRY, Inserted)
    genVal(DeviceQueueEntryLength, sizeof(KDEVICE_QUEUE_ENTRY))

    //
    // Event object structure definitions.
    //

    genCom("Event Object Structure Offset Definitions")

    genDef(Ev, DISPATCHER_HEADER, Type)
    genDef(Ev, DISPATCHER_HEADER, Size)
    genDef(Ev, DISPATCHER_HEADER, SignalState)
    genAlt(EvWaitListHead, KEVENT, Header.WaitListHead)
    genVal(EventObjectLength, sizeof(KEVENT))

    //
    // Interrupt object structure definitions.
    //

    genCom("Interrupt Object Structure Offset Definitions")

    genVal(InLevelSensitive, LevelSensitive)
    genVal(InLatched, Latched)

    genSpc()

    genDef(In, KINTERRUPT, ServiceRoutine)
    genDef(In, KINTERRUPT, ServiceContext)
    genDef(In, KINTERRUPT, BusInterruptLevel)
    genDef(In, KINTERRUPT, Irql)
    genDef(In, KINTERRUPT, Connected)
    genDef(In, KINTERRUPT, Mode)
    genDef(In, KINTERRUPT, ShareVector)
    genDef(In, KINTERRUPT, DispatchCode)
    genVal(InterruptObjectLength, sizeof(KINTERRUPT))

#if defined(_X86_)

    genSpc()

    genVal(NORMAL_DISPATCH_LENGTH, NORMAL_DISPATCH_LENGTH * sizeof(ULONG))
    genVal(DISPATCH_LENGTH, DISPATCH_LENGTH * sizeof(ULONG))

#endif

    //
    // Process object structure offset definitions.
    //

    genCom("Process Object Structure Offset Definitions")

    genDef(Pr, DISPATCHER_HEADER, Type)
    genDef(Pr, DISPATCHER_HEADER, Size)
    genDef(Pr, DISPATCHER_HEADER, SignalState)

    genDef(Pr, KPROCESS, ReadyListHead)
    genDef(Pr, KPROCESS, ThreadListHead)
    genDef(Pr, KPROCESS, StackCount)
    genDef(Pr, KPROCESS, BasePriority)
    genDef(Pr, KPROCESS, ThreadQuantum)
    genVal(ProcessObjectLength, ((sizeof(KPROCESS) + 15) & ~15))

    //
    // Queue object structure offset definitions.
    //

    genCom("Queue Object Structure Offset Definitions")

    genDef(Qu, DISPATCHER_HEADER, Type)
    genDef(Qu, DISPATCHER_HEADER, Size)
    genDef(Qu, DISPATCHER_HEADER, SignalState)
    genDef(Qu, KQUEUE, EntryListHead)
    genDef(Qu, KQUEUE, CurrentCount)
    genDef(Qu, KQUEUE, MaximumCount)
    genDef(Qu, KQUEUE, ThreadListHead)
    genVal(QueueObjectLength, sizeof(KQUEUE))

    //
    // Thread object structure offset definitions
    //

    genCom("Thread Object Structure Offset Definitions")

    genDef(Et, ETHREAD, UniqueThread)
    genVal(EtEthreadLength, ((sizeof(ETHREAD) + 15) & ~15))

    genSpc()

    genDef(Th, DISPATCHER_HEADER, Type)
    genDef(Th, DISPATCHER_HEADER, Size)
    genDef(Th, DISPATCHER_HEADER, SignalState)
    genDef(Th, KTHREAD, MutantListHead)
    genDef(Th, KTHREAD, KernelTime)
    genDef(Th, KTHREAD, StackBase)
    genDef(Th, KTHREAD, StackLimit)
    genDef(Th, KTHREAD, KernelStack)
    genDef(Th, KTHREAD, TlsData)
    genDef(Th, KTHREAD, State)
    genDef(Th, KTHREAD, Alerted)
    genDef(Th, KTHREAD, Alertable)
    genDef(Th, KTHREAD, NpxState)
    genDef(Th, KTHREAD, Saturation)
    genDef(Th, KTHREAD, Priority)
    genDef(Th, KTHREAD, ApcState)
    genDef(Th, KTHREAD, ContextSwitches)
    genDef(Th, KTHREAD, WaitStatus)
    genDef(Th, KTHREAD, WaitIrql)
    genDef(Th, KTHREAD, WaitMode)
    genDef(Th, KTHREAD, WaitNext)
    genDef(Th, KTHREAD, WaitReason)
    genDef(Th, KTHREAD, WaitBlockList)
    genDef(Th, KTHREAD, WaitListEntry)
    genDef(Th, KTHREAD, WaitTime)
    genDef(Th, KTHREAD, KernelApcDisable)
    genDef(Th, KTHREAD, Quantum)
    genDef(Th, KTHREAD, BasePriority)
    genDef(Th, KTHREAD, DecrementCount)
    genDef(Th, KTHREAD, PriorityDecrement)
    genDef(Th, KTHREAD, DisableBoost)
    genDef(Th, KTHREAD, NpxIrql)
    genDef(Th, KTHREAD, SuspendCount)
    genDef(Th, KTHREAD, Preempted)
    genDef(TH, KTHREAD, HasTerminated)
    genDef(Th, KTHREAD, Queue)
    genDef(Th, KTHREAD, QueueListEntry)
    genDef(Th, KTHREAD, Timer)
    genDef(Th, KTHREAD, TimerWaitBlock)
    genDef(Th, KTHREAD, SuspendApc)
    genDef(Th, KTHREAD, SuspendSemaphore)
    genDef(Th, KTHREAD, ThreadListEntry)

    genVal(ThreadObjectLength, ((sizeof(KTHREAD) + 15) & ~15))
    genVal(ExtendedThreadObjectLength, ((sizeof(ETHREAD) + 15) & ~15))

    genSpc()

#if defined(_X86_)

    genVal(NPX_STATE_NOT_LOADED, NPX_STATE_NOT_LOADED)
    genVal(NPX_STATE_LOADED, NPX_STATE_LOADED)

#endif

    //
    // Timer object structure offset definitions
    //

    genCom("Timer object Structure Offset Definitions")

    genDef(Ti, DISPATCHER_HEADER, Type)
    genDef(Ti, DISPATCHER_HEADER, Size)
    genDef(Ti, DISPATCHER_HEADER, Inserted)
    genDef(Ti, DISPATCHER_HEADER, SignalState)
    genDef(Ti, KTIMER, DueTime)
    genDef(Ti, KTIMER, TimerListEntry)
    genDef(Ti, KTIMER, Dpc)
    genDef(Ti, KTIMER, Period)
    genVal(TimerObjectLength, sizeof(KTIMER))

    genSpc()

    genVal(TIMER_TABLE_SIZE, TIMER_TABLE_SIZE)

    //
    // Wait block structure offset definitions
    //

    genCom("Wait Block Structure Offset Definitions")

    genDef(Wb, KWAIT_BLOCK, WaitListEntry)
    genDef(Wb, KWAIT_BLOCK, Thread)
    genDef(Wb, KWAIT_BLOCK, Object)
    genDef(Wb, KWAIT_BLOCK, NextWaitBlock)
    genDef(Wb, KWAIT_BLOCK, WaitKey)
    genDef(Wb, KWAIT_BLOCK, WaitType)

    //
    // Wait block structure offset definitions
    //

    genCom("Reader/Writer Lock Structure Offset Definitions")

    genDef(Erw, ERWLOCK, LockCount)
    genDef(Erw, ERWLOCK, WritersWaitingCount)
    genDef(Erw, ERWLOCK, ReadersWaitingCount)
    genDef(Erw, ERWLOCK, ReadersEntryCount)
    genDef(Erw, ERWLOCK, WriterEvent)
    genDef(Erw, ERWLOCK, ReaderSemaphore)

    //
    // Common TEB structure offset definitions
    //

    genCom("Thread Environment Block Structure Offset Definitions")

    genDef(Te, NT_TIB, StackBase)
    genDef(Te, NT_TIB, StackLimit)
    genDef(Te, NT_TIB, FiberData)

    genVal(EVENT_INCREMENT,EVENT_INCREMENT)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\kiinit.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kiinit.c

Abstract:

    This module implements architecture independent kernel initialization.

Author:

    David N. Cutler 11-May-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiInitSystem (
    VOID
    )
/*++

Routine Description:

    This function initializes architecture independent kernel structures.

Arguments:

    None.

Return Value:

    None.

--*/
{

    ULONG Index;

    //
    // Initialize dispatcher ready queue listheads.
    //

    for (Index = 0; Index < MAXIMUM_PRIORITY; Index += 1) {
        InitializeListHead(&KiDispatcherReadyListHead[Index]);
    }

    //
    // Initialize the timer expiration DPC object.
    //

    KeInitializeDpc(&KiTimerExpireDpc,
                    (PKDEFERRED_ROUTINE)KiTimerExpiration, NIL);

    //
    // Initialize the timer table, the timer completion listhead, and the
    // timer completion DPC.
    //

    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
        InitializeListHead(&KiTimerTableListHead[Index]);
    }

    //
    // Initialize the wait listhead.
    //

    InitializeListHead(&KiWaitInListHead);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\mutntobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mutntobj.c

Abstract:

    This module implements the kernel mutant object. Functions are
    provided to initialize, read, and release mutant objects.

    N.B. Kernel mutex objects have been subsumed by mutant objects.

Author:

    David N. Cutler (davec) 16-Oct-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input mutant is
// really a kmutant and not something else, like deallocated pool.
//

#define ASSERT_MUTANT(E) {                    \
    ASSERT((E)->Header.Type == MutantObject); \
}

VOID
KeInitializeMutant (
    IN PRKMUTANT Mutant,
    IN BOOLEAN InitialOwner
    )

/*++

Routine Description:

    This function initializes a kernel mutant object.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    InitialOwner - Supplies a boolean value that determines whether the
        current thread is to be the initial owner of the mutant object.

Return Value:

    None.

--*/

{

    PLIST_ENTRY ListEntry;
    KIRQL OldIrql;
    PRKTHREAD Thread;

    //
    // Initialize standard dispatcher object header, set the owner thread to
    // NULL, set the abandoned state to FALSE, and set the APC disable count
    // to zero (this is the only thing that distinguishes a mutex from a mutant).
    //

    Mutant->Header.Type = MutantObject;
    Mutant->Header.Size = sizeof(KMUTANT) / sizeof(LONG);
    if (InitialOwner == TRUE) {
        Thread = KeGetCurrentThread();
        Mutant->Header.SignalState = 0;
        Mutant->OwnerThread = Thread;
        KiLockDispatcherDatabase(&OldIrql);
        ListEntry = Thread->MutantListHead.Blink;
        InsertHeadList(ListEntry, &Mutant->MutantListEntry);
        KiUnlockDispatcherDatabase(OldIrql);

    } else {
        Mutant->Header.SignalState = 1;
        Mutant->OwnerThread = (PKTHREAD)NULL;
    }

    InitializeListHead(&Mutant->Header.WaitListHead);
    Mutant->Abandoned = FALSE;
    return;
}

LONG
KeReleaseMutant (
    IN PRKMUTANT Mutant,
    IN KPRIORITY Increment,
    IN BOOLEAN Abandoned,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a mutant object by incrementing the mutant
    count. If the resultant value is one, then an attempt is made to
    satisfy as many Waits as possible. The previous signal state of
    the mutant is returned as the function value. If the Abandoned
    parameter is TRUE, then the mutant object is released by settings
    the signal state to one.

Arguments:

    Mutant - Supplies a pointer to a dispatcher object of type mutant.

    Increment - Supplies the priority increment that is to be applied
        if setting the event causes a Wait to be satisfied.

    Abandoned - Supplies a boolean value that signifies whether the
        mutant object is being abandoned.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseMutant will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the mutant object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;


    ASSERT_MUTANT(Mutant);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the mutant object.
    //

    OldState = Mutant->Header.SignalState;

    //
    // If the Abandoned parameter is TRUE, then force the release of the
    // mutant object by setting its ownership count to one and setting its
    // abandoned state to TRUE. Otherwise increment mutant ownership count.
    // If the result count is one, then remove the mutant object from the
    // thread's owned mutant list, set the owner thread to NULL, and attempt
    // to satisfy a Wait for the mutant object if the mutant object wait
    // list is not empty.
    //

    Thread = KeGetCurrentThread();
    if (Abandoned != FALSE) {
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;

    } else {

        //
        // If the Mutant object is not owned by the current thread, then
        // unlock the dispatcher data base and raise an exception. Otherwise
        // increment the ownership count.
        //

        if (Mutant->OwnerThread != Thread) {
            KiUnlockDispatcherDatabase(OldIrql);
            ExRaiseStatus(Mutant->Abandoned ?
                          STATUS_ABANDONED : STATUS_MUTANT_NOT_OWNED);
        }

        Mutant->Header.SignalState += 1;
    }

    if (Mutant->Header.SignalState == 1) {
        if (OldState <= 0) {
            RemoveEntryList(&Mutant->MutantListEntry);
        }

        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) == FALSE) {
            KiWaitTest(Mutant, Increment);
        }
    }

    //
    // If the value of the Wait argument is TRUE, then return to
    // caller with IRQL raised and the dispatcher database locked.
    // Else release the dispatcher database lock and lower IRQL to
    // its previous value.
    //

    if (Wait != FALSE) {
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of mutant object.
    //

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\procobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    procobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel process object. Functions are provided to initialize, attach,
    detach, exclude, include, and set the base priority of process objects.

Author:

    David N. Cutler (davec) 7-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KeInitializeProcess (
    IN PRKPROCESS Process,
    IN KPRIORITY BasePriority
    )

/*++

Routine Description:

    This function initializes a kernel process object. The base priority,
    affinity, and page frame numbers for the process page table directory
    and hyper space are stored in the process object.

    N.B. It is assumed that the process object is zeroed.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    BasePriority - Supplies the base priority of the process.

Return Value:

    None.

--*/

{

    //
    // Initialize the base priority.
    //

    Process->BasePriority = (SCHAR)BasePriority;

    //
    // Initialize the stack count, profile listhead, ready queue list head,
    // accumulated runtime, process quantum, thread quantum, and thread list
    // head.
    //

    InitializeListHead(&Process->ReadyListHead);
    InitializeListHead(&Process->ThreadListHead);
    Process->ThreadQuantum = THREAD_QUANTUM;

    return;
}

KPRIORITY
KeSetPriorityProcess (
    IN PKPROCESS Process,
    IN KPRIORITY NewBase
    )

/*++

Routine Description:

    This function set the base priority of a process to a new value
    and adjusts the priority and base priority of all child threads
    as appropriate.

Arguments:

    Process - Supplies a pointer to a dispatcher object of type process.

    NewBase - Supplies the new base priority of the process.

Return Value:

    The previous base priority of the process.

--*/

{

    KPRIORITY Adjustment;
    PLIST_ENTRY NextEntry;
    KPRIORITY NewPriority;
    KIRQL OldIrql;
    KPRIORITY OldBase;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Save the current process base priority, set the new process base
    // priority, compute the adjustment value, and adjust the priority
    // and base priority of all child threads as appropriate.
    //

    OldBase = Process->BasePriority;
    Process->BasePriority = (SCHAR)NewBase;
    Adjustment = NewBase - OldBase;
    NextEntry = Process->ThreadListHead.Flink;
    if (NewBase >= LOW_REALTIME_PRIORITY) {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // Compute the new base priority of the thread.
            //

            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the realtime class,
            // then limit the change to the realtime class.
            //

            if (NewPriority < LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY;

            } else if (NewPriority > HIGH_PRIORITY) {
                NewPriority = HIGH_PRIORITY;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the appropriate value.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from variable to realtime, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase < LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = HIGH_PRIORITY;

                } else if (Thread->Saturation < 0) {
                    NewPriority = LOW_REALTIME_PRIORITY;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Process->ThreadQuantum;
                Thread->DecrementCount = 0;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            NextEntry = NextEntry->Flink;
        }

    } else {
        while (NextEntry != &Process->ThreadListHead) {
            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, ThreadListEntry);

            //
            // Compute the new base priority of the thread.
            //

            NewPriority = Thread->BasePriority + Adjustment;

            //
            // If the new base priority is outside the variable class,
            // then limit the change to the variable class.
            //

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;

            } else if (NewPriority <= LOW_PRIORITY) {
                NewPriority = 1;
            }

            //
            // Set the base priority and the current priority of the
            // thread to the computed value and reset the thread quantum.
            //
            // N.B. If priority saturation occured the last time the thread
            //      base priority was set and the new process base priority
            //      is not crossing from realtime to variable, then it is not
            //      necessary to change the thread priority.
            //

            if ((Thread->Saturation == 0) || (OldBase >= LOW_REALTIME_PRIORITY)) {
                if (Thread->Saturation > 0) {
                    NewPriority = LOW_REALTIME_PRIORITY - 1;

                } else if (Thread->Saturation < 0) {
                    NewPriority = 1;
                }

                Thread->BasePriority = (SCHAR)NewPriority;
                Thread->Quantum = Process->ThreadQuantum;
                Thread->DecrementCount = 0;
                Thread->PriorityDecrement = 0;
                KiSetPriorityThread(Thread, NewPriority);
            }

            NextEntry = NextEntry->Flink;
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous process base priority
    //

    return OldBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\miscc.c ===
/*++

Copyright (c) 1989-1992  Microsoft Corporation

Module Name:

    miscc.c

Abstract:

    This module implements machine independent miscellaneous kernel functions.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#undef KeEnterCriticalRegion
VOID
KeEnterCriticalRegion (
   VOID
   )

/*++

Routine Description:

   This function disables kernel APC's.

   N.B. The following code does not require any interlocks. There are
        two cases of interest: 1) On an MP system, the thread cannot
        be running on two processors as once, and 2) if the thread is
        is interrupted to deliver a kernel mode APC which also calls
        this routine, the values read and stored will stack and unstack
        properly.

Arguments:

   None.

Return Value:

   None.

--*/

{
    //
    // Simply directly disable kernel APCs.
    //

    KeGetCurrentThread()->KernelApcDisable -= 1;
}

#undef KeLeaveCriticalRegion
VOID
KeLeaveCriticalRegion (
    VOID
    )

/*++

Routine Description:

    This function enables kernel APC's and requests an APC interrupt if
    appropriate.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Increment the kernel APC disable count. If the resultant count is
    // zero and the thread's kernel APC List is not empty, then request an
    // APC interrupt.
    //
    // For multiprocessor performance, the following code utilizes the fact
    // that queuing an APC is done by first queuing the APC, then checking
    // the AST disable count. The following code increments the disable
    // count first, checks to determine if it is zero, and then checks the
    // kernel AST queue.
    //
    // See also KiInsertQueueApc().
    //

    KiLeaveCriticalRegion();
}

ULONGLONG
KeQueryInterruptTime (
    VOID
    )

/*++

Routine Description:

    This function returns the current interrupt time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{
    LARGE_INTEGER CurrentTime;

    KiQueryInterruptTime(&CurrentTime);
    return CurrentTime.QuadPart;
}

VOID
KeQuerySystemTime (
    OUT PLARGE_INTEGER CurrentTime
    )

/*++

Routine Description:

    This function returns the current system time by determining when the
    time is stable and then returning its value.

Arguments:

    CurrentTime - Supplies a pointer to a variable that will receive the
        current system time.

Return Value:

    None.

--*/

{
    LARGE_INTEGER StackCurrentTime;

    KiQuerySystemTime(&StackCurrentTime);
    *CurrentTime = StackCurrentTime;
}

VOID
KeSetSystemTime (
    IN PLARGE_INTEGER NewTime,
    OUT PLARGE_INTEGER OldTime
    )

/*++

Routine Description:

    This function sets the system time to the specified value and updates
    timer queue entries to reflect the difference between the old system
    time and the new system time.

Arguments:

    NewTime - Supplies a pointer to a variable that specifies the new system
        time.

    OldTime - Supplies a pointer to a variable that will receive the previous
        system time.

Return Value:

    None.

--*/

{

    LIST_ENTRY AbsoluteListHead;
    LIST_ENTRY ExpiredListHead;
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql1;
    KIRQL OldIrql2;
    LARGE_INTEGER TimeDelta;
    PKTIMER Timer;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Set affinity to the processor that keeps the system time, raise IRQL
    // to dispatcher level and lock the dispatcher database, then raise IRQL
    // to HIGH_LEVEL to synchronize with the clock interrupt routine.
    //

    KiLockDispatcherDatabase(&OldIrql1);
    KeRaiseIrql(HIGH_LEVEL, &OldIrql2);

    //
    // Save the previous system time, set the new system time, and set
    // the realtime clock, if a time value is specified.
    //

    KiQuerySystemTime(OldTime);

    KeSystemTime.High2Time = NewTime->HighPart;
    KeSystemTime.LowPart   = NewTime->LowPart;
    KeSystemTime.High1Time = NewTime->HighPart;

    //
    // Compute the difference between the previous system time and the new
    // system time.
    //

    TimeDelta.QuadPart = NewTime->QuadPart - OldTime->QuadPart;

    //
    // Update the boot time to reflect the delta. This keeps time based
    // on boot time constant
    //

    KeBootTime.QuadPart = KeBootTime.QuadPart + TimeDelta.QuadPart;

    //
    // Track the overall bias applied to the boot time.
    //

    KeBootTimeBias = KeBootTimeBias + TimeDelta.QuadPart;

    //
    // Lower IRQL to dispatch level and if needed adjust the physical
    // system interrupt time.
    //

    KeLowerIrql(OldIrql2);

    //
    // Remove all absolute timers from the timer queue so their due time
    // can be recomputed.
    //

    InitializeListHead(&AbsoluteListHead);
    for (Index = 0; Index < TIMER_TABLE_SIZE; Index += 1) {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            NextEntry = NextEntry->Flink;
            if (Timer->Header.Absolute != FALSE) {
                RemoveEntryList(&Timer->TimerListEntry);
                InsertTailList(&AbsoluteListHead, &Timer->TimerListEntry);
            }
        }
    }

    //
    // Recompute the due time and reinsert all absolute timers in the timer
    // tree. If a timer has already expired, then insert the timer in the
    // expired timer list.
    //

    InitializeListHead(&ExpiredListHead);
    while (AbsoluteListHead.Flink != &AbsoluteListHead) {
        Timer = CONTAINING_RECORD(AbsoluteListHead.Flink, KTIMER, TimerListEntry);
        KiRemoveTreeTimer(Timer);
        Timer->DueTime.QuadPart -= TimeDelta.QuadPart;
        if (KiReinsertTreeTimer(Timer, Timer->DueTime) == FALSE) {
            Timer->Header.Inserted = TRUE;
            InsertTailList(&ExpiredListHead, &Timer->TimerListEntry);
        }
    }

    //
    // If any of the attempts to reinsert a timer failed, then timers have
    // already expired and must be processed.
    //
    // N.B. The following function returns with the dispatcher database
    //      unlocked.
    //

    KiTimerListExpire(&ExpiredListHead, OldIrql1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\queueobj.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    queueobj.c

Abstract:

    This module implements the kernel queue object. Functions are
    provided to initialize, read, insert, and remove queue objects.

Author:

    David N. Cutler (davec) 31-Dec-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input event is
// really a kernel event and not something else, like deallocated pool.
//

#define ASSERT_QUEUE(Q) ASSERT((Q)->Header.Type == QueueObject);

VOID
KeInitializeQueue (
    IN PRKQUEUE Queue,
    IN ULONG Count OPTIONAL
    )

/*++

Routine Description:

    This function initializes a kernel queue object.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

    Count - Supplies the target maximum number of threads that should
        be concurrently active. If this parameter is not specified,
        then the number of processors is used.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // state of queue object.
    //

    Queue->Header.Type = QueueObject;
    Queue->Header.Size = sizeof(KQUEUE) / sizeof(LONG);
    Queue->Header.SignalState = 0;
    InitializeListHead(&Queue->Header.WaitListHead);

    //
    // Initialize queue listhead, the thread list head, the current number
    // of threads, and the target maximum number of threads.
    //

    InitializeListHead(&Queue->EntryListHead);
    InitializeListHead(&Queue->ThreadListHead);
    Queue->CurrentCount = 0;
    if (ARGUMENT_PRESENT((PVOID)(ULONG_PTR)Count)) {
        Queue->MaximumCount = Count;

    } else {
        Queue->MaximumCount = 1;
    }

    return;
}

LONG
KeInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, FALSE);

    //
    // Unlock the dispather database, lower IRQL to the previous level, and
    // return signal state of Queue object.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldState;
}

LONG
KeInsertHeadQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    KIRQL OldIrql;
    LONG OldState;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Insert the specified entry in the queue object entry list.
    //

    OldState = KiInsertQueue(Queue, Entry, TRUE);

    //
    // Unlock the dispather database, lower IRQL to the previous level, and
    // return signal state of Queue object.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return OldState;
}

PLIST_ENTRY
KeRemoveQueue (
    IN PRKQUEUE Queue,
    IN KPROCESSOR_MODE WaitMode,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function removes the next entry from the Queue object entry
    list. If no list entry is available, then the calling thread is
    put in a wait state.

    N.B. The wait discipline for Queue object LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The address of the entry removed from the Queue object entry list or
    STATUS_TIMEOUT.

    N.B. These values can easily be distinguished by the fact that all
         addresses in kernel mode have the high order bit set.

--*/

{

    LARGE_INTEGER DueTime;
    PLIST_ENTRY Entry;
    LARGE_INTEGER NewTime;
    KIRQL OldIrql;
    PRKQUEUE OldQueue;
    PLARGE_INTEGER OriginalTime;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    KWAIT_BLOCK StackWaitBlock;
    PRKWAIT_BLOCK WaitBlock;
    LONG_PTR WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&OldIrql);
        Thread->WaitIrql = OldIrql;
    }

    //
    // Check if the thread is currently processing a queue entry and whether
    // the new queue is the same as the old queue.
    //

    OldQueue = Thread->Queue;
    Thread->Queue = Queue;
    if (Queue != OldQueue) {

        //
        // If the thread was previously associated with a queue, then remove
        // the thread from the old queue object thread list and attempt to
        // activate another thread.
        //

        Entry = &Thread->QueueListEntry;
        if (OldQueue != NULL) {
            RemoveEntryList(Entry);
            KiActivateWaiterQueue(OldQueue);
        }

        //
        // Insert thread in the thread list of the new queue that the thread
        // will be associate with.
        //

        InsertTailList(&Queue->ThreadListHead, Entry);

    } else {

        //
        // The previous and current queue are the same queue - decrement the
        // current number of threads.
        //

        Queue->CurrentCount -= 1;
    }

    //
    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the
    // middle of the wait or a kernel APC is pending on the first attempt
    // through the loop.
    //
    // If the Queue object entry list is not empty, then remove the next
    // entry from the Queue object entry list. Otherwise, wait for an entry
    // to be inserted in the queue.
    //

    OriginalTime = Timeout;
    WaitBlock = &StackWaitBlock;
    do {

        //
        // Check if there is a queue entry available and the current
        // number of active threads is less than target maximum number
        // of threads.
        //

        Entry = Queue->EntryListHead.Flink;
        if ((Entry != &Queue->EntryListHead) &&
            (Queue->CurrentCount < Queue->MaximumCount)) {

            //
            // Decrement the number of entires in the Queue object entry list,
            // increment the number of active threads, remove the next entry
            // rom the list, and set the forward link to NULL.
            //

            Queue->Header.SignalState -= 1;
            Queue->CurrentCount += 1;

            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            break;

        } else {

            //
            // Test to determine if a kernel APC is pending.
            //
            // If a kernel APC is pending and the previous IRQL was less than
            // APC_LEVEL, then a kernel APC was queued by another processor
            // just after IRQL was raised to DISPATCH_LEVEL, but before the
            // dispatcher database was locked.
            //
            // N.B. that this can only happen in a multiprocessor system.
            //

            if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

                //
                // Increment the current thread count, unlock the dispatcher
                // database, and lower IRQL to previous value. An APC interrupt
                // will immediately occur which will result in the delivery of
                // the kernel APC if possible.
                //

                Queue->CurrentCount += 1;
                KiUnlockDispatcherDatabase(Thread->WaitIrql);

            } else {

                //
                // Test if a user APC is pending.
                //

                if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) {
                    Entry = (PLIST_ENTRY)ULongToPtr(STATUS_USER_APC);
                    Queue->CurrentCount += 1;
                    break;
                }

                //
                // Construct a wait block and check to determine if the wait
                // is already satisfied. If the wait is satisfied, then perform
                // wait completion and return. Else put current thread in a
                // wait state if an explicit timeout value of zero is not
                // specified.
                //

                Thread->WaitStatus = (NTSTATUS)0;
                Thread->WaitBlockList = WaitBlock;
                WaitBlock->Object = (PVOID)Queue;
                WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);
                WaitBlock->WaitType = WaitAny;
                WaitBlock->Thread = Thread;

                //
                // Check to determine if a timeout value is specified.
                //

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // If the timeout value is zero, then return immediately
                    // without waiting.
                    //

                    if (!(Timeout->LowPart | Timeout->HighPart)) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }

                    //
                    // Initialize a wait block for the thread specific timer,
                    // insert wait block in timer wait list, insert the timer
                    // in the timer tree.
                    //
                    // N.B. The timer wait block is initialized when the
                    //      respective thread is initialized. Thus the constant
                    //      fields are not reinitialized. These include the wait
                    //      object, wait key, wait type, and the wait list entry
                    //      link pointers.
                    //

                    Timer = &Thread->Timer;
                    WaitTimer = &Thread->TimerWaitBlock;
                    WaitBlock->NextWaitBlock = WaitTimer;
                    Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;
                    Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;
                    WaitTimer->NextWaitBlock = WaitBlock;
                    if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                        Entry = (PLIST_ENTRY)ULongToPtr(STATUS_TIMEOUT);
                        Queue->CurrentCount += 1;
                        break;
                    }

                    DueTime.QuadPart = Timer->DueTime.QuadPart;

                } else {
                    WaitBlock->NextWaitBlock = WaitBlock;
                }

                //
                // Insert wait block in object wait list.
                //

                InsertTailList(&Queue->Header.WaitListHead, &WaitBlock->WaitListEntry);

                //
                // Set the thread wait parameters, set the thread dispatcher
                // state to Waiting, and insert the thread in the wait list.
                //

                Thread->Alertable = FALSE;
                Thread->WaitMode = WaitMode;
                Thread->WaitReason = WrQueue;
                Thread->WaitTime = KiQueryLowTickCount();
                Thread->State = Waiting;
                KiInsertWaitList(WaitMode, Thread);

                //
                // Switch context to selected thread.
                //
                // Control is returned at the original IRQL.
                //

                ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                WaitStatus = KiSwapThread();

                //
                // If the thread was not awakened to deliver a kernel mode APC,
                // then return wait status.
                //

                Thread->WaitReason = 0;
                if (WaitStatus != STATUS_KERNEL_APC) {
                    return (PLIST_ENTRY)WaitStatus;
                }

                if (ARGUMENT_PRESENT(Timeout)) {

                    //
                    // Reduce the amount of time remaining before timeout occurs.
                    //

                    Timeout = KiComputeWaitInterval(OriginalTime,
                                                    &DueTime,
                                                    &NewTime);
                }
            }

            //
            // Raise IRQL to DISPATCH_LEVEL, lock the dispatcher database,
            // and decrement the count of active threads.
            //

            KiLockDispatcherDatabase(&OldIrql);
            Thread->WaitIrql = OldIrql;
            Queue->CurrentCount -= 1;
        }

    } while (TRUE);

    //
    // Unlock the dispatcher database and return the list entry address or a
    // status of timeout.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return Entry;
}

PLIST_ENTRY
KeRundownQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function runs down the specified queue by removing the listhead
    from the queue list, removing any associated threads from the thread
    list, and returning the address of the first entry.


Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

Return Value:

    If the queue list is not empty, then the address of the first entry in
    the queue is returned as the function value. Otherwise, a value of NULL
    is returned.

--*/

{

    PLIST_ENTRY Entry;
    PLIST_ENTRY FirstEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT_QUEUE(Queue);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatch level and lock the dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Get the address of the first entry in the queue and check if the
    // list is empty or contains entries that should be flushed. If there
    // are no entries in the list, then set the return value to NULL.
    // Otherwise, set the return value to the address of the first list
    // entry and remove the listhead from the list.
    //

    FirstEntry = Queue->EntryListHead.Flink;
    if (FirstEntry == &Queue->EntryListHead) {
        FirstEntry = NULL;

    } else {
        RemoveEntryList(&Queue->EntryListHead);
    }

    //
    // Remove all associated threads from the thread list of the queue.
    //

    while (Queue->ThreadListHead.Flink != &Queue->ThreadListHead) {
        Entry = Queue->ThreadListHead.Flink;
        Thread = CONTAINING_RECORD(Entry, KTHREAD, QueueListEntry);
        Thread->Queue = NULL;
        RemoveEntryList(Entry);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous level,
    // and return the function value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return FirstEntry;
}

VOID
FASTCALL
KiActivateWaiterQueue (
    IN PRKQUEUE Queue
    )

/*++

Routine Description:

    This function is called when the current thread is about to enter a
    wait state and is currently processing a queue entry. The current
    number of threads processign entries for the queue is decrement and
    an attempt is made to activate another thread if the current count
    is less than the maximum count, there is a waiting thread, and the
    queue is not empty.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type event.

Return Value:

    None.

--*/

{

    PRLIST_ENTRY Entry;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PRLIST_ENTRY WaitEntry;

    //
    // Decrement the current count of active threads and check if another
    // thread can be activated. If the current number of active threads is
    // less than the target maximum number of threads, there is a entry in
    // in the queue, and a thread is waiting, then remove the entry from the
    // queue, decrement the number of entries in the queue, and unwait the
    // respectiive thread.
    //

    Queue->CurrentCount -= 1;
    if (Queue->CurrentCount < Queue->MaximumCount) {
        Entry = Queue->EntryListHead.Flink;
        WaitEntry = Queue->Header.WaitListHead.Blink;
        if ((Entry != &Queue->EntryListHead) &&
            (WaitEntry != &Queue->Header.WaitListHead)) {
            RemoveEntryList(Entry);
            Entry->Flink = NULL;
            Queue->Header.SignalState -= 1;
            WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
            Thread = WaitBlock->Thread;
            KiUnwaitThread(Thread, (LONG_PTR)Entry, 0);
        }
    }

    return;
}

LONG
FASTCALL
KiInsertQueue (
    IN PRKQUEUE Queue,
    IN PLIST_ENTRY Entry,
    IN BOOLEAN Head
    )

/*++

Routine Description:

    This function inserts the specified entry in the queue object entry
    list and attempts to satisfy the wait of a single waiter.

    N.B. The wait discipline for Queue object is LIFO.

Arguments:

    Queue - Supplies a pointer to a dispatcher object of type Queue.

    Entry - Supplies a pointer to a list entry that is inserted in the
        queue object entry list.

    Head - Supplies a boolean value that determines whether the queue
        entry is inserted at the head or tail of the queue if it can
        not be immediately dispatched.

Return Value:

    The previous signal state of the Queue object.

--*/

{

    LONG OldState;
    PRKTHREAD Thread;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    ASSERT_QUEUE(Queue);

    //
    // Capture the current signal state of queue object and check if there
    // is a thread waiting on the queue object, the current number of active
    // threads is less than the target number of threads, and the wait reason
    // of the current thread is not queue wait or the wait queue is not the
    // same queue as the insertion queue. If these conditions are satisfied,
    // then satisfy the thread wait and pass the thread the address of the
    // queue entry as the wait status. Otherwise, set the state of the queue
    // object to signaled and insert the specified entry in the queue object
    // entry list.
    //

    OldState = Queue->Header.SignalState;
    Thread = KeGetCurrentThread();
    WaitEntry = Queue->Header.WaitListHead.Blink;
    if ((WaitEntry != &Queue->Header.WaitListHead) &&
        (Queue->CurrentCount < Queue->MaximumCount) &&
        ((Thread->Queue != Queue) ||
        (Thread->WaitReason != WrQueue))) {

        //
        // Remove the last wait block from the wait list and get the address
        // of the waiting thread object.
        //

        RemoveEntryList(WaitEntry);
        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;

        //
        // Set the wait completion status, remove the thread from its wait
        // list, increment the number of active threads, and clear the wait
        // reason.
        //

        Thread->WaitStatus = (LONG_PTR)Entry;
        RemoveEntryList(&Thread->WaitListEntry);
        Queue->CurrentCount += 1;
        Thread->WaitReason = 0;

        //
        // If thread timer is still active, then cancel thread timer.
        //

        Timer = &Thread->Timer;
        if (Timer->Header.Inserted == TRUE) {
            KiRemoveTreeTimer(Timer);
        }

        //
        // Ready the thread for execution.
        //

        KiReadyThread(Thread);

    } else {
        Queue->Header.SignalState += 1;
        if (Head != FALSE) {
            InsertHeadList(&Queue->EntryListHead, Entry);

        } else {
            InsertTailList(&Queue->EntryListHead, Entry);
        }
    }

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\raisexcp.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    raisexcp.c

Abstract:

    This module implements the internal kernel code to continue execution
    and raise a exception.

Author:

    David N. Cutler (davec) 8-Aug-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

NTSTATUS
KiContinue (
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to copy the specified context frame to the
    specified exception and trap frames for the continue system service.

Arguments:

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if the context record is not readable
        from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the context record is not
        properly aligned.

    STATUS_SUCCESS is returned if the context frame is copied successfully
        to the specified exception and trap frames.

--*/

{
    KIRQL OldIrql;
    BOOLEAN IrqlChanged = FALSE;

    //
    // Synchronize with other context operations.
    //

    if (KeGetCurrentIrql() < APC_LEVEL) {

        //
        // To support try-except and ExRaiseStatus in device driver code we
        // need to check if we are already at raised level.
        //

        IrqlChanged = TRUE;
        KeRaiseIrql(APC_LEVEL, &OldIrql);
    }

    //
    // Move information from the context record to the exception
    // and trap frames.
    //

    KeContextToKframes(TrapFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags);

    if (IrqlChanged) {
        KeLowerIrql (OldIrql);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
KiRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to raise an exception. The exception can be
    raised as a first or second chance exception.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ContextRecord - Supplies a pointer to a context record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    STATUS_ACCESS_VIOLATION is returned if either the exception or the context
        record is not readable from user mode.

    STATUS_DATATYPE_MISALIGNMENT is returned if the exception record or the
        context record are not properly aligned.

    STATUS_INVALID_PARAMETER is returned if the number of exception parameters
        is greater than the maximum allowable number of exception parameters.

    STATUS_SUCCESS is returned if the exception is dispatched and handled.

--*/

{

    //
    // Move information from the context record to the exception and
    // trap frames.
    //

    KeContextToKframes(TrapFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags);

    //
    // Make sure the reserved bit is clear in the exception code and
    // perform exception dispatching.
    //
    // N.B. The reserved bit is used to differentiate internally gerarated
    //      codes from codes generated by application programs.
    //

    ExceptionRecord->ExceptionCode &= 0xefffffff;
    KiDispatchException(ExceptionRecord,
                        ExceptionFrame,
                        TrapFrame,
                        FirstChance);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=ke

TARGETNAME=ke
TARGETTYPE=LIBRARY

INCLUDES=..;$(BASEDIR)\private\ntos\inc;..\..\halx

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

SOURCES=..\apcobj.c   \
        ..\apcsup.c   \
        ..\bugcheck.c \
        ..\devquobj.c \
        ..\dpcobj.c   \
        ..\dpcsup.c   \
        ..\eventobj.c \
        ..\kernldat.c \
        ..\kiinit.c   \
        ..\miscc.c    \
        ..\mutntobj.c \
        ..\procobj.c  \
        ..\queueobj.c \
        ..\raisexcp.c \
        ..\semphobj.c \
        ..\thredobj.c \
        ..\thredsup.c \
        ..\timerobj.c \
        ..\timersup.c \
        ..\wait.c     \
        ..\waitsup.c  \
        ..\yield.c

NTTEST=
UMLIBS=$(BASEDIR)\public\sdk\lib\*\user32.lib
UMTEST=

NTTARGETFILES=

PRECOMPILED_INCLUDE=..\ki.h
PRECOMPILED_PCH=ki.pch
PRECOMPILED_OBJ=ki.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\semphobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    semphobj.c

Abstract:

    This module implements the kernel semaphore object. Functions
    are provided to initialize, read, and release semaphore objects.

Author:

    David N. Cutler (davec) 28-Feb-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input semaphore is
// really a ksemaphore and not something else, like deallocated pool.
//

#define ASSERT_SEMAPHORE(E) {                    \
    ASSERT((E)->Header.Type == SemaphoreObject); \
}

VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    )

/*++

Routine Description:

    This function initializes a kernel semaphore object. The initial
    count and limit of the object are set to the specified values.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Count - Supplies the initial count value to be assigned to the
        semaphore.

    Limit - Supplies the maximum count value that the semaphore
        can attain.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // count and maximum count values.
    //

    Semaphore->Header.Type = SemaphoreObject;
    Semaphore->Header.Size = sizeof(KSEMAPHORE) / sizeof(LONG);
    Semaphore->Header.SignalState = Count;
    InitializeListHead(&Semaphore->Header.WaitListHead);
    Semaphore->Limit = Limit;
    return;
}

LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a semaphore by adding the specified adjustment
    value to the current semaphore count and attempts to satisfy as many
    Waits as possible. The previous signal state of the semaphore object
    is returned as the function value.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Increment - Supplies the priority increment that is to be applied
        if releasing the semaphore causes a Wait to be satisfied.

    Adjustment - Supplies value that is to be added to the current
        semaphore count.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseSemaphore will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the semaphore object.

--*/

{

    LONG NewState;
    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_SEMAPHORE( Semaphore );
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the semaphore object and
    // compute the new count value.
    //

    OldState = Semaphore->Header.SignalState;
    NewState = OldState + Adjustment;

    //
    // If the new state value is greater than the limit or a carry occurs,
    // then unlock the dispatcher database, and raise an exception.
    //

    if ((NewState > Semaphore->Limit) || (NewState < OldState)) {
        KiUnlockDispatcherDatabase(OldIrql);
        ExRaiseStatus(STATUS_SEMAPHORE_LIMIT_EXCEEDED);
    }

    //
    // Set the new signal state of the semaphore object and set the wait
    // next value. If the previous signal state was Not-Signaled (i.e.
    // the count was zero), and the wait queue is not empty, then attempt
    // to satisfy as many Waits as possible.
    //

    Semaphore->Header.SignalState = NewState;
    if ((OldState == 0) && (IsListEmpty(&Semaphore->Header.WaitListHead) == FALSE)) {
        KiWaitTest(Semaphore, Increment);
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of sempahore object.
    //

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\timerobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timerobj.c

Abstract:

    This module implements the kernel timer object. Functions are
    provided to initialize, read, set, and cancel timer objects.

Author:

    David N. Cutler (davec) 2-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input timer is
// really a ktimer and not something else, like deallocated pool.
//

#define ASSERT_TIMER(E) {                                     \
    ASSERT(((E)->Header.Type == TimerNotificationObject) ||   \
           ((E)->Header.Type == TimerSynchronizationObject)); \
}

VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    )

/*++

Routine Description:

    This function initializes an extended kernel timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Type - Supplies the type of timer object; NotificationTimer or
        SynchronizationTimer;

Return Value:

    None.

--*/

{
    //
    // Initialize standard dispatcher object header and set initial
    // state of timer.
    //

    Timer->Header.Type = (UCHAR)(TimerNotificationObject + Type);
    Timer->Header.Inserted = FALSE;
    Timer->Header.Size = sizeof(KTIMER) / sizeof(LONG);
    Timer->Header.SignalState = FALSE;

#if DBG

    Timer->TimerListEntry.Flink = NULL;
    Timer->TimerListEntry.Blink = NULL;

#endif

    InitializeListHead(&Timer->Header.WaitListHead);
    Timer->DueTime.QuadPart = 0;
    Timer->Period = 0;
    return;
}

BOOLEAN
KeCancelTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function cancels a timer that was previously set to expire at
    a specified time. If the timer is not currently set, then no operation
    is performed. Canceling a timer does not set the state of the timer to
    Signaled.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock the dispatcher database, and
    // capture the timer inserted status. If the timer is currently set,
    // then remove it from the timer list.
    //

    KiLockDispatcherDatabase(&OldIrql);
    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return boolean value that signifies whether the timer was set of not.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}

BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    //
    // Set the timer with a period of zero.
    //

    return KeSetTimerEx(Timer, DueTime, 0, Dpc);
}

BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Period - Supplies an optional period for the timer in milliseconds.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    LARGE_INTEGER SystemTime;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the timer inserted status and if the timer is currently
    // set, then remove it from the timer list.
    //

    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Clear the signal state, set the period, set the DPC address, and
    // insert the timer in the timer tree. If the timer is not inserted
    // in the timer tree, then it has already expired and as many waiters
    // as possible should be continued, and a DPC, if specified should be
    // queued.
    //
    // N.B. The signal state must be cleared in case the period is not
    //      zero.
    //

    Timer->Header.SignalState = FALSE;
    Timer->Dpc = Dpc;
    Timer->Period = Period;
    if (KiInsertTreeTimer((PRKTIMER)Timer, DueTime) == FALSE) {
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            KiWaitTest(Timer, TIMER_EXPIRE_INCREMENT);
        }

        //
        // If a DPC is specfied, then call the DPC routine.
        //

        if (Dpc != NULL) {
            KiQuerySystemTime(&SystemTime);
            KeInsertQueueDpc(Timer->Dpc,
                             ULongToPtr(SystemTime.LowPart),
                             ULongToPtr(SystemTime.HighPart));
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer in the table. If this happens,
        //      try again.
        //

        if (Period != 0) {
            Interval.QuadPart = Int32x32To64(Timer->Period, - 10 * 1000);
            while (!KiInsertTreeTimer(Timer, Interval)) {
                ;
            }
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return boolean value that signifies whether the timer was set of
    // not.
    //

    return Inserted;
}

ULONGLONG
KeQueryTimerDueTime (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function returns the InterruptTime at which the timer is
    pending.   0 is returned if the timer is not pending.

    N.B. This function may only be called by the system sleep code.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    Returns the amount of time remaining on the timer, or 0 if the
    timer is not pending.

--*/

{

    KIRQL OldIrql;
    ULONGLONG DueTime;

    ASSERT_TIMER(Timer);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the timer is currently pending, compute its due time
    //

    DueTime = 0;
    if (Timer->Header.Inserted) {
        DueTime = Timer->DueTime.QuadPart;
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value, and return the due time
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return DueTime;
}

PVOID
KeCheckForTimer(
    IN PVOID BlockStart,
    IN ULONG BlockSize
    )
/*++

Routine Description:

    This function is used for debugging by checking all timers
    to see if any is in the memory block passed.  If so, the
    system stops at a debug breakpoint.

Arguments:

    MemoryBlock - Base address to check for timer

    BlockSize - Size (in bytes) to check in memory block

Return Value:

    The address of the currently active timer.

--*/
{
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;
    PUCHAR Address;
    PUCHAR Start;
    PUCHAR End;

    //
    // Compute the ending memory location.
    //

    Start = (PUCHAR)BlockStart;
    End = Start + BlockSize;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Run the entire timer database and check for any timers in
    // the memory block
    //

    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            Address = (PUCHAR)Timer;
            NextEntry = NextEntry->Flink;

            //
            // Check this timer object is not in the range.
            // In each of the following, we check that the object
            // does not overlap the range, for example, if the timer
            // object (in this first check), starts one dword before
            // the range being checked, we have an overlap and should
            // stop.
            //

            if ((Address > (Start - sizeof(KTIMER))) &&
                (Address < End)) {
                KeBugCheckEx(TIMER_OR_DPC_INVALID,
                             0x0,
                             (ULONG_PTR)Address,
                             (ULONG_PTR)Start,
                             (ULONG_PTR)End);
            }

            if (Timer->Dpc) {

                //
                // Check the timer's DPC object isn't in the range.
                //

                Address = (PUCHAR)Timer->Dpc;
                if ((Address > (Start - sizeof(KDPC))) &&
                    (Address < End)) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x1,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }

                //
                // Check the timer's DPC routine is not in the range.
                //

                Address = (PUCHAR)(ULONG_PTR)Timer->Dpc->DeferredRoutine;
                if (Address >= Start && Address < End) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x2,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);


    //
    // Unlock the dispatcher database and lower IRQL to its previous value
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\thredobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    threadobj.c

Abstract:

    This module implements the machine independent functions to manipulate
    the kernel thread object. Functions are provided to initialize, ready,
    alert, test alert, boost priority, enable APC queuing, disable APC
    queuing, confine, set affinity, set priority, suspend, resume, alert
    resume, terminate, read thread state, freeze, unfreeze, query data
    alignment handling mode, force resume, and enter and leave critical
    regions for thread objects.

Author:

    David N. Cutler (davec) 4-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input thread object is
// really a kthread and not something else, like deallocated pool.
//

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}

VOID
KeInitializeThread (
    IN PKTHREAD Thread,
    IN PVOID KernelStack,
    IN SIZE_T KernelStackSize,
    IN SIZE_T TlsDataSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PKPROCESS Process
    )

/*++

Routine Description:

    This function initializes a thread object. The priority, affinity,
    and initial quantum are taken from the parent process object. The
    thread object is inserted at the end of the thread list for the
    parent process.

    N.B. It is assumed that the thread object is zeroed.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    KernelStack - Supplies a pointer to the base of a kernel stack on which
        the context frame for the thread is to be constructed.

    KernelStackSize - Supplies the number of bytes allocated for the kernel
        stack.

    TlsDataSize - Supplies the number of bytes reserved from the kernel stack
        for thread local storage.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    Process - Supplies a pointer to a control object of type process.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;

    //
    // Initialize the standard dispatcher object header and set the initial
    // state of the thread object.
    //

    Thread->Header.Type = ThreadObject;
    Thread->Header.Size = sizeof(KTHREAD) / sizeof(LONG);
    InitializeListHead(&Thread->Header.WaitListHead);

    //
    // Initialize the owned mutant listhead.
    //

    InitializeListHead(&Thread->MutantListHead);

    //
    // Initialize the alerted, preempted, debugactive, autoalignment,
    // kernel stack resident, enable kernel stack swap, and process
    // ready queue boolean values.
    //
    // N.B. Only nonzero values are initialized.
    //

    //
    // Initialize the APC state pointers, the current APC state, the saved
    // APC state, and enable APC queuing.
    //

    InitializeListHead(&Thread->ApcState.ApcListHead[KernelMode]);
    InitializeListHead(&Thread->ApcState.ApcListHead[UserMode]);
    Thread->ApcState.Process = Process;
    Thread->ApcState.ApcQueueable = TRUE;

    //
    // Initialize the kernel mode suspend APC and the suspend semaphore object.
    // and the builtin wait timeout timer object.
    //

    KeInitializeApc(&Thread->SuspendApc,
                    Thread,
                    (PKKERNEL_ROUTINE)KiSuspendNop,
                    (PKRUNDOWN_ROUTINE)NULL,
                    KiSuspendThread,
                    KernelMode,
                    NULL);

    KeInitializeSemaphore(&Thread->SuspendSemaphore, 0L, 2L);

    //
    // Initialize the builtin timer trimer wait wait block.
    //
    // N.B. This is the only time the wait block is initialized since this
    //      information is constant.
    //

    Timer = &Thread->Timer;
    KeInitializeTimer(Timer);
    WaitBlock = &Thread->TimerWaitBlock;
    WaitBlock->Object = Timer;
    WaitBlock->WaitKey = (CSHORT)STATUS_TIMEOUT;
    WaitBlock->WaitType = WaitAny;
    WaitBlock->Thread = Thread;
    WaitBlock->WaitListEntry.Flink = &Timer->Header.WaitListHead;
    WaitBlock->WaitListEntry.Blink = &Timer->Header.WaitListHead;

    //
    // Set the initial kernel stack and the initial thread context.
    //

    Thread->StackBase = KernelStack;
    Thread->StackLimit = (PVOID)((ULONG_PTR)KernelStack - KernelStackSize);
    KiInitializeContextThread(Thread,
                              TlsDataSize,
                              SystemRoutine,
                              StartRoutine,
                              StartContext);

    //
    // Set the base thread priority, the thread priority, the thread affinity,
    // the thread quantum, and the scheduling state.
    //

    Thread->BasePriority = Process->BasePriority;
    Thread->Priority = Thread->BasePriority;
    Thread->Quantum = Process->ThreadQuantum;
    Thread->State = Initialized;
    Thread->DisableBoost = Process->DisableBoost;

    //
    // Lock the dispatcher database, insert the thread in the process
    // thread list, increment the kernel stack count, and unlock the
    // dispatcher database.
    //
    // N.B. The distinguished value MAXSHORT is used to signify that no
    //      threads have been created for a process.
    //

    KiLockDispatcherDatabase(&OldIrql);
    InsertTailList(&Process->ThreadListHead, &Thread->ThreadListEntry);
    Process->StackCount += 1;

    //
    // Initialize the ideal processor number for the thread.
    //
    //  N.B. This must be done under the dispatcher lock to prevent byte
    //      granularity problems on Alpha.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

BOOLEAN
KeAlertThread (
    IN PKTHREAD Thread,
    IN KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function attempts to alert a thread and cause its execution to
    be continued if it is currently in an alertable Wait state. Otherwise
    it just sets the alerted variable for the specified processor mode.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    AlertMode - Supplies the processor mode for which the thread is
        to be alerted.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and lock
    // APC queue.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // Capture the current state of the alerted variable for the specified
    // processor mode.
    //

    Alerted = Thread->Alerted[AlertMode];

    //
    // If the alerted state for the specified processor mode is Not-Alerted,
    // then attempt to alert the thread.
    //

    if (Alerted == FALSE) {

        //
        // If the thread is currently in a Wait state, the Wait is alertable,
        // and the specified processor mode is less than or equal to the Wait
        // mode, then the thread is unwaited with a status of "alerted".
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE) &&
            (AlertMode <= Thread->WaitMode)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT);

        } else {
            Thread->Alerted[AlertMode] = TRUE;
        }
    }

    //
    // Unlock APC queue, unlock dispatcher database, lower IRQL to its
    // previous value, and return the previous alerted state for the
    // specified mode.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return Alerted;
}

ULONG
KeAlertResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function attempts to alert a thread in kernel mode and cause its
    execution to be continued if it is currently in an alertable Wait state.
    In addition, a resume operation is performed on the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and lock
    // APC queue.
    //

    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // If the kernel mode alerted state is FALSE, then attempt to alert
    // the thread for kernel mode.
    //

    if (Thread->Alerted[KernelMode] == FALSE) {

        //
        // If the thread is currently in a Wait state and the Wait is alertable,
        // then the thread is unwaited with a status of "alerted". Else set the
        // kernel mode alerted variable.
        //

        if ((Thread->State == Waiting) && (Thread->Alertable == TRUE)) {
            KiUnwaitThread(Thread, STATUS_ALERTED, ALERT_INCREMENT);

        } else {
            Thread->Alerted[KernelMode] = TRUE;
        }
    }

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero, then resume the thread by
        // releasing its suspend semaphore.
        //

        if (Thread->SuspendCount == 0) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock APC queue, unlock dispatcher database, lower IRQL to its
    // previous value, and return the previous suspend count.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return OldCount;
}

VOID
KeBoostPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function boosts the priority of the specified thread using the
    same algorithm used when a thread gets a boost from a wait operation.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the thread does not run at a realtime priority level, then boost
    // the thread priority.
    //

    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        KiBoostPriorityThread(Thread, Increment);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

BOOLEAN
KeDisableApcQueuingThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function disables the queuing of APC's to the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous value of the APC queuing state variable.

--*/

{

    BOOLEAN ApcQueueable;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the APC queueable state variable and
    // set its state to FALSE.
    //

    ApcQueueable = Thread->ApcState.ApcQueueable;
    Thread->ApcState.ApcQueueable = FALSE;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous APC queueable state.
    //

    return ApcQueueable;
}

BOOLEAN
KeEnableApcQueuingThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function enables the queuing of APC's to the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous value of the APC queuing state variable.

--*/

{

    BOOLEAN ApcQueueable;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the APC queueable state variable and
    // set its state to TRUE.
    //

    ApcQueueable = Thread->ApcState.ApcQueueable;
    Thread->ApcState.ApcQueueable = TRUE;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return previous APC queueable state.
    //

    return ApcQueueable;
}

ULONG
KeForceResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function forces resumption of thread execution if the thread is
    suspended. If the specified thread is not suspended, then no operation
    is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The sum of the previous suspend count and the freeze count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then force resumption of
    // thread execution.
    //

    if (OldCount != 0) {
        Thread->SuspendCount = 0;
        Thread->SuspendSemaphore.Header.SignalState += 1;
        KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

LONG
KeQueryBasePriorityThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function returns the base priority increment of the specified
    thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The base priority increment of the specified thread.

--*/

{

    LONG Increment;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If priority saturation occured the last time the thread base priority
    // was set, then return the saturation increment value. Otherwise, compute
    // the increment value as the difference between the thread base priority
    // and the process base priority.
    //

    Process = Thread->ApcState.Process;
    Increment = Thread->BasePriority - Process->BasePriority;
    if (Thread->Saturation != 0) {
        Increment = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread base priority increment.
    //

    return Increment;
}

VOID
KeReadyThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution. If the thread's process
    is currently not in the balance set, then the thread is inserted in the
    thread's process' ready queue. Else if the thread is higher priority than
    another thread that is currently running on a processor then the thread
    is selected for execution on that processor. Else the thread is inserted
    in the dispatcher ready queue selected by its priority.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Ready the specified thread for execution.
    //

    KiReadyThread(Thread);

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

ULONG
KeResumeThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function resumes the execution of a suspended thread. If the
    specified thread is not suspended, then no operation is performed.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the thread is currently suspended, then decrement its suspend count.
    //

    if (OldCount != 0) {
        Thread->SuspendCount -= 1;

        //
        // If the resultant suspend count is zero, then resume the thread by
        // releasing its suspend semaphore.
        //

        if (Thread->SuspendCount == 0) {
            Thread->SuspendSemaphore.Header.SignalState += 1;
            KiWaitTest(&Thread->SuspendSemaphore, RESUME_INCREMENT);
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

VOID
KeRundownThread (
    VOID
    )

/*++

Routine Description:

    This function is called by the executive to rundown thread structures
    which must be guarded by the dispatcher database lock and which must
    be processed before actually terminating the thread. An example of such
    a structure is the mutant ownership list that is anchored in the kernel
    thread object.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKMUTANT Mutant;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // Scan the list of owned mutant objects and release the mutant objects
    // with an abandoned status. If the mutant is a kernel mutex, then bug
    // check.
    //

    NextEntry = Thread->MutantListHead.Flink;
    while (NextEntry != &Thread->MutantListHead) {
        Mutant = CONTAINING_RECORD(NextEntry, KMUTANT, MutantListEntry);

        RemoveEntryList(&Mutant->MutantListEntry);
        Mutant->Header.SignalState = 1;
        Mutant->Abandoned = TRUE;
        Mutant->OwnerThread = (PKTHREAD)NULL;
        if (IsListEmpty(&Mutant->Header.WaitListHead) != TRUE) {
            KiWaitTest(Mutant, MUTANT_INCREMENT);
        }

        NextEntry = Thread->MutantListHead.Flink;
    }

    //
    // Release dispatcher database lock and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

LONG
KeSetBasePriorityThread (
    IN PKTHREAD Thread,
    IN LONG Increment
    )

/*++

Routine Description:

    This function sets the base priority of the specified thread to a
    new value.  The new base priority for the thread is the process base
    priority plus the increment.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Increment - Supplies the base priority increment of the subject thread.

        N.B. If the absolute value of the increment is such that saturation
             of the base priority is forced, then subsequent changes to the
             parent process base priority will not change the base priority
             of the thread.

Return Value:

    The previous base priority increment of the specified thread.

--*/

{

    KPRIORITY NewBase;
    KPRIORITY NewPriority;
    KPRIORITY OldBase;
    LONG OldIncrement;
    KIRQL OldIrql;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the base priority of the specified thread and determine
    // whether saturation if being forced.
    //

    Process = Thread->ApcState.Process;
    OldBase = Thread->BasePriority;
    OldIncrement = OldBase - Process->BasePriority;
    if (Thread->Saturation != 0) {
        OldIncrement = ((HIGH_PRIORITY + 1) / 2) * Thread->Saturation;
    }

    Thread->Saturation = FALSE;
    if (abs(Increment) >= (HIGH_PRIORITY + 1) / 2) {
        Thread->Saturation = (Increment > 0) ? 1 : -1;
    }

    //
    // Set the base priority of the specified thread. If the thread's process
    // is in the realtime class, then limit the change to the realtime class.
    // Otherwise, limit the change to the variable class.
    //

    NewBase = Process->BasePriority + Increment;
    if (Process->BasePriority >= LOW_REALTIME_PRIORITY) {
        if (NewBase < LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY;

        } else if (NewBase > HIGH_PRIORITY) {
            NewBase = HIGH_PRIORITY;
        }

        //
        // Set the new priority of the thread to the new base priority.
        //

        NewPriority = NewBase;

    } else {
        if (NewBase >= LOW_REALTIME_PRIORITY) {
            NewBase = LOW_REALTIME_PRIORITY - 1;

        } else if (NewBase <= LOW_PRIORITY) {
            NewBase = 1;
        }

        //
        // Compute the new thread priority. If the new priority is outside
        // the variable class, then set the new priority to the highest
        // variable priority.
        //

        if (Thread->Saturation != 0) {
            NewPriority = NewBase;

        } else {
            NewPriority = Thread->Priority +
                            (NewBase - OldBase) - Thread->PriorityDecrement;

            if (NewPriority >= LOW_REALTIME_PRIORITY) {
                NewPriority = LOW_REALTIME_PRIORITY - 1;
            }
        }
    }

    //
    // Set the new base priority and clear the priority decrement. If the
    // new priority is not equal to the old priority, then set the new thread
    // priority.
    //

    Thread->BasePriority = (SCHAR)NewBase;
    Thread->DecrementCount = 0;
    Thread->PriorityDecrement = 0;
    if (NewPriority != Thread->Priority) {
        Thread->Quantum = Process->ThreadQuantum;
        KiSetPriorityThread(Thread, NewPriority);
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread base priority.
    //

    return OldIncrement;
}

LOGICAL
KeSetDisableBoostThread (
    IN PKTHREAD Thread,
    IN LOGICAL Disable
    )

/*++

Routine Description:

    This function disables priority boosts for the specified thread.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Disable - Supplies a logical value that determines whether priority
        boosts for the thread are disabled or enabled.

Return Value:

    The previous value of the disable boost state variable.

--*/

{

    LOGICAL DisableBoost;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current state of the disable boost variable and set its
    // state to TRUE.
    //

    DisableBoost = Thread->DisableBoost;
    Thread->DisableBoost = (BOOLEAN)Disable;

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous disable boost state.
    //

    return DisableBoost;
}

KPRIORITY
KeSetPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Priority
    )

/*++

Routine Description:

    This function sets the priority of the specified thread to a new value.
    If the new thread priority is lower than the old thread priority, then
    resecheduling may take place if the thread is currently running on, or
    about to run on, a processor.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new priority of the subject thread.

Return Value:

    The previous priority of the specified thread.

--*/

{

    KIRQL OldIrql;
    KPRIORITY OldPriority;
    PKPROCESS Process;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(((Priority != 0) || (Thread->BasePriority == 0)) &&
           (Priority <= HIGH_PRIORITY));

    ASSERT(KeIsExecutingDpc() == FALSE);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current thread priority, set the thread priority to the
    // the new value, and replenish the thread quantum. It is assumed that
    // the priority would not be set unless the thread had already lost it
    // initial quantum.
    //

    OldPriority = Thread->Priority;
    Process = Thread->ApcState.Process;
    Thread->Quantum = Process->ThreadQuantum;
    Thread->DecrementCount = 0;
    Thread->PriorityDecrement = 0;
    KiSetPriorityThread(Thread, Priority);

    //
    // Unlock dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous thread priority.
    //

    return OldPriority;
}

ULONG
KeSuspendThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    This function suspends the execution of a thread. If the suspend count
    overflows the maximum suspend count, then a condition is raised.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The previous suspend count.

--*/

{

    ULONG OldCount;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current suspend count.
    //

    OldCount = Thread->SuspendCount;

    //
    // If the suspend count is at its maximum value, then unlock dispatcher
    // database, lower IRQL to its previous value, and raise an error
    // condition.
    //

    if (OldCount == MAXIMUM_SUSPEND_COUNT) {

        //
        // Unlock the dispatcher database and raise an exception.
        //

        KiUnlockDispatcherDatabase(OldIrql);
        ExRaiseStatus(STATUS_SUSPEND_COUNT_EXCEEDED);
    }

    //
    // Don't suspend if APC queuing is disabled. Thread is being deleted in this case.
    //

    if (Thread->ApcState.ApcQueueable == TRUE) {

        //
        // Increment the suspend count. If the thread was not previously suspended,
        // then queue the thread's suspend APC.
        //

        Thread->SuspendCount += 1;
        if (OldCount == 0) {
            if (KiInsertQueueApc(&Thread->SuspendApc, RESUME_INCREMENT) == FALSE) {
                Thread->SuspendSemaphore.Header.SignalState -= 1;
            }
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return the previous suspend count.
    //

    return OldCount;
}

VOID
KeTerminateThread (
    VOID
    )

/*++

Routine Description:

    This function terminates the execution of the current thread, sets the
    signal state of the thread to Signaled, and attempts to satisfy as many
    Waits as possible. The scheduling state of the thread is set to terminated,
    and a new thread is selected to run on the current processor. There is no
    return from this function.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKPROCESS Process;
    PRKQUEUE Queue;
    PRKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the current thread is processing a queue entry, then remove
    // the thrread from the queue object thread list and attempt to
    // activate another thread that is blocked on the queue object.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        RemoveEntryList(&Thread->QueueListEntry);
        KiActivateWaiterQueue(Queue);
    }

    //
    // Set the state of the current thread object to Signaled, and attempt
    // to satisfy as many Waits as possible.
    //

    Thread->Header.SignalState = TRUE;
    if (IsListEmpty(&Thread->Header.WaitListHead) != TRUE) {
        KiWaitTest((PVOID)Thread, 0);
    }

    //
    // Remove thread from its parent process' thread list.
    //

    RemoveEntryList(&Thread->ThreadListEntry);

    //
    // Set thread scheduling state to terminated, decrement the process'
    // stack count, select a new thread to run on the current processor,
    // and swap context to the new thread.
    //

    Thread->State = Terminated;
    Process = Thread->ApcState.Process;
    Process->StackCount -= 1;

    //
    // Rundown any architectural specific structures.
    //

    KiRundownThread(Thread);

    //
    // Insert the reaper DPC into the DPC queue to delete the stack and release
    // the reference on the thread object.
    //

    InsertTailList(&PsReaperListHead, &((PETHREAD)Thread)->ReaperListEntry);
    KeInsertQueueDpc(&PsReaperDpc, NULL, NULL);

    //
    // Get off the processor for the last time.
    //

    KiSwapThread();
    return;
}

BOOLEAN
KeTestAlertThread (
    IN KPROCESSOR_MODE AlertMode
    )

/*++

Routine Description:

    This function tests to determine if the alerted variable for the
    specified processor mode has a value of TRUE or whether a user mode
    APC should be delivered to the current thread.

Arguments:

    AlertMode - Supplies the processor mode which is to be tested
        for an alerted condition.

Return Value:

    The previous state of the alerted variable for the specified processor
    mode.

--*/

{

    BOOLEAN Alerted;
    KIRQL OldIrql;
    PKTHREAD Thread;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock dispatcher database, and lock
    // APC queue.
    //

    Thread = KeGetCurrentThread();
    KiLockDispatcherDatabase(&OldIrql);
    KiLockApcQueueAtDpcLevel(Thread);

    //
    // If the current thread is alerted for the specified processor mode,
    // then clear the alerted state. Else if the specified processor mode
    // is user and the current thread's user mode APC queue contains an entry,
    // then set user APC pending.
    //

    Alerted = Thread->Alerted[AlertMode];
    if (Alerted == TRUE) {
        Thread->Alerted[AlertMode] = FALSE;

    } else if ((AlertMode == UserMode) &&
              (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode]) != TRUE)) {
        Thread->ApcState.UserApcPending = TRUE;
    }

    //
    // Unlock APC queue, unlock dispatcher database, lower IRQL to its
    // previous value, and return the previous alerted state for the
    // specified mode.
    //

    KiUnlockApcQueueFromDpcLevel(Thread);
    KiUnlockDispatcherDatabase(OldIrql);
    return Alerted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\timersup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timersup.c

Abstract:

    This module contains the support routines for the timer object. It
    contains functions to insert and remove from the timer queue.

Author:

    David N. Cutler (davec) 13-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define forward referenced function prototypes.
//

LOGICAL
FASTCALL
KiInsertTimerTable (
    LARGE_INTEGER Interval,
    LARGE_INTEGER CurrentTime,
    IN PRKTIMER Timer
    );

LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PRKTIMER Timer,
    IN LARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function inserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Interval - Supplies the absolute or relative time at which the time
        is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER TimeDifference;

    //
    // Clear the signal state of timer if the timer period is zero and set
    // the inserted state to TRUE.
    //

    Timer->Header.Inserted = TRUE;
    Timer->Header.Absolute = FALSE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // If the specified interval is not a relative time (i.e., is an absolute
    // time), then convert it to relative time.
    //

    if (Interval.HighPart >= 0) {
        KiQuerySystemTime(&SystemTime);
        TimeDifference.QuadPart = SystemTime.QuadPart - Interval.QuadPart;

        //
        // If the resultant relative time is greater than or equal to zero,
        // then the timer has already expired.
        //

        if (TimeDifference.HighPart >= 0) {
            Timer->Header.SignalState = TRUE;
            Timer->Header.Inserted = FALSE;
            return FALSE;
        }

        Interval = TimeDifference;
        Timer->Header.Absolute = TRUE;
    }

    //
    // Get the current interrupt time, insert the timer in the timer table,
    // and return the inserted state.
    //

    KiQueryInterruptTime(&CurrentTime);
    return KiInsertTimerTable(Interval, CurrentTime, Timer);
}

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PRKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    )

/*++

Routine Description:

    This function reinserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies the absolute time the timer is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Interval;

    //
    // Clear the signal state of timer if the timer period is zero and set
    // the inserted state to TRUE.
    //

    Timer->Header.Inserted = TRUE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // Compute the interval between the current time and the due time.
    // If the resultant relative time is greater than or equal to zero,
    // then the timer has already expired.
    //

    KiQueryInterruptTime(&CurrentTime);
    Interval.QuadPart = CurrentTime.QuadPart - DueTime.QuadPart;
    if (Interval.QuadPart >= 0) {
        Timer->Header.SignalState = TRUE;
        Timer->Header.Inserted = FALSE;
        return FALSE;
    }

    //
    // Insert the timer in the timer table and return the inserted state.
    //

    return KiInsertTimerTable(Interval, CurrentTime, Timer);
}

LOGICAL
FASTCALL
KiInsertTimerTable (
    LARGE_INTEGER Interval,
    LARGE_INTEGER CurrentTime,
    IN PRKTIMER Timer
    )

/*++

Routine Description:

    This function inserts a timer object in the timer table.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Interval - Supplies the relative timer before the timer is to expire.

    CurrentTime - supplies the current interrupt time.

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PRKTIMER NextTimer;
    ULONG SearchCount;

    //
    // Compute the timer table index and set the timer expiration time.
    //

    Index = KiComputeTimerTableIndex(Interval, CurrentTime, Timer);

    //
    // If the timer is due before the first entry in the computed list
    // or the computed list is empty, then insert the timer at the front
    // of the list and check if the timer has already expired. Otherwise,
    // insert then timer in the sorted order of the list searching from
    // the back of the list forward.
    //
    // N.B. The sequence of operations below is critical to avoid the race
    //      condition that exists between this code and the clock interrupt
    //      code that examines the timer table lists to detemine when timers
    //      expire.
    //

    ListHead = &KiTimerTableListHead[Index];
    NextEntry = ListHead->Blink;

#if DBG

    SearchCount = 0;

#endif

    while (NextEntry != ListHead) {

        //
        // Compute the maximum search count.
        //

#if DBG

        SearchCount += 1;
        if (SearchCount > KiMaximumSearchCount) {
            KiMaximumSearchCount = SearchCount;
        }

#endif

        NextTimer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
        if (((Timer->DueTime.HighPart == NextTimer->DueTime.HighPart) &&
            (Timer->DueTime.LowPart >= NextTimer->DueTime.LowPart)) ||
            (Timer->DueTime.HighPart > NextTimer->DueTime.HighPart)) {
            InsertHeadList(NextEntry, &Timer->TimerListEntry);
            return TRUE;
        }

        NextEntry = NextEntry->Blink;
    }

    //
    // The computed list is empty or the timer is due to expire before
    // the first entry in the list. Insert the entry in the computed
    // timer table list, then check if the timer has expired.
    //
    // Note that it is critical that the interrupt time not be captured
    // until after the timer has been completely inserted into the list.
    //
    // Otherwise, the clock interrupt code can think the list is empty,
    // and the code here that checks if the timer has expired will use
    // a stale interrupt time.
    //

    InsertHeadList(ListHead, &Timer->TimerListEntry);
    KiQueryInterruptTime(&CurrentTime);
    if (((Timer->DueTime.HighPart == (ULONG)CurrentTime.HighPart) &&
        (Timer->DueTime.LowPart <= CurrentTime.LowPart)) ||
        (Timer->DueTime.HighPart < (ULONG)CurrentTime.HighPart)) {

        //
        // The timer is due to expire before the current time. Remove the
        // timer from the computed list, set its status to Signaled, set
        // its inserted state to FALSE, and
        //

        KiRemoveTreeTimer(Timer);
        Timer->Header.SignalState = TRUE;
    }

    return Timer->Header.Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\wait.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    wait.c

Abstract:

    This module implements the generic kernel wait routines. Functions
    are provided to wait for a single object, wait for multiple objects,
    wait for event pair low, wait for event pair high, release and wait
    for semaphore, and to delay thread execution.

    N.B. This module is written to be a fast as possible and not as small
        as possible. Therefore some code sequences are duplicated to avoid
        procedure calls. It would also be possible to combine wait for
        single object into wait for multiple objects at the cost of some
        speed. Since wait for single object is the most common case, the
        two routines have been separated.

Author:

    David N. Cutler (davec) 23-Mar-89

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Test for alertable condition.
//
// If alertable is TRUE and the thread is alerted for a processor
// mode that is equal to the wait mode, then return immediately
// with a wait completion status of ALERTED.
//
// Else if alertable is TRUE, the wait mode is user, and the user APC
// queue is not empty, then set user APC pending, and return immediately
// with a wait completion status of USER_APC.
//
// Else if alertable is TRUE and the thread is alerted for kernel
// mode, then return immediately with a wait completion status of
// ALERTED.
//
// Else if alertable is FALSE and the wait mode is user and there is a
// user APC pending, then return immediately with a wait completion
// status of USER_APC.
//

#define TestForAlertPending(Alertable) \
    if (Alertable) { \
        if (Thread->Alerted[WaitMode] != FALSE) { \
            Thread->Alerted[WaitMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } else if ((WaitMode != KernelMode) && \
                  (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode])) == FALSE) { \
            Thread->ApcState.UserApcPending = TRUE; \
            WaitStatus = STATUS_USER_APC; \
            break; \
        } else if (Thread->Alerted[KernelMode] != FALSE) { \
            Thread->Alerted[KernelMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } \
    } else if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) { \
        WaitStatus = STATUS_USER_APC; \
        break; \
    }

VOID
KiAdjustQuantumThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    If the current thread is not a time critical or realtime thread, then
    adjust its quantum in accordance with the adjustment that would have
    occured if the thread had actually waited.

Arguments:

    Thread - Supplies a pointer to the current thread.

Return Value:

    None.

--*/

{
    PKPRCB Prcb;
    PKPROCESS Process;
    PKTHREAD NewThread;
    SCHAR ThreadPriority;

    if ((Thread->Priority < LOW_REALTIME_PRIORITY) &&
        (Thread->BasePriority < TIME_CRITICAL_PRIORITY_BOUND)) {
        Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
        if (Thread->Quantum <= 0) {
            Process = Thread->ApcState.Process;
            Thread->Quantum = Process->ThreadQuantum;
            ThreadPriority = (SCHAR)(Thread->Priority - (Thread->PriorityDecrement + 1));
            if (ThreadPriority < Thread->BasePriority) {
                ThreadPriority = Thread->BasePriority;
            }

            Thread->PriorityDecrement = 0;
            if (ThreadPriority != Thread->Priority) {
                KiSetPriorityThread(Thread, ThreadPriority);

            } else {
                Prcb = KeGetCurrentPrcb();
                if (Prcb->NextThread == NULL) {
                    NewThread = KiFindReadyThread(ThreadPriority);
                    if (NewThread != NULL) {
                        Prcb->NextThread = NewThread;
                        NewThread->State = Standby;
                    }
                }
            }
        }
    }

    return;
}

NTSTATUS
KeDelayExecutionThread (
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    WaitMode  - Supplies the processor mode in which the delay is to occur.

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    Interval - Supplies a pointer to the absolute or relative time over which
        the delay is to occur.

Return Value:

    The wait completion status. A value of STATUS_SUCCESS is returned if
    the delay occurred. A value of STATUS_ALERTED is returned if the wait
    was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    LARGE_INTEGER NewTime;
    PLARGE_INTEGER OriginalTime;
    PKPRCB Prcb;
    KPRIORITY Priority;
    PRKQUEUE Queue;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&Thread->WaitIrql);
    }

    //
    // Start of delay loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the delay or a kernel APC is pending on the first attempt through
    // the loop.
    //

    OriginalTime = Interval;
    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // Initialize wait block, insert wait block in timer wait list,
            // insert timer in timer queue, put thread in wait state, select
            // next thread to execute, and context switch to next thread.
            //
            // N.B. The timer wait block is initialized when the respective
            //      thread is initialized. Thus the constant fields are not
            //      reinitialized. These include the wait object, wait key,
            //      wait type, and the wait list entry link pointers.
            //

            WaitBlock = &Thread->TimerWaitBlock;
            Thread->WaitBlockList = WaitBlock;
            Thread->WaitStatus = (NTSTATUS)0;
            Timer = &Thread->Timer;
            WaitBlock->NextWaitBlock = WaitBlock;
            Timer->Header.WaitListHead.Flink = &WaitBlock->WaitListEntry;
            Timer->Header.WaitListHead.Blink = &WaitBlock->WaitListEntry;

            //
            // If the timer is inserted in the timer tree, then place the
            // current thread in a wait state. Otherwise, attempt to force
            // the current thread to yield the processor to another thread.
            //

            if (KiInsertTreeTimer(Timer, *Interval) == FALSE) {

                //
                // If the thread is not a realtime thread, then drop the
                // thread priority to the base priority.
                //

                Prcb = KeGetCurrentPrcb();
                Priority = Thread->Priority;
                if (Priority < LOW_REALTIME_PRIORITY) {
                    if (Priority != Thread->BasePriority) {
                        Thread->PriorityDecrement = 0;
                        KiSetPriorityThread(Thread, Thread->BasePriority);
                    }
                }

                //
                // If a new thread has not been selected, the attempt to round
                // robin the thread with other threads at the same priority.
                //

                if (Prcb->NextThread == NULL) {
                    Prcb->NextThread = KiFindReadyThread(Thread->Priority);
                }

                //
                // If a new thread has been selected for execution, then
                // switch immediately to the selected thread.
                //

                if (Prcb->NextThread != NULL) {

                    //
                    // Give the current thread a new qunatum and switch
                    // context to selected thread.
                    //
                    // N.B. Control is returned at the original IRQL.
                    //

                    Thread->Preempted = FALSE;
                    Thread->Quantum = Thread->ApcState.Process->ThreadQuantum;

                    ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                    KiReadyThread(Thread);
                    WaitStatus = (NTSTATUS)KiSwapThread();
                    goto WaitComplete;

                } else {
                    WaitStatus = (NTSTATUS)STATUS_SUCCESS;
                    break;
                }
            }

            DueTime.QuadPart = Timer->DueTime.QuadPart;

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->Alertable = Alertable;
            Thread->WaitMode = WaitMode;
            Thread->WaitReason = DelayExecution;
            Thread->WaitTime= KiQueryLowTickCount();
            Thread->State = Waiting;
            KiInsertWaitList(WaitMode, Thread);

            //
            // Switch context to selected thread.
            //
            // N.B. Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

        WaitComplete:
            //
            // If the thread was awakened to deliver a user mode APC, then
            // deliver pending user mode APCs.
            //

            if (WaitStatus == STATUS_USER_APC) {
                KiDeliverUserApc();
            }

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                if (WaitStatus == STATUS_TIMEOUT) {
                    WaitStatus = STATUS_SUCCESS;
                }
                return WaitStatus;
            }

            //
            // Reduce the time remaining before the time delay expires.
            //

            Interval = KiComputeWaitInterval(OriginalTime,
                                             &DueTime,
                                             &NewTime);
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&Thread->WaitIrql);
    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return the
    // wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;
}

NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled. The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled. If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Object[] - Supplies an array of pointers to dispatcher objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

    WaitBlockArray - Supplies a pointer to an array of wait blocks that are to
        used to describe the wait operation.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait. A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread. A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    ULONG Index;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;
    BOOLEAN WaitSatisfied;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // The caller always must supply storage for the KWAIT_BLOCKs (this was
    // optional for small counts under NT).
    //

    ASSERT(WaitBlockArray != NULL);

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&Thread->WaitIrql);
    }

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    OriginalTime = Timeout;
    do {

        //
        // Set address of wait block list in thread object.
        //

        Thread->WaitBlockList = WaitBlockArray;

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Construct wait blocks and check to determine if the wait is
            // already satisfied. If the wait is satisfied, then perform
            // wait completion and return. Else put current thread in a wait
            // state if an explicit timeout value of zero is not specified.
            //

            Thread->WaitStatus = (NTSTATUS)0;
            WaitSatisfied = TRUE;
            for (Index = 0; Index < Count; Index += 1) {

                //
                // Test if wait can be satisfied immediately.
                //

                Objectx = (PKMUTANT)Object[Index];

                ASSERT(Objectx->Header.Type != QueueObject);

                if (WaitType == WaitAny) {

                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MINLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is greater than zero, or the current thread is
                    // the owner of the mutant object, then satisfy the wait.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Objectx->Header.SignalState > 0) ||
                            (Thread == Objectx->OwnerThread)) {
                            if (Objectx->Header.SignalState != MINLONG) {
                                KiWaitSatisfyMutant(Objectx, Thread);
                                WaitStatus = (NTSTATUS)(Index | Thread->WaitStatus);
                                goto NoWait;

                            } else {
                                KiUnlockDispatcherDatabase(Thread->WaitIrql);
                                ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                            }
                        }

                    //
                    // If the signal state is greater than zero, then satisfy
                    // the wait.
                    //

                    } else if (Objectx->Header.SignalState > 0) {
                        KiWaitSatisfyOther(Objectx);
                        WaitStatus = (NTSTATUS)(Index);
                        goto NoWait;
                    }

                } else {

                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MAXLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is less than or equal to zero and the current
                    // thread is not the  owner of the mutant object, then the
                    // wait cannot be satisfied.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Thread == Objectx->OwnerThread) &&
                            (Objectx->Header.SignalState == MINLONG)) {
                            KiUnlockDispatcherDatabase(Thread->WaitIrql);
                            ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);

                        } else if ((Objectx->Header.SignalState <= 0) &&
                                  (Thread != Objectx->OwnerThread)) {
                            WaitSatisfied = FALSE;
                        }

                    //
                    // If the signal state is less than or equal to zero, then
                    // the wait cannot be satisfied.
                    //

                    } else if (Objectx->Header.SignalState <= 0) {
                        WaitSatisfied = FALSE;
                    }
                }

                //
                // Construct wait block for the current object.
                //

                WaitBlock = &WaitBlockArray[Index];
                WaitBlock->Object = (PVOID)Objectx;
                WaitBlock->WaitKey = (CSHORT)(Index);
                WaitBlock->WaitType = (USHORT)WaitType;
                WaitBlock->Thread = Thread;
                WaitBlock->NextWaitBlock = &WaitBlockArray[Index + 1];
            }

            //
            // If the wait type is wait all, then check to determine if the
            // wait can be satisfied immediately.
            //

            if ((WaitType == WaitAll) && (WaitSatisfied)) {
                WaitBlock->NextWaitBlock = &WaitBlockArray[0];
                KiWaitSatisfyAll(WaitBlock);
                WaitStatus = (NTSTATUS)Thread->WaitStatus;
                goto NoWait;
            }

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisifed immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // If the timeout value is zero, then return immediately without
                // waiting.
                //

                if (!(Timeout->LowPart | Timeout->HighPart)) {
                    WaitStatus = (NTSTATUS)(STATUS_TIMEOUT);
                    goto NoWait;
                }

                //
                // Initialize a wait block for the thread specific timer,
                // initialize timer wait list head, insert the timer in the
                // timer tree, and increment the number of wait objects.
                //
                // N.B. The timer wait block is initialized when the respective
                //      thread is initialized. Thus the constant fields are not
                //      reinitialized. These include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                WaitTimer = &Thread->TimerWaitBlock;
                WaitBlock->NextWaitBlock = WaitTimer;
                WaitBlock = WaitTimer;
                Timer = &Thread->Timer;
                InitializeListHead(&Timer->Header.WaitListHead);
                if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                DueTime.QuadPart = Timer->DueTime.QuadPart;
            }

            //
            // Close up the circular list of wait control blocks.
            //

            WaitBlock->NextWaitBlock = &WaitBlockArray[0];

            //
            // Insert wait blocks in object wait lists.
            //

            WaitBlock = &WaitBlockArray[0];
            do {
                Objectx = (PKMUTANT)WaitBlock->Object;
                InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);
                WaitBlock = WaitBlock->NextWaitBlock;
            } while (WaitBlock != &WaitBlockArray[0]);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->Alertable = Alertable;
            Thread->WaitMode = WaitMode;
            Thread->WaitReason = (UCHAR)WaitReason;
            Thread->WaitTime= KiQueryLowTickCount();
            Thread->State = Waiting;
            KiInsertWaitList(WaitMode, Thread);

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was awakened to deliver a user mode APC, then
            // deliver pending user mode APCs.
            //

            if (WaitStatus == STATUS_USER_APC) {
                KiDeliverUserApc();
            }

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&Thread->WaitIrql);
    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the thread priority that is less than time critical, then reduce
    // the thread quantum. If a quantum end occurs, then reduce the thread
    // priority.
    //

NoWait:
    KiAdjustQuantumThread(Thread);

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;
}

NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the object
    attains a state of Signaled. If a timeout is specified, and the object
    has not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait. A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    KWAIT_BLOCK StackWaitBlock;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // Collect call data.
    //

#if defined(_COLLECT_WAIT_SINGLE_CALLDATA_)

    RECORD_CALL_DATA(&KiWaitSingleCallData);

#endif

    //
    // If the dispatcher database lock is not already held, then set the wait
    // IRQL and lock the dispatcher database. Else set boolean wait variable
    // to FALSE.
    //

    Thread = KeGetCurrentThread();
    if (Thread->WaitNext) {
        Thread->WaitNext = FALSE;

    } else {
        KiLockDispatcherDatabase(&Thread->WaitIrql);
    }

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    OriginalTime = Timeout;
    WaitBlock = &StackWaitBlock;
    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Test if the wait can be immediately satisfied.
            //

            Objectx = (PKMUTANT)Object;
            Thread->WaitStatus = (NTSTATUS)0;

            ASSERT(Objectx->Header.Type != QueueObject);

            //
            // If the object is a mutant object and the mutant object has been
            // recursively acquired MINLONG times, then raise an exception.
            // Otherwise if the signal state of the mutant object is greater
            // than zero, or the current thread is the owner of the mutant
            // object, then satisfy the wait.
            //

            if (Objectx->Header.Type == MutantObject) {
                if ((Objectx->Header.SignalState > 0) ||
                    (Thread == Objectx->OwnerThread)) {
                    if (Objectx->Header.SignalState != MINLONG) {
                        KiWaitSatisfyMutant(Objectx, Thread);
                        WaitStatus = (NTSTATUS)(Thread->WaitStatus);
                        goto NoWait;

                    } else {
                        KiUnlockDispatcherDatabase(Thread->WaitIrql);
                        ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                    }
                }

            //
            // If the signal state is greater than zero, then satisfy the wait.
            //

            } else if (Objectx->Header.SignalState > 0) {
                KiWaitSatisfyOther(Objectx);
                WaitStatus = (NTSTATUS)(0);
                goto NoWait;
            }

            //
            // Construct a wait block for the object.
            //

            Thread->WaitBlockList = WaitBlock;
            WaitBlock->Object = Object;
            WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);
            WaitBlock->WaitType = WaitAny;
            WaitBlock->Thread = Thread;

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisifed immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // If the timeout value is zero, then return immediately without
                // waiting.
                //

                if (!(Timeout->LowPart | Timeout->HighPart)) {
                    WaitStatus = (NTSTATUS)(STATUS_TIMEOUT);
                    goto NoWait;
                }

                //
                // Initialize a wait block for the thread specific timer, insert
                // wait block in timer wait list, insert the timer in the timer
                // tree.
                //
                // N.B. The timer wait block is initialized when the respective
                //      thread is initialized. Thus the constant fields are not
                //      reinitialized. These include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                Timer = &Thread->Timer;
                WaitTimer = &Thread->TimerWaitBlock;
                WaitBlock->NextWaitBlock = WaitTimer;
                Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;
                Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;
                WaitTimer->NextWaitBlock = WaitBlock;
                if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                DueTime.QuadPart = Timer->DueTime.QuadPart;

            } else {
                WaitBlock->NextWaitBlock = WaitBlock;
            }

            //
            // Insert wait block in object wait list.
            //

            InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->Alertable = Alertable;
            Thread->WaitMode = WaitMode;
            Thread->WaitReason = (UCHAR)WaitReason;
            Thread->WaitTime= KiQueryLowTickCount();
            Thread->State = Waiting;
            KiInsertWaitList(WaitMode, Thread);

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was awakened to deliver a user mode APC, then
            // deliver pending user mode APCs.
            //

            if (WaitStatus == STATUS_USER_APC) {
                KiDeliverUserApc();
            }

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to DISPATCH_LEVEL and lock the dispatcher database.
        //

        KiLockDispatcherDatabase(&Thread->WaitIrql);
    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the thread priority that is less than time critical, then reduce
    // the thread quantum. If a quantum end occurs, then reduce the thread
    // priority.
    //

NoWait:
    KiAdjustQuantumThread(Thread);

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    if (WaitStatus == STATUS_USER_APC) {
        KiDeliverUserApc();
    }
    return WaitStatus;
}

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    )

/*++

Routine Description:

    This function recomputes the wait interval after a thread has been
    awakened to deliver a kernel APC.

Arguments:

    OriginalTime - Supplies a pointer to the original timeout value.

    DueTime - Supplies a pointer to the previous due time.

    NewTime - Supplies a pointer to a variable that receives the
        recomputed wait interval.

Return Value:

    A pointer to the new time is returned as the function value.

--*/

{

    //
    // If the original wait time was absolute, then return the same
    // absolute time. Otherwise, reduce the wait time remaining before
    // the time delay expires.
    //

    if (OriginalTime->QuadPart >= 0) {
        return OriginalTime;

    } else {
        KiQueryInterruptTime(NewTime);
        NewTime->QuadPart -= DueTime->QuadPart;
        return NewTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\thredsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    thredsup.c

Abstract:

    This module contains the support routines for the thread object. It
    contains functions to boost the priority of a thread, find a ready
    thread, select the next thread, ready a thread, set priority of a
    thread, and to suspend a thread.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    All of the functions in this module execute in kernel mode except
    the function that raises a user mode alert condition.

Revision History:


--*/

#include "ki.h"

//
// Define context switch data collection macro.
//

//#define _COLLECT_SWITCH_DATA_ 1

#if defined(_COLLECT_SWITCH_DATA_)

#define KiIncrementSwitchCounter(Member) KeThreadSwitchCounters.Member += 1

#else

#define KiIncrementSwitchCounter(Member)

#endif

VOID
KiSuspendNop (
    IN PKAPC Apc,
    IN OUT PKNORMAL_ROUTINE *NormalRoutine,
    IN OUT PVOID *NormalContext,
    IN OUT PVOID *SystemArgument1,
    IN OUT PVOID *SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC for a
    thread. It is executed in kernel mode as the result of queuing the
    builtin suspend APC and performs no operation. It is called just prior
    to calling the normal routine and simply returns.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

    NormalRoutine - not used

    NormalContext - not used

    SystemArgument1 - not used

    SystemArgument2 - not used

Return Value:

    None.

--*/

{

    //
    // No operation is performed by this routine.
    //

    return;
}

PKTHREAD
FASTCALL
KiFindReadyThread (
    IN KPRIORITY LowPriority
    )

/*++

Routine Description:

    This function searches the dispatcher ready queues from the specified
    high priority to the specified low priority in an attempt to find a thread
    that can execute on the specified processor.

Arguments:

    Processor - Supplies the number of the processor to find a thread for.

    LowPriority - Supplies the lowest priority dispatcher ready queue to
        examine.

Return Value:

    If a thread is located that can execute on the specified processor, then
    the address of the thread object is returned. Otherwise a null pointer is
    returned.

--*/

{

    ULONG HighPriority;
    PRLIST_ENTRY ListHead;
    PRLIST_ENTRY NextEntry;
    ULONG PrioritySet;
    PRKTHREAD Thread;

    //
    // Compute the set of priority levels that should be scanned in an attempt
    // to find a thread that can run on the specified processor.
    //

    PrioritySet = (~((1 << LowPriority) - 1)) & KiReadySummary;

    FindFirstSetLeftMember(PrioritySet, &HighPriority);
    ListHead = &KiDispatcherReadyListHead[HighPriority];
    PrioritySet <<= (31 - HighPriority);
    while (PrioritySet != 0) {

        //
        // If the next bit in the priority set is a one, then examine the
        // corresponding dispatcher ready queue.
        //

        if ((LONG)PrioritySet < 0) {
            NextEntry = ListHead->Flink;

            ASSERT(NextEntry != ListHead);

            Thread = CONTAINING_RECORD(NextEntry, KTHREAD, WaitListEntry);
            RemoveEntryList(&Thread->WaitListEntry);
            if (IsListEmpty(ListHead)) {
                ClearMember(HighPriority, KiReadySummary);
            }

            return (PKTHREAD)Thread;
        }

        HighPriority -= 1;
        ListHead -= 1;
        PrioritySet <<= 1;
    };

    //
    // No thread could be found, return a null pointer.
    //

    return (PKTHREAD)NULL;
}

VOID
FASTCALL
KiReadyThread (
    IN PRKTHREAD Thread
    )

/*++

Routine Description:

    This function readies a thread for execution and attempts to immediately
    dispatch the thread for execution by preempting another lower priority
    thread. If a thread can be preempted, then the specified thread enters
    the standby state and the target processor is requested to dispatch. If
    another thread cannot be preempted, then the specified thread is inserted
    either at the head or tail of the dispatcher ready selected by its priority
    acccording to whether it was preempted or not.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{

    PRKPRCB Prcb;
    BOOLEAN Preempted;
    KPRIORITY ThreadPriority;
    PRKTHREAD Thread1;

    //
    // Save value of thread's preempted flag, set thread preempted FALSE,
    // capture the thread priority, and set clear the read wait time.
    //

    Preempted = Thread->Preempted;
    Thread->Preempted = FALSE;
    ThreadPriority = Thread->Priority;
    Thread->WaitTime = KiQueryLowTickCount();

    //
    // If there is an idle processor, then schedule the thread on an
    // idle processor giving preference to the processor the thread
    // last ran on. Otherwise, try to preempt either a thread in the
    // standby or running state.
    //

    Prcb = KeGetCurrentPrcb();
    if (KiIdleSummary != 0) {
        KiIdleSummary = 0;
        KiIncrementSwitchCounter(IdleLast);
        Prcb->NextThread = Thread;
        Thread->State = Standby;

        return;

    } else {

        if (Prcb->NextThread != NULL) {
            Thread1 = Prcb->NextThread;
            if (ThreadPriority > Thread1->Priority) {
                Thread1->Preempted = TRUE;
                Prcb->NextThread = Thread;
                Thread->State = Standby;
                KiReadyThread(Thread1);
                KiIncrementSwitchCounter(PreemptLast);
                return;
            }

        } else {
            Thread1 = Prcb->CurrentThread;
            if (ThreadPriority > Thread1->Priority) {
                Thread1->Preempted = TRUE;
                Prcb->NextThread = Thread;
                Thread->State = Standby;
                KiRequestDispatchInterrupt();
                KiIncrementSwitchCounter(PreemptLast);
                return;
            }
        }
    }

    //
    // No thread can be preempted. Insert the thread in the dispatcher
    // queue selected by its priority. If the thread was preempted and
    // runs at a realtime priority level, then insert the thread at the
    // front of the queue. Else insert the thread at the tail of the queue.
    //

    Thread->State = Ready;
    if (Preempted != FALSE) {
        InsertHeadList(&KiDispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);

    } else {
        InsertTailList(&KiDispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);
    }

    SetMember(ThreadPriority, KiReadySummary);
    return;
}

PRKTHREAD
FASTCALL
KiSelectNextThread (
    IN PRKTHREAD Thread
    )

/*++

Routine Description:

    This function selects the next thread to run on the processor that the
    specified thread is running on. If a thread cannot be found, then the
    idle thread is selected.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    The address of the selected thread object.

--*/

{

    PRKPRCB Prcb;
    PRKTHREAD Thread1;

    //
    // Get the processor number and the address of the processor control block.
    //

    Prcb = KeGetCurrentPrcb();

    //
    // If a thread has already been selected to run on the specified processor,
    // then return that thread as the selected thread.
    //

    if ((Thread1 = Prcb->NextThread) != NULL) {
        Prcb->NextThread = (PKTHREAD)NULL;

    } else {

        //
        // Attempt to find a ready thread to run.
        //

        Thread1 = KiFindReadyThread(0);

        //
        // If a thread was not found, then select the idle thread and
        // set the processor member in the idle summary.
        //

        if (Thread1 == NULL) {
            KiIncrementSwitchCounter(SwitchToIdle);
            Thread1 = Prcb->IdleThread;

            KiIdleSummary = 1;
        }
    }

    //
    // Return address of selected thread object.
    //

    return Thread1;
}

VOID
FASTCALL
KiSetPriorityThread (
    IN PRKTHREAD Thread,
    IN KPRIORITY Priority
    )

/*++

Routine Description:

    This function set the priority of the specified thread to the specified
    value. If the thread is in the standby or running state, then the processor
    may be redispatched. If the thread is in the ready state, then some other
    thread may be preempted.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new thread priority value.

Return Value:

    None.

--*/

{

    PRKPRCB Prcb;
    KPRIORITY ThreadPriority;
    PRKTHREAD Thread1;

    ASSERT(Priority <= HIGH_PRIORITY);

    //
    // Capture the current priority of the specified thread.
    //

    ThreadPriority = Thread->Priority;

    //
    // If the new priority is not equal to the old priority, then set the
    // new priority of the thread and redispatch a processor if necessary.
    //

    if (Priority != ThreadPriority) {
        Thread->Priority = (SCHAR)Priority;

        //
        // Case on the thread state.
        //

        switch (Thread->State) {

            //
            // Ready case - Remove the thread from its current dispatcher ready
            // queue. If the new priority is less than the old priority, then
            // insert the thread at the tail of the dispatcher ready queue
            // selected by the new priority. Else reready the thread for
            // execution.
            //

        case Ready:
            RemoveEntryList(&Thread->WaitListEntry);
            if (IsListEmpty(&KiDispatcherReadyListHead[ThreadPriority])) {
                ClearMember(ThreadPriority, KiReadySummary);
            }

            if (Priority < ThreadPriority) {
                InsertTailList(&KiDispatcherReadyListHead[Priority],
                               &Thread->WaitListEntry);
                SetMember(Priority, KiReadySummary);

            } else {
                KiReadyThread(Thread);
            }

            break;

            //
            // Standby case - If the thread's priority is being lowered, then
            // attempt to find another thread to execute. If a new thread is
            // found, then put the new thread in the standby state, and reready
            // the old thread.
            //

        case Standby:

            if (Priority < ThreadPriority) {

                Thread1 = KiFindReadyThread(Priority);

                if (Thread1 != NULL) {

                    Prcb = KeGetCurrentPrcb();

                    Thread1->State = Standby;
                    Prcb->NextThread = Thread1;
                    KiReadyThread(Thread);
                }
            }

            break;

            //
            // Running case - If there is not a thread in the standby state
            // on the thread's processor and the thread's priority is being
            // lowered, then attempt to find another thread to execute. If
            // a new thread is found, then put the new thread in the standby
            // state, and request a redispatch on the thread's processor.
            //

        case Running:

            Prcb = KeGetCurrentPrcb();

            if (Prcb->NextThread == NULL) {
                if (Priority < ThreadPriority) {

                    Thread1 = KiFindReadyThread(Priority);

                    if (Thread1 != NULL) {
                        Thread1->State = Standby;
                        Prcb->NextThread = Thread1;
                    }
                }
            }

            break;

            //
            // Initialized, Terminated, Waiting, Transition case - For
            // these states it is sufficient to just set the new thread
            // priority.
            //

        default:
            break;
        }
    }

    return;
}

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC of a
    thread. It is executed in kernel mode as the result of queuing the builtin
    suspend APC and suspends thread execution by Waiting nonalertable on the
    thread's builtin suspend semaphore. When the thread is resumed, execution
    of thread is continued by simply returning.

Arguments:

    Apc - Supplies a pointer to a control object of type APC.

Return Value:

    None.

--*/

{

    PRKTHREAD Thread;

    //
    // Get the address of the current thread object and Wait nonalertable on
    // the thread's builtin suspend semaphore.
    //

    Thread = KeGetCurrentThread();

    KeWaitForSingleObject(&Thread->SuspendSemaphore,
                          Suspended,
                          KernelMode,
                          FALSE,
                          (PLARGE_INTEGER)NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\waitsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    waitsup.c

Abstract:

    This module contains the support routines necessary to support the
    generic kernel wait functions. Functions are provided to test if a
    wait can be satisfied, to satisfy a wait, and to unwwait a thread.

Author:

    David N. Cutler (davec) 24-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
FASTCALL
KiUnwaitThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function unwaits a thread, sets the thread's wait completion status,
    calculates the thread's new priority, and readies the thread for execution.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    WaitStatus - Supplies the wait completion status.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

Return Value:

    None.

--*/

{

    KPRIORITY NewPriority;
    PKPROCESS Process;
    PKQUEUE Queue;
    PKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;

    //
    // Set wait completion status, remove wait blocks from object wait
    // lists, and remove thread from wait list.
    //

    Thread->WaitStatus |= WaitStatus;
    WaitBlock = Thread->WaitBlockList;
    do {
        RemoveEntryList(&WaitBlock->WaitListEntry);
        WaitBlock = WaitBlock->NextWaitBlock;
    } while (WaitBlock != Thread->WaitBlockList);

    RemoveEntryList(&Thread->WaitListEntry);

    //
    // If thread timer is still active, then cancel thread timer.
    //

    Timer = &Thread->Timer;
    if (Timer->Header.Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // If the thread is processing a queue entry, then increment the
    // count of currently active threads.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        Queue->CurrentCount += 1;
    }

    //
    // If the thread runs at a realtime priority level, then reset the
    // thread quantum. Otherwise, compute the next thread priority and
    // charge the thread for the wait operation.
    //

    Process = Thread->ApcState.Process;
    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        if ((Thread->PriorityDecrement == 0) &&
            (Thread->DisableBoost == FALSE)) {
            NewPriority = Thread->BasePriority + Increment;

            if (NewPriority > Thread->Priority) {
                if (NewPriority >= LOW_REALTIME_PRIORITY) {
                    Thread->Priority = LOW_REALTIME_PRIORITY - 1;

                } else {
                    Thread->Priority = (SCHAR)NewPriority;
                }
            }
        }

        if (Thread->BasePriority >= TIME_CRITICAL_PRIORITY_BOUND) {
            Thread->Quantum = Process->ThreadQuantum;

        } else {
            Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
            if (Thread->Quantum <= 0) {
                Thread->Quantum = Process->ThreadQuantum;
                Thread->Priority -= (Thread->PriorityDecrement + 1);
                if (Thread->Priority < Thread->BasePriority) {
                    Thread->Priority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;
            }
        }

    } else {
        Thread->Quantum = Process->ThreadQuantum;
    }

    //
    // Reready the thread for execution.
    //

    KiReadyThread(Thread);
    return;
}

VOID
KeBoostCurrentThread(
    VOID
    )

/*++

Routine Description:

    This function boosts the priority of the current thread for one quantum,
    then reduce the thread priority to the base priority of the thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD Thread;

    //
    // Get current thread address, raise IRQL to synchronization level, and
    // lock the dispatcher database
    //

    Thread = KeGetCurrentThread();

redoboost:
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If a priority boost is not already active for the current thread
    // and the thread priority is less than 14, then boost the thread
    // priority to 14 and give the thread a large quantum. Otherwise,
    // if a priority boost is active, then decrement the round trip
    // count. If the count goes to zero, then release the dispatcher
    // database lock, lower the thread priority to the base priority,
    // and then attempt to boost the priority again. This will give
    // other threads a chance to run. If the count does not reach zero,
    // then give the thread another large qunatum.
    //
    // If the thread priority is above 14, then no boost is applied.
    //

    if ((Thread->PriorityDecrement == 0) && (Thread->Priority < 14)) {
        Thread->PriorityDecrement = 14 - Thread->BasePriority;
        Thread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
        Thread->Priority = 14;
        Thread->Quantum = Thread->ApcState.Process->ThreadQuantum * 2;

    } else if (Thread->PriorityDecrement != 0) {
        Thread->DecrementCount -= 1;
        if (Thread->DecrementCount == 0) {
            KiUnlockDispatcherDatabase(OldIrql);
            KeSetPriorityThread(Thread, Thread->BasePriority);
            goto redoboost;

        } else {
            Thread->Quantum = Thread->ApcState.Process->ThreadQuantum * 2;
        }
    }

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

VOID
FASTCALL
KiWaitSatisfyAll (
    IN PRKWAIT_BLOCK WaitBlock
    )

/*++

Routine Description:

    This function satisfies a wait all and performs any side effects that
    are necessary.

Arguments:

    WaitBlock - Supplies a pointer to a wait block.

Return Value:

    None.

--*/

{

    PKMUTANT Object;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock1;

    //
    // If the wait type was WaitAny, then perform neccessary side effects on
    // the object specified by the wait block. Else perform necessary side
    // effects on all the objects that were involved in the wait operation.
    //

    WaitBlock1 = WaitBlock;
    Thread = WaitBlock1->Thread;
    do {
        if (WaitBlock1->WaitKey != (CSHORT)STATUS_TIMEOUT) {
            Object = (PKMUTANT)WaitBlock1->Object;
            KiWaitSatisfyAny(Object, Thread);
        }

        WaitBlock1 = WaitBlock1->NextWaitBlock;
    } while (WaitBlock1 != WaitBlock);

    return;
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function tests if a wait can be satisfied when an object attains
    a state of signaled. If a wait can be satisfied, then the subject thread
    is unwaited with a completion status that is the WaitKey of the wait
    block from the object wait list. As many waits as possible are satisfied.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

Return Value:

    None.

--*/

{

    PKEVENT Event;
    PLIST_ENTRY ListHead;
    PRKWAIT_BLOCK NextBlock;
    PKMUTANT Mutant;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;

    //
    // As long as the signal state of the specified object is Signaled and
    // there are waiters in the object wait list, then try to satisfy a wait.
    //

    Event = (PKEVENT)Object;
    ListHead = &Event->Header.WaitListHead;
    WaitEntry = ListHead->Flink;
    while ((Event->Header.SignalState > 0) &&
           (WaitEntry != ListHead)) {
        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;
        if (WaitBlock->WaitType != WaitAny) {

            //
            // The wait type is wait all - if all the objects are in
            // a Signaled state, then satisfy the wait.
            //

            NextBlock = WaitBlock->NextWaitBlock;
            while (NextBlock != WaitBlock) {
                if (NextBlock->WaitKey != (CSHORT)(STATUS_TIMEOUT)) {
                    Mutant = (PKMUTANT)NextBlock->Object;
                    if ((Mutant->Header.Type == MutantObject) &&
                        (Mutant->Header.SignalState <= 0) &&
                        (Thread == Mutant->OwnerThread)) {
                        goto next;

                    } else if (Mutant->Header.SignalState <= 0) {
                        goto scan;
                    }
                }

            next:
                NextBlock = NextBlock->NextWaitBlock;
            }

            //
            // All objects associated with the wait are in the Signaled
            // state - satisfy the wait.
            //

            WaitEntry = WaitEntry->Blink;
            KiWaitSatisfyAll(WaitBlock);

        } else {

            //
            // The wait type is wait any - satisfy the wait.
            //

            WaitEntry = WaitEntry->Blink;
            KiWaitSatisfyAny((PKMUTANT)Event, Thread);
        }

        KiUnwaitThread(Thread, (NTSTATUS)WaitBlock->WaitKey, Increment);

    scan:
        WaitEntry = WaitEntry->Flink;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\clockint.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    clockint.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.  It works on UP and SystemPro.
;
;--

.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include i386\ix8259.inc
        .list

        EXTRNP  HalBeginClockInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,,FASTCALL
        extrn   _KiTimerTableListHead:DWORD
        extrn   _KiTimerExpireDpc:DWORD
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint
        EXTRNP  _DbgBreakPointWithStatus,1
        extrn   _KiPCR:DWORD
        extrn   _KiIdleThread:DWORD
        extrn   _KeTickCount:DWORD
        extrn   _KeInterruptTime:DWORD
        extrn   _KeSystemTime:DWORD

if DBG
        extrn   _DbgPrint:near
        extrn   _KiDPCTimeout:DWORD
        extrn   _MsgDpcTimeout:BYTE
endif

ifdef DEVKIT
        EXTRNP  _KdPollBreakIn
        extrn   _KiDbgClockInt:DWORD
endif

        page ,132
        subttl  "Update System Time"

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; KeClockInterrupt(
;       VOID
;       )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK.
;    Its function is to update the system time and check to determine if a timer
;    has expired.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
cPublicProc _KeClockInterrupt     ,0

;
; Save machine state in trap frame.
;

        ENTER_INTERRUPT

;
; (esp) - base of trap frame
; (ebp) - base of trap frame
;

;
; Dismiss interrupt and raise irq level to CLOCK_LEVEL.
;

.errnz CLOCK_VECTOR - PRIMARY_VECTOR_BASE
        xor     ecx, ecx
        mov     edx, CLOCK_LEVEL
        push    ecx                     ; allocate space to save OldIrql
        fstCall HalBeginClockInterrupt

ifdef DEVKIT
;
; Call the debugger's clock interrupt routine if there is one.
;
        mov     esi,_KiDbgClockInt
        test    esi, esi
        jz      kust_nodbgr
        push    ebp
        call    esi
kust_nodbgr:
endif

;
; Update interrupt time.
;
; N.B. The interrupt time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     edi,_KeInterruptTime+0  ; get low interrupt time
        mov     esi,_KeInterruptTime+4  ; get high interrupt time
        mov     ebx,_KeTickCount        ; get tick count
        add     edi,CLOCK_TIME_INCREMENT; add time increment
        adc     esi,0                   ; propagate carry
        mov     _KeInterruptTime+8,esi  ; store high 2 interrupt time
        mov     _KeInterruptTime+0,edi  ; store low interrupt time
        mov     _KeInterruptTime+4,esi  ; store high 1 interrupt time

;
; Update system time.
;
; N.B. The system time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     ecx,_KeSystemTime+0     ; get low interrupt time
        mov     edx,_KeSystemTime+4     ; get high interrupt time
        add     ecx,CLOCK_TIME_INCREMENT; add time increment
        adc     edx,0                   ; propagate carry
        mov     _KeSystemTime+8,edx     ; store high 2 interrupt time
        mov     _KeSystemTime+0,ecx     ; store low interrupt time
        mov     _KeSystemTime+4,edx     ; store high 1 interrupt time

;
; Update tick count.
;

        mov     eax,ebx                 ; copy tick count
        mov     ecx,ebx                 ; copy tick count
        inc     ecx                     ; increment tick count
        mov     _KeTickCount,ecx        ; store low tick count

;
; Check to determine if a timer has expired.
; (edi:esi) = KiInterruptTime
; (eax) = bucket
; (ebx) = KeTickCount.LowPart
;

kust10: and     eax,TIMER_TABLE_SIZE-1  ; isolate current hand value
        lea     ecx,_KiTimerTableListHead[eax*8] ; get listhead addrees
        mov     edx,[ecx]               ; get first entry address
        cmp     ecx,edx                 ; check if list is empry
        je      kustxx                  ; if equal, list is empty
        cmp     esi,[edx].TiDueTime.TmHighTime-TiTimerListEntry ; compare high
        jb      kustxx                  ; if below, timer has not expired
        ja      short kust15            ; if above, timer has expired
        cmp     edi,[edx].TiDueTime.TmLowTime-TiTimerListEntry ; compare low
        jb      kustxx                  ; if below, timer has not expired

kust15:
;
; Timer has expired, put timer expiration DPC in the current processor's DPC
; queue.
;
; (ebx) = KeTickCount.LowPart
;

        lea     eax,_KiTimerExpireDpc+DpDpcListEntry ; get list entry address
        cmp     byte ptr [eax]+(DpInserted-DpDpcListEntry), 0H ; check if inserted
        jnz     kustxx                  ; if nz, DPC already inserted

        cli

        mov     byte ptr [eax]+(DpInserted-DpDpcListEntry), 1 ; mark as inserted
        mov     [eax]+(DpSystemArgument1-DpDpcListEntry),ebx  ; pass tick count
        lea     ecx,PCR[PcPrcbData+PbDpcListHead] ; compute DPC listhead address
        mov     ebx,[ecx]+LsBlink       ; get address of last entry in list
        mov     [ecx]+LsBlink, eax      ; set new address of last entry
        mov     [ebx]+LsFlink, eax      ; set forward link in old last entry
        mov     [eax]+LsFlink, ecx      ; set forward link in new last entry
        mov     [eax]+LsBlink, ebx      ; set backward link in new last entry

        sti                             ; enable interrupt

; request dispatch interrupt

        mov     ecx, DISPATCH_LEVEL
        fstCall HalRequestSoftwareInterrupt

kustxx:
ifdef DEVKIT
        cmp     _KdDebuggerEnabled, 0
        jz      kust30
        stdCall _KdPollBreakIn
        test    al,al
        jz      kust30
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
kust30:
endif

;
; inline KeUpdateRunTime to do the actual work
;

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]
        mov     ebx, PCR[PcPrcbData+PbCurrentThread] ; (ebx)->current thread

;
; Update the total time spent in kernel mode
;

        cmp     byte ptr [esp], DISPATCH_LEVEL
        jc      short Kutp4             ; OldIrql<2, then kernel
        ja      short Kutp3             ; OldIrql>2, then interrupt

        cmp     dword ptr PCR[PcPrcbData.PbDpcRoutineActive], 0
        jz      short Kutp4             ; Executing Dpc?, no then thread time

        inc     dword ptr PCR[PcPrcbData.PbDpcTime]
if DBG
;
; Check for dpcs which run for too long
;

        inc     dword ptr PCR[PcPrcbData.PbDebugDpcTime]
        mov     edx, _KiDPCTimeout
        cmp     dword ptr PCR[PcPrcbData.PbDebugDpcTime], edx
        jc      Kutp55                  ; Jump if not over limit

;
; Dpc time has exceeded the allowed quanta
;

        push    offset FLAT:_MsgDpcTimeout ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 1 * 4              ; remove arguments from stack

        cmp     _KdDebuggerEnabled, 0   ; check if debugger enabled
        je      short Kutp6             ; if eq, no debugger, continue
        stdCall _DbgBreakPoint          ; break into debugger

Kutp6:  mov     dword ptr PCR[PcPrcbData.PbDebugDpcTime], 0 ; Reset Time
endif
        jmp     Kutp55

ALIGN 4
Kutp3:
;
; Update the time spent at interrupt time for this processor
;

        inc     dword ptr PCR[PcPrcbData.PbInterruptTime]
        jmp     Kutp55

ALIGN 4
Kutp4:

;
; Update the time spent in kernel mode for the current thread.
;

        inc     dword ptr [ebx]+ThKernelTime

;
; Decrement current thread quantum and check to determine if a quantum end
; has occurred.
;

ALIGN 4
Kutp55: sub     dword ptr [ebx]+ThQuantum, CLOCK_QUANTUM_DECREMENT ; decrement quantum
        jg      Kutp75                      ; if > 0, time remaining on quantum

;
; Set quantum end flag and initiate a dispather interrupt on the current
; processor.
;

        cmp     ebx,offset FLAT:_KiIdleThread ; check if idle thread
        jz      Kutp75                      ; if z, then idle thread
        mov     PCR[PcPrcbData.PbQuantumEnd], esp ; set quantum end indicator
        mov     ecx, DISPATCH_LEVEL         ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
Kutp75:                                     ;

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT

stdENDP _KeClockInterrupt

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\yield.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    yield.c

Abstract:

    This module implements the function to yield execution for one quantum
    to any other runnable thread.

Author:

    David N. Cutler (davec) 15-Mar-1996

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

NTSTATUS
NtYieldExecution (
    VOID
    )

/*++

Routine Description:

    This function yields execution to any ready thread for up to one
    quantum.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PRKPRCB Prcb;
    KPRIORITY Priority;
    NTSTATUS Status;
    PRKTHREAD Thread;

    //
    // If any other threads are ready, then attempt to yield execution.
    //

    Status = STATUS_NO_YIELD_PERFORMED;
    if (KiReadySummary != 0) {

        //
        // If a thread has not already been selected for execution, then
        // attempt to select another thread for execution.
        //

        Thread = KeGetCurrentThread();
        KiLockDispatcherDatabase(&Thread->WaitIrql);
        Prcb = KeGetCurrentPrcb();
        if (Prcb->NextThread == NULL) {
            Prcb->NextThread = KiFindReadyThread(1);
        }

        //
        // If a new thread has been selected for execution, then switch
        // immediately to the selected thread.
        //

        if (Prcb->NextThread != NULL) {

            //
            // Give the current thread a new quantum, simulate a quantum
            // end, insert the current thread in the appropriate ready list,
            // and switch context to selected thread.
            //

            Thread->Quantum = Thread->ApcState.Process->ThreadQuantum;
            Thread->State = Ready;
            Priority = Thread->Priority;
            if (Priority < LOW_REALTIME_PRIORITY) {
                Priority = Priority - Thread->PriorityDecrement - 1;
                if (Priority < Thread->BasePriority) {
                    Priority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;

            }

            Thread->Priority = (SCHAR)Priority;

            InsertTailList(&KiDispatcherReadyListHead[Priority],
                           &Thread->WaitListEntry);

            SetMember(Priority, KiReadySummary);
            KiSwapThread();
            Status = STATUS_SUCCESS;

        } else {
            KiUnlockDispatcherDatabase(Thread->WaitIrql);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;        Some of the code is extracted from Cruiser (mainly,
;        the code to determine 386 stepping.)
;
; Environment:
;
;    80x86
;
; Revision History:
;
;--

        .xlist
include ks386.inc
include callconv.inc
        .list

.586p

_TEXT   SEGMENT DWORD PUBLIC 'CODE'      ; Put IdleLoop in text section
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; ULONGLONG
; FASTCALL
; RDMSR (
;   IN ULONG MsrRegister
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicFastCall RDMSR, 1
    rdmsr
    fstRET  RDMSR
fstENDP RDMSR


;++
;
; VOID
; WRMSR (
;   IN ULONG MsrRegister
;   IN LONGLONG MsrValue
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _WRMSR, 3
    mov     ecx, [esp+4]
    mov     eax, [esp+8]
    mov     edx, [esp+12]
    wrmsr
    stdRET  _WRMSR
stdENDP _WRMSR

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\i386pcr.asm ===
title  "I386 PCR"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    i386pcr.asm
;
; Abstract:
;
;    This module implements routines for accessing and initing the pcr.
;
; Author:
;
;    Bryan Willman (bryanwi) 20 Mar 90
;
; Environment:
;
;    Kernel mode, early init of first processor.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

        extrn   _KiPCR:DWORD

;
;   NOTE - This definition of PCR gives us 2 instructions to get to some
;       variables that need to be addressable in one instruction.  Any
;       such variable (such as current thread) must be accessed via its
;       own access procedure (see below), NOT by KeGetPcr()->PbCurrentThread.
;       (This is only an issue on MP machines.)
;

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc _KeGetPcr ,0

        lea     eax,_KiPCR
        stdRET    _KeGetPcr

stdENDP _KeGetPcr


;++
;
; PKPRCB
; KeGetCurrentPrcb()
;
; Return Value:
;
;   Pointer to current PRCB.
;
;--
cPublicProc _KeGetCurrentPrcb   ,0

        mov     eax,PCR[PcPrcb]
        stdRET    _KeGetCurrentPrcb

stdENDP _KeGetCurrentPrcb


;++
;
; PKTHREAD
; KeGetCurrentThread()
;
; Return Value:
;
;   Pointer to current Thread object.
;
;--
cPublicProc _KeGetCurrentThread   ,0

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        stdRET    _KeGetCurrentThread

stdENDP _KeGetCurrentThread


;++
;
; BOOLEAN
; KeIsExecutingDpc(
;       VOID
;       );
;
; Return Value:
;
;   Value of flag which indicates whether we're executing in DPC context
;
;--

cPublicProc _KeIsExecutingDpc   ,0

        mov     eax,PCR[PcPrcbData.PbDpcRoutineActive]
        stdRET    _KeIsExecutingDpc

stdENDP _KeIsExecutingDpc

_TEXT   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\exceptn.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch expections to the
    proper mode and invoke the exception dispatcher.

--*/

#include "ki.h"

#define FN_BITS_PER_TAGWORD     16
#define FN_TAG_EMPTY            0x3
#define FN_TAG_MASK             0x3
#define FX_TAG_VALID            0x1
#define NUMBER_OF_FP_REGISTERS  8
#define BYTES_PER_FP_REGISTER   10
#define BYTES_PER_FX_REGISTER   16

ULONG
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct esp from a trapframe, accounting
    for whether the frame is a user or kernel mode frame, and whether
    it has been edited.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of Esp.

--*/

{
    if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

        //  Kernel mode frame which has had esp edited,
        //  value of Esp is in TempEsp.

        return TrapFrame->TempEsp;

    } else {

        //  Kernel mode frame has has not had esp edited, compute esp.

        return (ULONG)&TrapFrame->HardwareEsp;
    }
}

VOID
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    )

/*++

Routine Description:

    This routine sets the specified value Esp into the trap frame,
    accounting for whether the frame is a user or kernel mode frame,
    and whether it has been edited before.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    Esp - New value for Esp.

Return Value:

    None.

--*/
{
    ULONG   OldEsp;

    OldEsp = KiEspFromTrapFrame(TrapFrame);

    //
    //  Kernel mode esp can't be lowered or iret emulation will fail
    //

    if (Esp < OldEsp)
        KeBugCheck(SET_OF_INVALID_CONTEXT);

    //
    //  Edit frame, setting edit marker as needed.
    //

    if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

        //  Kernel frame that has already been edited,
        //  store value in TempEsp.

        TrapFrame->TempEsp = Esp;

    } else {

        //  Kernel frame for which Esp is being edited first time.
        //  Save real SegCs, set marked in SegCs, save Esp value.

        if (OldEsp != Esp) {
            TrapFrame->TempSegCs = TrapFrame->SegCs;
            TrapFrame->SegCs = TrapFrame->SegCs & ~FRAME_EDITED;
            TrapFrame->TempEsp = Esp;
        }
    }
}

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception frames
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        ContextFrame->Ebp = TrapFrame->Ebp;
        ContextFrame->Eip = TrapFrame->Eip;

        if (((TrapFrame->SegCs & FRAME_EDITED) == 0) &&
            ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0)) {
            ContextFrame->SegCs = TrapFrame->TempSegCs & SEGMENT_MASK;
        } else {
            ContextFrame->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
        }
        ContextFrame->EFlags = TrapFrame->EFlags;
        ContextFrame->SegSs = KGDT_R0_DATA;
        ContextFrame->Esp = KiEspFromTrapFrame(TrapFrame);
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        ContextFrame->Edi = TrapFrame->Edi;
        ContextFrame->Esi = TrapFrame->Esi;
        ContextFrame->Ebx = TrapFrame->Ebx;
        ContextFrame->Ecx = TrapFrame->Ecx;
        ContextFrame->Edx = TrapFrame->Edx;
        ContextFrame->Eax = TrapFrame->Eax;
    }

    //
    // Set extended register contents if specified.
    //

    if (((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) ||
        ((ContextFrame->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)) {

        KiFlushNPXState();

        NpxFrame = (PFX_SAVE_AREA)KeGetPcr()->NtTib.StackBase;

        RtlCopyMemory( &ContextFrame->FloatSave,
                       &NpxFrame->FloatSave,
                       sizeof(FLOATING_SAVE_AREA) );
    }
}

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers eflag, ebp, eip, cs, esp and ss.
        // Eflags is set first, so that the auxilliary routines
        // can check the v86 bit to determine as well as cs, to
        // determine if the frame is kernel or user mode. (v86 mode cs
        // can have any value)
        //

        TrapFrame->EFlags = SANITIZE_FLAGS(ContextFrame->EFlags);
        TrapFrame->Ebp = ContextFrame->Ebp;
        TrapFrame->Eip = ContextFrame->Eip;
        KiEspToTrapFrame(TrapFrame, ContextFrame->Esp);
    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax.
        //
        //  Can NOT call RtlMoveMemory here because the regs aren't
        //  contiguous in pusha frame, and we don't want to export
        //  bits of junk into context record.
        //

        TrapFrame->Edi = ContextFrame->Edi;
        TrapFrame->Esi = ContextFrame->Esi;
        TrapFrame->Ebx = ContextFrame->Ebx;
        TrapFrame->Ecx = ContextFrame->Ecx;
        TrapFrame->Edx = ContextFrame->Edx;
        TrapFrame->Eax = ContextFrame->Eax;
    }

    //
    // Set extended register contents if requested.
    //

    if (((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) ||
        ((ContextFrame->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)) {

        KiFlushNPXState();

        NpxFrame = (PFX_SAVE_AREA)KeGetPcr()->NtTib.StackBase;

        RtlCopyMemory( &NpxFrame->FloatSave,
                       &ContextFrame->FloatSave,
                       sizeof(FLOATING_SAVE_AREA) );

        //
        // Make sure only valid floating state bits are moved to Cr0NpxState.
        //

        NpxFrame->FloatSave.Cr0NpxState &= ~(CR0_EM | CR0_MP | CR0_TS);

        //
        // Make sure all reserved bits are clear in MXCSR so we don't get a GP
        // fault when doing an FRSTOR on this state.
        //

        NpxFrame->FloatSave.MXCsr = SANITIZE_MXCSR(NpxFrame->FloatSave.MXCsr);
    }
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called. If the previous mode is
    kernel, then the exception dispatcher is called directly to process the
    exception. Otherwise the exception record, exception frame, and trap
    frame contents are copied to the user mode stack. The contents of the
    exception frame and trap are then modified such that when control is
    returned, execution will commense in user mode in a routine which will
    call the exception dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{
    CONTEXT ContextFrame;

    //
    // Move machine state from trap and exception frames to a context frame,
    // and increment the number of exceptions dispatched.
    //

    ContextFrame.ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER |
        CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS;

    KeContextFromKframes(TrapFrame, &ContextFrame);

    //
    // if it is BREAK_POINT exception, we subtract 1 from EIP and report
    // the updated EIP to user.  This is because Cruiser requires EIP
    // points to the int 3 instruction (not the instruction following int 3).
    // In this case, BreakPoint exception is fatal. Otherwise we will step
    // on the int 3 over and over again, if user does not handle it
    //
    // if the BREAK_POINT occured in V86 mode, the debugger running in the
    // VDM will expect CS:EIP to point after the exception (the way the
    // processor left it.  this is also true for protected mode dos
    // app debuggers.  We will need a way to detect this.
    //
    //

    switch (ExceptionRecord->ExceptionCode) {
        case STATUS_BREAKPOINT:
            ContextFrame.Eip--;
            break;
    }

    //
    // Previous mode was kernel.
    //
    // If the kernel debugger is active, then give the kernel debugger the
    // first chance to handle the exception. If the kernel debugger handles
    // the exception, then continue execution. Else attempt to dispatch the
    // exception to a frame based handler. If a frame based handler handles
    // the exception, then continue execution.
    //
    // If a frame based handler does not handle the exception,
    // give the kernel debugger a second chance, if it's present.
    //
    // If the exception is still unhandled, call KeBugCheck().
    //

    if (FirstChance == TRUE) {

        if ((KiDebugRoutine != NULL) &&
           (((KiDebugRoutine) (TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               &ContextFrame,
                               FALSE)) != FALSE)) {

            goto Handled1;
        }

        // Kernel debugger didn't handle exception.

        if (RtlDispatchException(ExceptionRecord, &ContextFrame) == TRUE) {
            goto Handled1;
        }
    }

    //
    // This is the second chance to handle the exception.
    //

    if ((KiDebugRoutine != NULL) &&
        (((KiDebugRoutine) (TrapFrame,
                            ExceptionFrame,
                            ExceptionRecord,
                            &ContextFrame,
                            TRUE)) != FALSE)) {

        goto Handled1;
    }

    KeBugCheckEx(
        KMODE_EXCEPTION_NOT_HANDLED,
        ExceptionRecord->ExceptionCode,
        (ULONG)ExceptionRecord->ExceptionAddress,
        ExceptionRecord->ExceptionInformation[0],
        ExceptionRecord->ExceptionInformation[1]
        );

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:
    KeContextToKframes(TrapFrame, &ContextFrame, ContextFrame.ContextFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\ctxswap.asm ===
title  "Context Swap"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ctxswap.asm
;
; Abstract:
;
;    This module implements the code necessary to field the dispatch
;    interrupt and to perform kernel initiated context switching.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 14-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   22-feb-90   bryanwi
;       write actual swap context procedure
;
;--

.486p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  HalClearSoftwareInterrupt,1,,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,,FASTCALL
        EXTRNP  KiReadyThread,1,,FASTCALL
        EXTRNP  KiWaitTest,2,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _KeGetCurrentThread,0
        EXTRNP  _KiDeliverApc,0
        EXTRNP  _KiQuantumEnd,0
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeBugCheck,1

        extrn   _KiTrap13:PROC
        extrn   KiRetireDpcList:PROC
        extrn   _KeTickCount:DWORD

        extrn   _KiDispatcherReadyListHead:DWORD
        extrn   _KiIdleSummary:DWORD
        extrn   _KiReadySummary:DWORD
        extrn   _KiPCR:DWORD
        extrn   _KiIdleThread:DWORD

if DBG
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
endif

ifdef DEVKIT
        extrn  _KiDbgCtxSwapNotify:DWORD
endif

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Unlock Dispatcher Database"
;++
;
; VOID
; KiUnlockDispatcherDatabase (
;    IN KIRQL OldIrql
;    )
;
; Routine Description:
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database locked. Its function is to either unlock the dispatcher
;    database and return or initiate a context switch if another thread
;    has been selected for execution.
;
; Arguments:
;
;    (TOS)   Return address
;
;    (ecx)   OldIrql - Supplies the IRQL when the dispatcher database
;        lock was acquired.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KiUnlockDispatcherDatabase, 1

;
; Check if a new thread is scheduled for execution.
;

        cmp     PCR[PcPrcbData+PbNextThread], 0 ; check if next thread
        jne     short Kiu20             ; if ne, new thread scheduled

;
; Release dispatcher database lock, lower IRQL to its previous level,
; and return.
;

Kiu00:                                  ;

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     @KfLowerIrql@4          ; lower IRQL to previous level

;
; A new thread has been selected to run on the current processor, but
; the new IRQL is not below dispatch level. If the current processor is
; not executing a DPC, then request a dispatch interrupt on the current
; processor.
;

Kiu10:  cmp     dword ptr PCR[PcPrcbData.PbDpcRoutineActive],0  ; check if DPC routine active
        jne     short Kiu00             ; if ne, DPC routine is active

        push    ecx                     ; save new IRQL

        mov     cl, DISPATCH_LEVEL      ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
        pop     ecx                     ; restore new IRQL

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     @KfLowerIrql@4          ; lower IRQL to previous level

;
; Check if the previous IRQL is less than dispatch level.
;

Kiu20:  cmp     cl, DISPATCH_LEVEL      ; check if IRQL below dispatch level
        jge     short Kiu10             ; if ge, not below dispatch level

;
; There is a new thread scheduled for execution and the previous IRQL is
; less than dispatch level. Context switch to the new thread immediately.
;
;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 4, 1, 0)
        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        lea     ebx, _KiPCR             ; get address of PCR
        mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     [edi].ThWaitIrql, cl    ; save previous IRQL
        mov     ecx, edi                ; set address of current thread
        fstCall KiReadyThread           ; reready thread for execution
        mov     cl, [edi].ThWaitIrql    ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        or      al, al                  ; check if kernel APC pending
        mov     cl, [esi].ThWaitIrql    ; get original wait IRQL
        jnz     short Kiu50             ; if nz, kernel APC pending

Kiu30:  mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     @KfLowerIrql@4          ; lower IRQL to previous level

Kiu50:  mov     cl, APC_LEVEL           ; lower IRQL to APC level
        fstCall KfLowerIrql             ;
        xor     eax, eax                ; set previous mode to kernel
        stdCall _KiDeliverApc           ; deliver kernel mode APC
        xor     ecx, ecx                ; set original wait IRQL
        jmp     short Kiu30

fstENDP KiUnlockDispatcherDatabase

        page ,132
        subttl  "Swap Thread"
;++
;
; VOID
; KiSwapThread (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called to select the next thread to run on the
;    current processor and to perform a context switch to the thread.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Wait completion status (eax).
;
;--

cPublicFastCall KiSwapThread, 0
.fpo (0, 0, 0, 4, 1, 0)

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;

        lea     ebx, _KiPCR             ; get address of PCR
        mov     edx, [ebx].PcPrcbData.PbNextThread ; get next thread address
        or      edx, edx                ; check if next thread selected
        jnz     Swt140                  ; if nz, next thread selected

;
; Find the highest nibble in the ready summary that contains a set bit
; and left justify so the nibble is in bits <31:28>
;

        mov     ecx, 16                 ; set base bit number
        mov     edi, _KiReadySummary    ; get ready summary
        mov     esi, edi                ; copy ready summary
        shr     esi, 16                 ; isolate bits <31:16> of summary
        jnz     short Swt10             ; if nz, bits <31:16> are nonzero
        xor     ecx, ecx                ; set base bit number
        mov     esi, edi                ; set bits <15:0> of summary
Swt10:  shr     esi, 8                  ; isolate bits <15:8> of low bits
        jz      short Swt20             ; if z, bits <15:8> are zero
        add     ecx, 8                  ; add offset to nonzero byte
Swt20:  mov     esi, edi                ; isolate highest nonzero byte
        shr     esi, cl                 ;
        add     ecx, 3                  ; adjust to high bit of nibble
        cmp     esi, 10h                ; check if high nibble nonzero
        jb      short Swt30             ; if b, then high nibble is zero
        add     ecx, 4                  ; compute ready queue priority
Swt30:  mov     esi, ecx                ; left justify ready summary nibble
        not     ecx                     ;
        shl     edi, cl                 ;
        or      edi, edi                ;

;
; If the next bit is set in the ready summary, then scan the corresponding
; dispatcher ready queue.
;

Swt40:  js      short Swt60             ; if s, queue contains an entry
Swt50:  sub     esi, 1                  ; decrement ready queue priority
        shl     edi, 1                  ; position next ready summary bit
        jnz     short Swt40             ; if nz, more queues to scan

;
; All ready queues were scanned without finding a runnable thread so
; default to the idle thread and set the appropriate bit in idle summary.
;

        mov     _KiIdleSummary, 1       ; set idle summary bit

        lea     edx, _KiIdleThread      ; set idle thread address
        jmp     Swt140                  ;

;
; If the thread can execute on the current processor, then remove it from
; the dispatcher ready queue.
;

        align   4
swt60:  lea     ebp, [esi*8] + _KiDispatcherReadyListHead ; get ready queue address
        mov     ecx, [ebp].LsFlink      ; get address of first queue entry
Swt70:  mov     edx, ecx                ; compute address of thread object
        sub     edx, ThWaitListEntry    ;

;
; Remove the selected thread from the ready queue.
;

        mov     eax, [ecx].LsFlink      ; get list entry forward link
        mov     ebp, [ecx].LsBlink      ; get list entry backward link
        mov     [ebp].LsFlink, eax      ; set forward link in previous entry
        mov     [eax].LsBlink, ebp      ; set backward link in next entry
        cmp     eax, ebp                ; check if list is empty
        jnz     short Swt140            ; if nz, list is not empty
        mov     ebp, 1                  ; clear ready summary bit
        mov     ecx, esi                ;
        shl     ebp, cl                 ;
        xor     _KiReadySummary, ebp    ;

;
; Swap context to the next thread.
;

Swt140: mov     esi, edx                ; set address of next thread
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; set current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     cl, [edi].ThWaitIrql    ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        or      al, al                  ; check if kernel APC pending
        mov     edi, [esi].ThWaitStatus ; save wait completion status
        mov     cl, [esi].ThWaitIrql    ; get wait IRQL
        jnz     short Swt160            ; if nz, kernel APC pending

Swt150: fstCall KfLowerIrql             ; lower IRQL to previous value

        mov     eax, edi                ; set wait completion status
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4                ;
        fstRET  KiSwapThread            ;

Swt160: mov     cl, APC_LEVEL           ; lower IRQL to APC level
        fstCall KfLowerIrql             ;
        xor     eax, eax                ; set previous mode to kernel
        stdCall _KiDeliverApc           ; deliver kernel mode APC
        xor     ecx, ecx                ; set original wait IRQL
        jmp     short Swt150

fstENDP KiSwapThread

        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at DISPATCH_LEVEL. Its function is to process the Deferred Procedure Call
;    (DPC) list, and then perform a context switch if a new thread has been
;    selected for execution on the processor.
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database unlocked. When a return to the caller finally occurs, the
;    IRQL remains at DISPATCH_LEVEL, and the dispatcher database is still
;    unlocked.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--

        align 16
cPublicProc _KiDispatchInterrupt ,0
cPublicFpo 0, 0

        lea     ebx, _KiPCR             ; get address of PCR
kdi00:  lea     eax, [ebx].PcPrcbData.PbDpcListHead ; get DPC listhead address

;
; Disable interrupts and check if there is any work in the DPC list
; of the current processor.
;

kdi10:  cli                             ; disable interrupts
        cmp     eax, [eax].LsFlink      ; check if DPC List is empty
        je      short kdi40             ; if eq, list is empty
        push    ebp                     ; save register

;
; Exceptions occuring in DPCs are unrelated to any exception handlers
; in the interrupted thread.  Terminate the exception list.
;

        push    [ebx].PcExceptionList
        mov     [ebx].PcExceptionList, EXCEPTION_CHAIN_END

;
; Switch to the DPC stack for this processor.
;

        mov     edx, esp
        mov     esp, [ebx].PcPrcbData.PbDpcStack
        push    edx

.fpo (0, 0, 0, 1, 1, 0)

        mov     ebp, eax                ; set address of DPC listhead
        call    KiRetireDpcList         ; process the current DPC list

;
; Switch back to the current thread stack, restore the exception list
; and saved EBP.
;

        pop     esp
	pop     [ebx].PcExceptionList
        pop     ebp

.fpo (0, 0, 0, 0, 0, 0)

;
; Check to determine if quantum end is requested.
;
; N.B. If a new thread is selected as a result of processing the quantum
;      end request, then the new thread is returned with the dispatcher
;      database locked. Otherwise, NULL is returned with the dispatcher
;      database unlocked.
;

kdi40:  sti                             ; enable interrupts
        cmp     dword ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; quantum end requested
        jne     kdi90                   ; if neq, quantum end request

;
; Check to determine if a new thread has been selected for execution on this
; processor.
;

        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; check addr of next thread object
        je      short kdi70             ; if eq, then no new thread

;
; Disable interrupts and attempt to acquire the dispatcher database lock.
;

        mov     eax, [ebx].PcPrcbData.PbNextThread ; get next thread address

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 3, 1, 0)

kdi60:  sub     esp, 3*4
        mov     [esp+8], esi            ; save registers
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     esi, eax                ; set next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     ecx, edi                ; set address of current thread
        fstCall KiReadyThread           ; ready thread (ecx) for execution
        mov     cl, 1                   ; set APC interrupt bypass disable
        call    SwapContext             ; call context swap routine
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        add     esp, 3*4
kdi70:  stdRET  _KiDispatchInterrupt    ; return

;
; Process quantum end event.
;
; N.B. If the quantum end code returns a NULL value, then no next thread
;      has been selected for execution. Otherwise, a next thread has been
;      selected and the dispatcher databased is locked.
;

kdi90:  mov     dword ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; clear quantum end indicator
        stdCall _KiQuantumEnd           ; process quantum end
        or      eax, eax                ; check if new thread selected
        jne     short kdi60             ; if ne, new thread selected
        stdRET  _KiDispatchInterrupt    ; return

stdENDP _KiDispatchInterrupt

        page ,132
        subttl  "Swap Context to Next Thread"
;++
;
; Routine Description:
;
;    This routine is called to swap context from one thread to the next.
;    It swaps context, flushes the data, instruction, and translation
;    buffer caches, restores nonvolatile integer registers, and returns
;    to its caller.
;
;    N.B. It is assumed that the caller (only callers are within this
;         module) saved the nonvolatile registers, ebx, esi, edi, and
;         ebp. This enables the caller to have more registers available.
;
; Arguments:
;
;    cl - APC interrupt bypass disable (zero enable, nonzero disable).
;    edi - Address of previous thread.
;    esi - Address of next thread.
;    ebx - Address of PCR.
;
; Return value:
;
;    al - Kernel APC pending.
;    ebx - Address of PCR.
;    esi - Address of current thread object.
;
;--

        align   16
        public  SwapContext

SwapContext     proc


;
;   NOTE:   The ES: override on the move to ThState is part of the
;           lazy-segment load system.  It assures that ES has a valid
;           selector in it, thus preventing us from propagating a bad
;           ES accross a context switch.
;
;           Note that if segments, other than the standard flat segments,
;           with limits above 2 gig exist, neither this nor the rest of
;           lazy segment loads are reliable.
;
; Note that ThState must be set before the dispatcher lock is released
; to prevent KiSetPriorityThread from seeing a stale value.
;

;
; Save the APC disable flag and set new thread state to running.
;

        or      cl, cl                  ; set zf in flags
        mov     byte ptr es:[esi]+ThState, Running ; set thread state to running
        pushfd
cPublicFpo 0, 1

;
; Save the APC disable flag and the exception listhead.
; (also, check for DPC running which is illegal right now).
;

        mov     ecx, [ebx]+PcExceptionList ; save exception list
        cmp     [ebx]+PcPrcbData+PbDpcRoutineActive, 0
        push    ecx
cPublicFpo 0, 2
        jne     sc91                    ; bugcheck if DPC active.

;
; Notify the profiling function of the context switch.
;

ifdef DEVKIT

        cmp     _KiDbgCtxSwapNotify, 0
        jne     sc92
sc03:

endif ; DEVKIT

;
; On a uniprocessor system the NPX state is swapped in a lazy manner.
; If a thread whose state is not in the coprocessor attempts to perform
; a coprocessor operation, the current NPX state is swapped out (if needed),
; and the new state is swapped in durning the fault.  (KiTrap07)
;
; On a multiprocessor system we still fault in the NPX state on demand, but
; we save the state when the thread switches out (assuming the NPX state
; was loaded).  This is because it could be difficult to obtain the thread's
; NPX in the trap handler if it was loaded into a different processor's
; coprocessor.
;
        mov     ebp, cr0                ; get current CR0
        mov     edx, ebp

;
; Switch stacks:
;
;   1.  Save old esp in old thread object.
;   2.  Copy stack base and stack limit into TSS AND PCR
;   3.  Load esp from new thread object
;
; Keep interrupts off so we don't confuse the trap handler into thinking
; we've overrun the kernel stack.
;

        cli                             ; disable interrupts
        mov     [edi]+ThKernelStack, esp ; save old kernel stack pointer
        mov     eax, [esi]+ThStackBase  ; get new initial stack pointer
        mov     ecx, [esi]+ThStackLimit ; get stack limit
        sub     eax, NPX_FRAME_LENGTH   ; space for NPX_FRAME & NPX CR0 flags
        mov     [ebx]+PcStackLimit, ecx ; set new stack limit
        mov     [ebx]+PcStackBase, eax  ; set new stack base

.errnz (NPX_STATE_NOT_LOADED - CR0_TS - CR0_MP)
.errnz (NPX_STATE_LOADED - 0)

; (eax) = Initial Stack
; (ebx) = Prcb
; (edi) = OldThread
; (esi) = NewThread
; (ebp) = Current CR0
; (edx) = Current CR0

        xor     ecx, ecx
        mov     cl, [esi]+ThNpxState            ; New NPX state is (or is not) loaded

        and     edx, NOT (CR0_MP+CR0_EM+CR0_TS) ; clear thread settable NPX bits
        or      ecx, edx                        ; or in new thread's cr0
        or      ecx, [eax]+FpCr0NpxState        ; merge new thread settable state
        cmp     ebp, ecx                ; check if old and new CR0 match
        jne     sc_reload_cr0           ; if ne, no change in CR0

        align   4
sc06:   mov     esp, [esi]+ThKernelStack ; set new stack pointer
        sti                             ; enable interrupts

;
; Update context switch counters.
;

        inc     dword ptr [esi]+ThContextSwitches ; thread count
        inc     dword ptr [ebx]+PcPrcbData+PbContextSwitches ; processor count
        pop     ecx                     ; restore exception list
        mov     [ebx].PcExceptionList, ecx ;

;
; If the new thread has a kernel mode APC pending, then request an APC
; interrupt.
;

        cmp     byte ptr [esi].ThApcState.AsKernelApcPending, 0 ; APC pending?
        jne     short sc80              ; if ne, kernel APC pending
        popfd                           ; restore flags
        xor     eax, eax                ; clear kernel APC pending
        ret                             ; return

;
; The new thread has an APC interrupt pending. If APC interrupt bypass is
; enable, then return kernel APC pending. Otherwise, request a software
; interrupt at APC_LEVEL and return no kernel APC pending.
;

sc80:   popfd                           ; restore flags
        jnz     short sc90              ; if nz, APC interupt bypass disabled
        mov     al, 1                   ; set kernel APC pending
        ret                             ;

sc90:   mov     cl, APC_LEVEL           ; request software interrupt level
        fstCall HalRequestSoftwareInterrupt ;
        xor     eax, eax                ; clear kernel APC pending
        ret                             ;

;
; Cr0 has changed (ie, floating point processor present), load the new value.
;

sc_reload_cr0:
if DBG

        test    byte ptr [esi]+ThNpxState, NOT (CR0_TS+CR0_MP)
        jnz     sc_error                ;
        test    dword ptr [eax]+FpCr0NpxState, NOT (CR0_PE+CR0_MP+CR0_EM+CR0_TS)
        jnz     sc_error3               ;

endif
        mov     cr0,ecx                 ; set new CR0 NPX state
        jmp     sc06

;
; Notify context swap callout routine.  This code is out of line to
; optimize the normal case (which is expected to be the case where
; there is no callout routine).
;

ifdef DEVKIT

sc92:   mov     edx, [esi].EtUniqueThread ; set new thread unique id
        mov     ecx, [edi].EtUniqueThread ; set old thread unique id
        call    [_KiDbgCtxSwapNotify]     ; notify callout routine
        jmp     sc03

endif ; DEVKIT

.fpo (2, 0, 0, 0, 0, 0)
sc91:   stdCall _KeBugCheck <ATTEMPTED_SWITCH_FROM_DPC>
        ret                             ; return

if DBG
sc_error5:  int 3
sc_error4:  int 3
sc_error3:  int 3
sc_error2:  int 3
sc_error:   int 3
endif

SwapContext     endp

        page , 132
        subttl "Flush EntireTranslation Buffer"
;++
;
; VOID
; KeFlushCurrentTb (
;     )
;
; Routine Description:
;
;     This function flushes the entire translation buffer (TB) on the current
;     processor and also flushes the data cache if an entry in the translation
;     buffer has become invalid.
;
; Arguments:
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KeFlushCurrentTb ,0

        mov     eax, cr3                ; (eax) = directory table base
        mov     cr3, eax                ; flush TLB
        stdRET    _KeFlushCurrentTb

stdENDP _KeFlushCurrentTb

cPublicProc _KeFlushCurrentTbAndInvalidateAllCaches ,0

        mov     eax, cr3                ; (eax) = directory table base
        mov     cr3, eax                ; flush TLB

cPublicProc _KeInvalidateAllCaches ,0

        wbinvd
        stdRET    _KeFlushCurrentTbAndInvalidateAllCaches

stdENDP _KeInvalidateAllCaches

stdENDP _KeFlushCurrentTbAndInvalidateAllCaches

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\geni386.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    genoff.c

Abstract:

    This module implements a program which generates structure offset
    definitions for kernel structures that are accessed in assembly code.

Author:

    Bryan M. Willman (bryanwi) 16-Oct-90


To build:

    in ke\up do a "nmake UMAPPL=geni386"
    watch out for precompiled headers


Revision History:

    Forrest Foltz (forrestf) 24-Jan-1998

        Modified format to use new obj-based procedure.

--*/


#include "ki.h"
#pragma hdrstop

#include "nturtl.h"
#include "ntdbg.h"
#include "xdisk.h"
#include "bldr.h"
#include "xpcicfg.h"

/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    genxx.h

Abstract:

    This file contains macros (some of them destined for the M4 preprocessor)
    to aid in the generation of ks & hal header files.  This is used by
    ke\xxx\genxxx.c, as well as sdktools\genxx.

Author:

    Forrest C. Foltz (forrestf) 23-Jan-1998

Revision History:

--*/



//
// Structure element definitions.  
//

#define MAX_ELEMENT_NAME_LEN 127    // big enough for comments too
typedef struct _STRUC_ELEMENT {

//
// Flags is one or more SEF_xxx, defined below.
//

    UINT64 Flags;

//
// Note that Equate is used to store a pointer in the case of bitfield
// processing.
//

    UINT64 Equate;

//
// Name should be quite long, as it is used to hold comments as well.
//

    CHAR Name[ MAX_ELEMENT_NAME_LEN + 1 ];
} STRUC_ELEMENT, *PSTRUC_ELEMENT;

#define SEF_ENABLE_MASK     0x0000FF00      
#define SEF_HAL             0x00000100
#define SEF_KERNEL          0x00000200

#define SEF_INC_FORMAT_MASK 0x00010000
#define SEF_H_FORMAT        0x00000000
#define SEF_INC_FORMAT      0x00010000

//
// Types.  Note that SETMASK, CLRMASK has no effect on te BITFLD types.  BITFLD
// types have SEF_HAL | SEF_KERNEL set in the type.
//

#define SEF_TYPE_MASK       0x000000FF
#define SEF_EQUATE          0x00000000
#define SEF_EQUATE64        0x00000001
#define SEF_COMMENT         0x00000002      
#define SEF_STRING          0x00000003      // Equate is vararg to printf
#define SEF_BITFLD          0x00000004
#define SEF_BITALIAS        0x00000005
#define SEF_STRUCTURE       0x00000006
#define SEF_SETMASK         0x00000010      // Equate is the mask
#define SEF_CLRMASK         0x00000011      // Equate is the mask
#define SEF_END             0x00000012
#define SEF_START           0x00000013
#define SEF_PATH            0x00000014

//
// Note that BITFLD entries have per-entry hal|kernel flags
//


//
// Define architecture specific generation macros.
//

#define SEF_FLAGS 0
#define HAL SEF_HAL
#define KERNEL SEF_KERNEL

#ifndef ULONG_MAX
#define ULONG_MAX 0xFFFFFFFF
#endif

#ifdef _WIN64_
#define SEF_UINT SEF_EQUATE64
#else
#define SEF_UINT SEF_EQUATE
#endif

//
// genDef(Pc, KPCR, MinorVersion)
//
// -> #define PcMinorVersion 0x0
//

#define genDef(Prefix, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Prefix #Member },

//
// genAlt( PbAlignmentFixupCount, KPRCB, KeAlignmentFixupCount )
//
// -> #define PbAlignmentFixupCount 0x2f4
// 

#define genAlt(Name, Type, Member) \
    { SEF_EQUATE, OFFSET(Type, Member), #Name },

//
// genCom("This is a comment")
//
//    //
// -> // This is a comment
//    //
//

#define genCom(Comment) \
    { SEF_COMMENT, 0, Comment },

//
// genNam(PCR_MINOR_VERSION)
//
// -> #define PCR_MINOR_VERSION 0x1
//

#define genNam(Name) \
    { SEF_EQUATE, (ULONG)(Name), #Name },

//
// genNamUint(KSEG0_BASE)
//
// -> #define KSE0_BASE 0xffffffff80000000
//

#define genNamUint(Name) \
    { SEF_UINT, (UINT64)(Name), #Name },

//
// genVal(FirmwareFrameLength, FIRMWARE_FRAME_LENGTH)
//
// -> #define FirmwareFrameLength 0x250
//
// Note: if the value is 64-bit when _WIN64_ is enabled, use genValUint()
//

#define genVal(Name, Value) \
    { SEF_EQUATE, (ULONG)(Value), #Name },

//
// genValUint(KiPcr, KIPCR)
//
// -> #define KiPcr 0xe0000000ffffe000
//

#define genValUint(Name, Value) \
    { SEF_UINT, (UINT64)(Value), #Name },

//
// genSpc()
//
// ->
//

#define genSpc() \
    { SEF_STRING, 0, "\n" },

//
// genStr("    PCR equ ds:[0%lXH]\n", KIP0PCRADDRESS)
//
// ->     PCR equ ds:[0FFDFF000H]
//

#define genStr(String, Value) \
    { SEF_STRING, (ULONG_PTR)(Value), String },

//
// genTxt("ifdef NT_UP\n")
//
// -> ifdef NT_UP
//

#define genTxt(String) \
    { SEF_STRING, 0, String },

#define DisableInc( x ) \
    { SEF_CLRMASK, x, "" },

#define EnableInc( x ) \
    { SEF_SETMASK, x, "" },

#define MARKER_STRING "This is the genxx marker string."

//
// Source file can specify the _NTDRIVE\_NTROOT - relative output path.
// 'f' is the set of enable-flags that should be routed to this file.
// Use '0' if there is only a single output file.
//
// 'f' should also contain one of SEF_H_FORMAT or SEF_INC_FORMAT to
// indicate whether the generated file is in 'header file' or 'include file'
// format.
//

#define setPath( p, f ) \
    { SEF_PATH | f, 0, p },

//
// START_LIST defines the first element in ElementList.  This element contains
// a (possibly truncated) pointer to the ElementList array.  This is used to
// determine the fixup RA bias.
//

#define START_LIST \
    { SEF_START, (ULONG_PTR)ElementList, MARKER_STRING },

#define END_LIST \
    { SEF_END, 0, "" }

//
// Preprocessor assertion.  Do something here to make the compiler generate
// an error if x != y.
//

#define ASSERT_SAME( x, y )

//
// Macro to round Val up to the next Bnd boundary.  Bnd must be an integral
// power of two.
//

#define ROUND_UP( Val, Bnd ) \
    (((Val) + ((Bnd) - 1)) & ~((Bnd) - 1))

#ifndef OFFSET

//
// Define member offset computation macro.
//

#define OFFSET(type, field) ((ULONG_PTR)(&((type *)0)->field))

#endif

//
// Following are some M4 macros to help with bitfields.  
//

#ifndef SKIP_M4

//
// First, define the makezeros(n) macro that will generate a string with
// n pairs of ',0'.  This is a recursively defined macro.
//



//
// Define a concatenation macro.
//



//
// The following example bitfield declaration uses HARDWARE_PTE as an
// example, which is declared (for alpha) as follows:
//
// typedef struct _HARDWARE_PTE {
//     ULONG Valid: 1;
//     ULONG Owner: 1;
//     ULONG Dirty: 1;
//     ULONG reserved: 1;
//     ULONG Global: 1;
//     ULONG GranularityHint: 2;
//     ULONG Write: 1;
//     ULONG CopyOnWrite: 1;
//     ULONG PageFrameNumber: 23;
// } HARDWARE_PTE, *PHARDWARE_PTE;
//
//
// // First, startBitStruc() is invoked with the structure name.
//
// startBitStruc( HARDWARE_PTE, SEF_HAL | SEF_KERNEL )
//
// //
// // Now, suppose we wanted to expose seven of the fields in an assembly
// // include file:
// //
//
// genBitField( Valid, PTE_VALID )
// genBitField( Owner, PTE_OWNER )
// genBitField( Dirty, PTE_DIRTY )
// genBitField( reserved )
// genBitField( Global, PTE_GLOBAL )
// genBitField( GranularityHint )
// genBitField( Write, PTE_WRITE )
// genBitField( CopyOnWrite, PTE_COPYONWRITE )
// genBitField( PageFrameNumber, PTE_PFN )
//
// Note that fields that are not used (in this case 'reserved' and
// 'GranularityHint') must still appear in the list.
//
// The above will generate a bunch of static, initialized copies of HARDWARE_PTE
// like so:
//
// HARDWARE_PTE HARDWARE_PTE_Valid = {
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Owner = {
//     0,   // Valid
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Dirty = {
//     0,   // Valid
//     0,   // Owner
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Global = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_Write = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_CopyOnWrite = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0xFFFFFFFF };
//
// HARDWARE_PTE HARDWARE_PTE_PageFrameNumber = {
//     0,   // Valid
//     0,   // Owner
//     0,   // Dirty
//     0,   // reserved (skipped)
//     0,   // Global
//     0,   // GranularityHint (skipped)
//     0,   // CopyOnWrite
//     0xFFFFFFFF };
//
// Then, as part of processing the END_LIST macro, these structures are
// generated:
//
// { SEF_BITFLD, &HARDWARE_PTE_Valid,           "PTE_VALID" },
// { SEF_BITFLD, &HARDWARE_PTE_Owner,           "PTE_OWNER" },
// { SEF_BITFLD, &HARDWARE_PTE_Dirty,           "PTE_DIRTY" },
// { SEF_BITFLD, &HARDWARE_PTE_Global,          "PTE_GLOBAL" },
// { SEF_BITFLD, &HARDWARE_PTE_Write,           "PTE_WRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_CopyOnWrite,     "PTE_COPYONWRITE" },
// { SEF_BITFLD, &HARDWARE_PTE_PageFrameNumber, "PTE_PFN" },
// { SEF_END,    0,                             "" }
//
//
// ... and that's what gets compiled by the target compiler into the .obj.
// Now, the final stage: genxx.exe is run against this target .obj, and
// would generate the following:
//
// #define PTE_VALID_MASK 0x1
// #define PTE_VALID 0x0
// #define PTE_OWNER_MASK 0x2
// #define PTE_OWNER 0x1
// #define PTE_DIRTY_MASK 0x4
// #define PTE_DIRTY 0x2
// #define PTE_GLOBAL_MASK 0x10
// #define PTE_GLOBAL 0x4
// #define PTE_WRITE_MASK 0x80
// #define PTE_WRITE 0x7
// #define PTE_COPYONWRITE_MASK 0x100
// #define PTE_COPYONWRITE 0x8
// #define PTE_PFN_MASK 0xfffffe00
// #define PTE_PFN 0x9
//

//
// BITFIELD_STRUCS accumulates array element initializations.  END_LIST will
// dump these into the definition array.
// 



//
// startBitStruc( <strucname>, <whichfile> )
// sets BIT_STRUC_NAME = <strucname> and resets the ZERO_FIELDS count to 0.
// It also sets the WHICH_FILE macro.
//



//
// genBitField( <fldname>, <generatedname> ) declares a structure of type
// <strucname> and initializes the <fldname> bitfield within it.
//
// Note that I used "cma" instead of an actual comma, this gets changed to
// a comma by END_LIST, below.  If I were more proficient with M4 I would know
// how to get around this.
//





//
// END_LIST dumps the array initializers accumulated by , after
// replacing each 'cma' with an actual comma.
//



#endif  // SKIP_M4



#define KS386 KERNEL
#define HAL386 HAL

STRUC_ELEMENT ElementList[] = {

    START_LIST

  EnableInc(KS386)

    #include "genxx.inc"

    //
    // Generate architecture dependent definitions.
    //

    genCom("Apc Record Structure Offset Definitions")

    genDef(Ar, KAPC_RECORD, NormalRoutine)
    genDef(Ar, KAPC_RECORD, NormalContext)
    genDef(Ar, KAPC_RECORD, SystemArgument1)
    genDef(Ar, KAPC_RECORD, SystemArgument2)
    genVal(ApcRecordLength, sizeof(KAPC_RECORD))
    genSpc()

  EnableInc(HAL386)
    genCom("Processor Control Registers Structure Offset Definitions")

    genTxt("PCR equ dword ptr [_KiPCR]\n")
    genTxt("PCRB equ byte ptr [_KiPCR]\n")

    genAlt(PcExceptionList, KPCR,  NtTib.ExceptionList)
    genAlt(PcStackBase, KPCR, NtTib.StackBase)
    genAlt(PcStackLimit, KPCR, NtTib.StackLimit)
    genDef(Pc, KPCR, SelfPcr)
    genDef(Pc, KPCR, Prcb)
    genAlt(PcTeb, KPCR, NtTib.Self)
    genDef(Pc, KPCR, Irql)
    genDef(Pc, KPCR, PrcbData)
  DisableInc (HAL386)
    genVal(ProcessorControlRegisterLength, sizeof(KPCR))

  EnableInc (HAL386)
    genCom("Tss Structure Offset Definitions")

    genDef(Tss, KTSS, Ss0)
    genDef(Tss, KTSS, Esp0)
    genDef(Tss, KTSS, Eip)
    genDef(Tss, KTSS, EFlags)
    genDef(Tss, KTSS, Esp)
    genDef(Tss, KTSS, CR3)
    genDef(Tss, KTSS, Cs)
    genDef(Tss, KTSS, Ss)
    genDef(Tss, KTSS, Ds)
    genDef(Tss, KTSS, Es)
    genDef(Tss, KTSS, Fs)
    genDef(Tss, KTSS, Gs)
    genDef(Tss, KTSS, IoMapBase)
    genDef(Tss, KTSS, IoMaps)
    genVal(TssLength, sizeof(KTSS))
  DisableInc (HAL386)

  EnableInc (HAL386)
    genCom("Gdt Descriptor Offset Definitions")

    genNam(KGDT_R0_CODE)
    genNam(KGDT_R0_DATA)
    genNam(KGDT_R0_PCR)
    genNam(KGDT_TSS)
  DisableInc (HAL386)
    genNam(KGDT_DF_TSS)
    genNam(KGDT_NMI_TSS)

  EnableInc (HAL386)
    genCom("GdtEntry Offset Definitions")

    genDef(Kgdt, KGDTENTRY, BaseLow)
    genAlt(KgdtBaseMid, KGDTENTRY, HighWord.Bytes.BaseMid)
    genAlt(KgdtBaseHi, KGDTENTRY, HighWord.Bytes.BaseHi)
    genAlt(KgdtFlags1, KGDTENTRY, HighWord.Bytes.Flags1)
    genAlt(KgdtLimitHi, KGDTENTRY, HighWord.Bytes.Flags2)
    genDef(Kgdt, KGDTENTRY, LimitLow)
    genVal(KgdtEntryLength, (sizeof(KGDTENTRY)))
    genSpc()

    genCom("IdtEntry Offset Definitions")

    genDef(Kidt, KIDTENTRY, Offset)
    genDef(Kidt, KIDTENTRY, Selector)
    genDef(Kidt, KIDTENTRY, Access)
    genDef(Kidt, KIDTENTRY, ExtendedOffset)
    genVal(KidtEntryLength, (sizeof(KIDTENTRY)))
    genSpc()

    //
    // Processor block structure definitions.
    //

    genCom("Processor Block Structure Offset Definitions")

    genDef(Pb, KPRCB, CurrentThread)
    genDef(Pb, KPRCB, NextThread)
    genDef(Pb, KPRCB, IdleThread)

#ifdef DEVKIT
    genDef(Pb, KPRCB, DebugHaltThread)
    genDef(Pb, KPRCB, DebugMonitorData)
    genDef(Pb, KPRCB, DebugDoubleFault)
#endif

  DisableInc (HAL386)

    genDef(Pb, KPRCB, NpxThread)
    genDef(Pb, KPRCB, InterruptCount)
    genDef(Pb, KPRCB, DpcTime)
    genDef(Pb, KPRCB, InterruptTime)
    genDef(Pb, KPRCB, DebugDpcTime)
    genAlt(PbContextSwitches, KPRCB, KeContextSwitches)
    genDef(Pb, KPRCB, DpcInterruptRequested)
    genDef(Pb, KPRCB, DpcListHead)
    genDef(Pb, KPRCB, DpcRoutineActive)
    genDef(Pb, KPRCB, DpcStack)
    genDef(Pb, KPRCB, QuantumEnd)
    genDef(Pb, KPRCB, NpxSaveArea)
    genVal(ProcessorBlockLength, ((sizeof(KPRCB) + 15) & ~15))

  EnableInc (HAL386)
    genCom("Time Fields (TIME_FIELDS) Structure Offset Definitions")
    genDef(Tf, TIME_FIELDS, Second)
    genDef(Tf, TIME_FIELDS, Minute)
    genDef(Tf, TIME_FIELDS, Hour)
    genDef(Tf, TIME_FIELDS, Weekday)
    genDef(Tf, TIME_FIELDS, Day)
    genDef(Tf, TIME_FIELDS, Month)
    genDef(Tf, TIME_FIELDS, Year)
    genDef(Tf, TIME_FIELDS, Milliseconds)
    genSpc()
  DisableInc (HAL386)

  EnableInc (HAL386)
    genCom("constants for system irql and IDT vector conversion")

    genNam(MAXIMUM_IDTVECTOR)
    genNam(MAXIMUM_PRIMARY_VECTOR)
    genNam(PRIMARY_VECTOR_BASE)

    genCom("Flags in the CR0 register")

    genNam(CR0_PG)
    genNam(CR0_ET)
    genNam(CR0_TS)
    genNam(CR0_EM)
    genNam(CR0_MP)
    genNam(CR0_PE)
    genNam(CR0_CD)
    genNam(CR0_NW)
    genNam(CR0_AM)
    genNam(CR0_WP)
    genNam(CR0_NE)

    genCom("Flags in the CR4 register")

    genNam(CR4_VME)
    genNam(CR4_PVI)
    genNam(CR4_TSD)
    genNam(CR4_DE)
    genNam(CR4_PSE)
    genNam(CR4_PAE)
    genNam(CR4_MCE)
    genNam(CR4_PGE)
    genNam(CR4_FXSR)
    genNam(CR4_XMMEXCPT)

    genCom("Miscellaneous Definitions")

    genNam(MAXIMUM_PROCESSORS)
    genNam(INITIAL_STALL_COUNT)
    genNam(IRQL_NOT_GREATER_OR_EQUAL)
    genNam(IRQL_NOT_LESS_OR_EQUAL)
    genNam(MUTEX_ALREADY_OWNED)
    genNam(THREAD_NOT_MUTEX_OWNER)
  DisableInc (HAL386)
    genNam(BASE_PRIORITY_THRESHOLD)
    genNam(LOW_REALTIME_PRIORITY)
    genNam(KERNEL_STACK_SIZE)
    genNam(DOUBLE_FAULT_STACK_SIZE)
    genNam(EFLAG_SELECT)
    genNam(BREAKPOINT_BREAK )
    genNam(CLOCK_QUANTUM_DECREMENT)
    genNam(THREAD_QUANTUM)
    genNam(WAIT_QUANTUM_DECREMENT)
    genNam(ROUND_TRIP_DECREMENT_COUNT)

    //
    // Print trap frame offsets relative to sp.
    //

  EnableInc (HAL386)
    genCom("Trap Frame Offset Definitions and Length")

    genDef(Ts, KTRAP_FRAME, ExceptionList)
    genDef(Ts, KTRAP_FRAME, Edi)
    genDef(Ts, KTRAP_FRAME, Esi)
    genDef(Ts, KTRAP_FRAME, Ebp)
    genDef(Ts, KTRAP_FRAME, Ebx)
    genDef(Ts, KTRAP_FRAME, Edx)
    genDef(Ts, KTRAP_FRAME, Ecx)
    genDef(Ts, KTRAP_FRAME, Eax)
    genDef(Ts, KTRAP_FRAME, ErrCode)
    genDef(Ts, KTRAP_FRAME, Eip)
    genDef(Ts, KTRAP_FRAME, SegCs)
    genAlt(TsEflags, KTRAP_FRAME, EFlags)
    genDef(Ts, KTRAP_FRAME, HardwareEsp)
    genDef(Ts, KTRAP_FRAME, HardwareSegSs)
    genDef(Ts, KTRAP_FRAME, TempSegCs)
    genDef(Ts, KTRAP_FRAME, TempEsp)
    genDef(Ts, KTRAP_FRAME, DbgEbp)
    genDef(Ts, KTRAP_FRAME, DbgEip)
    genDef(Ts, KTRAP_FRAME, DbgArgMark)
    genDef(Ts, KTRAP_FRAME, DbgArgPointer)
    genNam(KTRAP_FRAME_LENGTH)
    genNam(KTRAP_FRAME_ALIGN)
    genNam(FRAME_EDITED)
    genNam(EFLAGS_ALIGN_CHECK)
    genNam(EFLAGS_V86_MASK)
    genNam(EFLAGS_INTERRUPT_MASK)
    genNam(EFLAGS_VIF)
    genNam(EFLAGS_VIP)
    genNam(EFLAGS_USER_SANITIZE)

    genCom("Context Frame Offset and Flag Definitions")

    genNam(CONTEXT_FULL)
    genNam(CONTEXT_DEBUG_REGISTERS)
    genNam(CONTEXT_CONTROL)
    genNam(CONTEXT_FLOATING_POINT)
    genNam(CONTEXT_INTEGER)
    genNam(CONTEXT_SEGMENTS)
    genSpc()

    //
    // Print context frame offsets relative to sp.
    //

    genDef(Cs, CONTEXT, ContextFlags)
    genDef(Cs, CONTEXT, FloatSave)
    genDef(Cs, CONTEXT, Edi)
    genDef(Cs, CONTEXT, Esi)
    genDef(Cs, CONTEXT, Ebp)
    genDef(Cs, CONTEXT, Ebx)
    genDef(Cs, CONTEXT, Edx)
    genDef(Cs, CONTEXT, Ecx)
    genDef(Cs, CONTEXT, Eax)
    genDef(Cs, CONTEXT, Eip)
    genDef(Cs, CONTEXT, SegCs)
    genAlt(CsEflags, CONTEXT, EFlags)
    genDef(Cs, CONTEXT, Esp)
    genDef(Cs, CONTEXT, SegSs)
    genVal(ContextFrameLength, ROUND_UP(sizeof(CONTEXT), 16))
    genNam(DR6_LEGAL)
    genNam(DR7_LEGAL)
    genNam(DR7_ACTIVE)

    //
    // Print Registration Record Offsets relative to base
    //

    genDef(Err, EXCEPTION_REGISTRATION_RECORD, Handler)
    genDef(Err, EXCEPTION_REGISTRATION_RECORD, Next)

    //
    // Print floating point field offsets relative to Context.FloatSave
    //

    genCom("Floating save area field offset definitions")

    genDef(Fx, FLOATING_SAVE_AREA, ControlWord)
    genDef(Fx, FLOATING_SAVE_AREA, StatusWord)
    genDef(Fx, FLOATING_SAVE_AREA, ErrorOffset)
    genDef(Fx, FLOATING_SAVE_AREA, ErrorSelector)
    genDef(Fx, FLOATING_SAVE_AREA, DataOffset)
    genDef(Fx, FLOATING_SAVE_AREA, DataSelector)
    genDef(Fx, FLOATING_SAVE_AREA, MXCsr)
    genDef(Fp, FLOATING_SAVE_AREA, Cr0NpxState)

    genSpc()
    genVal(NPX_FRAME_LENGTH, sizeof(FX_SAVE_AREA))

    //
    // Processor State Frame offsets relative to base
    //

    genCom("Processor State Frame Offset Definitions")

    genDef(Ps, KPROCESSOR_STATE, ContextFrame)
    genDef(Ps, KPROCESSOR_STATE, SpecialRegisters)
    genDef(Sr, KSPECIAL_REGISTERS, Cr0)
    genDef(Sr, KSPECIAL_REGISTERS, Cr2)
    genDef(Sr, KSPECIAL_REGISTERS, Cr3)
    genDef(Sr, KSPECIAL_REGISTERS, Cr4)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr0)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr1)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr2)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr3)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr6)
    genDef(Sr, KSPECIAL_REGISTERS, KernelDr7)
    genAlt(SrGdtr, KSPECIAL_REGISTERS, Gdtr.Limit)

    genAlt(SrIdtr, KSPECIAL_REGISTERS, Idtr.Limit)
    genDef(Sr, KSPECIAL_REGISTERS, Tr)
    genDef(Sr, KSPECIAL_REGISTERS, Ldtr)

    genDef(PsNT5, X86_NT5_KPROCESSOR_STATE, ContextFrame)
    genDef(PsNT5, X86_NT5_KPROCESSOR_STATE, SpecialRegisters)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr0)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr2)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr3)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Cr4)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr0)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr1)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr2)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr3)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr6)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, KernelDr7)
    genAlt(SrNT5Gdtr, X86_KSPECIAL_REGISTERS, Gdtr.Limit)

    genAlt(SrNT5Idtr, X86_KSPECIAL_REGISTERS, Idtr.Limit)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Tr)
    genDef(SrNT5, X86_KSPECIAL_REGISTERS, Ldtr)

    genSpc()
    genNam(PAGE_SIZE)

    genSpc()
    genNam(CLOCK_ROLLOVER_COUNT)
    genNam(CLOCK_TIME_INCREMENT)

    genSpc()
    genNam(PAGE_DIRECTORY_PHYSICAL_ADDRESS)

    genSpc()
    genNam(ROM_SHADOW_PHYSICAL_ADDRESS)
    genNam(ROM_SHADOW_SIZE)

    genSpc()
    genNam(XDISK_UNPARTITIONED_SECTORS)

    genSpc()
    genVal(MzXdataSectionHeader, ((ULONG_PTR)&((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2))
    genDef(Xdsh, XDATA_SECTION_HEADER, SizeOfUninitializedData)
    genDef(Xdsh, XDATA_SECTION_HEADER, SizeOfInitializedData)
    genDef(Xdsh, XDATA_SECTION_HEADER, PointerToRawData)
    genDef(Xdsh, XDATA_SECTION_HEADER, VirtualAddress)

    genSpc()
    genDef(Mudb, MICROCODE_UPDATE_DATA_BLOCK, Processor)
    genDef(Mudb, MICROCODE_UPDATE_DATA_BLOCK, UpdateData)
    genVal(MudbStructureLength, sizeof(MICROCODE_UPDATE_DATA_BLOCK))

    genNam(XPCICFG_LPCBRIDGE_IO_REGISTER_BASE_0)
    genNam(XPCICFG_LPCBRIDGE_IO_REGISTER_LENGTH_0)
    genNam(XPCICFG_SMBUS_IO_REGISTER_BASE_1)
    genNam(XPCICFG_SMBUS_IO_REGISTER_LENGTH_1)
    genNam(XPCICFG_GPU_MEMORY_REGISTER_BASE_0)
    genNam(XPCICFG_GPU_MEMORY_REGISTER_LENGTH_0)

  DisableInc (HAL386)

    END_LIST
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\intobj.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

--*/

#include "ki.h"

//
//  Externs from trap.asm used to compute and set handlers for unexpected
//  hardware interrupts.
//

extern  ULONG   KiStartUnexpectedRange(VOID);
extern  ULONG   KiEndUnexpectedRange(VOID);
extern  ULONG   KiUnexpectedEntrySize;

VOID
KeInitializeInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector
    )
/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, SynchronizeIrql, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    Vector - Supplies the index of the entry in the Interrupt Dispatch Table
        that is to be associated with the ServiceRoutine function.

    Irql - Supplies the request priority of the interrupting source.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

Return Value:

    None.

--*/
{
    PULONG pl;
    PULONG NormalDispatchCode;
    ULONG InterruptDispatch;

    ASSERT(Irql <= HIGH_LEVEL);
    ASSERT(Vector >= PRIMARY_VECTOR_BASE && Vector < PRIMARY_VECTOR_BASE + 16);

    //
    // Initialize the address of the service routine,
    // the service context, the address of the spin lock, the vector
    // number, the IRQL of the interrupting source, the Irql used for
    // synchronize execution, abd the interrupt mode.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;

    Interrupt->BusInterruptLevel = Vector - PRIMARY_VECTOR_BASE;
    Interrupt->Irql = (UCHAR)Irql;
    Interrupt->Mode = InterruptMode;

    //
    // Copy the interrupt dispatch code template into the interrupt object
    // and edit the machine code stored in the structure (please see
    // _KiInterruptTemplate in intsup.asm.)
    //

    NormalDispatchCode = &(Interrupt->DispatchCode[0]);

    RtlCopyMemory(NormalDispatchCode, KiInterruptTemplate,
        NORMAL_DISPATCH_LENGTH * sizeof(ULONG));

    //
    // Fill in the address of the interrupt object.
    //

    pl = (PULONG)((PUCHAR)NormalDispatchCode + ((PUCHAR)&KiInterruptTemplateObject -
                                (PUCHAR)KiInterruptTemplate) -4);
    *pl = (ULONG)Interrupt;

    //
    // Fill in the address of interrupt dispatch code.
    //

    pl = (PULONG)((PUCHAR)NormalDispatchCode +
                ((PUCHAR)&KiInterruptTemplateDispatch -
                 (PUCHAR)KiInterruptTemplate) -4);

    if (InterruptMode == LevelSensitive) {
        InterruptDispatch = (ULONG)KiLevelInterruptDispatch;
    } else {
        InterruptDispatch = (ULONG)KiInterruptDispatch;
    }

    *pl = InterruptDispatch-(ULONG)((PUCHAR)pl+4);

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
}

BOOLEAN
KeConnectInterrupt (
    IN PKINTERRUPT Interrupt
    )
/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object. If the interrupt object is already
    connected, or an attempt is made to connect to an interrupt that cannot
    be connected, then a value of FALSE is returned. Else the specified
    interrupt object is connected to the interrupt vector, the connected
    state is set to TRUE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Else a value of TRUE is returned.

--*/
{
    KIRQL OldIrql;
    BOOLEAN Connected;
    ULONG BusInterruptLevel;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Is interrupt object already connected?
    //

    Connected = FALSE;

    if (!Interrupt->Connected) {

        BusInterruptLevel = Interrupt->BusInterruptLevel;

        //
        // Is the IDT entry unclaimed?
        //

        if (KiReturnHandlerAddressFromIDT(BusInterruptLevel + PRIMARY_VECTOR_BASE) ==
            (((ULONG)&KiStartUnexpectedRange) +
            BusInterruptLevel * KiUnexpectedEntrySize)) {

            //
            // Connect the dispatch code in the interrupt object to the IDT
            // and enable the interrupt.
            //

            KiSetHandlerAddressToIDT(BusInterruptLevel + PRIMARY_VECTOR_BASE,
                (ULONG)&Interrupt->DispatchCode);

            HalEnableSystemInterrupt(BusInterruptLevel, Interrupt->Mode);

            Interrupt->Connected = TRUE;
            Connected = TRUE;
        }
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return whether interrupt was connected to the specified vector.
    //

    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    )
/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object. If the interrupt object is not
    connected, then a value of FALSE is returned. Else the specified interrupt
    object is disconnected from the interrupt vector, the connected state is
    set to FALSE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/
{
    KIRQL OldIrql;
    BOOLEAN Connected;
    ULONG BusInterruptLevel;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Connected = Interrupt->Connected;

    if (Connected) {

        BusInterruptLevel = Interrupt->BusInterruptLevel;

        //
        // Disable the interrupt and connect the unexpected interrupt code to
        // the IDT.
        //

        HalDisableSystemInterrupt(BusInterruptLevel);

        KiSetHandlerAddressToIDT(BusInterruptLevel + PRIMARY_VECTOR_BASE,
            (((ULONG)&KiStartUnexpectedRange) +
            BusInterruptLevel * KiUnexpectedEntrySize));

        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Connected;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\int.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    int.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Disable Processor Interrupts"
;++
;
; BOOLEAN
; KiDisableInterrupts(
;    VOID
;    )
;
; Routine Description:
;
;    This routine disables interrupts at the processor level.  It does not
;    edit the PICS or adjust IRQL, it is for use in the debugger only.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    (eax) = !0 if interrupts were on, 0 if they were off
;
;--
cPublicProc _KiDisableInterrupts    ,0
cPublicFpo 0, 0
        pushfd
        pop     eax
        and     eax,EFLAGS_IF               ; (eax) = the interrupt bit
        shr     eax,EFLAGS_SHIFT            ; low bit of (eax) == interrupt bit
        cli
        stdRET    _KiDisableInterrupts

stdENDP _KiDisableInterrupts


        page ,132
        subttl  "Restore Processor Interrupts"
;++
;
; VOID
; KiRestoreInterrupts(
;    BOOLEAN Restore
;    )
;
; Routine Description:
;
;    This routine restores interrupts at the processor level.  It does not
;    edit the PICS or adjust IRQL, it is for use in the debugger only.
;
; Arguments:
;
;    Restore (esp+4) - a "boolean" returned by KiDisableInterrupts, if
;                       !0 interrupts will be turned on, else left off.
;
;       NOTE: We don't actually test the boolean as such, we just or
;             it directly into the flags!
;
; Return Value:
;
;    none.
;
;--
cPublicProc _KiRestoreInterrupts    ,1
cPublicFpo 1, 0
        xor     eax, eax
        mov     al, byte ptr [esp]+4
        shl     eax,EFLAGS_SHIFT            ; (eax) == the interrupt bit
        pushfd
        or      [esp],eax                   ; or EI into flags
        popfd
        stdRET    _KiRestoreInterrupts

stdENDP _KiRestoreInterrupts

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\intsup.asm ===
TITLE  "Interrupt Object Support Routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intsup.asm
;
; Abstract:
;
;    This module implements the code necessary to support interrupt objects.
;    It contains the interrupt dispatch code and the code template that gets
;    copied into an interrupt object.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 20-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KeBugCheck,1
        EXTRNP  _KiDeliverApc,0
        EXTRNP  HalBeginSystemInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  HalEndSystemLevelInterrupt,1,,FASTCALL
        extrn   HalpSpecialDismissTable:DWORD
        extrn   _KiPCR:DWORD
if DBG
        extrn   _DbgPrint:near
        extrn   _MsgISRTimeout:BYTE
        extrn   _MsgISROverflow:BYTE
        extrn   _KeTickCount:DWORD
        extrn   _KiISRTimeout:DWORD
        extrn   _KiISROverflow:DWORD
endif

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

if DBG
COMM    KiInterruptCounts:dword:16*2
endif

_DATA   ends

        page ,132
        subttl  "Synchronize Execution"

_TEXT   SEGMENT PARA PUBLIC 'CODE'

;++
;
; BOOLEAN
; KeSynchronizeExecution (
;    IN PKINTERRUPT Interrupt,
;    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
;    IN PVOID SynchronizeContext
;    )
;
; Routine Description:
;
;    This function synchronizes the execution of the specified routine with the
;    execution of the service routine associated with the specified interrupt
;    object.
;
; Arguments:
;
;    Interrupt - Supplies a pointer to a control object of type interrupt.
;
;    SynchronizeRoutine - Supplies a pointer to a function whose execution
;       is to be synchronized with the execution of the service routine associated
;       with the specified interrupt object.
;
;    SynchronizeContext - Supplies a pointer to an arbitrary data structure
;       which is to be passed to the function specified by the SynchronizeRoutine
;       parameter.
;
; Return Value:
;
;    The value returned by the SynchronizeRoutine function is returned as the
;    function value.
;
;--
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
cPublicProc _KeSynchronizeExecution ,3

; equates of Local variables

KsePreviousIrql equ [ebp - 4]                ; previous IRQL
KseStackSize = 4 * 1

; equates for arguments

KseInterrupt equ [ebp +8]
KseSynchronizeRoutine equ [ebp + 12]
KseSynchronizeContext equ [ebp + 16]

        push    ebp                     ; save ebp
        mov     ebp, esp                ; (ebp)-> base of local variable frame
        sub     esp, KseStackSize       ; allocate local variables space
        push    ebx                     ; save ebx

; Acquire the associated spin lock and raise IRQL to the interrupting source.

        mov     ebx, KseInterrupt       ; (ebx)->interrupt object

        mov     ecx, InIrql[ebx]        ; (ecx) = Synchronize Irql
        fstCall KfRaiseIrql
        mov     KsePreviousIrql, al

; Call specified routine passing the specified context parameter.
        mov     eax,KseSynchronizeContext
        push    eax
        call    KseSynchronizeRoutine
        mov     ebx, eax                ; save function returned value

; Unlock spin lock, lower IRQL to its previous level, and return the value
; returned by the specified routine.

        mov     ecx, KsePreviousIrql
        fstCall KfLowerIrql

        mov     eax, ebx                ; (eax) = returned value
        pop     ebx                     ; restore ebx
        leave                           ; will clear stack
        stdRET    _KeSynchronizeExecution

stdENDP _KeSynchronizeExecution

        page ,132
        subttl  "Interrupt Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to directly call the specified interrupt service routine.
;
;    This version is used for edge sensitive interrupts.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiInterruptDispatch    ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; Save previous IRQL and set new priority level
;
; Instead of invoking HalBeginSystemInterrupt, we call indirect through the
; dismiss table ourselves.
;

        mov     ecx, [edi].InBusInterruptLevel
        mov     edx, [edi].InIrql
        push    0                       ; make room for OldIrql
        call    HalpSpecialDismissTable[ecx*4]

;
; Call the service routine.
;

if DBG
        mov     ebx, [edi].InBusInterruptLevel  ; this vector
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second
        shl     ebx, 3                          ; eax = eax * 8
        cmp     eax, [KiInterruptCounts+ebx]        ; in same 1/2 range?
        jne     kid_overflowreset

        mov     eax, _KiISROverflow
        inc     [KiInterruptCounts+ebx+4]
        cmp     [KiInterruptCounts+ebx+4], eax
        jnc     kid_interruptoverflow
kid_dbg2:
        mov     ebx, _KeTickCount
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine

if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     kid200
kid31:
endif

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                  ; will do an iret

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kid200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     kid31                   ; continue

kid_interruptoverflow:
        push    [KiInterruptCounts+ebx+4]
        push    InServiceRoutine[edi]
        push    offset FLAT:_MsgISROverflow
        call    _DbgPrint
        add     esp,12
        int 3

        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second

kid_overflowreset:
        mov     [KiInterruptCounts+ebx], eax        ; initialize time
        mov     [KiInterruptCounts+ebx+4], 0        ; reset count
        jmp     kid_dbg2
endif


stdENDP _KiInterruptDispatch

        page ,132
        subttl  "Level Interrupt Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to directly call the specified interrupt service routine.
;
;    This version is used for level sensitive interrupts.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiLevelInterruptDispatch    ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; Save previous IRQL and set new priority level
;
; Instead of invoking HalBeginSystemInterrupt, we call indirect through the
; dismiss table ourselves.
;

        mov     ecx, [edi].InBusInterruptLevel
        mov     edx, [edi].InIrql
        push    0                       ; make room for OldIrql
        call    HalpSpecialDismissTable[ecx*4]

;
; Call the service routine.
;

if DBG
        mov     ebx, [edi].InBusInterruptLevel  ; this vector
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second
        shl     ebx, 3                          ; eax = eax * 8
        cmp     eax, [KiInterruptCounts+ebx]        ; in same 1/2 range?
        jne     klid_overflowreset

        mov     eax, _KiISROverflow
        inc     [KiInterruptCounts+ebx+4]
        cmp     [KiInterruptCounts+ebx+4], eax
        jnc     klid_interruptoverflow
klid_dbg2:
        mov     ebx, _KeTickCount
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        call    InServiceRoutine[edi]   ; call specified routine

if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     klid200
klid31:
endif

;
; Do interrupt exit processing
;

        mov     eax, [edi].InBusInterruptLevel
        LEVEL_INTERRUPT_EXIT

;
; ISR took a long time to complete, abort to debugger
;

if DBG
klid200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     klid31                  ; continue

klid_interruptoverflow:
        push    [KiInterruptCounts+ebx+4]
        push    InServiceRoutine[edi]
        push    offset FLAT:_MsgISROverflow
        call    _DbgPrint
        add     esp,12
        int 3

        mov     eax, _KeTickCount               ; current time
        and     eax, NOT 31                     ; mask to closest 1/2 second

klid_overflowreset:
        mov     [KiInterruptCounts+ebx], eax        ; initialize time
        mov     [KiInterruptCounts+ebx+4], 0        ; reset count
        jmp     klid_dbg2
endif

stdENDP _KiLevelInterruptDispatch

        page ,132
        subttl  "Interrupt Template"
;++
;
; Routine Description:
;
;    This routine is a template that is copied into each interrupt object. Its
;    function is to save machine state and pass the address of the respective
;    interrupt object and transfer control to the appropriate interrupt
;    dispatcher.
;
;    Control comes here through i386 interrupt gate and, upon entry, the
;    interrupt is disabled.
;
;    Note: If the length of this template changed, the corresponding constant
;          defined in Ki.h needs to be updated accordingly.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    edi - addr of interrupt object
;    esp - top of trap frame
;    interrupts are disabled
;
;--

_KiShutUpAssembler      proc

        public  _KiInterruptTemplate
_KiInterruptTemplate    label   byte

; Save machine state on trap frame

        ENTER_INTERRUPT

;
; the following instruction gets the addr of associated interrupt object.
; the value ? will be replaced by REAL interrupt object address at
; interrupt object initialization time.
;       mov     edi, addr of interrupt object
;
; Template modifications made to support BBT, include replacing bogus
; insructions (created by db and dd) with real instructions.
; This stuff gets overwritten anyway.  BBT just needs to see real instructions.

        public  _KiInterruptTemplate2ndDispatch
_KiInterruptTemplate2ndDispatch equ     this dword
        mov      edi,0

        public  _KiInterruptTemplateObject
_KiInterruptTemplateObject      equ     this dword

; the following instruction transfers control to the appropriate dispatcher
; code.  The value ? will be replaced by real InterruptObj.DispatchAddr
; at interrupt initialization time.  The dispatcher routine will be any one
; of _KiInterruptDispatch or _KiChainDispatch.
;       jmp     [IntObj.DispatchAddr]

        db      0E9h, 0, 0, 0, 0

        public  _KiInterruptTemplateDispatch
_KiInterruptTemplateDispatch    equ     this dword

; end of _KiInterruptTemplate

; The template must fit in the KINTERRUPT.DispatchCode[DISPATCH_LENGTH] field.
.errnz (($ - _KiInterruptTemplate) GT DISPATCH_LENGTH)

_KiShutUpAssembler      endp

        page ,132
        subttl  "Unexpected Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is not connected to an interrupt object.
;
;    For any unconnected vector, its associated 8259 irq is masked out at
;    Initialization time.  So, this routine should NEVER be called.
;    If somehow, this routine gets control we simple raise a BugCheck and
;    stop the system.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--
        public _KiUnexpectedInterrupt
_KiUnexpectedInterrupt  proc
cPublicFpo 0,0

; stop the system
        stdCall   _KeBugCheck, <TRAP_CAUSE_UNKNOWN>
        nop

_KiUnexpectedInterrupt endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\kernlini.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    kernlini.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, and the processor control
    block.

--*/

#include "ki.h"

VOID
KiSwapGDT (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KiSwapGDT)
#endif

#if DBG
const UCHAR MsgDpcTrashedEsp[] = "\n*** DPC routine %p trashed ESP\n";
const UCHAR MsgDpcFpuEnabled[] = "\n*** DPC routine %p returned with the FPU enabled\n";
const UCHAR MsgDpcTimeout[]    = "\n*** DPC routine > 1 sec --- This is not a break in KeUpdateSystemTime\n";
const UCHAR MsgISRTimeout[]    = "\n*** ISR at %lx took over .5 second\n";
const UCHAR MsgISROverflow[]   = "\n*** ISR at %lx - %d interrupts per .5 second\n";

ULONG   KiDPCTimeout       = 110;
ULONG   KiISRTimeout       = 55;
ULONG   KiISROverflow      = 5500;
#endif

extern  KPCR KiPCR;
extern  KTHREAD KiIdleThread;
extern  UCHAR KiIdleThreadStackLimit[];
extern  KGDTENTRY KiGDTEnd[];
extern  KIDTENTRY KiIDTEnd[];

VOID
KiPreInitializeKernel(
    VOID
    )
/*++

Routine Description:

    This function gains control before the kernel debugger has been initialized
    in order to partially initialize static kernel data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKPCR Pcr;

    Pcr = &KiPCR;

    //
    // Initialize the PCR.  The stack base and limit are initialized in case we
    // end up attempting to flush the NPX state before the KiInitializeKernel
    // has completed initialization.
    //

    Pcr->SelfPcr = Pcr;
    Pcr->Prcb = &Pcr->PrcbData;

    Pcr->NtTib.ExceptionList = EXCEPTION_CHAIN_END;
    Pcr->NtTib.StackLimit = KiIdleThreadStackLimit;
    Pcr->NtTib.StackBase = KiIdleThreadStackLimit + KERNEL_STACK_SIZE - sizeof(FX_SAVE_AREA);

    Pcr->PrcbData.CurrentThread = &KiIdleThread;

    //
    // Mark the idle thread as not having a NPX state as well to further avoid
    // attempting to flush the NPX state.
    //

    KiIdleThread.NpxState = NPX_STATE_NOT_LOADED;
    KiIdleThread.StackLimit = KiIdleThreadStackLimit;
    KiIdleThread.StackBase = KiIdleThreadStackLimit + KERNEL_STACK_SIZE;
}

VOID
KiInitializeKernel(
    VOID
    )
/*++

Routine Description:

    This function gains control after the system has been bootstrapped and
    before the system has been initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    initialize the processor control block, call the executive initialization
    routine, and then return to the system startup routine. This routine is
    also called to initialize the processor specific structures when a new
    processor is brought on line.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKPCR Pcr;
    PKPRCB Prcb;
    PFX_SAVE_AREA NpxFrame;
    KIRQL OldIrql;
    PVOID DpcStack;

    Pcr = KeGetPcr();
    Prcb = KeGetCurrentPrcb();

    //
    // Assert that NpxSaveArea is 16 byte aligned; KeSaveFloatingPointState will
    // use the fxsave instruction with this buffer and the Intel architecture
    // requires that the pointer be 16 byte aligned.
    //

    ASSERT((((ULONG_PTR)&Prcb->NpxSaveArea) % 16) == 0);

    //
    // Initialize DPC listhead and lock.
    //

    InitializeListHead(&Prcb->DpcListHead);
    Prcb->DpcRoutineActive = 0;

    //
    // Lower IRQL to APC level.
    //

    KeLowerIrql(APC_LEVEL);

    //
    // Platform architecture independent initialization.
    //

    KiInitSystem();

    //
    // Initialize idle process object.
    //

    KeInitializeProcess(&KiIdleProcess, (KPRIORITY)0);

    KiIdleProcess.ThreadQuantum = MAXCHAR;

    //
    // Initialize system process object.
    //

    KeInitializeProcess(&KiSystemProcess, NORMAL_BASE_PRIORITY);

    KiSystemProcess.ThreadQuantum = THREAD_QUANTUM;

    //
    // Initialize idle thread object and then set:
    //
    //      1. the initial kernel stack to the specified idle stack.
    //      2. the next processor number to the specified processor.
    //      3. the thread priority to the highest possible value.
    //      4. the state of the thread to running.
    //      5. the thread affinity to the specified processor.
    //      6. the specified processor member in the process active processors
    //          set.
    //

    KeInitializeThread(&KiIdleThread, KiIdleThreadStackLimit + KERNEL_STACK_SIZE,
                       KERNEL_STACK_SIZE, 0, (PKSYSTEM_ROUTINE)NULL,
                       (PKSTART_ROUTINE)NULL, (PVOID)NULL, &KiIdleProcess);
    KiIdleThread.Priority = HIGH_PRIORITY;
    KiIdleThread.State = Running;
    KiIdleThread.WaitIrql = DISPATCH_LEVEL;

    //
    // Initialize the idle thread's NPX state to the same state used for normal
    // threads.
    //

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(KiIdleThread.StackBase) -
                sizeof(FX_SAVE_AREA)));

    RtlZeroMemory((PVOID)NpxFrame, sizeof(FX_SAVE_AREA));

    NpxFrame->FloatSave.ControlWord = 0x27f;     //like fpinit but 64bit mode
    NpxFrame->FloatSave.MXCsr       = 0x1f80;    // mask all the exceptions

    //
    // Initialize the processor block. (Note that some fields have been
    // initialized at KiPreInitializeKernel).
    //

    Prcb->CurrentThread = &KiIdleThread;
    Prcb->NextThread = (PKTHREAD)NULL;
    Prcb->IdleThread = &KiIdleThread;
    Pcr->NtTib.StackBase = (PCHAR)KiIdleThread.StackBase - sizeof(FX_SAVE_AREA);

    //
    // call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive();
    } except (EXCEPTION_EXECUTE_HANDLER) {
        KeBugCheck (PHASE0_EXCEPTION);
    }

    //
    // Processor 0's DPC stack was temporarily allocated on
    // the Double Fault Stack, switch to a proper kernel
    // stack now.
    //

    DpcStack = MmCreateKernelStack(KERNEL_STACK_SIZE, FALSE);

    if (DpcStack == NULL) {
        KeBugCheckEx(NO_PAGES_AVAILABLE, 1, 0, 0, 0);
    }
    Prcb->DpcStack = DpcStack;

    //
    // Set the priority of the specified idle thread to zero, set appropriate
    // member in KiIdleSummary and return to the system start up routine.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(&KiIdleThread, (KPRIORITY)0);

    //
    // if a thread has not been selected to run on the current processors,
    // check to see if there are any ready threads; otherwise add this
    // processors to the IdleSummary
    //

    if (Prcb->NextThread == (PKTHREAD)NULL) {
        SetMember(0, KiIdleSummary);
    }

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
}

VOID
KiSwapGDT(
    VOID
    )
/*++

Routine Description:

    This function is called to edit the GDT.  It swaps words of the address
    and access fields around into the format the part actually needs.
    This allows for easy static init of the GDT.

    Note that this procedure edits the current GDT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKGDTENTRY Entry;
    UCHAR Temp;

    //
    // Rearrange the entries of GDT to match i386 structure
    //

    for (Entry = KiGDT; Entry < KiGDTEnd; Entry++) {
        Temp = Entry->HighWord.Bytes.Flags1;
        Entry->HighWord.Bytes.Flags1 = Entry->HighWord.Bytes.Flags2;
        Entry->HighWord.Bytes.Flags2 = Entry->HighWord.Bytes.BaseHi;
        Entry->HighWord.Bytes.BaseHi = Temp;
    }
}

VOID
KiSwapIDT(
    VOID
    )
/*++

Routine Description:

    This function is called to edit the IDT.  It swaps words of the address
    and access fields around into the format the part actually needs.
    This allows for easy static init of the IDT.

    Note that this procedure edits the current IDT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PKIDTENTRY Entry;
    USHORT Temp;

    //
    // Rearrange the entries of IDT to match i386 interrupt gate structure
    //

    for (Entry = KiIDT; Entry < KiIDTEnd; Entry++) {
        Temp = Entry->Selector;
        Entry->Selector = Entry->ExtendedOffset;
        Entry->ExtendedOffset = Temp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implements machine dependent miscellaneous kernel functions.

Author:

    Ken Reneris     7-5-95

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Internal format of the floating_save structure which is passed
//
typedef struct _CONTROL_WORD {
    USHORT      ControlWord;
    ULONG       MXCsr;
} CONTROL_WORD, *PCONTROL_WORD;

typedef struct {
    UCHAR       Flags;
    KIRQL       Irql;
    KIRQL       PreviousNpxIrql;
    UCHAR       Spare[2];

    union {
        CONTROL_WORD    Fcw;
        PFX_SAVE_AREA   Context;
    } u;
    ULONG       Cr0NpxState;

    PKTHREAD    Thread;         // debug

} FLOAT_SAVE, *PFLOAT_SAVE;


#define FLOAT_SAVE_COMPLETE_CONTEXT     0x01
#define FLOAT_SAVE_FREE_CONTEXT_HEAP    0x02
#define FLOAT_SAVE_VALID                0x04
#define FLOAT_SAVE_RESERVED             0xF8

#pragma warning(disable:4035)               // re-enable below

// notes:
// Kix86FxSave(NpxFame) - performs an FxSave to the address specificied
//                   - no other action occurs
__inline
KIRQL
Kix86FxSave(
    PULONG NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit   0
    }
}

//
// Load Katmai New Instruction Technology Control/Status
//
__inline
KIRQL
Kix86LdMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;LDMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  10h
    }
}

//
// Store Katmai New Instruction Technology Control/Status
//
__inline
KIRQL
Kix86StMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;STMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  18h
    }
}
#pragma warning(default:4035)


NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     PublicFloatSave
    )
/*++

Routine Description:

    This routine saves the thread's current non-volatile NPX state,
    and sets a new initial floating point state for the caller.

Arguments:

    FloatSave - receives the current non-volatile npx state for the thread

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    KIRQL                   Irql;
    USHORT                  ControlWord;
    ULONG                   MXCsr;
    PKPRCB                  Prcb;
    PFLOAT_SAVE             FloatSave;

    //
    // Get the current irql and thread
    //

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;

    Irql = KeGetCurrentIrql();
    Thread = KeGetCurrentThread();

    ASSERT (Thread->NpxIrql <= Irql);

    FloatSave->Flags           = 0;
    FloatSave->Irql            = Irql;
    FloatSave->PreviousNpxIrql = Thread->NpxIrql;
    FloatSave->Thread          = Thread;

    //
    // If the irql has changed we need to save the complete floating
    // state context as the prior level has been interrupted.
    //

    if (Thread->NpxIrql != Irql) {

        //
        // If this is apc level we don't have anyplace to hold this
        // context, allocate some heap.
        //

        if (Irql == APC_LEVEL) {
            FloatSave->u.Context = ExAllocatePoolWithTag (
                                        sizeof (FX_SAVE_AREA),
                                        ' XPN'
                                        );

            if (!FloatSave->u.Context) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            FloatSave->Flags |= FLOAT_SAVE_FREE_CONTEXT_HEAP;

        } else {

            ASSERT (Irql == DISPATCH_LEVEL);
            FloatSave->u.Context = &KeGetCurrentPrcb()->NpxSaveArea;

        }

        FloatSave->Flags |= FLOAT_SAVE_COMPLETE_CONTEXT;
    }

    //
    // Stop context switching and allow access to the local fp unit
    //

    _asm {
        cli
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        cmp     eax, ecx
        je      short sav10

        mov     cr0, eax
sav10:
    }

    Prcb = KeGetCurrentPrcb();

    //
    // Get ownership of npx register set for this context
    //

    if (Prcb->NpxThread != Thread) {

        //
        // If the other context is loaded in the npx registers, flush
        // it to that threads save area
        //
        if (Prcb->NpxThread) {

            NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Prcb->NpxThread->StackBase) -
                        sizeof(FX_SAVE_AREA)));

            Kix86FxSave((PULONG)NpxFrame);

            Prcb->NpxThread->NpxState = NPX_STATE_NOT_LOADED;
        }

        Prcb->NpxThread = Thread;
    }

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->StackBase) -
                sizeof(FX_SAVE_AREA)));


    //
    // Save the previous state as required
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Need to save the entire context
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            Kix86FxSave ((PULONG)(FloatSave->u.Context));

            FloatSave->u.Context->FloatSave.Cr0NpxState = NpxFrame->FloatSave.Cr0NpxState;

        } else {

            RtlCopyMemory (FloatSave->u.Context, NpxFrame, sizeof(FX_SAVE_AREA));
        }

    } else {

        //
        // Save only the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            _asm {
                mov     eax, FloatSave
                fnstcw  [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }

            Kix86StMXCsr(&FloatSave->u.Fcw.MXCsr);

        } else {
            //
            // Save the control word from the npx frame.
            //

            FloatSave->u.Fcw.ControlWord = (USHORT) NpxFrame->FloatSave.ControlWord;
            FloatSave->u.Fcw.MXCsr = NpxFrame->FloatSave.MXCsr;
        }

        //
        // Save Cr0NpxState, but clear CR0_TS as there's not non-volatile
        // pending fp exceptions
        //

        FloatSave->Cr0NpxState = NpxFrame->FloatSave.Cr0NpxState & ~CR0_TS;
    }

    //
    // The previous state is saved.  Set an initial default
    // FP state for the caller
    //

    NpxFrame->FloatSave.Cr0NpxState = 0;
    Thread->NpxState = NPX_STATE_LOADED;
    Thread->NpxIrql  = Irql;
    ControlWord = 0x27f;    // 64bit mode
    MXCsr = 0x1f80;

    _asm {
        fninit
        fldcw       ControlWord
    }

    Kix86LdMXCsr(&MXCsr);

    _asm {
        sti
    }

    FloatSave->Flags |= FLOAT_SAVE_VALID;
    return STATUS_SUCCESS;
}


NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      PublicFloatSave
    )
/*++

Routine Description:

    This routine retores the thread's current non-volatile NPX state,
    to the passed in state.

Arguments:

    FloatSave - the non-volatile npx state for the thread to restore

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    ULONG                   Cr0State;
    PFLOAT_SAVE             FloatSave;

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;
    Thread = FloatSave->Thread;
    
    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->StackBase) -
                sizeof(FX_SAVE_AREA)));


    //
    // Verify float save looks like it's from the right context
    //

    if ((FloatSave->Flags & (FLOAT_SAVE_VALID | FLOAT_SAVE_RESERVED)) != FLOAT_SAVE_VALID) {

        //
        // Invalid floating point save area.
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     0,
                     FloatSave->Flags,
                     0,
                     0);
    }

    if (FloatSave->Irql != KeGetCurrentIrql()) {

        //
        // Invalid IRQL.   IRQL now must be the same as when the
        // context was saved.  (Why?   Because we save it in different
        // places depending on the IRQL at that time).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     1,
                     FloatSave->Irql,
                     KeGetCurrentIrql(),
                     0);
    }

    if (Thread != KeGetCurrentThread()) {

        //
        // Invalid Thread.   The thread this floating point context
        // belongs to is not the current thread (or the saved thread
        // field is trash).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     2,
                     (ULONG_PTR)Thread,
                     (ULONG_PTR)KeGetCurrentThread(),
                     0);
    }


    //
    // Synchronize with context switches and the npx trap handlers
    //

    _asm {
        cli
    }

    //
    // Restore the required state
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Restore the entire fp state to the threads save area
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // This state in the fp unit is no longer needed, just disregard it
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED;
            KeGetCurrentPrcb()->NpxThread = NULL;
        }

        //
        // Copy restored state to npx frame
        //

        RtlCopyMemory (NpxFrame, FloatSave->u.Context, sizeof(FX_SAVE_AREA));

    } else {

        //
        // Restore the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // Init fp state and restore control word
            //

            _asm {
                fninit
                mov     eax, FloatSave
                fldcw   [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }

            Kix86LdMXCsr(&FloatSave->u.Fcw.MXCsr);

        } else {

            //
            // Fp state not loaded.  Restore control word in npx frame
            //

            NpxFrame->FloatSave.ControlWord = FloatSave->u.Fcw.ControlWord;
            NpxFrame->FloatSave.StatusWord = 0;
            NpxFrame->FloatSave.TagWord = 0;
            NpxFrame->FloatSave.MXCsr = FloatSave->u.Fcw.MXCsr;
        }

        NpxFrame->FloatSave.Cr0NpxState = FloatSave->Cr0NpxState;
    }

    //
    // Restore NpxIrql and Cr0
    //

    Thread->NpxIrql = FloatSave->PreviousNpxIrql;
    Cr0State = Thread->NpxState | NpxFrame->FloatSave.Cr0NpxState;

    _asm {
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        or      eax, Cr0State
        cmp     eax, ecx
        je      short res10
        mov     cr0, eax
res10:
        sti
    }

    //
    // Done
    //

    if (FloatSave->Flags & FLOAT_SAVE_FREE_CONTEXT_HEAP) {
        ExFreePool (FloatSave->u.Context);
    }

    FloatSave->Flags = 0;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\kimacro.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       kimacro.inc
;
;   Abstract:
;
;       This module contains the macros used by kernel assembler code.
;       It includes macros to manipulate interrupts, support system
;       entry and exit for syscalls, faults, and interrupts, and
;       manipulate floating point state.
;
;   Author:
;
;       Shie-Lin (shielint) 24-Jan-1990
;
;   Revision History:
;
;       BryanWi 17-Aug-90
;           Replace GENERATE_MACHINE... and RESTORE... with ENTER_...
;           and EXIT_ALL macros.
;
;--

;++
;
;   These constants are used by the fpo directives in this file.
;   This directive causes the assembler to output a .debug$f segment
;   in the obj file.  The segment will contain 1 fpo record for each
;   directive present during assembly.
;
;   Although the assembler will accept all valid values, the value of 7
;   in the FPO_REGS field indicates to the debugger that a trap frame is
;   generated by the function.  The value of 7 can be used because the
;   C/C++ compiler puts a maximum value of 3 in the field.
;
FPO_LOCALS      equ     0         ; 32 bits, size of locals in dwords
FPO_PARAMS      equ     0         ; 32 bits, size of parameters in dwords
FPO_PROLOG      equ     0         ; 12 bits, 0-4095, # of bytes in prolog
FPO_REGS        equ     0         ; 3 bits, 0-7, # regs saved in prolog
FPO_USE_EBP     equ     0         ; 1 bit, 0-1, is ebp used?
FPO_TRAPFRAME   equ     1         ; 2 bits, 0=fpo, 1=trap frame, 2=tss
;
;--


;++
;
;   POLL_DEBUGGER
;
;   Macro Description:
;
;       Call the debugger so it can check for control-c.  If it finds
;       it, it will report our iret address as address of break-in.
;
;       N.B. This macro should be used when all the caller's registers
;            have been restored. (Otherwise, the kernel debugger register
;            dump will not have correct state.)  The only exception is
;            fs.  This is because Kd may need to access PCR or PRCB.
;
;   Arguments:
;
;       There MUST be an iret frame on the stack when this macro
;       is invoked.
;
;   Exit:
;
;       Debugger will iret for us, so we don't usually return from
;       this macro, but remember that it generates nothing for non-DEVL
;       kernels.
;--

POLL_DEBUGGER   macro
local   a, b, c_

ifdef DEVKIT
        EXTRNP  _KdPollBreakIn,0
        EXTRNP  _DbgBreakPointWithStatus,1
        stdCall _KdPollBreakIn
        or      al,al
        jz      short c_
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
c_:
endif
endm

;++
;
;   ASSERT_FS
;
;   Try to catch funky condition wherein we get FS=r3 value while
;   running in kernel mode.
;
;--

ASSERT_FS   macro
local   a,b

if DBG
        EXTRNP   _KeBugCheck,1

        cmp     dword ptr fs:[0], 0
        jne     short b

a:
        stdCall   _KeBugCheck,<-1>
align 4
b:
endif
endm



;++
;
;
;   Copy data from various places into base of TrapFrame, net effect
;   is to allow dbg KB command to trace accross trap frame, and to
;   allow user to find arguments to system calls.
;
;   USE ebx and edi.
;--

SET_DEBUG_DATA  macro

ife FPO

;
; This macro is used by ENTER_SYSTEM_CALL, ENTER_TRAP and ENTER_INTERRUPT
; and is used at the end of above macros.  It is safe to destroy ebx, edi.
;

        mov     ebx,[ebp]+TsEbp
        mov     edi,[ebp]+TsEip
        mov     [ebp]+TsDbgArgPointer,edx
        mov     [ebp]+TsDbgArgMark,0BADB0D00h
        mov     [ebp]+TsDbgEbp,ebx
        mov     [ebp]+TsDbgEip,edi
endif

endm

;++
;
;   ENTER_SYSCALL
;
;   Macro Description:
;
;       Build the frame and set registers needed by a system call.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;
;       Don't Save:
;           Volatile regs
;           Seg regs
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Direction
;
;   Arguments:
;       None.
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, edx
;
;   Note:
;       The DS: reference to PreviousMode is *required* for correct
;       functioning of lazy selector loads.  If you remove this use
;       of DS:, put a DS: override on something.
;
;--

ENTER_SYSCALL macro

.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

ifdef KERNELONLY

;
; Construct trap frame.
;
; N.B. The initial part of the trap frame is constructed by pushing values
;      on the stack. If the format of the trap frame is changed, then the
;      following code must alos be changed.
;

        push    0                       ; put pad dword for error on stack
        push    ebp                     ; save the non-volatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;

;
; Save the old exception list in trap frame and initialize a new empty
; exception list.
;

        push    PCR[PcExceptionList]    ; save old exception list
        mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END ; set new empty list

;
; Allocate the remainder of trap frame,
;

        sub     esp,TsExceptionList
        mov     ebp,esp                 ; set trap frame address
        cld                             ; make sure direction is forward

        SET_DEBUG_DATA                  ; Note this destroys edi

        sti                             ; enable interrupts

else
        %out    ENTER_SYSCAL outside of kernel
        .err
endif
        endm

;++
;
;   ENTER_INTERRUPT  PassParm
;
;   Macro Description:
;
;       Build the frame and set registers needed by an interrupt.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;           Volatile regs
;           Seg regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode
;
;   Arguments:
;       PassParm -
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, ecx, edx
;
;--

ENTER_INTERRUPT macro   PassParm
        local b

.FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

ifb <PassParm>
        push    esp                 ; put pad dword for error on stack
endif
        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        sub     esp, TsEdi
        mov     ebp,esp

        mov     [esp]+TsEax, eax    ; Save volatile registers
        mov     [esp]+TsEcx, ecx
        mov     [esp]+TsEdx, edx

        mov     ebx, PCR[PcExceptionList] ;Save, set ExceptionList
        mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END
        mov     [esp]+TsExceptionList, ebx

        cld

        SET_DEBUG_DATA

        endm

;++
;
;   ENTER_TRAP
;
;   Macro Description:
;
;       Build the frame and set registers needed by a trap or exception.
;
;       Save:
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Volatile regs
;           Seg Regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode,
;           ExceptionList
;
;   Arguments:
;       None.
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax
;
;--

ENTER_TRAP macro
        local b

.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

        mov     word ptr [esp+2], 0 ; Clear upper word of ErrorCode

        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        mov     ebx, PCR[PcExceptionList] ;Save ExceptionList
        push    ebx
        push    eax                 ; Save the volatile registers
        push    ecx
        push    edx

;
;   Skip allocate reset of trap frame.
;

        sub     esp,TsEdx

        mov     ebp,esp

        cld
        SET_DEBUG_DATA

        endm
;++
;
;   EXIT_ALL    NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
;
;   Macro Description:
;
;       Load a syscall frame back into the machine.
;
;       Restore:
;           Volatile regs, IF NoRestoreVolatiles blank
;           NoPreviousMode,
;           ExceptionList,
;           FS,
;           Non-volatile regs
;
;       If the frame is a kernel mode frame, AND esp has been edited,
;       then TsSegCs will have a special value.  Test for that value
;       and execute special code for that case.
;
;       N.B. This macro generates an IRET!  (i.e. It exits!)
;
;   Arguments:
;
;       NoRestoreSegs - non-blank if DS, ES, GS are NOT to be restored
;
;       NoRestoreVolatiles - non-blank if Volatile regs are NOT to be restored
;
;       NoPreviousMode - if nb pop ThPreviousMode
;
;   Entry-conditions:
;
;       (esp)->base of trap frame
;       (ebp)->Base of trap frame
;
;   Exit-conditions:
;
;       Does not exit, returns.
;       Preserves eax, ecx, edx, IFF NoRestoreVolatiles is set
;
;--

?adjesp = 0
?RestoreAll = 1

EXIT_ALL macro  NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
local   a, b, f, x
local   Db_NotATrapFrame, Db_A, Db_NotValidEntry
local   DbgHalt, DbgNoHalt, DbgDoneHalt

;
; Sanity check some values and setup globals for macro
;

?adjesp = TsEdx
?RestoreAll = 1

ifnb <NoRestoreSegs>
    ?RestoreAll = 0
endif

ifnb <NoRestoreVolatiles>
    if ?RestoreAll eq 1
        %out "EXIT_ALL NoRestoreVolatiles requires NoRestoreSegs"
        .err
    endif
    ?adjesp = ?adjesp + 12
endif

ifb <NoPreviousMode>
ifndef KERNELONLY
        %out    EXIT_ALL can not restore previousmode outside kernel
        .err
endif
endif

; All callers are responsible for getting here with interrupts disabled.

if DBG
        pushfd
        pop     edx

        test    edx, EFLAGS_INTERRUPT_MASK
        jnz     Db_NotValidEntry

        cmp     esp, ebp                    ; make sure esp = ebp
        jne     Db_NotValidEntry

; Make sure BADB0D00 sig is present.  If not this isn't a trap frame!
Db_A:   sub     [esp]+TsDbgArgMark,0BADB0D00h
        jne     Db_NotATrapFrame
endif

        ASSERT_FS

        mov     edx, [esp]+TsExceptionList
if DBG
        or      edx, edx
        jnz     short @f
    int 3
@@:
endif
        mov     PCR[PcExceptionList], edx   ; Restore ExceptionList

        test    word ptr [esp]+TsSegCs,FRAME_EDITED
        jz      b                           ; Edited frame pop out.

ifb <NoRestoreVolatiles>
ifb <NoRestoreSegs>                         ; must restore eax before any
        mov     eax, [esp].TsEax            ; selectors! (see trap0e handler)
endif
endif

ifb <NoRestoreVolatiles>
        mov     edx, [ebp]+TsEdx            ; Restore volitales
        mov     ecx, [ebp]+TsEcx
ifb <NoRestoreSegs>
else
        mov     eax, [ebp]+TsEax
endif
endif   ; NoRestoreVolatiles

        lea     esp, [ebp]+TsEdi            ; Skip PreMode, ExceptList and fs

ifdef DEVKIT
        ; check for requested halt
        mov     edi, PCR[PcPrcbData+PbDebugHaltThread]
        test    edi, edi
        jnz     short DbgHalt
DbgNoHalt:
        ; EBP is toast here, so we'd better not need it
endif

        pop     edi                         ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        add     esp, 4              ; remove error code from trap frame
        iretd                       ; return

ifdef DEVKIT
DbgHalt:
        ; There is a requested halt, so let's see if now's the time to halt
        push    eax
        mov     eax, PCR[PcIrql]
        push    ecx
        push    edx
        test    eax, eax            ; only break if irql = 0
        jne     DbgDoneHalt
        call    edi
        test    al, al
        je      DbgDoneHalt
        sti
        mov     ebp, [esp+24]       ; load up the saved EBP so the debugger
        int     3h                  ; shows a reasonable trace
        cli
DbgDoneHalt:
        pop     edx
        pop     ecx
        pop     eax
        jmp     DbgNoHalt
endif

if DBG
Db_NotATrapFrame:
        add     [esp]+TsDbgArgMark,0BADB0D00h   ; put back the orig value
Db_NotValidEntry:
        int 3
        jmp     Db_A
endif

;
;   TsSegCs contains the special value that means the frame was edited
;   in a way that affected esp, AND it's a kernel mode frame.
;   (Special value is null selector except for RPL.)
;
;   Put back the real CS.
;   push eflags, eip onto target stack
;   restore
;   switch to target stack
;   iret
;

b:      mov     ebx,[esp]+TsTempSegCs
        mov     [esp]+TsSegCs,ebx

;
;   There is no instruction that will load esp with an arbitrary value
;   (i.e. one out of a frame) and do a return, if no privledge transition
;   is occuring.  Therefore, if we are returning to kernel mode, and
;   esp has been edited, we must "emulate" a kind of iretd.
;
;   We do this by logically pushing the eip,cs,eflags onto the new
;   logical stack, loading that stack, and doing an iretd.  This
;   requires that the new logical stack is at least 1 dword higher
;   than the unedited esp would have been.  (i.e.  It is not legal
;   to edit esp to have a new value < the old value.)
;
;   KeContextToKframes enforces this rule.
;

;
;   Compute new logical stack address
;

        mov     ebx,[esp]+TsTempEsp
        sub     ebx,12
        mov     [esp]+TsErrCode,ebx

;
;   Copy eip,cs,eflags to new stack.  note we do this high to low
;

        mov     esi,[esp]+TsEflags
        mov     [ebx+8],esi
        mov     esi,[esp]+TsSegCs
        mov     [ebx+4],esi
        mov     esi,[esp]+TsEip
        mov     [ebx],esi

;
;   Do a standard restore sequence.
;
;   Observe that RestoreVolatiles is honored.  Editing a volatile
;   register has no effect when returning from a system call.
;
ifb     <NoRestoreVolatiles>
        mov     eax,[esp].TsEax
endif
;        add     esp,TsSegGs
;
;ifb     <NoRestoreSegs>
;        pop     gs
;        pop     es
;        pop     ds
;else
;        add     esp,12
;endif

ifb     <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx
        mov     ecx, [esp]+TsEcx
endif

;ifnb <NoPreviousMode>
;        add     esp, 4              ; Skip previous mode
;else
;        pop     ebx                 ; Restore PreviousMode
;        mov     esi,fs:[PcPrcbData+PbCurrentThread]
;        mov     ss:[esi]+ThPreviousMode,bl
;endif
;
;       pop     ebx
;
;       mov     fs:[PcExceptionList], ebx ;Restore ExceptionList
;       pop     fs

        add     esp, TsEdi
        pop     edi                 ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
;   (esp)->TsErrCode, where we saved the new esp
;

        mov     esp,[esp]           ; Do move not push to avoid increment
        iretd

        endm


;++
;
;   INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from an interrupt vector service
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution. If control is returning to
;       user mode and there is a user  APC pending, then APC level interupt
;       will be requested and control is transfered to the user APC delivery
;       routine, if no higher level interrupt pending.
;
;   Arguments:
;
;       (TOS)   = previous irql
;       (TOS+4 ...) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

INTERRUPT_EXIT     macro
local   a

if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif

        cli
        pop     ecx
        jmp     @HalEndSystemInterrupt@4

endm


;++
;
;   LEVEL_INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from an interrupt vector service
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution. If control is returning to
;       user mode and there is a user  APC pending, then APC level interupt
;       will be requested and control is transfered to the user APC delivery
;       routine, if no higher level interrupt pending.
;
;   Arguments:
;
;       (eax)-> bus interrupt level
;       (TOS)   = previous irql
;       (TOS+4 ...) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

LEVEL_INTERRUPT_EXIT     macro
local   a

if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif

        cli
        pop     ecx
        jmp     @HalEndSystemLevelInterrupt@4

endm


;++
;
;   SPURIOUS_INTERRUPT_EXIT
;
;   Macro Description:
;
;       To exit an interrupt without performing the EOI.
;
;   Arguments:
;
;       (TOS) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

SPURIOUS_INTERRUPT_EXIT  macro
local   a
if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif
        jmp     Kei386EoiHelper@0
endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\thredini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent function to set the initial
    context and data alignment handling mode for a process or thread object.

Author:

    David N. Cutler (davec) 31-Mar-1990

Environment:

    Kernel mode only.

Revision History:

    3 April 90  bryan willman

        This version ported to 386.

--*/

#include "ki.h"

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN SIZE_T TlsDataSize,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread object.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    TlsDataSize - Supplies the number of bytes reserved from the kernel stack
        for thread local storage.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

Return Value:

    None.

--*/

{
    PFX_SAVE_AREA NpxFrame;
    PVOID TlsData;
    PKSWITCHFRAME SwitchFrame;
    PULONG PSystemRoutine;
    PULONG PStartRoutine;
    PULONG PStartContext;

    //
    // Load up an initial NPX state.
    //

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->StackBase) -
                sizeof(FX_SAVE_AREA)));

    RtlZeroMemory((PVOID)NpxFrame, sizeof(FX_SAVE_AREA));

    NpxFrame->FloatSave.ControlWord = 0x27f;     //like fpinit but 64bit mode
    NpxFrame->FloatSave.MXCsr       = 0x1f80;    // mask all the exceptions

    //
    // Thread's NPX state is not in the coprocessor.
    //

    Thread->NpxState = NPX_STATE_NOT_LOADED;

    //
    // Zero the thread local storage area.
    //

    TlsDataSize = ALIGN_UP(TlsDataSize, ULONG);
    TlsData = ((PUCHAR)(ULONG)NpxFrame) - TlsDataSize;

    if (TlsDataSize != 0) {
        Thread->TlsData = TlsData;
        RtlZeroMemory(TlsData, TlsDataSize);
    } else {
        Thread->TlsData = NULL;
    }

    //
    // Space for arguments to KiThreadStartup.  Order of fields in the
    // switchframe is important, since args are passed on stack through
    // KiThreadStartup to PStartRoutine with PStartContext as an argument.
    //

    PStartContext = (PULONG)((ULONG)TlsData) - 1;
    PStartRoutine = PStartContext - 1;
    PSystemRoutine = PStartRoutine - 1;

    SwitchFrame = (PKSWITCHFRAME)((PUCHAR)PSystemRoutine - sizeof(KSWITCHFRAME));

    //
    // Set up thread start parameters.
    //

    *PStartContext = (ULONG)StartContext;
    *PStartRoutine = (ULONG)StartRoutine;
    *PSystemRoutine = (ULONG)SystemRoutine;

    //
    // Set up switch frame.
    //

    SwitchFrame->RetAddr = (ULONG)KiThreadStartup;

    SwitchFrame->Eflags = EFLAGS_INTERRUPT_MASK;

    SwitchFrame->ExceptionList = (ULONG)(EXCEPTION_CHAIN_END);

    //
    // Set the initial kernel stack pointer.
    //

    Thread->KernelStack = (PVOID)SwitchFrame;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\threadbg.asm ===
title  "Thread Startup"

;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    threadbg.asm
;
; Abstract:
;
;    This module implements the code necessary to startup a thread in kernel
;    mode.
;
; Author:
;
;    Bryan Willman (bryanwi) 22-Feb-1990, derived from DaveC's code.
;
; Environment:
;
;    Kernel mode only, IRQL PASSIVE_LEVEL.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KeBugCheck,1
        EXTRNP  _PsTerminateSystemThread,1
        extrn   _KiPCR:DWORD

        page ,132
        subttl  "Thread Startup"

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; Routine Description:
;
;    This routine is called at thread startup. Its function is to call the
;    initial thread procedure.
;
; Arguments:
;
;   (TOS)    = SystemRoutine - address of initial system routine.
;   (TOS+4)  = StartRoutine - Initial thread routine.
;   (TOS+8)  = StartContext - Context parm for initial thread routine.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiThreadStartup    ,1

        xor     ebx,ebx             ; clear registers
        xor     esi,esi             ;
        xor     edi,edi             ;
        xor     ebp,ebp             ;
        mov     ecx, PASSIVE_LEVEL
        fstCall KfLowerIrql         ; KeLowerIrql(PASSIVE_LEVEL)

;
; Check if PsCreateSystemThreadEx failed to fully initialize the thread.  If so,
; it will mark the thread as already terminated and use PsTerminateSystemThread
; to cleanup the thread.
;

        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        cmp     BYTE PTR [eax].ThHasTerminated, 0
        jne     kits20

;
; Invoke the system routine.
;

        pop     eax                 ; (eax)->SystemRoutine
        call    eax                 ; SystemRoutine(StartRoutine, StartContext)
IFNDEF STD_CALL
        add     esp,8               ; Clear off args
ENDIF

kits10: stdCall _KeBugCheck, <NO_USER_MODE_CONTEXT>

kits20: stdCall _PsTerminateSystemThread, <STATUS_NO_MEMORY>

stdENDP _KiThreadStartup

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\newsysbg.asm ===
title  "System Startup"
;++
;
; Copyright (c) 1989-2001  Microsoft Corporation
;
; Module Name:
;
;    newsysbg.asm
;
; Abstract:
;
;    This module implements the code necessary to initially startup the
;    NT system.
;
; Environment:
;
;    Kernel mode only.
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, 0 )
endm
        .list

        option  segment:flat

        EXTRNP  _KdInitSystem,1
        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KiPreInitializeKernel
        EXTRNP  _KiInitializeKernel
        extrn   SwapContext:PROC
        EXTRNP  _KiSwapGDT
        EXTRNP  _KiSwapIDT
        extrn   _KiTrap08:PROC
        extrn   _KiTrap02:PROC
        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _KeBugCheckEx, 5
        EXTRNP  _HalMicrocodeUpdateLoader,0
        EXTRNP  HalClearSoftwareInterrupt,1,,FASTCALL
        EXTRNP  _MmPrepareToQuickRebootSystem,0

        extrn   _KeHasQuickBooted:BYTE
        extrn   _KiIDT:BYTE
        extrn   _KiIDTLEN:BYTE          ; NOTE - really an ABS, linker problems

ifdef DEVKIT
        extrn   _KiDpcDispatchNotify:DWORD
endif

if DBG
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        extrn   _DbgPrint:near
        extrn   _MsgDpcTrashedEsp:BYTE
        extrn   _MsgDpcFpuEnabled:BYTE
endif

;
; Constants for various variables
;

_DATA   SEGMENT PARA PUBLIC 'DATA'

COMM    _KiDoubleFaultStackLimit:byte:DOUBLE_FAULT_STACK_SIZE
COMM    _KiIdleThreadStackLimit:byte:KERNEL_STACK_SIZE

        align   16
        public  _KiIdleThread
_KiIdleThread  label   byte
        db      ExtendedThreadObjectLength dup(0) ; sizeof (ETHREAD)

        align   16
        dd      3 dup(0) ; padding to force PbNpxSaveArea to be 16 byte aligned
.errnz ((SIZEOF DWORD * 3 + PcPrcbData + PbNpxSaveArea) AND 15)
        public  _KiPCR
_KiPCR label dword
        db      ProcessorControlRegisterLength dup (0)

_DATA   ends

STICKY  SEGMENT PARA PUBLIC 'DATA'

;
; Allocate space for the task state segments.
;

INITIALIZE_TSS macro HandlerRoutine, HandlerStack
        dw      0                       ; TssBacklink
        dw      0                       ; TssReserved0
        dd      HandlerStack            ; TssEsp0
        dw      KGDT_R0_DATA            ; TssSs0
        dw      0                       ; TssReserved1
        dd      0                       ; TssEsp1
        dw      0                       ; TssSs1
        dw      0                       ; TssReserved2
        dd      0                       ; TssEsp2
        dw      0                       ; TssSs2
        dw      0                       ; TssReserved3
        dd      0                       ; TssCR3
        dd      HandlerRoutine          ; TssEip
        dd      0                       ; TssEFlags
        dd      0                       ; TssEax
        dd      0                       ; TssEcx
        dd      0                       ; TssEdx
        dd      0                       ; TssEbx
        dd      HandlerStack            ; TssEsp
        dd      0                       ; TssEbp
        dd      0                       ; TssEsi
        dd      0                       ; TssEdi
        dw      KGDT_R0_DATA            ; TssEs
        dw      0                       ; TssReserved4
        dw      KGDT_R0_CODE            ; TssCs
        dw      0                       ; TssReserved5
        dw      KGDT_R0_DATA            ; TssSs
        dw      0                       ; TssReserved6
        dw      KGDT_R0_DATA            ; TssDs
        dw      0                       ; TssReserved7
        dw      KGDT_R0_PCR             ; TssFs
        dw      0                       ; TssReserved8
        dw      0                       ; TssGs
        dw      0                       ; TssReserved9
        dw      0                       ; TssLDT
        dw      0                       ; TssReserved10
        dw      0                       ; TssFlags
        dw      TssIoMaps               ; TssIoMapBase
        endm

        align   8
        public  _KiNormalTSS
_KiNormalTSS label byte
INITIALIZE_TSS 0, 0

        align   8
        public  _KiDoubleFaultTSS
_KiDoubleFaultTSS label byte
INITIALIZE_TSS <OFFSET _KiTrap08>, <OFFSET _KiDoubleFaultStackLimit + DOUBLE_FAULT_STACK_SIZE>

        align   8
        public  _KiNMITSS
_KiNMITSS label byte
INITIALIZE_TSS <OFFSET _KiTrap02>, <OFFSET _KiDoubleFaultStackLimit + DOUBLE_FAULT_STACK_SIZE>

;
; Allocate space for the global descriptor table.
;

GDTEntry macro  base,limit,flags
        dw      limit
        dd      base
        dw      flags
        endm

        align   8
        public  _KiGDT, _KiGDTLEN, _KiGDTEnd
_KiGDT label byte

GDTEntry        0, 0, 0                                                 ; KGDT_NULL
GDTEntry        0, 0FFFFh, 0CB9Bh                                       ; KGDT_R0_CODE
GDTEntry        0, 0FFFFh, 0CF93h                                       ; KGDT_R0_DATA
GDTEntry        <OFFSET _KiNormalTSS>, TssIoMaps, 89h                   ; KGDT_TSS
GDTEntry        <OFFSET _KiPCR>, ProcessorControlRegisterLength, 0C093h ; KGDT_R0_PCR
GDTEntry        <OFFSET _KiDoubleFaultTSS>, TssIoMaps, 89h              ; KGDT_DF_TSS
GDTEntry        <OFFSET _KiNMITSS>, TssIoMaps, 89h                      ; KGDT_NMI_TSS

_KiGDTLEN       equ     $ - _KiGDT
_KiGDTEnd       equ     $

STICKY  ends

        page ,132
        subttl  "System Startup"
INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; For processor 0, Routine Description:
;
;    This routine is called when the NT system begins execution.
;    Its function is to initialize system hardware state, call the
;    kernel initialization routine, and then fall into code that
;    represents the idle thread for all processors.
;
;    Entry state created by the boot loader:
;       A short-form IDT (0-1f) exists and is active.
;       A complete GDT is set up and loaded.
;       A complete TSS is set up and loaded.
;       Page map is set up with minimal start pages loaded
;           The lower 4Mb of virtual memory are directly mapped into
;           physical memory.
;
;           The system code (ntoskrnl.exe) is mapped into virtual memory
;           as described by its memory descriptor.
;       DS=ES=SS = flat
;       ESP->a usable boot stack
;       Interrupts OFF
;
; For processor > 0, Routine Description:
;
;   This routine is called when each additional processor begins execution.
;   The entry state for the processor is:
;       IDT, GDT, TSS, stack, selectors, PCR = all valid
;       Page directory is set to the current running directory
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiSystemStartup,0

;
; Initialize ebp, esp, and argument registers for initializing the kernel.
; Reserve space for idle thread stack NPX_SAVE_AREA, enough padding bytes to
; store the initial context from KiInitializeContextThread and the FWORD for
; lgdt/lidt.
;

        xor     ebp, ebp                ; (ebp) = 0.   No more stack frame
        mov     esp, offset _KiIdleThreadStackLimit + KERNEL_STACK_SIZE - NPX_FRAME_LENGTH - 64

;
; Rearrange the bytes in KiGDT to match the processor's layout.
;

        stdCall _KiSwapGDT

;
; Load the global descriptor table register.
;

        mov     WORD PTR [esp], _KiGDTLEN
        mov     DWORD PTR [esp+2], OFFSET _KiGDT
        lgdt    FWORD PTR [esp]

;
; Execute a 16:32 jump to reload the code selector.
;

        db      0EAh
        dd      OFFSET kis10
        dw      KGDT_R0_CODE

;
; Reload the data selectors.
;

kis10:  mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax

;
; Load the various selector registers.
;

        push    KGDT_R0_PCR
        pop     fs

        mov     eax, KGDT_TSS
        ltr     ax

;
; Initialize TssCr3 of the task state segments to the boot page directory.
;

        mov     eax, cr3
        mov     dword ptr [_KiNormalTSS]+TssCr3, eax
        mov     dword ptr [_KiDoubleFaultTSS]+TssCr3, eax
        mov     dword ptr [_KiNMITSS]+TssCr3, eax

;
; Update the microcode for the processor.
;

        stdCall _HalMicrocodeUpdateLoader

;
; Since the entries of Kernel IDT have their Selector and Extended Offset
; fields set up in the wrong order, we need to swap them back to the order
; which i386 recognizes.
;

        stdCall _KiSwapIDT

;
; Load the interrupt descriptor table register.
;

        mov     ecx, offset FLAT:_KiIDTLEN
        mov     WORD PTR [esp], cx
        mov     DWORD PTR [esp+2], OFFSET _KiIDT
        lidt    FWORD PTR [esp]

;
; Preinitialize the system data structures.
;

        stdCall _KiPreInitializeKernel

;
; Enable the kernel debugger.
;

        stdCall _KdInitSystem, <1>

if  DEVL
;
; Give the debugger an opportunity to gain control.
;

        POLL_DEBUGGER
endif   ; DEVL
        nop                             ; leave a spot for int-3 patch

;
; Set initial IRQL = HIGH_LEVEL for init
;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql

;
; Initialize system data structures and HAL.
;

        stdCall _KiInitializeKernel

;
; Set "shadow" priority value for Idle thread.  This will keep the Mutex
; priority boost/drop code from dropping priority on the Idle thread, and
; thus avoids leaving a bit set in the ActiveMatrix for the Idle thread when
; there should never be any such bit.
;

        mov     byte ptr [_KiIdleThread]+ThPriority,LOW_REALTIME_PRIORITY

;
; Control is returned to the idle thread with IRQL at HIGH_LEVEL. Lower IRQL
; to DISPATCH_LEVEL and set wait IRQL of idle thread.
;

        sti
        mov     ecx, DISPATCH_LEVEL
        fstCall KfLowerIrql
        mov     byte ptr [_KiIdleThread]+ThWaitIrql, DISPATCH_LEVEL

;
; The following code represents the idle thread for a processor. The idle
; thread executes at IRQL DISPATCH_LEVEL and continually polls for work to
; do. Control may be given to this loop either as a result of a return from
; the system initialization routine or as the result of starting up another
; processor in a multiprocessor configuration.
;

        jmp     KiIdleLoop              ; enter idle loop

stdENDP _KiSystemStartup

INIT   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'      ; Put IdleLoop in text section
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; DECLSPEC_NORETURN
; VOID
; KeQuickRebootSystem(
;     VOID
;     )
;
; Routine Description:
;
;     This function quick reboots the system.  The .data section is refreshed
;     from the ROM and system initialization is started again.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _KeQuickRebootSystem,0

;
; Disable interrupts.
;

        cli

;
; Initialize ebp, esp, and argument registers for initializing the kernel.
; Reserve space for idle thread stack NPX_SAVE_AREA, enough padding bytes to
; store the initial context from KiInitializeContextThread and the FWORD for
; lgdt/lidt.
;

        xor     ebp, ebp                ; (ebp) = 0.   No more stack frame
        mov     esp, offset _KiIdleThreadStackLimit + KERNEL_STACK_SIZE - NPX_FRAME_LENGTH - 64

;
; Inform the memory manager that we're about to quick reboot the system.  This
; will cause us to switch back to large pages and to make the ROM visible so
; that we can copy out our .data section again.
;

        stdCall _MmPrepareToQuickRebootSystem

;
; Copy the initialized portion of the .data section from ROM.  Note that the
; stack that we're running on is part of this data image, so don't use the
; stack here or in the next block.
;

        cld
        mov     ecx, dword ptr ds:[MzXdataSectionHeader]+XdshSizeOfInitializedData
        shr     ecx, 2
        mov     esi, dword ptr ds:[MzXdataSectionHeader]+XdshPointerToRawData
        mov     edi, dword ptr ds:[MzXdataSectionHeader]+XdshVirtualAddress
        rep     movsd

;
; Zero out the uninitialized portion of the .data section.
;

        mov     ecx, dword ptr ds:[MzXdataSectionHeader]+XdshSizeOfUninitializedData
        xor     eax, eax
        shr     ecx, 2
        rep     stosd

;
; Indicate to the rest of the system that we're initializing due to a quick
; boot.
;

        mov     byte ptr [_KeHasQuickBooted], 1

;
; Since the entries of Kernel IDT have their Selector and Extended Offset
; fields set up in the wrong order, we need to swap them back to the order
; which i386 recognizes.
;

        stdCall _KiSwapIDT

;
; Load the interrupt descriptor table register.
;

        mov     ecx, offset FLAT:_KiIDTLEN
        mov     WORD PTR [esp], cx
        mov     DWORD PTR [esp+2], OFFSET _KiIDT
        lidt    FWORD PTR [esp]

;
; Preinitialize the system data structures.
;

        stdCall _KiPreInitializeKernel

;
; Enable the kernel debugger.
;

        stdCall _KdInitSystem, <1>

;
; Set initial IRQL = HIGH_LEVEL for init
;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql

;
; Initialize system data structures and HAL.
;

        stdCall _KiInitializeKernel

;
; Set "shadow" priority value for Idle thread.  This will keep the Mutex
; priority boost/drop code from dropping priority on the Idle thread, and
; thus avoids leaving a bit set in the ActiveMatrix for the Idle thread when
; there should never be any such bit.
;

        mov     byte ptr [_KiIdleThread]+ThPriority,LOW_REALTIME_PRIORITY

;
; Control is returned to the idle thread with IRQL at HIGH_LEVEL. Lower IRQL
; to DISPATCH_LEVEL and set wait IRQL of idle thread.
;

        sti
        mov     ecx, DISPATCH_LEVEL
        fstCall KfLowerIrql
        mov     byte ptr [_KiIdleThread]+ThWaitIrql, DISPATCH_LEVEL

;
; The following code represents the idle thread for a processor. The idle
; thread executes at IRQL DISPATCH_LEVEL and continually polls for work to
; do. Control may be given to this loop either as a result of a return from
; the system initialization routine or as the result of starting up another
; processor in a multiprocessor configuration.
;

        jmp     KiIdleLoop              ; enter idle loop

stdENDP _KeQuickRebootSystem

        page ,132
        subttl  "Idle Loop"
;++
;
; Routine Description:
;
;    This routine continuously executes the idle loop and never returns.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    None - routine never returns.
;
;--

        public  KiIdleLoop
KiIdleLoop proc

        lea     ebx, _KiPCR             ; get address of PCR
        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address

kid10:

;
; N.B. The following code enables interrupts for a few cycles, then
;      disables them again for the subsequent DPC and next thread
;      checks.
;

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        je      short CheckNextThread   ; if eq, DPC list is empty
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        fstCall HalClearSoftwareInterrupt ; clear software interrupt
        call    KiRetireDpcList         ; process the current DPC list

;
; Check if a thread has been selected to run on the current processor.
;

CheckNextThread:                        ;
        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; thread selected?
        je      short kid10             ; if eq, no thread selected

;
; A thread has been selected for execution on this processor. Acquire
; the dispatcher database lock, get the thread address again (it may have
; changed), clear the address of the next thread in the processor block,
; and call swap context to start execution of the selected thread.
;
; N.B. If the dispatcher database lock cannot be obtained immediately,
;      then attempt to process another DPC rather than spinning on the
;      dispatcher database lock.
;

        sti                             ; enable interrupts
        mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; set current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address

        mov     cl, 1                   ; set APC interrupt bypass disable
        call    SwapContext             ;

        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address
        jmp     kid10

KiIdleLoop      endp

        page ,132
        subttl  "Retire DPC List Loop"
;++
;
; Routine Description:
;
;    This routine continuously executes a retire DPC loop and never returns.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    None - routine never returns.
;
;--

cPublicProc _KeRetireDpcListLoop,0

        lea     ebx, _KiPCR             ; get address of PCR
        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address

;
; This routine is entered at DPC level from a HAL DPC routine.  Clear the flag
; that indicates that we're already executing a DPC so that the debug code in
; the clock interrupt won't fire because we're taking too long to execute.
;

        mov     [ebx].PcPrcbData.PbDpcRoutineActive, 0

krd10:

;
; N.B. The following code enables interrupts for a few cycles, then
;      disables them again for the subsequent DPC and next thread
;      checks.
;

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        je      short krd10             ; if eq, DPC list is empty
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        fstCall HalClearSoftwareInterrupt ; clear software interrupt
        call    KiRetireDpcList         ; process the current DPC list
        jmp     short krd10

stdENDP _KeRetireDpcListLoop

        page ,132
        subttl  "Retire Deferred Procedure Call List"
;++
;
; Routine Description:
;
;    This routine is called to retire the specified deferred procedure
;    call list. DPC routines are called using the idle thread (current)
;    stack.
;
;    N.B. Interrupts must be disabled and the DPC list lock held on entry
;         to this routine. Control is returned to the caller with the same
;         conditions true.
;
;    N.B. The registers ebx and ebp are preserved across the call.
;
; Arguments:
;
;    ebx - Address of the target processor PCR.
;    ebp - Address of the target DPC listhead.
;
; Return value:
;
;    None.
;
;--

        public  KiRetireDpcList
KiRetireDpcList proc

?FpoValue = 0

FPOFRAME ?FpoValue,0

;
; Disable the FPU to catch the use of floating point from a DPC without first
; calling KeSaveFloatingPointState and KeRestoreFloatingPointState.
;

if DBG
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        jne     rdl5
        mov     eax, cr0                ; retrieve CR0
        or      eax, CR0_MP+CR0_TS
        lmsw    ax                      ; load new CR0 (low 16-bits)
endif

rdl5:   mov     PCR[PcPrcbData.PbDpcRoutineActive], esp ; set DPC routine active

;
; Process the DPC List.
;

rdl10:                                  ;

        mov     edx, [ebp].LsFlink      ; get address of next entry
        mov     ecx, [edx].LsFlink      ; get address of next entry
        mov     [ebp].LsFlink, ecx      ; set address of next in header
        mov     [ecx].LsBlink, ebp      ; set address of previous in next
        sub     edx, DpDpcListEntry     ; compute address of DPC object
        mov     ecx, [edx].DpDeferredRoutine ; get DPC routine address

if DBG
        push    ecx                     ; remember DPC routine address
        push    edi                     ; save register
        mov     edi, esp                ; save current stack pointer
endif

ifdef DEVKIT
        push    esi                     ; save esi register
endif

FPOFRAME ?FpoValue,0

        push    [edx].DpSystemArgument2 ; second system argument
        push    [edx].DpSystemArgument1 ; first system argument
        push    [edx].DpDeferredContext ; get deferred context argument
        push    edx                     ; address of DPC object
        mov     byte ptr [edx]+DpInserted, 0 ; clear DPC inserted state
if DBG
        mov     PCR[PcPrcbData.PbDebugDpcTime], 0 ; Reset the time in DPC
endif

        sti                             ; enable interrupts

;
; If the profiler is active, call its notification routine.
;
ifdef DEVKIT
        cmp     _KiDpcDispatchNotify, 0
        jne     rdl70
        call    ecx                     ; call DPC routine
rdl20:  pop     esi                     ; restore esi

else
        call    ecx                     ; call DPC routine
endif

if DBG

;
; Verify that the DPC returned with the FPU disabled.  If the FPU is enabled,
; then the DPC probably forgot to call KeRestoreFloatingPointState.
;

        mov     eax, cr0                ; retrieve CR0
        test    al, CR0_TS              ; test if FPU is still disabled
        je      rdl57                   ; if e, FPU not disabled

;
; Verify that the DPC returned at DISPATCH_LEVEL.
;

rdl25:  movzx   eax, byte ptr PCR[PcIrql] ; get current IRQL
        cmp     al, DISPATCH_LEVEL      ; check if still at dispatch level
        jne     rdl55                   ; if ne, not at dispatch level
        cmp     esp, edi                ; check if stack pointer is correct
        jne     rdl60                   ; if ne, stack pointer is not correct
rdl30:  pop     edi                     ; restore register
        pop     ecx                     ; pop off saved DPC routine address

endif

FPOFRAME ?FpoValue,0

rdl35:  cli                             ; disable interrupts
        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        jne     rdl10                   ; if ne, DPC list not empty

;
; Clear DPC routine active and DPC requested flags.
;

rdl40:  mov     [ebx].PcPrcbData.PbDpcRoutineActive, 0
        mov     [ebx].PcPrcbData.PbDpcInterruptRequested, 0

;
; Check one last time that the DPC list is empty. This is required to
; close a race condition with the DPC queuing code where it appears that
; a DPC routine is active (and thus an interrupt is not requested), but
; this code has decided the DPC list is empty and is clearing the DPC
; active flag.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        jne     rdl5                    ; if ne, DPC list not empty

;
; Restore the original CR0 if the current thread still owns the FPU.  Note that
; if a DPC called KeSaveFloatingPointState or hit the debugger, then the FPU
; state was flushed, so we shouldn't enable the FPU.
;

if DBG
        mov     ecx, PCR[PcPrcbData+PbCurrentThread]
        cmp     byte ptr [ecx].ThNpxState, NPX_STATE_LOADED
        jne     rdl50

        mov     eax, cr0
        mov     edx, [ebx].PcStackBase
        and     eax, NOT (CR0_MP+CR0_EM+CR0_TS)
        or      eax, [edx].FpCr0NpxState
        lmsw    ax                      ; load new CR0 (low 16-bits)
endif

rdl50:  ret                             ; return

;
; Unlock DPC list and clear DPC active.
;

if DBG

rdl55:  stdCall _KeBugCheckEx, <IRQL_NOT_GREATER_OR_EQUAL, ebx, eax, 0, 0> ;

rdl57:  push    dword ptr [edi+4]
        push    offset FLAT:_MsgDpcFpuEnabled ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 8                  ; remove arguments from stack
        int     3                       ; break into debugger
        mov     esp, edi                ; reset stack pointer
        jmp     rdl25                   ;

rdl60:  push    dword ptr [edi+4]       ; push address of DPC function
        push    offset FLAT:_MsgDpcTrashedEsp ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 8                  ; remove arguments from stack
        int     3                       ; break into debugger
        mov     esp, edi                ; reset stack pointer
        jmp     rdl30                   ;

endif

;
; Notify the profiler that a DPC routine is called:
;
;   VOID (FASTCALL *KiDpcDispatchNotify)(VOID*, ULONG)
;

ifdef DEVKIT
rdl70:  mov     esi, ecx                ; save DPC routine address in esi
        xor     edx, edx                ; KiDpcDispatchNotify(dpcproc, 0)
        call    [_KiDpcDispatchNotify]

        call    esi                     ; call the DPC routine

        mov     ecx, esi                ; KiDpcDispatchNotify(dpcproc, 1)
        mov     edx, 1
        call    [_KiDpcDispatchNotify]
        jmp     rdl20
endif

KiRetireDpcList endp

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\timindex.asm ===
TITLE   "Compute Timer Table Index"
;++
;
; Copyright (c) 1993  Microsoft Corporation
;
; Module Name:
;
;    timindex.asm
;
; Abstract:
;
;    This module implements the code necessary to compute the timer table
;    index for a timer.
;
; Author:
;
;    David N. Cutler (davec) 19-May-1993
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc            ; calling convention macros
        .list

        extrn  _KiTimeIncrementReciprocal:dword
        extrn  _KiTimeIncrementShiftCount:BYTE

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page
        subttl  "Compute Timer Table Index"
;++
;
; ULONG
; KiComputeTimerTableIndex (
;    IN LARGE_INTEGER Interval,
;    IN LARGE_INTEGER CurrentTime,
;    IN PKTIMER Timer
;    )
;
; Routine Description:
;
;    This function computes the timer table index for the specified timer
;    object and stores the due time in the timer object.
;
;    N.B. The interval parameter is guaranteed to be negative since it is
;         expressed as relative time.
;
;    The formula for due time calculation is:
;
;    Due Time = Current Time - Interval
;
;    The formula for the index calculation is:
;
;    Index = (Due Time / Maximum time) & (Table Size - 1)
;
;    The time increment division is performed using reciprocal multiplication.
;
; Arguments:
;
;    Interval  - Supplies the relative time at which the timer is to
;        expire.
;
;    CurrentCount  - Supplies the current system tick count.
;
;    Timer - Supplies a pointer to a dispatch object of type timer.
;
; Return Value:
;
;    The time table index is returned as the function value and the due
;    time is stored in the timer object.
;
;--

LocalStack  equ  20

Interval    equ [esp+LocalStack+4]
CurrentTime equ [esp+LocalStack+12]
Timer       equ [esp+LocalStack+20]

cPublicProc _KiComputeTimerTableIndex ,5
        sub     esp, LocalStack
        mov     [esp+16], ebx
        mov     ebx,CurrentTime         ; get low current time
        mov     ecx,CurrentTime + 4     ; get high current time
        sub     ebx,Interval            ; subtract low parts
        sbb     ecx,Interval + 4        ; subtract high parts and borrow
        mov     eax,Timer               ; get address of timer object
        mov     [eax].TiDueTime.LiLowPart,ebx ; set low part of due time
        mov     [eax].TiDueTime.LiHighPart,ecx ; set high part of due time

;
; Compute low 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax,ebx                 ; copy low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        mov     [esp+12], edx           ; save high order 32-bits of product

;
; Compute low 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax,ebx                 ; copy low 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal+4] ;multiply by high 32-bits of divisor
        mov     [esp+8], eax            ; save full 64-bit product
        mov     [esp+4], edx            ;

;
; Compute high 32-bits of dividend times low 32-bits of divisor.
;

        mov     eax,ecx                 ; copy high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal] ; multiply by low 32-bits of divisor
        mov     [esp+0], edx            ; save high 32-bits of product

;
; Compute carry out of low 64-bits of 128-bit product.
;

        xor     ebx,ebx                 ; clear carry accumlator
        add     eax,[esp]+8             ; generate carry
        adc     ebx,0                   ; accumlate carry
        add     eax,[esp]+12             ; generate carry
        adc     ebx,0                   ; accumulate carry

;
; Compute high 32-bits of dividend times high 32-bits of divisor.
;

        mov     eax,ecx                 ; copy high 32-bits of dividend
        mul     [_KiTimeIncrementReciprocal+4] ; multiply by high 32-bits of divisor

;
; Compute high 64-bits of 128-bit product.
;

        add     eax,ebx                 ; add carry from low 64-bits
        adc     edx,0                   ; propagate carry
        add     eax,[esp]+0             ; add and generate carry
        adc     edx,0                   ; propagate carry
        add     eax,[esp]+4             ; add and generate carry
        adc     edx,0                   ; propagate carry

;
; Right shift the result by the specified shift count and mask off extra
; bits.
;

        mov     cl,[_KiTimeIncrementShiftCount] ; get shift count value
        shrd    eax,edx,cl              ; extract appropriate product bits

        mov     ebx, [esp+16]           ; restore register
        add     esp, LocalStack         ; trim stack
        and     eax,(TIMER_TABLE_SIZE-1); reduce to size of table

        stdRET    _KicomputeTimerTableIndex

stdENDP _KiComputeTimerTableIndex

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    trap.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    trap conditions.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 4-Feb-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
        .list


        page ,132
        extrn   ExpInterlockedPopEntrySListFault:DWORD
        extrn   ExpInterlockedPopEntrySListResume:DWORD
        extrn   _KiHardwareTrigger:dword
        extrn   _KiBugCheckData:dword
        EXTRNP  _KeGetCurrentIrql,0

        EXTRNP  _HalHandleNMI,0
        EXTRNP  HalBeginSystemInterrupt,2,,FASTCALL
        EXTRNP  HalEndSystemInterrupt,1,,FASTCALL
        EXTRNP  _KiDispatchException,4
        EXTRNP  _MmAccessFault,3
        EXTRNP  _KeBugCheck,1
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeTestAlertThread,1
        EXTRNP  _KiContinue,3
        EXTRNP  _KiRaiseException,5
        extrn   _DbgPrint:proc
        EXTRNP  _Ki386CheckDivideByZeroTrap,1
        extrn   SwapContext:near
        extrn   _KiGDT:BYTE
        extrn   _KiPCR:DWORD
        extrn   _KiDoubleFaultTSS:DWORD
ifdef DEVKIT
        EXTRNP  _KdSetOwedBreakpoints
        extrn   _KdpOweBreakpoint:dword
endif

;
; Equates for exceptions which cause system fatal error
;

EXCEPTION_DIVIDED_BY_ZERO       EQU     0
EXCEPTION_DEBUG                 EQU     1
EXCEPTION_NMI                   EQU     2
EXCEPTION_INT3                  EQU     3
EXCEPTION_BOUND_CHECK           EQU     5
EXCEPTION_INVALID_OPCODE        EQU     6
EXCEPTION_NPX_NOT_AVAILABLE     EQU     7
EXCEPTION_DOUBLE_FAULT          EQU     8
EXCEPTION_NPX_OVERRUN           EQU     9
EXCEPTION_INVALID_TSS           EQU     0AH
EXCEPTION_SEGMENT_NOT_PRESENT   EQU     0BH
EXCEPTION_STACK_FAULT           EQU     0CH
EXCEPTION_GP_FAULT              EQU     0DH
EXCEPTION_RESERVED_TRAP         EQU     0FH
EXCEPTION_NPX_ERROR             EQU     010H
EXCEPTION_ALIGNMENT_CHECK       EQU     011H

;
; Exception flags
;

EXCEPT_UNKNOWN_ACCESS           EQU     0H
EXCEPT_LIMIT_ACCESS             EQU     10H

;
; page fault read/write mask
;

ERR_0E_STORE                    EQU     2

;
; EFLAGS single step bit
;

EFLAGS_TF_BIT                   EQU     100h
EFLAGS_OF_BIT                   EQU     4000H

;
;   Force assume into place
;

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT   ENDS

_DATA   SEGMENT PARA PUBLIC 'DATA'

;
; Definitions for gate descriptors
;

GATE_TYPE_386INT        EQU     0E00H
GATE_TYPE_386TRAP       EQU     0F00H
GATE_TYPE_TASK          EQU     0500H
D_GATE                  EQU     0
D_PRESENT               EQU     8000H
D_DPL_3                 EQU     6000H
D_DPL_0                 EQU     0

;
; Definitions for present 386 trap and interrupt gate attributes
;

D_TRAP032               EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386TRAP
D_TRAP332               EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386TRAP
D_INT032                EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_386INT
D_INT332                EQU     D_PRESENT+D_DPL_3+D_GATE+GATE_TYPE_386INT
D_TASK                  EQU     D_PRESENT+D_DPL_0+D_GATE+GATE_TYPE_TASK

;
;       This is the protected mode interrupt descriptor table.
;

if DBG
BadInterruptMessage db 0ah,7,7,'!!! Unexpected Interrupt %02lx !!!',0ah,00
endif

;++
;
;   DEFINE_SINGLE_EMPTY_VECTOR - helper for DEFINE_EMPTY_VECTORS
;
;--

DEFINE_SINGLE_EMPTY_VECTOR macro    number
IDTEntry    _KiUnexpectedInterrupt&number, D_INT032
_TEXT   SEGMENT
        public  _KiUnexpectedInterrupt&number
_KiUnexpectedInterrupt&number proc
        push    dword ptr (&number)
        jmp     _KiUnexpectedInterruptTail
_KiUnexpectedInterrupt&number endp
_TEXT   ENDS

        endm

FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, FPO_TRAPFRAME )
endm

FXSAVE_ESI  macro
    db  0FH, 0AEH, 06
endm

FXSAVE_ECX  macro
    db  0FH, 0AEH, 01
endm

FXRSTOR_ECX macro
    db  0FH, 0AEH, 09
endm

;++
;
;   DEFINE_EMPTY_VECTORS emits an IDTEntry macro (and thus and IDT entry)
;   into the data segment.  It then emits an unexpected interrupt target
;   with push of a constant into the code segment.  Labels in the code
;   segment are defined to bracket the unexpected interrupt targets so
;   that KeConnectInterrupt can correctly test for them.
;
;   Empty vectors will be defined from 30 to 3f, which is the hardware
;   vector set.
;
;--

NUMBER_OF_IDT_VECTOR    EQU     03fH

DEFINE_EMPTY_VECTORS macro

;
;   Set up
;

        empty_vector = 00H

_TEXT   SEGMENT
IFDEF STD_CALL
        public  _KiStartUnexpectedRange@0
_KiStartUnexpectedRange@0   equ     $
ELSE
        public  _KiStartUnexpectedRange
_KiStartUnexpectedRange     equ     $
ENDIF
_TEXT   ENDS

        rept (NUMBER_OF_IDT_VECTOR - (($ - _KiIDT)/8)) + 1

        DEFINE_SINGLE_EMPTY_VECTOR  %empty_vector
        empty_vector = empty_vector + 1

        endm    ;; rept

_TEXT   SEGMENT
IFDEF STD_CALL
        public  _KiEndUnexpectedRange@0
_KiEndUnexpectedRange@0     equ     $
ELSE
        public  _KiEndUnexpectedRange
_KiEndUnexpectedRange       equ     $
ENDIF
_TEXT   ENDS

        endm    ;; DEFINE_EMPTY_VECTORS macro

IDTEntry macro  name,access
        dd      offset FLAT:name
        dw      access
        dw      KGDT_R0_CODE
        endm

IDTEntryEx macro  name,access,sel
        dd      offset FLAT:name
        dw      access
        dw      sel
        endm

ALIGN 8
                public  _KiIDT, _KiIDTLEN, _KiIDTEnd
_KiIDT          label byte

IDTEntry        _KiTrap00, D_INT032             ; 0: Divide Error
IDTEntry        _KiTrap01, D_INT032             ; 1: DEBUG TRAP
IDTEntryEx      _KiTrap02, D_TASK, KGDT_NMI_TSS ; 2: NMI/NPX Error
IDTEntry        _KiTrap03, D_INT332             ; 3: Breakpoint
IDTEntry        _KiTrap04, D_INT332             ; 4: INTO
IDTEntry        _KiTrap05, D_INT032             ; 5: BOUND/Print Screen
IDTEntry        _KiTrap06, D_INT032             ; 6: Invalid Opcode
IDTEntry        _KiTrap07, D_INT032             ; 7: NPX Not Available
IDTEntryEx      _KiTrap08, D_TASK, KGDT_DF_TSS  ; 8: Double Exception
IDTEntry        _KiTrap09, D_INT032             ; 9: NPX Segment Overrun
IDTEntry        _KiTrap0A, D_INT032             ; A: Invalid TSS
IDTEntry        _KiTrap0B, D_INT032             ; B: Segment Not Present
IDTEntry        _KiTrap0C, D_INT032             ; C: Stack Fault
IDTEntry        _KiTrap0D, D_INT032             ; D: General Protection
IDTEntry        _KiTrap0E, D_INT032             ; E: Page Fault
IDTEntry        _KiTrap0F, D_INT032             ; F: Intel Reserved

IDTEntry        _KiTrap10, D_INT032             ;10: 486 coprocessor error
IDTEntry        _KiTrap11, D_INT032             ;11: 486 alignment
IDTEntry        _KiTrap0F, D_INT032             ;12: Machine-Check
IDTEntry        _KiTrap13, D_INT032             ;13: XMMI unmasked numeric exception
IDTEntry        _KiTrap0F, D_INT032             ;14: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;15: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;16: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;17: Intel Reserved

IDTEntry        _KiTrap0F, D_INT032             ;18: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;19: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1A: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1B: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1C: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1D: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1E: Intel Reserved
IDTEntry        _KiTrap0F, D_INT032             ;1F: Reserved for APIC

        rept 28H - (($ - _KiIDT)/8)
IDTEntry        0, 0                            ;invalid IDT entry
        endm
IDTEntry        _KiContinueService, D_INT332        ;28: NtContinue service
IDTEntry        _KiRaiseExceptionService, D_INT332  ;29: NtRaiseException service
IDTEntry        0, 0                                ;2A: OBSOLETE: KiGetTickCount service
IDTEntry        0, 0                                ;2B: OBSOLETE: KiCallbackReturn
IDTEntry        0, 0                                ;2C: OBSOLETE: KiSetLowWaitHighThread service
IDTEntry        _KiDebugService,  D_INT332          ;2D: debugger calls
IDTEntry        0, 0                                ;2E: OBSOLETE: system service calls
IDTEntry        _KiTrap0F, D_INT032                 ;2F: Reserved for APIC

;
;   Generate per-vector unexpected interrupt entries for 30 - 3f
;
        DEFINE_EMPTY_VECTORS

_KiIDTLEN       equ     $ - _KiIDT
_KiIDTEnd       equ     $

                public  _KiUnexpectedEntrySize
_KiUnexpectedEntrySize          dd  _KiUnexpectedInterrupt1 - _KiUnexpectedInterrupt0

;
; definition for  floating status word error mask
;

FSW_INVALID_OPERATION   EQU     1
FSW_DENORMAL            EQU     2
FSW_ZERO_DIVIDE         EQU     4
FSW_OVERFLOW            EQU     8
FSW_UNDERFLOW           EQU     16
FSW_PRECISION           EQU     32
FSW_STACK_FAULT         EQU     64
FSW_CONDITION_CODE_0    EQU     100H
FSW_CONDITION_CODE_1    EQU     200H
FSW_CONDITION_CODE_2    EQU     400H
FSW_CONDITION_CODE_3    EQU     4000H
_DATA   ENDS

_TEXT   SEGMENT
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page    ,132
        subttl "NtContinue service"
;++
;
; Routine Description:
;
;    This routine gains control when trap occurs via vector 28H.
;
;    After the trap frame is constructed, control is transferred to
;    NtContinue.  The call will not return.
;
; Arguments:
;
;    eax - ContextRecord parameter to NtContinue.
;    ecx - TestAlert parameter to NtContinue.
;
; Return Value:
;
;    Does not return.
;
;--

align 16
        PUBLIC  _KiContinueService
_KiContinueService proc

        ENTER_SYSCALL
        stdCall _NtContinue, <eax, ecx>

_KiContinueService endp

        page    ,132
        subttl "NtRaiseException service"
;++
;
; Routine Description:
;
;    This routine gains control when trap occurs via vector 29H.
;
;    After the trap frame is constructed, control is transferred to
;    NtRaiseException.  The call will not return.
;
; Arguments:
;
;    eax - ExceptionRecord parameter to NtRaiseException.
;    ecx - ContextRecord parameter to NtRaiseException.
;    edx - FirstChance parameter to NtRaiseException.
;
; Return Value:
;
;    Does not return.
;
;--

align 16
        PUBLIC  _KiRaiseExceptionService
_KiRaiseExceptionService proc

        ENTER_SYSCALL
        stdcall _NtRaiseException, <eax, ecx, edx>

_KiRaiseExceptionService endp

;
;   System service's private version of KiExceptionExit
;   (Also used by KiDebugService)
;
        public  _KiServiceExit
_KiServiceExit:

        cli                                         ; disable interrupts

;
; Exit from SystemService
;

        EXIT_ALL    NoRestoreSegs, NoRestoreVolatile

;++
;
;   _KiServiceExit2 - same as _KiServiceExit BUT the full trap_frame
;       context is restored
;
;--
        public  _KiServiceExit2
_KiServiceExit2:

        cli                             ; disable interrupts

;
; Exit from SystemService
;
        EXIT_ALL                            ; RestoreAll

        page ,132
        subttl  "Common Trap Exit"
;++
;
;   KiExceptionExit
;
;   Routine Description:
;
;       This code is transfered to at the end of the processing for
;       an exception.  Its function is to restore machine state, and
;       continue thread execution.  If control is returning to user mode
;       and there is a user APC pending, then control is transfered to
;       the user APC delivery routine.
;
;       N.B. It is assumed that this code executes at IRQL zero or APC_LEVEL.
;          Therefore page faults and access violations can be taken.
;
;       NOTE: This code is jumped to, not called.
;
;   Arguments:
;
;       (ebp) -> base of trap frame.
;
;   Return Value:
;
;       None.
;
;--
align 4
        public  _KiExceptionExit
_KiExceptionExit proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        cli                             ; disable interrupts

;
; Exit from Exception
;

        EXIT_ALL    ,,NoPreviousMode

_KiExceptionExit endp


;++
;
;   KiUnexpectedInterruptTail
;
;   Routine Description:
;       This function is jumped to by an IDT entry who has no interrupt
;       handler.
;
;   Arguments:
;
;       (esp) -> base of trap frame.
;       (ebp) -> base of trap frame.
;
;--

        public  _KiUnexpectedInterruptTail
_KiUnexpectedInterruptTail  proc
        ENTER_INTERRUPT PassDwordParm

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

        mov     ecx, [ebp]+TsErrCode    ; get IRQ passed through error code
        mov     edx, HIGH_LEVEL
        push    0                       ; make space for OldIrql

        fstCall HalBeginSystemInterrupt

if DBG
        push    dword ptr [ebp]+TsErrCode
        push    offset FLAT:BadInterruptMessage
        call    _DbgPrint               ; display unexpected interrupt message
        add     esp, 8
endif
;
; end this interrupt
;
        INTERRUPT_EXIT

_KiUnexpectedInterruptTail  endp


        page , 132
        subttl "trap processing"

;++
;
; Routine Description:
;
;    _KiTrapxx - protected mode trap entry points
;
;    These entry points are for internally generated exceptions,
;    such as a general protection fault.  They do not handle
;    external hardware interrupts, or user software interrupts.
;
; Arguments:
;
;    On entry the stack looks like:
;
;       [ss]
;       [esp]
;       eflags
;       cs
;       eip
;    ss:sp-> [error]
;
;    The cpu saves the previous SS:ESP, eflags, and CS:EIP on
;    the new stack if there was a privilige transition. If no
;    priviledge level transition occurred, then there is no
;    saved SS:ESP.
;
;    Some exceptions save an error code, others do not.
;
; Return Value:
;
;       None.
;
;--


        page , 132
        subttl "dispatch exception"

;++
;
; CommonDispatchException
;
; Routine Description:
;
;    This routine allocates exception record on stack, sets up exception
;    record using specified parameters and finally sets up arguments
;    and calls _KiDispatchException.
;
;    NOTE:
;
;    The purpose of this routine is to save code space.  Use this routine
;    only if:
;    1. ExceptionRecord is NULL
;    2. ExceptionFlags is 0
;    3. Number of parameters is less or equal than 3.
;
;    Otherwise, you should use DISPATCH_EXCEPTION macro to set up your special
;    exception record.
;
; Arguments:
;
;    (eax) = ExcepCode - Exception code to put into exception record
;    (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
;    (ecx) = NumParms - Number of additional parameters
;    (edx) = Parameter1
;    (esi) = Parameter2
;    (edi) = Parameter3
;
; Return Value:
;
;    None.
;
;--
CommonDispatchException0Args:
        xor     ecx, ecx                ; zero arguments
        call    CommonDispatchException

CommonDispatchException1Arg0d:
        xor     edx, edx                ; zero edx
CommonDispatchException1Arg:
        mov     ecx, 1                  ; one argument
        call    CommonDispatchException ; there is no return

CommonDispatchException2Args0d:
        xor     edx, edx                ; zero edx
CommonDispatchException2Args:
        mov     ecx, 2                  ; two arguments
        call    CommonDispatchException ; there is no return

      public CommonDispatchException
align dword
CommonDispatchException proc
cPublicFpo 0, ExceptionRecordLength / 4
;
;       Set up exception record for raising exception
;

        sub     esp, ExceptionRecordLength
                                        ; allocate exception record
        mov     dword ptr [esp]+ErExceptionCode, eax
                                        ; set up exception code
        xor     eax, eax
        mov     dword ptr [esp]+ErExceptionFlags, eax
                                        ; set exception flags
        mov     dword ptr [esp]+ErExceptionRecord, eax
                                        ; set associated exception record
        mov     dword ptr [esp]+ErExceptionAddress, ebx
        mov     dword ptr [esp]+ErNumberParameters, ecx
                                        ; set number of parameters
        cmp     ecx, 0
        je      short de00

        lea     ebx, [esp + ErExceptionInformation]
        mov     [ebx], edx
        mov     [ebx+4], esi
        mov     [ebx+8], edi
de00:
;
; set up arguments and call _KiDispatchException
;

        mov     ecx, esp                ; (ecx)->exception record

; 1 - first chance TRUE
; ebp - trap frame addr
; 0 - Null exception frame
; ecx - exception record addr

        stdCall _KiDispatchException,<ecx, 0, ebp, 1>

        mov     esp, ebp                ; (esp) -> trap frame
        jmp     _KiExceptionExit

CommonDispatchException endp

        page ,132
        subttl "Divide error processing"
;++
;
; Routine Description:
;
;    Handle divide error fault.
;
;    The divide error fault occurs if a DIV or IDIV instructions is
;    executed with a divisor of 0, or if the quotient is too big to
;    fit in the result operand.
;
;    An INTEGER DIVIDED BY ZERO exception will be raised for the fault.
;    If the fault occurs in kernel mode, the system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap00
_KiTrap00       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; Set up exception record for raising Integer_Divided_by_zero exception
; and call _KiDispatchException
;

if DBG
        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jnz     short @f                                ; interrupts disabled?

        xor     eax, eax
        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,-1,eax,esi>
@@:
endif

        sti

;
; Flat mode
;
; The intel processor raises a divide by zero expcetion on DIV instruction
; which overflows. To be compatible we other processors we want to
; return overflows as such and not as divide by zero's.  The operand
; on the div instruction is tested to see if it's zero or not.
;
        stdCall _Ki386CheckDivideByZeroTrap,<ebp>
        mov     ebx, [ebp]+TsEip        ; (ebx)-> faulting instruction
        jmp     CommonDispatchException0Args ; Won't return

_KiTrap00       endp

        page ,132
        subttl "Debug Exception"
;++
;
; Routine Description:
;
;    Handle debug exception.
;
;    The processor triggers this exception for any of the following
;    conditions:
;
;    1. Instruction breakpoint fault.
;    2. Data address breakpoint trap.
;    3. General detect fault.
;    4. Single-step trap.
;    5. Task-switch breadkpoint trap.
;
;
; Arguments:
;
;    At entry, the values of saved CS and EIP depend on whether the
;    exception is a fault or a trap.
;    No error code is provided with the divide error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap01
_KiTrap01       proc

; Set up machine state frame for displaying

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; Set up exception record for raising single step exception
; and call _KiDispatchException
;

        and     dword ptr [ebp]+TsEflags, not EFLAGS_TF_BIT
        mov     ebx, [ebp]+TsEip                ; (ebx)-> faulting instruction
        mov     eax, STATUS_SINGLE_STEP
        jmp     CommonDispatchException0Args    ; Never return

_KiTrap01       endp

        page ,132
        subttl "Nonmaskable Interrupt"
;++
;
; Routine Description:
;
;    Handle Nonmaskable interrupt.
;
;    An NMI is typically used to signal serious system conditions
;    such as bus time-out, memory parity error, and so on.
;
;    Upon detection of the NMI, the system will be terminated, ie a
;    bugcheck will be raised, no matter what previous mode is.
;
; Arguments:
;
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap02
_KiTrap02       proc
.FPO (1, 0, 0, 0, 0, 2)
        cli

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; Clear the busy bit in the TSS selector
;
        mov     byte ptr [_KiGDT+KGDT_NMI_TSS+5],089h

;
; Let the HAL have a crack at it before we crash
;
        stdCall _HalHandleNMI

        stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP,2,0,0,0>

_KiTrap02       endp

        page ,132
        subttl "DebugService Breakpoint"
;++
;
; Routine Description:
;
;    Handle INT 2d DebugService
;
;    The trap is caused by an INT 2d.  This is used instead of a
;    BREAKPOINT exception so that parameters can be passed for the
;    requested debug service.  A BREAKPOINT instruction is assumed
;    to be right after the INT 2d - this allows this code to share code
;    with the breakpoint handler.
;
; Arguments:
;     eax - ServiceClass - which call is to be performed
;     ecx - Arg1 - generic first argument
;     edx - Arg2 - generic second argument
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiDebugService
_KiDebugService  proc
        push    0                           ; push dummy error code
        ENTER_TRAP
;       sti                                 ; *NEVER sti here*

        inc     dword ptr [ebp]+TsEip
        mov     eax, [ebp]+TsEax            ; ServiceClass
        mov     ecx, [ebp]+TsEcx            ; Arg1      (already loaded)
        mov     edx, [ebp]+TsEdx            ; Arg2      (already loaded)
        jmp     KiTrap03DebugService

_KiDebugService  endp

        page ,132
        subttl "Single Byte INT3 Breakpoin"
;++
;
; Routine Description:
;
;    Handle INT 3 breakpoint.
;
;    The trap is caused by a single byte INT 3 instruction.  A
;    BREAKPOINT exception with additional parameter indicating
;    READ access is raised for this trap if previous mode is user.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INT 3 instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap03
_KiTrap03       proc
        push    0                       ; push dummy error code
        ENTER_TRAP

   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

        mov     eax, BREAKPOINT_BREAK

KiTrap03DebugService:

;
; Set up exception record and arguments for raising breakpoint exception
;

        mov     esi, ecx                ; ExceptionInfo 2
        mov     edi, edx                ; ExceptionInfo 3
        mov     edx, eax                ; ExceptionInfo 1

        mov     ebx, [ebp]+TsEip
        dec     ebx                     ; (ebx)-> int3 instruction
        mov     ecx, 3
        mov     eax, STATUS_BREAKPOINT
        call    CommonDispatchException ; Never return

_KiTrap03       endp

        page ,132
        subttl "Integer Overflow"
;++
;
; Routine Description:
;
;    Handle INTO overflow.
;
;    The trap occurs when the processor encounters an INTO instruction
;    and the OF flag is set.
;
;    An INTEGER_OVERFLOW exception will be raised for this fault.
;
;    N.B. i386 will not generate fault if only OF flag is set.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the instruction immediately
;    following the INTO instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap04
_KiTrap04       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; set exception record and arguments and call _KiDispatchException
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> instr. after INTO
        dec     ebx                     ; (ebx)-> INTO
        mov     eax, STATUS_INTEGER_OVERFLOW
        jmp     CommonDispatchException0Args ; Never return

_KiTrap04       endp

        page ,132
        subttl "Bound Check fault"
;++
;
; Routine Description:
;
;    Handle bound check fault.
;
;    The bound check fault occurs if a BOUND instruction finds that
;    the tested value is outside the specified range.
;
;    For bound check fault, an ARRAY BOUND EXCEEDED exception will be
;    raised.
;    For kernel mode exception, it causes system to be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting BOUND
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap05
_KiTrap05       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

;
; set exception record and arguments and call _KiDispatchException
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->BOUND instruction
        mov     eax, STATUS_ARRAY_BOUNDS_EXCEEDED
        jmp     CommonDispatchException0Args ; Won't return

_KiTrap05       endp

        page ,132
        subttl "Invalid OP code"
;++
;
; Routine Description:
;
;    Handle invalid op code fault.
;
;    The invalid opcode fault occurs if CS:EIP point to a bit pattern which
;    is not recognized as an instruction by the 386.  This may happen if:
;
;    1. the opcode is not a valid 80386 instruction
;    2. a register operand is specified for an instruction which requires
;       a memory operand
;    3. the LOCK prefix is used on an instruction that cannot be locked
;
;    If fault occurs in USER mode:
;       an Illegal_Instruction exception will be raised
;    if fault occurs in KERNEL mode:
;       system will be terminated.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the invalid
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap06
_KiTrap06       proc

        push    0                       ; Push dummy error code
        ENTER_TRAP

;
; set exception record and arguments and call _KiDispatchException
;
        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)-> invalid instruction
        mov     eax, STATUS_ILLEGAL_INSTRUCTION
        jmp     CommonDispatchException0Args ; Won't return

_KiTrap06       endp

        page ,132
        subttl "Coprocessor Not Avalaible"
;++
;
; Routine Description:
;
;   Handle Coprocessor not avaliable exception.
;
;   If we are REALLY emulating the 80387, the trap 07 vector is edited
;   to point directly at the emulator's entry point.  So this code is
;   only hit when an 80387 DOES exist.
;
;   The current threads coprocessor state is loaded into the
;   coprocessor.  If the coprocessor has a different threads state
;   in it (UP only) it is first saved away.  The thread is then continued.
;   Note: the threads state may contian the TS bit - In this case the
;   code loops back to the top of the Trap07 handler.  (which is where
;   we would end up if we let the thread return to user code anyway).
;
;   If the threads NPX context is in the coprocessor and we hit a Trap07
;   there is an NPX error which needs to be processed.  If the trap was
;   from usermode the error is dispatched.  If the trap was from kernelmode
;   the error is remembered, but we clear CR0 so the kernel code can
;   continue.  We can do this because the kernel mode code will restore
;   CR0 (and set TS) to signal a delayed error for this thread.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the first byte of the faulting
;    instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap07
_KiTrap07       proc

        push    0                       ; push dummy error code
        ENTER_TRAP
Kt0700:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack
        cli                             ; don't context switch

;
; Bugcheck if attempting to use the FPU from a DPC without first calling
; KeSaveFloatingPointState.
;

if DBG
        cmp     PCR[PcPrcbData.PbDpcRoutineActive],0
        jne     Kt07110
endif

Kt0701: cmp     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        je      Kt0715

;
; Trap occured and this threads NPX state is not loaded.  Load it now
; and resume the application.  If someone elses state is in the coprocessor
; (uniprocessor implementation only) then save it first.
;

        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, ebx                ; allow frstor (& fnsave) to work

Kt0702:
        mov     edx, PCR[PcPrcbData+PbNpxThread] ; Owner of NPX state
        or      edx, edx                ; NULL?
        jz      Kt0704                  ; Yes - skip save

;
; Due to an hardware errata we need to know that the coprocessor
; doesn't generate an error condition once interrupts are disabled and
; trying to perform an fnsave which could wait for the error condition
; to be handled.
;
; The fix for this errata is that we "know" that the coprocessor is
; being used by a different thread then the one which may have caused
; the error condition.  The round trip time to swap to a new thread
; is longer then ANY floating point instruction.  We therefore know
; that any possible coprocessor error has already occured and been
; handled.
;
        mov     esi,[edx].ThStackBase
        sub     esi, NPX_FRAME_LENGTH   ; Space for NPX_FRAME

        FXSAVE_ESI
        mov     byte ptr [edx].ThNpxState, NPX_STATE_NOT_LOADED
Kt0704:

;
; Load current threads coprocessor state into the coprocessor
;
; (eax) - CurrentThread
; (ecx) - CurrentThreads NPX save area
; (ebx) - CR0
; (ebp) - trap frame
; Interrupts disabled
;

        FXRSTOR_ECX                     ; reload NPX context

Kt0704c:
        mov     byte ptr [eax].ThNpxState, NPX_STATE_LOADED
        mov     PCR[PcPrcbData+PbNpxThread], eax  ; owner of coprocessors state

        sti                             ; Allow interrupts & context switches
        nop                             ; sti needs one cycle

        cmp     dword ptr [ecx].FpCr0NpxState, 0
        jz      _KiExceptionExit        ; nothing to set, skip CR0 reload

;
; Note: we have to get the CR0 value again to insure that we have the
;       correct state for TS.  We may have context switched since
;       the last move from CR0, and our npx state may have been moved off
;       of the npx.
;
        cli
if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz short Kt07dbg1
endif
        mov     ebx,CR0
        or      ebx, [ecx].FpCr0NpxState
        mov     cr0, ebx                ; restore threads CR0 NPX state
        sti
        test    ebx, CR0_TS             ; Setting TS?  (delayed error)
        jz      _KiExceptionExit        ; No - continue

        jmp     Kt0700                  ; Dispatch delayed exception
if DBG
Kt07dbg1:    int 3
Kt07dbg2:    int 3
Kt07dbg3:    int 3
        sti
        jmp short $-2
endif

;
; A Trap07 or Trap10 has occured from a ring 0 ESCAPE instruction.  This
; may occur when trying to load the coprocessors state.  These
; code paths rely on Cr0NpxState to signal a delayed error (not CR0) - we
; set CR0_TS in Cr0NpxState to get a delayed error, and make sure CR0 CR0_TS
; is not set so the R0 ESC instruction(s) can complete.
;
; (ecx) - CurrentThreads NPX save area
; (ebp) - trap frame
; Interrupts disabled
;

Kt0710:
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack

Kt0715:
if DBG
        mov     eax, cr0                    ; Did we fault because some bit in CR0
        test    eax, (CR0_TS+CR0_MP+CR0_EM)
        jnz     short Kt07dbg3
endif

        or      dword ptr [ecx].FpCr0NpxState, CR0_TS   ; signal a delayed error

Kt0716: mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack

Kt0720:
;
; Some type of coprocessor exception has occured for the current thread.
;
; (eax) - CurrentThread
; (ecx) - CurrentThreads NPX save area
; (ebp) - TrapFrame
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fnsave & fwait

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;

        FXSAVE_ECX

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt07dbg2
endif
        or      ebx, NPX_STATE_NOT_LOADED
        or      ebx,[ecx]+FpCr0NpxState ; restore this threads CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

;
; According to the floating error priority, we test what is the cause of
; the NPX error and raise an appropriate exception.
;

        mov     ebx, [ecx] + FxErrorOffset
        movzx   eax, word ptr [ecx] + FxControlWord
        movzx   edx, word ptr [ecx] + FxStatusWord
        mov     esi, [ecx] + FxDataOffset ; (esi) = operand addr

        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        not     eax                        ; ax = mask of enabled exceptions
        and     eax, edx
        test    eax, FSW_INVALID_OPERATION ; Is it an invalid op exception?
        jz      short Kt0740               ; if z, no, go Kt0740
        test    eax, FSW_STACK_FAULT       ; Is it caused by stack fault?
        jnz     short Kt0730               ; if nz, yes, go Kt0730

; Raise Floating reserved operand exception
;

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0730:
;
; Raise Access Violation exception for stack overflow/underflow
;

        mov     eax, STATUS_FLOAT_STACK_CHECK
        jmp     CommonDispatchException2Args0d ; Won't return

Kt0740:

; Check for floating zero divide exception

        test    eax, FSW_ZERO_DIVIDE    ; Is it a zero divide error?
        jz      short Kt0750            ; if z, no, go Kt0750

; Raise Floating divided by zero exception

        mov     eax, STATUS_FLOAT_DIVIDE_BY_ZERO
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0750:

; Check for denormal error

        test    eax, FSW_DENORMAL       ; Is it a denormal error?
        jz      short Kt0760            ; if z, no, go Kt0760

; Raise floating reserved operand exception

        mov     eax, STATUS_FLOAT_INVALID_OPERATION
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0760:

; Check for floating overflow error

        test    eax, FSW_OVERFLOW       ; Is it an overflow error?
        jz      short Kt0770            ; if z, no, go Kt0770

; Raise floating overflow exception

        mov     eax, STATUS_FLOAT_OVERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0770:

; Check for floating underflow error

        test    eax, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt0780            ; if z, no, go Kt0780

; Raise floating underflow exception

        mov     eax, STATUS_FLOAT_UNDERFLOW
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt0780:

; Check for precision (IEEE inexact) error

        test    eax, FSW_PRECISION      ; Is it a precision error
        jz      short Kt07100           ; if z, no, go Kt07100

        mov     eax, STATUS_FLOAT_INEXACT_RESULT
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt07100:
        sti                             ; stop the system
        stdCall _KeBugCheck, <TRAP_CAUSE_UNKNOWN>

if DBG
Kt07110:
        cmp     byte ptr [eax].ThNpxIrql, DISPATCH_LEVEL
        je      Kt0701
        stdCall _KeBugCheck, <ATTEMPTED_FPU_USE_FROM_DPC>
endif

_KiTrap07       endp


        page ,132
        subttl "Double Fault"
;++
;
; Routine Description:
;
;    Handle double exception fault.
;
;    Normally, when the processor detects an exception while trying to
;    invoke the handler for a prior exception, the two exception can be
;    handled serially.  If, however, the processor cannot handle them
;    serially, it signals the double-fault exception instead.
;
;    If double exception is detected, no matter previous mode is USER
;    or kernel, a bugcheck will be raised and the system will be terminated.
;
; Arguments:
;
;    error code, which is always zero, is pushed on stack.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap08
_KiTrap08       proc
.FPO (0, 0, 0, 0, 0, 2)

        cli

ifdef DEVKIT
;
; If the debugger can handle a double fault now, then we do so
;
        lea     edi, PCR[PcPrcbData+PbDebugDoubleFault]
        mov     eax, [edi]
        test    eax, eax
        je      Kt0810

;
; we're only going to take one double fault at a time
;
        xor     edx, edx
        mov     [edi], edx

;
; find the old TSS
;
        mov     dx, word ptr [_KiDoubleFaultTSS]
        lea     ecx, _KiGDT
        mov     edi, [edx+ecx+2]
        push    edi
        mov     dl, [edx+ecx+7]
        mov     [esp+3], dl

;
; ask the debugger whether we can handle things
;
        call    eax
        test    al, al
        je      Kt0810

;
; we're good to go
;
        iretd
        jmp     _KiTrap08   ; in case we dbl-fault again
endif ; DEVKIT

Kt0810:
;
; Clear the busy bit in the TSS selector
;
        mov     byte ptr [_KiGDT+KGDT_DF_TSS+5],089h

;
; Clear Nested Task bit in EFLAGS
;
        pushfd
        and     [esp], not 04000h
        popfd

;
; The original machine context is in original task's TSS
;
@@:     stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP,8,0,0,0>
        jmp     short @b        ; do not remove - for debugger

_KiTrap08       endp

        page ,132
        subttl "Coprocessor Segment Overrun"
;++
;
; Routine Description:
;
;    Handle Coprocessor Segment Overrun exception.
;
;    This exception only occurs on the 80286 (it's a trap 0d on the 80386),
;    so choke if we get here.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap09
_KiTrap09       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

        sti
        mov     eax, EXCEPTION_NPX_OVERRUN ; (eax) = exception type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap09       endp

        page ,132
        subttl "Invalid TSS exception"
;++
;
; Routine Description:
;
;    Handle Invalid TSS fault.
;
;    This exception occurs if a segment exception other than the
;    not-present exception is detected when loading a selector
;    from the TSS.
;
;    If the exception is caused as a result of the kernel, device
;    drivers, or user incorrectly setting the NT bit in the flags
;    while the back-link selector in the TSS is invalid and the
;    IRET instruction being executed, in this case, this routine
;    will clear the NT bit in the trap frame and restart the iret
;    instruction.  For other causes of the fault, the user process
;    will be terminated if previous mode is user and the system
;    will stop if the exception occurs in kernel mode.  No exception
;    is raised.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
;    NT386 does not use TSS for context switching.  So, the invalid tss
;    fault should NEVER occur.  If it does, something is wrong with
;    the kernel.  We simply shutdown the system.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap0A
_KiTrap0A       proc

        ENTER_TRAP

        sti
        mov     eax, EXCEPTION_INVALID_TSS ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0A       endp

        page ,132
        subttl "Segment Not Present"
;++
;
; Routine Description:
;
;    Handle Segment Not Present fault.
;
;    This exception occurs when the processor finds the P bit 0
;    when accessing an otherwise valid descriptor that is not to
;    be loaded in SS register.
;
;    The only place the fault can occur (in kernel mode) is Trap/Exception
;    exit code.  Otherwise, this exception causes system to be terminated.
;    NT386 uses flat mode, the segment not present fault in Kernel mode
;    indicates system malfunction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code containing the segment causing the exception is provided.
;
; Return value:
;
;    None
;
;--
        page ,132
        subttl "Stack segment fault"
;++
;
; Routine Description:
;
;    Handle Stack Segment fault.
;
;    This exception occurs when the processor detects certain problem
;    with the segment addressed by the SS segment register:
;
;    1. A limit violation in the segment addressed by the SS (error
;       code = 0)
;    2. A limit vioalation in the inner stack during an interlevel
;       call or interrupt (error code = selector for the inner stack)
;    3. If the descriptor to be loaded into SS has its present bit 0
;       (error code = selector for the not-present segment)
;
;    The exception should never occurs in kernel mode except when we
;    perform the iret back to user mode.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        page ,132
        subttl "General Protection Fault"
;++
;
; Routine Description:
;
;    Handle General protection fault.
;
;    First, check to see if the fault occured in kernel mode with
;    incorrect selector values.  If so, this is a lazy segment load.
;    Correct the selector values and restart the instruction.  Otherwise,
;    parse out various kinds of faults and report as exceptions.
;
;    All protection violations that do not cause another exception
;    cause a general exception.  If the exception indicates a violation
;    of the protection model by an application program executing a
;    previleged instruction or I/O reference, a PRIVILEGED INSTRUCTION
;    exception will be raised.  All other causes of general protection
;    fault cause a ACCESS VIOLATION exception to be raised.
;
;    If previous mode = Kernel;
;        the system will be terminated  (assuming not lazy segment load)
;    Else previous mode = USER
;        the process will be terminated if the exception was not caused
;        by privileged instruction.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction or
;    the first instruction of the task if the fault occurs as part of
;    a task switch.
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap0B
_KiTrap0B       proc
_KiTrap0C       label byte
_KiTrap0D       label byte

; Set up machine state frame for displaying

        ENTER_TRAP

        sti
        mov     ebx, [ebp]+TsEip        ; (ebx)->faulting instruction
        mov     esi, [ebp]+TsErrCode
        mov     eax, STATUS_ACCESS_VIOLATION
        jmp     CommonDispatchException2Args0d ; Won't return

_KiTrap0B       endp

        page ,132
        subttl "Page fault processing"
;++
;
; Routine Description:
;
;    Handle page fault.
;
;    The page fault occurs if paging is enabled and any one of the
;    conditions is true:
;
;    1. page not present
;    2. the faulting procedure does not have sufficient privilege to
;       access the indicated page.
;
;    For case 1, the referenced page will be loaded to memory and
;    execution continues.
;    For case 2, registered exception handler will be invoked with
;    appropriate error code (in most cases STATUS_ACCESS_VIOLATION)
;
;    N.B. It is assumed that no page fault is allowed during task
;    switches.
;
;    N.B. INTERRUPTS MUST REMAIN OFF UNTIL AFTER CR2 IS CAPTURED.
;
; Arguments:
;
;    Error code left on stack.
;    CR2 contains faulting address.
;    Interrupts are turned off at entry by use of an interrupt gate.
;
; Return value:
;
;    None
;
;--

        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _KiTrap0E
_KiTrap0E       proc

        ENTER_TRAP

        mov     edi,cr2
        sti

        test    [ebp]+TsEFlags, EFLAGS_INTERRUPT_MASK   ; faulted with
        jz      Kt0e12b                 ; interrupts disabled?
Kt0e01:

;
; call _MmAccessFault to page in the not present page.  If the cause
; of the fault is 2, _MmAccessFault will return approriate error code
;

        sub     esp, 12
        mov     [esp+8], ebp            ; pass in the trap frame base
        mov     [esp+4], edi
        mov     eax, [ebp]+TsErrCode    ; (eax)= error code
        and     eax, ERR_0E_STORE       ; (eax)= 0 if fault caused by read
                                        ;      = 2 if fault caused by write
        shr     eax, 1                  ; (eax) = 0 if read fault, 1 if write fault
        mov     [esp+0], eax            ; arg3: load/store indicator

        call    _MmAccessFault@12

        or      eax, eax                ; sucessful?
        jge     Kt0e10                  ; yes, go exit

;
; Check to determine if the fault occured in the interlocked pop entry slist
; code. There is a case where a fault may occur in this code when the right
; set of circumstances occurs. The fault can be ignored by simply skipping
; the faulting instruction.
;

Kt0e05: mov     ecx, offset FLAT:ExpInterlockedPopEntrySListFault ; get pop code address
        cmp     [ebp].TsEip, ecx        ; check if fault at pop code address
        je      Kt0e10a                 ; if eq, skip faulting instruction

        mov     ecx, [ebp]+TsErrCode    ; (ecx) = error code
        and     ecx, ERR_0E_STORE       ; (ecx) = 0 if fault caused by read
                                        ;         2 if fault caused by write
        shr     ecx,1                   ; (ecx) = load/store indicator

;
; Set up exception record and arguments and call _KiDispatchException
;

        mov     esi, [ebp]+TsEip        ; (esi)-> faulting instruction

        cmp     eax, STATUS_ACCESS_VIOLATION ; dispatch access violation or
        je      short Kt0e9b                 ; or in_page_error?

        cmp     eax, STATUS_GUARD_PAGE_VIOLATION
        je      short Kt0e9b

        cmp     eax, STATUS_STACK_OVERFLOW
        je      short Kt0e9b

;
; test to see if davec's reserved status code bit is set. If so, then bugchecka
;

        cmp     eax, STATUS_IN_PAGE_ERROR or 10000000h
        je      Kt0e12                  ; bugchecka

;
; (ecx) = ExceptionInfo 1
; (edi) = ExceptionInfo 2
; (eax) = ExceptionInfo 3
; (esi) -> Exception Addr
;

        mov     edx, ecx
        mov     ebx, esi
        mov     esi, edi
        mov     ecx, 3
        mov     edi, eax
        mov     eax, STATUS_IN_PAGE_ERROR
        call    CommonDispatchException ; Won't return

Kt0e9b:
        mov     ebx, esi
        mov     edx, ecx
        mov     esi, edi
        jmp     CommonDispatchException2Args ; Won't return

.FPO ( 0, 0, 0, 0, 0, FPO_TRAPFRAME )

;
; The fault occured in the interlocked pop slist function and the faulting
; instruction should be skipped.
;

Kt0e10a:mov     ecx, offset FLAT:ExpInterlockedPopEntrySListResume ; get resume address
        mov     [ebp].TsEip, ecx        ; set continuation address

Kt0e10:

ifdef DEVKIT
        mov     esp,ebp                 ; (esp) -> trap frame
        test    _KdpOweBreakpoint, 1    ; do we have any owed breakpoints?
        jz      _KiExceptionExit        ; No, all done

        stdCall _KdSetOwedBreakpoints   ; notify the debugger
endif

Kt0e11: mov     esp,ebp                 ; (esp) -> trap frame
        jmp     _KiExceptionExit        ; join common code

Kt0e12:
        stdCall _KeGetCurrentIrql       ; (eax) = OldIrql
Kt0e12a:
   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer

;
; bugcheck a, addr, irql, load/store, pc
;
        mov     ecx, [ebp]+TsErrCode    ; (ecx)= error code
        and     ecx, ERR_0E_STORE       ; (ecx)= 0 if fault caused by read
        shr     ecx, 1                  ; (ecx) = 0 if read fault, 1 if write fault

        mov     esi, [ebp]+TsEip        ; [esi] = faulting instruction

        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,edi,eax,ecx,esi>

Kt0e12b:
        cmp     _KiBugCheckData, 0      ; If crashed, handle trap in
        jnz     Kt0e01                  ; normal manner


        mov     eax, 0ffh               ; OldIrql = -1
        jmp     short Kt0e12a

_KiTrap0E       endp

        page ,132
        subttl "Trap0F -- Intel Reserved"
;++
;
; Routine Description:
;
;    The trap 0F should never occur.  If, however, the exception occurs in
;    USER mode, the current process will be terminated.  If the exception
;    occurs in KERNEL mode, a bugcheck will be raised.  NO registered
;    handler, if any, will be inviked to handle the exception.
;
; Arguments:
;
;    None
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap0F
_KiTrap0F       proc

        push    0                       ; push dummy error code
        ENTER_TRAP
        sti

        mov     eax, EXCEPTION_RESERVED_TRAP ; (eax) = trap type
        jmp     _KiSystemFatalException ; go terminate the system

_KiTrap0F       endp


        page ,132
        subttl "Coprocessor Error"

;++
;
; Routine Description:
;
;    Handle Coprocessor Error.
;
;    This exception is used on 486 or above only.  For i386, it uses
;    IRQ 13 instead.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap10
_KiTrap10       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

        mov     eax, PCR[PcPrcbData+PbNpxThread]  ; Correct context for fault?
        cmp     eax, PCR[PcPrcbData+PbCurrentThread]
        je      Kt0710                  ; Yes - go try to dispatch it

;
; We are in the wrong NPX context and can not dispatch the exception right now.
; Set up the target thread for a delay exception.
;
; Note: we don't think this is a possible case, but just to be safe...
;
        mov     eax, [eax].ThStackBase
        sub     eax, NPX_FRAME_LENGTH   ; Space for NPX_FRAME
        or      dword ptr [eax].FpCr0NpxState, CR0_TS   ; Set for delayed error

        jmp     _KiExceptionExit

_KiTrap10       endp

        page ,132
        subttl "Alignment fault"
;++
;
; Routine Description:
;
;    Handle alignment faults.
;
;    This exception occurs when an unaligned data access is made by a thread
;    with alignment checking turned on.
;
;    This exception will only occur on 486 machines.  The 386 will not do
;    any alignment checking.  Only threads which have the appropriate bit
;    set in EFLAGS will generate alignment faults.
;
;    The exception will never occur in kernel mode.  (hardware limitation)
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction.
;    Error code is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap11
_KiTrap11       proc

        ENTER_TRAP
        sti

;
; We should never be here, since the 486 will not generate alignment faults
; in kernel mode.
;
        mov     eax, EXCEPTION_ALIGNMENT_CHECK      ; (eax) = trap type
        jmp     _KiSystemFatalException

_KiTrap11       endp

;++
;
; Routine Description:
;
;    Handle XMMI Exception.
;;
; Arguments:
;
;    At entry, the saved CS:EIP point to the aborted instruction.
;    No error code is provided with the error.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING

align dword
        public  _KiTrap13
_KiTrap13       proc

        push    0                       ; push dummy error code
        ENTER_TRAP

        mov     eax, PCR[PcPrcbData+PbNpxThread]  ; Correct context for fault?
        cmp     eax, PCR[PcPrcbData+PbCurrentThread]
        je      Kt13_10                 ; Yes - go try to dispatch it

;
;       Katmai New Instruction exceptions are precise and occur immediately.
;       if we are in the wrong NPX context, bugcheck the system.
;
        ; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,eax,0,0>

Kt13_10:
        mov     ecx, PCR[PcStackBase] ; (ecx) -> top of kernel stack

;
;       TrapFrame is built by ENTER_TRAP.
;       XMMI are accessible from all IA execution modes:
;       Protected Mode, Real address mode, Virtual 8086 mode
;
Kt13_15:
;
; We are about to dispatch a XMMI floating point exception to user mode.
;
; (ebp) - Trap frame
; (ecx) - CurrentThreads NPX save area (PCR[PcStackBase])
; (eax) - CurrentThread

; Dispatch
Kt13_20:
;
; Some type of coprocessor exception has occured for the current thread.
;
; Interrupts disabled
;
        mov     ebx, cr0
        and     ebx, NOT (CR0_MP+CR0_EM+CR0_TS)
        mov     cr0, ebx                ; Clear MP+TS+EM to do fxsave

;
; Save the faulting state so we can inspect the cause of the floating
; point fault
;
        FXSAVE_ECX

if DBG
        test    dword ptr [ecx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_TS)
        jnz     Kt13_dbg2
endif

        or      ebx, NPX_STATE_NOT_LOADED ; CR0_TS | CR0_MP
        or      ebx,[ecx]+FpCr0NpxState ; restore this threads CR0 NPX state
        mov     cr0, ebx                ; set TS so next ESC access causes trap

;
; Clear TS bit in Cr0NpxFlags in case it was set to trigger this trap.
;
        and     dword ptr [ecx].FpCr0NpxState, NOT CR0_TS

;
; The state is no longer in the coprocessor.  Clear ThNpxState and
; re-enable interrupts to allow context switching.
;
        mov     byte ptr [eax].ThNpxState, NPX_STATE_NOT_LOADED
        mov     dword ptr PCR[PcPrcbData+PbNpxThread], 0  ; No state in coprocessor
        sti

; (eax) = ExcepCode - Exception code to put into exception record
; (ebx) = ExceptAddress - Addr of instruction which the hardware exception occurs
; (ecx) = NumParms - Number of additional parameters
; (edx) = Parameter1
; (esi) = Parameter2
; (edi) = Parameter3
        mov     ebx, [ebp].TsEip          ; Eip is from trap frame, not from FxErrorOffset
        movzx   eax, word ptr [ecx] + FxMXCsr
        mov     edx, eax
        shr     edx, 7                    ; get the mask
        not     edx
        mov     esi, 0                    ; (esi) = operand addr, addr is computed from
                                          ; trap frame, not from FxDataOffset
;
;       Exception will be handled in user's handler if there is one declared.
;
        and     eax, FSW_INVALID_OPERATION + FSW_DENORMAL + FSW_ZERO_DIVIDE + FSW_OVERFLOW + FSW_UNDERFLOW + FSW_PRECISION
        and     eax, edx
        test    eax, FSW_INVALID_OPERATION ; Is it an invalid op exception?
        jz      short Kt13_40              ; if z, no, go Kt13_40
;
; Invalid Operation Exception - Invalid arithmetic operand
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_40:
; Check for floating zero divide exception
;
        test    eax, FSW_ZERO_DIVIDE    ; Is it a zero divide error?
        jz      short Kt13_50           ; if z, no, go Kt13_50
;
; Division-By-Zero Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_50:
; Check for denormal error
;
        test    eax, FSW_DENORMAL       ; Is it a denormal error?
        jz      short Kt13_60           ; if z, no, go Kt13_60
;
; Denormal Operand Excpetion
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_TRAPS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_60:
; Check for floating overflow error
;
        test    eax, FSW_OVERFLOW       ; Is it an overflow error?
        jz      short Kt13_70           ; if z, no, go Kt13_70
;
; Numeric Overflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_70:
; Check for floating underflow error
;
        test    eax, FSW_UNDERFLOW      ; Is it a underflow error?
        jz      short Kt13_80           ; if z, no, go Kt13_80
;
; Numeric Underflow Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

Kt13_80:
; Check for precision (IEEE inexact) error
;
        test    eax, FSW_PRECISION      ; Is it a precision error
        jz      short Kt13_100          ; if z, no, go Kt13_100
;
; Inexact-Result (Precision) Exception
; Raise exception
;
        mov     eax, STATUS_FLOAT_MULTIPLE_FAULTS
        jmp     CommonDispatchException1Arg0d ; Won't return

; Huh?
Kt13_100:
; If status word does not indicate error, then something is wrong...
; (Note: that we have done a sti, before the status is examined)
        sti
; stop the system
        stdCall _KeBugCheckEx,<TRAP_CAUSE_UNKNOWN,13,eax,0,1>

if DBG
Kt13_dbg1:    int 3
Kt13_dbg2:    int 3
Kt13_dbg3:    int 3
        sti
        jmp short $-2
endif

_KiTrap13       endp

;++
;
; VOID
; KiFlushNPXState (
;     VOID
;     )
;
; Routine Description:
;
;   When a threads NPX context is requested (most likely by a debugger)
;   this function is called to flush the threads NPX context out of the
;   compressor if required.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
align dword

cPublicProc _KiFlushNPXState    ,0
cPublicFpo 1, 1

        pushfd
        cli                             ; don't context switch

        mov     edx, PCR[PcPrcbData+PbCurrentThread]

        cmp     byte ptr [edx].ThNpxState, NPX_STATE_LOADED
        jne     short fnpx70

fnpx20:
    ;
    ; Current thread has NPX state in the coprocessor, flush it
    ;
        mov     eax, cr0
        test    eax, CR0_MP+CR0_TS+CR0_EM
        jz      short fnpx30
        and     eax, NOT (CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax                ; allow frstor (& fnsave) to work
fnpx30:
        mov     ecx, PCR[PcStackBase]   ; (ecx) -> top of kernel stack
        FXSAVE_ECX

        mov     byte ptr [edx].ThNpxState, NPX_STATE_NOT_LOADED
        mov     PCR[PcPrcbData+PbNpxThread], 0      ; clear npx owner

        or      eax, NPX_STATE_NOT_LOADED           ; or in new threads cr0
        or      eax, [ecx].FpCr0NpxState            ; merge new thread setable state
        mov     cr0, eax

fnpx70:
        popfd                           ; enable interrupts
        stdRET    _KiFlushNPXState

stdENDP _KiFlushNPXState

;++
;
; VOID
; KiSetHardwareTrigger (
;     VOID
;     )
;
; Routine Description:
;
;   This function sets KiHardwareTrigger such that an analyzer can sniff
;   for this access.   It needs to occur with a lock cycle such that
;   the processor won't speculatively read this value.   Interlocked
;   functions can't be used as in a UP build they do not use a
;   lock prefix.
;
; Arguments:
;
;    None
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:NOTHING
cPublicProc _KiSetHardwareTrigger,0
   lock inc     ds:_KiHardwareTrigger   ; trip hardware analyzer
        stdRet  _KiSetHardwareTrigger
stdENDP _KiSetHardwareTrigger


        page ,132
        subttl "Processing System Fatal Exceptions"
;++
;
; Routine Description:
;
;    This routine processes the system fatal exceptions.
;    The machine state and trap type will be displayed and
;    System will be stopped.
;
; Arguments:
;
;    (eax) = Trap type
;    (ebp) -> machine state frame
;
; Return value:
;
;    system stopped.
;
;--
        assume  ds:nothing, es:nothing, ss:nothing, fs:nothing, gs:nothing

align dword
        public  _KiSystemFatalException
_KiSystemFatalException proc
.FPO (0, 0, 0, 0, 0, FPO_TRAPFRAME)

        stdCall _KeBugCheckEx,<UNEXPECTED_KERNEL_MODE_TRAP, eax, 0, 0, 0>
        ret

_KiSystemFatalException endp

        page
        subttl  "Continue Execution System Service"
;++
;
; NTSTATUS
; NtContinue (
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN TestAlert
;    )
;
; Routine Description:
;
;    This routine is called as a system service to continue execution after
;    an exception has occurred. Its function is to transfer information from
;    the specified context record into the trap frame that was built when the
;    system service was executed, and then exit the system as if an exception
;    had occurred.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwContinue!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
; Arguments:
;
;    KTrapFrame (ebp+0: after setup) -> base of KTrapFrame
;
;    ContextRecord (ebp+8: after setup) = Supplies a pointer to a context rec.
;
;    TestAlert (esp+12: after setup) = Supplies a boolean value that specifies
;       whether alert should be tested for the previous processor mode.
;
; Return Value:
;
;    Normally there is no return from this routine. However, if the specified
;    context record is misaligned or is not accessible, then the appropriate
;    status code is returned.
;
;--

NcTrapFrame             equ     [ebp + 0]
NcContextRecord         equ     [ebp + 8]
NcTestAlert             equ     [ebp + 12]

align dword
cPublicProc _NtContinue     ,2

        push    ebp

;
; Call KiContinue to load ContextRecord into TrapFrame.  On x86 TrapFrame
; is an atomic entity, so we don't need to allocate any other space here.
;
; KiContinue(NcContextRecord, 0, NcTrapFrame)
;

        mov     ebp,esp
        mov     eax, NcTrapFrame
        mov     ecx, NcContextRecord
        stdCall  _KiContinue, <ecx, 0, eax>
        or      eax,eax                 ; return value 0?
        jnz     short Nc20              ; KiContinue failed, go report error

;
; Check to determine if alert should be tested for the previous processor mode.
;

        cmp     byte ptr NcTestAlert,0  ; Check test alert flag
        je      short Nc10              ; if z, don't test alert, go Nc10
        stdCall _KeTestAlertThread, <0>  test alert for current thread

Nc10:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit2         ; common exit

Nc20:   pop     ebp                     ; (ebp) -> TrapFrame
        mov     esp,ebp                 ; (esp) = (ebp) -> trapframe
        jmp     _KiServiceExit          ; common exit

stdENDP _NtContinue

align dword
cPublicProc _ZwContinue     ,2

;
; Must go through an interrupt trap in order to build the trap frame that
; NtContinue requires.
;
        mov     eax, [esp+4]            ; (eax) -> ContextRecord
        mov     ecx, [esp+8]            ; (ecx) -> TestAlert
        int     28h
        stdRet  _ZwContinue

stdENDP _ZwContinue

        page
        subttl  "Raise Exception System Service"
;++
;
; NTSTATUS
; NtRaiseException (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PCONTEXT ContextRecord,
;    IN BOOLEAN FirstChance
;    )
;
; Routine Description:
;
;    This routine is called as a system service to raise an exception. Its
;    function is to transfer information from the specified context record
;    into the trap frame that was built when the system service was executed.
;    The exception may be raised as a first or second chance exception.
;
;   WARNING - Do not call this routine directly, always call it as
;             ZwRaiseException!!!  This is required because it needs the
;             trapframe built by KiSystemService.
;
;   NOTE - KiSystemService will terminate the ExceptionList, which is
;          not what we want for this case, so we will fish it out of
;          the trap frame and restore it.
;
; Arguments:
;
;    TrapFrame (ebp+0: before setup) -> System trap frame for this call
;
;    ExceptionRecord (ebp+8: after setup) -> An exception record.
;
;    ContextRecord (ebp+12: after setup) -> Points to a context record.
;
;    FirstChance (epb+16: after setup) -> Supplies a boolean value that
;       specifies whether the exception is to be raised as a first (TRUE)
;       or second chance (FALSE) exception.
;
; Return Value:
;
;    None.
;--
align dword
cPublicProc _NtRaiseException ,3

        push    ebp

;
;   Put back the ExceptionList so the exception can be properly
;   dispatched.
;

        mov     ebp,esp                 ; [ebp+0] -> TrapFrame
        mov     ebx, [ebp+0]            ; (ebx)->TrapFrame
        mov     edx, [ebp+16]           ; (edx) = First chance indicator
        mov     eax, [ebx]+TsExceptionList ; Old exception list
        mov     ecx, [ebp+12]           ; (ecx)->ContextRecord
        mov     PCR[PcExceptionList],eax
        mov     eax, [ebp+8]            ; (eax)->ExceptionRecord

;
;   KiRaiseException(ExceptionRecord, ContextRecord, ExceptionFrame,
;           TrapFrame, FirstChance)
;

        stdCall   _KiRaiseException,<eax, ecx, 0, ebx, edx>

        pop     ebp
        mov     esp,ebp                 ; (esp) = (ebp) -> trap frame

;
;   If the exception was handled, then the trap frame has been edited to
;   reflect new state, and we'll simply exit the system service to get
;   the effect of a continue.
;
;   If the exception was not handled, we'll return to our caller, who
;   will raise a new exception.
;
        jmp     _KiServiceExit2

stdENDP _NtRaiseException

align dword
cPublicProc _ZwRaiseException     ,3

;
; Must go through an interrupt trap in order to build the trap frame that
; NtRaiseException requires.
;
        mov     eax, [esp+4]            ; (eax) -> ExceptionRecord
        mov     ecx, [esp+8]            ; (ecx) -> ContextRecord
        mov     edx, [esp+12]           ; (edx) -> FirstChance
        int     29h
        stdRet  _ZwRaiseException

stdENDP _ZwRaiseException

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ldrx\ldrx.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ldrx.h

Abstract:

    This module contains the private data structures and procedure prototypes
    for the Xbox executable image loader.

--*/

#ifndef _LDRX_
#define _LDRX_

#include <ntos.h>
#include <ani.h>
#include <ldr.h>
#include <dm.h>
#include <ntddcdvd.h>
#include <xbeimage.h>
#include <smcdef.h>
#include <limits.h>
#include <wtypes.h>
#include <xbox.h>
#include <xboxp.h>
#include <xconfig.h>
#include <xlaunch.h>
#include <pshpack4.h>

//
// DBG sensitive DbgPrint wrapper.
//

#if DBG
#define LdrxDbgPrint(x)                         DbgPrint x
#define LdrxDbgBreakPoint()                     DbgBreakPoint()
#else
#define LdrxDbgPrint(x)
#define LdrxDbgBreakPoint()
#endif

//
// Bit flag macros.
//

#define LdrxIsFlagSet(flagset, flag)            (((flagset) & (flag)) != 0)
#define LdrxIsFlagClear(flagset, flag)          (((flagset) & (flag)) == 0)

//
// Define the title identifier of the dashboard.
//

#define LDR_DASHBOARD_TITLE_ID                  0xFFFE0000

//
// External symbols.
//

VOID
DebugLoadImageSymbols(
    IN PSTRING FileName,
    IN PKD_SYMBOLS_INFO SymbolInfo
    );

NTSTATUS
DebugService(
    ULONG ServiceClass,
    PVOID Arg1,
    PVOID Arg2
    );

DECLSPEC_NORETURN
VOID
IdexDiskFatalError(
    IN ULONG ErrorCode
    );

extern PDEVICE_OBJECT IdexCdRomDeviceObject;
extern BOOLEAN IdexCdRomDVDX2Authenticated;
extern BOOLEAN IdexDiskSecurityUnlocked;

#include <poppack.h>

#endif  // LDRX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\i386\trapc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    trapc.c

Abstract:

    This module contains some trap handling code written in C.
    Only by the kernel.

Author:

    Ken Reneris     6-9-93

Revision History:

--*/

#include    "ki.h"

#define REG(field)          ((ULONG)(&((KTRAP_FRAME *)0)->field))
#define GETREG(frame,reg)   ((PULONG) (((ULONG) frame)+reg))[0]

typedef struct {
    UCHAR   RmDisplaceOnly;     // RM of displacment only, no base reg
    UCHAR   RmSib;              // RM of SIB
    UCHAR   RmDisplace;         // bit mask of RMs which have a displacement
    UCHAR   Disp;               // sizeof displacement (in bytes)
} KMOD, *PKMOD;

static UCHAR RM32[] = {
    /* 000 */   REG(Eax),
    /* 001 */   REG(Ecx),
    /* 010 */   REG(Edx),
    /* 011 */   REG(Ebx),
    /* 100 */   REG(HardwareEsp),
    /* 101 */   REG(Ebp),       // SIB
    /* 110 */   REG(Esi),
    /* 111 */   REG(Edi)
};

static UCHAR RM8[] = {
    /* 000 */   REG(Eax),       // al
    /* 001 */   REG(Ecx),       // cl
    /* 010 */   REG(Edx),       // dl
    /* 011 */   REG(Ebx),       // bl
    /* 100 */   REG(Eax) + 1,   // ah
    /* 101 */   REG(Ecx) + 1,   // ch
    /* 110 */   REG(Edx) + 1,   // dh
    /* 111 */   REG(Ebx) + 1    // bh
};

static KMOD MOD32[] = {
    /* 00 */     5,     4,   0x20,   4,
    /* 01 */  0xff,     4,   0xff,   1,
    /* 10 */  0xff,     4,   0xff,   4,
    /* 11 */  0xff,  0xff,   0x00,   0
} ;

NTSTATUS
Ki386CheckDivideByZeroTrap (
    IN  PKTRAP_FRAME    TrapFrame
    )
/*++

Routine Description:

    This function gains control when the x86 processor generates a
    divide by zero trap.  The x86 design generates such a trap on
    divide by zero and on division overflows.  In order to determine
    which expection code to dispatch, the divisor of the "div" or "idiv"
    instruction needs to be inspected.

Arguments:

    TrapFrame - Trap frame of the divide by zero trap

Return Value:

    exception code dispatch

--*/
{
    ULONG       operandsize, operandmask, i, accum;
    PUCHAR      istream, pRM;
    UCHAR       ibyte, rm;
    PKMOD       Mod;
    BOOLEAN     fPrefix;
    NTSTATUS    status;

    status = STATUS_INTEGER_DIVIDE_BY_ZERO;

    try {

        //
        // read instruction prefixes
        //

        fPrefix = TRUE;
        pRM = RM32;
        operandsize = 4;
        operandmask = 0xffffffff;
        istream = (PUCHAR) TrapFrame->Eip;
        while (fPrefix) {
            ibyte = *istream++;
            switch (ibyte) {
                case 0x2e:  // cs override
                case 0x36:  // ss override
                case 0x3e:  // ds override
                case 0x26:  // es override
                case 0x64:  // fs override
                case 0x65:  // gs override
                case 0xF3:  // rep
                case 0xF2:  // rep
                case 0xF0:  // lock
                    break;

                case 0x66:
                    // 16 bit operand override
                    operandsize = 2;
                    operandmask = 0xffff;
                    break;

                case 0x67:
                    // 16 bit address size override
                    // this is some non-flat code
                    goto try_exit;

                default:
                    fPrefix = FALSE;
                    break;
            }
        }

        //
        // Check instruction opcode
        //

        if (ibyte != 0xf7  &&  ibyte != 0xf6) {
            // this is not a DIV or IDIV opcode
            goto try_exit;
        }

        if (ibyte == 0xf6) {
            // this is a byte div or idiv
            operandsize = 1;
            operandmask = 0xff;
        }

        //
        // Get Mod R/M
        //

        ibyte = *istream++;
        Mod = MOD32 + (ibyte >> 6);
        rm  = (UCHAR)(ibyte & 7);

        //
        // put register values into accum
        //

        if (operandsize == 1  &&  (ibyte & 0xc0) == 0xc0) {
            pRM = RM8;
        }

        accum = 0;
        if (rm != Mod->RmDisplaceOnly) {
            if (rm == Mod->RmSib) {
                // get SIB
                ibyte = *istream++;
                i = (ibyte >> 3) & 7;
                if (i != 4) {
                    accum = GETREG(TrapFrame, RM32[i]);
                    accum = accum << (ibyte >> 6);    // apply scaler
                }
                i = ibyte & 7;
                accum = accum + GETREG(TrapFrame, RM32[i]);
            } else {
                // get register's value
                accum = GETREG(TrapFrame, pRM[rm]);
            }
        }

        //
        // apply displacement to accum
        //

        if (Mod->RmDisplace & (1 << rm)) {
            if (Mod->Disp == 4) {
                i = *((PULONG) istream);
            } else {
                ibyte = *istream;
                i = (signed long) ((signed char) ibyte);    // sign extend
            }
            accum += i;
        }

        //
        // if this is an effective address, go get the data value
        //

        if (Mod->Disp) {
            switch (operandsize) {
                case 1:  accum = *((PUCHAR) accum);    break;
                case 2:  accum = *((PUSHORT) accum);  break;
                case 4:  accum = *((PULONG) accum);    break;
            }
        }

        //
        // accum now contains the instruction operand, see if the
        // operand was really a zero
        //

        if (accum & operandmask) {
            // operand was non-zero, must be an overflow
            status = STATUS_INTEGER_OVERFLOW;
        }

try_exit: ;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing...
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ke\up\makefile.inc ===
#
# "nmake genxx" will generate platform-dependent include files
#

!if "$(TARGET_DIRECTORY)"=="alpha" || "$(TARGET_DIRECTORY)"=="axp64"
KS_NAME=ksp$(TARGET_DIRECTORY)
HAL_NAME=halp$(TARGET_DIRECTORY)

!else if "$(TARGET_DIRECTORY)"=="i386"
HAL_NAME=hal386
KS_NAME=ks386

!else
HAL_NAME=hal$(TARGET_DIRECTORY)
KS_NAME=ks$(TARGET_DIRECTORY)
!endif

KS_TARGET =$(_NTROOT)\public\sdk\inc\$(KS_NAME).$(ASM_INCLUDE_SUFFIX)
HAL_TARGET=$(_NTROOT)\private\ntos\inc\$(HAL_NAME).$(ASM_INCLUDE_SUFFIX)

genxx: $(KS_TARGET) $(HAL_TARGET)

#
# If the following invocation of genxx fails, make sure you have a
# current version of genxx.
#

$(KS_TARGET) $(HAL_TARGET): \
!if $(AXP64)
        ..\alpha\genalpha.m4 \
!endif	
	..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).m4 \
        ..\genxx.h \
        ..\genxx.inc \
        $(_NTROOT)\public\ddk\inc\ntddk.h
    set PASS0ONLY=
    if not exist obj\$(TARGET_DIRECTORY) mkdir obj\$(TARGET_DIRECTORY)
    -erase obj\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).obj
    -erase ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).c
    m4 < ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).m4 \
       > ..\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).c
    nmake -l obj\$(TARGET_DIRECTORY)\gen$(TARGET_DIRECTORY).obj NTNOPCH=1
    genxx -$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ldrx\sources.inc ===
!IF 0

Copyright (c) 1989-2001  Microsoft Corporation

!ENDIF

MAJORCOMP=ntos
MINORCOMP=ldrx

TARGETPATH=$(BASEDIR)\private\ntos\obj
TARGETTYPE=LIBRARY

INCLUDES=$(BASEDIR)\private\ntos\inc

MSC_WARNING_LEVEL=/W4 /WX

C_DEFINES=$(C_DEFINES) -D_NTSYSTEM_

!if defined(ARCADE)
C_DEFINES=$(C_DEFINES) -DARCADE
!endif

!IF DEFINED(INTERIMPUBKEY)
C_DEFINES=$(C_DEFINES) -DINTERIMPUBKEY=1
!ENDIF

SOURCES=..\loader.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\ldrx\loader.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Module Name:

    loader.c

Abstract:

    This module implements the Xbox executable image loader.

--*/

#include "ldrx.h"

//
// Verify that the definitions in the xbeimage.h match those found in xconfig.h.
//
C_ASSERT(XBEIMAGE_GAME_REGION_NA == XC_GAME_REGION_NA);
C_ASSERT(XBEIMAGE_GAME_REGION_JAPAN == XC_GAME_REGION_JAPAN);
C_ASSERT(XBEIMAGE_GAME_REGION_RESTOFWORLD == XC_GAME_REGION_RESTOFWORLD);
C_ASSERT(XBEIMAGE_GAME_REGION_MANUFACTURING == XC_GAME_REGION_MANUFACTURING);

//
// Contains the public key data to verify the encrypted header digest of an Xbox
// executable image.
//
#ifdef INTERIMPUBKEY
//## -- what public key is this???
DECLSPEC_RDATA UCHAR XePublicKeyData[XC_PUBLIC_KEYDATA_SIZE] = {
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0xE5,0xEC,0x86,0x9B,
    0x50,0x89,0x3B,0xB3,0xEB,0x41,0x30,0x8A,
    0x13,0x6E,0xAD,0xE9,0x7D,0xCA,0x9B,0xB4,
    0xF1,0x89,0x58,0xCE,0xAE,0xE1,0x9A,0x66,
    0xE9,0x1C,0x3C,0x04,0x39,0x2E,0xF7,0xA1,
    0x13,0xE8,0xFB,0x66,0x1C,0x59,0xC1,0xCE,
    0x18,0x7C,0x71,0xB8,0x5D,0x25,0xBB,0x5F,
    0x21,0x30,0x59,0xF7,0xDC,0x3B,0x24,0x13,
    0x42,0x69,0x30,0xF6,0x88,0x3D,0x99,0x89,
    0xCC,0xEB,0xFB,0x16,0x7C,0x78,0xEB,0x05,
    0x6B,0x41,0x8F,0xE0,0xB3,0x55,0x5F,0xEB,
    0x74,0xCA,0xB4,0x31,0x04,0xA2,0xB2,0x5A,
    0xF0,0x03,0x8E,0xDC,0x27,0x1A,0x61,0xF8,
    0x90,0x45,0xFE,0x20,0xD4,0x29,0x1C,0x58,
    0xAF,0xE9,0xFD,0x77,0x37,0x90,0xEC,0xBD,
    0x19,0xD0,0x8F,0x06,0x56,0x3C,0x95,0xC8,
    0xA0,0xA9,0x5A,0x07,0x62,0x4E,0xE8,0x35,
    0xCB,0xCF,0xA5,0xAE,0x27,0x94,0xE5,0x1C,
    0x4F,0xA6,0x18,0x5E,0xD3,0x5C,0xE9,0x06,
    0x24,0x93,0x57,0x38,0x91,0xC7,0x98,0x17,
    0x81,0x3B,0xD3,0x39,0xC7,0xD6,0xEC,0x6D,
    0xFC,0xB1,0xE1,0x52,0xAB,0x82,0x90,0x40,
    0x7B,0xC9,0x1D,0xD4,0x45,0x87,0xAC,0x94,
    0xD6,0x9D,0xB1,0x40,0xB3,0x19,0xE5,0xAD,
    0x18,0xF2,0xB8,0x9C,0xB0,0x54,0xE5,0x07,
    0x4C,0x74,0x4C,0xBD,0x9F,0xCC,0xDF,0xEC,
    0x7C,0xFF,0xAD,0x19,0x2A,0x44,0x03,0xD4,
    0xAA,0xA2,0x79,0x23,0xF9,0x1A,0xDD,0x46,
    0x05,0xF1,0x11,0xB0,0x89,0xC0,0xEB,0xBC,
    0xD7,0x3D,0x94,0xFC,0x04,0x9E,0x67,0x01,
    0x4C,0x10,0x00,0x70,0x2A,0x3F,0x5A,0xD0,
    0x68,0xCF,0xC7,0x59,0xA9,0x01,0x7B,0x07,
    0x34,0x26,0x54,0xA6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
};
#else
//## -- debug public key
DECLSPEC_RDATA UCHAR XePublicKeyData[XC_PUBLIC_KEYDATA_SIZE] = {/*
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x