e range
{
    return E_NOTIMPL;
} 


HRESULT CFtpStrmImpl::Clone(IStream ** UNREF_PARAM(ppstm))  //Points to location for pointer to the new stream object
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\ftpstrm.h ===
#ifndef __HTTPSTRM_H
#define __HTTPSTRM_H

#include "unk.h"
#include "ihttpstrm.h"
#include "iasyncwnt.h"
#include <wininet.h>

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// CFtpStrm is an HTTP-based implementation of IStream.
// One thing to note is that it cannot be opened in direct mode for an http://
// URL, only for file:// URLs.
//
// This is required to make network bandwidth requirements reasonable.

class CFtpStrmImpl: public CCOMBase, public IHttpStrm
{
public:
    CFtpStrmImpl();
    ~CFtpStrmImpl();

public:
    // IHttpStrm Methods
    STDMETHODIMP Open(LPWSTR pwszURL,           // URL to file to base stream on
                      BOOL fDirect,             // should we open this in direct mode, or transacted mode?
                                                // must be FALSE for http:// pwszPath
                      BOOL fDeleteWhenDone,
                      BOOL fCreate);    // should we remove this file after closing the stream?
                                                // must be FALSE for http:// pwszPath
    STDMETHODIMP SetAuth(LPWSTR pwszUserName,
                         LPWSTR pwszPassword);

public:
    // IStream methods
    
    STDMETHODIMP Read(
        void * pv,          //Pointer to buffer into which the stream is read
        ULONG cb,           //Specifies the number of bytes to read
        ULONG * pcbRead);   //Pointer to location that contains actual number of bytes read
    
    
    STDMETHODIMP Write(
        void const* pv,     //Address of buffer from which stream is written
        ULONG cb,           //Specifies the number of bytes to write
        ULONG * pcbWritten);//Specifies the actual number of bytes written        
    
    STDMETHODIMP Seek(
        LARGE_INTEGER dlibMove,           //Offset relative to dwOrigin
        DWORD dwOrigin,                   //Specifies the origin for the offset
        ULARGE_INTEGER * plibNewPosition  //Pointer to location containing
        // new seek pointer
        );

    STDMETHODIMP Stat(
        STATSTG * pstatstg,  //Location for STATSTG structure
        DWORD grfStatFlag    //Values taken from the STATFLAG enumeration
        );
    
    STDMETHODIMP Commit(  
        DWORD grfCommitFlags  //Specifies how changes are committed
        );
    
    STDMETHODIMP Revert(void);

public:
    // IStream methods not supported

    STDMETHODIMP SetSize(
        ULARGE_INTEGER libNewSize  //Specifies the new size of the stream object
        );

    STDMETHODIMP LockRegion(  
        ULARGE_INTEGER libOffset,  //Specifies the byte offset for
                                   // the beginning of the range
        ULARGE_INTEGER cb,         //Specifies the length of the range in bytes
        DWORD dwLockType           //Specifies the restriction on
                                   // accessing the specified range
        );
    
    STDMETHODIMP UnlockRegion(
        ULARGE_INTEGER libOffset,  //Specifies the byte offset for
                                   // the beginning of the range
        ULARGE_INTEGER cb,           //Specifies the length of the range in bytes
        DWORD dwLockType);           //Specifies the access restriction
                                     // previously placed on the range

    STDMETHODIMP CopyTo(
        IStream * pstm,              //Points to the destination stream
        ULARGE_INTEGER cb,           //Specifies the number of bytes to copy
        ULARGE_INTEGER * pcbRead,    //Pointer to the actual number of bytes 
                                     // read from the source
        ULARGE_INTEGER * pcbWritten);//Pointer to the actual number of 
                                     // bytes written to the destination
    
    STDMETHODIMP Clone(IStream ** ppstm);  //Points to location for pointer to the new stream object

private:
    // internal helper methods
    STDMETHODIMP _DuplicateFileURL(LPWSTR pwszURL, LPWSTR* ppwszWin32FName);
    STDMETHODIMP _OpenRemoteTransacted(BOOL fCreate);       // path to file to base stream on
    STDMETHODIMP _OpenLocalDirect(BOOL fCreate, BOOL fDeleteWhenDone);  // should we remove this file after closing the stream?
    STDMETHODIMP _OpenLocalTransacted(BOOL fCreate, BOOL fDeleteWhenDone);  // should we remove this file after closing the stream?
    STDMETHODIMP _FreeURLComponents(LPURL_COMPONENTS pURLComponents);
    STDMETHODIMP _CommitLocal(DWORD grfCommitFlags);
    STDMETHODIMP _CommitRemote(DWORD grfCommitFlags);
private:
    HANDLE          _hInternet;    
    HANDLE          _hURL;
    LPWSTR          _pwszURL;
    HANDLE          _hLocalFile;
    LPWSTR          _pwszLocalFile;

    LPWSTR          _pwszUserName;
    LPWSTR          _pwszPassword;
    
    BOOL            _fDirect;
    BOOL            _fLocalResource;
};

typedef CUnkTmpl<CFtpStrmImpl> CFtpStrm;

#endif // __HTTPSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\clsidslib\makefile.inc ===
$(DAVTRANS_CLSIDS)\lib\ftpstrm_g.lib: $(O)\ftpstrm_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "ftpstrm.clsid.h"
#include "ftpstrm.h"

CFactoryData g_FactoryDataArray[] =
{
    { &CLSID_FtpStrm, 
      CFtpStrm::UnkCreateInstance,
      CFtpStrm::UnkActiveComponents,
      L"Simple FTP stream",                    // Friendly name
      L"FTPSTRM.1",                  // ProgID
      L"FTTPSTRM",                    // Version-independent
      TRUE},                         // ThreadingModel == Both
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\useful.h ===
#include <objbase.h>

///////////////////////////////////////////////////////////////////////////////
// macros

// the size of an array is its total size divided by the size of its first element
#define ARRAYSIZE(_rg)  (sizeof((_rg)) / sizeof((_rg)[0]))

// free a pointer only if it is null: 
// note, this may hide errors, you may want to assert if it's not null, or something

#define SAFEFREE(x) \
    if ((x) != NULL) \
    { \
    free((x)); \
    } \
    else
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\clsids.cpp ===
//
//   - Defines CLSID for SimpleStream
//
#include <objbase.h>

// {18BA3B83-7AA8-441c-BFE6-85267A911B2E}
extern "C" CLSID CLSID_HttpStrm = 
{ 0x18ba3b83, 0x7aa8, 0x441c, { 0xbf, 0xe6, 0x85, 0x26, 0x7a, 0x91, 0x1b, 0x2e } };

// {3072A3E9-A3F7-4338-96CF-07D7FC450D3B}
extern "C" IID IID_IHttpStrm = 
{ 0x3072a3e9, 0xa3f7, 0x4338, { 0x96, 0xcf, 0x7, 0xd7, 0xfc, 0x45, 0xd, 0x3b } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\dll\makefile.inc ===
!include $(BASEDIR)\private\neptune\mkinc.inc

$(O)\httpstrm.dll : $(O)\httpstrm.dll
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\httpstrmu.cpp ===
#include "httpstrm.h"
#include "ihttpstrm.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY httpstrmIME[] =
{
    _INTFMAPENTRY(CHttpStrm, IHttpStrm),
};

const INTFMAPENTRY* CHttpStrm::_pintfmap = httpstrmIME;
const DWORD CHttpStrm::_cintfmap =
    (sizeof(httpstrmIME)/sizeof(httpstrmIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CHttpStrm::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\clsidslib\makefile.inc ===
$(DAVTRANS_CLSIDS)\lib\httpstrm_g.lib: $(O)\httpstrm_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\dll\makefile.inc ===
!include $(BASEDIR)\private\neptune\mkinc.inc

$(O)\httpstrm.dll : $(O)\httpstrm.dll
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\httpstrm.cpp ===
///////////////////////////////////////////////////////////////////////////////
// includes

#include <objbase.h>
#include <wchar.h>
#include <assert.h>
#include <wininet.h>

#include "httpstrm.h"
#include "mischlpr.h"
#include "strutil.h"
#include <stdio.h>
//#define TRACE(a) (fprintf(stderr,"%d %s\n",GetTickCount(),a))
#define TRACE(a)

//////////////////////////////////////////////////////////////////////////////

CHttpStrmImpl::CHttpStrmImpl(): _hLocalFile(NULL), _hInternet(NULL), _pwszURL(NULL), _pwszLocalFile(NULL)
{
    TRACE("CHttpStrm::CHttpStrm");
}

CHttpStrmImpl::~CHttpStrmImpl() 
{
    TRACE("CHttpStrm::~CHttpStrm");
    if (_hLocalFile != NULL)
    {
        CloseHandle(_hLocalFile);
    }
    if (_hInternet != NULL)
    {
        InternetCloseHandle(_hInternet);
    }
    if (_pwszURL != NULL)
    {
        free(_pwszURL);
    }
    if (_pwszLocalFile != NULL)
    {
        free(_pwszLocalFile);
    }
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHttpStrmImpl::_DuplicateFileURL(LPWSTR pwszURL,
                                              LPWSTR* ppwszWin32FName)
{
    HRESULT hr = S_OK;

    TRACE("CHttpStrm::_DuplicateFileURL");
    assert(LStrCmpN(pwszURL, L"file:///", 8) == 0);

    *ppwszWin32FName = DuplicateStringW(pwszURL+8);
    if (*ppwszWin32FName == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {        
        // change the forward slashes into backslashes, to turn the URL into a win32 filepath
        // could use shlwapi, but shlwapi is big and we don't need to bring it all in
        UINT i = 0;
        while (*ppwszWin32FName[i] != NULL)
        {
            if (*ppwszWin32FName[i] == '/')
            {
                *ppwszWin32FName[i] = '\\';
            }
            i++;
        }
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
// IHttpStrm methods

STDMETHODIMP CHttpStrmImpl::_OpenRemoteTransacted(BOOL fCreate)       // path to file to base stream on
{
    HINTERNET hURL;
    HRESULT hr = S_OK;
    WCHAR wszTempFname[MAX_PATH];
    WCHAR wszTempPath[MAX_PATH];
    ULONG cbRead;
    ULONG cbWritten;
    BYTE rgb[4096];
    DWORD dwStatusCode;

    TRACE("CHttpStrm::_OpenRemoteTransacted");
    
    // we've been handed a URL, copy it
    
    hURL = InternetOpenUrl(_hInternet, _pwszURL, NULL, 0, 0, 0);
    if (hURL == NULL)
    {
        hr = E_FAIL;
    }
    else
    {
        DWORD cchTemp = 4;
        
        if (!HttpQueryInfo(hURL,                             // handle to request to get info on
            HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, // flags
            &dwStatusCode,                                   // buffer to write into
            &cchTemp,                                        // pointer to size of buffer
            NULL))                                           // pointer to index to grab, unused
        {
            hr = E_FAIL;
        }
        else
        {
            if ((dwStatusCode < 100 || dwStatusCode > 299) && !fCreate)
            {
                // file not found, and we only wanted to open an existing file
                hr = E_FAIL;
            }
            else
            {
                // copy the file to a local temp file, set _hLocalFile to be equal to that file
                if (GetTempPath(MAX_PATH, wszTempPath) == 0)
                {
                    hr = E_FAIL;
                }
                else if (GetTempFileName(wszTempPath, L"DAV", 0, wszTempFname) == 0)
                {
                    hr = E_FAIL;
                }
                else
                {
                    _hLocalFile = CreateFile(wszTempFname, GENERIC_READ | GENERIC_WRITE, 
                        0, NULL, CREATE_ALWAYS, 
                        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, 
                        NULL);
                    if (_hLocalFile == INVALID_HANDLE_VALUE)
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        if (dwStatusCode >= 100 && dwStatusCode <= 299)
                        {
                            // read the data from the URL, stick into the temp file
                            // (we can use standard HTTP, don't need to use DAV)
                            BOOL fDone = FALSE;
                            while (!fDone)
                            {
                                // read in 4096-byte blocks
                                if (!InternetReadFile(hURL,
                                    rgb,
                                    4096,
                                    &cbRead))
                                {
                                    fDone = TRUE;
                                }
                                else if (cbRead <= 0)
                                {
                                    fDone = TRUE;
                                }
                                else
                                {
                                
                                    // write each block to the temp file
                                    if (!WriteFile(_hLocalFile, rgb, cbRead, &cbWritten, NULL))
                                    {
                                        hr = E_FAIL;
                                        fDone = TRUE;
                                    }
                                    else if (cbRead != cbWritten)
                                    {
                                        hr = E_FAIL;
                                        fDone = TRUE;
                                    }
                                    else
                                    {
                                        // everything is fine, seek back to beginning
                                        if (SetFilePointer(_hLocalFile,
                                                           0,
                                                           NULL,
                                                           FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                                        {
                                            hr = E_FAIL;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            InternetCloseHandle(hURL);
        }
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHttpStrmImpl::_OpenLocalDirect(BOOL fCreate, BOOL fDeleteWhenDone)  // should we remove this file after closing the stream?
{
    HRESULT hr = S_OK;

    // we've been handed a local file URL and we should open it for direct access
    DWORD dwFileAttributes;
    DWORD dwCreation;

    TRACE("CHttpStrm::_OpenLocalDirect");

    if (fDeleteWhenDone && !fCreate)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (fDeleteWhenDone)
        {
            dwFileAttributes = FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE;
        }
        else
        {
            dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
        }

        if (fCreate)
        {
            dwCreation = CREATE_ALWAYS;
        }
        else
        {
            dwCreation = OPEN_EXISTING;
        }

        // -- open the file
        _hLocalFile = CreateFile(_pwszURL + 8, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_READ,  // +8 to skip file:///
                                 NULL, dwCreation, dwFileAttributes, NULL);
    
        if (_hLocalFile == INVALID_HANDLE_VALUE)
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHttpStrmImpl::_OpenLocalTransacted(BOOL fCreate, BOOL fDeleteWhenDone)  // should we remove this file after closing the stream?
                                                                        // must be FALSE for http:// pwszPath
{
    HRESULT hr = S_OK;
    WCHAR wszTempFname[MAX_PATH];
    WCHAR wszTempPath[MAX_PATH];
    HANDLE hNewFile;

    TRACE("CHttpStrm::_OpenLocalTransacted");

    if (!fCreate && fDeleteWhenDone)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // copy the file to a local temp file, set _hLocalFile to be equal to that file
        if (GetTempPath(MAX_PATH, wszTempPath) == 0)
        {
            hr = E_FAIL;
        }
        else if (GetTempFileName(wszTempPath, L"DAV", 0, wszTempFname) == 0)
        {
            hr = E_FAIL;
        }
        else
        {
            if (!fCreate)
            {
                // copy the file, in the process checking if it exists
                if (CopyFile(_pwszURL + 8, wszTempFname, FALSE))
                {
                    _pwszLocalFile = DuplicateStringW(wszTempFname);

                    _hLocalFile = CreateFile(wszTempFname, GENERIC_READ | GENERIC_WRITE, 0,
                                             NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
                    if (_hLocalFile == INVALID_HANDLE_VALUE)
                    {
                        hr = E_FAIL;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                // create a new file
                _pwszLocalFile = DuplicateStringW(wszTempFname);
                
                hNewFile = CreateFile(_pwszURL + 8, GENERIC_WRITE, 0,
                                      NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (hNewFile == INVALID_HANDLE_VALUE)
                {
                    hr = E_FAIL;
                }
                else
                {
                    CloseHandle(hNewFile);
                    _hLocalFile = CreateFile(wszTempFname, GENERIC_READ | GENERIC_WRITE, 0,
                                             NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL);
                    if (_hLocalFile == INVALID_HANDLE_VALUE)
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        // everything is fine, seek back to beginning
                        if (SetFilePointer(_hLocalFile,
                                           0,
                                           NULL,
                                           FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                        {
                            hr = E_FAIL;
                        }
                    }
                }
            }
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHttpStrmImpl::Open(LPWSTR pwszURL,        // URL to base stream on
                                 BOOL fDirect,          // should we open this in direct mode, or transacted mode?
                                                        // must be FALSE for http:// pwszPath
                                 BOOL fDeleteWhenDone,  // should we remove this file after closing the stream?
                                                        // must be FALSE for http:// pwszPath
                                 BOOL fCreate)          // are we trying to create/overwrite a file (TRUE), or only open an existing file (FALSE)
{
    // locals
    HRESULT hr = S_OK;
    TRACE("CHttpStrm::Open");

    // check args
    if (pwszURL == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        _pwszURL = DuplicateStringW(pwszURL);
        if (_pwszURL == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            _fDirect = fDirect;

            // code
            if (LStrCmpN(_pwszURL, L"file:///", 8) == 0) // BUGBUG: case sensitive?
            {
                _fLocalResource = TRUE;
            }
            else if (LStrCmpN(_pwszURL, L"http://", 7) == 0) // BUGBUG: does this break user:// ?
            {
                _fLocalResource = FALSE;
            }
            else
            {
                hr = E_INVALIDARG;
            }

            if (SUCCEEDED(hr))
            {   
                if (_fLocalResource && fDirect)
                {
                    hr = this->_OpenLocalDirect(fCreate, fDeleteWhenDone);
                }
                else if (_fLocalResource && !fDirect)
                {
                    hr = this->_OpenLocalTransacted(fCreate, fDeleteWhenDone);
                }
                else
                {
                    if (!_fLocalResource && (fDirect || fDeleteWhenDone))
                    {
                        hr = E_INVALIDARG; // remote files must be transacted, cannot be temp files
                    }
                    else
                    {                        
                        _hInternet = InternetOpen(L"HTTPSTRM", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
                        if (_hInternet == NULL)
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            hr = this->_OpenRemoteTransacted(fCreate);
                        }
                    }
                }
            }
        }
    }

    return hr;  
}

//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CHttpStrmImpl::SetAuth(LPWSTR pwszUserName,
                                    LPWSTR pwszPassword)
{
    HRESULT hr = S_OK;
    TRACE("CHttpStrm::SetAuth");

    if (_pwszUserName != NULL)
    {
        free(_pwszUserName);
        _pwszUserName = NULL;
    }
    if (_pwszPassword != NULL)
    {
        free(_pwszPassword);
        _pwszPassword = NULL;
    }

    if (pwszUserName != NULL)
    {
        _pwszUserName = DuplicateStringW(pwszUserName);
        if (_pwszUserName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (pwszPassword != NULL)
        {
            _pwszPassword = DuplicateStringW(pwszPassword);
            if (_pwszPassword == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }


    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// IStream methods

HRESULT CHttpStrmImpl::Read(void * pv,
                        ULONG cb,          
                        ULONG * pcbRead)
{
    // locals
    HRESULT hr = S_OK;
    DWORD cbRead;
    BOOL fReadSuccess;
    TRACE("CHttpStrm::Read");

    // check arguments
    if (pv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {    
        // code    
        fReadSuccess = ReadFile(_hLocalFile,
                                pv,
                                cb,
                                &cbRead,
                                NULL);
        if (!fReadSuccess)
        {
            hr = E_FAIL;
        }
        else
        {
            if (pcbRead != NULL)
            {
                *pcbRead = cbRead;
            }
        }
    }

    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::Write(void const* pv,
                         ULONG cb,
                         ULONG * pcbWritten)
{
    // locals
    HRESULT hr = S_OK;
    DWORD cbWritten;
    BOOL fWriteSuccess;
    TRACE("CHttpStrm::Write");

    // check arguments
    if (pv == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // code    
        fWriteSuccess = WriteFile(_hLocalFile,
                                  pv,
                                  cb,
                                  &cbWritten,
                                  NULL);
        if (!fWriteSuccess)
        {
            hr = E_FAIL;
        }
        else
        {
            if (pcbWritten != NULL)
            {
                *pcbWritten = cbWritten;
            }
        }
    }

    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::Seek(LARGE_INTEGER dlibMove,          
                        DWORD dwOrigin,                  
                        ULARGE_INTEGER * plibNewPosition)
{
    // locals
    DWORD dwMoveMethod = FILE_BEGIN; // makes compiler happy
    LONG iHighPart;
    DWORD dwResult;
    HRESULT hr = S_OK;
    TRACE("CHttpStrm::Seek");

    // check args
    if (dwOrigin != STREAM_SEEK_SET && dwOrigin != STREAM_SEEK_CUR && dwOrigin != STREAM_SEEK_END)
    {
        hr = E_INVALIDARG;
    }
    else
    {

        // code
        switch (dwOrigin) {
        case STREAM_SEEK_SET:
            dwMoveMethod = FILE_BEGIN;
            break;
        case STREAM_SEEK_CUR:
            dwMoveMethod = FILE_CURRENT;
            break;
        case STREAM_SEEK_END:
            dwMoveMethod = FILE_END;
            break;
        default:
            assert(0);
        }

        iHighPart = dlibMove.HighPart;
        
        dwResult = SetFilePointer(_hLocalFile,
                                  dlibMove.LowPart,
                                  &iHighPart,
                                  dwMoveMethod);

        if (dwResult == INVALID_SET_FILE_POINTER)
        {
            hr = E_FAIL;
        }
        else
        {
            if (plibNewPosition != NULL)
            {
                (*plibNewPosition).LowPart = dwResult;
                (*plibNewPosition).HighPart = iHighPart;
            }
        }
    }

    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::Stat(STATSTG*  pstatstg,     //Location for STATSTG structure
                            DWORD     grfStatFlag)  //Values taken from the STATFLAG enumeration             
{
    // locals
    HRESULT hr = S_OK;
    TRACE("CHttpStrm::Stat");

    // check args
    if (grfStatFlag != STATFLAG_DEFAULT && grfStatFlag != STATFLAG_NONAME)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (grfStatFlag == STATFLAG_DEFAULT) 
        {
            pstatstg->pwcsName = DuplicateStringW(_pwszURL);
        }

        pstatstg->type = STGTY_STREAM;
    
        if (!GetFileSizeEx(_hLocalFile,(LARGE_INTEGER*)&pstatstg->cbSize))
        {
            hr = E_FAIL;
        }
        else
        {
            if (_fLocalResource)
            {
                if (!GetFileTime(_hLocalFile, &(pstatstg->ctime), &(pstatstg->atime), &(pstatstg->mtime)))
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                // BUGBUG: currently we look at the local file for filetime
                if (!GetFileTime(_hLocalFile, &(pstatstg->ctime), &(pstatstg->atime), &(pstatstg->mtime)))
                {
                    hr = E_FAIL;
                }
            }

            if (SUCCEEDED(hr))
            {
                pstatstg->grfMode = 0; // BUGBUG: what should this be???
                pstatstg->grfLocksSupported = LOCK_EXCLUSIVE;
                pstatstg->clsid = CLSID_NULL;
                pstatstg->grfStateBits = 0;
                pstatstg->reserved = 0;
            }
        }
    }
   
    return hr;  
} 

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::_CommitLocal(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;
    TRACE("CHttpStrm::CommitLocal");

    // commit a local transacted file
    // a local transacted file should be copied to the original place
    if (!CloseHandle(_hLocalFile)) // close local
    {
        hr = E_FAIL;
    }
    else if (!CopyFile(_pwszLocalFile, _pwszURL+8, FALSE)) // copy local
    {
        hr = E_FAIL;
    }
    else
    {
        _hLocalFile = CreateFile(_pwszLocalFile, GENERIC_READ | GENERIC_WRITE, 0,
                             NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); // re-open local
        if (_hLocalFile == INVALID_HANDLE_VALUE)
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::_CommitRemote(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;
    LPWSTR pwszServer = NULL;
    LPWSTR pwszPath = NULL;
    ULONG nServerPort;
    ULONG cbRead;
    DWORD fSizeHigh;
    DWORD fSizeLow;
    ULONG cbData;
    LPVOID pbData;
    URL_COMPONENTS urlComponents = {0};
    
    TRACE("CHttpStrm::CommitRemote");

    // commit a remote transacted resource
    // first seek to start of local file
    if (SetFilePointer(_hLocalFile,
        0,
        NULL,
        FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        hr = E_FAIL;
    }
    else
    {
        // second, open remote resource and seek to start of it
        // -- first parse the URL (server, port, path)
        urlComponents.dwStructSize = sizeof(URL_COMPONENTS);
        urlComponents.dwHostNameLength = 1;
        urlComponents.dwUrlPathLength = 1;
        urlComponents.nPort = 1;
        if (!InternetCrackUrl(_pwszURL, 0, 0, &urlComponents))
        {
            hr = E_FAIL;
        }
        else
        {
            pwszServer = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwHostNameLength));
            if (pwszServer == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pwszServer = lstrcpyn(pwszServer, urlComponents.lpszHostName, 1 + urlComponents.dwHostNameLength); // +1 for the final null char
                nServerPort = urlComponents.nPort;
                if (nServerPort == 0)
                {
                    hr = E_FAIL;
                }
                else
                {
                    pwszPath = (LPWSTR)malloc(sizeof(WCHAR) * (1 + urlComponents.dwUrlPathLength));
                    if (pwszPath == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        lstrcpyn(pwszPath, urlComponents.lpszUrlPath, 1 + urlComponents.dwUrlPathLength);
                        // -- then connect to the server
                        hConnect = InternetConnect(_hInternet, pwszServer, (USHORT)nServerPort,
                                                   _pwszUserName, _pwszPassword, INTERNET_SERVICE_HTTP,
                                                   0, 0);
                        if (hConnect == NULL)
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            // then create the put request
                            hRequest = HttpOpenRequest(hConnect, L"PUT", pwszPath, NULL, 
                                                       NULL, NULL, 0, 0);
                            if (hRequest == NULL)
                            {
                                hr = E_FAIL;
                            }
                            else 
                            {
                                // then build the data to post
                                fSizeLow = GetFileSize(_hLocalFile, &fSizeHigh);
                                assert(fSizeHigh == 0); // BUGBUG: dunno how to malloc more than a DWORD of memory
                                cbData = fSizeLow;
                                pbData = (LPVOID)malloc(cbData);
                                if (pbData == NULL)
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                                else
                                {
                                    if (!ReadFile(_hLocalFile, pbData, cbData, &cbRead, NULL))
                                    {
                                        hr = E_FAIL;
                                    }
                                    else if (cbRead != cbData)
                                    {
                                        hr = E_FAIL;
                                    }
                                    else
                                    {
                                        // then actually transmit the data
                                        if (!HttpSendRequest(hRequest, NULL, 0,
                                            pbData, cbData))
                                        {
                                            DWORD dwErr = GetLastError();
                                            hr = E_FAIL;
                                        }
                                        else
                                        {
                                            BYTE buffer[1000]; 
                                            ULONG bytesRead;
                                            InternetReadFile(hRequest,    // handle to request to get response to
                                                buffer,      // buffer to write response into
                                                1000,        // size of buffer
                                                &bytesRead);
                                            
                                            InternetCloseHandle(hRequest);
                                            InternetCloseHandle(hConnect);
                                        }
                                    }
                                }
                            }
                        }
                        free(pwszPath);
                    }
                }
                free(pwszServer);
            }
        }        
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = S_OK;

    if (_fDirect)
    {
        hr = E_FAIL; // in direct mode, commit is meaningless
    }
    else if (grfCommitFlags != STGC_DEFAULT)
    {
        hr = E_INVALIDARG; // we only support the default commit style
    }
    else
    {
        if (_fLocalResource)
            hr = this->_CommitLocal(grfCommitFlags);
        else
            hr = this->_CommitRemote(grfCommitFlags);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////

HRESULT CHttpStrmImpl::Revert()
{
    HRESULT hr = S_OK;
    TRACE("CHttpStrm::Revert");

    if (_fDirect)
    {
        hr = E_FAIL; // in direct mode, revert is meaningless
    }
    else
    {
        if (_fLocalResource)
        {
            // revert a local transacted file
            if (!CloseHandle(_hLocalFile)) // should delete the file if needed...
            {
                hr = E_FAIL;
            }
            else if (!CopyFile(_pwszURL+8, _pwszLocalFile, FALSE)) // ... but we'll overwrite it if not
            {
                hr = E_FAIL;
            }
            else
            {
                _hLocalFile = CreateFile(_pwszLocalFile, GENERIC_READ | GENERIC_WRITE, 0,
                                         NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                if (_hLocalFile == INVALID_HANDLE_VALUE)
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {            
            // revert commit a remote transacted resource
            if (!CloseHandle(_hLocalFile)) // this should delete the file
            {
                hr = E_FAIL;
            }
            else
            {
                hr = this->_OpenRemoteTransacted(FALSE); // don't create, we want to reopen what was there before
            }
        }
    }

    return hr;
} 

/////////////////////////////////////////////////////////////////////////////////
// These IStream methods are not supported

HRESULT CHttpStrmImpl::SetSize(ULARGE_INTEGER UNREF_PARAM(libNewSize))  //Specifies the new size of the stream object
{
    return E_NOTIMPL;
} 

HRESULT CHttpStrmImpl::CopyTo(IStream * UNREF_PARAM(pstm),              //Points to the destination stream
                          ULARGE_INTEGER UNREF_PARAM(cb),           //Specifies the number of bytes to copy
                          ULARGE_INTEGER * UNREF_PARAM(pcbRead),    //Pointer to the actual number of bytes 
                                                                    // read from the source
                          ULARGE_INTEGER * UNREF_PARAM(pcbWritten)) //Pointer to the actual number of 
                          // bytes written to the destination
{
    return E_NOTIMPL;
} 

HRESULT CHttpStrmImpl::LockRegion(ULARGE_INTEGER UNREF_PARAM(libOffset),  //Specifies the byte offset for
                                                                      // the beginning of the range
                              ULARGE_INTEGER UNREF_PARAM(cb),         //Specifies the length of the range in bytes
                              DWORD UNREF_PARAM(dwLockType))          //Specifies the restriction on
                                                                      // accessing the specified range
{
    return E_NOTIMPL;
} 

HRESULT CHttpStrmImpl::UnlockRegion(ULARGE_INTEGER UNREF_PARAM(libOffset),  //Specifies the byte offset for
                                                                        // the beginning of the range
                                ULARGE_INTEGER UNREF_PARAM(cb),         //Specifies the length of the range in bytes
                                DWORD UNREF_PARAM(dwLockType))          //Specifies the access restriction
                                                                        // previously placed on the range
{
    return E_NOTIMPL;
} 


HRESULT CHttpStrmImpl::Clone(IStream ** UNREF_PARAM(ppstm))  //Points to location for pointer to the new stream object
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ftpstrm\tstdrv\tstdrv.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>
#include "ftpstrm.clsid.h"
#include "httpstrm.clsid.h"
#include "ihttpstrm.h"


// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(int argc, char *argv[])
{
    // locals
    HRESULT             hr;
    
    IHttpStrm*      pHStream = NULL;
    LARGE_INTEGER   li = {0};
    ULARGE_INTEGER  uli = {0};
    ULONG           cbWritten;

    CoInitialize(NULL);
    hr = ::CoCreateInstance(CLSID_FtpStrm, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IHttpStrm, 
                              (LPVOID*)&pHStream);

    if (SUCCEEDED(hr))
    {
        hr = pHStream->SetAuth(L"anonymous", L"grendel");
        if (SUCCEEDED(hr))
        {
            hr = pHStream->Open(L"ftp://aidanl/catnames.txt", FALSE, FALSE, FALSE);
            if (SUCCEEDED(hr))
            {
                hr = pHStream->Seek(li, 0, &uli);
                if (SUCCEEDED(hr))
                {
                    hr = pHStream->Write("I am God here.", sizeof(CHAR)*(strlen("I am God here.")), &cbWritten);
                    if (SUCCEEDED(hr))
                    {
                        hr = pHStream->Commit(STGC_DEFAULT);
                    }
                }
            }
        }
    }

    // release stuff
    if (pHStream != NULL)
    {
        pHStream->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "httpstrm.clsid.h"
#include "httpstrm.h"

CFactoryData g_FactoryDataArray[] =
{
    { &CLSID_HttpStrm, 
      CHttpStrm::UnkCreateInstance,
      CHttpStrm::UnkActiveComponents,
      L"Simple HTTP stream",                    // Friendly name
      L"HTTPSTRM.1",                  // ProgID
      L"HTTPSTRM",                    // Version-independent
      TRUE},                         // ThreadingModel == Both
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\httpstrm.h ===
#ifndef __HTTPSTRM_H
#define __HTTPSTRM_H

#include "unk.h"
#include "ihttpstrm.h"
#include "iasyncwnt.h"
#include <wininet.h>

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

// CHttpStrm is an HTTP-based implementation of IStream.
// One thing to note is that it cannot be opened in direct mode for an http://
// URL, only for file:// URLs.
//
// This is required to make network bandwidth requirements reasonable.

class CHttpStrmImpl: public CCOMBase, public IHttpStrm
{
public:
    CHttpStrmImpl();
    ~CHttpStrmImpl();

public:
    // IHttpStrm Methods
    STDMETHODIMP Open(LPWSTR pwszURL,           // URL to file to base stream on
                      BOOL fDirect,             // should we open this in direct mode, or transacted mode?
                                                // must be FALSE for http:// pwszPath
                      BOOL fDeleteWhenDone,
                      BOOL fCreate);    // should we remove this file after closing the stream?
                                                // must be FALSE for http:// pwszPath
    STDMETHODIMP SetAuth(LPWSTR pwszUserName,
                         LPWSTR pwszPassword);

public:
    // IStream methods
    
    STDMETHODIMP Read(
        void * pv,          //Pointer to buffer into which the stream is read
        ULONG cb,           //Specifies the number of bytes to read
        ULONG * pcbRead);   //Pointer to location that contains actual number of bytes read
    
    
    STDMETHODIMP Write(
        void const* pv,     //Address of buffer from which stream is written
        ULONG cb,           //Specifies the number of bytes to write
        ULONG * pcbWritten);//Specifies the actual number of bytes written        
    
    STDMETHODIMP Seek(
        LARGE_INTEGER dlibMove,           //Offset relative to dwOrigin
        DWORD dwOrigin,                   //Specifies the origin for the offset
        ULARGE_INTEGER * plibNewPosition  //Pointer to location containing
        // new seek pointer
        );

    STDMETHODIMP Stat(
        STATSTG * pstatstg,  //Location for STATSTG structure
        DWORD grfStatFlag    //Values taken from the STATFLAG enumeration
        );
    
    STDMETHODIMP Commit(  
        DWORD grfCommitFlags  //Specifies how changes are committed
        );
    
    STDMETHODIMP Revert(void);

public:
    // IStream methods not supported

    STDMETHODIMP SetSize(
        ULARGE_INTEGER libNewSize  //Specifies the new size of the stream object
        );

    STDMETHODIMP LockRegion(  
        ULARGE_INTEGER libOffset,  //Specifies the byte offset for
                                   // the beginning of the range
        ULARGE_INTEGER cb,         //Specifies the length of the range in bytes
        DWORD dwLockType           //Specifies the restriction on
                                   // accessing the specified range
        );
    
    STDMETHODIMP UnlockRegion(
        ULARGE_INTEGER libOffset,  //Specifies the byte offset for
                                   // the beginning of the range
        ULARGE_INTEGER cb,           //Specifies the length of the range in bytes
        DWORD dwLockType);           //Specifies the access restriction
                                     // previously placed on the range

    STDMETHODIMP CopyTo(
        IStream * pstm,              //Points to the destination stream
        ULARGE_INTEGER cb,           //Specifies the number of bytes to copy
        ULARGE_INTEGER * pcbRead,    //Pointer to the actual number of bytes 
                                     // read from the source
        ULARGE_INTEGER * pcbWritten);//Pointer to the actual number of 
                                     // bytes written to the destination
    
    STDMETHODIMP Clone(IStream ** ppstm);  //Points to location for pointer to the new stream object

private:
    // internal helper methods
    STDMETHODIMP _DuplicateFileURL(LPWSTR pwszURL, LPWSTR* ppwszWin32FName);
    STDMETHODIMP _OpenRemoteTransacted(BOOL fCreate);       // path to file to base stream on
    STDMETHODIMP _OpenLocalDirect(BOOL fCreate, BOOL fDeleteWhenDone);  // should we remove this file after closing the stream?
    STDMETHODIMP _OpenLocalTransacted(BOOL fCreate, BOOL fDeleteWhenDone);  // should we remove this file after closing the stream?
    STDMETHODIMP _FreeURLComponents(LPURL_COMPONENTS pURLComponents);
    STDMETHODIMP _CommitLocal(DWORD grfCommitFlags);
    STDMETHODIMP _CommitRemote(DWORD grfCommitFlags);
private:
    HANDLE          _hInternet;    
    HANDLE          _hURL;
    LPWSTR          _pwszURL;
    HANDLE          _hLocalFile;
    LPWSTR          _pwszLocalFile;

    LPWSTR          _pwszUserName;
    LPWSTR          _pwszPassword;
    
    BOOL            _fDirect;
    BOOL            _fLocalResource;
};

typedef CUnkTmpl<CHttpStrmImpl> CHttpStrm;

#endif // __HTTPSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\tstdrv\tstdrv.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>
#include "httpstrm.clsid.h"
#include "ihttpstrm.h"


// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(int argc, char *argv[])
{
    // locals
    HRESULT             hres;
    
    IHttpStrm*      pHStream = NULL;
    LARGE_INTEGER   li = {0};
    ULARGE_INTEGER  uli = {0};
    ULONG           cbWritten;

    CoInitialize(NULL);
    hres = ::CoCreateInstance(CLSID_HttpStrm, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IHttpStrm, 
                              (LPVOID*)&pHStream);

    if (SUCCEEDED(hres))
    {
        hres = pHStream->SetAuth(L"aidan", L"grendel");
        if (SUCCEEDED(hres))
        {
            hres = pHStream->Open(L"http://aidanl:8088/dav/aidanl/cartman.txt", FALSE, FALSE, FALSE);
            if (SUCCEEDED(hres))
            {
                hres = pHStream->Seek(li, 0, &uli);
                if (SUCCEEDED(hres))
                {
                    hres = pHStream->Write("I am God here.", sizeof(CHAR)*(strlen("I am God here.")), &cbWritten);
                    if (SUCCEEDED(hres))
                    {
                        hres = pHStream->Commit(STGC_DEFAULT);
                    }
                }
            }
        }
    }

    // release stuff
    if (pHStream != NULL)
    {
        pHStream->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\idavbagmn.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Thu Dec 09 13:07:37 1999
 */
/* Compiler settings for ..\idavbagmn.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __idavbagmn_h__
#define __idavbagmn_h__

/* Forward Declarations */ 

#ifndef __IDavBagMan_FWD_DEFINED__
#define __IDavBagMan_FWD_DEFINED__
typedef interface IDavBagMan IDavBagMan;
#endif 	/* __IDavBagMan_FWD_DEFINED__ */


#ifndef __IDavBag_FWD_DEFINED__
#define __IDavBag_FWD_DEFINED__
typedef interface IDavBag IDavBag;
#endif 	/* __IDavBag_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __DavBagManAPI_LIBRARY_DEFINED__
#define __DavBagManAPI_LIBRARY_DEFINED__

/* library DavBagManAPI */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DavBagManAPI;

#ifndef __IDavBagMan_INTERFACE_DEFINED__
#define __IDavBagMan_INTERFACE_DEFINED__

/* interface IDavBagMan */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IDavBagMan;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF39DAF7-7844-4393-8F91-B6C25F9D67CE")
    IDavBagMan : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewBag( 
            /* [in] */ LPCWSTR pwszURL,
            IPropertyBag __RPC_FAR *__RPC_FAR *ppBag,
            LPWSTR __RPC_FAR *ppwszNewID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBag( 
            /* [in] */ LPCWSTR pwszURL,
            BOOL fCreate,
            IPropertyBag __RPC_FAR *__RPC_FAR *ppBag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pwszURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Copy( 
            /* [in] */ LPCWSTR pwszURLSource,
            LPCWSTR pwszURLDestination,
            BOOL fOverwrite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ LPCWSTR pwszURLSource,
            LPCWSTR pwszURLDestination,
            BOOL fOverwrite) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserAgent( 
            /* [in] */ LPCWSTR pwszUserAgent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuth( 
            /* [in] */ LPCWSTR pwszUserName,
            LPCWSTR pwszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDavBagManVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDavBagMan __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDavBagMan __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IDavBagMan __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NewBag )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszURL,
            IPropertyBag __RPC_FAR *__RPC_FAR *ppBag,
            LPWSTR __RPC_FAR *ppwszNewID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBag )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszURL,
            BOOL fCreate,
            IPropertyBag __RPC_FAR *__RPC_FAR *ppBag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszURLSource,
            LPCWSTR pwszURLDestination,
            BOOL fOverwrite);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszURLSource,
            LPCWSTR pwszURLDestination,
            BOOL fOverwrite);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserAgent )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUserAgent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuth )( 
            IDavBagMan __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUserName,
            LPCWSTR pwszPassword);
        
        END_INTERFACE
    } IDavBagManVtbl;

    interface IDavBagMan
    {
        CONST_VTBL struct IDavBagManVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDavBagMan_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDavBagMan_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDavBagMan_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDavBagMan_Init(This)	\
    (This)->lpVtbl -> Init(This)

#define IDavBagMan_NewBag(This,pwszURL,ppBag,ppwszNewID)	\
    (This)->lpVtbl -> NewBag(This,pwszURL,ppBag,ppwszNewID)

#define IDavBagMan_GetBag(This,pwszURL,fCreate,ppBag)	\
    (This)->lpVtbl -> GetBag(This,pwszURL,fCreate,ppBag)

#define IDavBagMan_Delete(This,pwszURL)	\
    (This)->lpVtbl -> Delete(This,pwszURL)

#define IDavBagMan_Copy(This,pwszURLSource,pwszURLDestination,fOverwrite)	\
    (This)->lpVtbl -> Copy(This,pwszURLSource,pwszURLDestination,fOverwrite)

#define IDavBagMan_Move(This,pwszURLSource,pwszURLDestination,fOverwrite)	\
    (This)->lpVtbl -> Move(This,pwszURLSource,pwszURLDestination,fOverwrite)

#define IDavBagMan_SetUserAgent(This,pwszUserAgent)	\
    (This)->lpVtbl -> SetUserAgent(This,pwszUserAgent)

#define IDavBagMan_SetAuth(This,pwszUserName,pwszPassword)	\
    (This)->lpVtbl -> SetAuth(This,pwszUserName,pwszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDavBagMan_Init_Proxy( 
    IDavBagMan __RPC_FAR * This);


void __RPC_STUB IDavBagMan_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_NewBag_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszURL,
    IPropertyBag __RPC_FAR *__RPC_FAR *ppBag,
    LPWSTR __RPC_FAR *ppwszNewID);


void __RPC_STUB IDavBagMan_NewBag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_GetBag_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszURL,
    BOOL fCreate,
    IPropertyBag __RPC_FAR *__RPC_FAR *ppBag);


void __RPC_STUB IDavBagMan_GetBag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_Delete_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszURL);


void __RPC_STUB IDavBagMan_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_Copy_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszURLSource,
    LPCWSTR pwszURLDestination,
    BOOL fOverwrite);


void __RPC_STUB IDavBagMan_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_Move_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszURLSource,
    LPCWSTR pwszURLDestination,
    BOOL fOverwrite);


void __RPC_STUB IDavBagMan_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_SetUserAgent_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUserAgent);


void __RPC_STUB IDavBagMan_SetUserAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavBagMan_SetAuth_Proxy( 
    IDavBagMan __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUserName,
    LPCWSTR pwszPassword);


void __RPC_STUB IDavBagMan_SetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDavBagMan_INTERFACE_DEFINED__ */


#ifndef __IDavBag_INTERFACE_DEFINED__
#define __IDavBag_INTERFACE_DEFINED__

/* interface IDavBag */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IDavBag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D243A955-B951-41ab-B70F-A31689284E0B")
    IDavBag : public IPropertyBag
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ LPVOID __RPC_FAR *pDavTransport,
            LPWSTR pwszURL,
            LPWSTR pwszUserName,
            LPWSTR pwszPassword,
            LPWSTR pwszUserAgent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDavBagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDavBag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDavBag __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDavBag __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IDavBag __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPropName,
            /* [out][in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ IErrorLog __RPC_FAR *pErrorLog);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IDavBag __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszPropName,
            /* [in] */ VARIANT __RPC_FAR *pVar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IDavBag __RPC_FAR * This,
            /* [in] */ LPVOID __RPC_FAR *pDavTransport,
            LPWSTR pwszURL,
            LPWSTR pwszUserName,
            LPWSTR pwszPassword,
            LPWSTR pwszUserAgent);
        
        END_INTERFACE
    } IDavBagVtbl;

    interface IDavBag
    {
        CONST_VTBL struct IDavBagVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDavBag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDavBag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDavBag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDavBag_Read(This,pszPropName,pVar,pErrorLog)	\
    (This)->lpVtbl -> Read(This,pszPropName,pVar,pErrorLog)

#define IDavBag_Write(This,pszPropName,pVar)	\
    (This)->lpVtbl -> Write(This,pszPropName,pVar)


#define IDavBag_Init(This,pDavTransport,pwszURL,pwszUserName,pwszPassword,pwszUserAgent)	\
    (This)->lpVtbl -> Init(This,pDavTransport,pwszURL,pwszUserName,pwszPassword,pwszUserAgent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDavBag_Init_Proxy( 
    IDavBag __RPC_FAR * This,
    /* [in] */ LPVOID __RPC_FAR *pDavTransport,
    LPWSTR pwszURL,
    LPWSTR pwszUserName,
    LPWSTR pwszPassword,
    LPWSTR pwszUserAgent);


void __RPC_STUB IDavBag_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDavBag_INTERFACE_DEFINED__ */

#endif /* __DavBagManAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\idavinet.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for idavinet.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __idavinet_h__
#define __idavinet_h__

/* Forward Declarations */ 

#ifndef __IPropFindRequest_FWD_DEFINED__
#define __IPropFindRequest_FWD_DEFINED__
typedef interface IPropFindRequest IPropFindRequest;
#endif 	/* __IPropFindRequest_FWD_DEFINED__ */


#ifndef __IPropPatchRequest_FWD_DEFINED__
#define __IPropPatchRequest_FWD_DEFINED__
typedef interface IPropPatchRequest IPropPatchRequest;
#endif 	/* __IPropPatchRequest_FWD_DEFINED__ */


#ifndef __IDavCallback_FWD_DEFINED__
#define __IDavCallback_FWD_DEFINED__
typedef interface IDavCallback IDavCallback;
#endif 	/* __IDavCallback_FWD_DEFINED__ */


#ifndef __IDavTransport_FWD_DEFINED__
#define __IDavTransport_FWD_DEFINED__
typedef interface IDavTransport IDavTransport;
#endif 	/* __IDavTransport_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __DavAPI_LIBRARY_DEFINED__
#define __DavAPI_LIBRARY_DEFINED__

/* library DavAPI */
/* [helpstring][version][uuid] */ 

#define	DEPTH_INFINITY	( 0xfffffffe )

#define	CCHMAX_DAV_USERNAME	( 255 )

#define	CCHMAX_DAV_PASSWORD	( 255 )

#define	DAVOPTIONS_DAVSUPPORT_1	( 0x1 )

#define	DAVOPTIONS_DAVSUPPORT_2	( 0x2 )

#define	DAVOPTIONS_DAVVERB_GET	( 0x1 )

#define	DAVOPTIONS_DAVVERB_HEAD	( 0x2 )

#define	DAVOPTIONS_DAVVERB_OPTIONS	( 0x4 )

#define	DAVOPTIONS_DAVVERB_PUT	( 0x8 )

#define	DAVOPTIONS_DAVVERB_POST	( 0x10 )

#define	DAVOPTIONS_DAVVERB_DELETE	( 0x20 )

#define	DAVOPTIONS_DAVVERB_MKCOL	( 0x40 )

#define	DAVOPTIONS_DAVVERB_COPY	( 0x80 )

#define	DAVOPTIONS_DAVVERB_MOVE	( 0x100 )

#define	DAVOPTIONS_DAVVERB_PROPFIND	( 0x200 )

#define	DAVOPTIONS_DAVVERB_PROPPATCH	( 0x400 )

typedef 
enum tagDAVPROPTYPE
    {	DPT_BLOB	= 0,
	DPT_FILETIME	= DPT_BLOB + 1,
	DPT_I2	= DPT_FILETIME + 1,
	DPT_I4	= DPT_I2 + 1,
	DPT_LPWSTR	= DPT_I4 + 1,
	DPT_UI2	= DPT_LPWSTR + 1,
	DPT_UI4	= DPT_UI2 + 1
    }	DAVPROPTYPE;

typedef enum tagDAVPROPTYPE __RPC_FAR *LPDAVPROPTYPE;

typedef struct tagDAVPROPID
    {
    DWORD dwId;
    DAVPROPTYPE dpt;
    }	DAVPROPID;

typedef struct tagDAVPROPID __RPC_FAR *LPDAVPROPID;

typedef struct tagDAVBLOB
    {
    DWORD cbBlob;
    /* [size_is] */ BYTE __RPC_FAR *pb;
    }	DAVBLOB;

typedef struct tagDAVBLOB __RPC_FAR *LPDAVBLOB;

typedef struct tagDAVPROPVAL
    {
    DWORD dwId;
    DAVPROPTYPE dpt;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ DAVBLOB dbVal;
        /* [case()] */ FILETIME ftVal;
        /* [case()] */ short iVal;
        /* [case()] */ long lVal;
        /* [case()] */ LPWSTR pwszVal;
        /* [case()] */ USHORT uiVal;
        /* [case()] */ ULONG ulVal;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	DAVPROPVAL;

typedef struct tagDAVPROPVAL __RPC_FAR *LPDAVPROPVAL;


EXTERN_C const IID LIBID_DavAPI;

#ifndef __IPropFindRequest_INTERFACE_DEFINED__
#define __IPropFindRequest_INTERFACE_DEFINED__

/* interface IPropFindRequest */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropFindRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("391B226C-D032-11d2-B311-00105A9974A0")
    IPropFindRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropInfo( 
            LPCWSTR pwszNamespace,
            LPCWSTR pwszPropname,
            DAVPROPID propid) = 0;
        
        virtual BOOL STDMETHODCALLTYPE GetPropInfo( 
            LPCWSTR pwszNamespace,
            LPCWSTR pwszPropName,
            LPDAVPROPID ppropid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropCount( 
            /* [out] */ UINT __RPC_FAR *cProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXmlUtf8( 
            IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropFindRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropFindRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropFindRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropFindRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropInfo )( 
            IPropFindRequest __RPC_FAR * This,
            LPCWSTR pwszNamespace,
            LPCWSTR pwszPropname,
            DAVPROPID propid);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *GetPropInfo )( 
            IPropFindRequest __RPC_FAR * This,
            LPCWSTR pwszNamespace,
            LPCWSTR pwszPropName,
            LPDAVPROPID ppropid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropCount )( 
            IPropFindRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *cProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetXmlUtf8 )( 
            IPropFindRequest __RPC_FAR * This,
            IStream __RPC_FAR *__RPC_FAR *ppStream);
        
        END_INTERFACE
    } IPropFindRequestVtbl;

    interface IPropFindRequest
    {
        CONST_VTBL struct IPropFindRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropFindRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropFindRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropFindRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropFindRequest_SetPropInfo(This,pwszNamespace,pwszPropname,propid)	\
    (This)->lpVtbl -> SetPropInfo(This,pwszNamespace,pwszPropname,propid)

#define IPropFindRequest_GetPropInfo(This,pwszNamespace,pwszPropName,ppropid)	\
    (This)->lpVtbl -> GetPropInfo(This,pwszNamespace,pwszPropName,ppropid)

#define IPropFindRequest_GetPropCount(This,cProp)	\
    (This)->lpVtbl -> GetPropCount(This,cProp)

#define IPropFindRequest_GetXmlUtf8(This,ppStream)	\
    (This)->lpVtbl -> GetXmlUtf8(This,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropFindRequest_SetPropInfo_Proxy( 
    IPropFindRequest __RPC_FAR * This,
    LPCWSTR pwszNamespace,
    LPCWSTR pwszPropname,
    DAVPROPID propid);


void __RPC_STUB IPropFindRequest_SetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IPropFindRequest_GetPropInfo_Proxy( 
    IPropFindRequest __RPC_FAR * This,
    LPCWSTR pwszNamespace,
    LPCWSTR pwszPropName,
    LPDAVPROPID ppropid);


void __RPC_STUB IPropFindRequest_GetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindRequest_GetPropCount_Proxy( 
    IPropFindRequest __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *cProp);


void __RPC_STUB IPropFindRequest_GetPropCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropFindRequest_GetXmlUtf8_Proxy( 
    IPropFindRequest __RPC_FAR * This,
    IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IPropFindRequest_GetXmlUtf8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropFindRequest_INTERFACE_DEFINED__ */


#ifndef __IPropPatchRequest_INTERFACE_DEFINED__
#define __IPropPatchRequest_INTERFACE_DEFINED__

/* interface IPropPatchRequest */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPropPatchRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A508200-3EA3-4725-84EE-8A326976D483")
    IPropPatchRequest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPropValue( 
            /* [in] */ LPCWSTR pwszNamespace,
            /* [in] */ LPCWSTR pwszPropname,
            /* [in] */ LPDAVPROPVAL ppropval) = 0;
        
        virtual BOOL STDMETHODCALLTYPE GetPropInfo( 
            /* [out] */ LPCWSTR pwszNamespace,
            /* [out] */ LPCWSTR pwszPropName,
            /* [in] */ LPDAVPROPID ppropid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXmlUtf8( 
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropPatchRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropPatchRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropPatchRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropValue )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszNamespace,
            /* [in] */ LPCWSTR pwszPropname,
            /* [in] */ LPDAVPROPVAL ppropval);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *GetPropInfo )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [out] */ LPCWSTR pwszNamespace,
            /* [out] */ LPCWSTR pwszPropName,
            /* [in] */ LPDAVPROPID ppropid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetXmlUtf8 )( 
            IPropPatchRequest __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);
        
        END_INTERFACE
    } IPropPatchRequestVtbl;

    interface IPropPatchRequest
    {
        CONST_VTBL struct IPropPatchRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropPatchRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropPatchRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropPatchRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropPatchRequest_SetPropValue(This,pwszNamespace,pwszPropname,ppropval)	\
    (This)->lpVtbl -> SetPropValue(This,pwszNamespace,pwszPropname,ppropval)

#define IPropPatchRequest_GetPropInfo(This,pwszNamespace,pwszPropName,ppropid)	\
    (This)->lpVtbl -> GetPropInfo(This,pwszNamespace,pwszPropName,ppropid)

#define IPropPatchRequest_GetXmlUtf8(This,ppStream)	\
    (This)->lpVtbl -> GetXmlUtf8(This,ppStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropPatchRequest_SetPropValue_Proxy( 
    IPropPatchRequest __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszNamespace,
    /* [in] */ LPCWSTR pwszPropname,
    /* [in] */ LPDAVPROPVAL ppropval);


void __RPC_STUB IPropPatchRequest_SetPropValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IPropPatchRequest_GetPropInfo_Proxy( 
    IPropPatchRequest __RPC_FAR * This,
    /* [out] */ LPCWSTR pwszNamespace,
    /* [out] */ LPCWSTR pwszPropName,
    /* [in] */ LPDAVPROPID ppropid);


void __RPC_STUB IPropPatchRequest_GetPropInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropPatchRequest_GetXmlUtf8_Proxy( 
    IPropPatchRequest __RPC_FAR * This,
    /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppStream);


void __RPC_STUB IPropPatchRequest_GetXmlUtf8_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropPatchRequest_INTERFACE_DEFINED__ */


#ifndef __IDavCallback_INTERFACE_DEFINED__
#define __IDavCallback_INTERFACE_DEFINED__

/* interface IDavCallback */
/* [object][helpstring][uuid] */ 

typedef 
enum tagDAVCOMMAND
    {	DAV_NONE	= 0,
	DAV_GET	= DAV_NONE + 1,
	DAV_OPTIONS	= DAV_GET + 1,
	DAV_HEAD	= DAV_OPTIONS + 1,
	DAV_PUT	= DAV_HEAD + 1,
	DAV_MKCOL	= DAV_PUT + 1,
	DAV_POST	= DAV_MKCOL + 1,
	DAV_DELETE	= DAV_POST + 1,
	DAV_COPY	= DAV_DELETE + 1,
	DAV_MOVE	= DAV_COPY + 1,
	DAV_PROPFIND	= DAV_MOVE + 1,
	DAV_PROPPATCH	= DAV_PROPFIND + 1,
	DAV_SEARCH	= DAV_PROPPATCH + 1,
	DAV_REPLSEARCH	= DAV_SEARCH + 1,
	DAV_LAST	= DAV_REPLSEARCH + 1
    }	DAVCOMMAND;

typedef 
enum tagREPLCHANGETYPE
    {	REPL_ADD	= 0,
	REPL_DELETE	= REPL_ADD + 1,
	REPL_LAST	= REPL_DELETE + 1
    }	REPLCHANGETYPE;

typedef struct tagDAVGET
    {
    BOOL fTotalKnown;
    DWORD cbIncrement;
    DWORD cbCurrent;
    DWORD cbTotal;
    LPVOID pvBody;
    LPWSTR pwszContentType;
    }	DAVGET;

typedef struct tagDAVHEAD
    {
    DWORD cchRawHeaders;
    LPWSTR pwszRawHeaders;
    }	DAVHEAD;

typedef struct tagDAVOPTIONS
    {
    DWORD cchRawHeaders;
    LPWSTR pwszRawHeaders;
    BYTE bDavSupport;
    DWORD dwDavMethodsAllow;
    DWORD dwDavMethodsPublic;
    }	DAVOPTIONS;

typedef struct tagDAVPUT
    {
    LPCWSTR pwszLocation;
    BOOL fResend;
    DWORD cbIncrement;
    DWORD cbCurrent;
    DWORD cbTotal;
    }	DAVPUT;

typedef DAVPUT DAVPOST;

typedef struct tagDAVPROPFIND
    {
    LPCWSTR pwszHref;
    WORD cPropVal;
    DAVPROPVAL __RPC_FAR *rgPropVal;
    }	DAVPROPFIND;

typedef DAVPROPFIND DAVPROPPATCH;

typedef DAVPROPFIND DAVSEARCH;

typedef struct tagDAVREPLSEARCH
    {
    ULONG cbCollblob;
    BYTE __RPC_FAR *pbCollblob;
    LPCWSTR pwszHref;
    REPLCHANGETYPE changetype;
    WORD cPropVal;
    DAVPROPVAL __RPC_FAR *rgPropVal;
    }	DAVREPLSEARCH;

typedef struct tagDAVRESPONSE
    {
    DAVCOMMAND command;
    BOOL fDone;
    HRESULT hrResult;
    UINT uHTTPReturnCode;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ DAVGET rGet;
        /* [case()] */ DAVHEAD rHead;
        /* [case()] */ DAVOPTIONS rOptions;
        /* [case()] */ DAVPUT rPut;
        /* [case()] */ DAVPOST rPost;
        /* [case()] */ DAVPROPFIND rPropFind;
        /* [case()] */ DAVREPLSEARCH rReplSearch;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	DAVRESPONSE;

typedef struct tagDAVRESPONSE __RPC_FAR *LPDAVRESPONSE;


EXTERN_C const IID IID_IDavCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC0D2910-C20D-11d2-B2F5-00105A9974A0")
    IDavCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAuthChallenge( 
            /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
            /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResponse( 
            /* [in] */ DAVRESPONSE __RPC_FAR *pResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDavCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDavCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDavCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDavCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnAuthChallenge )( 
            IDavCallback __RPC_FAR * This,
            /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
            /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnResponse )( 
            IDavCallback __RPC_FAR * This,
            /* [in] */ DAVRESPONSE __RPC_FAR *pResponse);
        
        END_INTERFACE
    } IDavCallbackVtbl;

    interface IDavCallback
    {
        CONST_VTBL struct IDavCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDavCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDavCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDavCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDavCallback_OnAuthChallenge(This,szUserName,szPassword)	\
    (This)->lpVtbl -> OnAuthChallenge(This,szUserName,szPassword)

#define IDavCallback_OnResponse(This,pResponse)	\
    (This)->lpVtbl -> OnResponse(This,pResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDavCallback_OnAuthChallenge_Proxy( 
    IDavCallback __RPC_FAR * This,
    /* [out][in] */ TCHAR __RPC_FAR szUserName[ 255 ],
    /* [out][in] */ TCHAR __RPC_FAR szPassword[ 255 ]);


void __RPC_STUB IDavCallback_OnAuthChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavCallback_OnResponse_Proxy( 
    IDavCallback __RPC_FAR * This,
    /* [in] */ DAVRESPONSE __RPC_FAR *pResponse);


void __RPC_STUB IDavCallback_OnResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDavCallback_INTERFACE_DEFINED__ */


#ifndef __IDavTransport_INTERFACE_DEFINED__
#define __IDavTransport_INTERFACE_DEFINED__

/* interface IDavTransport */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IDavTransport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("93F23B8C-C20C-11d2-B2F5-00105A9974A0")
    IDavTransport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetUserAgent( 
            /* [in] */ LPCWSTR pwszUserAgent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuthentication( 
            /* [optional][in] */ LPCWSTR pwszUserName,
            /* [optional][in] */ LPCWSTR pwszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogFilePath( 
            /* [optional][in] */ LPCWSTR pwszLogFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandGET( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ ULONG nAcceptTypes,
            /* [size_is][in] */ LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            /* [in] */ BOOL fTranslate,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandOPTIONS( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandHEAD( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPUT( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ LPCWSTR pwszContentType,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPOST( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ LPCWSTR pwszContentType,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandMKCOL( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandDELETE( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandCOPY( 
            /* [in] */ LPCWSTR pwszUrlSource,
            /* [in] */ LPCWSTR pwszUrlDest,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fOverwrite,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandMOVE( 
            /* [in] */ LPCWSTR pwszUrlSource,
            /* [in] */ LPCWSTR pwszUrlDest,
            /* [in] */ BOOL fOverwrite,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPROPFIND( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IPropFindRequest __RPC_FAR *pRequest,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fNoRoot,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandPROPPATCH( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IPropPatchRequest __RPC_FAR *pRequest,
            /* [in] */ LPCWSTR pwszHeaders,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandSEARCH( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommandREPLSEARCH( 
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ ULONG cbCollblob,
            /* [size_is][in] */ BYTE __RPC_FAR *pbCollblob,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDavTransportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDavTransport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDavTransport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserAgent )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUserAgent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuthentication )( 
            IDavTransport __RPC_FAR * This,
            /* [optional][in] */ LPCWSTR pwszUserName,
            /* [optional][in] */ LPCWSTR pwszPassword);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogFilePath )( 
            IDavTransport __RPC_FAR * This,
            /* [optional][in] */ LPCWSTR pwszLogFilePath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandGET )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ ULONG nAcceptTypes,
            /* [size_is][in] */ LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            /* [in] */ BOOL fTranslate,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandOPTIONS )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandHEAD )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPUT )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ LPCWSTR pwszContentType,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPOST )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ LPCWSTR pwszContentType,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMKCOL )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandDELETE )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandCOPY )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrlSource,
            /* [in] */ LPCWSTR pwszUrlDest,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fOverwrite,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandMOVE )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrlSource,
            /* [in] */ LPCWSTR pwszUrlDest,
            /* [in] */ BOOL fOverwrite,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPROPFIND )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IPropFindRequest __RPC_FAR *pRequest,
            /* [in] */ DWORD dwDepth,
            /* [in] */ BOOL fNoRoot,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandPROPPATCH )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IPropPatchRequest __RPC_FAR *pRequest,
            /* [in] */ LPCWSTR pwszHeaders,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandSEARCH )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommandREPLSEARCH )( 
            IDavTransport __RPC_FAR * This,
            /* [in] */ LPCWSTR pwszUrl,
            /* [in] */ ULONG cbCollblob,
            /* [size_is][in] */ BYTE __RPC_FAR *pbCollblob,
            /* [in] */ IDavCallback __RPC_FAR *pCallback,
            /* [in] */ DWORD dwCallbackParam);
        
        END_INTERFACE
    } IDavTransportVtbl;

    interface IDavTransport
    {
        CONST_VTBL struct IDavTransportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDavTransport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDavTransport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDavTransport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDavTransport_SetUserAgent(This,pwszUserAgent)	\
    (This)->lpVtbl -> SetUserAgent(This,pwszUserAgent)

#define IDavTransport_SetAuthentication(This,pwszUserName,pwszPassword)	\
    (This)->lpVtbl -> SetAuthentication(This,pwszUserName,pwszPassword)

#define IDavTransport_SetLogFilePath(This,pwszLogFilePath)	\
    (This)->lpVtbl -> SetLogFilePath(This,pwszLogFilePath)

#define IDavTransport_CommandGET(This,pwszUrl,nAcceptTypes,rgwszAcceptTypes,fTranslate,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandGET(This,pwszUrl,nAcceptTypes,rgwszAcceptTypes,fTranslate,pCallback,dwCallbackParam)

#define IDavTransport_CommandOPTIONS(This,pwszUrl,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandOPTIONS(This,pwszUrl,pCallback,dwCallbackParam)

#define IDavTransport_CommandHEAD(This,pwszUrl,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandHEAD(This,pwszUrl,pCallback,dwCallbackParam)

#define IDavTransport_CommandPUT(This,pwszUrl,pStream,pwszContentType,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandPUT(This,pwszUrl,pStream,pwszContentType,pCallback,dwCallbackParam)

#define IDavTransport_CommandPOST(This,pwszUrl,pStream,pwszContentType,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandPOST(This,pwszUrl,pStream,pwszContentType,pCallback,dwCallbackParam)

#define IDavTransport_CommandMKCOL(This,pwszUrl,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandMKCOL(This,pwszUrl,pCallback,dwCallbackParam)

#define IDavTransport_CommandDELETE(This,pwszUrl,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandDELETE(This,pwszUrl,pCallback,dwCallbackParam)

#define IDavTransport_CommandCOPY(This,pwszUrlSource,pwszUrlDest,dwDepth,fOverwrite,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandCOPY(This,pwszUrlSource,pwszUrlDest,dwDepth,fOverwrite,pCallback,dwCallbackParam)

#define IDavTransport_CommandMOVE(This,pwszUrlSource,pwszUrlDest,fOverwrite,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandMOVE(This,pwszUrlSource,pwszUrlDest,fOverwrite,pCallback,dwCallbackParam)

#define IDavTransport_CommandPROPFIND(This,pwszUrl,pRequest,dwDepth,fNoRoot,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandPROPFIND(This,pwszUrl,pRequest,dwDepth,fNoRoot,pCallback,dwCallbackParam)

#define IDavTransport_CommandPROPPATCH(This,pwszUrl,pRequest,pwszHeaders,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandPROPPATCH(This,pwszUrl,pRequest,pwszHeaders,pCallback,dwCallbackParam)

#define IDavTransport_CommandSEARCH(This,pwszUrl,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandSEARCH(This,pwszUrl,pCallback,dwCallbackParam)

#define IDavTransport_CommandREPLSEARCH(This,pwszUrl,cbCollblob,pbCollblob,pCallback,dwCallbackParam)	\
    (This)->lpVtbl -> CommandREPLSEARCH(This,pwszUrl,cbCollblob,pbCollblob,pCallback,dwCallbackParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDavTransport_SetUserAgent_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUserAgent);


void __RPC_STUB IDavTransport_SetUserAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_SetAuthentication_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [optional][in] */ LPCWSTR pwszUserName,
    /* [optional][in] */ LPCWSTR pwszPassword);


void __RPC_STUB IDavTransport_SetAuthentication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_SetLogFilePath_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [optional][in] */ LPCWSTR pwszLogFilePath);


void __RPC_STUB IDavTransport_SetLogFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandGET_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ ULONG nAcceptTypes,
    /* [size_is][in] */ LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
    /* [in] */ BOOL fTranslate,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandGET_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandOPTIONS_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandOPTIONS_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandHEAD_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandHEAD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandPUT_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ LPCWSTR pwszContentType,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandPUT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandPOST_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ LPCWSTR pwszContentType,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandPOST_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandMKCOL_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandMKCOL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandDELETE_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandDELETE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandCOPY_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrlSource,
    /* [in] */ LPCWSTR pwszUrlDest,
    /* [in] */ DWORD dwDepth,
    /* [in] */ BOOL fOverwrite,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandCOPY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandMOVE_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrlSource,
    /* [in] */ LPCWSTR pwszUrlDest,
    /* [in] */ BOOL fOverwrite,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandMOVE_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandPROPFIND_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IPropFindRequest __RPC_FAR *pRequest,
    /* [in] */ DWORD dwDepth,
    /* [in] */ BOOL fNoRoot,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandPROPFIND_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandPROPPATCH_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IPropPatchRequest __RPC_FAR *pRequest,
    /* [in] */ LPCWSTR pwszHeaders,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandPROPPATCH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandSEARCH_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandSEARCH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavTransport_CommandREPLSEARCH_Proxy( 
    IDavTransport __RPC_FAR * This,
    /* [in] */ LPCWSTR pwszUrl,
    /* [in] */ ULONG cbCollblob,
    /* [size_is][in] */ BYTE __RPC_FAR *pbCollblob,
    /* [in] */ IDavCallback __RPC_FAR *pCallback,
    /* [in] */ DWORD dwCallbackParam);


void __RPC_STUB IDavTransport_CommandREPLSEARCH_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDavTransport_INTERFACE_DEFINED__ */

#endif /* __DavAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\httpstrm\idl\makefile.inc ===
$(DAVTRANS_ROOT)\ifaces\ihttpstrm.h: ihttpstrm.h
    copy $** $@

$(DAVTRANS_ROOT)\httpstrm\lib\ihttpstrm.tlb: ihttpstrm.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\iasyncwnt.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for iasyncwnt.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __iasyncwnt_h__
#define __iasyncwnt_h__

/* Forward Declarations */ 

#ifndef __IAsyncWntCallback_FWD_DEFINED__
#define __IAsyncWntCallback_FWD_DEFINED__
typedef interface IAsyncWntCallback IAsyncWntCallback;
#endif 	/* __IAsyncWntCallback_FWD_DEFINED__ */


#ifndef __IAsyncWnt_FWD_DEFINED__
#define __IAsyncWnt_FWD_DEFINED__
typedef interface IAsyncWnt IAsyncWnt;
#endif 	/* __IAsyncWnt_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_iasyncwnt_0000 */
/* [local] */ 

#define IASYNCWNT_ACCEPTALL 0xffffffff
interface IAsyncWnt;


extern RPC_IF_HANDLE __MIDL_itf_iasyncwnt_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iasyncwnt_0000_v0_0_s_ifspec;


#ifndef __AsyncWntAPI_LIBRARY_DEFINED__
#define __AsyncWntAPI_LIBRARY_DEFINED__

/* library AsyncWntAPI */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_AsyncWntAPI;

#ifndef __IAsyncWntCallback_INTERFACE_DEFINED__
#define __IAsyncWntCallback_INTERFACE_DEFINED__

/* interface IAsyncWntCallback */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IAsyncWntCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4868EB72-41A6-4781-B261-4C81F18497C0")
    IAsyncWntCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAuthChallenge( 
            TCHAR __RPC_FAR szUserName[ 255 ],
            TCHAR __RPC_FAR szPassword[ 255 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Respond( 
            LPWSTR pwszVerb,
            LPWSTR pwszPath,
            DWORD cchHeaders,
            LPWSTR pwszHeaders,
            DWORD dwStatusCode,
            LPWSTR pwszStatusCode,
            LPWSTR pwszContentType,
            DWORD cbSent,
            BYTE __RPC_FAR *pbResponse,
            DWORD cbResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncWntCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAsyncWntCallback __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAsyncWntCallback __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAsyncWntCallback __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnAuthChallenge )( 
            IAsyncWntCallback __RPC_FAR * This,
            TCHAR __RPC_FAR szUserName[ 255 ],
            TCHAR __RPC_FAR szPassword[ 255 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Respond )( 
            IAsyncWntCallback __RPC_FAR * This,
            LPWSTR pwszVerb,
            LPWSTR pwszPath,
            DWORD cchHeaders,
            LPWSTR pwszHeaders,
            DWORD dwStatusCode,
            LPWSTR pwszStatusCode,
            LPWSTR pwszContentType,
            DWORD cbSent,
            BYTE __RPC_FAR *pbResponse,
            DWORD cbResponse);
        
        END_INTERFACE
    } IAsyncWntCallbackVtbl;

    interface IAsyncWntCallback
    {
        CONST_VTBL struct IAsyncWntCallbackVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncWntCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncWntCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncWntCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncWntCallback_OnAuthChallenge(This,szUserName,szPassword)	\
    (This)->lpVtbl -> OnAuthChallenge(This,szUserName,szPassword)

#define IAsyncWntCallback_Respond(This,pwszVerb,pwszPath,cchHeaders,pwszHeaders,dwStatusCode,pwszStatusCode,pwszContentType,cbSent,pbResponse,cbResponse)	\
    (This)->lpVtbl -> Respond(This,pwszVerb,pwszPath,cchHeaders,pwszHeaders,dwStatusCode,pwszStatusCode,pwszContentType,cbSent,pbResponse,cbResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAsyncWntCallback_OnAuthChallenge_Proxy( 
    IAsyncWntCallback __RPC_FAR * This,
    TCHAR __RPC_FAR szUserName[ 255 ],
    TCHAR __RPC_FAR szPassword[ 255 ]);


void __RPC_STUB IAsyncWntCallback_OnAuthChallenge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncWntCallback_Respond_Proxy( 
    IAsyncWntCallback __RPC_FAR * This,
    LPWSTR pwszVerb,
    LPWSTR pwszPath,
    DWORD cchHeaders,
    LPWSTR pwszHeaders,
    DWORD dwStatusCode,
    LPWSTR pwszStatusCode,
    LPWSTR pwszContentType,
    DWORD cbSent,
    BYTE __RPC_FAR *pbResponse,
    DWORD cbResponse);


void __RPC_STUB IAsyncWntCallback_Respond_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAsyncWntCallback_INTERFACE_DEFINED__ */


#ifndef __IAsyncWnt_INTERFACE_DEFINED__
#define __IAsyncWnt_INTERFACE_DEFINED__

/* interface IAsyncWnt */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IAsyncWnt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B974C800-2214-4c65-9BA0-CDE1430F9786")
    IAsyncWnt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserAgent( 
            LPCWSTR pwszUserAgent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogFilePath( 
            LPCWSTR pwszLogFilePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            LPCWSTR pwszURL,
            LPCWSTR pwszVerb,
            LPCWSTR pwszHeaders,
            ULONG nAcceptTypes,
            LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            IAsyncWntCallback __RPC_FAR *pcallback,
            DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestWithStream( 
            LPCWSTR pwszURL,
            LPCWSTR pwszVerb,
            LPCWSTR pwszHeaders,
            ULONG nAcceptTypes,
            LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            IStream __RPC_FAR *pStream,
            IAsyncWntCallback __RPC_FAR *pcallback,
            DWORD dwContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestWithBuffer( 
            LPCWSTR pwszURL,
            LPCWSTR pWszVerb,
            LPCWSTR pwszHeaders,
            ULONG nAcceptTypes,
            LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            BYTE __RPC_FAR *pbBuffer,
            UINT cbBuffer,
            IAsyncWntCallback __RPC_FAR *pcallback,
            DWORD dwContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAsyncWntVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAsyncWnt __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAsyncWnt __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAsyncWnt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IAsyncWnt __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUserAgent )( 
            IAsyncWnt __RPC_FAR * This,
            LPCWSTR pwszUserAgent);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogFilePath )( 
            IAsyncWnt __RPC_FAR * This,
            LPCWSTR pwszLogFilePath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Request )( 
            IAsyncWnt __RPC_FAR * This,
            LPCWSTR pwszURL,
            LPCWSTR pwszVerb,
            LPCWSTR pwszHeaders,
            ULONG nAcceptTypes,
            LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            IAsyncWntCallback __RPC_FAR *pcallback,
            DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestWithStream )( 
            IAsyncWnt __RPC_FAR * This,
            LPCWSTR pwszURL,
            LPCWSTR pwszVerb,
            LPCWSTR pwszHeaders,
            ULONG nAcceptTypes,
            LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            IStream __RPC_FAR *pStream,
            IAsyncWntCallback __RPC_FAR *pcallback,
            DWORD dwContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestWithBuffer )( 
            IAsyncWnt __RPC_FAR * This,
            LPCWSTR pwszURL,
            LPCWSTR pWszVerb,
            LPCWSTR pwszHeaders,
            ULONG nAcceptTypes,
            LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
            BYTE __RPC_FAR *pbBuffer,
            UINT cbBuffer,
            IAsyncWntCallback __RPC_FAR *pcallback,
            DWORD dwContext);
        
        END_INTERFACE
    } IAsyncWntVtbl;

    interface IAsyncWnt
    {
        CONST_VTBL struct IAsyncWntVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAsyncWnt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAsyncWnt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAsyncWnt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAsyncWnt_Init(This)	\
    (This)->lpVtbl -> Init(This)

#define IAsyncWnt_SetUserAgent(This,pwszUserAgent)	\
    (This)->lpVtbl -> SetUserAgent(This,pwszUserAgent)

#define IAsyncWnt_SetLogFilePath(This,pwszLogFilePath)	\
    (This)->lpVtbl -> SetLogFilePath(This,pwszLogFilePath)

#define IAsyncWnt_Request(This,pwszURL,pwszVerb,pwszHeaders,nAcceptTypes,rgwszAcceptTypes,pcallback,dwContext)	\
    (This)->lpVtbl -> Request(This,pwszURL,pwszVerb,pwszHeaders,nAcceptTypes,rgwszAcceptTypes,pcallback,dwContext)

#define IAsyncWnt_RequestWithStream(This,pwszURL,pwszVerb,pwszHeaders,nAcceptTypes,rgwszAcceptTypes,pStream,pcallback,dwContext)	\
    (This)->lpVtbl -> RequestWithStream(This,pwszURL,pwszVerb,pwszHeaders,nAcceptTypes,rgwszAcceptTypes,pStream,pcallback,dwContext)

#define IAsyncWnt_RequestWithBuffer(This,pwszURL,pWszVerb,pwszHeaders,nAcceptTypes,rgwszAcceptTypes,pbBuffer,cbBuffer,pcallback,dwContext)	\
    (This)->lpVtbl -> RequestWithBuffer(This,pwszURL,pWszVerb,pwszHeaders,nAcceptTypes,rgwszAcceptTypes,pbBuffer,cbBuffer,pcallback,dwContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAsyncWnt_Init_Proxy( 
    IAsyncWnt __RPC_FAR * This);


void __RPC_STUB IAsyncWnt_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncWnt_SetUserAgent_Proxy( 
    IAsyncWnt __RPC_FAR * This,
    LPCWSTR pwszUserAgent);


void __RPC_STUB IAsyncWnt_SetUserAgent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncWnt_SetLogFilePath_Proxy( 
    IAsyncWnt __RPC_FAR * This,
    LPCWSTR pwszLogFilePath);


void __RPC_STUB IAsyncWnt_SetLogFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncWnt_Request_Proxy( 
    IAsyncWnt __RPC_FAR * This,
    LPCWSTR pwszURL,
    LPCWSTR pwszVerb,
    LPCWSTR pwszHeaders,
    ULONG nAcceptTypes,
    LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
    IAsyncWntCallback __RPC_FAR *pcallback,
    DWORD dwContext);


void __RPC_STUB IAsyncWnt_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncWnt_RequestWithStream_Proxy( 
    IAsyncWnt __RPC_FAR * This,
    LPCWSTR pwszURL,
    LPCWSTR pwszVerb,
    LPCWSTR pwszHeaders,
    ULONG nAcceptTypes,
    LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
    IStream __RPC_FAR *pStream,
    IAsyncWntCallback __RPC_FAR *pcallback,
    DWORD dwContext);


void __RPC_STUB IAsyncWnt_RequestWithStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAsyncWnt_RequestWithBuffer_Proxy( 
    IAsyncWnt __RPC_FAR * This,
    LPCWSTR pwszURL,
    LPCWSTR pWszVerb,
    LPCWSTR pwszHeaders,
    ULONG nAcceptTypes,
    LPCWSTR __RPC_FAR rgwszAcceptTypes[  ],
    BYTE __RPC_FAR *pbBuffer,
    UINT cbBuffer,
    IAsyncWntCallback __RPC_FAR *pcallback,
    DWORD dwContext);


void __RPC_STUB IAsyncWnt_RequestWithBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAsyncWnt_INTERFACE_DEFINED__ */

#endif /* __AsyncWntAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\idavstore.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for idavstore.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __idavstore_h__
#define __idavstore_h__

/* Forward Declarations */ 

#ifndef __IDavStorage_FWD_DEFINED__
#define __IDavStorage_FWD_DEFINED__
typedef interface IDavStorage IDavStorage;
#endif 	/* __IDavStorage_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_idavstore_0000 */
/* [local] */ 

interface IDavTransport;


extern RPC_IF_HANDLE __MIDL_itf_idavstore_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_idavstore_0000_v0_0_s_ifspec;


#ifndef __DavStoreAPI_LIBRARY_DEFINED__
#define __DavStoreAPI_LIBRARY_DEFINED__

/* library DavStoreAPI */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DavStoreAPI;

#ifndef __IDavStorage_INTERFACE_DEFINED__
#define __IDavStorage_INTERFACE_DEFINED__

/* interface IDavStorage */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IDavStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("97B79B7E-6701-43cb-8515-035301124B4F")
    IDavStorage : public IStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            LPWSTR pwszURL,
            IDavTransport __RPC_FAR *pDavTransport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuth( 
            LPWSTR pwszUserName,
            LPWSTR pwszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDavStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDavStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDavStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDavStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStream )( 
            IDavStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IDavStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage )( 
            IDavStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStorage )( 
            IDavStorage __RPC_FAR * This,
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IDavStorage __RPC_FAR * This,
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveElementTo )( 
            IDavStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IDavStorage __RPC_FAR * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert )( 
            IDavStorage __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumElements )( 
            IDavStorage __RPC_FAR * This,
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyElement )( 
            IDavStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameElement )( 
            IDavStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetElementTimes )( 
            IDavStorage __RPC_FAR * This,
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ const FILETIME __RPC_FAR *pctime,
            /* [unique][in] */ const FILETIME __RPC_FAR *patime,
            /* [unique][in] */ const FILETIME __RPC_FAR *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClass )( 
            IDavStorage __RPC_FAR * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStateBits )( 
            IDavStorage __RPC_FAR * This,
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stat )( 
            IDavStorage __RPC_FAR * This,
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IDavStorage __RPC_FAR * This,
            LPWSTR pwszURL,
            IDavTransport __RPC_FAR *pDavTransport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuth )( 
            IDavStorage __RPC_FAR * This,
            LPWSTR pwszUserName,
            LPWSTR pwszPassword);
        
        END_INTERFACE
    } IDavStorageVtbl;

    interface IDavStorage
    {
        CONST_VTBL struct IDavStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDavStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDavStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDavStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDavStorage_CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)	\
    (This)->lpVtbl -> CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)

#define IDavStorage_OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)	\
    (This)->lpVtbl -> OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)

#define IDavStorage_CreateStorage(This,pwcsName,grfMode,reserved1,reserved2,ppstg)	\
    (This)->lpVtbl -> CreateStorage(This,pwcsName,grfMode,reserved1,reserved2,ppstg)

#define IDavStorage_OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)	\
    (This)->lpVtbl -> OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)

#define IDavStorage_CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)	\
    (This)->lpVtbl -> CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)

#define IDavStorage_MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)	\
    (This)->lpVtbl -> MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)

#define IDavStorage_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IDavStorage_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IDavStorage_EnumElements(This,reserved1,reserved2,reserved3,ppenum)	\
    (This)->lpVtbl -> EnumElements(This,reserved1,reserved2,reserved3,ppenum)

#define IDavStorage_DestroyElement(This,pwcsName)	\
    (This)->lpVtbl -> DestroyElement(This,pwcsName)

#define IDavStorage_RenameElement(This,pwcsOldName,pwcsNewName)	\
    (This)->lpVtbl -> RenameElement(This,pwcsOldName,pwcsNewName)

#define IDavStorage_SetElementTimes(This,pwcsName,pctime,patime,pmtime)	\
    (This)->lpVtbl -> SetElementTimes(This,pwcsName,pctime,patime,pmtime)

#define IDavStorage_SetClass(This,clsid)	\
    (This)->lpVtbl -> SetClass(This,clsid)

#define IDavStorage_SetStateBits(This,grfStateBits,grfMask)	\
    (This)->lpVtbl -> SetStateBits(This,grfStateBits,grfMask)

#define IDavStorage_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)


#define IDavStorage_Init(This,pwszURL,pDavTransport)	\
    (This)->lpVtbl -> Init(This,pwszURL,pDavTransport)

#define IDavStorage_SetAuth(This,pwszUserName,pwszPassword)	\
    (This)->lpVtbl -> SetAuth(This,pwszUserName,pwszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDavStorage_Init_Proxy( 
    IDavStorage __RPC_FAR * This,
    LPWSTR pwszURL,
    IDavTransport __RPC_FAR *pDavTransport);


void __RPC_STUB IDavStorage_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDavStorage_SetAuth_Proxy( 
    IDavStorage __RPC_FAR * This,
    LPWSTR pwszUserName,
    LPWSTR pwszPassword);


void __RPC_STUB IDavStorage_SetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDavStorage_INTERFACE_DEFINED__ */

#endif /* __DavStoreAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\ishellstg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* Compiler settings for ishellstg.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ishellstg_h__
#define __ishellstg_h__

/* Forward Declarations */ 

#ifndef __IShellStorage_FWD_DEFINED__
#define __IShellStorage_FWD_DEFINED__
typedef interface IShellStorage IShellStorage;
#endif 	/* __IShellStorage_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_ishellstg_0000 */
/* [local] */ 

interface IDavTransport;


extern RPC_IF_HANDLE __MIDL_itf_ishellstg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ishellstg_0000_v0_0_s_ifspec;


#ifndef __ShellStorageAPI_LIBRARY_DEFINED__
#define __ShellStorageAPI_LIBRARY_DEFINED__

/* library ShellStorageAPI */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ShellStorageAPI;

#ifndef __IShellStorage_INTERFACE_DEFINED__
#define __IShellStorage_INTERFACE_DEFINED__

/* interface IShellStorage */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("694D8DB5-F7A4-4e72-A547-2F3DD5FA5B0D")
    IShellStorage : public IStorage
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            HWND hwnd,
            LPWSTR pwszServer,
            BOOL fShowProgressDialog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddIDListReference( 
            LPVOID __RPC_FAR rgpidl[  ],
            DWORD cpidl,
            BOOL fRecursive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IShellStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IShellStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IShellStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStream )( 
            IShellStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStream )( 
            IShellStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ void __RPC_FAR *reserved1,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateStorage )( 
            IShellStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [in] */ DWORD grfMode,
            /* [in] */ DWORD reserved1,
            /* [in] */ DWORD reserved2,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenStorage )( 
            IShellStorage __RPC_FAR * This,
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgPriority,
            /* [in] */ DWORD grfMode,
            /* [unique][in] */ SNB snbExclude,
            /* [in] */ DWORD reserved,
            /* [out] */ IStorage __RPC_FAR *__RPC_FAR *ppstg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IShellStorage __RPC_FAR * This,
            /* [in] */ DWORD ciidExclude,
            /* [size_is][unique][in] */ const IID __RPC_FAR *rgiidExclude,
            /* [unique][in] */ SNB snbExclude,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveElementTo )( 
            IShellStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ IStorage __RPC_FAR *pstgDest,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName,
            /* [in] */ DWORD grfFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IShellStorage __RPC_FAR * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert )( 
            IShellStorage __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumElements )( 
            IShellStorage __RPC_FAR * This,
            /* [in] */ DWORD reserved1,
            /* [size_is][unique][in] */ void __RPC_FAR *reserved2,
            /* [in] */ DWORD reserved3,
            /* [out] */ IEnumSTATSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyElement )( 
            IShellStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameElement )( 
            IShellStorage __RPC_FAR * This,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsOldName,
            /* [string][in] */ const OLECHAR __RPC_FAR *pwcsNewName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetElementTimes )( 
            IShellStorage __RPC_FAR * This,
            /* [string][unique][in] */ const OLECHAR __RPC_FAR *pwcsName,
            /* [unique][in] */ const FILETIME __RPC_FAR *pctime,
            /* [unique][in] */ const FILETIME __RPC_FAR *patime,
            /* [unique][in] */ const FILETIME __RPC_FAR *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClass )( 
            IShellStorage __RPC_FAR * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStateBits )( 
            IShellStorage __RPC_FAR * This,
            /* [in] */ DWORD grfStateBits,
            /* [in] */ DWORD grfMask);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stat )( 
            IShellStorage __RPC_FAR * This,
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Init )( 
            IShellStorage __RPC_FAR * This,
            HWND hwnd,
            LPWSTR pwszServer,
            BOOL fShowProgressDialog);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddIDListReference )( 
            IShellStorage __RPC_FAR * This,
            LPVOID __RPC_FAR rgpidl[  ],
            DWORD cpidl,
            BOOL fRecursive);
        
        END_INTERFACE
    } IShellStorageVtbl;

    interface IShellStorage
    {
        CONST_VTBL struct IShellStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellStorage_CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)	\
    (This)->lpVtbl -> CreateStream(This,pwcsName,grfMode,reserved1,reserved2,ppstm)

#define IShellStorage_OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)	\
    (This)->lpVtbl -> OpenStream(This,pwcsName,reserved1,grfMode,reserved2,ppstm)

#define IShellStorage_CreateStorage(This,pwcsName,grfMode,reserved1,reserved2,ppstg)	\
    (This)->lpVtbl -> CreateStorage(This,pwcsName,grfMode,reserved1,reserved2,ppstg)

#define IShellStorage_OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)	\
    (This)->lpVtbl -> OpenStorage(This,pwcsName,pstgPriority,grfMode,snbExclude,reserved,ppstg)

#define IShellStorage_CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)	\
    (This)->lpVtbl -> CopyTo(This,ciidExclude,rgiidExclude,snbExclude,pstgDest)

#define IShellStorage_MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)	\
    (This)->lpVtbl -> MoveElementTo(This,pwcsName,pstgDest,pwcsNewName,grfFlags)

#define IShellStorage_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IShellStorage_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IShellStorage_EnumElements(This,reserved1,reserved2,reserved3,ppenum)	\
    (This)->lpVtbl -> EnumElements(This,reserved1,reserved2,reserved3,ppenum)

#define IShellStorage_DestroyElement(This,pwcsName)	\
    (This)->lpVtbl -> DestroyElement(This,pwcsName)

#define IShellStorage_RenameElement(This,pwcsOldName,pwcsNewName)	\
    (This)->lpVtbl -> RenameElement(This,pwcsOldName,pwcsNewName)

#define IShellStorage_SetElementTimes(This,pwcsName,pctime,patime,pmtime)	\
    (This)->lpVtbl -> SetElementTimes(This,pwcsName,pctime,patime,pmtime)

#define IShellStorage_SetClass(This,clsid)	\
    (This)->lpVtbl -> SetClass(This,clsid)

#define IShellStorage_SetStateBits(This,grfStateBits,grfMask)	\
    (This)->lpVtbl -> SetStateBits(This,grfStateBits,grfMask)

#define IShellStorage_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)


#define IShellStorage_Init(This,hwnd,pwszServer,fShowProgressDialog)	\
    (This)->lpVtbl -> Init(This,hwnd,pwszServer,fShowProgressDialog)

#define IShellStorage_AddIDListReference(This,rgpidl,cpidl,fRecursive)	\
    (This)->lpVtbl -> AddIDListReference(This,rgpidl,cpidl,fRecursive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellStorage_Init_Proxy( 
    IShellStorage __RPC_FAR * This,
    HWND hwnd,
    LPWSTR pwszServer,
    BOOL fShowProgressDialog);


void __RPC_STUB IShellStorage_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellStorage_AddIDListReference_Proxy( 
    IShellStorage __RPC_FAR * This,
    LPVOID __RPC_FAR rgpidl[  ],
    DWORD cpidl,
    BOOL fRecursive);


void __RPC_STUB IShellStorage_AddIDListReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellStorage_INTERFACE_DEFINED__ */

#endif /* __ShellStorageAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shellstg.rc
//
#define IDS_UPLOADING                   1
#define IDS_CONNECTING                  2
#define IDS_EXAMINING                   3
#define IDS_SERVERTO                    4
#define IDS_SERVERNEWFOLDER             5
#define IDA_FTPUPLOAD                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\clsids.cpp ===
//
//   - Defines CLSID for the DAVSTORE
//
#include <objbase.h>

// {694D8DB5-F7A4-4e72-A547-2F3DD5FA5B0D}
extern "C" const IID IID_IShellStorage = 
{ 0x694D8DB5, 0xF7A4, 0x4e72, { 0xA5, 0x47, 0x2F, 0x3D, 0xD5, 0xFA, 0x5B, 0x0D} };

// {F46316E4-FB1B-46eb-AEDF-9520BFBB916A}
extern "C" const CLSID CLSID_CShellStorage = 
{ 0xf46316e4, 0xfb1b, 0x46eb, { 0xae, 0xdf, 0x95, 0x20, 0xbf, 0xbb, 0x91, 0x6a } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\factdata.cpp ===
///////////////////////////////////////////////////////////////////////////////
// This file contains the component server code.  The FactoryDataArray contains
// the components that can be served.
//
// The following array contains the data used by CFactory to create components.
// Each element in the array contains the CLSID, the pointer to the creation
// function, and the name of the component to place in the Registry.

#include "factdata.h"
#include "fact.h"

#include "shellstg.clsid.h"
#include "shellstg.h"

CFactoryData g_FactoryDataArray[] =
{
    { &CLSID_CShellStorage, 
      CShellStorage::UnkCreateInstance, 
      CShellStorage::UnkActiveComponents, 
      L"ShellStorage",     // Friendly name
      L"ShellStorage.1",                  // ProgID
      L"ShellStorage",                    // Version-independent
      TRUE},                         // ThreadingModel == Both
};

const CFactoryData* CCOMBaseFactory::_pDLLFactoryData = g_FactoryDataArray;

const DWORD CCOMBaseFactory::_cDLLFactoryData = sizeof(g_FactoryDataArray) /
    sizeof(g_FactoryDataArray[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\ihttpprop.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Feb 14 14:23:33 2000
 */
/* Compiler settings for ..\ihttpprop.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ihttpprop_h__
#define __ihttpprop_h__

/* Forward Declarations */ 

#ifndef __IHttpProp_FWD_DEFINED__
#define __IHttpProp_FWD_DEFINED__
typedef interface IHttpProp IHttpProp;
#endif 	/* __IHttpProp_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __HttpPropAPI_LIBRARY_DEFINED__
#define __HttpPropAPI_LIBRARY_DEFINED__

/* library HttpPropAPI */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HttpPropAPI;

#ifndef __IHttpProp_INTERFACE_DEFINED__
#define __IHttpProp_INTERFACE_DEFINED__

/* interface IHttpProp */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IHttpProp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2CD7358A-E573-4c98-9480-1E0C1276E8C8")
    IHttpProp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            LPWSTR pwszPath,
            BOOL fDirect,
            BOOL fDeleteWhenDone,
            BOOL fCreate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuth( 
            LPWSTR pwszUserName,
            LPWSTR pwszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpPropVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHttpProp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHttpProp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHttpProp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IHttpProp __RPC_FAR * This,
            LPWSTR pwszPath,
            BOOL fDirect,
            BOOL fDeleteWhenDone,
            BOOL fCreate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuth )( 
            IHttpProp __RPC_FAR * This,
            LPWSTR pwszUserName,
            LPWSTR pwszPassword);
        
        END_INTERFACE
    } IHttpPropVtbl;

    interface IHttpProp
    {
        CONST_VTBL struct IHttpPropVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpProp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpProp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHttpProp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHttpProp_Open(This,pwszPath,fDirect,fDeleteWhenDone,fCreate)	\
    (This)->lpVtbl -> Open(This,pwszPath,fDirect,fDeleteWhenDone,fCreate)

#define IHttpProp_SetAuth(This,pwszUserName,pwszPassword)	\
    (This)->lpVtbl -> SetAuth(This,pwszUserName,pwszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHttpProp_Open_Proxy( 
    IHttpProp __RPC_FAR * This,
    LPWSTR pwszPath,
    BOOL fDirect,
    BOOL fDeleteWhenDone,
    BOOL fCreate);


void __RPC_STUB IHttpProp_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHttpProp_SetAuth_Proxy( 
    IHttpProp __RPC_FAR * This,
    LPWSTR pwszUserName,
    LPWSTR pwszPassword);


void __RPC_STUB IHttpProp_SetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHttpProp_INTERFACE_DEFINED__ */

#endif /* __HttpPropAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\shellstg.cpp ===
#include <objbase.h>
#include <assert.h>

#include "shlwapi.h"
#include "shellstg.h"
#include "mischlpr.h"
#include "strutil.h"
#include "resource.h"

#include <stdio.h>
#define DEBUG
//#define TRACE(a) (fprintf(stderr,"%d %s\n",GetTickCount(),a))
#define TRACE(a)

///////////////////////////////////////

CShellStorageImpl::CShellStorageImpl (): _plistPIDL(NULL), _pwszTitleExamining(NULL), _pwszTitleConnecting(NULL), 
                                         _pwszTitleSending(NULL), _pwszTitleTo(NULL), _ppd(NULL)
{
    TRACE("CShellStorage::CShellStorage");
}

///////////////////////////////////////

CShellStorageImpl::~CShellStorageImpl ()
{
    TRACE("CShellStorage::~CShellStorage");
}

///////////////////////////////////////

STDMETHODIMP CShellStorageImpl::Init(HWND hwnd, LPWSTR pwszServer, BOOL fShowProgressDialog)
{
    HRESULT hr = S_OK;
    
    TRACE("CShellStorage::Init");

    _hwnd = hwnd;
    _hinstShellStg = GetModuleHandle(L"shellstg");
    if (!_hinstShellStg)
    {
        hr = E_FAIL;
    }
    else
    {
        WCHAR wszLoad[MAX_PATH];
        _pwszTitleExamining = NULL;
        _pwszTitleConnecting = NULL;
        _pwszTitleSending = NULL;
        _pwszTitleTo = NULL;

        if (LoadStringW(_hinstShellStg, IDS_EXAMINING, wszLoad, sizeof(wszLoad)))
            _pwszTitleExamining = DuplicateStringW(wszLoad);

        if (LoadStringW(_hinstShellStg, IDS_CONNECTING, wszLoad, sizeof(wszLoad)))
            _pwszTitleConnecting = DuplicateStringW(wszLoad);

        if (LoadStringW(_hinstShellStg, IDS_UPLOADING, wszLoad, sizeof(wszLoad)))
            _pwszTitleSending = DuplicateStringW(wszLoad);

        if (LoadStringW(_hinstShellStg, IDS_SERVERTO, wszLoad, sizeof(wszLoad)))
            _pwszTitleTo = DuplicateStringW(wszLoad);

        if (LoadStringW(_hinstShellStg, IDS_SERVERNEWFOLDER, wszLoad, sizeof(wszLoad)))
            _pwszTitleNewFolder = DuplicateStringW(wszLoad);

        _plistPIDL = new CGenericList();
        _pwszServer = DuplicateStringW(pwszServer);
        
        if (!_pwszTitleExamining || !_pwszTitleConnecting ||
            !_pwszTitleSending || !_pwszTitleTo ||
            !_pwszTitleNewFolder ||
            !_plistPIDL || !_pwszServer)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            if (fShowProgressDialog)
            {
                // set up the progress dialog    
                hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_IProgressDialog, (LPVOID*)&_ppd);
                // BUGBUG: catch all these return values
                hr = _ppd->SetAnimation(_hinstShellStg, IDA_FTPUPLOAD);
                if (SUCCEEDED(hr))
                {
                    _ppd->SetTitle(_pwszTitleExamining);
                    if (SUCCEEDED(hr))
                    {
                        hr = _ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL);if (SUCCEEDED(hr))
                        {
                            
                        }
                    }
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::AddIDListReference(LPVOID rgpidl[], 
                                                   DWORD cpidl,
                                                   BOOL fRecursive)
{
    HRESULT hr = S_OK;
    TRACE("CShellStorage::AddIDListReference");

    if (!rgpidl || cpidl <= 0)
        hr = E_INVALIDARG;
    else
    {
        for (DWORD i = 0; i < cpidl; i++)
        {
            if (!rgpidl[i])
            {
                hr = E_INVALIDARG;
                break;
            }
            else
            {
                // add the pidl
                DWORD cb = ((LPSHITEMID)rgpidl[i])->cb;
                LPITEMIDLIST pidl = ILClone((LPITEMIDLIST)rgpidl[i]);
                if (!pidl)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    WCHAR wszTag[2];
                    wszTag[0] = fRecursive ? 'R' : 'S';
                    wszTag[1] = '\0';
                    hr = _plistPIDL->Add(wszTag, pidl, cb);
                }
            }
        }
    }

    return hr;
}

///////////////////////////////////

STDMETHODIMP CShellStorageImpl::CreateStream(const WCHAR * UNREF_PARAM(pwcsName),  //Points to the name of the new stream
                                             DWORD UNREF_PARAM(grfMode),           //Access mode for the new stream
                                             DWORD UNREF_PARAM(reserved1),         //Reserved; must be zero
                                             DWORD UNREF_PARAM(reserved2),         //Reserved; must be zero
                                             IStream ** UNREF_PARAM(ppstm))        //Points to new stream object
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::OpenStream(const WCHAR * UNREF_PARAM(pwcsName), //Points to name of stream to open
                                         void * UNREF_PARAM(reserved1),         //Reserved; must be NULL
                                         DWORD UNREF_PARAM(grfMode),            //Access mode for the new stream
                                         DWORD UNREF_PARAM(reserved2),          //Reserved; must be zero
                                         IStream ** UNREF_PARAM(ppstm))         //Address of output variable
                                                                                // that receives the IStream interface pointer
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::CreateStorage(const WCHAR * UNREF_PARAM(pwcsName),  //Points to the name of the new storage object
                                            DWORD UNREF_PARAM(grfMode),           //Access mode for the new storage object
                                            DWORD UNREF_PARAM(reserved1),         //Reserved; must be zero
                                            DWORD UNREF_PARAM(reserved2),         //Reserved; must be zero
                                            IStorage ** UNREF_PARAM(ppstg))       //Points to new storage object
{
    return E_NOTIMPL; // not the first pass
}
    
/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::OpenStorage(const WCHAR * UNREF_PARAM(pwcsName),   //Points to the name of the
                                                                    // storage object to open
                                          IStorage * UNREF_PARAM(pstgPriority),  //Must be NULL.
                                          DWORD UNREF_PARAM(grfMode),            //Access mode for the new storage object
                                          SNB UNREF_PARAM(snbExclude),           //Must be NULL.
                                          DWORD UNREF_PARAM(reserved),           //Reserved; must be zero
                                          IStorage ** UNREF_PARAM(ppstg))        //Points to opened storage object
{
    return E_NOTIMPL; // not the first pass
}
        
/////////////////////////////////////
STDMETHODIMP CShellStorageImpl::_IncrementULargeInteger(ULARGE_INTEGER* a,                                                     
                                                        ULARGE_INTEGER* b)
{
    a->HighPart+=b->HighPart;

    DWORD dwNewLow = a->LowPart + b->LowPart;        
    if ((dwNewLow < a->LowPart) ||( dwNewLow < b->LowPart))
    {
        a->HighPart+=1; // rollover in low
    }

    a->LowPart = dwNewLow;

    return S_OK;
}

STDMETHODIMP CShellStorageImpl::_IncrementByteCount(LPITEMIDLIST pidl,                                                     
                                                    ULARGE_INTEGER* pcbTotal)
{
    HRESULT hr = S_OK;    

    
    LPCITEMIDLIST pidlRelative;
    IShellFolder* pshfParent = NULL;

    hr = SHBindToParent(pidl, IID_IShellFolder, (LPVOID*)&pshfParent, &pidlRelative);

    if (SUCCEEDED(hr))
    {
        WIN32_FIND_DATA wfdData;
        hr = SHGetDataFromIDList(pshfParent, pidlRelative, SHGDFIL_FINDDATA, &wfdData, sizeof(wfdData));
        if (SUCCEEDED(hr))
        {
            ULARGE_INTEGER ulwfdData;
            ulwfdData.HighPart = wfdData.nFileSizeHigh;
            ulwfdData.LowPart = wfdData.nFileSizeLow;

            hr = this->_IncrementULargeInteger(pcbTotal, &ulwfdData);
        }
    }

    return hr;
}

/////////////////////////////////////
STDMETHODIMP CShellStorageImpl::_ExaminePIDLListRecursive(LPITEMIDLIST pidl,
                                                          IShellFolder* pshfDesk,
                                                          UINT* pcbElts, 
                                                          ULARGE_INTEGER* pcbTotal)
{
    HRESULT hr = S_OK;
    SHFILEINFO sfi;
    TRACE("CShellStorage::_FlattenPIDLListRecursive");

    if (!SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), 
                       SHGFI_PIDL | SHGFI_ATTRIBUTES | SHGFI_DISPLAYNAME))
    {
        hr = E_FAIL;
    }
    else
    {
        *pcbElts = *pcbElts + 1;
        hr = this->_IncrementByteCount(pidl, pcbTotal);
        if (SUCCEEDED(hr))
        {
            if (_ppd)
            {
                WCHAR wszTempLine1[MAX_PATH];
                WCHAR wszTempLine2[MAX_PATH];
                swprintf(wszTempLine1, L"Found %d files", *pcbElts);
                if (pcbTotal->HighPart > 0)
                {
                    // BUGBUG: need to format lowpart correctly so it'll have the right width
                    swprintf(wszTempLine2, L"Total %d%d bytes", pcbTotal->HighPart, pcbTotal->LowPart);
                }
                else
                {
                    swprintf(wszTempLine2, L"Total %d bytes", pcbTotal->LowPart);
                }
                hr = this->_UpdateProgressDialog(NULL, NULL, NULL, wszTempLine1, wszTempLine2);
            }

            if (SUCCEEDED(hr) && hr != S_FALSE)
            {
                if ((sfi.dwAttributes & SFGAO_FILESYSTEM) && (sfi.dwAttributes & SFGAO_FOLDER))
                {
                    // if this is a folder, we need to enumerate its contents and add those too
                    IShellFolder* pshf = NULL;
                    LPENUMIDLIST penumIDList = NULL;
                    LPITEMIDLIST pidlRelative = NULL;
                    LPITEMIDLIST pidlAbsolute = NULL;
                    
                    hr = pshfDesk->BindToObject(pidl, NULL, IID_IShellFolder, (LPVOID*)&pshf);
                    if (SUCCEEDED(hr))
                    {
                        hr = pshf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penumIDList);
                        if (SUCCEEDED(hr))
                        {
                            BOOL fDone = FALSE;
                            while (!fDone)
                            {                        
                                DWORD cFetched;
                                hr = penumIDList->Next(1, &pidlRelative, &cFetched);
                                if (SUCCEEDED(hr))
                                {
                                    if (hr == S_FALSE || cFetched != 1)
                                    {
                                        hr = S_OK;
                                        fDone = TRUE;
                                    }
                                    else
                                    {
                                        pidlAbsolute = ILCombine((LPCITEMIDLIST)pidl, pidlRelative);
                                        if (!pidlAbsolute)
                                        {
                                            hr = E_FAIL;
                                        }
                                        else
                                        {
                                            hr = this->_ExaminePIDLListRecursive(pidlAbsolute,
                                                                                 pshfDesk,
                                                                                 pcbElts, 
                                                                                 pcbTotal);
                                        }
                                    }
                                }

                                if (FAILED(hr) || hr == S_FALSE)
                                {
                                    fDone=TRUE;
                                }
                            }
                        }
                        pshf->Release();
                    }
                }            
            }
        }
    }

    return hr;
}

/////////////////////////////////////
STDMETHODIMP CShellStorageImpl::_ExaminePIDLList(UINT* pcElts, 
                                                 ULARGE_INTEGER* pcbTotal)
{
    HRESULT hr = S_OK;
    UINT cEltsTopLevel;
    LPWSTR pwszTag;
    LPITEMIDLIST pidl;
    UINT cbPIDL;
    IShellFolder* pshfDesk = NULL;

    hr = _plistPIDL->Size(&cEltsTopLevel);
    if (SUCCEEDED(hr))
    {
        for (UINT i = 0; i < cEltsTopLevel; i++)
        {
            hr = _plistPIDL->GetTagByDex (i, &pwszTag);
            if (SUCCEEDED(hr))
            {
                hr = _plistPIDL->FindByDex(i, (LPVOID*)&pidl, &cbPIDL);
                if (SUCCEEDED(hr))
                {
                    if (*pwszTag == 'R')
                    {
                        // add to the new list recursively
                        if (!pshfDesk)
                        {
                            hr = SHGetDesktopFolder(&pshfDesk);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = _ExaminePIDLListRecursive(pidl, pshfDesk, pcElts, pcbTotal);
                        }
                    }
                    else
                    {
                        if (SUCCEEDED(hr))
                        {                    
                            // increment count of elements to copy
                            *pcElts = *pcElts + 1;
                            // if a file, get size and add to pcbTotal
                            hr = this->_IncrementByteCount(pidl, pcbTotal);
                            WCHAR wszTempLine1[MAX_PATH];
                            WCHAR wszTempLine2[MAX_PATH];
                            swprintf(wszTempLine1, L"Found %d files", *pcElts);
                            swprintf(wszTempLine2, L"Total %d%d bytes", pcbTotal->HighPart, pcbTotal->LowPart);
                            hr = this->_UpdateProgressDialog(NULL, NULL, NULL, wszTempLine1, wszTempLine2);
                        }
                    }
                }
            }
            if (FAILED(hr) || hr == S_FALSE)
            {
                break;
            }
        }
    }

    return hr;
}

/////////////////////////////////////

HRESULT CShellStorageImpl::_UpdateProgressDialog(ULARGE_INTEGER* pcbNewComplete,
                                                 ULARGE_INTEGER* pcbComplete,
                                                 ULARGE_INTEGER* pcbTotal,
                                                 LPWSTR pwszLine1,
                                                 LPWSTR pwszLine2)
{
    HRESULT hr = S_OK;
    static BOOL fSending = FALSE;

    assert(_ppd); // should not call if we aren't using the dialog

    // first, check if user has cancelled
    if (_ppd->HasUserCancelled())
    {
        hr = S_FALSE;
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = _ppd->SetLine(1, pwszLine1, TRUE, NULL);
            if (SUCCEEDED(hr))
            {
                hr = _ppd->SetLine(2, pwszLine2, TRUE, NULL);

                if (pcbNewComplete && pcbComplete && pcbTotal)
                {
                    if (SUCCEEDED(hr))
                    {
                    // -- update title if appropriate, "Connecting" --> "Sending"
                        if (!fSending)
                        {
                            hr = _ppd->SetTitle(_pwszTitleSending);
                            fSending = TRUE;
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = this->_IncrementULargeInteger(pcbComplete, pcbNewComplete);
                            if (SUCCEEDED(hr))
                            {
                                hr = _ppd->SetProgress64(pcbComplete->QuadPart, pcbTotal->QuadPart);
                            }
                        }
                    }            
                }
            }
        }
    }
        

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::_CopyPidlToStream(LPITEMIDLIST pidl,
                                                  IStream* pstream,
                                                  ULARGE_INTEGER* pcbComplete,
                                                  ULARGE_INTEGER* pcbTotal,
                                                  UINT cchRootPath)
{
    HRESULT hr = S_OK;
    WCHAR wszPath[MAX_PATH];
    WCHAR wszLine2[MAX_PATH];
    BOOL fLine2Init = FALSE;
    DWORD cbRead, cbWritten;    

    TRACE("CShellStorage::_CopyPidlToStream");
    if (!SHGetPathFromIDList(pidl, wszPath))
    {
        hr = E_FAIL;
    }
    else
    {
        HANDLE hFile = CreateFile(wszPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = E_FAIL;
        }
        else
        {
            do
            {
                BYTE lpv[4096];
                if (ReadFile(hFile, lpv, 4096, &cbRead, NULL))
                {
                    if (cbRead > 0)
                    {
                        hr = pstream->Write(lpv, cbRead, &cbWritten);
                        if (SUCCEEDED(hr))
                        {
                            if (cbRead != cbWritten)
                            {
                                hr = E_FAIL;
                            }
                            else
                            {
                                if (_ppd)
                                {
                                    // update progress dialog
                                    if (!fLine2Init)
                                    {
                                        lstrcpy(wszLine2, _pwszTitleTo);
                                        lstrcat(wszLine2, wszPath + cchRootPath);
                                        fLine2Init = TRUE;
                                    }
                                    ULARGE_INTEGER ulcbWritten;
                                    ulcbWritten.HighPart = 0;
                                    ulcbWritten.LowPart = cbWritten;
                                    hr = this->_UpdateProgressDialog(&ulcbWritten, pcbComplete, pcbTotal, wszPath, wszLine2);
                                }
                            }
                        }
                    }
                }
            }
            while (cbRead > 0 && SUCCEEDED(hr) && hr != S_FALSE);

            CloseHandle(hFile);
        }
    }

    return hr;

}

/////////////////////////////////////
STDMETHODIMP CShellStorageImpl::_CopyPidlContentsToStorage(LPITEMIDLIST pidl, 
                                                           IStorage* pstgDest,
                                                           ULARGE_INTEGER* pcbComplete,
                                                           ULARGE_INTEGER* pcbTotal,
                                                           BOOL fRecursive,
                                                           UINT cchRootPath)
{
    HRESULT hr = S_OK;
    TRACE("CShellStorage::_FlattenPIDLListRecursive");

    IShellFolder* pshfDesk = NULL; // BUGBUG, don't get this every time
    IShellFolder* pshf = NULL;
    LPENUMIDLIST penumIDList = NULL;
    LPITEMIDLIST pidlRelative = NULL;
    LPITEMIDLIST pidlAbsolute = NULL;
        
    SHGetDesktopFolder(&pshfDesk);
    hr = pshfDesk->BindToObject(pidl, NULL, IID_IShellFolder, (LPVOID*)&pshf);
    if (SUCCEEDED(hr))
    {
        hr = pshf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penumIDList);
        if (SUCCEEDED(hr))
        {
            BOOL fDone = FALSE;
            while (!fDone)
            {                        
                DWORD cFetched;
                hr = penumIDList->Next(1, &pidlRelative, &cFetched);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_FALSE || cFetched != 1)
                    {
                        hr = S_OK;
                        fDone = TRUE;
                    }
                    else
                    {
                        pidlAbsolute = ILCombine((LPCITEMIDLIST)pidl, pidlRelative);
                        if (!pidlAbsolute)
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            hr = this->_CopyPidlToStorage(pidlAbsolute, 
                                                          pstgDest,
                                                          pcbComplete,
                                                          pcbTotal,
                                                          fRecursive,
                                                          cchRootPath);
                        }
                    }
                }

                if (FAILED(hr) || hr == S_FALSE)
                {
                    fDone=TRUE;
                }
            }
        }
        pshf->Release();
    }

    pshfDesk->Release();
    return hr;
}

STDMETHODIMP CShellStorageImpl::_CopyPidlToStorage(LPITEMIDLIST pidl, 
                                                   IStorage* pstgDest,
                                                   ULARGE_INTEGER* pcbComplete,
                                                   ULARGE_INTEGER* pcbTotal,
                                                   BOOL fRecursive,
                                                   UINT cchRootPath)
{
    HRESULT hr = S_OK;
    SHFILEINFO sfi;
    IStorage* newStorage = NULL;
    IStream* newStream = NULL;

    TRACE("CShellStorage::_CopyPidlToStorage");
    
    if (!SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), 
                       SHGFI_PIDL | SHGFI_ATTRIBUTES | SHGFI_DISPLAYNAME))
    {
        hr = E_FAIL;
    }
    else
    {
        if (sfi.dwAttributes & SFGAO_FILESYSTEM) // we only support filesystem items for now
        {
            if (sfi.dwAttributes & SFGAO_FOLDER)
            {
                // folder
                hr = pstgDest->CreateStorage(sfi.szDisplayName, 0, 0, 0, &newStorage);
                if (FAILED(hr))
                { // if we can't create, try to open an existing storage there
                    hr = pstgDest->OpenStorage(sfi.szDisplayName, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &newStorage); 
                }
                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[MAX_PATH];
                    WCHAR wszPath[MAX_PATH];
                    if (!SHGetPathFromIDList(pidl, wszPath))
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        lstrcpy(wszTitle, _pwszTitleNewFolder);
                        lstrcat(wszTitle, wszPath + cchRootPath);
                        hr = this->_UpdateProgressDialog(NULL, NULL, NULL, wszTitle, L"");
                        if (SUCCEEDED(hr))
                        {
                            if (fRecursive)
                            {
                                hr = this->_CopyPidlContentsToStorage(pidl, newStorage, pcbComplete, pcbTotal, TRUE, cchRootPath);
                            }                        
                        }
                        newStorage->Release();
                    }
                }
            }
            else
            {
                // file
                hr = pstgDest->CreateStream(sfi.szDisplayName, STGM_TRANSACTED, 0, 0, &newStream);
                if (SUCCEEDED(hr))
                {
                    hr = _CopyPidlToStream(pidl, newStream, pcbComplete, pcbTotal, cchRootPath);
                    if (SUCCEEDED(hr) && hr != S_FALSE)
                    {
                        hr = newStream->Commit(0);
                    }

                    newStream->Release();
                }
            }
        }
    }

    return hr;
}

/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::CopyTo(DWORD UNREF_PARAM(ciidExclude),         //Number of elements in rgiidExclude
                                       IID const * UNREF_PARAM(rgiidExclude),  //Array of interface identifiers (IIDs)
                                       SNB UNREF_PARAM(snbExclude),            //Points to a block of stream
                                                                               // names in the storage object
                                       IStorage* pstgDest)       //Points to destination storage object
{
    // here's where all the magic happens
    // ISSUE: we don't support exclusion at the moment
    HRESULT hr;
    UINT cElts = 0;
    ULARGE_INTEGER cbTotal = {0}; // total size in bytes of all files to be transmitted                           
    ULARGE_INTEGER cbComplete = {0};

    TRACE("CShellStorage::CopyTo");
    
    // examine list of pidls (maybe recursive), and find total size and number of elements
    hr = this->_ExaminePIDLList(&cElts, &cbTotal);

    if (_ppd && hr == S_FALSE)
    {
        // we just cancelled, but that doesn't mean failure
        _ppd->StopProgressDialog();
        hr = S_OK;
    }
    else if (SUCCEEDED(hr))
    {
        if (_ppd)
        {
            _ppd->SetTitle(_pwszTitleConnecting);
            this->_UpdateProgressDialog(NULL, NULL, NULL, L"", L"");
        }

        UINT cEltsTopLevel;
        _plistPIDL->Size(&cEltsTopLevel); // BUGBUG: check ret val

        if (SUCCEEDED(hr))
        {
            for (UINT i = 0; i < cEltsTopLevel; i++)
            {
                LPITEMIDLIST pidl;
                UINT cbPIDL;
            
                hr = _plistPIDL->FindByDex(i, (LPVOID*)&pidl, &cbPIDL);
                if (SUCCEEDED(hr))
                {
                    LPWSTR pwszTag = NULL;
                    hr = _plistPIDL->GetTagByDex (i, &pwszTag);
                    if (SUCCEEDED(hr))
                    {
                        WCHAR wszPath[MAX_PATH];
                        if (!SHGetPathFromIDList(pidl, wszPath))
                        {
                            hr = E_FAIL;
                        }
                        else 
                        {
                            SHFILEINFO sfi;                            
                            if (!SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), 
                                                SHGFI_PIDL | SHGFI_DISPLAYNAME))
                            {
                                hr = E_FAIL;
                            }
                            else
                            {
                                UINT cchRootPath = lstrlen(wszPath) - lstrlen(sfi.szDisplayName);
                                if (*pwszTag == 'R')
                                    hr = this->_CopyPidlToStorage(pidl, pstgDest, &cbComplete, &cbTotal, TRUE, cchRootPath);
                                else
                                    hr = this->_CopyPidlToStorage(pidl, pstgDest, &cbComplete, &cbTotal, FALSE, cchRootPath);
                            }
                        }
                    }

                }
                if (FAILED(hr))
                {
                    break;
                }
            }
        
            if (_ppd)
            {
                hr = _ppd->StopProgressDialog();
            }
        }        
    }

    return hr;
}
        
/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::MoveElementTo(const WCHAR * UNREF_PARAM(pwcsName),  //Name of the element to be moved
                                            IStorage * UNREF_PARAM(pstgDest),     //Points to destination storage object
                                            const WCHAR* UNREF_PARAM(pwcsNewName),      //Points to new name of element in destination
                                            DWORD UNREF_PARAM(grfFlags))          //Specifies a copy or a move
{
    return E_NOTIMPL; // not the first pass
}
            
/////////////////////////////////////

// IStorage::EnumElements
STDMETHODIMP CShellStorageImpl::EnumElements(DWORD UNREF_PARAM(reserved1),        //Reserved; must be zero
                                           void * UNREF_PARAM(reserved2),       //Reserved; must be NULL
                                           DWORD UNREF_PARAM(reserved3),        //Reserved; must be zero
                                           IEnumSTATSTG ** UNREF_PARAM(ppenum)) //Address of output variable that
                                                                   // receives the IEnumSTATSTG interface pointer
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::DestroyElement(const WCHAR* UNREF_PARAM(pwcsName))  //Points to the name of the element to be removed
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////
        
STDMETHODIMP CShellStorageImpl::RenameElement(const WCHAR * UNREF_PARAM(pwcsOldName),  //Points to the name of the
                                                                        // element to be changed
                                            const WCHAR * UNREF_PARAM(pwcsNewName))  //Points to the new name for
                                                                        // the specified element
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////
        
STDMETHODIMP CShellStorageImpl::SetStateBits(DWORD UNREF_PARAM(grfStateBits),  //Specifies new values of bits
                                           DWORD UNREF_PARAM(grfMask))       //Specifies mask that indicates which
                                                                // bits are significant
{
    return E_NOTIMPL; // not the first pass
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CShellStorageImpl::Commit(DWORD UNREF_PARAM(grfCommitFlags))  //Specifies how changes are to be committed
{
    return E_NOTIMPL;  // first pass, we do everything synchronously to the server
}
    
/////////////////////////////////////

STDMETHODIMP CShellStorageImpl::Revert(void)
{
    return E_NOTIMPL;  // first pass, we do everything synchronously to the server
}
    
/////////////////////////////////////
        
STDMETHODIMP CShellStorageImpl::SetElementTimes(const WCHAR * UNREF_PARAM(pwcsName),   //Points to name of element to be changed
                                              FILETIME const * UNREF_PARAM(pctime),  //New creation time for element, or NULL
                                              FILETIME const * UNREF_PARAM(patime),  //New access time for element, or NULL
                                              FILETIME const * UNREF_PARAM(pmtime))  //New modification time for element, or NULL
{
    return E_NOTIMPL; // not the first time around
}

/////////////////////////////////////
        
STDMETHODIMP CShellStorageImpl::SetClass(REFCLSID UNREF_PARAM(clsid))  //Class identifier to be assigned to the storage object
{
    return E_NOTIMPL; // not the first pass
}

/////////////////////////////////////
        
STDMETHODIMP CShellStorageImpl::Stat(STATSTG* UNREF_PARAM(pstatstg),  //Location for STATSTG structure
                                   DWORD UNREF_PARAM(grfStatFlag))  //Values taken from the STATFLAG enumeration
{
    return E_NOTIMPL; // not the first pass
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\shellstg.h ===
#ifndef __SHELLSTG_H
#define __SHELLSTG_H

#include <objbase.h>
#include <shlobj.h>
#include <shellapi.h>
#include <shlobjp.h>

#include "unk.h"
#include "ishellstg.h"
#include "generlst.h"

class CShellStorageImpl : public CCOMBase, public IShellStorage
{
private:
    // internal utility functions

public:
    CShellStorageImpl ();
    ~CShellStorageImpl ();
    
    ///////////////////////////////////////////////////////////
    // IShellStorage
    STDMETHODIMP Init(HWND hwnd, LPWSTR pwszServer, BOOL fShowProgressDialog);
    
    STDMETHODIMP AddIDListReference(LPVOID rgpidl[], DWORD cpidl, BOOL fRecursive);

    ///////////////////////////////////////////////////////////
    // IStorage
    STDMETHODIMP CreateStream(
        const WCHAR * pwcsName,  //Points to the name of the new stream
        DWORD grfMode,           //Access mode for the new stream
        DWORD reserved1,         //Reserved; must be zerosh
        DWORD reserved2,         //Reserved; must be zero
        IStream ** ppstm);       //Points to new stream object

    STDMETHODIMP OpenStream(
        const WCHAR * pwcsName,   //Points to name of stream to open
        void * reserved1,         //Reserved; must be NULL
        DWORD grfMode,            //Access mode for the new stream
        DWORD reserved2,          //Reserved; must be zero
        IStream ** ppstm);        //Address of output variable
        // that receives the IStream interface pointer

    STDMETHODIMP CreateStorage(
        const WCHAR * pwcsName,  //Points to the name of the new storage object
        DWORD grfMode,           //Access mode for the new storage object
        DWORD reserved1,         //Reserved; must be zero
        DWORD reserved2,         //Reserved; must be zero
        IStorage ** ppstg);      //Points to new storage object
    
    STDMETHODIMP OpenStorage(
        const WCHAR * pwcsName,   //Points to the name of the
                                  // storage object to open
        IStorage * pstgPriority,  //Must be NULL.
        DWORD grfMode,            //Access mode for the new storage object
        SNB snbExclude,           //Must be NULL.
        DWORD reserved,           //Reserved; must be zero
        IStorage ** ppstg);       //Points to opened storage object
        
    STDMETHODIMP CopyTo(
        DWORD ciidExclude,         //Number of elements in rgiidExclude
        IID const * rgiidExclude,  //Array of interface identifiers (IIDs)
        SNB snbExclude,            //Points to a block of stream
        // names in the storage object
        IStorage * pstgDest);      //Points to destination storage object
        
    STDMETHODIMP MoveElementTo(
        const WCHAR * pwcsName,  //Name of the element to be moved
        IStorage * pstgDest,     //Points to destination storage object IStorage
        const WCHAR * pwcsNewName,      //Points to new name of element in destination
        DWORD grfFlags);         //Specifies a copy or a move
            
    STDMETHODIMP Commit(DWORD grfCommitFlags);  //Specifies how changes are to be committed
    
    STDMETHODIMP Revert(void);
    
    STDMETHODIMP EnumElements(
        DWORD reserved1,        //Reserved; must be zero
        void * reserved2,       //Reserved; must be NULL
        DWORD reserved3,        //Reserved; must be zero
        IEnumSTATSTG ** ppenum);//Address of output variable that
                                // receives the IEnumSTATSTG interface pointer

    STDMETHODIMP DestroyElement(const WCHAR* pwcsName);  //Points to the name of the element to be removed
        
    STDMETHODIMP RenameElement(
        const WCHAR * pwcsOldName,  //Points to the name of the
                                    // element to be changed
        const WCHAR * pwcsNewName); //Points to the new name for
                                    // the specified element
        
    STDMETHODIMP SetElementTimes(
        const WCHAR * pwcsName,   //Points to name of element to be changed
        FILETIME const * pctime,  //New creation time for element, or NULL
        FILETIME const * patime,  //New access time for element, or NULL
        FILETIME const * pmtime); //New modification time for element, or NULL
        
    STDMETHODIMP SetClass(REFCLSID clsid);  //Class identifier to be assigned to the storage object
        
    STDMETHODIMP SetStateBits(
        DWORD grfStateBits,  //Specifies new values of bits
        DWORD grfMask);      //Specifies mask that indicates which
                             // bits are significant
        
    STDMETHODIMP Stat(
        STATSTG * pstatstg,  //Location for STATSTG structure
        DWORD grfStatFlag);  //Values taken from the STATFLAG enumeration
        
private:
    // internal utility functions
    STDMETHODIMP _UpdateProgressDialog(ULARGE_INTEGER* pcbNewComplete,
                                       ULARGE_INTEGER* pcbComplete,
                                       ULARGE_INTEGER* pcbTotal,
                                       LPWSTR pwszLine1,
                                       LPWSTR pwszLine2);
                                                 
    STDMETHODIMP _CopyPidlToStream(LPITEMIDLIST pidl, 
                                   IStream* pstream,
                                   ULARGE_INTEGER* pcbComplete,
                                   ULARGE_INTEGER* pcbTotal,
                                   UINT cchRootPath);

    STDMETHODIMP _CopyPidlContentsToStorage(LPITEMIDLIST pidl, 
                                            IStorage* pstgDest,
                                            ULARGE_INTEGER* pcbComplete,
                                            ULARGE_INTEGER* pcbTotal,
                                            BOOL fRecursive,
                                            UINT cchRootPath);

    STDMETHODIMP _CopyPidlToStorage(LPITEMIDLIST pidl, 
                                    IStorage* pstgDest,
                                    ULARGE_INTEGER* pcbComplete,
                                    ULARGE_INTEGER* pcbTotal,
                                    BOOL fRecursive,
                                    UINT cchRootPath);

    STDMETHODIMP _IncrementULargeInteger(ULARGE_INTEGER* a,                                                     
                                         ULARGE_INTEGER* b);

    STDMETHODIMP _IncrementByteCount(LPITEMIDLIST pidl, 
                                     ULARGE_INTEGER* pcbTotal);

    STDMETHODIMP _ExaminePIDLListRecursive(LPITEMIDLIST pidl,
                                           IShellFolder* pshfDesk,
                                           UINT* pcbElts, 
                                           ULARGE_INTEGER* pcbTotal);

    STDMETHODIMP _ExaminePIDLList(UINT* pcbElts, 
                                  ULARGE_INTEGER* pcbTotal);


private:
    // member variables
    CGenericList*       _plistPIDL;
    HWND                _hwnd;
    LPWSTR              _pwszServer;
    HINSTANCE           _hinstShellStg;
    LPWSTR              _pwszTitleExamining;
    LPWSTR              _pwszTitleConnecting;
    LPWSTR              _pwszTitleSending;
    LPWSTR              _pwszTitleTo;
    LPWSTR              _pwszTitleNewFolder;
    IProgressDialog*    _ppd;
};

typedef CUnkTmpl<CShellStorageImpl> CShellStorage;

#endif // __SHELLSTG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\ifaces\ihttpstrm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Mon Feb 14 14:06:31 2000
 */
/* Compiler settings for ..\ihttpstrm.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ihttpstrm_h__
#define __ihttpstrm_h__

/* Forward Declarations */ 

#ifndef __IHttpStrm_FWD_DEFINED__
#define __IHttpStrm_FWD_DEFINED__
typedef interface IHttpStrm IHttpStrm;
#endif 	/* __IHttpStrm_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __HTTPSTRMAPI_LIBRARY_DEFINED__
#define __HTTPSTRMAPI_LIBRARY_DEFINED__

/* library HTTPSTRMAPI */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_HTTPSTRMAPI;

#ifndef __IHttpStrm_INTERFACE_DEFINED__
#define __IHttpStrm_INTERFACE_DEFINED__

/* interface IHttpStrm */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IHttpStrm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF4D9485-3285-405d-A023-E578B9C760CD")
    IHttpStrm : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            LPWSTR pwszPath,
            BOOL fDirect,
            BOOL fDeleteWhenDone,
            BOOL fCreate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuth( 
            LPWSTR pwszUserName,
            LPWSTR pwszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHttpStrmVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHttpStrm __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHttpStrm __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHttpStrm __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read )( 
            IHttpStrm __RPC_FAR * This,
            /* [length_is][size_is][out] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IHttpStrm __RPC_FAR * This,
            /* [size_is][in] */ const void __RPC_FAR *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek )( 
            IHttpStrm __RPC_FAR * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSize )( 
            IHttpStrm __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IHttpStrm __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
            /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IHttpStrm __RPC_FAR * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert )( 
            IHttpStrm __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockRegion )( 
            IHttpStrm __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockRegion )( 
            IHttpStrm __RPC_FAR * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stat )( 
            IHttpStrm __RPC_FAR * This,
            /* [out] */ STATSTG __RPC_FAR *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IHttpStrm __RPC_FAR * This,
            /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IHttpStrm __RPC_FAR * This,
            LPWSTR pwszPath,
            BOOL fDirect,
            BOOL fDeleteWhenDone,
            BOOL fCreate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAuth )( 
            IHttpStrm __RPC_FAR * This,
            LPWSTR pwszUserName,
            LPWSTR pwszPassword);
        
        END_INTERFACE
    } IHttpStrmVtbl;

    interface IHttpStrm
    {
        CONST_VTBL struct IHttpStrmVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHttpStrm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHttpStrm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHttpStrm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHttpStrm_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IHttpStrm_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define IHttpStrm_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IHttpStrm_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IHttpStrm_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IHttpStrm_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IHttpStrm_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IHttpStrm_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IHttpStrm_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IHttpStrm_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IHttpStrm_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define IHttpStrm_Open(This,pwszPath,fDirect,fDeleteWhenDone,fCreate)	\
    (This)->lpVtbl -> Open(This,pwszPath,fDirect,fDeleteWhenDone,fCreate)

#define IHttpStrm_SetAuth(This,pwszUserName,pwszPassword)	\
    (This)->lpVtbl -> SetAuth(This,pwszUserName,pwszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHttpStrm_Open_Proxy( 
    IHttpStrm __RPC_FAR * This,
    LPWSTR pwszPath,
    BOOL fDirect,
    BOOL fDeleteWhenDone,
    BOOL fCreate);


void __RPC_STUB IHttpStrm_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHttpStrm_SetAuth_Proxy( 
    IHttpStrm __RPC_FAR * This,
    LPWSTR pwszUserName,
    LPWSTR pwszPassword);


void __RPC_STUB IHttpStrm_SetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHttpStrm_INTERFACE_DEFINED__ */

#endif /* __HTTPSTRMAPI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\idl\makefile.inc ===
$(DAVTRANS_ROOT)\ifaces\ishellstg.h: ishellstg.h
    copy $** $@

$(DAVTRANS_ROOT)\shellstg\lib\ishellstg.tlb: ishellstg.tlb
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\clsidslib\makefile.inc ===
$(DAVTRANS_ROOT)\clsids\lib\shellstg_g.lib: $(O)\shellstg_g.lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\shellstgu.cpp ===
#include <objbase.h>
#include "shellstg.clsid.h"
#include "shellstg.h"

///////////////////////////////////////////////////////////////////////////////
// CUnkTmpl Interface Map initialization code
// Begin ->
const INTFMAPENTRY shellstgIME[] =
{
    _INTFMAPENTRY(CShellStorage, IShellStorage),
};

const INTFMAPENTRY* CShellStorage::_pintfmap = shellstgIME;
const DWORD CShellStorage::_cintfmap =
    (sizeof(shellstgIME)/sizeof(shellstgIME[0]));

// -> End
///////////////////////////////////////////////////////////////////////////////

DWORD CShellStorage::_cComponents = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\anp.cpp ===
#include "stdafx.h"
#include "netplace.h"
#include "pubwiz.h"
#pragma hdrstop


// add net place wizard (v2)

class CAddNetPlace : IWizardSite, IServiceProvider
{
public:
    CAddNetPlace();
    ~CAddNetPlace();
    void _ShowAddNetPlace();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    // dialog handlers
    static CAddNetPlace* s_GetANP(HWND hwnd, UINT uMsg, LPARAM lParam);

    static INT_PTR s_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CAddNetPlace *panp = s_GetANP(hwnd, uMsg, lParam); return panp->_WelcomeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CAddNetPlace *panp = s_GetANP(hwnd, uMsg, lParam); return panp->_DoneDlgProc(hwnd, uMsg, wParam, lParam); }

    INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND _hwndFrame;
    LONG _cRef;

    IPublishingWizard *_ppw;            // publishing wizard object
    IResourceMap *_prm;                 // our resource map object
    CNetworkPlace _np;
};


// Construction/destruction

CAddNetPlace::CAddNetPlace() :
    _cRef(1)
{
    DllAddRef();
}

CAddNetPlace::~CAddNetPlace()
{   
    DllRelease();
}


// Reference counting of the object

ULONG CAddNetPlace::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CAddNetPlace::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAddNetPlace::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CAddNetPlace, IWizardSite),      // IID_IWizardSite
        QITABENT(CAddNetPlace, IServiceProvider), // IID_IServiceProvider
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// Helper functions

CAddNetPlace* CAddNetPlace::s_GetANP(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CAddNetPlace*)ppsp->lParam;
    }
    return (CAddNetPlace*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


// Welcome/Intro dialog

INT_PTR CAddNetPlace::_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndFrame = GetParent(hwnd);
            SendDlgItemMessage(hwnd, IDC_PUB_WELCOME, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);

            IXMLDOMNode *pdn;
            HRESULT hr = _prm->SelectResourceScope(TEXT("dialog"), TEXT("welcome"), &pdn);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[1024];

                _prm->LoadString(pdn, TEXT("caption"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOME, szBuffer);

                _prm->LoadString(pdn, TEXT("description"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOMEPROMPT, szBuffer);

                pdn->Release();
            }
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    return TRUE;              

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ppw->GetFirstPage(&hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// Were done, so lets create the link etc.

INT_PTR CAddNetPlace::_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_PUB_DONE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);            
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case NM_CLICK:
                case NM_RETURN:
                    if (pnmh->idFrom == IDC_PUB_COMPLETEMSG)
                    {
                        _np.CreatePlace(hwnd, TRUE);
                        return TRUE;
                    }
                    break;

                case PSN_SETACTIVE:
                {
                    TCHAR szTemp[INTERNET_MAX_URL_LENGTH] = {0}; 
                    TCHAR szBuffer[MAX_PATH+INTERNET_MAX_URL_LENGTH];

                    // using the manifest lets work out where the net place was created to.
                    IXMLDOMDocument *pdocManifest;
                    HRESULT hr = _ppw->GetTransferManifest(NULL, &pdocManifest);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode *pdnUploadInfo;
                        if (S_OK == pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdnUploadInfo))
                        {
                            hr = GetURLFromElement(pdnUploadInfo, ELEMENT_TARGET, szTemp, ARRAYSIZE(szTemp));
                            if (SUCCEEDED(hr))
                            {
                                // set the target so that we create the place
                                _np.SetTarget(NULL, szTemp, NPTF_VALIDATE | NPTF_ALLOWWEBFOLDERS);

                                IXMLDOMNode *pdnTarget;
                                hr = pdocManifest->selectSingleNode(XPATH_UPLOADTARGET, &pdnTarget);
                                if (hr == S_OK)
                                {
                                    // get the user name (for the FTP case)

                                    if (SUCCEEDED(GetStrFromAttribute(pdnTarget, ATTRIBUTE_USERNAME, szBuffer, ARRAYSIZE(szBuffer))))
                                        _np.SetLoginInfo(szBuffer, NULL);                        

                                    // lets get the prefered display name, if this is not found then we will default to
                                    // using the name generated by the net places code.

                                    if (SUCCEEDED(GetStrFromAttribute(pdnUploadInfo, ATTRIBUTE_FRIENDLYNAME, szTemp, ARRAYSIZE(szTemp))))
                                        _np.SetName(NULL, szTemp);

                                    pdnTarget->Release();
                                }
                            }
                            pdnUploadInfo->Release();
                        }

                        pdocManifest->Release();
                    }

                    // lets format up the text for the control.
                    FormatMessageString(IDS_ANP_SUCCESS, szBuffer, ARRAYSIZE(szBuffer), szTemp);
                    SetDlgItemText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);                                
                
                    // lets move the controls accordingly
                    UINT ctls[] = { IDC_PUB_OPENFILES };
                    int dy = SizeControlFromText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);
                    MoveControls(hwnd, ctls, ARRAYSIZE(ctls), 0, dy);
                    
                    // default to opening the place when the user closes this wizard.
                    CheckDlgButton(hwnd, IDC_PUB_OPENFILES, TRUE);
                
                    // were done.
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    _np.CreatePlace(hwnd, (IsDlgButtonChecked(hwnd, IDC_PUB_OPENFILES) == BST_CHECKED));
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)FALSE);
                    return TRUE;
                }
            }
            break;
        }
    }
    
    return FALSE;
}


// IServiceProvider 

STDMETHODIMP CAddNetPlace::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_ResourceMap)
        return _prm->QueryInterface(riid, ppv);

    *ppv = NULL;
    return E_FAIL;
}


// Site object helpers, these allow nagivation back and forward in the wizard

HRESULT CAddNetPlace::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(_hwndFrame, IDD_PUB_WELCOME);
    *phPage = PropSheet_IndexToPage(_hwndFrame, i);
    return S_OK;
}

HRESULT CAddNetPlace::GetNextPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(_hwndFrame, IDD_ANP_DONE);
    *phPage = PropSheet_IndexToPage(_hwndFrame, i);
    return S_OK;
}


// main entry point which shows the wizard

void CAddNetPlace::_ShowAddNetPlace()
{
    struct
    {
        INT idPage;
        INT idHeading;
        INT idSubHeading;
        DWORD dwFlags;
        DLGPROC dlgproc;
    }
    c_wpPages[] =
    {
        {IDD_PUB_WELCOME, 0, 0, PSP_HIDEHEADER, CAddNetPlace::s_WelcomeDlgProc},
        {IDD_ANP_DONE, 0, 0, PSP_HIDEHEADER, CAddNetPlace::s_DoneDlgProc},
    };

    // create the page array, we add the welcome page and the finished page
    // the rest is loaded as an extension to the wizard.

    HPROPSHEETPAGE hpages[10] = { 0 };
    for (int i = 0; i < ARRAYSIZE(c_wpPages) ; i++ )
    {                           
        PROPSHEETPAGE psp = { 0 };
        psp.dwSize = SIZEOF(PROPSHEETPAGE);
        psp.hInstance = g_hinst;
        psp.lParam = (LPARAM)this;
        psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | c_wpPages[i].dwFlags;
        psp.pszTemplate = MAKEINTRESOURCE(c_wpPages[i].idPage);
        psp.pfnDlgProc = c_wpPages[i].dlgproc;
        psp.pszTitle = MAKEINTRESOURCE(IDS_ANP_CAPTION);
        psp.pszHeaderTitle = MAKEINTRESOURCE(c_wpPages[i].idHeading);
        psp.pszHeaderSubTitle = MAKEINTRESOURCE(c_wpPages[i].idSubHeading);
        hpages[i] = CreatePropertySheetPage(&psp);
    }

    // create the wizard extension (for publishing) and have it append its
    // pages, if that succeeds then lets show the wizard.

    HRESULT hr = CResourceMap_Initialize(L"res://netplwiz.dll/xml/resourcemap.xml", &_prm);
    if (SUCCEEDED(hr))
    {
        hr = _prm->LoadResourceMap(TEXT("wizard"), TEXT("AddNetPlace"));
        if (SUCCEEDED(hr))
        {
            hr = CoCreateInstance(CLSID_PublishingWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPublishingWizard, &_ppw));
            if (SUCCEEDED(hr))
            {
                hr = _ppw->Initialize(NULL, SHPWHF_NOFILESELECTOR|SHPWHF_VALIDATEVIAWEBFOLDERS, TEXT("AddNetPlace"));          
                if (SUCCEEDED(hr))
                {
                    IUnknown_SetSite(_ppw, SAFECAST(this, IWizardSite*));           // we are the site
    
                    UINT nPages;
                    hr = _ppw->AddPages(&hpages[i], ARRAYSIZE(hpages)-i, &nPages);
                    if (SUCCEEDED(hr))
                    {
                        PROPSHEETHEADER psh = { 0 };
                        psh.dwSize = SIZEOF(PROPSHEETHEADER);
                        psh.hInstance = g_hinst;
                        psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
                        psh.pszbmHeader = MAKEINTRESOURCE(IDB_ANP_BANNER);
                        psh.pszbmWatermark = MAKEINTRESOURCE(IDB_ANP_WATERMARK);
                        psh.phpage = hpages;
                        psh.nPages = i+nPages;
                        PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_ADDNETPLACE));
                    }

                    IUnknown_SetSite(_ppw, NULL); 
                }
                _ppw->Release();
            }
        }
        _prm->Release();
    }
}


// RunDll entry point used by the world to access the Add Net Place wizard.

void APIENTRY AddNetPlaceRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        CAddNetPlace *panp = new CAddNetPlace;
        if (panp)
        {
            panp->_ShowAddNetPlace();
            panp->Release();
        }
        CoUninitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\data.cpp ===
#include "stdafx.h"
#include "resource.h"
#pragma hdrstop


// group list management

CGroupInfoList::CGroupInfoList()
{
}

CGroupInfoList::~CGroupInfoList()
{
    if (HDPA())
        DestroyCallback(DestroyGroupInfoCallback, NULL);
}

int CGroupInfoList::DestroyGroupInfoCallback(CGroupInfo* pGroupInfo, LPVOID pData)
{
    delete pGroupInfo;
    return 1;
}

HRESULT CGroupInfoList::Initialize()
{
    USES_CONVERSION;    
    HRESULT hr = S_OK;
    
    NET_API_STATUS status;
    DWORD_PTR dwResumeHandle = 0;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;

    if (HDPA())
        DestroyCallback(DestroyGroupInfoCallback, NULL);

    // Create new list initially with 8 items
    if (Create(8))
    {
        // Now begin enumerating local groups
        LOCALGROUP_INFO_1* prgGroupInfo;

        // Read each local group
        BOOL fBreakLoop = FALSE;
        while (!fBreakLoop)
        {
            status = NetLocalGroupEnum(NULL, 1, (BYTE**) &prgGroupInfo, 
                8192, &dwEntriesRead, &dwTotalEntries, 
                &dwResumeHandle);

            if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
            {
                // We got some local groups - add information for all users in these local
                // groups to our list
                DWORD iGroup;
                for (iGroup = 0; iGroup < dwEntriesRead; iGroup ++)
                {

                    AddGroupToList(W2T(prgGroupInfo[iGroup].lgrpi1_name), 
                        W2T(prgGroupInfo[iGroup].lgrpi1_comment));
                }

                NetApiBufferFree((BYTE*) prgGroupInfo);
            
                // Maybe we don't have to try NetLocalGroupEnum again (if we got all the groups)
                fBreakLoop = (dwEntriesRead == dwTotalEntries);
            }
            else
            {
                // Check for access denied

                fBreakLoop = TRUE;
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CGroupInfoList::AddGroupToList(LPCTSTR szGroup, LPCTSTR szComment)
{
    CGroupInfo* pGroupInfo = new CGroupInfo();
    if (!pGroupInfo)
        return E_OUTOFMEMORY;

    lstrcpyn(pGroupInfo->m_szGroup, szGroup, ARRAYSIZE(pGroupInfo->m_szGroup));
    lstrcpyn(pGroupInfo->m_szComment, szComment, ARRAYSIZE(pGroupInfo->m_szComment));
    AppendPtr(pGroupInfo);
    return S_OK;
}


// user data manager

CUserManagerData::CUserManagerData(LPCTSTR pszCurrentDomainUser)
{
    m_szHelpfilePath[0] = TEXT('\0');

    // Initialize everything except for the user loader thread
    // and the group list here; the rest is done in
    // ::Initialize.
    
    // Fill in the computer name
    DWORD cchComputername = ARRAYSIZE(m_szComputername);
    ::GetComputerName(m_szComputername, &cchComputername);
 
    // Detect if 'puter is in a domain
    SetComputerDomainFlag();

    // Get the current user information
    DWORD cchUsername = ARRAYSIZE(m_LoggedOnUser.m_szUsername);
    DWORD cchDomain = ARRAYSIZE(m_LoggedOnUser.m_szDomain);
    GetCurrentUserAndDomainName(m_LoggedOnUser.m_szUsername, &cchUsername,
        m_LoggedOnUser.m_szDomain, &cchDomain);

    // Get the extra data for this user
    m_LoggedOnUser.GetExtraUserInfo();

    // We'll set logoff required only if the current user has been updated
    m_pszCurrentDomainUser = (LPTSTR) pszCurrentDomainUser;
    m_fLogoffRequired = FALSE;
}

CUserManagerData::~CUserManagerData()
{
}

HRESULT CUserManagerData::Initialize(HWND hwndUserListPage)
{
    CWaitCursor cur;
    m_GroupList.Initialize();
    m_UserListLoader.Initialize(hwndUserListPage);
    return S_OK;
}


// Registry access constants for auto admin logon
static const TCHAR szWinlogonSubkey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
static const TCHAR szAutologonValueName[] = TEXT("AutoAdminLogon");
static const TCHAR szDefaultUserNameValueName[] = TEXT("DefaultUserName");
static const TCHAR szDefaultDomainValueName[] = TEXT("DefaultDomainName");
static const TCHAR szDefaultPasswordValueName[] = TEXT("DefaultPassword");

BOOL CUserManagerData::IsAutologonEnabled()
{
    BOOL fAutologon = FALSE;

    // Read the registry to see if autologon is enabled
    HKEY hkey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szWinlogonSubkey, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szResult[2];
        DWORD dwType;
        DWORD cbSize = sizeof(szResult);
        if (RegQueryValueEx(hkey, szAutologonValueName, 0, &dwType, (BYTE*) szResult, &cbSize) == ERROR_SUCCESS)
        {
            long lResult = StrToLong(szResult);
            fAutologon = (lResult != 0);
        }
        RegCloseKey(hkey);
    }

    return (fAutologon);
}

#define STRINGBYTESIZE(x) ((lstrlen((x)) + 1) * sizeof(TCHAR))

void CUserManagerData::SetComputerDomainFlag()
{
    m_fInDomain = ::IsComputerInDomain();
}

TCHAR* CUserManagerData::GetHelpfilePath()
{
    static const TCHAR szHelpfileUnexpanded[] = TEXT("%systemroot%\\system32\\users.hlp");
    if (m_szHelpfilePath[0] == TEXT('\0'))
    {
        ExpandEnvironmentStrings(szHelpfileUnexpanded, m_szHelpfilePath, 
            ARRAYSIZE(m_szHelpfilePath));
    }
    return (m_szHelpfilePath);
}

void CUserManagerData::UserInfoChanged(LPCTSTR pszUser, LPCTSTR pszDomain)
{
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2]; szDomainUser[0] = 0;

    MakeDomainUserString(pszDomain, pszUser, szDomainUser, ARRAYSIZE(szDomainUser));

    if (StrCmpI(szDomainUser, m_pszCurrentDomainUser) == 0)
    {
        m_fLogoffRequired = TRUE;
    }
}

BOOL CUserManagerData::LogoffRequired()
{
    return (m_fLogoffRequired);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\neptune\aidanl\davtrans\shellstg\tstdrv\tstdrv.cpp ===
// --------------------------------------------------------------------------------
// tstdrv.cpp
// --------------------------------------------------------------------------------
#include <objbase.h>
#include <stdio.h>
#include <shlobj.h>

#include "shellstg.clsid.h"
#include "ishellstg.h"

#include "davinet.clsid.h"
#include "idavinet.h"

#include "davstore.clsid.h"
#include "idavstore.h"

#include "strutil.h"

// --------------------------------------------------------------------------------
// main
// --------------------------------------------------------------------------------
void __cdecl main(INT argc, CHAR * argv[])
{
    // locals
    HRESULT        hr;   
    IDavTransport* pDavTransport = NULL;
    IShellStorage* pShellStg = NULL;
    IDavStorage*   pStorage = NULL;
    IShellFolder*  pshfDesk = NULL;
    LPITEMIDLIST   pidl = NULL;
    LPWSTR         pwsz = NULL;


    CoInitialize(NULL);
    hr = ::CoCreateInstance(CLSID_CShellStorage, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IShellStorage, 
                              (LPVOID*)&pShellStg);
    
    if (SUCCEEDED(hr))
    {
        hr = pShellStg->Init(NULL, L"http://aidanl:8088/dav/aidanl/", TRUE);
        if (SUCCEEDED(hr))
        {        
            hr = SHGetDesktopFolder(&pshfDesk);
            if (SUCCEEDED(hr))
            {
                for (INT i = 1; i < argc; i++)
                {
                    pwsz = ConvertToUnicode(CP_ACP, argv[i]);
                    if (!pwsz)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = pshfDesk->ParseDisplayName(NULL, NULL, pwsz, NULL, &pidl, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = pShellStg->AddIDListReference((LPVOID*)&pidl, 1, TRUE);
                        }

                        free(pwsz);

                        if (FAILED(hr))
                        {
                            break;
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = ::CoCreateInstance(CLSID_CDavStorage, 
                                            NULL, 
                                            CLSCTX_INPROC_SERVER, 
                                            IID_IDavStorage, 
                                            (LPVOID*)&pStorage);    
                    if (SUCCEEDED(hr))
                    {
                        hr = ::CoCreateInstance(CLSID_DAVInet, 
                                                NULL, 
                                                CLSCTX_INPROC_SERVER, 
                                                IID_IDavTransport, 
                                                (LPVOID*)&pDavTransport);
                        if (SUCCEEDED(hr))
                        {
                            hr = pDavTransport->SetAuthentication(L"aidan", L"grendel");
            
                            if (SUCCEEDED(hr))
                            {
                                hr = pStorage->Init(L"http://aidanl:8088/dav/aidanl/", pDavTransport);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pShellStg->CopyTo(0, NULL, 0, pStorage);
                                }
                            }
                        }

                        pDavTransport->Release();
                    }
                    pStorage->Release();
                }
            }
        }

        pShellStg->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\dialog.cpp ===
#include "stdafx.h"
#pragma hdrstop

INT_PTR CPropertyPage::StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CPropertyPage* pthis = (CPropertyPage*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    PROPSHEETPAGE* ppage;
    INT_PTR fProcessed;

    if (uMsg == WM_INITDIALOG)
    {
        ppage = (PROPSHEETPAGE*) lParam;
        pthis = (CPropertyPage*) ppage->lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
    }

    if (pthis != NULL)
    {
        fProcessed = pthis->DialogProc(hwndDlg, uMsg, wParam, lParam);
    }
    else
    {
        fProcessed = FALSE;
    }

    return fProcessed;
}

INT_PTR CDialog::StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDialog* pthis = (CDialog*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    INT_PTR fProcessed;

    if (uMsg == WM_INITDIALOG)
    {
        pthis = (CDialog*) lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pthis); 
    }

    if (pthis != NULL)
    {
        fProcessed = pthis->DialogProc(hwndDlg, uMsg, wParam, lParam);
    }
    else
    {
        fProcessed = FALSE;
    }

    return fProcessed;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\dialog.h ===
#ifndef DIALOG_H_INCLUDED
#define DIALOG_H_INCLUDED

class CDialogBase
{
protected:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;

public:
    virtual ~CDialogBase() {}
};

class CPropertyPage: public CDialogBase
{
public:
    void SetPropSheetPageMembers(PROPSHEETPAGE* ppsp)
    {
        ppsp->lParam = (LPARAM) this;
        ppsp->pfnDlgProc = CPropertyPage::StaticProc;
    }

private:
    static INT_PTR StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

class CDialog: public CDialogBase
{
public:
    INT_PTR DoModal(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent)
    {return DialogBoxParam(hInstance, lpTemplate, hWndParent, CDialog::StaticProc, (LPARAM) this);}

private:
    static INT_PTR StaticProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif //!DIALOG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\data.h ===
#ifndef DATA_H
#define DATA_H


// group info object, this holds the information about a group - name, comment etc

class CGroupInfo
{
public:
    CGroupInfo()
    {
        m_szGroup[0] = m_szComment[0] = TEXT('\0');
    }

    TCHAR m_szGroup[MAX_GROUP + 1];
    TCHAR m_szComment[MAXCOMMENTSZ];
};


// object for managing a list of groups

class CGroupInfoList: public CDPA<CGroupInfo>
{
public:
    CGroupInfoList();
    ~CGroupInfoList();

    HRESULT Initialize();

private:
    static int CALLBACK DestroyGroupInfoCallback(CGroupInfo* pGroupInfo, LPVOID pData);
    HRESULT AddGroupToList(LPCTSTR szGroup, LPCTSTR szComment);
};


// user data manager

class CUserManagerData
{
public:
    // Functions
    CUserManagerData(LPCTSTR pszCurrentDomainUser);
    ~CUserManagerData();

    HRESULT Initialize(HWND hwndUserListPage);

    BOOL IsComputerInDomain()           
        {return m_fInDomain;}
    CUserListLoader* GetUserListLoader()
        {return &m_UserListLoader;}   
    CGroupInfoList* GetGroupList()
        {return &m_GroupList;}
    CUserInfo* GetLoggedOnUserInfo()
        {return &m_LoggedOnUser;}
    TCHAR* GetComputerName()        
        {return m_szComputername;}
    
    BOOL IsAutologonEnabled();
    TCHAR* GetHelpfilePath();

    void UserInfoChanged(LPCTSTR pszUser, LPCTSTR pszDomain);
    BOOL LogoffRequired();

private:
    // Functions
    void SetComputerDomainFlag();

private:
    // Data
    // List of users read from the local security DB
    CUserInfo m_LoggedOnUser;
    CUserListLoader m_UserListLoader;
    CGroupInfoList m_GroupList;
    BOOL m_fInDomain;
    TCHAR m_szComputername[MAX_COMPUTERNAME + 1];
    TCHAR m_szHelpfilePath[MAX_PATH + 1];

    LPTSTR m_pszCurrentDomainUser;
    BOOL m_fLogoffRequired;
};

#endif //! DATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\disconndlg.cpp ===
#include "stdafx.h"

// Disconnect drive dialog
// History:
//  dsheldon    11/09/2000  created

class CDisconnectDrives : public CDialog
{
private:
    void _InitializeDriveListview(HWND hwnd);
    BOOL _DriveAlreadyInList(HWND hwndList, NETRESOURCE* pnr);
    UINT _FillDriveList(HWND hwnd, DWORD dwScope);
    void _DoDisconnect(HWND hwnd);
    void _EnableButtons(HWND hwnd);
    INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Data
};

INT_PTR CDisconnectDrives::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fReturn = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szCaption[256];
            LoadString(g_hinst, IDS_DISCONNECT_CAPTION, szCaption, ARRAYSIZE(szCaption));
            SetWindowText(hwndDlg, szCaption);
            
            HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_PSW));
            SendMessage(hwndDlg, WM_SETICON, (WPARAM) ICON_BIG, (LPARAM) hIcon);
            SendMessage(hwndDlg, WM_SETICON, (WPARAM) ICON_SMALL, (LPARAM) hIcon);
            _InitializeDriveListview(hwndDlg);
            if (_FillDriveList(hwndDlg, RESOURCE_CONNECTED) + _FillDriveList(hwndDlg, RESOURCE_REMEMBERED) == 0)
            {
                DisplayFormatMessage(hwndDlg, IDS_DISCONNECTDRIVETITLE, IDS_NONETDRIVES, MB_ICONINFORMATION | MB_OK);
                EndDialog(hwndDlg, IDCANCEL);
            }
            _EnableButtons(hwndDlg);

            fReturn = TRUE;
        }
        break;
    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDOK:
                _DoDisconnect(hwndDlg);
                // Fall through
            case IDCANCEL:
                EndDialog(hwndDlg, LOWORD(wParam));
                fReturn = TRUE;
                break;
            }
        }
        break;
    case WM_NOTIFY:
        switch ((int) wParam)
        {
        case IDC_DRIVELIST:
            if (((LPNMHDR) lParam)->code == LVN_ITEMCHANGED)
            {
                _EnableButtons(hwndDlg);
            }
            break;
        }
        break;
    }

    return fReturn;
}

#define COL_LOCALNAME  0
#define COL_REMOTENAME 1
#define COL_COMMENT    2

const UINT c_auTileColumns[] = {COL_LOCALNAME, COL_REMOTENAME, COL_COMMENT};
const UINT c_auTileSubItems[] = {COL_REMOTENAME, COL_COMMENT};

void CDisconnectDrives::_InitializeDriveListview(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_DRIVELIST);
    ListView_SetView(hwndList, LV_VIEW_TILE);

    for (int i=0; i<ARRAYSIZE(c_auTileColumns); i++)
    {
        LV_COLUMN col;
        col.mask = LVCF_SUBITEM;
        col.iSubItem = c_auTileColumns[i];
        ListView_InsertColumn(hwndList, i, &col);
    }

    RECT rc;
    GetClientRect(hwndList, &rc);

    LVTILEVIEWINFO lvtvi;
    lvtvi.cbSize = sizeof(LVTILEVIEWINFO);
    lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
    lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
    // Bug 298835 - Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
    lvtvi.sizeTile.cx = ((rc.right-rc.left) - GetSystemMetrics(SM_CXVSCROLL))/2;
    lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
    ListView_SetTileViewInfo(hwndList, &lvtvi);

    HIMAGELIST himlLarge, himlSmall;
    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);
}

BOOL CDisconnectDrives::_DriveAlreadyInList(HWND hwndList, NETRESOURCE* pnr)
{
    BOOL fAlreadyInList = FALSE;
    if (pnr->lpLocalName)
    {
        int cItems = ListView_GetItemCount(hwndList);
        if (-1 != cItems)
        {
            int i = 0;
            while ((i < cItems) && !fAlreadyInList)
            {
                WCHAR szItem[MAX_PATH]; *szItem = 0;
                ListView_GetItemText(hwndList, i, 0, szItem, ARRAYSIZE(szItem));
                if (0 == StrCmpI(szItem, pnr->lpLocalName))
                {
                    fAlreadyInList = TRUE;
                }

                i++;
            }
        }
    }

    return fAlreadyInList;
}

UINT CDisconnectDrives::_FillDriveList(HWND hwnd, DWORD dwScope)
{
    UINT nAdded = 0;
    HWND hwndList = GetDlgItem(hwnd, IDC_DRIVELIST);

    HANDLE hEnum = NULL;
    DWORD dwRes = WNetOpenEnum(dwScope, RESOURCETYPE_DISK, 0, NULL, &hEnum);
    if (NO_ERROR == dwRes)
    {
        do
        {
            BYTE rgBuffer[16 * 1024];
            DWORD cbSize = sizeof (rgBuffer);
            DWORD cEntries = -1;
            dwRes = WNetEnumResource(hEnum, &cEntries, (void*) rgBuffer, &cbSize);

            if ((ERROR_MORE_DATA == dwRes) ||
                (NO_ERROR == dwRes))
            {
                NETRESOURCE* pnrResults = (NETRESOURCE*) rgBuffer;

                for (DWORD iEntry = 0; iEntry < cEntries; iEntry ++)
                {
                    WCHAR szNone[MAX_PATH + 1];
                    NETRESOURCE* pnr = pnrResults + iEntry;

                    if (!_DriveAlreadyInList(hwndList, pnr))
                    {
                        nAdded ++;

                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                        if (pnr->lpLocalName)
                        {
                            lvi.pszText = pnr->lpLocalName;
                            lvi.lParam = TRUE; // Flag that says, "this connection has a local name (device letter)"
                        }
                        else
                        {
                            LoadString(g_hinst, IDS_NONE, szNone, ARRAYSIZE(szNone));
                            lvi.pszText = szNone;
                        }

                        lvi.iImage =  Shell_GetCachedImageIndex(L"shell32.dll", II_DRIVENET, 0x0);

                        int iItem = ListView_InsertItem(hwndList, &lvi);
                        if (iItem != -1)
                        {
                            LVTILEINFO lvti;
                            lvti.cbSize = sizeof(LVTILEINFO);
                            lvti.iItem = iItem;
                            lvti.cColumns = ARRAYSIZE(c_auTileSubItems);
                            lvti.puColumns = (UINT*)c_auTileSubItems;
                            ListView_SetTileInfo(hwndList, &lvti);

                            ListView_SetItemText(hwndList, iItem, 1, pnr->lpRemoteName);
                            ListView_SetItemText(hwndList, iItem, 2, pnr->lpComment);
                        }
                    }
                }
            }
        } while (ERROR_MORE_DATA == dwRes);

        WNetCloseEnum(hEnum);
    }

    return nAdded;
}

void CDisconnectDrives::_DoDisconnect(HWND hwnd)
{
    SetCursor(LoadCursor(NULL, IDC_WAIT));

    HWND hwndList = GetDlgItem(hwnd, IDC_DRIVELIST);
    int iSelectedItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    while (-1 != iSelectedItem)
    {
        WCHAR szRemoteName[MAX_PATH + 1];
        ListView_GetItemText(hwndList, iSelectedItem, COL_REMOTENAME, szRemoteName, ARRAYSIZE(szRemoteName));
        WCHAR szLocalName[MAX_PATH + 1];
        ListView_GetItemText(hwndList, iSelectedItem, COL_LOCALNAME, szLocalName, ARRAYSIZE(szLocalName));

        LVITEM lvi = {0};
        lvi.iItem = iSelectedItem;
        lvi.mask = LVIF_PARAM;
        ListView_GetItem(hwndList, &lvi);
        
        BOOL fHasDevice = (BOOL) lvi.lParam;

        // Try non-forcing disconnect
        DWORD dwRes = WNetCancelConnection2(fHasDevice ? szLocalName : szRemoteName, CONNECT_UPDATE_PROFILE, FALSE);

        if ((ERROR_OPEN_FILES == dwRes) ||
            (ERROR_DEVICE_IN_USE == dwRes))
        {
            if (IDYES == DisplayFormatMessage(hwnd, IDS_DISCONNECTDRIVETITLE, fHasDevice ? IDS_DISCONNECT_CONFIRM : IDS_DISCONNECT_CONFIRM_NODEV, MB_ICONWARNING | MB_YESNO, szLocalName, szRemoteName))
            {
                dwRes = WNetCancelConnection2(fHasDevice ? szLocalName : szRemoteName, CONNECT_UPDATE_PROFILE, TRUE);
            }
            else
            {
                dwRes = NO_ERROR;
            }
        }

        if (NO_ERROR != dwRes)
        {
            WCHAR szMessage[512];
            if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) dwRes, 0, szMessage, ARRAYSIZE(szMessage), NULL))
            {
                DisplayFormatMessage(hwnd, IDS_DISCONNECTDRIVETITLE, IDS_DISCONNECTERROR, MB_ICONERROR | MB_OK, szLocalName, szRemoteName, szMessage);
            }
        }

        iSelectedItem = ListView_GetNextItem(hwndList, iSelectedItem, LVNI_SELECTED);
    }
}

void CDisconnectDrives::_EnableButtons(HWND hwnd)
{
    UINT nSelected = ListView_GetSelectedCount(GetDlgItem(hwnd, IDC_DRIVELIST));
    EnableWindow(GetDlgItem(hwnd, IDOK), (nSelected > 0));
}

STDAPI_(DWORD) SHDisconnectNetDrives(HWND hwndParent)
{
    TCHAR szCaption[256];
    LoadString(g_hinst, IDS_DISCONNECT_CAPTION, szCaption, ARRAYSIZE(szCaption));
    CEnsureSingleInstance ESI(szCaption);

    if (!ESI.ShouldExit())
    {
        CDisconnectDrives disc;
        disc.DoModal(g_hinst, MAKEINTRESOURCE(IDD_DISCONNECTDRIVES), NULL);
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\dll.cpp ===
#include "stdafx.h"
#include "advpub.h"         // For REGINSTALL
#pragma hdrstop

#define DECL_CRTFREE
#include <crtfree.h>


// Fix the debug builds
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "netplwiz"
#define SZ_MODULE           "NETPLWIZ"

#define DECLARE_DEBUG
#include "debug.h"


// shell/lib files look for this instance variable
EXTERN_C HINSTANCE g_hinst = 0;
LONG g_cLocks = 0;
BOOL g_bMirroredOS = FALSE;


// DLL lifetime stuff

STDAPI_(BOOL) DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hinstDLL;
        g_hinst = hinstDLL;                         // For shell/lib files who extern him
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        SHFusionInitializeFromModule(hinstDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        CleanUpIntroFont();
        SHFusionUninitialize();
    }
    
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;                        
}

STDAPI DllCanUnloadNow()
{
    return (g_cLocks == 0) ? S_OK:S_FALSE;
}
 
STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cLocks);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cLocks);
}


// helper to handle the SELFREG.INF parsing

HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(g_hinst, szSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer()
{
    _CallRegInstall("UnregDll", TRUE);

    HRESULT hres = _CallRegInstall("RegDll", FALSE);
    if ( SUCCEEDED(hres) )
    {
        // if this is a workstation build then lets install the users and  password cpl

        NT_PRODUCT_TYPE NtProductType;
        RtlGetNtProductType(&NtProductType);            // get the product type
        if (NtProductType == NtProductWinNt)
        {
            hres = _CallRegInstall("RegDllWorkstation", FALSE);
        }
    }
    return S_OK;
}

STDAPI DllUnregisterServer()
{
    return S_OK;
}


//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
#define OIF_ALLOWAGGREGATION  0x0001

CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY( &CLSID_PublishingWizard, CPublishingWizard_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PublishDropTarget, CPublishDropTarget_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_UserPropertyPages, CUserPropertyPages_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_InternetPrintOrdering, CPublishDropTarget_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PassportWizard, CPassportWizard_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_PassportClientServices, CPassportClientServices_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        _ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
 
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                hr = S_OK;
            }
        }

    }

#ifdef ATL_ENABLED
    if (hr == CLASS_E_CLASSNOTAVAILABLE)
        hr = AtlGetClassObject(rclsid, riid, ppv);
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\getpp.cpp ===
#include "stdafx.h"
#pragma hdrstop

#define PROPERTY_PASSPORTUSER               L"PassportUser"
#define PROPERTY_PASSPORTPASSWORD           L"PassportPassword"
#define PROPERTY_PASSPORTREMEMBERPASSWORD   L"PassportRememberPassword"
#define PROPERTY_PASSPORTUSEMSNEMAIL        L"PassportUseMSNExplorerEmail"
#define PROPERTY_PASSPORTMARSAVAILABLE      L"PassportMSNExplorerAvailable"

// Wizard pages
#define WIZPAGE_WELCOME         0
#define WIZPAGE_FINISH          1
#define WIZPAGE_STARTOFEXT      2    // First webwizard extension page
#define WIZPAGE_MAX             10

#define REGKEY_PASSPORT_INTERNET_SETTINGS     L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport"
#define REGVAL_PASSPORT_WIZARDCOMPLETE        L"RegistrationCompleted"
#define REGVAL_PASSPORT_NUMBEROFWIZARDRUNS    L"NumRegistrationRuns"

void BoldControl(HWND hwnd, int id);

class CPassportWizard : public IWizardSite, IServiceProvider, IPassportWizard
{
public:
    CPassportWizard();
    ~CPassportWizard();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return E_NOTIMPL; }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IPassportWizard
    STDMETHODIMP Show(HWND hwndParent);
    STDMETHODIMP SetOptions(DWORD dwOptions);

protected:
    static CPassportWizard* s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam);    

    // Page Procs
    static INT_PTR CALLBACK s_WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPassportWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_WelcomePageProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR CALLBACK s_FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPassportWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_FinishPageProc(hwnd, uMsg, wParam, lParam); }

    INT_PTR _WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _CreateMyWebDocumentsLink();
    HRESULT _ApplyChanges(HWND hwnd);
    HRESULT _CreateWizardPages(void);
    HRESULT _SetURLFromNexus();
    HRESULT _GetCurrentPassport();
    HRESULT _LaunchHotmailRegistration();
    BOOL _IsMSNExplorerAvailableForEmail();
    HRESULT _UseMSNExplorerForEmail();

    INT_PTR _WizardNext(HWND hwnd, int iPage);

    LONG _cRef;
    IPropertyBag* _ppb;                         // Property Bag 
    IWebWizardExtension* _pwwe;                 // Wizard host - used for HTML pages
    HPROPSHEETPAGE _rgWizPages[WIZPAGE_MAX];

    DWORD _dwOptions;                           // Option flags for the passport wizard
};

STDAPI CPassportWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPassportWizard *pPPW = new CPassportWizard();
    if (!pPPW)
        return E_OUTOFMEMORY;

    HRESULT hr = pPPW->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pPPW->Release();
    return hr;
}

CPassportWizard::CPassportWizard() :
    _cRef(1)
{}

CPassportWizard::~CPassportWizard()
{
    ATOMICRELEASE(_ppb);
    ATOMICRELEASE(_pwwe);
}

// IUnknown
ULONG CPassportWizard::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPassportWizard::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPassportWizard::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPassportWizard, IServiceProvider),   // IID_IServiceProvider
        QITABENT(CPassportWizard, IWizardSite),        // IID_IWizardSite
        QITABENT(CPassportWizard, IModalWindow),       // IID_IModalWindow
        QITABENT(CPassportWizard, IPassportWizard),    // IID_IModalWindow
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IWizardSite
STDMETHODIMP CPassportWizard::GetNextPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _rgWizPages[WIZPAGE_FINISH];
    return S_OK;
}

STDMETHODIMP CPassportWizard::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _rgWizPages[WIZPAGE_WELCOME];
    return S_OK;
}


// IServiceProvider
STDMETHODIMP CPassportWizard::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;                // no result yet

    if (guidService == SID_WebWizardHost)
    {
        if (riid == IID_IPropertyBag)
            hr = _ppb->QueryInterface(riid, ppv);
    }

    return hr;
}

// IModalWindow

#define WIZDLG(name, dlgproc, dwFlags)   \
    { MAKEINTRESOURCE(IDD_GETPP_##name##), dlgproc, MAKEINTRESOURCE(IDS_GETPP_HEADER_##name##), MAKEINTRESOURCE(IDS_GETPP_SUBHEADER_##name##), dwFlags }

HRESULT CPassportWizard::_CreateWizardPages(void)
{
    static const WIZPAGE c_wpPages[] =
    {    
        WIZDLG(WELCOME,           CPassportWizard::s_WelcomePageProc,     PSP_HIDEHEADER),
        WIZDLG(FINISH,            CPassportWizard::s_FinishPageProc,      PSP_HIDEHEADER),
    };

    // if we haven't created the pages yet, then lets initialize our array of handlers.

    if (!_rgWizPages[0])
    {
        INITCOMMONCONTROLSEX iccex = { 0 };
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_LINK_CLASS;
        InitCommonControlsEx(&iccex);
        LinkWindow_RegisterClass();

        for (int i = 0; i < ARRAYSIZE(c_wpPages) ; i++ )
        {                           
            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = SIZEOF(PROPSHEETPAGE);
            psp.hInstance = g_hinst;
            psp.lParam = (LPARAM)this;
            psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | 
                          PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |
                          c_wpPages[i].dwFlags;

            psp.pszTemplate = c_wpPages[i].idPage;
            psp.pfnDlgProc = c_wpPages[i].pDlgProc;
            psp.pszTitle = MAKEINTRESOURCE(IDS_GETPP_CAPTION);
            psp.pszHeaderTitle = c_wpPages[i].pHeading;
            psp.pszHeaderSubTitle = c_wpPages[i].pSubHeading;

            _rgWizPages[i] = CreatePropertySheetPage(&psp);
            if (!_rgWizPages[i])
            {
                return E_FAIL;
            }
        }
    }

    return S_OK;
}

HRESULT CPassportWizard::_SetURLFromNexus()
{
    WCHAR szURL[INTERNET_MAX_URL_LENGTH];
    DWORD cch = ARRAYSIZE(szURL) - 1;
    HRESULT hr = PassportGetURL(PASSPORTURL_REGISTRATION, szURL, &cch);
    if (SUCCEEDED(hr))
    {
        hr = _pwwe->SetInitialURL(szURL);
    }
    else
    {
        // Cause the webserviceerror to appear since we can't get a good URL
        hr = _pwwe->SetInitialURL(L"");
    }

    return hr;
}

HRESULT CPassportWizard::Show(HWND hwndParent)
{
    // create our wizard pages, these are required before we do anything
    HRESULT hr = _CreateWizardPages();
    if (SUCCEEDED(hr))
    {
        // we interface with the wizard host via a property bag, so lets create an
        // initialize that before we proceed.
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &_ppb));
        if (SUCCEEDED(hr))
        {
            // Provide a property telling Passport if MSN Explorer is available as an e-mail client
            // in the start menu
            SHPropertyBag_WriteBOOL(_ppb, PROPERTY_PASSPORTMARSAVAILABLE, _IsMSNExplorerAvailableForEmail());

            // create the object which will host the HTML wizard pages, these are shown in the frame
            hr = CoCreateInstance(CLSID_WebWizardHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWebWizardExtension, &_pwwe));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(_pwwe, SAFECAST(this, IServiceProvider*));
        
                UINT cExtnPages = 0;
                hr = _pwwe->AddPages(_rgWizPages + WIZPAGE_STARTOFEXT, WIZPAGE_MAX - WIZPAGE_STARTOFEXT, &cExtnPages);
                if (SUCCEEDED(hr))
                {
                    PROPSHEETHEADER psh = { 0 };
                    psh.hwndParent = hwndParent;
                    psh.dwSize = SIZEOF(PROPSHEETHEADER);
                    psh.hInstance = g_hinst;
                    psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_STRETCHWATERMARK | PSH_HEADER | PSH_WATERMARK;
                    psh.pszbmHeader = MAKEINTRESOURCE(IDB_GETPP_BANNER);
                    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_GETPP_WATERMARK);
                    psh.phpage = _rgWizPages;
                    psh.nPages = (cExtnPages + WIZPAGE_STARTOFEXT);
                    psh.nStartPage = WIZPAGE_WELCOME;

                    // Return S_FALSE on cancel; otherwise S_OK;
                    hr = PropertySheet(&psh) ? S_OK : S_FALSE;
                }

                IUnknown_SetSite(_pwwe, NULL);
                ATOMICRELEASE(_pwwe);
            }
        }
        ATOMICRELEASE(_ppb);    
    }
    return hr;
}

HRESULT CPassportWizard::SetOptions(DWORD dwOptions)
{
    _dwOptions = dwOptions;
    return S_OK;
}

CPassportWizard* CPassportWizard::s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPassportWizard*)ppsp->lParam;
    }
    return (CPassportWizard*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

INT_PTR CPassportWizard::_WizardNext(HWND hwnd, int iPage)
{
    PropSheet_SetCurSel(GetParent(hwnd), _rgWizPages[iPage], -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
    return TRUE;
}

INT_PTR CPassportWizard::_WelcomePageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
                BoldControl(hwnd, IDC_BOLD1);
                // Increment "NumRegistrationRuns" value in the registry
                HKEY hkey;
                if (NO_ERROR == RegCreateKeyEx(HKEY_CURRENT_USER, REGKEY_PASSPORT_INTERNET_SETTINGS, NULL, NULL, 0, KEY_SET_VALUE | KEY_QUERY_VALUE, NULL, &hkey, NULL))
                {
                    DWORD dwType;
                    DWORD nRuns;
                    DWORD cb = sizeof (nRuns);
                    if ((NO_ERROR != RegQueryValueEx(hkey, REGVAL_PASSPORT_NUMBEROFWIZARDRUNS, NULL, &dwType, (LPBYTE) &nRuns, &cb)) ||
                        (REG_DWORD != dwType))
                    {
                        nRuns = 0;
                    }

                    nRuns ++;
                    RegSetValueEx(hkey, REGVAL_PASSPORT_NUMBEROFWIZARDRUNS, NULL, REG_DWORD, (const BYTE *) &nRuns, sizeof (nRuns));
                    RegCloseKey(hkey);
                }
            }
            return TRUE;
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT);
                    return TRUE;
                case PSN_WIZNEXT:
                {
                    // we need ICW to have executed before we navigate to webbased UI
                    LaunchICW();
                    
                    if (SUCCEEDED(_SetURLFromNexus()))
                    {
                        HPROPSHEETPAGE hpageNext;
                        if (SUCCEEDED(_pwwe->GetFirstPage(&hpageNext)))
                        {
                            PropSheet_SetCurSel(GetParent(hwnd), hpageNext, -1);
                        }
                    }

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) -1);
                    return TRUE;
                }
                case NM_CLICK:
                case NM_RETURN:
                    switch ((int) wParam)
                    {
                        case IDC_PRIVACYLINK:
                            {
                                WCHAR szURL[INTERNET_MAX_URL_LENGTH];
                                DWORD cch = ARRAYSIZE(szURL) - 1;
                                HRESULT hr = PassportGetURL(PASSPORTURL_PRIVACY, szURL, &cch);
                                if (SUCCEEDED(hr))
                                {
                                    WCHAR szURLWithLCID[INTERNET_MAX_URL_LENGTH];
                                    LPCWSTR pszFormat = StrChr(szURL, L'?') ? L"%s&pplcid=%d":L"%s?pplcid=%d";
                                    if (wnsprintf(szURLWithLCID, ARRAYSIZE(szURLWithLCID), pszFormat, szURL, GetUserDefaultLCID()) > 0)
                                    {
                                        // Open the browser to the privacy policy site
                                        SHELLEXECUTEINFO shexinfo = {0};
                                        shexinfo.cbSize = sizeof (shexinfo);
                                        shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
                                        shexinfo.nShow = SW_SHOWNORMAL;
                                        shexinfo.lpFile = szURL;
                                        shexinfo.lpVerb = TEXT("open");
                                        ShellExecuteEx(&shexinfo);
                                    }                                    
                                }                                
                            }
                            return TRUE;
                    }
            }
            return FALSE;
        }
    }
    return FALSE;
}

// Make sure MSN Explorer exists as an email client
BOOL CPassportWizard::_IsMSNExplorerAvailableForEmail()
{
    BOOL fAvailable = FALSE;
    HKEY hkeyMSNEmail;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"Software\\Clients\\Mail\\MSN Explorer", 0, KEY_READ, &hkeyMSNEmail))
    {
        fAvailable = TRUE;
        RegCloseKey(hkeyMSNEmail);
    }

    return fAvailable;
}

HRESULT CPassportWizard::_UseMSNExplorerForEmail()
{
    HRESULT hr = E_FAIL;

    if (_IsMSNExplorerAvailableForEmail())
    {
        HKEY hkeyDefaultEmail;
        // Change the default email program for the current user only
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, L"Software\\Clients\\Mail", 0, NULL, 0, KEY_SET_VALUE, NULL, &hkeyDefaultEmail, NULL))
        {
            static WCHAR szMSNExplorer[] = L"MSN Explorer";
            if (ERROR_SUCCESS == RegSetValueEx(hkeyDefaultEmail, L"", 0, REG_SZ, (BYTE*) szMSNExplorer, sizeof(szMSNExplorer)))
            {
                hr = S_OK;

                SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Clients\\Mail"));
            }

            RegCloseKey(hkeyDefaultEmail);
        }
    }

    return hr;
}

HRESULT CPassportWizard::_ApplyChanges(HWND hwnd)
{
    // Read user, password, and auth DA.
    WCHAR szPassportUser[1024];
    HRESULT hr = SHPropertyBag_ReadStr(_ppb, PROPERTY_PASSPORTUSER, szPassportUser, ARRAYSIZE(szPassportUser));
    if (SUCCEEDED(hr) && *szPassportUser)
    {
        WCHAR szPassportPassword[256];
        hr = SHPropertyBag_ReadStr(_ppb, PROPERTY_PASSPORTPASSWORD, szPassportPassword, ARRAYSIZE(szPassportPassword));
        if (SUCCEEDED(hr) && *szPassportPassword)
        {
            BOOL fRememberPW = SHPropertyBag_ReadBOOLDefRet(_ppb, PROPERTY_PASSPORTREMEMBERPASSWORD, FALSE);
            if (ERROR_SUCCESS == CredUIStoreSSOCredW(NULL, szPassportUser, szPassportPassword, fRememberPW))
            {
                hr = S_OK;

                // Write "RegistrationCompleted" value into the registry
                DWORD dwValue = 1;
                SHSetValue(HKEY_CURRENT_USER, REGKEY_PASSPORT_INTERNET_SETTINGS, REGVAL_PASSPORT_WIZARDCOMPLETE, REG_DWORD, &dwValue, sizeof (dwValue));

#if 0
                if (BST_CHECKED == SendDlgItemMessage(hwnd, IDC_MYWEBDOCUMENTSLINK, BM_GETCHECK, 0, 0))
                {
                    // Temporarily commented out - _CreateMyWebDocumentsLink();
                }

#endif
            }
            else
            {
                hr = E_FAIL;
            }

            if (SHPropertyBag_ReadBOOLDefRet(_ppb, PROPERTY_PASSPORTUSEMSNEMAIL, FALSE))
            {
                _UseMSNExplorerForEmail();
            }
        }
    }

    return hr;
}

INT_PTR CPassportWizard::_FinishPageProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    // Temporarily commented out - SendDlgItemMessage(hwnd, IDC_MYWEBDOCUMENTSLINK, BM_SETCHECK, (WPARAM) BST_CHECKED, 0);

                    WCHAR szPassportUser[1024];

                    // Try to get the passport user name... we may have to add an error page if this fails... TODO
                    HRESULT hr = SHPropertyBag_ReadStr(_ppb, PROPERTY_PASSPORTUSER, szPassportUser, ARRAYSIZE(szPassportUser));
                    if (SUCCEEDED(hr) && *szPassportUser)
                    {
                        SetDlgItemText(hwnd, IDC_YOURPASSPORT, szPassportUser);
                    }

                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_FINISH);
                    return TRUE;
                }

                case PSN_WIZBACK:
                    // The next page is the web wizard host. We show different pages depending whether or not
                    // the user has an email account (or passport) or not.
                    if (SUCCEEDED(_SetURLFromNexus()))
                    {
                        HPROPSHEETPAGE hpageNext;
                        if (SUCCEEDED(_pwwe->GetFirstPage(&hpageNext)))
                        {
                            PropSheet_SetCurSel(GetParent(hwnd), hpageNext, -1);
                        }
                    }

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;

                case PSN_WIZFINISH:
                    _ApplyChanges(hwnd);
                    return TRUE;
            }
            break;
        }
    }
    return FALSE;
}

// Help requires a rundll entrypoint to run passport wizard
void APIENTRY PassportWizardRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        IPassportWizard* pPW = NULL;
        hr = CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW));
        if (SUCCEEDED(hr))
        {
            pPW->SetOptions(PPW_LAUNCHEDBYUSER);
            pPW->Show(hwndStub);
            pPW->Release();
        }

        CoUninitialize();
    }
}

void BoldControl(HWND hwnd, int id)
{
    HWND hwndTitle = GetDlgItem(hwnd, id);

    // Get the existing font
    HFONT hfontOld = (HFONT) SendMessage(hwndTitle, WM_GETFONT, 0, 0);

    LOGFONT lf = {0};
    if (GetObject(hfontOld, sizeof(lf), &lf))
    {
        lf.lfWeight = FW_BOLD;

        HFONT hfontNew = CreateFontIndirect(&lf);
        if (hfontNew)
        {
            SendMessage(hwndTitle, WM_SETFONT, (WPARAM) hfontNew, FALSE);

            // Don't do this, its shared.
            // DeleteObject(hfontOld);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\grpinfo.cpp ===
#include "stdafx.h"
#include "grpinfo.h"
#pragma hdrstop

// Names of groups retrieved by SID
WCHAR g_szPowerUsers[MAX_GROUP + 1];
WCHAR g_szUsers[MAX_GROUP + 1];


/**************************************************************
 CGroupPageBase Implementation

  Functions common to both the group prop page and the group
  wizard page.
**************************************************************/
CGroupPageBase::CGroupPageBase(CUserInfo* pUserInfo, CDPA<CGroupInfo>* pGroupList)
{
    m_pUserInfo = pUserInfo;
    m_pGroupList = pGroupList;
    m_hBoldFont = NULL;
    
    // Load names for local groups based on SID
    if (FAILED(LookupLocalGroupName(DOMAIN_ALIAS_RID_POWER_USERS, g_szPowerUsers, ARRAYSIZE(g_szPowerUsers))))
    {
        *g_szPowerUsers = L'\0';
    }

    if (FAILED(LookupLocalGroupName(DOMAIN_ALIAS_RID_USERS, g_szUsers, ARRAYSIZE(g_szUsers))))
    {
        *g_szUsers = L'\0';
    }
}             
             
INT_PTR CGroupPageBase::HandleGroupMessage(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    };

    return FALSE;
}

void CGroupPageBase::InitializeLocalGroupCombo(HWND hwndCombo)
{
    ComboBox_ResetContent(hwndCombo);

    // Add all of the groups in the list to the box
    for(int i = 0; i < m_pGroupList->GetPtrCount(); i ++)
    {
        CGroupInfo* pGroupInfo = m_pGroupList->GetPtr(i);
        int index = ComboBox_AddString(hwndCombo, pGroupInfo->m_szGroup);
        ComboBox_SetItemData(hwndCombo, index, pGroupInfo->m_szComment);
    }

    TCHAR szSelectGroup[MAX_GROUP + 1];
    // Load a local group name from the resources to select by default
    LoadString(g_hinst, IDS_USR_DEFAULTGROUP, szSelectGroup, ARRAYSIZE(szSelectGroup));

    if (ComboBox_SelectString(hwndCombo, 0, szSelectGroup) == CB_ERR)
        ComboBox_SetCurSel(hwndCombo, 0);
}

void CGroupPageBase::SetGroupDescription(HWND hwndCombo, HWND hwndEdit)
{
    int iItem = ComboBox_GetCurSel(hwndCombo);
    TCHAR* pszDescription = (TCHAR*) ComboBox_GetItemData(hwndCombo, iItem);
    SetWindowText(hwndEdit, pszDescription);
}

BOOL CGroupPageBase::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Fill in the local group combo box
    HWND hwndCombo = GetDlgItem(hwnd, IDC_GROUPS);
    InitializeLocalGroupCombo(hwndCombo);

    HWND hwndEdit = GetDlgItem(hwnd, IDC_GROUPDESC);
    
    if ((NULL != m_pUserInfo) && (m_pUserInfo->m_szGroups[0] != TEXT('\0')))
    {
        // Select the local group corresponding to the first one in the user's groups
        // string
        TCHAR szSelect[MAX_GROUP + 1];

        // Copy the string since we might shorten our copy
        lstrcpyn(szSelect, m_pUserInfo->m_szGroups, ARRAYSIZE(szSelect));
        
        TCHAR* pchEndOfFirst = StrChr(szSelect, TEXT(';'));

        if (pchEndOfFirst)
        {
            // More than one group; we'll fix that!
            *pchEndOfFirst = TEXT('\0');
        }

        SelectGroup(hwnd, szSelect);
    }
    else
    {
        // Select the power user group by default 
        SendDlgItemMessage(hwnd, IDC_POWERUSERS, BM_SETCHECK, 
            (WPARAM) BST_CHECKED, 0);

        OnRadioChanged(hwnd, IDC_POWERUSERS);
    }
   
    SetGroupDescription(hwndCombo, hwndEdit);

    // Bold the group names
    BoldGroupNames(hwnd);

    return TRUE;
}

BOOL CGroupPageBase::GetSelectedGroup(HWND hwnd, LPTSTR pszGroupOut, DWORD cchGroup, CUserInfo::GROUPPSEUDONYM* pgsOut)
{
    *pgsOut = CUserInfo::USEGROUPNAME;

    UINT idString = 0;
    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_POWERUSERS)))
    {
        StrCpyN(pszGroupOut, g_szPowerUsers, cchGroup);
        *pgsOut = CUserInfo::STANDARD;
    }
    else if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_USERS)))
    {
        StrCpyN(pszGroupOut, g_szUsers, cchGroup);
        *pgsOut = CUserInfo::RESTRICTED;
    }
    else
    {
        // 'other' must be selected; get the string from the dropdown
        GetWindowText(GetDlgItem(hwnd, IDC_GROUPS), pszGroupOut, cchGroup);
    }

    return TRUE;
}

// Returns IDC_OTHER if no radio button id corresponds to the group
UINT CGroupPageBase::RadioIdForGroup(LPCTSTR pszGroup)
{
    UINT uiRadio = IDC_OTHER;                       // Assume IDC_OTHER to start
    if (0 == StrCmpI(pszGroup, g_szPowerUsers))
    {
        uiRadio = IDC_POWERUSERS;
    }
    else if (0 == StrCmpI(pszGroup, g_szUsers))
    {
        uiRadio = IDC_USERS;
    }

    return uiRadio;
}

// Disable/update as appropriate when radio selection changes
void CGroupPageBase::OnRadioChanged(HWND hwnd, UINT idRadio)
{
    BOOL fEnableGroupDropdown = (IDC_OTHER == idRadio);

    EnableWindow(GetDlgItem(hwnd, IDC_GROUPS), fEnableGroupDropdown);
    EnableWindow(GetDlgItem(hwnd, IDC_OTHER_STATIC), fEnableGroupDropdown);

    ShowWindow(GetDlgItem(hwnd, IDC_GROUPDESC), 
        fEnableGroupDropdown ? SW_SHOW : SW_HIDE);
}

void CGroupPageBase::SelectGroup(HWND hwnd, LPCTSTR pszSelect)
{
    // Always select the group in the 'other' dropdown
    ComboBox_SelectString(GetDlgItem(hwnd, IDC_GROUPS),
        -1, pszSelect);
    
    // Check the appropriate radio button
    UINT idRadio = RadioIdForGroup(pszSelect);
    Button_SetCheck(GetDlgItem(hwnd, idRadio), BST_CHECKED);

    OnRadioChanged(hwnd, idRadio);
}


void CGroupPageBase::BoldGroupNames(HWND hwnd)
{
    HWND hwndPowerUsers = GetDlgItem(hwnd, IDC_POWERUSERS);

    HFONT hfont = (HFONT) SendMessage(hwndPowerUsers, WM_GETFONT, 0, 0);

    if (hfont)
    {
        LOGFONT lf;
        if (FALSE != GetObject((HGDIOBJ) hfont, sizeof(lf), &lf))
        {
            lf.lfWeight = FW_BOLD;

            m_hBoldFont = CreateFontIndirect(&lf);

            if (NULL != m_hBoldFont)
            {
                // Set the font
                SendMessage(hwndPowerUsers, WM_SETFONT, 
                    (WPARAM) m_hBoldFont, 0);

                SendDlgItemMessage(hwnd, IDC_USERS,
                    WM_SETFONT, (WPARAM) m_hBoldFont, 0);

                SendDlgItemMessage(hwnd, IDC_OTHER,
                    WM_SETFONT, (WPARAM) m_hBoldFont, 0);
            }
        }
    }
}

BOOL CGroupPageBase::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(codeNotify)
    {
    case CBN_SELCHANGE:
        SetGroupDescription(hwndCtl, GetDlgItem(hwnd, IDC_GROUPDESC));
        PropSheet_Changed(GetParent(hwnd), hwnd);
        break;

    case BN_CLICKED:
        // Handle radio clicks
        switch (id)
        {
        case IDC_POWERUSERS:
        case IDC_USERS:
        case IDC_OTHER:
            PropSheet_Changed(GetParent(hwnd), hwnd);
            OnRadioChanged(hwnd, id);
        }
        break;
    }
    return FALSE;
}

/**************************************************************
 CGroupWizardPage Implementation
**************************************************************/

INT_PTR CGroupWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CGroupWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
        {
            PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_FINISH);
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            return TRUE;
        }

        case PSN_WIZFINISH:
        {
            // Read in the local group name
            CUserInfo::GROUPPSEUDONYM gs;
            GetSelectedGroup(hwnd, m_pUserInfo->m_szGroups,
                ARRAYSIZE(m_pUserInfo->m_szGroups), &gs);

            // Don't close wizard by default
            LONG_PTR finishResult = (LONG_PTR) hwnd;

            CWaitCursor cur;
            if (SUCCEEDED(m_pUserInfo->Create(hwnd, gs)))
            {
                m_pUserInfo->m_fHaveExtraUserInfo = FALSE;
                // Close wizard
                finishResult = 0;
            }

            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, finishResult);
            return TRUE;
        }
    }
    return FALSE;
}

/**************************************************************
 CGroupPropertyPage Implementation
**************************************************************/

INT_PTR CGroupPropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CGroupPropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch(pnmh->code)
    {
        case PSN_APPLY:
            {
                // Check to see if the group needs updating on Apply
                TCHAR szTemp[MAX_GROUP + 1];

                // Read in the local group name
                CUserInfo::GROUPPSEUDONYM gs;
                GetSelectedGroup(hwnd, szTemp,
                    ARRAYSIZE(szTemp), &gs);

                if (StrCmp(szTemp, m_pUserInfo->m_szGroups) != 0)
                {
                    HRESULT hr = m_pUserInfo->UpdateGroup(hwnd, szTemp, gs);

                    if (SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
                        MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername,
                            szDomainUser, ARRAYSIZE(szDomainUser));

                        ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, 
                            IDS_USR_UPDATE_GROUP_ERROR, MB_ICONERROR | MB_OK,
                            szDomainUser);

                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    }
                }
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\helpids.h ===
#ifndef HELPIDS_USR_H
#define HELPIDS_USR_H

#define IDH_USER_LIST               1210    // User list box
#define IDH_ADDUSER_BUTTON          1211    // Add User button
#define IDH_REMOVEUSER_BUTTON       1212    // Remove User button
#define IDH_USERPROPERTIES_BUTTON   1213    // Properties button
#define IDH_PASSWORD_BUTTON         1216    // Set Password button
#define IDH_ADVANCED_BUTTON         1220    // Advanced button
#define IDH_SECUREBOOT_CHECK        1225    // Require c-a-d checkbox
#define IDH_AUTOLOGON_CHECK         1226    // Require user name and pw to log on
#define IDH_MANAGEPWD_BUTTON        1218    // Keyring button
#define IDH_PASSPORTWIZARD          1223    // Passport wizard button
 
#endif // !HELPIDS_USR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\grpinfo.h ===
#ifndef GRPINFO_H_INCLUDED
#define GRPINFO_H_INCLUDED


// base implementation of the page/wizard object - handles state

class CGroupPageBase
{
public:
    // Public interface (in the case where you're not using a derived class
    CGroupPageBase(CUserInfo* pUserInfo, CDPA<CGroupInfo>* pGroupList);

    ~CGroupPageBase() 
    {
        if (NULL != m_hBoldFont)
            DeleteObject((HGDIOBJ) m_hBoldFont);
    }

    INT_PTR HandleGroupMessage(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    BOOL GetSelectedGroup(HWND hwnd, LPTSTR pszGroupOut, DWORD cchGroup, CUserInfo::GROUPPSEUDONYM* pgsOut);

protected:

    void InitializeLocalGroupCombo(HWND hwndCombo);
    void SetGroupDescription(HWND hwndCombo, HWND hwndEdit);
    void BoldGroupNames(HWND hwnd);
    void SelectGroup(HWND hwnd, LPCTSTR pszSelect);
    UINT RadioIdForGroup(LPCTSTR pszGroup);

protected:
    // Message handlers
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    void OnRadioChanged(HWND hwnd, UINT idRadio);

protected:
    // Data
    CUserInfo* m_pUserInfo;
    CDPA<CGroupInfo>* m_pGroupList;
    HFONT m_hBoldFont;
};


// wizard page for exposing the group membership

class CGroupWizardPage: public CPropertyPage, public CGroupPageBase
{
public:
    CGroupWizardPage(CUserInfo* pUserInfo, 
        CDPA<CGroupInfo>* pGroupList): 
        CGroupPageBase(pUserInfo, pGroupList) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
};


// property page for exposing group membership

class CGroupPropertyPage: public CPropertyPage, public CGroupPageBase
{
public:
    CGroupPropertyPage(CUserInfo* pUserInfo,
        CDPA<CGroupInfo>* pGroupList): 
        CGroupPageBase(pUserInfo, pGroupList) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
};


#endif // !GRPINFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\misc.cpp ===
#include "stdafx.h"
#include <objsel.h>         // Object picker
#include <dsrole.h>
#include "icwcfg.h"
#pragma hdrstop



// Wait cursor object

CWaitCursor::CWaitCursor() :
    _hCursor(NULL)
{
    WaitCursor();
}

CWaitCursor::~CWaitCursor()
{
    RestoreCursor();
}

void CWaitCursor::WaitCursor()
{ 
    _hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); 
}

void CWaitCursor::RestoreCursor()
{ 
    if (_hCursor)
     { 
        SetCursor(_hCursor); 
        _hCursor = NULL; 
    } 
}

HRESULT BrowseToPidl(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // Use shellexecuteex to open a view on the pidl
    SHELLEXECUTEINFO shexinfo = {0};
    shexinfo.cbSize = sizeof (shexinfo);
    shexinfo.fMask = SEE_MASK_IDLIST | SEE_MASK_FLAG_NO_UI;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpIDList = (void*) pidl;
    shexinfo.lpVerb = TEXT("open");

    hr = ShellExecuteEx(&shexinfo) ? S_OK : E_FAIL;

    return hr;
}


void FetchText(HWND hWndDlg, UINT uID, LPTSTR lpBuffer, DWORD dwMaxSize)
{
    TCHAR*  pszTemp;
    LPTSTR  pszString;

    *lpBuffer = L'\0';

    HWND hwndCtl = GetDlgItem(hWndDlg, uID);

    if (hwndCtl)
    {
        int iSize = GetWindowTextLength(hwndCtl);

        pszTemp = new TCHAR[iSize + 1];

        if (pszTemp)
        {
            GetWindowText(hwndCtl, pszTemp, iSize + 1);

            for (pszString = pszTemp ; *pszString && (*pszString == L' ') ; )
                pszString = CharNext(pszString); 

            if (*pszString )
            {
                lstrcpyn(lpBuffer, pszString, dwMaxSize);
                pszString = lpBuffer+(lstrlen(lpBuffer)-1);

                while ( (pszString > lpBuffer) && (*pszString == L' ') )
                    pszString--;

                pszString = CharNext(pszString);
                *pszString = L'\0';
            }

            delete [] pszTemp;
        }
    }
}

INT FetchTextLength(HWND hWndDlg, UINT uID) 
{
    TCHAR szBuffer[MAX_PATH];
    FetchText(hWndDlg, uID, szBuffer, ARRAYSIZE(szBuffer));
    return lstrlen(szBuffer);
}

HRESULT AttemptLookupAccountName(LPCTSTR szUsername, PSID* ppsid,
                                LPTSTR szDomain, DWORD* pcchDomain, SID_NAME_USE* psUse)
{
    HRESULT hr = S_OK;

    // First try to find required size of SID
    DWORD cbSid = 0;
    DWORD cchDomain = *pcchDomain;
    BOOL fSuccess = LookupAccountName(NULL, szUsername, *ppsid, &cbSid, szDomain, pcchDomain, psUse);

    *ppsid = LocalAlloc(0, cbSid);      // Now create the SID buffer and try again
    if (!*ppsid )
        return E_OUTOFMEMORY;

    *pcchDomain = cchDomain;
    
    if (!LookupAccountName(NULL, szUsername, *ppsid, &cbSid, szDomain, pcchDomain, psUse))
    {
        // Free our allocated SID
        LocalFree(*ppsid);
        *ppsid = NULL;
        return E_FAIL;
    }
    return S_OK;
}

BOOL FormatMessageTemplate(LPCTSTR pszTemplate, LPTSTR pszStrOut, DWORD cchSize, ...)
{
    va_list vaParamList;
    va_start(vaParamList, cchSize);
    BOOL fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, pszTemplate, 0, 0, pszStrOut, cchSize, &vaParamList);
    va_end(vaParamList);
    return fResult;
}

BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...)
{
    BOOL fResult = FALSE;

    va_list vaParamList;
    
    TCHAR szFormat[MAX_STATIC + 1];
    if (LoadString(g_hinst, idTemplate, szFormat, ARRAYSIZE(szFormat)))
    {
        va_start(vaParamList, cchSize);
        
        fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, pszStrOut, cchSize, &vaParamList);

        va_end(vaParamList);
    }

    return fResult;
}

int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...)
{
    int iResult = IDCANCEL;
    TCHAR szError[MAX_STATIC + 1]; *szError = 0;
    TCHAR szCaption[MAX_CAPTION + 1];
    TCHAR szFormat[MAX_STATIC + 1]; *szFormat = 0;

    // Load and format the error body
    if (LoadString(g_hinst, idFormatString, szFormat, ARRAYSIZE(szFormat)))
    {
        va_list arguments;
        va_start(arguments, uType);

        if (FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, szError, ARRAYSIZE(szError), &arguments))
        {
            // Load the caption
            if (LoadString(g_hinst, idCaption, szCaption, MAX_CAPTION))
            {
                iResult = MessageBox(hwnd, szError, szCaption, uType);
            }
        }

        va_end(arguments);
    }
    return iResult;
}

void EnableControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, BOOL fEnable)
{
    DWORD i;
    for (i = 0; i < cIDs; i ++)
    {
        EnableWindow(GetDlgItem(hwnd, prgIDs[i]), fEnable);
    }
}

void MakeDomainUserString(LPCTSTR szDomain, LPCTSTR szUsername, LPTSTR szDomainUser, DWORD cchBuffer)
{
    *szDomainUser = 0;

    if ((!szDomain) || szDomain[0] == TEXT('\0'))
    {
        // No domain - just use username
        lstrcpyn(szDomainUser, szUsername, cchBuffer);
    }
    else
    {
        // Otherwise we have to build a DOMAIN\username string
        wnsprintf(szDomainUser, cchBuffer, TEXT("%s\\%s"), szDomain, szUsername);
    }    
}

// From the NT knowledge base
#define MY_BUFSIZE 512  // highly unlikely to exceed 512 bytes

BOOL GetCurrentUserAndDomainName(LPTSTR UserName, LPDWORD cchUserName, LPTSTR DomainName, LPDWORD cchDomainName)
{
    HANDLE hToken;
    
    UCHAR InfoBuffer[ MY_BUFSIZE ];
    DWORD cbInfoBuffer = MY_BUFSIZE;
    
    SID_NAME_USE snu;
    BOOL bSuccess;
    
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken)) 
    {
        if(GetLastError() == ERROR_NO_TOKEN) 
        {   
            // attempt to open the process token, since no thread token  exists
            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken)) 
                return FALSE;
        } 
        else 
        {
            return FALSE;
        }
    }
    
    bSuccess = GetTokenInformation(hToken, TokenUser, InfoBuffer, cbInfoBuffer, &cbInfoBuffer);
    CloseHandle(hToken);

    if(!bSuccess) 
        return FALSE;

    return LookupAccountSid(NULL, ((PTOKEN_USER)InfoBuffer)->User.Sid, UserName, cchUserName, DomainName, cchDomainName, &snu);
}

// Pass NULL as TokenHandle to see if thread token is admin
HRESULT IsUserLocalAdmin(HANDLE TokenHandle, BOOL* pfIsAdmin)
{
    // First we must check if the current user is a local administrator; if this is
    // the case, our dialog doesn't even display

    PSID psidAdminGroup = NULL;
    SID_IDENTIFIER_AUTHORITY security_nt_authority = SECURITY_NT_AUTHORITY;
    
    BOOL fSuccess = ::AllocateAndInitializeSid(&security_nt_authority, 2, 
                                               SECURITY_BUILTIN_DOMAIN_RID, 
                                               DOMAIN_ALIAS_RID_ADMINS, 
                                               0, 0, 0, 0, 0, 0,
                                               &psidAdminGroup);
    if (fSuccess)
    {
        // See if the user for this process is a local admin
        fSuccess = CheckTokenMembership(TokenHandle, psidAdminGroup, pfIsAdmin);
        FreeSid(psidAdminGroup);
    }

    return fSuccess ? S_OK:E_FAIL;
}

BOOL IsComputerInDomain()
{
    static BOOL fInDomain = FALSE;
    static BOOL fValid = FALSE;

    if (!fValid)
    {
        fValid = TRUE;

        DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdspdinfb = {0};
        DWORD err = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, 
            (BYTE**) &pdspdinfb);

        if ((err == NO_ERROR) && (pdspdinfb != NULL))
        {
            if ((pdspdinfb->MachineRole == DsRole_RoleStandaloneWorkstation) ||
                (pdspdinfb->MachineRole == DsRole_RoleStandaloneServer))
            {
                fInDomain = FALSE;
            }
            else
            {
                fInDomain = TRUE;
            }

            DsRoleFreeMemory(pdspdinfb);
        }
    }

    return fInDomain;
}

void OffsetControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, int dx, int dy)
{
    for (DWORD i = 0; i < cIDs; i ++)
        OffsetWindow(GetDlgItem(hwnd, prgIDs[i]), dx, dy);
}

void OffsetWindow(HWND hwnd, int dx, int dy)
{
    RECT rc;
    GetWindowRect(hwnd, &rc);
    MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rc, 2);
    OffsetRect(&rc, dx, dy);
    SetWindowPos(hwnd, NULL, rc.left, rc.top, 0, 0, SWP_NOZORDER|SWP_NOSIZE);
}

BOOL AddPropSheetPageCallback(HPROPSHEETPAGE hpsp, LPARAM lParam)
{
    // lParam is really a ADDPROPSHEETDATA*
    ADDPROPSHEETDATA* ppsd = (ADDPROPSHEETDATA*)lParam;
    if (ppsd->nPages < ARRAYSIZE(ppsd->rgPages))
    {
        ppsd->rgPages[ppsd->nPages++] = hpsp;
        return TRUE;
    }
    return FALSE;
}

// Code to ensure only one instance of a particular window is running
CEnsureSingleInstance::CEnsureSingleInstance(LPCTSTR szCaption)
{
    // Create an event
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, szCaption);

    // If any weird errors occur, default to running the instance
    m_fShouldExit = FALSE;

    if (NULL != m_hEvent)
    {
        // If our event isn't signaled, we're the first instance
        m_fShouldExit = (WAIT_OBJECT_0 == WaitForSingleObject(m_hEvent, 0));

        if (m_fShouldExit)
        {
            // app should exit after calling ShouldExit()

            // Find and show the caption'd window
            HWND hwndActivate = FindWindow(NULL, szCaption);
            if (IsWindow(hwndActivate))
            {
                SetForegroundWindow(hwndActivate);
            }
        }
        else
        {
            // Signal that event
            SetEvent(m_hEvent);
        }
    }
}

CEnsureSingleInstance::~CEnsureSingleInstance()
{
    if (NULL != m_hEvent)
    {
        CloseHandle(m_hEvent);
    }
}


// Browse for a user
//
// This routine activates the appropriate Object Picker to allow
// the user to select a user
// uiTextLocation  -- The resource ID of the Edit control where the selected 
//                    object should be printed 

HRESULT BrowseForUser(HWND hwndDlg, TCHAR* pszUser, DWORD cchUser, TCHAR* pszDomain, DWORD cchDomain)
{
    DSOP_SCOPE_INIT_INFO scopeInfo = {0};
    scopeInfo.cbSize = sizeof (scopeInfo);
    scopeInfo.flType = 
        DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE   |
        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE | 
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN      |
        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN    |
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN            |
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    scopeInfo.flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    scopeInfo.FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    scopeInfo.FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS;
    scopeInfo.FilterFlags.Uplevel.flMixedModeOnly = 0;
    scopeInfo.FilterFlags.Uplevel.flNativeModeOnly = 0;
    scopeInfo.pwzADsPath = NULL;
    scopeInfo.pwzDcName = NULL;
    scopeInfo.hr = E_FAIL;

    DSOP_INIT_INFO initInfo = {0};
    initInfo.cbSize = sizeof (initInfo);
    initInfo.pwzTargetComputer = NULL;
    initInfo.cDsScopeInfos = 1;
    initInfo.aDsScopeInfos = &scopeInfo;
    initInfo.flOptions = 0;

    IDsObjectPicker* pPicker;
    
    HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (LPVOID*)&pPicker);
    if (SUCCEEDED(hr))
    {
        hr = pPicker->Initialize(&initInfo);
        if (SUCCEEDED(hr))
        {
            IDataObject* pdo;
            hr = pPicker->InvokeDialog(hwndDlg, &pdo);            // S_FALSE indicates cancel
            if ((S_OK == hr) && (NULL != pdo))
            {
                // Get the DS_SELECTION_LIST out of the data obj
                FORMATETC fmt;
                fmt.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);
                fmt.ptd = NULL;
                fmt.dwAspect = DVASPECT_CONTENT;
                fmt.lindex = -1;
                fmt.tymed = TYMED_HGLOBAL;

                STGMEDIUM medium = {0};
                
                hr = pdo->GetData(&fmt, &medium);

                if (SUCCEEDED(hr))
                {
                    DS_SELECTION_LIST* plist;
                    plist = (DS_SELECTION_LIST*)
                        GlobalLock(medium.hGlobal);

                    if (NULL != plist)
                    {
                        if (plist->cItems >= 1)
                        {
                            WCHAR szWinNTProviderName[MAX_DOMAIN + MAX_USER + 10];
                            lstrcpyn(szWinNTProviderName, plist->aDsSelection[0].pwzADsPath, ARRAYSIZE(szWinNTProviderName));

                            // Is the name in the correct format?
                            if (StrCmpNI(szWinNTProviderName, TEXT("WinNT://"), 8) == 0)
                            {
                                // Yes, copy over the user name and password
                                LPTSTR szDomain = szWinNTProviderName + 8;
                                LPTSTR szUser = StrChr(szDomain, TEXT('/'));
                                if (szUser)
                                {
                                    LPTSTR szTemp = CharNext(szUser);
                                    *szUser = 0;
                                    szUser = szTemp;

                                    // Just in case, remove the trailing slash
                                    LPTSTR szTrailingSlash = StrChr(szUser, TEXT('/'));
                                    if (szTrailingSlash)
                                        *szTrailingSlash = 0;

                                    lstrcpyn(pszUser, szUser, cchUser);
                                    lstrcpyn(pszDomain, szDomain, cchDomain);

                                    hr = S_OK;
                                }
                            }
                        }
                    }
                    else
                    {
                        hr = E_UNEXPECTED;                          // No selection list!
                    }
                    GlobalUnlock(medium.hGlobal);
                }
                pdo->Release();
            }
        }
        pPicker->Release();
    }
    return hr;
}


//
// create the intro/done large font for wizards
// 

static HFONT g_hfontIntro = NULL;

HFONT GetIntroFont(HWND hwnd)
{
    if ( !g_hfontIntro )
    {
        TCHAR szBuffer[64];
        NONCLIENTMETRICS ncm = { 0 };
        LOGFONT lf;

        ncm.cbSize = SIZEOF(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        lf = ncm.lfMessageFont;
        LoadString(g_hinst, IDS_TITLEFONTNAME, lf.lfFaceName, ARRAYSIZE(lf.lfFaceName));
        lf.lfWeight = FW_BOLD;

        LoadString(g_hinst, IDS_TITLEFONTSIZE, szBuffer, ARRAYSIZE(szBuffer));
        lf.lfHeight = 0 - (GetDeviceCaps(NULL, LOGPIXELSY) * StrToInt(szBuffer) / 72);

        g_hfontIntro = CreateFontIndirect(&lf);
    }
    return g_hfontIntro;
}

void CleanUpIntroFont()
{
    if (g_hfontIntro)
    {
        DeleteObject(g_hfontIntro);
        g_hfontIntro = NULL;
    }
}

void DomainUserString_GetParts(LPCTSTR szDomainUser, LPTSTR szUser, DWORD cchUser, LPTSTR szDomain, DWORD cchDomain)
{
    // Check for invalid args
    if ((!szUser) ||
        (!szDomain) ||
        (!cchUser) ||
        (!cchDomain))
    {
        return;
    }
    else
    {
        *szUser = 0;
        *szDomain = 0;

        TCHAR szTemp[MAX_USER + MAX_DOMAIN + 2];
        lstrcpyn(szTemp, szDomainUser, ARRAYSIZE(szTemp));

        LPTSTR szWhack = StrChr(szTemp, TEXT('\\'));

        if (!szWhack)
        {
            // Also check for forward slash to be friendly
            szWhack = StrChr(szTemp, TEXT('/'));
        }

        if (szWhack)
        {
            LPTSTR szUserPointer = szWhack + 1;
            *szWhack = 0;

            // Temp now points to domain.
            lstrcpyn(szDomain, szTemp, cchDomain);
            lstrcpyn(szUser, szUserPointer, cchUser);
        }
        else
        {
            // Don't have a domain name - just a username
            lstrcpyn(szUser, szTemp, cchUser);
        }
    }
}

LPITEMIDLIST GetComputerParent()
{
    USES_CONVERSION;
    LPITEMIDLIST pidl = NULL;

    IShellFolder *psfDesktop;
    HRESULT hres = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hres))
    {
        TCHAR szName[MAX_PATH];

        lstrcpy(szName, TEXT("\\\\"));

        LPTSTR pszAfterWhacks = szName + 2;

        DWORD cchName = MAX_PATH - 2;
        if (GetComputerName(pszAfterWhacks, &cchName))
        {
            hres = psfDesktop->ParseDisplayName(NULL, NULL, T2W(szName), NULL, &pidl, NULL);
            if (SUCCEEDED(hres))
            {
                ILRemoveLastID(pidl);
            }
        }
        else
        {
            hres = E_FAIL;
        }

        psfDesktop->Release();
    }

    if (FAILED(hres))
    {
        pidl = NULL;
    }

    return pidl;    
}

int CALLBACK ShareBrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
    case BFFM_INITIALIZED:
        {
            // Try to set the selected item according to the path string passed in lpData
            LPTSTR pszPath = (LPTSTR) lpData;

            if (pszPath && pszPath[0])
            {
                int i = lstrlen(pszPath) - 1;
                if ((pszPath[i] == TEXT('\\')) ||
                    (pszPath[i] == TEXT('/')))
                {
                    pszPath[i] = 0;
                }
   
                SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) (LPTSTR) pszPath);
            }
            else
            {
                // Try to get the computer's container folder
                LPITEMIDLIST pidl = GetComputerParent();

                if (pidl)
                {
                    SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) FALSE, (LPARAM) (LPTSTR) pidl);                
                    ILFree(pidl);
                }
            }
        }
        break;

    case BFFM_SELCHANGED:
        // Disable OK if this isn't a UNC path type thing
        {
            TCHAR szPath[MAX_PATH];
            LPITEMIDLIST pidl = (LPITEMIDLIST) lParam;

            BOOL fEnableOk = FALSE;
            
            if (SUCCEEDED(SHGetTargetFolderPath(pidl, szPath, ARRAYSIZE(szPath))))
            {
                SHFILEINFO sfi;

                SHGetFileInfo(szPath, 0, &sfi, sizeof(sfi), SHGFI_ATTRIBUTES);

                // Enable OK only if this is a file folder
                if (sfi.dwAttributes & SFGAO_FILESYSTEM)
                {
                    fEnableOk = PathIsUNC(szPath);
                }
            }

            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM) fEnableOk);
        }
        break;
    }
    return 0;
}


void RemoveControl(HWND hwnd, UINT idControl, UINT idNextControl, const UINT* prgMoveControls, DWORD cControls, BOOL fShrinkParent)
{
    HWND hwndControl = GetDlgItem(hwnd, idControl);
    HWND hwndNextControl = GetDlgItem(hwnd, idNextControl);
    RECT rcControl;
    RECT rcNextControl;

    if (hwndControl && GetWindowRect(hwndControl, &rcControl) && 
        hwndNextControl && GetWindowRect(hwndNextControl, &rcNextControl))
    {
        int dx = rcControl.left - rcNextControl.left;
        int dy = rcControl.top - rcNextControl.top;

        MoveControls(hwnd, prgMoveControls, cControls, dx, dy);

        if (fShrinkParent)
        {
            RECT rcParent;

            if (GetWindowRect(hwnd, &rcParent))
            {
                MapWindowPoints(NULL, GetParent(hwnd), (LPPOINT)&rcParent, 2);

                rcParent.right += dx;
                rcParent.bottom += dy;

                SetWindowPos(hwnd, NULL, 0, 0, RECTWIDTH(rcParent), RECTHEIGHT(rcParent), SWP_NOMOVE | SWP_NOZORDER);
            }
        }

        EnableWindow(hwndControl, FALSE);
        ShowWindow(hwndControl, SW_HIDE);
    }
}

void MoveControls(HWND hwnd, const UINT* prgControls, DWORD cControls, int dx, int dy)
{
    DWORD iControl;
    for (iControl = 0; iControl < cControls; iControl ++)
    {
        HWND hwndControl = GetDlgItem(hwnd, prgControls[iControl]);
        RECT rcControl;

        if (hwndControl && GetWindowRect(hwndControl, &rcControl))
        {
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcControl, 2);
            SetWindowPos(hwndControl, NULL, rcControl.left + dx, rcControl.top + dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        }
    }
}


// compute the size of a control based on the you are going to set into it, 
// returning the delta in size.

int SizeControlFromText(HWND hwnd, UINT id, LPTSTR psz)
{
    HDC hdc = GetDC(hwnd);
    if (hdc)
    {   
        HFONT hfDialog = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0);
        HFONT hfOld = (HFONT)SelectObject(hdc, hfDialog);

        RECT rc;
        GetClientRect(GetDlgItem(hwnd, id), &rc);

        int cy = RECTHEIGHT(rc);
        int dy = DrawTextEx(hdc, psz, -1, &rc, 
                            DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS |
                            DT_NOPREFIX | DT_EXTERNALLEADING | DT_EDITCONTROL,
                             NULL) - cy;

        SetWindowPos(GetDlgItem(hwnd, id), NULL, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOMOVE|SWP_NOZORDER);

        if (hfOld)
            SelectObject(hdc, hfOld);

        ReleaseDC(hwnd, hdc);
        return dy;
    }
    return 0;
}


void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain)
{
    BOOL fEnable;

    // Get the string the user is typing
    TCHAR* pszLogonName;
    int cchBuffer = (int)SendMessage(hwndUsername, WM_GETTEXTLENGTH, 0, 0) + 1;

    pszLogonName = (TCHAR*) LocalAlloc(0, cchBuffer * sizeof(TCHAR));
    if (pszLogonName != NULL)
    {
        SendMessage(hwndUsername, WM_GETTEXT, (WPARAM) cchBuffer, (LPARAM) pszLogonName);

        // Disable the domain combo if the user is using a
        // UPN (if there is a "@") - ie foo@microsoft.com
        fEnable = (NULL == StrChr(pszLogonName, TEXT('@')));

        EnableWindow(hwndDomain, fEnable);

        LocalFree(pszLogonName);
    }
}


//
//  Set our Alt+Tab icon for the duration of a modal property sheet.
//

int PropertySheetIcon(LPCPROPSHEETHEADER ppsh, LPCTSTR pszIcon)
{
    int     iResult;
    HWND    hwnd, hwndT;
    BOOL    fChangedIcon = FALSE;
    HICON   hicoPrev;

    // This trick doesn't work for modeless property sheets
    _ASSERT(!(ppsh->dwFlags & PSH_MODELESS));

    // Don't do this if the property sheet itself already has an icon
    _ASSERT(ppsh->hIcon == NULL);

    // Walk up the parent/owner chain until we find the master owner.
    //
    // We need to walk the parent chain because sometimes we are given
    // a child window as our lpwd->hwnd.  And we need to walk the owner
    // chain in order to find the owner whose icon will be used for
    // Alt+Tab.
    //
    // GetParent() returns either the parent or owner.  Normally this is
    // annoying, but we luck out and it's exactly what we want.

    hwnd = ppsh->hwndParent;
    while ((hwndT = GetParent(hwnd)) != NULL)
    {
        hwnd = hwndT;
    }

    // If the master owner isn't visible we can futz his icon without
    // screwing up his appearance.
    if (!IsWindowVisible(hwnd))
    {
        HICON hicoNew = LoadIcon(g_hinst, pszIcon);
        hicoPrev = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoNew);
        fChangedIcon = TRUE;
    }

    iResult = (int)PropertySheet(ppsh);

    // Clean up our icon now that we're done
    if (fChangedIcon)
    {
        // Put the old icon back
        HICON hicoNew = (HICON)SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hicoPrev);
        if (hicoNew)
            DestroyIcon(hicoNew);
    }

    return iResult;
}


// Launch ICW shiznits

BOOL IsICWCompleted()
{
    DWORD dwICWCompleted = 0;
    DWORD dwICWSize = sizeof(dwICWCompleted);
    SHGetValue(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), TEXT(ICW_REGKEYCOMPLETED), NULL, &dwICWCompleted, &dwICWSize);

    // 99/01/15 #272829 vtan: This is a horrible hack!!! If ICW has
    // not been run but settings have been made manually then values
    // in HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Connections
    // exists with the values given. Look for the presence of a key
    // to resolve that settings are present but that ICW hasn't been
    // launched.

    // The ideal solution is to get ICW to make this determination
    // for us BUT TO NOT LAUNCH ICWCONN1.EXE IN THE PROCESS.
    // Currently it will only launch. There is no way to get the
    // desired result without a launch.

    // 99/02/01 #280138 vtan: Well the solution put in for #272829
    // doesn't work. So peeking at the CheckConnectionWizard()
    // source in inetcfg\export.cpp shows that it uses a
    // wininet.dll function to determine whether manually configured
    // internet settings exist. It also exports this function so
    // look for it and bind to it dynamically.

    if (dwICWCompleted == 0)
    {

#define SMART_RUNICW    TRUE
#define SMART_QUITICW   FALSE

        HINSTANCE hICWInst = LoadLibrary(TEXT("inetcfg.dll"));
        if (hICWInst != NULL)
        {
            typedef DWORD (WINAPI *PFNISSMARTSTART) ();
            PFNISSMARTSTART pfnIsSmartStart = reinterpret_cast<PFNISSMARTSTART>(GetProcAddress(hICWInst, "IsSmartStart"));
            if (pfnIsSmartStart)
            {
                dwICWCompleted = BOOLIFY(pfnIsSmartStart() == SMART_QUITICW);
            }
            FreeLibrary(hICWInst);
        }
    }
    return (dwICWCompleted != 0);
}

void LaunchICW()
{
    static BOOL s_fCheckedICW = FALSE;

    if (!s_fCheckedICW && !IsICWCompleted())
    {
       // Prevent an error in finding the ICW from causing this to execute over and over again.

        s_fCheckedICW = TRUE;
        HINSTANCE hICWInst = LoadLibrary(TEXT("inetcfg.dll"));
        if (hICWInst != NULL)
        {
            PFNCHECKCONNECTIONWIZARD pfnCheckConnectionWizard;

            pfnCheckConnectionWizard = reinterpret_cast<PFNCHECKCONNECTIONWIZARD>(GetProcAddress(hICWInst, "CheckConnectionWizard"));
            if (pfnCheckConnectionWizard != NULL)
            {
                // If the user cancels ICW then it needs to be launched again.

                s_fCheckedICW = FALSE;
                
                DWORD dwICWResult;
                pfnCheckConnectionWizard(ICW_LAUNCHFULL | ICW_LAUNCHMANUAL, &dwICWResult);
            }
            FreeLibrary(hICWInst);
        }
    }
}

HRESULT LookupLocalGroupName(DWORD dwRID, LPWSTR pszName, DWORD cchName)
{
    HRESULT hr = E_FAIL;

    PSID psidGroup = NULL;
    SID_IDENTIFIER_AUTHORITY security_nt_authority = SECURITY_NT_AUTHORITY;
    
    BOOL fSuccess = ::AllocateAndInitializeSid(&security_nt_authority, 2, 
                                               SECURITY_BUILTIN_DOMAIN_RID, 
                                               dwRID, 
                                               0, 0, 0, 0, 0, 0,
                                               &psidGroup);
    if (fSuccess)
    {
        // Get the name
        WCHAR szDomain[MAX_GROUP + 1];
        DWORD cchDomain = ARRAYSIZE(szDomain);
        SID_NAME_USE type;
        fSuccess = LookupAccountSid(NULL, psidGroup, pszName, &cchName, szDomain, &cchDomain, &type);
        FreeSid(psidGroup);

        hr = fSuccess ? S_OK : E_FAIL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\join.cpp ===
#include "stdafx.h"
#pragma hdrstop

//
// registry information
//

const WCHAR c_szWinLogon[]          = L"Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon";

const WCHAR c_szAutoLogon[]         = L"AutoAdminLogon";
const WCHAR c_szDisableCAD[]        = L"DisableCAD";

const WCHAR c_szDefUserName[]       = L"DefaultUserName";
const WCHAR c_szDefDomain[]         = L"DefaultDomainName";
const WCHAR c_szDefPassword[]       = L"DefaultPassword";

const WCHAR c_szDefaultPwdKey[]     = L"DefaultPassword";

//
// registry helpers
//

BOOL _RegSetSZ(HKEY hk, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    DWORD dwSize = lstrlen(pszValue)*SIZEOF(WCHAR);
    return ERROR_SUCCESS == RegSetValueEx(hk, pszValueName, 0x0, REG_SZ, (BYTE *)pszValue, dwSize);
}

BOOL _RegSetDWORD(HKEY hk, LPCWSTR pszValueName, DWORD dwValue)
{
    DWORD dwSize = SIZEOF(dwValue);
    return ERROR_SUCCESS == RegSetValueEx(hk, pszValueName, 0x0, REG_DWORD, (BYTE *)&dwValue, dwSize);
}

BOOL _RegDelValue(HKEY hk, LPCWSTR pszValueName)
{
    return ERROR_SUCCESS == RegDeleteValue(hk, pszValueName);
}


INT_PTR CALLBACK _CredDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    LPCREDINFO pci = (LPCREDINFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch ( uMsg ) 
    {
        case WM_INITDIALOG:
        {
            pci = (LPCREDINFO)lParam;
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            SetDlgItemText(hwnd, IDC_USER, pci->pszUser);
            Edit_LimitText(GetDlgItem(hwnd, IDC_USER), pci->cchUser - 1);

            SetDlgItemText(hwnd, IDC_DOMAIN, pci->pszDomain);
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), pci->cchDomain - 1);

            SetDlgItemText(hwnd, IDC_PASSWORD, pci->pszPassword);
            Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), pci->cchPassword - 1);

            return TRUE;
        }

        case WM_COMMAND:
        {
            switch ( LOWORD(wParam) )
            {
                case IDOK:
                    {
                        FetchText(hwnd, IDC_DOMAIN, pci->pszDomain, pci->cchDomain);
                        FetchText(hwnd, IDC_USER, pci->pszUser, pci->cchUser);

                        if (StrChr(pci->pszUser, TEXT('@')))
                        {
                            *(pci->pszDomain) = 0;
                        }

                        GetDlgItemText(hwnd, IDC_PASSWORD, pci->pszPassword, pci->cchPassword);
                        return EndDialog(hwnd, IDOK);
                    }

                case IDCANCEL:
                    return EndDialog(hwnd, IDCANCEL);

                case IDC_USER:
                {
                    if ( HIWORD(wParam) == EN_CHANGE )
                    {
                        EnableWindow(GetDlgItem(hwnd, IDOK), FetchTextLength(hwnd, IDC_USER) > 0);

                        EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));
                    }
                    break;
                }
            }
            return TRUE;
        }
    }

    return FALSE;
}


//
// attempt to join a domain/workgroup using the specified names and OU.
//

HRESULT _AttemptJoin(HWND hwnd, DWORD dwFlags, LPCWSTR pszDomain, LPCWSTR pszUser, LPCWSTR pszUserDomain, LPCWSTR pszPassword)
{
    HRESULT hr = S_OK;

#ifndef DONT_JOIN
    TCHAR szDomainUser[MAX_DOMAINUSER + 1];
    if ( pszUser )
        MakeDomainUserString(pszUserDomain, pszUser, szDomainUser, ARRAYSIZE(szDomainUser));

    NET_API_STATUS nas = NetJoinDomain(NULL, pszDomain, NULL, szDomainUser, pszPassword, dwFlags);
    if ( (nas == ERROR_ACCESS_DENIED) )
    {
        // perhaps an account exists, but we can't delete it so try and remove
        // the account create flag

        if ( dwFlags & NETSETUP_ACCT_CREATE )
        {    
            dwFlags &= ~NETSETUP_ACCT_CREATE;
            nas = NetJoinDomain(NULL, pszDomain, NULL, szDomainUser, *pszPassword ? pszPassword : NULL, dwFlags);
        }
    }

    if ( (nas != NERR_Success) && (nas != NERR_SetupAlreadyJoined) )
    {
        TCHAR szMessage[512];

        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) nas, 0, szMessage, ARRAYSIZE(szMessage), NULL))
            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));
        
        ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_NAW_JOIN_GENERICERROR, MB_OK|MB_ICONERROR, szMessage);
        hr = HRESULT_FROM_WIN32(nas);
    }
#endif

    return hr;
}


void _ShowDcNotFoundErrorDialog(HWND hwnd, LPCWSTR pszDomain, LPCWSTR pszTitle)
{
    typedef void (*pfnShowDcNotFoundErrorDialog)(HWND, PCWSTR, PCWSTR);
    static HMODULE hNetID = NULL;
    static pfnShowDcNotFoundErrorDialog ShowDcNotFoundErrorDialog = NULL;

    if (!hNetID)
    {
        hNetID = LoadLibrary(L"netid.dll");
    }

    if (hNetID)
    {
        ShowDcNotFoundErrorDialog = (pfnShowDcNotFoundErrorDialog) GetProcAddress(hNetID, "ShowDcNotFoundErrorDialog");
        if (ShowDcNotFoundErrorDialog)
        {
            ShowDcNotFoundErrorDialog(hwnd, pszDomain, pszTitle);
        }
    }
}

//
// Handle moving from to a workgroup or domain.  To do this we are passed
// a structure containing all the information we need.
//
HRESULT JoinDomain(HWND hwnd, BOOL fDomain, LPCWSTR pszDomain, CREDINFO* pci, BOOL *pfReboot)
{
    HRESULT hres = E_FAIL;
    DWORD dwFlags = 0x0;
    LPWSTR pszCurrentDomain = NULL;
    NET_API_STATUS nas;
    BOOL fPassedCredentials = (pci && pci->pszUser && pci->pszUser[0] && pci->pszPassword);
    CWaitCursor cur;    

    //
    // lets validate the domain name before we go and use it, therefore avoiding
    // orphaning the computer too badly
    //

    nas = NetValidateName(NULL, pszDomain, NULL, NULL, fDomain ? NetSetupDomain:NetSetupWorkgroup);

    if (fDomain && (ERROR_NO_SUCH_DOMAIN == nas))
    {
        WCHAR szTitle[256];
        LoadString(g_hinst, IDS_NETWIZCAPTION, szTitle, ARRAYSIZE(szTitle));

        _ShowDcNotFoundErrorDialog(hwnd, pszDomain, szTitle);
        return E_FAIL;
    }

    if ( NERR_Success != nas )
    {
        ShellMessageBox(g_hinst, hwnd,
                        fDomain ? MAKEINTRESOURCE(IDS_ERR_BADDOMAIN) : MAKEINTRESOURCE(IDS_ERR_BADWORKGROUP), 
                        MAKEINTRESOURCE(IDS_NETWIZCAPTION),
                        MB_OK|MB_ICONWARNING,
                        pszDomain);
        return E_FAIL;
    }

    // 
    // now attempt to join the domain, prompt for credentails if the ones
    // specified are not good enough
    //

    if ( fDomain )
    {
        dwFlags |= NETSETUP_JOIN_DOMAIN|NETSETUP_ACCT_CREATE|NETSETUP_DOMAIN_JOIN_IF_JOINED;
    }
    else
    {
        nas = NetUnjoinDomain(NULL, NULL, NULL, NETSETUP_ACCT_DELETE);
        if ( (nas != NERR_Success) && (nas != NERR_SetupNotJoined) )
        {
            nas = NetUnjoinDomain(NULL, NULL, NULL, 0x0);
        }

        if ( (nas != NERR_Success) && (nas != NERR_SetupNotJoined) )
        {
            hres = E_UNEXPECTED;
            goto exit_gracefully;
        }

        *pfReboot = TRUE;               // we changed the domain
    }

    if ( !fDomain || fPassedCredentials)
    {
        if (fPassedCredentials)
        {
            hres = _AttemptJoin(hwnd, dwFlags, pszDomain, pci->pszUser, pci->pszDomain, pci->pszPassword);
        }
        else
        {
            hres = _AttemptJoin(hwnd, dwFlags, pszDomain, NULL, NULL, NULL);
        }
    }

    if ( fDomain && ((FAILED(hres) || (!fPassedCredentials))) )
    {
        do
        {
            if ( IDCANCEL == DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_PSW_JOINCREDENTIALS), 
                                                hwnd, _CredDlgProc, (LPARAM)pci) )
            {
                hres = E_FAIL;
                goto exit_gracefully;
            }

            // The dialog box changed the cursor from a wait cursor to an arrow cursor, so the cursor
            // needs to be changed back.. This call could be moved to _AttemptJoin (along with a call to
            // reset the cursor).  This call is made synchronously from the message loop for this hwnd
            cur.WaitCursor();            
            hres = _AttemptJoin(hwnd, dwFlags, pszDomain, pci->pszUser, pci->pszDomain, pci->pszPassword);

        }
        while ( FAILED(hres) );
    }

exit_gracefully:

    if ( SUCCEEDED(hres) )
    {
       ClearAutoLogon();
        *pfReboot = TRUE;               // we changed the domain
    }

    NetApiBufferFree(pszCurrentDomain);
    return hres;                                                                                                                                                                
}


//
// set and clear the auto admin logon state.
//
// we set the default user and default domain to the specified strings, we then blow away
// the clear text password stored in the registry to replace it with a password stored
// in the LSA secret space.
//

NTSTATUS _SetDefaultPassword(LPCWSTR PasswordBuffer)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0L, (HANDLE)NULL, NULL);

    Status = LsaOpenPolicy(NULL, &ObjectAttributes, POLICY_CREATE_SECRET, &LsaHandle);
    if (!NT_SUCCESS(Status))
        return Status;

    RtlInitUnicodeString(&SecretName, c_szDefaultPwdKey);
    RtlInitUnicodeString(&SecretValue, PasswordBuffer);

    Status = LsaStorePrivateData(LsaHandle, &SecretName, &SecretValue);
    LsaClose(LsaHandle);

    return Status;
}


//
// Set and clear auto logon for a particular
//

void SetAutoLogon(LPCWSTR pszUserName, LPCWSTR pszPassword)
{
#ifndef DONT_JOIN
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwComputerName = ARRAYSIZE(szComputerName);
    HKEY hk;

    GetComputerName(szComputerName, &dwComputerName);
    SetDefAccount(pszUserName, szComputerName);         // also clears auto logon

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinLogon, 0x0, KEY_WRITE, &hk) )
    {
        _RegSetSZ(hk, c_szAutoLogon, L"1");             // auto admin logon
        _RegDelValue(hk, c_szDefPassword);              // use the LSA secret for the password
        RegCloseKey (hk);
    }

    _SetDefaultPassword(pszPassword);    
#endif
}


//
// clear the auto admin logon
//

STDAPI ClearAutoLogon(VOID)
{
#ifndef DONT_JOIN
    HKEY hk;
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinLogon, 0x0, KEY_WRITE, &hk) )
    {
        _RegSetSZ(hk, c_szAutoLogon, L"0");         // no auto admin logon
        _RegDelValue(hk, c_szDefPassword);  

        RegCloseKey(hk);
    }

    _SetDefaultPassword(L"");            // clear the LSA secret
#endif
    return S_OK;
}


//
// set the default account
//

void SetDefAccount(LPCWSTR pszUser, LPCWSTR pszDomain)
{
#ifndef DONT_JOIN
   ClearAutoLogon();

    HKEY hk;
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinLogon, 0x0, KEY_WRITE, &hk) )
    {
        _RegSetSZ(hk, c_szDefUserName, pszUser);             
        _RegSetSZ(hk, c_szDefDomain, pszDomain);
       RegCloseKey(hk);
    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\makefile.inc ===
..\resource.rc : $(SELFREGNAME) ..\resource.h ..\publishing.rc ..\res\providers.xml ..\res\resourcemap.xml

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\netpage.h ===
#ifndef NETPAGE_H
#define NETPAGE_H

class CNetworkUserWizardPage: public CPropertyPage
{
public:
    CNetworkUserWizardPage(CUserInfo* pUserInfo);

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);


private:
    // Data
    CUserInfo* m_pUserInfo;

private:
    // Functions
    void SetWizardButtons(HWND hwnd, HWND hwndPropSheet);
    HRESULT GetUserAndDomain(HWND hwnd);
};

#endif //!NETPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\misc.h ===
#ifndef MISC_H
#define MISC_H

#ifndef MAX
#define MAX(x,y) (((x) > (y)) ? (x) : (y))
#endif

#ifndef MIN
#define MIN(x,y) (((x) < (y)) ? (x) : (y))
#endif


#define GetDlgItemTextLength(hwnd, id)              \
            GetWindowTextLength(GetDlgItem(hwnd, id))

#define WIZARDNEXT(hwnd, to)                        \
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)to)


// wait cursor management

class CWaitCursor 
{
  public:
    CWaitCursor();
    ~CWaitCursor();
    void WaitCursor();
    void RestoreCursor();

  private:
    HCURSOR _hCursor;
};

HRESULT BrowseToPidl(LPCITEMIDLIST pidl);

void FetchText(HWND hWndDlg, UINT uID, LPTSTR lpBuffer, DWORD dwMaxSize);
INT FetchTextLength(HWND hWndDlg, UINT uID);

HRESULT AttemptLookupAccountName(LPCTSTR szUsername, PSID* ppsid,
                                 LPTSTR szDomain, DWORD* pcchDomain, 
                                 SID_NAME_USE* psUse);

int DisplayFormatMessage(HWND hwnd, UINT idCaption, UINT idFormatString, UINT uType, ...);
BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...);
BOOL FormatMessageTemplate(LPCTSTR pszTemplate, LPTSTR pszStrOut, DWORD cchSize, ...);

void MakeDomainUserString(LPCTSTR szDomain, LPCTSTR szUsername, LPTSTR szDomainUser, DWORD cchBuffer);
void DomainUserString_GetParts(LPCTSTR szDomainUser, LPTSTR szUser, DWORD cchUser, LPTSTR szDomain, DWORD cchDomain);
BOOL GetCurrentUserAndDomainName(LPTSTR UserName, LPDWORD cchUserName, LPTSTR DomainName, LPDWORD cchDomainName);
HRESULT IsUserLocalAdmin(HANDLE TokenHandle OPTIONAL, BOOL* pfIsAdmin);
BOOL IsComputerInDomain();
LPITEMIDLIST GetComputerParent();

void EnableControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, BOOL fEnable);
void OffsetControls(HWND hwnd, const UINT* prgIDs, DWORD cIDs, int dx, int dy);
void OffsetWindow(HWND hwnd, int dx, int dy);
HFONT GetIntroFont(HWND hwnd);
void CleanUpIntroFont();

void RemoveControl(HWND hwnd, UINT idControl, UINT idNextControl, const UINT* prgMoveControls, DWORD cControls, BOOL fShrinkParent);
void MoveControls(HWND hwnd, const UINT* prgControls, DWORD cControls, int dx, int dy);
int SizeControlFromText(HWND hwnd, UINT id, LPTSTR psz);

void EnableDomainForUPN(HWND hwndUsername, HWND hwndDomain);
int PropertySheetIcon(LPCPROPSHEETHEADER ppsh, LPCTSTR pszIcon);


// Stuff for the callback for IShellPropSheetExt::AddPages
#define MAX_PROPSHEET_PAGES     10

struct ADDPROPSHEETDATA
{
    HPROPSHEETPAGE rgPages[MAX_PROPSHEET_PAGES];
    int nPages;
};

BOOL AddPropSheetPageCallback(HPROPSHEETPAGE hpsp, LPARAM lParam);


// single instance management

class CEnsureSingleInstance
{
public:
    CEnsureSingleInstance(LPCTSTR szCaption);
    ~CEnsureSingleInstance();

    BOOL ShouldExit() { return m_fShouldExit;}

private:
    BOOL m_fShouldExit;
    HANDLE m_hEvent;
};


// BrowseForUser
//  S_OK = Username/Domain are Ok
//  S_FALSE = User clicked cancel
//  E_xxx = Error

HRESULT BrowseForUser(HWND hwndDlg, TCHAR* pszUser, DWORD cchUser, TCHAR* pszDomain, DWORD cchDomain);
int CALLBACK ShareBrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);


// Passport functions - implemented in PassportMisc.cpp
#define PASSPORTURL_REGISTRATION    L"RegistrationUrl"
#define PASSPORTURL_LOGON           L"LoginServerUrl"
#define PASSPORTURL_PRIVACY         L"Privacy"

HRESULT PassportGetURL(PCWSTR pszName, PWSTR pszBuf, PDWORD pdwBufLen);
VOID    PassportForceNexusRepopulate();

// Launch ICW if it hasn't been run yet
void LaunchICW();

// LookupLocalGroupName - retrieves a local group name for a given RID.
// RID is one of these:
//  DOMAIN_ALIAS_RID_ADMINS
//  DOMAIN_ALIAS_RID_USERS
//  DOMAIN_ALIAS_RID_GUESTS
//  DOMAIN_ALIAS_RID_POWER_USERS
//  etc... (look in the SDK for other groups)
HRESULT LookupLocalGroupName(DWORD dwRID, LPWSTR pszName, DWORD cchName);

#endif //!MISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\mnddlg.cpp ===
#include "stdafx.h"
#include "password.h"
#pragma hdrstop


// class defn's used for the map net drive dialog and its helpers

class CMapNetDriveMRU
{
public:
    CMapNetDriveMRU();
    ~CMapNetDriveMRU();

    BOOL IsValid() {return (NULL != m_hMRU);}
    BOOL FillCombo(HWND hwndCombo);
    BOOL AddString(LPCTSTR psz);

private:
    static const DWORD c_nMaxMRUItems;
    static const TCHAR c_szMRUSubkey[];
    
    HANDLE m_hMRU;

    static int CompareProc(LPCTSTR lpsz1, LPCTSTR lpsz2);
};

class CMapNetDrivePage: public CPropertyPage
{
public:
    CMapNetDrivePage(LPCONNECTDLGSTRUCTW pConnectStruct, DWORD* pdwLastError): 
         m_pConnectStruct(pConnectStruct), m_pdwLastError(pdwLastError)
     {*m_pdwLastError = WN_SUCCESS; m_szDomainUser[0] = m_szPassword[0] = TEXT('\0');}

protected:
    // Message handlers
    INT_PTR DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem);
    BOOL OnDestroy(HWND hwnd);

    // Utility fn's
    void SetAdvancedLinkText(HWND hwnd);
    void EnableReconnect(HWND hwnd);
    BOOL ReadShowAdvanced();
    void WriteShowAdvanced(BOOL fShow);
    BOOL ReadReconnect();
    void WriteReconnect(BOOL fReconnect);
    void FillDriveBox(HWND hwnd);
    BOOL MapDrive(HWND hwnd);
    BOOL QueryDSForFolder(HWND hwndDlg, TCHAR* szFolderOut, DWORD cchFolderOut);
private:
    BOOL m_fRecheckReconnect; // When (none) is selected as the drive letter, we disable reconnect; Should we reenable it when another drive letter is selected?
    BOOL m_fAdvancedExpanded;
    LPCONNECTDLGSTRUCTW m_pConnectStruct;
    DWORD* m_pdwLastError;

    // Hold results of the "connect as" dialog
    TCHAR m_szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    TCHAR m_szPassword[MAX_PASSWORD + 1];

    // MRU list
    CMapNetDriveMRU m_MRU;
};

struct MapNetThreadData
{
    HWND hwnd;
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    TCHAR szPassword[MAX_PASSWORD + 1];
    TCHAR szPath[MAX_PATH + 1];
    TCHAR szDrive[3];
    BOOL fReconnect;
    HANDLE hEventCloseNow;
};

class CMapNetProgress: public CDialog
{
public:
    CMapNetProgress(MapNetThreadData* pdata, DWORD* pdwDevNum, DWORD* pdwLastError):
                    m_pdata(pdata), m_pdwDevNum(pdwDevNum), m_pdwLastError(pdwLastError)
        {}

    ~CMapNetProgress()
        { if (m_hEventCloseNow != NULL) CloseHandle(m_hEventCloseNow); }

protected:
    // Message handlers
    INT_PTR DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnMapSuccess(HWND hwnd, DWORD dwDevNum, DWORD dwLastError);

    // Thread
    static DWORD WINAPI MapDriveThread(LPVOID pvoid);
    static BOOL MapDriveHelper(MapNetThreadData* pdata, DWORD* pdwDevNum, DWORD* pdwLastError);
    static BOOL ConfirmDisconnectDrive(HWND hWndDlg, LPCTSTR lpDrive, LPCTSTR lpShare, DWORD dwType);
    static BOOL ConfirmDisconnectOpenFiles(HWND hWndDlg);

private:
    // data
    MapNetThreadData* m_pdata;    

    DWORD* m_pdwDevNum;
    DWORD* m_pdwLastError;

    HANDLE m_hEventCloseNow;
};

class CConnectAsDlg: public CDialog
{
public:
    CConnectAsDlg(TCHAR* pszDomainUser, DWORD cchDomainUser, TCHAR* pszPassword, DWORD cchPassword):
          m_pszDomainUser(pszDomainUser), m_cchDomainUser(cchDomainUser), m_pszPassword(pszPassword), m_cchPassword(cchPassword)
      {}

    INT_PTR DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
    TCHAR* m_pszDomainUser;
    DWORD m_cchDomainUser;

    TCHAR* m_pszPassword;
    DWORD m_cchPassword;
};


// x-position of share name in the combo box
#define SHARE_NAME_PIXELS   30      

// Drive-related Constants
#define DRIVE_NAME_STRING   TEXT(" :")
#define DRIVE_NAME_LENGTH   ((sizeof(DRIVE_NAME_STRING) - 1) / sizeof(TCHAR))

#define FIRST_DRIVE         TEXT('A')
#define LAST_DRIVE          TEXT('Z')
#define SHARE_NAME_INDEX    5   // Index of the share name in the drive string

#define SELECT_DONE         0x00000001  // The highlight has been set

// MPR Registry Constants
#define MPR_HIVE            HKEY_CURRENT_USER
#define MPR_KEY             TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Network\\Persistent Connections")
#define MPR_VALUE           TEXT("SaveConnections")
#define MPR_YES             TEXT("yes")
#define MPR_NO              TEXT("no")

const DWORD CMapNetDriveMRU::c_nMaxMRUItems = 26; // 26 is the same as the run dialog
const TCHAR CMapNetDriveMRU::c_szMRUSubkey[] = TEXT("software\\microsoft\\windows\\currentversion\\explorer\\Map Network Drive MRU");

CMapNetDriveMRU::CMapNetDriveMRU() : m_hMRU(NULL)
{
    MRUINFO mruinfo;
    mruinfo.cbSize = sizeof (MRUINFO);
    mruinfo.uMax = c_nMaxMRUItems;
    mruinfo.fFlags = 0;
    mruinfo.hKey = HKEY_CURRENT_USER;
    mruinfo.lpszSubKey = c_szMRUSubkey;
    mruinfo.lpfnCompare = CompareProc;
    m_hMRU = CreateMRUList(&mruinfo);
}

BOOL CMapNetDriveMRU::FillCombo(HWND hwndCombo)
{
    if (!m_hMRU)
        return FALSE;

    ComboBox_ResetContent(hwndCombo);

    int nItem = 0;
    TCHAR szMRUItem[MAX_PATH + 1];

    while (TRUE)
    {
        int nResult = EnumMRUList(m_hMRU, nItem, (LPVOID) szMRUItem, ARRAYSIZE(szMRUItem));
        if (-1 != nResult)
        {
            ComboBox_AddString(hwndCombo, szMRUItem);               // Add the string
            nItem ++;
        }
        else
        {
            break;                          // No selection list!
        }
    }
    return TRUE;
}

BOOL CMapNetDriveMRU::AddString(LPCTSTR psz)
{
    if (m_hMRU && (-1 != AddMRUString(m_hMRU, psz)))
        return TRUE;

    return FALSE;
}

CMapNetDriveMRU::~CMapNetDriveMRU()
{
    if (m_hMRU)
        FreeMRUList(m_hMRU);
}

int CMapNetDriveMRU::CompareProc(LPCTSTR lpsz1, LPCTSTR lpsz2)
{
    return StrCmpI(lpsz1, lpsz2);
}


void CMapNetDrivePage::EnableReconnect(HWND hwnd)
{
    BOOL fEnable = !(m_pConnectStruct->dwFlags & CONNDLG_HIDE_BOX);
    EnableWindow(GetDlgItem(hwnd, IDC_RECONNECT), fEnable);
}

BOOL CMapNetDrivePage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Check or uncheck the "reconnect at logon" box (registry)
    Button_SetCheck(GetDlgItem(hwnd, IDC_RECONNECT), ReadReconnect() ? BST_CHECKED : BST_UNCHECKED);

    EnableReconnect(hwnd);

    ComboBox_LimitText(GetDlgItem(hwnd, IDC_FOLDER), MAX_PATH);

    // Set up the drive drop-list
    FillDriveBox(hwnd);

    // Set focus to default control
    return FALSE;
}

BOOL CMapNetDrivePage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_FOLDERBROWSE:
            {
                LPITEMIDLIST pidl;
                // Future consideration: Need a CSIDL for computers near me to root the browse
                if (SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidl) == NOERROR)
                {
                    TCHAR szReturnedPath[MAX_PATH];
                    TCHAR szStartPath[MAX_PATH];
                    TCHAR szTitle[256];
                
                    // Get the path the user has typed so far; we'll try to begin
                    // the browse at this point
                    HWND hwndFolderEdit = GetDlgItem(hwnd, IDC_FOLDER);
                    FetchText(hwnd, IDC_FOLDER, szStartPath, ARRAYSIZE(szStartPath));

                    // Get the browse dialog title
                    LoadString(g_hinst, IDS_MND_SHAREBROWSE, szTitle, ARRAYSIZE(szTitle));

                    BROWSEINFO bi;
                    bi.hwndOwner = hwnd;
                    bi.pidlRoot = pidl;
                    bi.pszDisplayName = szReturnedPath;
                    bi.lpszTitle = szTitle;
                    // Show old-style dialog if we're running under WOW. RAID 216120
                    bi.ulFlags = (NULL == NtCurrentTeb()->WOW32Reserved) ? BIF_NEWDIALOGSTYLE : 0;
                    bi.lpfn = ShareBrowseCallback;
                    bi.lParam = (LPARAM) szStartPath;
                    bi.iImage = 0;

                    LPITEMIDLIST pidlReturned = SHBrowseForFolder(&bi);

                    if (pidlReturned != NULL)
                    {
                        if (SUCCEEDED(SHGetTargetFolderPath(pidlReturned, szReturnedPath, ARRAYSIZE(szReturnedPath))))
                        {
                            SetWindowText(hwndFolderEdit, szReturnedPath);

                            BOOL fEnableFinish = (szReturnedPath[0] != 0);
                            PropSheet_SetWizButtons(GetParent(hwnd), fEnableFinish ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
                        }
                    
                        ILFree(pidlReturned);
                    }

                    ILFree(pidl);
                }
            }
            return TRUE;

        case IDC_DRIVELETTER:
            if ( CBN_SELCHANGE == codeNotify )
            {
                HWND hwndCombo = GetDlgItem(hwnd, IDC_DRIVELETTER);
                int iItem = ComboBox_GetCurSel(hwndCombo);
                BOOL fNone = (BOOL)ComboBox_GetItemData(hwndCombo, iItem);
                HWND hwndReconnect = GetDlgItem(hwnd, IDC_RECONNECT);

                if (fNone)
                {
                    if (IsWindowEnabled(hwndReconnect))
                    {
                        // going from non-none to (none) - remember if we're checked
                        m_fRecheckReconnect = (BST_CHECKED == SendMessage(hwndReconnect, BM_GETCHECK, 0, 0));
                        // Uncheck the box
                        SendMessage(hwndReconnect, BM_SETCHECK, (WPARAM) BST_UNCHECKED, 0);
                    }
                }
                else
                {
                    if (!IsWindowEnabled(hwndReconnect))
                    {
                        SendMessage(hwndReconnect, BM_SETCHECK, (WPARAM) m_fRecheckReconnect ? BST_CHECKED : BST_UNCHECKED, 0);
                    }
                }

                EnableWindow(GetDlgItem(hwnd, IDC_RECONNECT), !fNone);        
            }
            break;

        case IDC_FOLDER:
            if ((CBN_EDITUPDATE == codeNotify) || (CBN_SELCHANGE == codeNotify))
            {
                // Enable Finish only if something is typed into the folder box
                TCHAR szTemp[MAX_PATH];
                FetchText(hwnd, IDC_FOLDER, szTemp, ARRAYSIZE(szTemp));
                BOOL fEnableFinish = (CBN_SELCHANGE == codeNotify) || (lstrlen(szTemp));
            
                PropSheet_SetWizButtons(GetParent(hwnd), fEnableFinish ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
                return TRUE;
            }
            break;

        default:
            break;
    }
    return FALSE;
}

BOOL CMapNetDrivePage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    USES_CONVERSION;

    BOOL fHandled = FALSE;

    switch (pnmh->code)
    {
    case PSN_SETACTIVE:
        {
            m_MRU.FillCombo(GetDlgItem(hwnd, IDC_FOLDER));

            // A path may have been specified. If so, use it
            TCHAR szPath[MAX_PATH + 1];
            if ((m_pConnectStruct->lpConnRes != NULL) && (m_pConnectStruct->lpConnRes->lpRemoteName != NULL))
            {
                // Copy over the string into our private buffer 
                lstrcpyn(szPath, W2T(m_pConnectStruct->lpConnRes->lpRemoteName), ARRAYSIZE(szPath));
        
                if (m_pConnectStruct->dwFlags & CONNDLG_RO_PATH)
                {
                    // this is read only
                    EnableWindow(GetDlgItem(hwnd, IDC_FOLDER), FALSE);
                    EnableWindow(GetDlgItem(hwnd, IDC_FOLDERBROWSE), FALSE);
                }
            }
            else
            {
                szPath[0] = TEXT('\0');
            }

            // Set the path
            SetWindowText(GetDlgItem(hwnd, IDC_FOLDER), szPath);

            // Enable Finish only if something is typed into the folder box
            BOOL fEnableFinish = lstrlen(szPath);
            PropSheet_SetWizButtons(GetParent(hwnd), fEnableFinish ? PSWIZB_FINISH : PSWIZB_DISABLEDFINISH);
        }
        return TRUE;

    case PSN_QUERYINITIALFOCUS:
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) GetDlgItem(hwnd, IDC_FOLDER));
        return TRUE;

    case PSN_WIZFINISH:
        if (MapDrive(hwnd))
        {
            WriteReconnect(BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_RECONNECT)));
            // Allow wizard to exit
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) FALSE);
        }
        else
        {
            // Force wizard to stick around
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LONG_PTR) GetDlgItem(hwnd, IDC_FOLDER));
        }
        return TRUE;

    case PSN_QUERYCANCEL:
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, FALSE);          // Allow cancel
        *m_pdwLastError = 0xFFFFFFFF;
        return TRUE;

    case NM_CLICK:
    case NM_RETURN:
        switch (idCtrl)
        {
            case IDC_CONNECTASLINK:
                {
                    CConnectAsDlg dlg(m_szDomainUser, ARRAYSIZE(m_szDomainUser), m_szPassword, ARRAYSIZE(m_szPassword));
                    dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_MND_CONNECTAS), hwnd);
                }
                return TRUE;

            case IDC_ADDPLACELINK:
                {
                    // Launch the ANP wizard
                    STARTUPINFO startupinfo = {0};
                    startupinfo.cb = sizeof(startupinfo);

                    TCHAR szCommandLine[] = TEXT("rundll32.exe netplwiz.dll,AddNetPlaceRunDll");

                    PROCESS_INFORMATION process_information;
                    if (CreateProcess(NULL, szCommandLine, NULL, NULL, 0, NULL, NULL, NULL, &startupinfo, &process_information))
                    {
                        CloseHandle(process_information.hProcess);
                        CloseHandle(process_information.hThread);
                        PropSheet_PressButton(GetParent(hwnd), PSBTN_CANCEL);
                    }
                    else
                    {
                        DisplayFormatMessage(hwnd, IDS_MAPDRIVE_CAPTION, IDS_MND_ADDPLACEERR, MB_ICONERROR | MB_OK);
                    }
                }
                return TRUE;

            default:
                break;
        }
        break;
    }

    return FALSE;
}

BOOL CMapNetDrivePage::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpDrawItem)
{
    // If there are no listbox items, skip this message.
    if (lpDrawItem->itemID == -1)
        return TRUE;
    
    // Draw the text for the listbox items
    switch (lpDrawItem->itemAction)
    {    
        case ODA_SELECT: 
        case ODA_DRAWENTIRE:
        {              
            TCHAR       tszDriveName[MAX_PATH + DRIVE_NAME_LENGTH + SHARE_NAME_INDEX];
            LPTSTR      lpShare;
            TEXTMETRIC  tm;
            COLORREF    clrForeground;
            COLORREF    clrBackground;
            DWORD       dwExStyle = 0L;
            UINT        fuETOOptions = ETO_CLIPPED;
            ZeroMemory(tszDriveName, sizeof(tszDriveName));

            // Get the text string associated with the given listbox item
            ComboBox_GetLBText(lpDrawItem->hwndItem, lpDrawItem->itemID,  tszDriveName);

            // Check to see if the drive name string has a share name at
            // index SHARE_NAME_INDEX.  If so, set lpShare to this location
            // and NUL-terminate the drive name.

            // Check for special (none) item and don't mess with the string in this case
            BOOL fNone = (BOOL) ComboBox_GetItemData(lpDrawItem->hwndItem, lpDrawItem->itemID);
            if ((*(tszDriveName + DRIVE_NAME_LENGTH) == L'\0') || fNone)
            {
                lpShare = NULL;
            }
            else
            {
                lpShare = tszDriveName + SHARE_NAME_INDEX;
                *(tszDriveName + DRIVE_NAME_LENGTH) = L'\0';
            }

            GetTextMetrics(lpDrawItem->hDC, &tm);
            clrForeground = SetTextColor(lpDrawItem->hDC,
                                         GetSysColor(lpDrawItem->itemState & ODS_SELECTED ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
            clrBackground = SetBkColor(lpDrawItem->hDC, 
                                        GetSysColor(lpDrawItem->itemState & ODS_SELECTED ? COLOR_HIGHLIGHT : COLOR_WINDOW));
            
            // check for RTL...
            dwExStyle = GetWindowLong(lpDrawItem->hwndItem, GWL_EXSTYLE);
            if(dwExStyle & WS_EX_RTLREADING)
               fuETOOptions |= ETO_RTLREADING; 

            // Draw the text into the listbox
            ExtTextOut(lpDrawItem->hDC,
                       LOWORD(GetDialogBaseUnits()) / 2,
                       (lpDrawItem->rcItem.bottom + lpDrawItem->rcItem.top - tm.tmHeight) / 2,
                       fuETOOptions | ETO_OPAQUE,
                       &lpDrawItem->rcItem,
                       tszDriveName, lstrlen(tszDriveName),
                       NULL);

            // If there's a share name, draw it in a second column
            // at (x = SHARE_NAME_PIXELS)
            if (lpShare != NULL)
            {
                ExtTextOut(lpDrawItem->hDC,
                           SHARE_NAME_PIXELS,
                           (lpDrawItem->rcItem.bottom + lpDrawItem->rcItem.top - tm.tmHeight) / 2,
                           fuETOOptions,
                           &lpDrawItem->rcItem,
                           lpShare, lstrlen(lpShare),
                           NULL);

                // Restore the original string
                *(tszDriveName + lstrlen(DRIVE_NAME_STRING)) = TEXT(' ');
            }

            // Restore the original text and background colors
            SetTextColor(lpDrawItem->hDC, clrForeground); 
            SetBkColor(lpDrawItem->hDC, clrBackground);

            // If the item is selected, draw the focus rectangle
            if (lpDrawItem->itemState & ODS_SELECTED)
            {
                DrawFocusRect(lpDrawItem->hDC, &lpDrawItem->rcItem); 
            }                     
            break;
        }
    }             
    return TRUE;
}

INT_PTR CMapNetDrivePage::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwnd, WM_DRAWITEM, OnDrawItem);
    }

    return FALSE;
}



// "Reconnect check" registry setting
BOOL CMapNetDrivePage::ReadReconnect()
{
    BOOL fReconnect = TRUE;

    if (m_pConnectStruct->dwFlags & CONNDLG_PERSIST)
    {
        fReconnect = TRUE;
    }
    else if (m_pConnectStruct->dwFlags & CONNDLG_NOT_PERSIST)
    {
        fReconnect = FALSE;
    }
    else
    {
        // User didn't specify -- check the registry.
        HKEY hkeyMPR;
        if (ERROR_SUCCESS == RegOpenKeyEx(MPR_HIVE, MPR_KEY, 0, KEY_READ, &hkeyMPR))
        {
            DWORD dwType;
            TCHAR szAnswer[ARRAYSIZE(MPR_YES) + ARRAYSIZE(MPR_NO)];
            DWORD cbSize = sizeof(szAnswer);

            if (ERROR_SUCCESS == RegQueryValueEx(hkeyMPR, MPR_VALUE, NULL,
                &dwType, (BYTE*) szAnswer, &cbSize))
            {
                fReconnect = (StrCmpI(szAnswer, (const TCHAR *) MPR_YES) == 0);
            }

            RegCloseKey(hkeyMPR);
        }            
    }
    return fReconnect;
}

void CMapNetDrivePage::WriteReconnect(BOOL fReconnect)
{
    // Don't write to the registry if the user didn't have a choice about reconnect
    if (!(m_pConnectStruct->dwFlags & CONNDLG_HIDE_BOX))
    {
        HKEY hkeyMPR;
        DWORD dwDisp;

        // User didn't specify -- check the registry.
        if (ERROR_SUCCESS == RegCreateKeyEx(MPR_HIVE, MPR_KEY, 0, NULL, 0, KEY_WRITE, NULL,
            &hkeyMPR, &dwDisp))
        {
            LPTSTR pszNewValue = (fReconnect ? MPR_YES : MPR_NO);

            RegSetValueEx(hkeyMPR, MPR_VALUE, NULL,
                REG_SZ, (BYTE*) pszNewValue, (lstrlen(pszNewValue) + 1) * sizeof (TCHAR));

            RegCloseKey(hkeyMPR);
        }            
    }
}


// This routine fills the drive letter drop-down list with all
// of the drive names and, if appropriate, the name of the share to which
// the drive is already connected

void CMapNetDrivePage::FillDriveBox(HWND hwnd)
{
    HWND    hWndCombo      = GetDlgItem(hwnd, IDC_DRIVELETTER);
    DWORD   dwFlags        = 0;
    DWORD   dwBufferLength = MAX_PATH - 1;
    TCHAR   szDriveName[SHARE_NAME_INDEX + MAX_PATH];
    TCHAR   szShareName[MAX_PATH - DRIVE_NAME_LENGTH];

    ZeroMemory(szDriveName, sizeof(szDriveName));
    ZeroMemory(szShareName, sizeof(szShareName));

    // lpDriveName looks like this: "<space>:<null>"
    lstrcpyn(szDriveName, DRIVE_NAME_STRING, ARRAYSIZE(szDriveName));

    // lpDriveName looks like this: 
    // "<space>:<null><spaces until index SHARE_NAME_INDEX>"
    for (UINT i = DRIVE_NAME_LENGTH + 1; i < SHARE_NAME_INDEX; i++)
    {
        szDriveName[i] = L' ';
    }

    for (TCHAR cDriveLetter = LAST_DRIVE; cDriveLetter >= FIRST_DRIVE; cDriveLetter--)
    {        
        // lpDriveName looks like this: "<drive>:<null><lots of spaces>"
        szDriveName[0] = cDriveLetter;
        UINT uDriveType = GetDriveType(szDriveName);

        // NoRootDir == usually available, but may be mounted to a network drive that currently isn't
        // available - check for this!
        if (DRIVE_NO_ROOT_DIR == uDriveType)
        {
            if (ERROR_CONNECTION_UNAVAIL == WNetGetConnection(szDriveName, szShareName, &dwBufferLength))
            {
                // Pretend its a remote drive
                uDriveType = DRIVE_REMOTE;
                dwBufferLength = MAX_PATH - DRIVE_NAME_LENGTH - 1;
            }
        }

        // Removable == floppy drives, Fixed == hard disk, CDROM == obvious :),
        // Remote == network drive already attached to a share
        switch (uDriveType)
        {
            case DRIVE_REMOVABLE:
            case DRIVE_FIXED:
            case DRIVE_CDROM:
                // These types of drives can't be mapped
                break;

            case DRIVE_REMOTE:
            {
                UINT    i;

                // Reset the share buffer length (it 
                // gets overwritten by WNetGetConnection)
                dwBufferLength = MAX_PATH - DRIVE_NAME_LENGTH - 1;
                
                // Retrieve "\\server\share" for current drive
                DWORD dwRes = WNetGetConnection(szDriveName, szShareName, &dwBufferLength);
                if ((dwRes == NO_ERROR) || (dwRes == ERROR_CONNECTION_UNAVAIL))
                {
                    // lpDriveName looks like this: 
                    // "<drive>:<spaces until SHARE_NAME_INDEX><share name><null>"
                
                    szDriveName[DRIVE_NAME_LENGTH] = L' ';
                    lstrcpyn(szDriveName + SHARE_NAME_INDEX, szShareName, (MAX_PATH - DRIVE_NAME_LENGTH - 1));


                    // Store a FALSE into the item data for all items except the
                    // special (none) item
                    int iItem = ComboBox_AddString(hWndCombo, szDriveName);
                    ComboBox_SetItemData(hWndCombo, iItem, (LPARAM) FALSE);

                    // Reset the drive name to "<drive>:<null><lots of spaces>"
                    szDriveName[DRIVE_NAME_LENGTH] = L'\0';

                    for (i = DRIVE_NAME_LENGTH + 1; i < MAX_PATH + SHARE_NAME_INDEX; i++)
                    {
                        *(szDriveName + i) = L' ';
                    }
                    break;
                }
                else
                {                    
                    // If there's an error with this drive, ignore the drive
                    // and skip to the next one.  Note that dwBufferLength will
                    // only be changed if lpShareName contains MAX_PATH or more
                    // characters, which shouldn't ever happen.  For release,
                    // however, keep on limping along.

                    dwBufferLength = MAX_PATH - DRIVE_NAME_LENGTH - 1;
                    break;
                }
            }

            default:                                                
            {
                // The drive is not already connected to a share

                // Suggest the first available and unconnected 
                // drive past the C drive
                DWORD dwIndex = ComboBox_AddString(hWndCombo, szDriveName);
                if (!(dwFlags & SELECT_DONE))
                {                
                    ComboBox_SetCurSel(hWndCombo, dwIndex);
                    dwFlags |= SELECT_DONE;
                }
                break;
            }
        }
    }
    // Add one more item - a special (none) item that if selected causes 
    // a deviceless connection to be created.

    LoadString(g_hinst, IDS_NONE, szDriveName, ARRAYSIZE(szDriveName));
    int iItem = ComboBox_AddString(hWndCombo, szDriveName);
    ComboBox_SetItemData(hWndCombo, iItem, (LPARAM) TRUE);


    // If there is no selection at this point, just select (none) item
    // This will happen when all drive letters are mapped

    if (ComboBox_GetCurSel(hWndCombo) == CB_ERR)
    {
        ComboBox_SetCurSel(hWndCombo, iItem);
    }
}

BOOL CMapNetDrivePage::MapDrive(HWND hwnd)
{
    BOOL fMapWorked = FALSE;
    
    HWND hwndCombo = GetDlgItem(hwnd, IDC_DRIVELETTER);
    int iItem = ComboBox_GetCurSel(hwndCombo);

    // Get this item's text and itemdata (to check if its the special (none) drive)
    BOOL fNone = (BOOL) ComboBox_GetItemData(hwndCombo, iItem);
        
    // Fill in the big structure that maps a drive
    MapNetThreadData* pdata = new MapNetThreadData;

    if (pdata != NULL)
    {
        // Set reconnect
        pdata->fReconnect = (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_RECONNECT)));

        // Set the drive
        if (fNone)
        {
            pdata->szDrive[0] = TEXT('\0');
        }
        else
        {
            ComboBox_GetText(hwndCombo, pdata->szDrive, 3);
        }

        // Set the net share
        FetchText(hwnd, IDC_FOLDER, pdata->szPath, ARRAYSIZE(pdata->szPath));
        PathRemoveBackslash(pdata->szPath);

        // Get an alternate username/password/domain if required
        // Domain/username
        lstrcpyn(pdata->szDomainUser, m_szDomainUser, ARRAYSIZE(pdata->szDomainUser));

        // Password
        lstrcpyn(pdata->szPassword, m_szPassword, ARRAYSIZE(pdata->szPassword));

        CMapNetProgress dlg(pdata, &m_pConnectStruct->dwDevNum, m_pdwLastError);
        
        // On IDOK == Close dialog!
        fMapWorked = (IDOK == dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_MND_PROGRESS_DLG), hwnd));
    }

    if (fMapWorked)
    {
        TCHAR szPath[MAX_PATH + 1];
        FetchText(hwnd, IDC_FOLDER, szPath, ARRAYSIZE(szPath));
        m_MRU.AddString(szPath);

        // If a drive letter wasn't assigned, open a window on the new drive now
        if (fNone)
        {
            // Use shellexecuteex to open a view folder
            SHELLEXECUTEINFO shexinfo = {0};
            shexinfo.cbSize = sizeof (shexinfo);
            shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
            shexinfo.nShow = SW_SHOWNORMAL;
            shexinfo.lpFile = szPath;
            shexinfo.lpVerb = TEXT("open");

            ShellExecuteEx(&shexinfo);
        }
    }
    
    return fMapWorked;
}


// Little progress dialog implementation

// Private message for thread to signal dialog if successful
//  (DWORD) (WPARAM) dwDevNum - 0-based device number connected to (0xFFFFFFFF for none)
//  (DWORD) (LPARAM) dwRetVal - Return value
#define WM_MAPFINISH (WM_USER + 100)

INT_PTR CMapNetProgress::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
        case WM_MAPFINISH: return OnMapSuccess(hwnd, (DWORD) wParam, (DWORD) lParam);
    }

    return FALSE;
}

BOOL CMapNetProgress::OnMapSuccess(HWND hwnd, DWORD dwDevNum, DWORD dwLastError)
{
    *m_pdwDevNum = dwDevNum;
    *m_pdwLastError = dwLastError;
    EndDialog(hwnd, ((dwLastError == WN_SUCCESS) ? IDOK : IDCANCEL));
    return TRUE;
}

BOOL CMapNetProgress::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HANDLE hThread = NULL;

    // Set the progress dialog text
    TCHAR szText[256];
    FormatMessageString(IDS_MND_PROGRESS, szText, ARRAYSIZE(szText), m_pdata->szPath);

    SetWindowText(GetDlgItem(hwnd, IDC_CONNECTING), szText);


    // We'll signal this guy when the thread should close down
    static const TCHAR EVENT_NAME[] = TEXT("Thread Close Event");
    m_hEventCloseNow = CreateEvent(NULL, TRUE, FALSE, EVENT_NAME);
    m_pdata->hEventCloseNow = NULL;

    if (m_hEventCloseNow != NULL)
    {
        // Get a copy of this puppy for the thread
        m_pdata->hEventCloseNow = OpenEvent(SYNCHRONIZE, FALSE, EVENT_NAME);

        if (m_pdata->hEventCloseNow != NULL)
        {
            m_pdata->hwnd = hwnd;

            // All we have to do is start up the worker thread, who will dutifully report back to us
            DWORD dwId;
            hThread = CreateThread(NULL, 0, CMapNetProgress::MapDriveThread, (LPVOID) m_pdata, 0, &dwId);
        }
    }

    // Abandon the poor little guy (he'll be ok)
    if (hThread != NULL)
    {
        CloseHandle(hThread);

        /* TAKE SPECIAL CARE
        At this point the thread owns m_pdata! Don't access it any more except on the thread.
        It may be deleted at any time! */

        m_pdata = NULL;
    }
    else
    {
        // Usually the thread would do this
        if (m_pdata->hEventCloseNow != NULL)
        {
            CloseHandle(m_pdata->hEventCloseNow);
        }
    
        delete m_pdata;

        // We just failed to create a thread. The computer must be near out of
        // resources.
        EndDialog(hwnd, IDCANCEL);
    }

    return FALSE;
}

BOOL CMapNetProgress::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (id == IDCANCEL)
    {
        SetEvent(m_hEventCloseNow); // Tell the thread to quit
        EndDialog(hwnd, id);
    }
    return FALSE;
}

DWORD CMapNetProgress::MapDriveThread(LPVOID pvoid)
{
    MapNetThreadData* pdata = (MapNetThreadData*) pvoid;

    DWORD dwDevNum;
    DWORD dwLastError;
    BOOL fSuccess = MapDriveHelper(pdata, &dwDevNum, &dwLastError);

    if (WAIT_OBJECT_0 == WaitForSingleObject(pdata->hEventCloseNow, 0))
    {
        // The user clicked cancel, don't call back to the progress wnd
    }
    else
    {
        PostMessage(pdata->hwnd, WM_MAPFINISH, (WPARAM) dwDevNum, 
            (LPARAM) dwLastError);
    }
    
    CloseHandle(pdata->hEventCloseNow);

    delete pdata;
    return 0;
}

BOOL CMapNetProgress::MapDriveHelper(MapNetThreadData* pdata, DWORD* pdwDevNum, DWORD* pdwLastError)
{
    NETRESOURCE     nrResource = {0};
    LPTSTR          lpMessage = NULL;

    *pdwDevNum = 0;
   
    //
    // Fill in the NETRESOURCE structure -- the local name is the drive and
    // the remote name is \\server\share (stored in the global buffer).
    // The provider is NULL to let NT find the provider on its own.
    //
    nrResource.dwType         = RESOURCETYPE_DISK;
    nrResource.lpLocalName    = pdata->szDrive[0] == TEXT('\0') ? NULL : pdata->szDrive;
    nrResource.lpRemoteName   = pdata->szPath;
    nrResource.lpProvider     = NULL;

    BOOL fRetry = TRUE;
    while (fRetry)
    {        
        *pdwLastError = WNetAddConnection3(pdata->hwnd, &nrResource,
            pdata->szDomainUser[0] == TEXT('\0') ? NULL : pdata->szPassword, 
            pdata->szDomainUser[0] == TEXT('\0') ? NULL : pdata->szDomainUser, 
            pdata->fReconnect ? CONNECT_INTERACTIVE | CONNECT_UPDATE_PROFILE : CONNECT_INTERACTIVE);

        // Don't display anything if we're supposed to quit
        if (WAIT_OBJECT_0 == WaitForSingleObject(pdata->hEventCloseNow, 0))
        {   
            // We should quit (quietly exit if we just failed)!
            if (*pdwLastError != NO_ERROR)
            {
                *pdwLastError = RETCODE_CANCEL;
                fRetry = FALSE;
            }
        }
        else
        {
            fRetry = FALSE;

            switch (*pdwLastError)
            {
                case NO_ERROR:
                    {
                        // Put the number of the connection into dwDevNum, where 
                        // drive A is 1, B is 2, ... Note that a deviceless connection
                        // is 0xFFFFFFFF
                        if (pdata->szDrive[0] == TEXT('\0'))
                        {
                            *pdwDevNum = 0xFFFFFFFF;
                        }
                        else
                        {
                            *pdwDevNum = *pdata->szDrive - FIRST_DRIVE + 1;
                        }
                
                        *pdwLastError = WN_SUCCESS;
                    }
                    break;

                //
                // The user cancelled the password dialog or cancelled the
                // connection through a different dialog
                //
                case ERROR_CANCELLED:
                    {
                        *pdwLastError = RETCODE_CANCEL;
                    }
                    break;

                //
                // An error involving the user's password/credentials occurred, so
                // bring up the password prompt. - Only works for WINNT
                //
                case ERROR_ACCESS_DENIED:
                case ERROR_CANNOT_OPEN_PROFILE:
                case ERROR_INVALID_PASSWORD:
                case ERROR_LOGON_FAILURE:
                case ERROR_BAD_USERNAME:
                    {
                        CPasswordDialog dlg(pdata->szPath, pdata->szDomainUser, ARRAYSIZE(pdata->szDomainUser), 
                            pdata->szPassword, ARRAYSIZE(pdata->szPassword), *pdwLastError);

                        if (IDOK == dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_WIZ_NETPASSWORD),
                            pdata->hwnd))
                        {
                            fRetry = TRUE;
                        }
                    }
                    break;

                // There's an existing/remembered connection to this drive
                case ERROR_ALREADY_ASSIGNED:
                case ERROR_DEVICE_ALREADY_REMEMBERED:

                    // See if the user wants us to break the connection
                    if (ConfirmDisconnectDrive(pdata->hwnd, 
                                                pdata->szDrive,
                                                pdata->szPath,
                                                *pdwLastError))
                    {
                        // Break the connection, but don't force it 
                        // if there are open files
                        *pdwLastError = WNetCancelConnection2(pdata->szDrive,
                                                        CONNECT_UPDATE_PROFILE,
                                                        FALSE);
     
                        if (*pdwLastError == ERROR_OPEN_FILES || 
                            *pdwLastError == ERROR_DEVICE_IN_USE)
                        {                    
                            // See if the user wants to force the disconnection
                            if (ConfirmDisconnectOpenFiles(pdata->hwnd))
                            {
                                // Roger 1-9er -- we have confirmation, 
                                // so force the disconnection.
                                *pdwLastError = WNetCancelConnection2(pdata->szDrive,
                                                      CONNECT_UPDATE_PROFILE,
                                                      TRUE);

                                if (*pdwLastError == NO_ERROR)
                                {
                                    fRetry = TRUE;
                                }
                                else
                                {
                                    DisplayFormatMessage(pdata->hwnd, IDS_MAPDRIVE_CAPTION, IDS_CANTCLOSEFILES_WARNING,
                                        MB_OK | MB_ICONERROR);
                                }
                            }
                        }
                        else
                        {
                            fRetry = TRUE;
                        }
                    }
                    break;

                // Errors caused by an invalid remote path
                case ERROR_BAD_DEV_TYPE:
                case ERROR_BAD_NET_NAME:
                case ERROR_BAD_NETPATH:
                    {

                        DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_ERR_INVALIDREMOTEPATH,
                            MB_OK | MB_ICONERROR, pdata->szPath);
                    }
                    break;

                // Provider is busy (e.g., initializing), so user should retry
                case ERROR_BUSY:
                    {
                        DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_ERR_INVALIDREMOTEPATH,
                            MB_OK | MB_ICONERROR);
                    }
                    break;
                //
                // Network problems
                //
                case ERROR_NO_NET_OR_BAD_PATH:
                case ERROR_NO_NETWORK:
                    {
                        DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_ERR_NONETWORK,
                            MB_OK | MB_ICONERROR);
                    }
                    break;

                // Share already mapped with different credentials
                case ERROR_SESSION_CREDENTIAL_CONFLICT:
                    {
                        DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION,
                            IDS_MND_ALREADYMAPPED, MB_OK | MB_ICONERROR);
                    }

                //
                // Errors that we (in theory) shouldn't get -- bad local name 
                // (i.e., format of drive name is invalid), user profile in a bad 
                // format, or a bad provider.  Problems here most likely indicate 
                // an NT system bug.  Also note that provider-specific errors 
                // (ERROR_EXTENDED_ERROR) and trust failures are lumped in here 
                // as well, since the below errors will display an "Unexpected 
                // Error" message to the user.
                //
                case ERROR_BAD_DEVICE:
                case ERROR_BAD_PROFILE:
                case ERROR_BAD_PROVIDER:
                default:
                    {
                        TCHAR szMessage[512];

                        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) *pdwLastError, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

                        ::DisplayFormatMessage(pdata->hwnd, IDS_ERR_CAPTION, IDS_MND_GENERICERROR, MB_OK|MB_ICONERROR, szMessage);
                    }
                    break;
                
            }
        }
    }

    return (*pdwLastError == NO_ERROR);
}


/*++

Routine Description:

    This routine verifies that the user wants to break a pre-existing
    connection to a drive.

Arguments:

    hWndDlg -- HWND of the Completion page
    lpDrive -- The name of the drive to disconnect
    lpShare -- The share to which the "freed" drive will be connected
    dwType  -- The connection error -- ERROR_ALREADY_ASSIGNED 
               or ERROR_DEVICE_ALREADY_REMEMBERED
    
Return Value:

    TRUE if the user wants to break the connection, FALSE otherwise

--*/

BOOL CMapNetProgress::ConfirmDisconnectDrive(HWND hWndDlg, LPCTSTR lpDrive, LPCTSTR lpShare, DWORD dwType)
{
    TCHAR   tszConfirmMessage[2 * MAX_PATH + MAX_STATIC] = {0};
    TCHAR   tszCaption[MAX_CAPTION + 1] = {0};
    TCHAR   tszConnection[MAX_PATH + 1] = {0};

    DWORD   dwLength = MAX_PATH;

    LoadString(g_hinst, IDS_ERR_CAPTION, tszCaption, ARRAYSIZE(tszCaption));

    //
    // Bug #143955 -- call WNetGetConnection here since with two instances of
    // the wizard open and on the Completion page with the same suggested
    // drive, the Completion combo box doesn't contain info about the connected
    // share once "Finish" is selected on one of the two wizards.
    //
    DWORD dwRes = WNetGetConnection(lpDrive, tszConnection, &dwLength);
    if ((NO_ERROR == dwRes) || (ERROR_CONNECTION_UNAVAIL == dwRes))
    {
        //
        // Load the appropriate propmt string, based on the type of 
        // error we encountered
        //
        FormatMessageString((dwType == ERROR_ALREADY_ASSIGNED ? IDS_ERR_ALREADYASSIGNED : IDS_ERR_ALREADYREMEMBERED), 
                                        tszConfirmMessage, ARRAYSIZE(tszConfirmMessage), lpDrive, tszConnection, lpShare);

        return (MessageBox(hWndDlg, tszConfirmMessage, tszCaption, MB_YESNO | MB_ICONWARNING)
            == IDYES);
    }
    else
    {
        // The connection was invalid. Don't overwrite it just in case
        return FALSE;
    }
}


/*++

Routine Description:

    This routine verifies that the user wants to break a pre-existing
    connection to a drive where the user has open files/connections

Arguments:

    hWndDlg -- HWND of the Completion dialog

Return Value:

    TRUE if the user wants to break the connection, FALSE otherwise    

--*/

BOOL CMapNetProgress::ConfirmDisconnectOpenFiles(HWND hWndDlg)
{
    TCHAR tszCaption[MAX_CAPTION + 1] = {0};
    TCHAR tszBuffer[MAX_STATIC + 1] = {0};

    LoadString(g_hinst, IDS_ERR_OPENFILES, tszBuffer, ARRAYSIZE(tszBuffer));
    LoadString(g_hinst, IDS_ERR_CAPTION, tszCaption, ARRAYSIZE(tszCaption));

    return (MessageBox(hWndDlg, tszBuffer, tszCaption, MB_YESNO | MB_ICONWARNING) == IDYES);
}

// CConnectAsDlg Implementation - Windows NT only
// ----------------------------------------------

// Little "username and password" dialog for connecting as a different user - NT only
INT_PTR CConnectAsDlg::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
    HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CConnectAsDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Fill in the user name and password
    HWND hwndCredential = GetDlgItem(hwnd, IDC_CREDENTIALS);
    SendMessage(hwndCredential, CRM_SETUSERNAME, NULL, (LPARAM) m_pszDomainUser);
    SendMessage(hwndCredential, CRM_SETPASSWORD, NULL, (LPARAM) m_pszPassword);
    SendMessage(hwndCredential, CRM_SETUSERNAMEMAX, m_cchDomainUser - 1, NULL);
    SendMessage(hwndCredential, CRM_SETPASSWORDMAX, m_cchPassword - 1, NULL);

    TCHAR szUser[MAX_USER + 1];
    TCHAR szDomain[MAX_DOMAIN + 1];
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];

    DWORD cchUser = ARRAYSIZE(szUser);
    DWORD cchDomain = ARRAYSIZE(szDomain);
    ::GetCurrentUserAndDomainName(szUser, &cchUser, szDomain, &cchDomain);
    ::MakeDomainUserString(szDomain, szUser, szDomainUser, ARRAYSIZE(szDomainUser));

    TCHAR szMessage[256];
    FormatMessageString(IDS_CONNECTASUSER, szMessage, ARRAYSIZE(szMessage), szDomainUser);

    SetWindowText(GetDlgItem(hwnd, IDC_MESSAGE), szMessage);

    if (!IsComputerInDomain())
        EnableWindow(GetDlgItem(hwnd, IDC_BROWSE), FALSE);

    return FALSE;
}

BOOL CConnectAsDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_BROWSE:
            {
                // User wants to look up a username
                TCHAR szUser[MAX_USER + 1];
                TCHAR szDomain[MAX_DOMAIN + 1];
                if (S_OK == ::BrowseForUser(hwnd, szUser, ARRAYSIZE(szUser), 
                    szDomain, ARRAYSIZE(szDomain)))
                {
                    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
                    ::MakeDomainUserString(szDomain, szUser, szDomainUser,
                        ARRAYSIZE(szDomainUser));

                    // Ok clicked and buffers valid
                    SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_SETUSERNAME, NULL, (LPARAM) szDomainUser);
                }
            }
            return TRUE;

        case IDOK:
            // TODO: Figure out about the -1 thing here...
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETUSERNAME, (WPARAM) m_cchDomainUser - 1, (LPARAM) m_pszDomainUser);
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETPASSWORD, (WPARAM) m_cchPassword - 1, (LPARAM) m_pszPassword);
            // fall through

        case IDCANCEL:
            EndDialog(hwnd, id);
            return TRUE;
    }
    return FALSE;
}

// ----------------------------------------------

// This function creates the Shared Folder Wizard.
// Return Value:
//  Returns WN_SUCCESS if the drive connected with no problem or 
//  RETCODE_CANCEL (0xFFFFFFFF) if the user cancels the Wizard or there 
//  is an unexplained/unrecoverable error

STDAPI_(DWORD) NetPlacesWizardDoModal(CONNECTDLGSTRUCTW *pConnDlgStruct, NETPLACESWIZARDTYPE npwt, BOOL fIsROPath)
{
    DWORD dwReturn = RETCODE_CANCEL;
    HRESULT hrInit = SHCoInitialize();
    if (SUCCEEDED(hrInit))
    {
        INITCOMMONCONTROLSEX iccex = {0};
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC = ICC_LISTVIEW_CLASSES;
        InitCommonControlsEx(&iccex);

        CredUIInitControls();
        LinkWindow_RegisterClass();

        // See if we're already running
        TCHAR szCaption[256];
        LoadString(g_hinst, IDS_MAPDRIVE_CAPTION, szCaption, ARRAYSIZE(szCaption));
        CEnsureSingleInstance ESI(szCaption);

        if (!ESI.ShouldExit())
        {
            CMapNetDrivePage page(pConnDlgStruct, &dwReturn);

            PROPSHEETPAGE psp = {0};
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.hInstance = g_hinst;
            psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_MND_PAGE);
            page.SetPropSheetPageMembers(&psp);
            HPROPSHEETPAGE hpage = CreatePropertySheetPage(&psp);

            PROPSHEETHEADER  psh = {0};
            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE | PSH_NOAPPLYNOW;
            psh.pszCaption = szCaption;
            psh.hwndParent = pConnDlgStruct->hwndOwner;
            psh.nPages = 1;
            psh.nStartPage = 0;
            psh.phpage = &hpage;
            PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_PSW));
        }
        SHCoUninitialize(hrInit);
    }
    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\netpage.cpp ===
#include "stdafx.h"
#include "netpage.h"
#pragma hdrstop


CNetworkUserWizardPage::CNetworkUserWizardPage(CUserInfo* pUserInfo) :
    m_pUserInfo(pUserInfo)
{
}

INT_PTR CNetworkUserWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
    }

    return FALSE;
}

BOOL CNetworkUserWizardPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, IDC_USER), MAX_USER);
    Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);
    return TRUE;
}

BOOL CNetworkUserWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
        {
            if (m_pUserInfo->m_psid != NULL)
            {
                LocalFree(m_pUserInfo->m_psid);
                m_pUserInfo->m_psid = NULL;
            }
            SetWizardButtons(hwnd, GetParent(hwnd));
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
        }
        return TRUE;

        case PSN_WIZNEXT:
        {
            // Read in the network user name and domain name
            if (FAILED(GetUserAndDomain(hwnd)))
            {
                // We don't have both!
                DisplayFormatMessage(hwnd, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_USR_NETUSERNAME_ERROR,
                    MB_OK | MB_ICONERROR);

                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            else
            {
                if (::UserAlreadyHasPermission(m_pUserInfo, hwnd))
                {
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
                }
                else
                {
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}

BOOL CNetworkUserWizardPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_BROWSE_BUTTON:
        {
            // Launch object picker to find a network account to give permissions to
            TCHAR szUser[MAX_USER + 1];
            TCHAR szDomain[MAX_DOMAIN + 1];
        
            if (S_OK == ::BrowseForUser(hwnd, szUser, ARRAYSIZE(szUser), szDomain, ARRAYSIZE(szDomain)))
            {
                SetDlgItemText(hwnd, IDC_USER, szUser);
                SetDlgItemText(hwnd, IDC_DOMAIN, szDomain);
            }
            return TRUE;
        }

        case IDC_USER:
        {
            if (codeNotify == EN_CHANGE)
            {
                SetWizardButtons(hwnd, GetParent(hwnd));
            }
            break;
        }
    }

    return FALSE;
}

void CNetworkUserWizardPage::SetWizardButtons(HWND hwnd, HWND hwndPropSheet)
{
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    DWORD dwUNLength = GetWindowTextLength(hwndUsername);
    PropSheet_SetWizButtons(hwndPropSheet, (dwUNLength == 0) ? 0 : PSWIZB_NEXT);
}

HRESULT CNetworkUserWizardPage::GetUserAndDomain(HWND hwnd)
{
    CWaitCursor cur;
    HRESULT hr = S_OK;

    // This code checks to ensure the user isn't trying
    // to add a well-known group like Everyone! This is bad
    // If the SID isn't read here, it is read in in CUserInfo::ChangeLocalGroup


    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];

    FetchText(hwnd, IDC_USER, m_pUserInfo->m_szUsername, ARRAYSIZE(m_pUserInfo->m_szUsername));
    FetchText(hwnd, IDC_DOMAIN, m_pUserInfo->m_szDomain, ARRAYSIZE(m_pUserInfo->m_szDomain));

    // If the username doesn't already contain a domain and the domain specified in blank
    if ((NULL == StrChr(m_pUserInfo->m_szUsername, TEXT('\\'))) && (0 == m_pUserInfo->m_szDomain[0]))
    {
        // Assume local machine for the domain
        DWORD cchName = ARRAYSIZE(m_pUserInfo->m_szDomain);
        
        if (!GetComputerName(m_pUserInfo->m_szDomain, &cchName))
        {
            *(m_pUserInfo->m_szDomain) = 0;
        }
    }

    ::MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

#ifdef _0
    // Try to find the SID for this user
    DWORD cchDomain = ARRAYSIZE(m_pUserInfo->m_szDomain);
    hr = AttemptLookupAccountName(szDomainUser, &m_pUserInfo->m_psid, m_pUserInfo->m_szDomain, &cchDomain, &m_pUserInfo->m_sUse);
    if (SUCCEEDED(hr))
    {
        // Make sure this isn't a well-known group like 'Everyone'
        if (m_pUserInfo->m_sUse == SidTypeWellKnownGroup)
        {
            hr = E_FAIL;
        }
    }
    else
    {
        // Failed to get the user's SID, just use the names provided
        // We'll get their SID once we add them
        m_pUserInfo->m_psid = NULL;
        hr = S_OK;
    }

#endif 

    // We'll get their SID once we add them
    m_pUserInfo->m_psid = NULL;

    if (FAILED(hr))
    {
        LocalFree(m_pUserInfo->m_psid);
        m_pUserInfo->m_psid = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\netplace.cpp ===
#include "stdafx.h"
#include "netplace.h"
#include "msdasc.h"
#pragma hdrstop



CNetworkPlace::CNetworkPlace() :
    _pidl(NULL), _fSupportWebFolders(FALSE), _fIsWebFolder(FALSE), _fDeleteWebFolder(FALSE)
{
    _szTarget[0] = TEXT('\0');
    _szName[0] = TEXT('\0');
    _szDescription[0] = TEXT('\0');
}

// destructor - clean up our state
CNetworkPlace::~CNetworkPlace()
{
    _InvalidateCache();
}

void CNetworkPlace::_InvalidateCache()
{
    // web folders will create a shortcut to objects if we go through its binding
    // process, therefore when we attempt to invalidate our cache we should
    // clean up our mess.
    //
    // if the user has commited the change then we can/will keep the shortcut
    // around, otherwise we call the delete verb on it.

    if (_fIsWebFolder && _fDeleteWebFolder && _pidl)
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        HRESULT hr = SHBindToIDListParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            IContextMenu *pcm;
            hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_X_PPV_ARG(IContextMenu, NULL, &pcm));
            if (SUCCEEDED(hr))
            {
                CMINVOKECOMMANDINFO ici = {0};
                ici.cbSize = sizeof (ici);
                ici.fMask = CMIC_MASK_FLAG_NO_UI;
                ici.lpVerb = "Delete";
                ici.nShow = SW_SHOWNORMAL;

                hr = pcm->InvokeCommand(&ici);
                pcm->Release();
            }
            psf->Release();
        }
    }

    // now clean up the rest of our state.

    ILFree(_pidl);
    _pidl = NULL;

    _szTarget[0] = TEXT('\0');
    _szName[0] = TEXT('\0');
    _szDescription[0] = TEXT('\0');

    _fIsWebFolder = FALSE;
    _fDeleteWebFolder = FALSE;
}


HRESULT CNetworkPlace::SetTarget(HWND hwnd, LPCWSTR pszTarget, DWORD dwFlags)
{
    _InvalidateCache();

    HRESULT hr = S_OK;
    if (pszTarget)
    {
        // set our state accordingly
        _fSupportWebFolders = (dwFlags & NPTF_ALLOWWEBFOLDERS) != 0;

        // copy the URL and prepare for parsing
        StrCpyN(_szTarget, pszTarget, ARRAYSIZE(_szTarget));

        INT cchTarget = lstrlen(_szTarget)-1;
        if ((_szTarget[cchTarget] == L'\\') || (_szTarget[cchTarget] == '/'))
        {
            _szTarget[cchTarget] = TEXT('\0');
        }

        if (dwFlags & NPTF_VALIDATE)
        {
            // connecting to a server root or local path is not supported
            if (PathIsUNCServer(_szTarget) || PathGetDriveNumber(_szTarget) != -1)
            {
                hr = E_INVALIDARG;                            
            }
            else
            {
                // check the policy to see if we are setting this.
                if (PathIsUNC(_szTarget) && SHRestricted(REST_NONETCONNECTDISCONNECT))
                {
                    hr = E_INVALIDARG;
                }
                else
                {
                    hr = _IDListFromTarget(hwnd);
                }
            }

            if (FAILED(hr))
            {
                if (hwnd && !(dwFlags & NPTF_SILENT))
                {
                    ::DisplayFormatMessage(hwnd, 
                                            IDS_ANP_CAPTION, 
                                            PathIsUNCServer(_szTarget) ? IDS_PUB_ONLYSERVER:IDS_CANTFINDFOLDER, 
                                            MB_OK|MB_ICONERROR);
                }
                _InvalidateCache();
            }
        }
    }
    
    return hr;
}


HRESULT CNetworkPlace::SetName(HWND hwnd, LPCWSTR pszName)
{
    HRESULT hr = S_OK;

    if (!_fIsWebFolder)
    {
        // check to see if we are going to overwrite an existing place, if we
        // are then display a prompt and let the user choose.  if they answer
        // yes, then have at it!

        TCHAR szPath[MAX_PATH];
        if (hwnd && _IsPlaceTaken(pszName, szPath))
        {
            if (IDNO == ::DisplayFormatMessage(hwnd, 
                                               IDS_ANP_CAPTION , IDS_FRIENDLYNAMEINUSE, 
                                               MB_YESNO|MB_ICONQUESTION, 
                                               pszName))
            {
                hr = E_FAIL;        
            }
        }
    }

    // if we succeed the above then lets use the new name.

    if (SUCCEEDED(hr))
        StrCpyN(_szName, pszName, ARRAYSIZE(_szName));

    return hr;
}


HRESULT CNetworkPlace::SetDescription(LPCWSTR pszDescription)
{
    StrCpyN(_szDescription, pszDescription, ARRAYSIZE(_szDescription));
    return S_OK;    
}


// recompute the URL based on the new user/password information that 
// we were just given.

HRESULT CNetworkPlace::SetLoginInfo(LPCWSTR pszUser, LPCWSTR pszPassword)
{
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    TCHAR szUrlPath[INTERNET_MAX_PATH_LENGTH + 1];
    TCHAR szExtraInfo[MAX_PATH + 1];                  // Includes Port Number and download type (ASCII, Binary, Detect)

    URL_COMPONENTS urlComps = {0};
    urlComps.dwStructSize = sizeof(urlComps);
    urlComps.lpszHostName = szServer;
    urlComps.dwHostNameLength = ARRAYSIZE(szServer);
    urlComps.lpszUrlPath = szUrlPath;
    urlComps.dwUrlPathLength = ARRAYSIZE(szUrlPath);
    urlComps.lpszExtraInfo = szExtraInfo;
    urlComps.dwExtraInfoLength = ARRAYSIZE(szExtraInfo);

    //  WARNING - the ICU_DECODE/ICU_ESCAPE is a lossy roundtrip - ZekeL - 26-MAR-2001
    //  many escaped characters are not correctly identified and re-escaped.
    //  any characters that are reserved for URL parsing purposes
    //  will be interpreted as their parsing char (ie '/').
    BOOL fResult = InternetCrackUrl(_szTarget, 0, 0, &urlComps);
    if (fResult)
    {
        urlComps.lpszUserName = (LPTSTR) pszUser;
        urlComps.dwUserNameLength = (pszUser ? lstrlen(pszUser) : 0);
        urlComps.lpszPassword = (LPTSTR) pszPassword;
        urlComps.dwPasswordLength = (pszPassword ? lstrlen(pszPassword) : 0);

        DWORD cchSize = ARRAYSIZE(_szTarget);
        fResult = InternetCreateUrl(&urlComps, (ICU_ESCAPE | ICU_USERNAME), _szTarget, &cchSize);

        // if we have a cached IDList then lets ensure that we clear it up
        // so that we rebind and the FTP namespace gets a crack at it.

        if (fResult && _pidl)
        {
            ILFree(_pidl);
            _pidl = NULL;
        }
    }
    return fResult ? S_OK : HRESULT_FROM_WIN32(GetLastError());
}


HRESULT CNetworkPlace::GetIDList(HWND hwnd, LPITEMIDLIST *ppidl)
{
    HRESULT hr = _IDListFromTarget(hwnd);
    if (SUCCEEDED(hr))
    {
        hr = SHILClone(_pidl, ppidl);
    }
    return hr;
}


HRESULT CNetworkPlace::GetObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = _IDListFromTarget(hwnd);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, riid, _pidl, ppv);  
    }
    return hr;
}

HRESULT CNetworkPlace::GetName(LPWSTR pszBuffer, int cchBuffer)
{
    HRESULT hr = _IDListFromTarget(NULL);
    if (SUCCEEDED(hr))
    {
        StrCpyN(pszBuffer, _szName, cchBuffer);
        hr = S_OK;
    }
    return hr;
}


// check to see if we are going to overwrite a network place

BOOL CNetworkPlace::_IsPlaceTaken(LPCTSTR pszName, LPTSTR pszPath)
{
    BOOL fOverwriting = FALSE;

    SHGetSpecialFolderPath(NULL, pszPath, CSIDL_NETHOOD, TRUE);
    PathCombine(pszPath, pszPath, pszName);
    
    IShellFolder *psf;
    HRESULT hr = SHGetDesktopFolder(&psf);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;  
        if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, pszPath, NULL, &pidl, NULL)))
        {
            // we think we are going to overwrite an existing net place, so lets
            // check first to see if the place which is there is not actually
            // pointing at our new target.  if its is then we can just
            // ignore all of this.

            TCHAR szTarget[INTERNET_MAX_URL_LENGTH];
            hr = _GetTargetPath(pidl, szTarget, ARRAYSIZE(szTarget));
            if (FAILED(hr) || (0 != StrCmpI(szTarget, _szTarget)))
            {
                fOverwriting = TRUE;
            }
            ILFree(pidl);
        }
        psf->Release();
    }

    return fOverwriting;
}


// handle creating the web folders IDLIST for this item.  we check with the
// rosebud binder to find out if this scheme is supported, if so then
// we attempt to have the Web Folders code crack the URL

static const BYTE c_pidlWebFolders[] = 
{
    0x14,0x00,0x1F,0x0F,0xE0,0x4F,0xD0,0x20,
    0xEA,0x3A,0x69,0x10,0xA2,0xD8,0x08,0x00,
    0x2B,0x30,0x30,0x9D,0x14,0x00,0x2E,0x00,
    0x00,0xDF,0xEA,0xBD,0x65,0xC2,0xD0,0x11,
    0xBC,0xED,0x00,0xA0,0xC9,0x0A,0xB5,0x0F,
    0x00,0x00
};

HRESULT CNetworkPlace::_TryWebFolders(HWND hwnd)
{
    // lets see if Rosebud can handle this scheme item by checking the
    // scheme and seeing if the rosebud binder can handle it.
    TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH + 1];
    DWORD cchScheme = ARRAYSIZE(szScheme);
    HRESULT hr = UrlGetPart(_szTarget, szScheme, &cchScheme, URL_PART_SCHEME, 0);
    if (SUCCEEDED(hr))
    {
        IRegisterProvider *prp;
        hr = CoCreateInstance(CLSID_RootBinder, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IRegisterProvider, &prp));
        if (SUCCEEDED(hr))
        {
            // let the web folders code have a go at creating a link to this storage,
            // the IDLIST we generate points to the folder inside My Computer (hidden)

            CLSID clsidOut;
            hr =  prp->GetURLMapping(szScheme, 0, &clsidOut);
            if (hr == S_OK)
            {
                IShellFolder *psf;
                hr = SHBindToObject(NULL, IID_IShellFolder, (LPCITEMIDLIST)c_pidlWebFolders, (void**)&psf);
                if (SUCCEEDED(hr))
                {
                    IBindCtx *pbc;
                    hr = CreateBindCtx(NULL, &pbc);
                    if (SUCCEEDED(hr))
                    {
                        BIND_OPTS bo = {sizeof(bo), 0, STGM_CREATE};
                        hr = pbc->SetBindOptions(&bo);
                        if (SUCCEEDED(hr))
                        {
                            // we need to pase NULL hWnd to this so that Web Folders doesn't display any
                            // UI, in particular its ever so useful NULL error message box... mumble mumble

                            LPITEMIDLIST pidl;
                            hr = psf->ParseDisplayName(NULL, pbc, _szTarget, NULL, &pidl, NULL);
                            if (SUCCEEDED(hr))
                            {
                                ASSERT(!_pidl);
                                hr = SHILCombine((LPCITEMIDLIST)c_pidlWebFolders, pidl, &_pidl);
                                ILFree(pidl);

                                _fDeleteWebFolder = TRUE;           // we now have the magic web folders link (clean it up)
                            }
                        }

                        pbc->Release();
                    }
                    psf->Release();
                }
            }
            else
            {
                hr = E_FAIL;
            }
            prp->Release();
        }
    }
    return hr;
}



// dereference a link and get the target path

HRESULT CNetworkPlace::_GetTargetPath(LPCITEMIDLIST pidl, LPTSTR pszPath, int cchPath)
{
    LPITEMIDLIST pidlTarget;
    HRESULT hr = SHGetTargetFolderIDList(pidl, &pidlTarget);
    if (SUCCEEDED(hr))
    {
        SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, pszPath, cchPath, NULL);
        ILFree(pidlTarget);
    }
    return hr;
 }


// create an IDLIST for the target that we have, this code attempts to parse the name and
// then set our state for the item.  if we fail to parse then we attempt to have Web Folders
// look at it - this most common scenario for this will be the DAV RDR failing because
// the server isn't a DAV store, so instead we try Web Folders to handle WEC etc.

HRESULT CNetworkPlace::_IDListFromTarget(HWND hwnd)
{
    HRESULT hr = S_OK;
    if (!_pidl)
    {
        if (_szTarget[0])
        {
            _fIsWebFolder = FALSE;                      // not a web folder

            BINDCTX_PARAM rgParams[] = 
            { 
                { STR_PARSE_PREFER_FOLDER_BROWSING, NULL},
                { L"BUT NOT WEBFOLDERS", NULL},
            };
            IBindCtx *pbc;
            hr = BindCtx_RegisterObjectParams(NULL, rgParams, ARRAYSIZE(rgParams), &pbc);
            if (SUCCEEDED(hr))
            {
                IBindCtx *pbcWindow;
                hr = BindCtx_RegisterUIWindow(pbc, hwnd, &pbcWindow);
                if (SUCCEEDED(hr))
                {
                    SFGAOF sfgao;
                    hr = SHParseDisplayName(_szTarget, pbcWindow, &_pidl, SFGAO_FOLDER, &sfgao);

                    //  if we parsed something that turns out to not
                    //  be a folder, we want to throw it away
                    if (SUCCEEDED(hr) && !(sfgao & SFGAO_FOLDER))
                    {   
                        ILFree(_pidl);
                        _pidl = 0;
                        hr = E_FAIL;
                    }

                    // if that failed, its is a HTTP/HTTPS and we have web folders support then lets try
                    // and fall back to the old behaviour.

                    if (FAILED(hr) && _fSupportWebFolders)
                    {
                        DWORD scheme = GetUrlScheme(_szTarget);
                        if (scheme == URL_SCHEME_HTTP || scheme == URL_SCHEME_HTTPS)
                        {
                            switch (hr)
                            {
#if 0
                                case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
                                case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
                                case HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME):
                                case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
#endif
                                case HRESULT_FROM_WIN32(ERROR_CANCELLED):
                                    break;

                                default:
                                {
                                    hr = _TryWebFolders(hwnd);
                                    if (SUCCEEDED(hr))
                                    {
                                        _fIsWebFolder = TRUE;
                                    }
                                }
                            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        // given that we may have translated the name above for the parse
                        // to work, lets read back the name we used into our _szTarget.
                        SHGetNameAndFlags(_pidl, SHGDN_FORPARSING, _szTarget, ARRAYSIZE(_szTarget), NULL);
                    }
                    pbcWindow->Release();
                }
    
                // compute the place name for the location we have hit, this includes reusing
                // any places we have already created.

                if (SUCCEEDED(hr) && !_szName[0])
                {
                    SHGetNameAndFlags(_pidl, SHGDN_NORMAL, _szName, ARRAYSIZE(_szName), NULL);

                    TCHAR szPath[MAX_PATH];
                    if (!_fIsWebFolder && _IsPlaceTaken(_szName, szPath))
                    {
                        PathYetAnotherMakeUniqueName(szPath, szPath, NULL, NULL);
                        StrCpyN(_szName, PathFindFileName(szPath), ARRAYSIZE(_szName));     // update our state
                    }
                }
                pbc->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}


// handle creating the network place shortcut

HRESULT CNetworkPlace::CreatePlace(HWND hwnd, BOOL fOpen)
{
    HRESULT hr = _IDListFromTarget(hwnd);
    if (SUCCEEDED(hr))
    {
        // web folders already have their links created, therefore we can ignore this
        // whole process for them, and instead fall back to just executing their link.
        // 
        // for regular folders though we must attempt to find a unique name and create
        // the link, or if the link already exists that we can use then just open it.

        if (!_fIsWebFolder)
        {
            IShellLink *psl;
            hr = CoCreateInstance(CLSID_FolderShortcut, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(_pidl);

                if (SUCCEEDED(hr))
                    hr = psl->SetDescription(_szDescription[0] ? _szDescription:_szTarget);

                if (SUCCEEDED(hr))
                {
                    IPersistFile *ppf;
                    hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                    if (SUCCEEDED(hr))
                    {
                        // get the name to the shortcut, we assume that this is unique

                        TCHAR szPath[MAX_PATH];
                        SHGetSpecialFolderPath(NULL, szPath, CSIDL_NETHOOD, TRUE);
                        PathCombine(szPath, szPath, _szName);

                        hr = ppf->Save(szPath, TRUE);
                        ppf->Release();
                    }
                }
                psl->Release();
            }
        }
        else
        {
            // this is the web folder case, so we now need to set the display
            // name for this guy.  note that we don't have any control over
            // the description text we are going to be seeing.

            IShellFolder *psf;
            LPCITEMIDLIST pidlLast;
            hr = SHBindToIDListParent(_pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlNew;
                hr = psf->SetNameOf(hwnd, pidlLast, _szName, SHGDN_INFOLDER, &pidlNew);
                if (SUCCEEDED(hr))
                {
                    _fDeleteWebFolder = FALSE;
                    //Web folders will return S_FALSE with bogus pidlNew if _szName is the same as the current name
                    if (S_OK == hr)
                    {
                        ILFree(_pidl);
                        hr = SHILCombine((LPCITEMIDLIST)c_pidlWebFolders, pidlNew, &_pidl);
                    }
                }
                psf->Release();
            }
        }
    
        // now open the target if thats what they asked for

        if (SUCCEEDED(hr) && fOpen)
        {
            LPITEMIDLIST pidlNetPlaces;
            hr = SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidlNetPlaces);
            if (SUCCEEDED(hr))
            {
                IShellFolder *psf;
                hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlNetPlaces, &psf));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = psf->ParseDisplayName(hwnd, NULL, _szName, NULL, &pidl, NULL);
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlToOpen;
                        hr = SHILCombine(pidlNetPlaces, pidl, &pidlToOpen);
                        if (SUCCEEDED(hr))
                        {
                            BrowseToPidl(pidlToOpen);
                            ILFree(pidlToOpen);
                        }
                        ILFree(pidl);
                    }
                    psf->Release();
                }
                ILFree(pidlNetPlaces);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\netplace.h ===
#define NPTF_VALIDATE           0x00000001      // => validate the URL
#define NPTF_ALLOWWEBFOLDERS    0x00000002      // => allow binding to Web Folder locations
#define NPTF_SILENT             0x00000004      // => silent binding - no errors

class CNetworkPlace
{
public:
    CNetworkPlace();
    ~CNetworkPlace();

    // INetworkPlace
    HRESULT SetTarget(HWND hwnd, LPCWSTR pszTarget, DWORD dwFlags);
    HRESULT SetLoginInfo(LPCWSTR pszUser, LPCWSTR pszPassword);
    HRESULT SetName(HWND hwnd, LPCWSTR pszName);
    HRESULT SetDescription(LPCWSTR pszDescription);

    HRESULT GetTarget(LPWSTR pszBuffer, int cchBuffer)  
        { StrCpyN(pszBuffer, _szTarget, cchBuffer); return S_OK; }
    
    HRESULT GetName(LPWSTR pszBuffer, int cchBuffer);
    HRESULT GetIDList(HWND hwnd, LPITEMIDLIST *ppidl);
    HRESULT GetObject(HWND hwnd, REFIID riid, void **ppv);
    HRESULT CreatePlace(HWND hwnd, BOOL fOpen);

private:
    void _InvalidateCache();
    HRESULT _IDListFromTarget(HWND hwnd);
    HRESULT _TryWebFolders(HWND hwnd);
    BOOL _IsPlaceTaken(LPCTSTR pszName, LPTSTR pszPath);
    HRESULT _GetTargetPath(LPCITEMIDLIST pidl, LPTSTR pszPath, int cchPath);    

    LPITEMIDLIST _pidl;
    TCHAR _szTarget[INTERNET_MAX_URL_LENGTH];
    TCHAR _szName[MAX_PATH];
    TCHAR _szDescription[MAX_PATH];

    BOOL _fSupportWebFolders;           // apply hacks    
    BOOL _fIsWebFolder;                 // special case certain operations for Web Folders (office compat)
    BOOL _fDeleteWebFolder;             // if this is set then we must delete the Web Folder
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\password.h ===
#ifndef PASSWORD_H_INCLUDED
#define PASSWORD_H_INCLUDED


// password dialog (used for users cpl)

class CPasswordDialog: public CDialog
{
public:
    CPasswordDialog(TCHAR* pszResourceName, TCHAR* pszDomainUser, DWORD cchDomainUser, 
        TCHAR* pszPassword, DWORD cchPassword, DWORD dwError): 
        m_pszResourceName(pszResourceName),
        m_pszDomainUser(pszDomainUser),
        m_cchDomainUser(cchDomainUser),
        m_pszPassword(pszPassword),
        m_cchPassword(cchPassword),
        m_dwError(dwError)
        {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    // Data
    TCHAR* m_pszResourceName;

    TCHAR* m_pszDomainUser;
    DWORD m_cchDomainUser;

    TCHAR* m_pszPassword;
    DWORD m_cchPassword;

    DWORD m_dwError;
};


// base class containing common stuff for the password prop page and set password dialog

class CPasswordPageBase
{
public:
    CPasswordPageBase(CUserInfo* pUserInfo): m_pUserInfo(pUserInfo) {}

protected:
    // Helpers
    BOOL DoPasswordsMatch(HWND hwnd);

protected:
    // Data
    CUserInfo* m_pUserInfo;
};

class CPasswordWizardPage: public CPropertyPage, public CPasswordPageBase
{
public:
    CPasswordWizardPage(CUserInfo* pUserInfo): CPasswordPageBase(pUserInfo) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
};

class CChangePasswordDlg: public CDialog, public CPasswordPageBase
{
public:
    CChangePasswordDlg(CUserInfo* pUserInfo): CPasswordPageBase(pUserInfo) {}

    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
};



#endif //!PASSWORD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\pubcopy.cpp ===
#include "stdafx.h"
#include "netplace.h"
#include "pubwiz.h"
#pragma hdrstop


// IEnumShellItems - used to expose the transfer list as a set of IShellItems

class CTransferItemEnum : public IEnumShellItems
{
public:
    CTransferItemEnum(LPCTSTR pszPath, IStorage *pstg, CDPA<TRANSFERITEM> *_pdpaItems);
    ~CTransferItemEnum();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Next)(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt)
        { return S_OK; }
    STDMETHOD(Reset)()
        { _iItem = 0; return S_OK; }
    STDMETHOD(Clone)(IEnumShellItems **ppenum)
        { return S_OK; }

private:
    long _cRef;

    TCHAR _szPath[MAX_PATH];
    int _cchPath;
    IStorage *_pstg;
    CDPA<TRANSFERITEM> *_pdpaItems;

    int _iItem;

    BOOL _GetNextItem(TRANSFERITEM **ppti);
    LPTSTR _GetNextComponent(LPTSTR pszPath);
};


// A IShellItem that represents an IStorage to the copy engine - limited functionality

class CTransferStgItem : public IShellItem
{
public:
    CTransferStgItem(LPCTSTR pszPath, int cchName, IStorage *pstg, CDPA<TRANSFERITEM> *pdpaItems);
    ~CTransferStgItem();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IShellItem
    STDMETHODIMP BindToHandler(IBindCtx *pbc, REFGUID rguidHandler, REFIID riid, void **ppv);
    STDMETHODIMP GetParent(IShellItem **ppsi)
        { return E_NOTIMPL; }
    STDMETHODIMP GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName);
    STDMETHODIMP GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags);        
    STDMETHODIMP Compare(IShellItem *psi, SICHINTF hint, int *piOrder)
        { return E_NOTIMPL; }

private:
    long _cRef;

    TCHAR _szPath[MAX_PATH];
    IStorage *_pstg;
    CDPA<TRANSFERITEM> *_pdpaItems;
};


// IShellItem implementation that will return a storage to anybody
// querying it.  We generate the in folder name from the path
// we are initialized from, and the attributes are fixed for the items.

CTransferStgItem::CTransferStgItem(LPCTSTR pszPath, int cchName, IStorage *pstg, CDPA<TRANSFERITEM> *pdpaItems) :
    _cRef(1), _pstg(pstg), _pdpaItems(pdpaItems)
{
    StrCpyN(_szPath, pszPath, (int)min(ARRAYSIZE(_szPath), cchName));
    _pstg->AddRef();
}

CTransferStgItem::~CTransferStgItem()
{
    _pstg->Release();
}

ULONG CTransferStgItem::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTransferStgItem::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTransferStgItem::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CTransferStgItem, IShellItem),    // IID_IShellItem
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CTransferStgItem::BindToHandler(IBindCtx *pbc, REFGUID rguidHandler, REFIID riid, void **ppv)
{
    HRESULT hr = E_UNEXPECTED;
    if (rguidHandler == BHID_StorageEnum)
    {
        CTransferItemEnum *ptie = new CTransferItemEnum(_szPath, _pstg, _pdpaItems);
        if (ptie)
        {
            hr = ptie->QueryInterface(riid, ppv);
            ptie->Release(); 
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CTransferStgItem::GetDisplayName(SIGDN sigdnName, LPOLESTR *ppszName)
{
    HRESULT hr = E_UNEXPECTED;
    if ((sigdnName == SIGDN_PARENTRELATIVEPARSING) ||
        (sigdnName == SIGDN_PARENTRELATIVEEDITING) ||
        (sigdnName == SIGDN_PARENTRELATIVEFORADDRESSBAR))
    {
        hr = SHStrDupW(PathFindFileName(_szPath), ppszName);
    }
    return hr;
}

HRESULT CTransferStgItem::GetAttributes(SFGAOF sfgaoMask, SFGAOF *psfgaoFlags)
{
    *psfgaoFlags = SFGAO_STORAGE;
    return S_OK;
}


// enumerator, this takes a DPA and returns IShellItems for the streams and
// storages it finds.   the storages are contructed dynamically based on 
// the destination paths specified.

CTransferItemEnum::CTransferItemEnum(LPCTSTR pszPath, IStorage *pstg, CDPA<TRANSFERITEM> *pdpaItems) :
    _cRef(1), _iItem(0), _pstg(pstg), _pdpaItems(pdpaItems)
{
    StrCpyN(_szPath, pszPath, ARRAYSIZE(_szPath));
    _cchPath = lstrlen(_szPath);
    _pstg->AddRef();
}

CTransferItemEnum::~CTransferItemEnum()
{
    _pstg->Release();
}

ULONG CTransferItemEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTransferItemEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTransferItemEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CTransferItemEnum, IEnumShellItems),    // IID_IEnumShellItems
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// next enumerator for the items that we have in the DPA, this works by comparing the root
// that we have against the items in our list.   those who match that criteria can then

BOOL CTransferItemEnum::_GetNextItem(TRANSFERITEM **ppti)
{
    BOOL fResult = FALSE;
    if (_iItem < _pdpaItems->GetPtrCount())
    {
        TRANSFERITEM *pti = _pdpaItems->GetPtr(_iItem);
        if (StrCmpNI(_szPath, pti->szFilename, _cchPath) == 0)
        {
            *ppti = pti;
            fResult = TRUE;
        }
        _iItem++;
    }
    return fResult;
}

LPTSTR CTransferItemEnum::_GetNextComponent(LPTSTR pszPath)
{
    LPTSTR pszResult = pszPath;

    if (*pszResult == TEXT('\\'))
        pszResult++;

    while (*pszResult && (*pszResult != TEXT('\\')))
        pszResult++;

    if (*pszResult == TEXT('\\'))
        pszResult++;

    return pszResult;        
}

HRESULT CTransferItemEnum::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    if (!celt || !rgelt)
        return E_INVALIDARG;                    // fail bad mojo

    if (pceltFetched)
        *pceltFetched = 0;                  
    
    HRESULT hr = S_FALSE;
    while (SUCCEEDED(hr) && (celt > 0) && (_iItem < _pdpaItems->GetPtrCount()))
    {
        // we still have some space in the buffer, and we haven't returned all
        // the items yet, so we can still itterate over the data set that we have
        // we have.

        TRANSFERITEM *pti;
        if (_GetNextItem(&pti))
        {
            TCHAR szFilename[MAX_PATH];
            StrCpy(szFilename, pti->szFilename);

            // storage or a stream, storages have trailing component names, if we
            // dont have that then we can assume its a create and pass out a IShellItem.

            LPTSTR pszNextComponent = _GetNextComponent(szFilename+_cchPath);
            if (!*pszNextComponent)
            {
                // create a wrapped shell item so that we can return the compressed
                // object back to the caller.

                if (!pti->psi)
                {
                    hr = SHCreateShellItem(NULL, NULL, pti->pidl, &pti->psi);            
                    if (SUCCEEDED(hr) && pti->fResizeOnUpload)
                    {
                        IImageRecompress *pir;
                        hr = CoCreateInstance(CLSID_ImageRecompress, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImageRecompress, &pir));
                        if (SUCCEEDED(hr))
                        {
                            IStream *pstrm;
                            hr = pir->RecompressImage(pti->psi, pti->cxResize, pti->cyResize, pti->iQuality, _pstg, &pstrm);
                            if (hr == S_OK)
                            {
                                STATSTG stat;
                                hr = pstrm->Stat(&stat, STATFLAG_DEFAULT);
                                if (SUCCEEDED(hr))
                                {
                                    IDynamicStorage *pdstg;
                                    hr = _pstg->QueryInterface(IID_PPV_ARG(IDynamicStorage, &pdstg));
                                    if (SUCCEEDED(hr))
                                    {
                                        IShellItem *psi;
                                        hr = pdstg->BindToItem(stat.pwcsName, IID_PPV_ARG(IShellItem, &psi));
                                        if (SUCCEEDED(hr))
                                        {
                                            IUnknown_Set((IUnknown**)&pti->psi, psi);
                                        }
                                        pdstg->Release();
                                    }
                                    CoTaskMemFree(stat.pwcsName);
                                }
                                pstrm->Release();
                            }
                            pir->Release();
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = pti->psi->QueryInterface(IID_PPV_ARG(IShellItem, rgelt));
                    if (SUCCEEDED(hr))
                    {
                        rgelt++;
                        celt--;
                        if (pceltFetched)
                        {
                            (*pceltFetched)++;
                        }
                    }
                }
            }
            else
            {
                // Its a storage, so lets create a dummy IShellItem that represents this
                // and pass it to the caller.  Then walk forward until we have skipped
                // all the items in this storage.

                int cchName = (int)(pszNextComponent-szFilename);
                CTransferStgItem *ptsi = new CTransferStgItem(szFilename, cchName, _pstg, _pdpaItems);
                if (ptsi)
                {
                    hr = ptsi->QueryInterface(IID_PPV_ARG(IShellItem, rgelt++));
                    if (SUCCEEDED(hr))
                    {
                        celt--;
                        if (pceltFetched)
                        {
                            (*pceltFetched)++;
                        }
                    }
                    ptsi->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                // Skip the children of this storage

                TRANSFERITEM *ptiNext;
                while (_GetNextItem(&ptiNext))
                {
                    if (0 != StrCmpNI(ptiNext->szFilename, szFilename, cchName))
                    {
                        _iItem--;               // we hit an item that doesn't match the criteria
                        break;   
                    }
                }
            }
        }
    }
    return hr;
}


// all this code relates to using the RDR to transfer items to the destination site
// rather than using the manifest to handle the transfer via a HTTP POST.

class CTransferThread : IUnknown
{
public:
    CTransferThread();

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT BeginTransfer(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
    
protected:
    ~CTransferThread();
    
    static DWORD CALLBACK s_ThreadProc(void *pv);

    DWORD _ThreadProc();
    HRESULT _FixUpDestination();
    HRESULT _InitSourceEnum(IEnumShellItems **ppesi);
    HRESULT _SetProgress(DWORD dwCompleted, DWORD dwTotal);
    
    LONG _cRef;
    TRANSFERINFO _ti;
    CDPA<TRANSFERITEM> _dpaItems;

    IStream *_pstrmSink;

    CNetworkPlace _np;
};


// Main transfer thread object, this calls the shell item processor to copy
// items using the manifest we received back from the site.

CTransferThread::CTransferThread() :
    _cRef(1)
{
    DllAddRef();
}

CTransferThread::~CTransferThread()
{
    ATOMICRELEASE(_pstrmSink);
    _dpaItems.DestroyCallback(_FreeTransferItems, NULL);
    DllRelease();
}

ULONG CTransferThread::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CTransferThread::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTransferThread::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// handle fixing up the server information to the correct site, this handles the case
// wher ethe server name is www.msnusers.com and we need to redirect to the correct place.

HRESULT CTransferThread::_FixUpDestination()
{
    LPCTSTR pszMSN = TEXT("http://www.msnusers.com/");
    int cchMSN = lstrlen(pszMSN);

    HRESULT hr = S_OK;
    if (0 == StrCmpNI(_ti.szFileTarget, pszMSN, cchMSN))
    {
        // this is the MSN server, therefore we need to perform
        // a PROPFIND to the root of the community to force it to create
        // the folders that we are going to be publishing into, if we don't
        // do this then we end up getting a file not found error back from the
        // DAV RDR - we should get the MSN dudes to fix this so we don't need to
        // keep this around.

        WCHAR szURL[INTERNET_MAX_URL_LENGTH];
        StrCpy(szURL, _ti.szFileTarget);
        *StrChr(szURL + cchMSN, L'/') = L'\0';

        CNetworkPlace np;
        hr = np.SetTarget(_ti.hwnd, _ti.szFileTarget, NPTF_SILENT|NPTF_VALIDATE);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = np.GetIDList(_ti.hwnd, &pidl);
            if (SUCCEEDED(hr))
            {
                ILFree(pidl);
            }
        }
    }
    return hr;
}


// being the transfer of items, by creating a background thread which handles the upload.

HRESULT CTransferThread::BeginTransfer(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    _ti = *pti;
    _dpaItems.Attach(pdpaItems->Detach()); // we have ownership of the DPA now

    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_ITransferAdviseSink, ptas, &_pstrmSink);
    if (SUCCEEDED(hr))
    {
        AddRef();
        hr = SHCreateThread(s_ThreadProc, this, CTF_INSIST | CTF_COINIT, NULL) ? S_OK:E_FAIL;
        if (FAILED(hr))
        {
            Release();
        }
    }

    return hr;
}

DWORD CALLBACK CTransferThread::s_ThreadProc(void *pv)
{
    CTransferThread *pTransfer = (CTransferThread*)pv;
    return pTransfer->_ThreadProc();
}

HRESULT CTransferThread::_InitSourceEnum(IEnumShellItems **ppesi)
{
    IStorage *pstg;
    HRESULT hr = CoCreateInstance(CLSID_DynamicStorage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IStorage, &pstg));
    {
        CTransferItemEnum *ptie = new CTransferItemEnum(L"", pstg, &_dpaItems);
        if (ptie)
        {
            hr = ptie->QueryInterface(IID_PPV_ARG(IEnumShellItems, ppesi));
            ptie->Release();
        }
        else
        {  
            hr = E_OUTOFMEMORY;
        }
        pstg->Release();
    }
    return hr;
}

DWORD CTransferThread::_ThreadProc()
{
    IEnumShellItems *penum =NULL;
    HRESULT hr = _InitSourceEnum(&penum);
    if (SUCCEEDED(hr))
    {
        hr = _FixUpDestination();                   // apply fixup for MSN etc.
        if (SUCCEEDED(hr))
        {
            hr = _np.SetTarget(_ti.hwnd, _ti.szFileTarget, NPTF_SILENT|NPTF_VALIDATE);          
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidl;
                hr = _np.GetIDList(_ti.hwnd, &pidl);
                if (SUCCEEDED(hr))
                {
                    IShellItem *psiDest;
                    hr = SHCreateShellItem(NULL, NULL, pidl, &psiDest);
                    if (SUCCEEDED(hr))
                    {
                        IStorageProcessor *psp;
                        hr = CoCreateInstance(CLSID_StorageProcessor, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IStorageProcessor, &psp));
                        if (SUCCEEDED(hr))
                        {
                            DWORD dwCookie = 0;

                            ITransferAdviseSink *ptas;
                            hr = CoGetInterfaceAndReleaseStream(_pstrmSink, IID_PPV_ARG(ITransferAdviseSink, &ptas));
                            _pstrmSink = NULL;

                            if (SUCCEEDED(hr))
                            {
                                hr = psp->Advise(ptas, &dwCookie);
                                ptas->Release();
                            }

                            hr = psp->Run(penum, psiDest, STGOP_COPY, STOPT_NOPROGRESSUI);

                            if (dwCookie)
                                psp->Unadvise(dwCookie);
                            
                            psp->Release();
                        }
                        psiDest->Release();
                    }
                    ILFree(pidl);
                }
            }
        }
        penum->Release();
    }

    // notify the fg thread that this has happened.

    PostMessage(_ti.hwnd, PWM_TRANSFERCOMPLETE, 0, (LPARAM)hr);

    // were done transfering the files so lets start to clear up - in particular
    // lets attempt to create the net work place.

    if (_ti.szLinkTarget[0] && !(_ti.dwFlags & SHPWHF_NONETPLACECREATE))
    {
        CNetworkPlace np;
        if (SUCCEEDED(np.SetTarget(_ti.hwnd, _ti.szLinkTarget, 0x0)))
        {
            if (_ti.szLinkName[0])
                np.SetName(NULL, _ti.szLinkName);
            if (_ti.szLinkDesc[0])
                np.SetDescription(_ti.szLinkDesc);            

            np.CreatePlace(_ti.hwnd, FALSE);
        }
    }

    Release();
    return 0;
}


// helper to create and initialize the transfer engine

HRESULT PublishViaCopyEngine(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    CTransferThread *ptt = new CTransferThread();
    if (!ptt)
        return E_OUTOFMEMORY;

    HRESULT hr = ptt->BeginTransfer(pti, pdpaItems, ptas);
    ptt->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\pubdrop.cpp ===
#include "stdafx.h"
#include "pubwiz.h"
#pragma hdrstop


typedef struct
{
   CLSID clsidWizard;           // which wizard is being invoked
   IStream *pstrmDataObj;       // IDataObject marshall object
   IStream *pstrmView;          // IFolderView marshall object
} PUBWIZDROPINFO;

// This is the drop target object which exposes the publishing wizard

class CPubDropTarget : public IDropTarget, IPersistFile, IWizardSite, IServiceProvider, CObjectWithSite
{
public:
    CPubDropTarget(CLSID clsidWizard, IFolderView *pfv);
    ~CPubDropTarget();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID)
        { *pClassID = _clsidWizard; return S_OK; };

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { *pdwEffect = DROPEFFECT_COPY; return S_OK; };
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { *pdwEffect = DROPEFFECT_COPY; return S_OK; };
    STDMETHODIMP DragLeave(void)
        { return S_OK; };
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage)
        { return GetNextPage(phPage); }

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    CLSID _clsidWizard;        
    LONG _cRef;

    HWND _hwndFrame;

    IPublishingWizard *_ppw;   
    IResourceMap *_prm;        
    IUnknown *_punkFTM;        
    IFolderView *_pfv;

    TCHAR _szSiteName[MAX_PATH];
    TCHAR _szSiteURL[INTERNET_MAX_URL_LENGTH];

    // helpers
    static void s_FreePubWizDropInfo(PUBWIZDROPINFO *ppwdi);
    static DWORD s_PublishThreadProc(void *pv);
    void _Publish(IDataObject *pdo);
    INT_PTR _InitDonePage(HWND hwnd);
    void _OpenSiteURL();
   
    // dialog handlers
    static INT_PTR s_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPubDropTarget *ppdt = s_GetPDT(hwnd, uMsg, lParam); return ppdt->_WelcomeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPubDropTarget *ppdt = s_GetPDT(hwnd, uMsg, lParam); return ppdt->_DoneDlgProc(hwnd, uMsg, wParam, lParam); }

    static CPubDropTarget* s_GetPDT(HWND hwnd, UINT uMsg, LPARAM lParam);
    INT_PTR _WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    friend void PublishRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
};


// Construction/destruction

CPubDropTarget::CPubDropTarget(CLSID clsidWizard, IFolderView *pfv) :
    _clsidWizard(clsidWizard), _cRef(1)
{
    // use the FTM to make the call back interface calls unmarshalled
    CoCreateFreeThreadedMarshaler(SAFECAST(this, IDropTarget *), &_punkFTM);

    // addref the IFolderView object we might be given
    IUnknown_Set((IUnknown**)&_pfv, pfv);

    DllAddRef();
}

CPubDropTarget::~CPubDropTarget()
{
    ATOMICRELEASE(_punkFTM);
    ATOMICRELEASE(_pfv);
    DllRelease();
}

// Reference counting of the object

ULONG CPubDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPubDropTarget::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPubDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPubDropTarget, IObjectWithSite),  // IID_IObjectWithSite
        QITABENT(CPubDropTarget, IWizardSite),      // IID_IWizardSite
        QITABENT(CPubDropTarget, IDropTarget),      // IID_IDropTarget
        QITABENT(CPubDropTarget, IPersistFile),     // IID_IPersistFile
        QITABENT(CPubDropTarget, IServiceProvider), // IID_IServiceProvider
        {0, 0},
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && _punkFTM)
    {
        hr = _punkFTM->QueryInterface(riid, ppv);
    }
    return hr;

}


// retrieve the 'this' ptr for the dialog

CPubDropTarget* CPubDropTarget::s_GetPDT(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPubDropTarget*)ppsp->lParam;
    }
    return (CPubDropTarget*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


// Welcome dialog. 

INT_PTR CPubDropTarget::_WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndFrame = GetParent(hwnd);
            SendDlgItemMessage(hwnd, IDC_PUB_WELCOME, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);

            IXMLDOMNode *pdn;
            HRESULT hr = _prm->SelectResourceScope(TEXT("dialog"), TEXT("welcome"), &pdn);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[512];

                _prm->LoadString(pdn, TEXT("caption"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOME, szBuffer);

                _prm->LoadString(pdn, TEXT("description"), szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText(hwnd, IDC_PUB_WELCOMEPROMPT, szBuffer);

                pdn->Release();
            }
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
#if 0 
                    if (_fSkipWelcome)
                    {
                        _fSkipWelcome = FALSE;
                        HPROPSHEETPAGE hpage;
                        if (SUCCEEDED(_ppw->GetFirstPage(&hpage)))
                        {
                            int i = PropSheet_PageToIndex(GetParent(hwnd), hpage);
                            if (i > 0) //cannot be zero because that's our index
                            {
                                UINT_PTR id = PropSheet_IndexToId(GetParent(hwnd), i);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)id);
                            }
                        }
                    }
#endif
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);
                    return TRUE;              
                }

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ppw->GetFirstPage(&hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// layout the controls on the done page

INT_PTR CPubDropTarget::_InitDonePage(HWND hwnd)
{
    HRESULT hrFromTransfer = E_FAIL; // default to that based on not getting any state back!
    
    // these are the states we can read back from the manifest

    BOOL fHasSiteName = FALSE;
    BOOL fHasNetPlace = FALSE;
    BOOL fHasFavorite = FALSE;
    BOOL fHasURL = FALSE;

    // lets crack the manifest and work out whats what with the publish that
    // we just performed.

    IXMLDOMDocument *pdocManifest;
    HRESULT hr = _ppw->GetTransferManifest(&hrFromTransfer, &pdocManifest);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdnUploadInfo;
        hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdnUploadInfo);
        if (hr == S_OK)
        {
            IXMLDOMElement *pdel;
            VARIANT var;

            // lets pick up the site name from the manifest, this will be an attribute on the
            // upload info element.

            hr = pdnUploadInfo->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
            if (SUCCEEDED(hr))
            {
                hr = pdel->getAttribute(ATTRIBUTE_FRIENDLYNAME, &var);
                if (hr == S_OK)
                {
                    StrCpyN(_szSiteName, var.bstrVal, ARRAYSIZE(_szSiteName));
                    VariantClear(&var);

                    fHasSiteName = TRUE;
                }

                pdel->Release();
            }

            // lets now try and pick up the site URL node, this is going to either
            // be the file target, or HTML UI element.

            IXMLDOMNode *pdnURL;
            hr = pdnUploadInfo->selectSingleNode(ELEMENT_HTMLUI, &pdnURL);
            
            if (hr == S_FALSE)
                hr = pdnUploadInfo->selectSingleNode(ELEMENT_NETPLACE, &pdnURL);

            if (hr== S_FALSE)
                hr = pdnUploadInfo->selectSingleNode(ELEMENT_TARGET, &pdnURL);

            if (hr == S_OK)
            {
                hr = pdnURL->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
                if (SUCCEEDED(hr))
                {
                    // attempt to read the HREF attribute, if that is defined
                    // the we use it, otherwise (for compatibility with B2, we need
                    // to get the node text and use that instead).

                    hr = pdel->getAttribute(ATTRIBUTE_HREF, &var);
                    if (hr != S_OK)
                        hr = pdel->get_nodeTypedValue(&var);

                    if (hr == S_OK)
                    {
                        StrCpyN(_szSiteURL, var.bstrVal, ARRAYSIZE(_szSiteURL));
                        VariantClear(&var);

                        fHasURL = TRUE;             // we now have the URL
                    }

                    pdel->Release();
                }
                pdnURL->Release();
            }

            // lets check for the favorite - if the element is present then we assume that
            // it was created.

            IXMLDOMNode *pdnFavorite;
            hr = pdnUploadInfo->selectSingleNode(ELEMENT_FAVORITE, &pdnFavorite);
            if (hr == S_OK)
            {
                pdnFavorite->Release();
                fHasFavorite = TRUE;
            }

            // lets check for the net place element - if the element is present then we
            // will assume it was created.

            IXMLDOMNode *pdnNetPlace;
            hr = pdnUploadInfo->selectSingleNode(ELEMENT_NETPLACE, &pdnNetPlace);
            if (hr == S_OK)
            {
                pdnNetPlace->Release();
                fHasNetPlace = TRUE;
            }

            pdnUploadInfo->Release();
        }
        pdocManifest->Release();
    }

    // adjust the resources on the done page to reflect the wizard that was invoked
    // and more importantly the success / failure that ocurred.

    IXMLDOMNode *pdn;
    hr = _prm->SelectResourceScope(TEXT("dialog"), TEXT("done"), &pdn);
    if (SUCCEEDED(hr))
    {
        TCHAR szBuffer[384 + INTERNET_MAX_URL_LENGTH];                   // enough for URL + text

        _prm->LoadString(pdn, TEXT("caption"), szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hwnd, IDC_PUB_DONE, szBuffer);

        if (hrFromTransfer == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            _prm->LoadString(pdn, TEXT("cancel"), szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (FAILED(hrFromTransfer))
        {
            _prm->LoadString(pdn, TEXT("failure"), szBuffer, ARRAYSIZE(szBuffer));
        }
        else
        {
            TCHAR szIntro[128] = {0};
            TCHAR szLink[128 +INTERNET_MAX_URL_LENGTH] = {0};
            TCHAR szConclusion[128] = {0};

            // get the intro text - this is common for all success pages

            _prm->LoadString(pdn, TEXT("success"), szIntro, ARRAYSIZE(szIntro));

            // if we have a link then we sometimes have a intro for that also

            if (fHasURL)
            {
                TCHAR szFmt[MAX_PATH];
                if (SUCCEEDED(_prm->LoadString(pdn, TEXT("haslink"), szFmt, ARRAYSIZE(szFmt))))
                {
                    wnsprintf(szLink, ARRAYSIZE(szLink), szFmt, fHasSiteName ? _szSiteName:_szSiteURL);
                }
            }   

            // then for some scenarios we have a postscript about creating favorites/netplaces

            if (fHasFavorite && fHasNetPlace)
            {
                _prm->LoadString(pdn, TEXT("hasfavoriteandplace"), szConclusion, ARRAYSIZE(szConclusion));
            }
            else if (fHasNetPlace)
            {
                _prm->LoadString(pdn, TEXT("hasplace"), szConclusion, ARRAYSIZE(szConclusion));
            }
            else if (fHasFavorite)
            {
                _prm->LoadString(pdn, TEXT("hasfavorite"), szConclusion, ARRAYSIZE(szConclusion));
            }

            // format it all into one string that we can set into the control
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s%s%s"), szIntro, szLink, szConclusion);
        }

        // update the message based on the strings we loaded. lets move the controls accordingly

        SetDlgItemText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);

        UINT ctls[] = { IDC_PUB_OPENFILES };
        int dy = SizeControlFromText(hwnd, IDC_PUB_COMPLETEMSG, szBuffer);
        MoveControls(hwnd, ctls, ARRAYSIZE(ctls), 0, dy);

        // show/hide the "open these files check" based on the URL that we might have

        BOOL fShowOpen = fHasURL && SUCCEEDED(hrFromTransfer) && (_clsidWizard == CLSID_PublishDropTarget);
        ShowWindow(GetDlgItem(hwnd, IDC_PUB_OPENFILES), fShowOpen ? SW_SHOW:SW_HIDE);
        CheckDlgButton(hwnd, IDC_PUB_OPENFILES, fShowOpen);

        pdn->Release();
    }

    // set the buttons to reflect what we can do in the wizard
    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH|PSWIZB_BACK);
    return TRUE;
}

void CPubDropTarget::_OpenSiteURL()
{
    SHELLEXECUTEINFO shexinfo = {0};
    shexinfo.cbSize = sizeof(shexinfo);
    shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpVerb = TEXT("open");
    shexinfo.lpFile =_szSiteURL;
    ShellExecuteEx(&shexinfo);
}

INT_PTR CPubDropTarget::_DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_PUB_DONE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case NM_CLICK:
                case NM_RETURN:
                    if (pnmh->idFrom == IDC_PUB_COMPLETEMSG)
                    {
                        _OpenSiteURL();
                        return TRUE;
                    }
                    break;

                case PSN_SETACTIVE:
                    return _InitDonePage(hwnd);

                case PSN_WIZBACK:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ppw->GetLastPage(&hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }

                case PSN_WIZFINISH:
                {
                    if (IsDlgButtonChecked(hwnd, IDC_PUB_OPENFILES) == BST_CHECKED)
                    {
                        _OpenSiteURL();
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)FALSE);
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// IServiceProvider 

STDMETHODIMP CPubDropTarget::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_ResourceMap)
    {
        return _prm->QueryInterface(riid, ppv);
    }
    else if ((guidService == SID_SFolderView) && _pfv)
    {
        return _pfv->QueryInterface(riid, ppv);
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}


// site object helpers, these allow nagivation back and forward in the wizard

HRESULT CPubDropTarget::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    int i = PropSheet_IdToIndex(_hwndFrame, IDD_PUB_WELCOME);
    *phPage = PropSheet_IndexToPage(_hwndFrame, i);
    return S_OK;
}

HRESULT CPubDropTarget::GetNextPage(HPROPSHEETPAGE *phPage)
{
   int i = PropSheet_IdToIndex(_hwndFrame, IDD_PUB_DONE);
   *phPage = PropSheet_IndexToPage(_hwndFrame, i);
   return S_OK;
}


// our publishing object

void CPubDropTarget::_Publish(IDataObject *pdo)
{
    // wizard implementation 

    struct
    {
        LPCTSTR idPage;
        LPCTSTR pszPage;    
        DWORD dwFlags;
        DLGPROC dlgproc;
    }
    _wizardpages[] =
    {
        {MAKEINTRESOURCE(IDD_PUB_WELCOME), TEXT("welcome"), PSP_HIDEHEADER, CPubDropTarget::s_WelcomeDlgProc},
        {MAKEINTRESOURCE(IDD_PUB_DONE),    TEXT("done"),    PSP_HIDEHEADER, CPubDropTarget::s_DoneDlgProc},
    };

    // load the resource map for this instance of the wizard

    HRESULT hr = CResourceMap_Initialize(L"res://netplwiz.dll/xml/resourcemap.xml", &_prm);
    if (SUCCEEDED(hr))
    {
        // if this is the printing wizard then configure accordingly
        //  (eg. remove ADVANCED, FOLDERCREATEION and NETPLACES).

        DWORD dwFlags = 0x0;
        LPTSTR pszWizardDefn = TEXT("PublishingWizard");

        if (_clsidWizard == CLSID_InternetPrintOrdering)
        {
            dwFlags |= SHPWHF_NONETPLACECREATE|SHPWHF_NORECOMPRESS;
            pszWizardDefn = TEXT("InternetPhotoPrinting");
        }

        hr = _prm->LoadResourceMap(TEXT("wizard"), pszWizardDefn);
        if (SUCCEEDED(hr))
        {
            // create the page array, we add the welcome page and the finished page
            // the rest is loaded as an extension to the wizard.

            HPROPSHEETPAGE hpages[10] = { 0 };
            for (int cPages = 0; SUCCEEDED(hr) && (cPages < ARRAYSIZE(_wizardpages)); cPages++)
            {               
                // find resource map for this page of the wizard

                IXMLDOMNode *pdn;
                hr = _prm->SelectResourceScope(TEXT("dialog"), _wizardpages[cPages].pszPage, &pdn);
                if (SUCCEEDED(hr))
                {
                    TCHAR szTitle[MAX_PATH], szHeading[MAX_PATH], szSubHeading[MAX_PATH];

                    _prm->LoadString(pdn, TEXT("title"), szTitle, ARRAYSIZE(szTitle));
                    _prm->LoadString(pdn, TEXT("heading"), szHeading, ARRAYSIZE(szHeading));
                    _prm->LoadString(pdn, TEXT("subheading"), szSubHeading, ARRAYSIZE(szSubHeading));

                    PROPSHEETPAGE psp = { 0 };
                    psp.dwSize = sizeof(PROPSHEETPAGE);
                    psp.hInstance = g_hinst;
                    psp.lParam = (LPARAM)this;
                    psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | _wizardpages[cPages].dwFlags;
                    psp.pszTemplate = _wizardpages[cPages].idPage;
                    psp.pfnDlgProc = _wizardpages[cPages].dlgproc;
                    psp.pszTitle = szTitle;
                    psp.pszHeaderTitle = szHeading;        
                    psp.pszHeaderSubTitle = szSubHeading;  
                    hpages[cPages] = CreatePropertySheetPage(&psp);
                    hr = ((hpages[cPages]) != NULL) ? S_OK:E_FAIL;

                    pdn->Release();
                }
            }

            // lets create the web publishing wizard, this will handle the transfer
            // and destination selection for the upload.

            hr = CoCreateInstance(CLSID_PublishingWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPublishingWizard, &_ppw));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(_ppw, SAFECAST(this, IWizardSite*));
                hr = _ppw->Initialize(pdo, dwFlags, pszWizardDefn);
                if (SUCCEEDED(hr))
                {
                    UINT cExtnPages;    
                    hr = _ppw->AddPages(&hpages[cPages], ARRAYSIZE(hpages)-cPages, &cExtnPages);
                    if (SUCCEEDED(hr))
                    {
                        cPages += cExtnPages;
                    }
                }
            }

            // ... that all worked so lets show the wizard.  on our way our remember
            // to clear up the objects

            if (SUCCEEDED(hr))
            {
                PROPSHEETHEADER psh = { 0 };
                psh.dwSize = sizeof(PROPSHEETHEADER);
                psh.hInstance = g_hinst;
                psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | (PSH_WATERMARK|PSH_USEHBMWATERMARK) | (PSH_HEADER|PSH_USEHBMHEADER);
                psh.phpage = hpages;
                psh.nPages = cPages;

                _prm->LoadBitmap(NULL, TEXT("header"), &psh.hbmHeader);
                _prm->LoadBitmap(NULL, TEXT("watermark"), &psh.hbmWatermark);

                if (psh.hbmHeader && psh.hbmWatermark)
                    PropertySheet(&psh);

                if (psh.hbmHeader)
                    DeleteObject(psh.hbmHeader);
                if (psh.hbmWatermark)
                    DeleteObject(psh.hbmWatermark);
            }

            IUnknown_SetSite(_ppw, NULL);                   // discard the publishing wizard
            IUnknown_Set((IUnknown**)&_ppw, NULL);
        }

        IUnknown_Set((IUnknown**)&_prm, NULL);                  // no more resource map
    }
}


// handle the drop operation, as the publishing wizard can take a long time we
// marshall the IDataObject and then create a worker thread which can
// handle showing the wizard.

void CPubDropTarget::s_FreePubWizDropInfo(PUBWIZDROPINFO *ppwdi)
{
    if (ppwdi->pstrmDataObj)
        ppwdi->pstrmDataObj->Release();
    if (ppwdi->pstrmView)
        ppwdi->pstrmView->Release();

    LocalFree(ppwdi);
}

DWORD CPubDropTarget::s_PublishThreadProc(void *pv)
{
    PUBWIZDROPINFO *ppwdi = (PUBWIZDROPINFO*)pv;
    if (ppwdi)
    {
        // ICW must have run before we go too far down this path
        LaunchICW();        
 
        // get the IDataObject, we need this to handle th drop
        IDataObject *pdo;
        HRESULT hr = CoGetInterfaceAndReleaseStream(ppwdi->pstrmDataObj, IID_PPV_ARG(IDataObject, &pdo));
        ppwdi->pstrmDataObj = NULL; // CoGetInterfaceAndReleaseStream always releases; NULL out.
        if (SUCCEEDED(hr))
        {   
            // try to unmarshall the IFolderView object we will use.
            IFolderView *pfv = NULL;
            if (ppwdi->pstrmView)
            {
                CoGetInterfaceAndReleaseStream(ppwdi->pstrmView, IID_PPV_ARG(IFolderView, &pfv));
                ppwdi->pstrmView = NULL; // CoGetInterfaceAndReleaseStream always releases; NULL out.
            }

            CPubDropTarget *ppw = new CPubDropTarget(ppwdi->clsidWizard, pfv);
            if (ppw)
            {
                ppw->_Publish(pdo);
                ppw->Release();
            }
    
            if (pfv)
                pfv->Release();

            pdo->Release();
        }  
        s_FreePubWizDropInfo(ppwdi);
    }
    return 0;    
}

STDMETHODIMP CPubDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    // create an instance of the wizard on another thread, package up any parameters
    // into a structure for the thread to handle (eg. the drop target)

    PUBWIZDROPINFO *ppwdi = (PUBWIZDROPINFO*)LocalAlloc(LPTR, sizeof(PUBWIZDROPINFO));
    if (ppwdi)
    {
        ppwdi->clsidWizard = _clsidWizard;

        // lets get the IFolderView object and marshall it for the bg thread

        IFolderView *pfv;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
        {
            CoMarshalInterThreadInterfaceInStream(IID_IFolderView, pfv, &ppwdi->pstrmView);
            pfv->Release();
        }
        
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &ppwdi->pstrmDataObj);
        if (SUCCEEDED(hr))
        {
            hr = SHCreateThread(s_PublishThreadProc, ppwdi, CTF_THREAD_REF|CTF_COINIT, NULL) ? S_OK:E_FAIL;
        }

        if (FAILED(hr))
        {
            s_FreePubWizDropInfo(ppwdi);
        }
    }
    return hr;
}


// create instance

STDAPI CPublishDropTarget_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPubDropTarget *pwiz = new CPubDropTarget(*poi->pclsid, NULL);
    if (!pwiz)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwiz->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pwiz->Release();
    return hr;
}

// invoke the publishing wizard to point at a particular directory

void APIENTRY PublishRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        CLSID clsid = CLSID_PublishDropTarget;
        UINT csidl = CSIDL_PERSONAL;

        if (0 == StrCmpIA(pszCmdLine, "/print"))
        {
            clsid = CLSID_InternetPrintOrdering;
            csidl = CSIDL_MYPICTURES;
        }

        LPITEMIDLIST pidl;
        hr = SHGetSpecialFolderLocation(NULL, csidl, &pidl);
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                IDataObject *pdo;
                hr = psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_X_PPV_ARG(IDataObject, NULL, &pdo));
                if (SUCCEEDED(hr))
                {
                    CPubDropTarget *pdt = new CPubDropTarget(clsid, NULL);
                    if (pdt)
                    {
                        pdt->_Publish(pdo);
                        pdt->Release();
                    }
                    pdo->Release();
                }
                psf->Release();
            }
            ILFree(pidl);
        }
        CoUninitialize();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\password.cpp ===
#include "stdafx.h"
#include "password.h"
#pragma hdrstop


// password prompt dialog

INT_PTR CPasswordDialog::DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
    default:
        break;
    }

    return FALSE;
}

BOOL CPasswordDialog::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szMessage[MAX_PATH + MAX_DOMAIN + MAX_USER + 256 + 2]; szMessage[0] = 0;

    //
    // Limit the size of the edit controls + Set username/password
    //
    HWND hwndCredential = GetDlgItem(hwnd, IDC_CREDENTIALS);
    SendMessage(hwndCredential, CRM_SETUSERNAME, NULL, (LPARAM) m_pszDomainUser);
    SendMessage(hwndCredential, CRM_SETPASSWORD, NULL, (LPARAM) m_pszPassword);
    SendMessage(hwndCredential, CRM_SETUSERNAMEMAX, m_cchDomainUser - 1, NULL);
    SendMessage(hwndCredential, CRM_SETPASSWORDMAX, m_cchPassword - 1, NULL);
    
    // We may need to generate a user name here to use if no user name was
    // passed in
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    LPTSTR pszUserNameToUse;

    if (*m_pszDomainUser)
    {
        pszUserNameToUse = m_pszDomainUser;
    }
    else
    {
        szDomainUser[0] = 0;

        TCHAR szUser[MAX_USER + 1];
        DWORD cchUser = ARRAYSIZE(szUser);
        TCHAR szDomain[MAX_DOMAIN + 1];
        DWORD cchDomain = ARRAYSIZE(szDomain);

        GetCurrentUserAndDomainName(szUser, &cchUser, szDomain, &cchDomain);
        
        MakeDomainUserString(szDomain, szUser, szDomainUser, ARRAYSIZE(szDomainUser));
        pszUserNameToUse = szDomainUser;
    }

    FormatMessageString(IDS_PWD_STATIC, szMessage, ARRAYSIZE(szMessage), m_pszResourceName, pszUserNameToUse);
    SetDlgItemText(hwnd, IDC_MESSAGE, szMessage);

    // Now set the error message description

    TCHAR szError[512];
    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, m_dwError, 0, szError, ARRAYSIZE(szError), NULL))
    {
        LoadString(g_hinst, IDS_ERR_UNEXPECTED, szError, ARRAYSIZE(szError));
    }
    SetDlgItemText(hwnd, IDC_ERROR, szError);

    return TRUE;
}

BOOL CPasswordDialog::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id) 
    {
    case IDOK:
        {
            // Read the username and password from the dialog.  Note
            // that we don't call FetchText for the password since it
            // strips leading and trailing whitespace and, for all we
            // know, that could be an important part of the password
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETUSERNAME, (WPARAM) m_cchDomainUser - 1, (LPARAM) m_pszDomainUser);
            SendDlgItemMessage(hwnd, IDC_CREDENTIALS, CRM_GETPASSWORD, (WPARAM) m_cchPassword - 1, (LPARAM) m_pszPassword);
        }
        // Fall through
    case IDCANCEL:
        EndDialog(hwnd, id);
        return TRUE;
    }

    return FALSE;
}


// page implementation - used for wizards etc

BOOL CPasswordPageBase::DoPasswordsMatch(HWND hwnd)
{
    TCHAR szConfirmPW[MAX_PASSWORD + 1];
    TCHAR szPassword[MAX_PASSWORD + 1];

    GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
    GetWindowText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), szConfirmPW,ARRAYSIZE(szConfirmPW));

    BOOL fMatch = (StrCmp(szPassword, szConfirmPW) == 0);
    if (!fMatch)
    {
        // Display a message saying the passwords don't match
        DisplayFormatMessage(hwnd, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_ERR_PWDNOMATCH,  MB_OK | MB_ICONERROR);
    }

    return fMatch;
}

INT_PTR CPasswordWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
    }

    return FALSE;
}

BOOL CPasswordWizardPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    Edit_LimitText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    return TRUE;
}

BOOL CPasswordWizardPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            // Verify that the passwords match
            if (DoPasswordsMatch(hwnd))
            {
                // Password is the same as confirm password - read password into user info
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), m_pUserInfo->m_szPasswordBuffer,
                                    ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer));

                // Hide the password
                m_pUserInfo->HidePassword();
                EndDialog(hwnd, IDOK);
            }
            else
            {
                m_pUserInfo->ZeroPassword();
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        
        default:
            break;
    }

    return TRUE;
}

BOOL CPasswordWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_NEXT | PSWIZB_BACK);
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            return TRUE;

        case PSN_WIZNEXT:
        {
            // Save the data the user has entered
            if (DoPasswordsMatch(hwnd))
            {
                // Password is the same as confirm password - read password into user info
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), 
                                         m_pUserInfo->m_szPasswordBuffer, 
                                          ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer));

                // Hide the password
                m_pUserInfo->HidePassword();
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            }
            else
            {
                m_pUserInfo->ZeroPassword();
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            return TRUE;
        }
    }
    return FALSE;
}



INT_PTR CChangePasswordDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CChangePasswordDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    Edit_LimitText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer) - 1);
    return TRUE;
}

BOOL CChangePasswordDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            if (DoPasswordsMatch(hwnd))
            {
                // Password is the same as confirm password - read password into user info
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), m_pUserInfo->m_szPasswordBuffer,
                                            ARRAYSIZE(m_pUserInfo->m_szPasswordBuffer));

                m_pUserInfo->HidePassword();                // Hide the password

                // Update the password
                BOOL fBadPasswordFormat;
                if (SUCCEEDED(m_pUserInfo->UpdatePassword(&fBadPasswordFormat)))
                {
                    EndDialog(hwnd, IDOK);
                }
                else
                {
                    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
                    MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername, 
                                            szDomainUser, ARRAYSIZE(szDomainUser));

                    if (fBadPasswordFormat)
                    {
                        ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, 
                            IDS_USR_UPDATE_PASSWORD_TOOSHORT_ERROR, MB_ICONERROR | MB_OK,
                            szDomainUser);
                    }
                    else
                    {
                        ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                            IDS_USR_UPDATE_PASSWORD_ERROR, MB_ICONERROR | MB_OK,
                            szDomainUser);
                    }
                }
            }
            break;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            break;
        
        default:
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\netwiz.cpp ===
#include "stdafx.h"
#include "grpinfo.h"
#include <dsgetdc.h>        // DsGetDCName and DS structures
#include <ntdsapi.h>
#include <activeds.h>       // ADsGetObject
#include <rasdlg.h>
#include <raserror.h>
#pragma hdrstop


CGroupPageBase* g_pGroupPageBase;       // used for the group page

DWORD g_dwWhichNet = 0;
UINT g_uWizardIs = NAW_NETID; 

BOOL g_fRebootOnExit = FALSE;           
BOOL g_fShownLastPage = FALSE;          
BOOL g_fCreatedConnection = FALSE;      // we created a RAS connection during the wizard, therefore kill it on exit
BOOL g_fMachineRenamed = FALSE;

WCHAR g_szUser[MAX_DOMAINUSER + 1] = { L'\0' };
WCHAR g_szDomain[MAX_DOMAIN + 1] = { L'\0' };
WCHAR g_szCompDomain[MAX_DOMAIN + 1] = { L'\0' };


// Stuff for creating a default autologon user
#define ITEMDATA_DEFAULTLOCALUSER   0xDEADBEEF

// default workgroup to be joined 
#define DEFAULT_WORKGROUP   L"WORKGROUP"


// Set the Wizard buttons for the dialog

void SetWizardButtons(HWND hwndPage, DWORD dwButtons)
{
    HWND hwndParent = GetParent(hwndPage);

    if (g_uWizardIs != NAW_NETID)
    {
        EnableWindow(GetDlgItem(hwndParent,IDHELP),FALSE);
        ShowWindow(GetDlgItem(hwndParent,IDHELP),SW_HIDE);
    }

    if (g_fRebootOnExit) 
    {
        TCHAR szBuffer[80];
        LoadString(g_hinst, IDS_CLOSE, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hwndParent, IDCANCEL, szBuffer);
    }
    
    PropSheet_SetWizButtons(hwndParent, dwButtons);
}


// intro dialog - set the title text etc

INT_PTR CALLBACK _IntroDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    SetWizardButtons(hwnd, PSWIZB_NEXT);
                    return TRUE;              

                case PSN_WIZNEXT:
                {
                    switch (g_uWizardIs)
                    {
                    case NAW_PSDOMAINJOINED:
                        WIZARDNEXT(hwnd, IDD_PSW_ADDUSER);
                        break;
                    default:
                        // Let the wizard go to the next page
                        break;
                    }
                        

                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}                                    


// how do they user this machine corp/vs home

INT_PTR CALLBACK _HowUseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            CheckRadioButton(hwnd, IDC_NETWORKED, IDC_NOTNETWORKED, IDC_NETWORKED);
            return TRUE;
    
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    SetWizardButtons(hwnd, PSWIZB_NEXT|PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_WELCOME);
                    return TRUE;

                case PSN_WIZNEXT:
                {                    
                    if (IsDlgButtonChecked(hwnd, IDC_NETWORKED) == BST_CHECKED)
                    {
                        WIZARDNEXT(hwnd, IDD_PSW_WHICHNET);
                    }
                    else
                    {
                        g_dwWhichNet = IDC_NONE;

                        if (SUCCEEDED(JoinDomain(hwnd, FALSE, DEFAULT_WORKGROUP, NULL, &g_fRebootOnExit)))
                        {
                            WIZARDNEXT(hwnd, IDD_PSW_DONE);
                        }
                        else
                        {
                            WIZARDNEXT(hwnd, -1);
                        }
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// determine the network they want to join

INT_PTR CALLBACK _WhichNetDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            CheckRadioButton(hwnd, IDC_DOMAIN, IDC_WORKGROUP, IDC_DOMAIN);
            return TRUE;
    
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    SetWizardButtons(hwnd, PSWIZB_NEXT|PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_HOWUSE);
                    return TRUE;

                case PSN_WIZNEXT:
                {                    
                    if (IsDlgButtonChecked(hwnd, IDC_DOMAIN) == BST_CHECKED)
                    {
                        g_dwWhichNet = IDC_DOMAIN;
                        WIZARDNEXT(hwnd, IDD_PSW_DOMAININFO);
                    }
                    else
                    {
                        g_dwWhichNet = IDC_WORKGROUP;
                        WIZARDNEXT(hwnd, IDD_PSW_WORKGROUP);
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// we are joining a workgroup etc

INT_PTR CALLBACK _WorkgroupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            Edit_LimitText(GetDlgItem(hwnd, IDC_WORKGROUP), MAX_WORKGROUP);
            SetDlgItemText(hwnd, IDC_WORKGROUP, DEFAULT_WORKGROUP);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;
                    if (!FetchTextLength(hwnd, IDC_WORKGROUP))
                        dwButtons &= ~PSWIZB_NEXT;

                    SetWizardButtons(hwnd, dwButtons);
                    return TRUE;
                }

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_WHICHNET);
                    return TRUE;

                case PSN_WIZNEXT:
                {
                    WCHAR szWorkgroup[MAX_WORKGROUP+1];
                    FetchText(hwnd, IDC_WORKGROUP, szWorkgroup, ARRAYSIZE(szWorkgroup));

                    if (SUCCEEDED(JoinDomain(hwnd, FALSE, szWorkgroup, NULL, &g_fRebootOnExit)))
                    {
                        ClearAutoLogon();
                        WIZARDNEXT(hwnd, IDD_PSW_DONE);
                    }
                    else
                    {
                        WIZARDNEXT(hwnd, -1);
                    }
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            if (HIWORD(wParam) == EN_CHANGE)
            {
                DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;
                if (!FetchTextLength(hwnd, IDC_WORKGROUP))
                    dwButtons &= ~PSWIZB_NEXT;

                SetWizardButtons(hwnd, dwButtons);
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}


// were done, show the final page

INT_PTR CALLBACK _DoneDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_TITLE, WM_SETFONT, (WPARAM)GetIntroFont(hwnd), 0);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    TCHAR szBuffer[MAX_PATH];

                    // change the closing prompt if we are supposed to be

                    LoadString(g_hinst, 
                               g_fRebootOnExit ? IDS_NETWIZFINISHREBOOT:IDS_NETWIZFINISH, 
                               szBuffer, ARRAYSIZE(szBuffer));
            
                    SetDlgItemText(hwnd, IDC_FINISHSTATIC, szBuffer);
                    SetWizardButtons(hwnd, PSWIZB_BACK|PSWIZB_FINISH);

                    g_fShownLastPage = TRUE;                    // show the last page of the wizard

                    return TRUE;
                }

                case PSN_WIZBACK:
                {
                    switch (g_dwWhichNet)
                    {
                        case IDC_DOMAIN:
                            WIZARDNEXT(hwnd, g_fMachineRenamed ? IDD_PSW_COMPINFO : IDD_PSW_ADDUSER);
                            break;

                        case IDC_WORKGROUP:
                            WIZARDNEXT(hwnd, IDD_PSW_WORKGROUP);
                            break;

                        case IDC_NONE:
                            WIZARDNEXT(hwnd, IDD_PSW_HOWUSE);
                            break;
                    }
                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}


// subclass this is used for the setup scenario where we want to remove various
// buttons and stop the dialog from being moved.  therefore we subclass the
// wizard during its creation and lock its place.

static WNDPROC _oldDlgWndProc;

LRESULT CALLBACK _WizardSubWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // on WM_WINDOWPOSCHANGING and the window is moving then lets centre it onto the
    // desktop window.  unfortunately setting the DS_CENTER bit doesn't buy us anything
    // as the wizard is resized after creation.
    //

    if (uMsg == WM_WINDOWPOSCHANGING)
    {
        LPWINDOWPOS lpwp = (LPWINDOWPOS)lParam;
        RECT rcDlg, rcDesktop;

        GetWindowRect(hwnd, &rcDlg);
        GetWindowRect(GetDesktopWindow(), &rcDesktop);

        lpwp->x = ((rcDesktop.right-rcDesktop.left)-(rcDlg.right-rcDlg.left))/2;
        lpwp->y = ((rcDesktop.bottom-rcDesktop.top)-(rcDlg.bottom-rcDlg.top))/2;
        lpwp->flags &= ~SWP_NOMOVE;
    }

    return _oldDlgWndProc(hwnd, uMsg, wParam, lParam);        
}

int CALLBACK _PropSheetCB(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    switch (uMsg)
    {
        // in pre-create lets set the window styles accorindlgy
        //      - remove the context menu and system menu

        case PSCB_PRECREATE:
        {
            DLGTEMPLATE *pdlgtmp = (DLGTEMPLATE*)lParam;
            pdlgtmp->style &= ~(DS_CONTEXTHELP|WS_SYSMENU);
            break;
        }

        // we now have a dialog, so lets sub class it so we can stop it being
        // move around.

        case PSCB_INITIALIZED:
        {
            if (g_uWizardIs != NAW_NETID)
                _oldDlgWndProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_WizardSubWndProc);

            break;
        }
    }

    return FALSE;
}


// gather domain information about the user

INT_PTR CALLBACK _DomainInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE: 
                    SetWizardButtons(hwnd, PSWIZB_NEXT|PSWIZB_BACK);
                    return TRUE;              

                case PSN_WIZBACK:
                {
                    if ( g_uWizardIs != NAW_NETID )
                        WIZARDNEXT(hwnd, IDD_PSW_WELCOME);

                    return TRUE;
                }
            }
            break;
        }
    }

    return FALSE;
}                                    



// handle searching the active directory for an object

//
// Search columns are returns as a ADS_SEARCH_COLUMN which is like a variant,
// but, the data form is more specific to a DS.
//
// We only need strings, therefore barf if any other type is given to us.
//

HRESULT _GetStringFromColumn(ADS_SEARCH_COLUMN *pasc, LPWSTR pBuffer, INT cchBuffer)
{
    switch ( pasc->dwADsType )
    {
        case ADSTYPE_DN_STRING:
        case ADSTYPE_CASE_EXACT_STRING:
        case ADSTYPE_CASE_IGNORE_STRING:
        case ADSTYPE_PRINTABLE_STRING:
        case ADSTYPE_NUMERIC_STRING:
            StrCpyN(pBuffer, pasc->pADsValues[0].DNString, cchBuffer);
            break;

        default:
            return E_FAIL;
    }

    return S_OK;
}


//
// Search the DS for a computer object that matches this computer name, if
// we find one then try and crack the name to give us something that
// can be used to join a domain.
//

HRESULT _FindComputerInDomain(LPWSTR pszUserName, LPWSTR pszUserDomain, LPWSTR pszSearchDomain, LPWSTR pszPassword, BSTR *pbstrCompDomain)
{
    HRESULT hres; 
    CWaitCursor cur;
    HRESULT hrInit = SHCoInitialize();

    WCHAR wszComputerObjectPath[MAX_PATH + 1] = { 0 };          // path to the computer object

    // Lets try and deterrmine the domain to search by taking the users domain and
    // calling DsGetDcName with it.

    PDOMAIN_CONTROLLER_INFO pdci;
    DWORD dwres = DsGetDcName(NULL, pszSearchDomain, NULL, NULL, DS_RETURN_DNS_NAME|DS_DIRECTORY_SERVICE_REQUIRED, &pdci);
    if ( (NO_ERROR == dwres) && pdci->DnsForestName )
    {
        TCHAR szDomainUser[MAX_DOMAINUSER + 1];
        MakeDomainUserString(pszUserDomain, pszUserName, szDomainUser, ARRAYSIZE(szDomainUser));

        WCHAR szBuffer[MAX_PATH + 1];
        wsprintf(szBuffer, L"GC://%s", pdci->DnsForestName);

        // now open the GC with the domain user (formatting the forest name above)

        IDirectorySearch* pds = NULL;
        hres = ADsOpenObject(szBuffer, szDomainUser, pszPassword, ADS_SECURE_AUTHENTICATION, IID_PPV_ARG(IDirectorySearch, &pds));
        if (SUCCEEDED(hres))
        {
            // we have a GC object, so lets search it...

            ADS_SEARCHPREF_INFO prefInfo[1];
            prefInfo[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;     // sub-tree search
            prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
            prefInfo[0].vValue.Integer = ADS_SCOPE_SUBTREE;
        
            hres = pds->SetSearchPreference(prefInfo, ARRAYSIZE(prefInfo));
            if (SUCCEEDED(hres))
            {
                LPWSTR c_aszAttributes[] = { L"ADsPath", };

                // using the computer name for this object lets scope the query accordingly
            
                WCHAR szComputerName[MAX_COMPUTERNAME + 1];
                DWORD dwComputerName = ARRAYSIZE(szComputerName);
                GetComputerName(szComputerName, &dwComputerName);
                wsprintf(szBuffer, L"(&(sAMAccountType=805306369)(sAMAccountName=%s$))", szComputerName);

                // issue the query

                ADS_SEARCH_HANDLE hSearch = NULL;
                hres = pds->ExecuteSearch(szBuffer, c_aszAttributes, ARRAYSIZE(c_aszAttributes), &hSearch);
                if (SUCCEEDED(hres))
                {
                    // we executed the search, so we can now attempt to read the results back
                    hres = pds->GetNextRow(hSearch);
                    if (SUCCEEDED(hres) && (hres != S_ADS_NOMORE_ROWS))
                    {
                        // we received a result back, so lets get the ADsPath of the computer
                        ADS_SEARCH_COLUMN ascADsPath;
                        hres = pds->GetColumn(hSearch, L"ADsPath", &ascADsPath);
                        if (SUCCEEDED(hres))
                            hres = _GetStringFromColumn(&ascADsPath, wszComputerObjectPath, ARRAYSIZE(wszComputerObjectPath));
                    }
                    pds->CloseSearchHandle(hSearch);
                }
            }
            pds->Release();
        }
        NetApiBufferFree(pdci);
    }
    else
    {
        hres = E_FAIL;
    }

    // So we found an object that is of the category computer, and it has the same name
    // as the computer object we are looking for.  Lets try and crack the name now
    // and determine which domain it is in.

    if (SUCCEEDED(hres))
    {
        IADsPathname* padp = NULL;
        hres = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (LPVOID*)&padp);
        if (SUCCEEDED(hres))
        {
            hres = padp->Set(wszComputerObjectPath, ADS_SETTYPE_FULL);
            if (SUCCEEDED(hres))
            {
                BSTR bstrX500DN = NULL;
                hres = padp->Retrieve(ADS_FORMAT_X500_DN, &bstrX500DN);
                if (SUCCEEDED(hres))
                {
                    PDS_NAME_RESULT pdnr = NULL;
                    dwres = DsCrackNames(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                                             DS_FQDN_1779_NAME, DS_CANONICAL_NAME,
                                             1, &bstrX500DN,  &pdnr);

                    if ( (NO_ERROR == dwres) && (pdnr->cItems == 1))
                    {
                        // try and get the NETBIOS name for the domain
                        dwres = DsGetDcName(NULL, pdnr->rItems->pDomain, NULL, NULL, DS_IS_DNS_NAME|DS_RETURN_FLAT_NAME, &pdci);
                        if (NO_ERROR == dwres)
                        {
                            if ( pbstrCompDomain )
                                *pbstrCompDomain = SysAllocString(pdci->DomainName);

                            hres = ((pbstrCompDomain && !*pbstrCompDomain)) ? E_OUTOFMEMORY:S_OK;
                        }
                        else
                        {   
                            hres = E_FAIL;                  // no flat name for the domain
                        }

                        DsFreeNameResult(pdnr);
                    }
                    else
                    {
                        hres = E_FAIL;                      // failed to find the computer in the domain
                    }

                    SysFreeString(bstrX500DN);
                }
            }
            padp->Release();
        }
    }

    SHCoUninitialize(hrInit);
    return hres;
}


// This is the phonebook callback, it is used to notify the book of the user name, domain
// and password to be used in this connection.  It is also used to receive changes made by
// the user.

VOID WINAPI _PhoneBkCB(ULONG_PTR dwCallBkID, DWORD dwEvent, LPWSTR pszEntry, void *pEventArgs)
{
    RASNOUSER *pInfo = (RASNOUSER *)pEventArgs;
    CREDINFO *pci = (CREDINFO *)dwCallBkID;

    switch ( dwEvent )
    {
        case RASPBDEVENT_NoUser:
        {
            // 
            // we are about to initialize the phonebook dialog, therefore
            // lets pass through our credential information.
            //

            pInfo->dwSize = SIZEOF(RASNOUSER);
            pInfo->dwFlags = 0;
            pInfo->dwTimeoutMs = 0;
            StrCpy(pInfo->szUserName, pci->pszUser);
            StrCpy(pInfo->szDomain, pci->pszDomain);
            StrCpy(pInfo->szPassword, pci->pszPassword);

            break;     
        }

        case RASPBDEVENT_NoUserEdit:
        {
            //
            // the user has changed the credetials we supplied for the
            // login, therefore we must update them in our copy accordingly.
            //

            if ( pInfo->szUserName[0] )
                StrCpyN(pci->pszUser, pInfo->szUserName, pci->cchUser);

            if ( pInfo->szPassword[0] )
                StrCpyN(pci->pszPassword, pInfo->szPassword, pci->cchPassword);

            if ( pInfo->szDomain[0] )
                StrCpyN(pci->pszDomain, pInfo->szDomain, pci->cchDomain);

            break;
        }
    }
}


// modify the RAS key for allowing phone book edits - so we can create a connectiod
// during setup.

BOOL SetAllowKey(DWORD dwNewValue, DWORD* pdwOldValue)
{
    BOOL fValueWasSet = FALSE;

    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_USERS,  TEXT(".DEFAULT\\Software\\Microsoft\\RAS Logon Phonebook"), NULL,
                                            TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkey, NULL))
    {
        const LPCTSTR pcszAllowEdit = TEXT("AllowLogonPhonebookEdits");

        if (NULL != pdwOldValue)
        {
            DWORD dwType = 0;
            DWORD cbSize = sizeof(DWORD);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, pcszAllowEdit, NULL, &dwType, (LPBYTE)pdwOldValue, &cbSize))
            {
                *pdwOldValue = 0;                   // Assume FALSE if the value doesn't exist
            }
        }

        // Set the new value
        if (ERROR_SUCCESS == RegSetValueEx(hkey, pcszAllowEdit, NULL, REG_DWORD, (CONST BYTE*) &dwNewValue, sizeof (DWORD)))
        {
            fValueWasSet = TRUE;
        }

        RegCloseKey(hkey);
    }

    return fValueWasSet;
}

//
// The user is trying to advance from the user info tab in the Wizard.  Therefore
// we must take the information they have entered and:
//
//  - log in using RAS (if ras is selected)
//  - try and locate a computer object
//  - if we find a computer object then allow them to use it
//  
// If we failed to find a computer object, or the user found one and decided not
// to use then we advance them to the 'computer info' page in the wizard.  If
// they decide to use it then we must apply it and advance to permissions.
//

void _DoUserInfoNext(HWND hwnd)
{
    HRESULT hres;
    WCHAR szPassword[MAX_PASSWORD + 1];
    BSTR bstrCompDomain = NULL;
    LONG idNextPage = -1;
    TCHAR szSearchDomain[MAX_DOMAIN + 1]; *szSearchDomain = 0;
    BOOL fTranslateNameTriedAndFailed = FALSE;

    // fSetAllowKey - Have we set the regval that says "allow connectiod creation before logon?"
    BOOL fSetAllowKey = FALSE;
    DWORD dwPreviousAllowValue = 0;

    //
    // read the user, domain and password from the dialog.  then 
    // lets search for the computer object that matches the currently
    // configure computer name.
    //

    FetchText(hwnd, IDC_USER, g_szUser, ARRAYSIZE(g_szUser));
    FetchText(hwnd, IDC_DOMAIN, g_szDomain, ARRAYSIZE(g_szDomain));
    FetchText(hwnd, IDC_PASSWORD, szPassword, ARRAYSIZE(szPassword));

    // Handle possible UPN case
    if (StrChr(g_szUser, TEXT('@')))
    {
        *g_szDomain = 0;
    }

    //
    // before we search for the computer object lets check to see if we should be using RAS 
    // to get ourselves onto the network.
    //

    if ( IsDlgButtonChecked(hwnd, IDC_DIALUP) == BST_CHECKED )
    {    
        fSetAllowKey = SetAllowKey(1, &dwPreviousAllowValue);

        // Its ok to use globals here - we want to overwrite them.
        CREDINFO ci = { g_szUser, ARRAYSIZE(g_szUser), 
                        g_szDomain, ARRAYSIZE(g_szDomain),
                        szPassword, ARRAYSIZE(szPassword) };

        RASPBDLG info = { 0 };
        info.dwSize = SIZEOF(info);
        info.hwndOwner = hwnd;
        info.dwFlags = RASPBDFLAG_NoUser;
        info.pCallback = _PhoneBkCB;
        info.dwCallbackId = (ULONG_PTR)&ci;

        if ( !RasPhonebookDlg(NULL, NULL, &info) )
        {
            hres = E_FAIL;              // failed to show the phone book
            goto exit_gracefully;
        }

        // Signal that the wizard has created a RAS connection.
        // Just to be extra paranoid, only do this if the wizard isn't a NETID wizard

        if (g_uWizardIs != NAW_NETID)
        {
            g_fCreatedConnection = TRUE;
        }

        SetDlgItemText(hwnd, IDC_USER, g_szUser);
        SetDlgItemText(hwnd, IDC_DOMAIN, g_szDomain);
    }

    //
    // now attempt to look up the computer object in the user domain.
    //

    if (StrChr(g_szUser, TEXT('@')))
    {
        TCHAR szDomainUser[MAX_DOMAINUSER + 1];
        ULONG ch = ARRAYSIZE(szDomainUser);
    
        if (TranslateName(g_szUser, NameUserPrincipal, NameSamCompatible, szDomainUser, &ch))
        {
            TCHAR szUser[MAX_USER + 1];
            DomainUserString_GetParts(szDomainUser, szUser, ARRAYSIZE(szUser), szSearchDomain, ARRAYSIZE(szSearchDomain));
        }
        else
        {
            fTranslateNameTriedAndFailed = TRUE;
        }
    }

    if (0 == *szSearchDomain)
        lstrcpyn(szSearchDomain, g_szDomain, ARRAYSIZE(szSearchDomain));

    hres = _FindComputerInDomain(g_szUser, g_szDomain, szSearchDomain, szPassword, &bstrCompDomain);
    switch ( hres )
    {
        case S_OK:
        {
            StrCpy(g_szCompDomain, bstrCompDomain);     // they want to change the domain

            //
            // we found an object in the DS that matches the current computer name
            // and domain.  show the domain to the user before we join, allowing them
            // to confirm that this is what they want to do.
            //

            if ( IDYES == ShellMessageBox(g_hinst, hwnd,
                                          MAKEINTRESOURCE(IDS_ABOUTTOJOIN), MAKEINTRESOURCE(IDS_USERINFO),
                                          MB_YESNO|MB_ICONQUESTION, 
                                          bstrCompDomain) )
            {
                // 
                // they don't want to modify the parameters so lets do the join.
                //

                idNextPage = IDD_PSW_ADDUSER;
                            
                // Make local copies of the user/domain buffers since we don't want to modify globals
                TCHAR szUser[MAX_DOMAINUSER + 1]; lstrcpyn(szUser, g_szUser, ARRAYSIZE(szUser));
                TCHAR szDomain[MAX_DOMAIN + 1]; lstrcpyn(szDomain, g_szDomain, ARRAYSIZE(szDomain));
                
                CREDINFO ci = {szUser, ARRAYSIZE(szUser), szDomain, ARRAYSIZE(szDomain), szPassword, ARRAYSIZE(szPassword)};
                if ( FAILED(JoinDomain(hwnd, TRUE, bstrCompDomain, &ci, &g_fRebootOnExit)) )
                {
                    idNextPage = -1;            // don't advance they failed to join
                }                
            }
            else
            {
                idNextPage = IDD_PSW_COMPINFO;
            }

            break;
        }
        
        case HRESULT_FROM_WIN32(ERROR_INVALID_DOMAINNAME):
        {
            // the domain was invalid, so we should really tell them
            ShellMessageBox(g_hinst, hwnd,
                            MAKEINTRESOURCE(IDS_ERR_BADDOMAIN), MAKEINTRESOURCE(IDS_USERINFO),
                            MB_OK|MB_ICONWARNING, g_szDomain);
            break;            

        }

        case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):
        case HRESULT_FROM_WIN32(ERROR_BAD_USERNAME):
        {
            // this was a credentail failure, so lets tell the user they got something
            // wrong, and let them correct it.
            if (!fTranslateNameTriedAndFailed)
            {
                ShellMessageBox(g_hinst, hwnd,
                                MAKEINTRESOURCE(IDS_ERR_BADPWUSER), MAKEINTRESOURCE(IDS_USERINFO),
                                MB_OK|MB_ICONWARNING);
                break;            
            }
            else
            {
                // Fall through... We tried to translate a UPN but we failed, so
                // we want to act as if we just failed to find a computer account
                goto default_label;
            }
        }


        default:
        {
default_label:
            // failed to find a computer that matches the information we have, therefore
            // lets advance to the computer information page.
            StrCmp(g_szCompDomain, g_szDomain);
            idNextPage = IDD_PSW_COMPINFO;
            break;
        }
    }

exit_gracefully:
    
    // Reset the "allow connectiod creation before login" value if appropriate
    if (fSetAllowKey)
        SetAllowKey(dwPreviousAllowValue, NULL);

    SysFreeString(bstrCompDomain);
    SetDlgItemText(hwnd, IDC_PASSWORD, L"");

    WIZARDNEXT(hwnd, idNextPage);                       
}


//
// wizard page to handle the user information (name, password and domain);
// 

BOOL _UserInfoBtnState(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;

    // the username/domain fields cannot be blank

    if ( !FetchTextLength(hwnd, IDC_USER) )
        dwButtons &= ~PSWIZB_NEXT;
    
    if (IsWindowEnabled(GetDlgItem(hwnd, IDC_DOMAIN)))
    {
        if ( !FetchTextLength(hwnd, IDC_DOMAIN) )
            dwButtons &= ~PSWIZB_NEXT;
    }

    SetWizardButtons(hwnd, dwButtons);
    return TRUE;
}

INT_PTR CALLBACK _UserInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            Edit_LimitText(GetDlgItem(hwnd, IDC_USER), MAX_DOMAINUSER);
            Edit_LimitText(GetDlgItem(hwnd, IDC_PASSWORD), MAX_PASSWORD);
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);

            // if we are launched from the netid tab then lets read the current 
            // user and domain and display accordingly.

            if ( g_uWizardIs == NAW_NETID ) 
            {
                DWORD dwcchUser = ARRAYSIZE(g_szUser);
                DWORD dwcchDomain = ARRAYSIZE(g_szDomain);
                GetCurrentUserAndDomainName(g_szUser, &dwcchUser, g_szDomain, &dwcchDomain);
                ShowWindow(GetDlgItem(hwnd, IDC_DIALUP), SW_HIDE);
            }

            SetDlgItemText(hwnd, IDC_USER, g_szUser);
            SetDlgItemText(hwnd, IDC_DOMAIN, g_szDomain);

            EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));

            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                    return _UserInfoBtnState(hwnd);

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_DOMAININFO);
                    return TRUE;

                case PSN_WIZNEXT:
                    _DoUserInfoNext(hwnd);      // handles setting the next page etc
                    return TRUE;
            }
            break;
        }

        case WM_COMMAND:
        {
            switch (HIWORD(wParam))
            {
            case EN_CHANGE:
                if ((IDC_USER == LOWORD(wParam)) || (IDC_DOMAIN == LOWORD(wParam)))
                {
                    EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));
                    _UserInfoBtnState(hwnd);
                }
            }
            break;
        }
    }

    return FALSE;
}



// modifying the computer name etc

BOOL _IsTCPIPAvailable(void)
{
    BOOL fTCPIPAvailable = FALSE;
    HKEY hk;
    DWORD dwSize = 0;

    // we check to see if the TCP/IP stack is installed and which object it is
    // bound to, this is a string, we don't check the value only that the
    // length is non-zero.

    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                       TEXT("System\\CurrentControlSet\\Services\\Tcpip\\Linkage"),
                                       0x0, 
                                       KEY_QUERY_VALUE, &hk) )
    {
        if ( ERROR_SUCCESS == RegQueryValueEx(hk, TEXT("Export"), 0x0, NULL, NULL, &dwSize) )
        {
            if ( dwSize > 2 )
            {
                fTCPIPAvailable = TRUE;
            }
        }
        RegCloseKey(hk);
    }

    return (fTCPIPAvailable);
}


BOOL _ChangeMachineName(HWND hwnd, WCHAR* pszDomainUser, WCHAR* pszPassword)
{
    BOOL fSuccess = FALSE;

    // the user has entered a short computer name (possibly a DNS host name), retrieve it
    WCHAR szNewShortMachineName[MAX_COMPUTERNAME + 1];
    FetchText(hwnd, IDC_COMPUTERNAME, szNewShortMachineName, ARRAYSIZE(szNewShortMachineName));
    
    // get the current short computer name
    WCHAR szOldShortMachineName[MAX_COMPUTERNAME + 1];
    DWORD cchShort = ARRAYSIZE(szOldShortMachineName);
    BOOL fGotOldName = GetComputerName(szOldShortMachineName, &cchShort);
    if (fGotOldName)
    {
        // did the user change the short computer name?
        if (0 != StrCmpI(szOldShortMachineName, szNewShortMachineName))
        {
            g_fMachineRenamed = TRUE;            
            // if so we need to rename the machine in the domain. For this we need the NetBIOS computer name
            WCHAR szNewNetBIOSMachineName[MAX_COMPUTERNAME + 1];

            // Get the netbios name from the short name
            DWORD cchNetbios = ARRAYSIZE(szNewNetBIOSMachineName);
            DnsHostnameToComputerName(szNewShortMachineName, szNewNetBIOSMachineName, &cchNetbios);

            // rename the computer in the domain
            NET_API_STATUS rename_status = ::NetRenameMachineInDomain(0, szNewNetBIOSMachineName,
                pszDomainUser, pszPassword, NETSETUP_ACCT_CREATE);

            // if the domain rename succeeded
            BOOL fDomainRenameSucceeded = (rename_status == ERROR_SUCCESS);
            if (fDomainRenameSucceeded)
            {
                // set the new short name locally
                BOOL fLocalRenameSucceeded;

                // do we have TCPIP?
                if (_IsTCPIPAvailable())
                {
                    // We can set the name using the short name
                    fLocalRenameSucceeded = ::SetComputerNameEx(ComputerNamePhysicalDnsHostname,
                        szNewShortMachineName);
                }
                else
                {
                    // We need to set using the netbios name - kind of a hack
                    fLocalRenameSucceeded = ::SetComputerNameEx(ComputerNamePhysicalNetBIOS,
                        szNewNetBIOSMachineName);
                }

                fSuccess = fLocalRenameSucceeded;
            }

			// Handle errors that may have occured changing the name
            if (rename_status != ERROR_SUCCESS)
            {
                TCHAR szMessage[512];

                switch (rename_status)
                {
                case NERR_UserExists:
                    {
                        // We don't really mean "user exists" in this case, we mean
                        // "computer name exists", so load that reason string
                        LoadString(g_hinst, IDS_COMPNAME_EXISTS, szMessage, ARRAYSIZE(szMessage));
                    }
                    break;
                default:
                    {
                        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) rename_status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));
                    }
                    break;
                }

                // Note that this is not a hard error, so we use the information icon
                ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_NAW_NAMECHANGE_ERROR, MB_OK|MB_ICONINFORMATION, szMessage);
            }
        }
		else
		{
			// Computer name hasn't changed - just return success
			fSuccess = TRUE;
		}
    }

    return(fSuccess);
}


// handle processing the changes

HRESULT _ChangeNameAndJoin(HWND hwnd)
{
    WCHAR szDomain[MAX_DOMAIN + 1];
    WCHAR szUser[MAX_DOMAINUSER + 1]; szUser[0] = 0;
    WCHAR szPassword[MAX_PASSWORD + 1]; szPassword[0] = 0;

    BOOL fNameChangeSucceeded = FALSE;
    FetchText(hwnd, IDC_DOMAIN, szDomain, ARRAYSIZE(szDomain));

    // try to join the new domain
    
    TCHAR szUserDomain[MAX_DOMAIN + 1]; *szUserDomain = 0;
    CREDINFO ci = { szUser, ARRAYSIZE(szUser), szUserDomain, ARRAYSIZE(szUserDomain), szPassword, ARRAYSIZE(szPassword) };

    HRESULT hres = JoinDomain(hwnd, TRUE, szDomain, &ci, &g_fRebootOnExit);
    if (SUCCEEDED(hres))
    {
#ifndef DONT_JOIN
        LPTSTR pszUser = szUser[0] ? szUser : NULL;
        LPTSTR pszPassword = szPassword[0] ?szPassword : NULL;
        fNameChangeSucceeded = _ChangeMachineName(hwnd, pszUser, pszPassword);
#endif
    }

    return hres;;
}


// ensure the wizard buttons reflect what we can do

BOOL _CompInfoBtnState(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;

    if ( !FetchTextLength(hwnd, IDC_COMPUTERNAME) )
        dwButtons &= ~PSWIZB_NEXT;
    if ( !FetchTextLength(hwnd, IDC_DOMAIN) )
        dwButtons &= ~PSWIZB_NEXT;

    SetWizardButtons(hwnd, dwButtons);
    return TRUE;
}


BOOL _ValidateMachineName(HWND hwnd)
{
    BOOL fNameInUse = FALSE;
    NET_API_STATUS name_status = NERR_Success;

    // the user has entered a short computer name (possibly a DNS host name), retrieve it
    WCHAR szNewShortMachineName[MAX_COMPUTERNAME + 1];
    FetchText(hwnd, IDC_COMPUTERNAME, szNewShortMachineName, ARRAYSIZE(szNewShortMachineName));
    
    // get the current short computer name
    WCHAR szOldShortMachineName[MAX_COMPUTERNAME + 1];
    DWORD cchShort = ARRAYSIZE(szOldShortMachineName);
    BOOL fGotOldName = GetComputerName(szOldShortMachineName, &cchShort);
    if (fGotOldName)
    {
        // did the user change the short computer name?
        if (0 != StrCmpI(szOldShortMachineName, szNewShortMachineName))
        {
            // first we need to check the flat, netbios name
            WCHAR szNewNetBIOSMachineName[MAX_COMPUTERNAME + 1];

            // Get the netbios name from the short name
            DWORD cchNetbios = ARRAYSIZE(szNewNetBIOSMachineName);
            DnsHostnameToComputerName(szNewShortMachineName, szNewNetBIOSMachineName, &cchNetbios);
            
            name_status = NetValidateName(NULL, szNewNetBIOSMachineName, NULL, NULL, NetSetupMachine);
        }
    }

    if (name_status != NERR_Success)
    {
        TCHAR szMessage[512];

        if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) name_status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
            LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

        ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_MACHINENAMEINUSE, MB_ICONERROR | MB_OK, szMessage);
    }

    return (name_status == NERR_Success);
}


INT_PTR CALLBACK _CompInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);
            Edit_LimitText(GetDlgItem(hwnd, IDC_COMPUTERNAME), MAX_COMPUTERNAME);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    WCHAR szCompName[MAX_PATH + 1], szMessage[MAX_PATH+MAX_DOMAIN];
                    DWORD dwBuffer = ARRAYSIZE(szCompName);

                    // fill in the user domain

                    FormatMessageString(IDS_COMPNOTFOUND, szMessage, ARRAYSIZE(szMessage), g_szDomain);
                    SetDlgItemText(hwnd, IDC_COMPINFO, szMessage);

                    // default the computer name to something sensible

                    GetComputerName(szCompName, &dwBuffer);

                    SetDlgItemText(hwnd, IDC_COMPUTERNAME, szCompName);
                    SetDlgItemText(hwnd, IDC_DOMAIN, g_szCompDomain);

                    return _CompInfoBtnState(hwnd);
                }

                case PSN_WIZBACK:
                    WIZARDNEXT(hwnd, IDD_PSW_USERINFO);
                    return TRUE;

                case PSN_WIZNEXT:
                {
                    INT idNextPage = -1;

                    if (_ValidateMachineName(hwnd))
                    {
                        if (SUCCEEDED(_ChangeNameAndJoin(hwnd)))
                        {
                            if (!g_fMachineRenamed)
                            {
                                idNextPage = IDD_PSW_ADDUSER;
                            }
                            else
                            {
                                idNextPage = IDD_PSW_DONE;
                            }
                        }
                    }

                    WIZARDNEXT(hwnd, idNextPage);
                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            if ( HIWORD(wParam) == EN_CHANGE )
                return _CompInfoBtnState(hwnd);

            break;
        }
    }

    return FALSE;
}




// changing the group membership for the user, adds a domain user to a local group on the machine
// eg. NET LOCALGROUP /ADD

BOOL _AddUserToGroup(HWND hwnd, LPCTSTR pszLocalGroup, LPCWSTR pszUser, LPCWSTR pszDomain)
{
#ifndef DONT_JOIN
    BOOL fResult = FALSE;
    NET_API_STATUS nas;
    LOCALGROUP_MEMBERS_INFO_3 lgm;
    TCHAR szDomainUser[MAX_DOMAINUSER + 1];
    CWaitCursor cur;

    MakeDomainUserString(pszDomain, pszUser, szDomainUser, ARRAYSIZE(szDomainUser));
    lgm.lgrmi3_domainandname = szDomainUser;

    nas = NetLocalGroupAddMembers(NULL, pszLocalGroup, 3, (BYTE *)&lgm, 1);
    switch ( nas )
    {
        // Success conditions
        case NERR_Success:
        case ERROR_MEMBER_IN_GROUP:
        case ERROR_MEMBER_IN_ALIAS:
        {
            fResult = TRUE;
            break;
        }
        case ERROR_INVALID_MEMBER:
        {
            DisplayFormatMessage(hwnd, 
                                 IDS_PERMISSIONS, IDS_ERR_BADUSER,                            
                                 MB_OK|MB_ICONWARNING, pszUser, pszDomain);
                        
            break;
        }

        case ERROR_NO_SUCH_MEMBER:
        {
            DisplayFormatMessage(hwnd,
                                 IDS_PERMISSIONS, IDS_ERR_NOSUCHUSER,
                                 MB_OK|MB_ICONWARNING, pszUser, pszDomain);
            break;
        }
        default:
        {
            TCHAR szMessage[512];

            if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) nas, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

            ::DisplayFormatMessage(hwnd, IDS_ERR_CAPTION, IDS_ERR_ADDUSER, MB_OK|MB_ICONERROR, szMessage);

            fResult = FALSE;

            break;
        }
    }

    return(fResult);
#else
    return TRUE;
#endif
}



// ensure the wizard buttons reflect what we can do

BOOL _PermissionsBtnState(HWND hwnd)
{
    // Next is always valid
    DWORD dwButtons = PSWIZB_NEXT | PSWIZB_BACK;

    SetWizardButtons(hwnd, dwButtons);
    return TRUE;              
}

// BtnState function for _AddUserDlgProc

BOOL _AddUserBtnState(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_NEXT|PSWIZB_BACK;
    BOOL fEnableEdits;

    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_ADDUSER)))
    {
        // Enable the user and domain edits
        fEnableEdits = TRUE;

        if ( !FetchTextLength(hwnd, IDC_USER) )
            dwButtons &= ~PSWIZB_NEXT;
    }
    else
    {
        // Disable user and domain edits
        fEnableEdits = FALSE;
    }

    EnableWindow(GetDlgItem(hwnd, IDC_USER), fEnableEdits);

    if (fEnableEdits)
    {
        EnableDomainForUPN(GetDlgItem(hwnd, IDC_USER), GetDlgItem(hwnd, IDC_DOMAIN));
    }
    else
    {
        EnableWindow(GetDlgItem(hwnd, IDC_DOMAIN), FALSE);
    }

    EnableWindow(GetDlgItem(hwnd, IDC_USER_STATIC), fEnableEdits);
    EnableWindow(GetDlgItem(hwnd, IDC_DOMAIN_STATIC), fEnableEdits);
    SetWizardButtons(hwnd, dwButtons);
    return TRUE;              
}

INT_PTR CALLBACK _AddUserDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            Edit_LimitText(GetDlgItem(hwnd, IDC_USER), MAX_DOMAINUSER);
            Edit_LimitText(GetDlgItem(hwnd, IDC_DOMAIN), MAX_DOMAIN);
            Button_SetCheck(GetDlgItem(hwnd, IDC_ADDUSER), BST_CHECKED);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    SetDlgItemText(hwnd, IDC_USER, g_szUser);
                    SetDlgItemText(hwnd, IDC_DOMAIN, g_szDomain);

                    _AddUserBtnState(hwnd);
                    return TRUE;
                }
                case PSN_WIZBACK:
                {
                    if ( g_uWizardIs == NAW_PSDOMAINJOINED )
                        WIZARDNEXT(hwnd, IDD_PSW_WELCOME);
                    else
                        WIZARDNEXT(hwnd, IDD_PSW_USERINFO);

                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    if (BST_CHECKED == Button_GetCheck(GetDlgItem(hwnd, IDC_ADDUSER)))
                    {
                        FetchText(hwnd, IDC_USER, g_szUser, ARRAYSIZE(g_szUser));
                        FetchText(hwnd, IDC_DOMAIN, g_szDomain, ARRAYSIZE(g_szDomain));

                        if (StrChr(g_szUser, TEXT('@')))
                        {
                            *g_szDomain = 0;
                        }

                        WIZARDNEXT(hwnd, IDD_PSW_PERMISSIONS);
                    }
                    else
                    {
                        WIZARDNEXT(hwnd, IDD_PSW_DONE);
                    }

                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            switch ( HIWORD(wParam) )
            {            
                case EN_CHANGE:
                case BN_CLICKED:
                    _AddUserBtnState(hwnd);
                    break;
            }
            break;
        }
    }

    return FALSE;
}


//
// DlgProc for the permissions page.
//

INT_PTR CALLBACK _PermissionsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Handle local-group related messages
    g_pGroupPageBase->HandleGroupMessage(hwnd, uMsg, wParam, lParam);

    switch ( uMsg )
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;             
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:            
                {
                    // Set the "What level of access do you want to grant %S" message

                    TCHAR szMessage[256];
                    TCHAR szDisplayName[MAX_DOMAINUSER];
    
                    // Make a domain/user string
                    MakeDomainUserString(g_szDomain, g_szUser, szDisplayName, ARRAYSIZE(szDisplayName));

                    FormatMessageString(IDS_WHATACCESS_FORMAT, szMessage, ARRAYSIZE(szMessage), szDisplayName);
                    SetDlgItemText(hwnd, IDC_WHATACCESS, szMessage);
                    
                    return _PermissionsBtnState(hwnd);
                }
                case PSN_WIZBACK:
                {
                    WIZARDNEXT(hwnd, IDD_PSW_ADDUSER);

                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    // Get the local group here! TODO
                    TCHAR szGroup[MAX_GROUP + 1];

                    CUserInfo::GROUPPSEUDONYM gs;
                    g_pGroupPageBase->GetSelectedGroup(hwnd, szGroup, ARRAYSIZE(szGroup), &gs);

                    if ( !_AddUserToGroup(hwnd, szGroup, g_szUser, g_szDomain) )
                    {
                        WIZARDNEXT(hwnd, -1);
                    }
                    else
                    {
                        SetDefAccount(g_szUser, g_szDomain);
                        WIZARDNEXT(hwnd, IDD_PSW_DONE);
                    }

                    return TRUE;
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            switch ( HIWORD(wParam) )
            {            
                case EN_CHANGE:
                    return _PermissionsBtnState(hwnd);
            }
            break;
        }
    }

    return FALSE;
}


// pages that make up the wizard

#define WIZDLG(name, dlgproc, dwFlags)   \
            { MAKEINTRESOURCE(IDD_PSW_##name##), dlgproc, MAKEINTRESOURCE(IDS_##name##), MAKEINTRESOURCE(IDS_##name##_SUB), dwFlags }

WIZPAGE pages[] =
{    
    WIZDLG(WELCOME,     _IntroDlgProc,       PSP_HIDEHEADER),
    WIZDLG(HOWUSE,      _HowUseDlgProc,      0),
    WIZDLG(WHICHNET,    _WhichNetDlgProc,    0),
    WIZDLG(DOMAININFO,  _DomainInfoDlgProc,  0),
    WIZDLG(USERINFO,    _UserInfoDlgProc,    0),
    WIZDLG(COMPINFO,    _CompInfoDlgProc,    0),
    WIZDLG(ADDUSER,     _AddUserDlgProc,     0),
    WIZDLG(PERMISSIONS, _PermissionsDlgProc, 0),
    WIZDLG(WORKGROUP,   _WorkgroupDlgProc,   0),
    WIZDLG(DONE,        _DoneDlgProc,        PSP_HIDEHEADER), 
};

STDAPI NetAccessWizard(HWND hwnd, UINT uType, BOOL *pfReboot)
{
    // init comctrl

    INITCOMMONCONTROLSEX iccex = { 0 };
    iccex.dwSize = sizeof (iccex);
    iccex.dwICC = ICC_LISTVIEW_CLASSES;

    InitCommonControlsEx(&iccex);

    switch (uType)
    {
        case NAW_NETID:
            break;

        case NAW_PSDOMAINJOINFAILED:
            g_dwWhichNet = IDC_NONE;
            g_uWizardIs = uType;
            break;

        case NAW_PSDOMAINJOINED:
            g_dwWhichNet = IDC_DOMAIN;
            g_uWizardIs = uType;
            break;

        default:
            return E_INVALIDARG;
    }

    // create the pages

    HPROPSHEETPAGE rghpage[ARRAYSIZE(pages)];
    INT cPages = 0;
    for (cPages = 0 ; cPages < ARRAYSIZE(pages) ; cPages++)
    {                           
        PROPSHEETPAGE psp = { 0 };
        WCHAR szBuffer[MAX_PATH] = { 0 };

        psp.dwSize = SIZEOF(PROPSHEETPAGE);
        psp.hInstance = g_hinst;
        psp.lParam = cPages;
        psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | 
                            PSP_USEHEADERSUBTITLE | pages[cPages].dwFlags;
        psp.pszTemplate = pages[cPages].idPage;
        psp.pfnDlgProc = pages[cPages].pDlgProc;
        psp.pszTitle = MAKEINTRESOURCE(IDS_NETWIZCAPTION);
        psp.pszHeaderTitle = pages[cPages].pHeading;
        psp.pszHeaderSubTitle = pages[cPages].pSubHeading;

        rghpage[cPages] = CreatePropertySheetPage(&psp);
    }

    // display the wizard

    PROPSHEETHEADER psh = { 0 };
    psh.dwSize = SIZEOF(PROPSHEETHEADER);
    psh.hwndParent = hwnd;
    psh.hInstance = g_hinst;
    psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | 
                            PSH_STRETCHWATERMARK | PSH_HEADER | PSH_USECALLBACK;
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_PSW_BANNER);
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_PSW_WATERMARK);
    psh.nPages = cPages;
    psh.phpage = rghpage;
    psh.pfnCallback = _PropSheetCB;

    // Create the global CGroupPageBase object if necessary
    CGroupInfoList grouplist;
    if (SUCCEEDED(grouplist.Initialize()))
    {
        g_pGroupPageBase = new CGroupPageBase(NULL, &grouplist);

        if (NULL != g_pGroupPageBase)
        {
            PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_PSW));
            delete g_pGroupPageBase;
        }
    }

    //
    // Hang up the all RAS connections if the wizard created one. It is assumed that no non-wizard connections will
    // exist at this time. 90% of the time, they've just changed their domain membership anyway to they will
    // be just about to reboot. Hanging up all connections MAY cause trouble if: There were existing connections
    // before the pre-logon wizard started AND the user cancelled after making connections with the wizard but before
    // changing their domain. There are no situations where this currently happens.
    //

    if (g_fCreatedConnection)
    {
        RASCONN* prgrasconn = (RASCONN*) LocalAlloc(0, sizeof(RASCONN));

        if (NULL != prgrasconn)
        {
            prgrasconn[0].dwSize = sizeof(RASCONN);

            DWORD cb = sizeof(RASCONN);
            DWORD nConn = 0;

            DWORD dwSuccess = RasEnumConnections(prgrasconn, &cb, &nConn);

            if (ERROR_BUFFER_TOO_SMALL == dwSuccess)
            {
                LocalFree(prgrasconn);
                prgrasconn = (RASCONN*) LocalAlloc(0, cb);

                if (NULL != prgrasconn)
                {
                    prgrasconn[0].dwSize = sizeof(RASCONN);
                    dwSuccess = RasEnumConnections(prgrasconn, &cb, &nConn);
                }
            }

            if (0 == dwSuccess)
            {
                // Make sure we have one and only one connection before hanging up
                for (DWORD i = 0; i < nConn; i ++)
                {
                    RasHangUp(prgrasconn[i].hrasconn);
                }
            }

            LocalFree(prgrasconn);
        }
    }

    //
    // restart the machine if we need to, eg: the domain changed
    //

    if (pfReboot)
        *pfReboot = g_fRebootOnExit;

    //
    // if this is coming from setup, then lets display the message
    //

    if (g_fRebootOnExit && !g_fShownLastPage && (g_uWizardIs != NAW_NETID))
    {
        ShellMessageBox(g_hinst, 
                        hwnd,
                        MAKEINTRESOURCE(IDS_RESTARTREQUIRED), MAKEINTRESOURCE(IDS_NETWIZCAPTION),
                        MB_OK);        
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\pubhelp.cpp ===
#include "stdafx.h"
#include "shimgdata.h"
#include "shui.h"
#include "netplace.h"
#include <Ntquery.h>
#include <shellp.h>
#include "pubwiz.h"
#include "gdiplus\gdiplus.h"
#include "imgprop.h"
#pragma hdrstop


// handle the provider list XML document, reading properties etc.

HRESULT GetStrFromElement(IXMLDOMNode *pdn, LPCTSTR pszElementName, LPTSTR pszBuffer, int cch)
{
    HRESULT hr;

    IXMLDOMNode *pdnElement;
    if (pszElementName)
        hr = pdn->selectSingleNode((BSTR)pszElementName, &pdnElement);
    else
        hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdnElement));

    if (SUCCEEDED(hr) && (hr == S_OK))
    {
        VARIANT var = {VT_BSTR};
        hr = pdnElement->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            VariantToStr(&var, pszBuffer, cch);
            VariantClear(&var);
        }
        pdnElement->Release();
    }
    return (hr == S_FALSE) ? E_FAIL:hr;
}

HRESULT GetStrFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPTSTR pszBuffer, int cch)
{
    IXMLDOMElement *pdel;
    HRESULT hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
    if (SUCCEEDED(hr))
    {
        VARIANT var = {VT_BSTR};
        hr = pdel->getAttribute((BSTR)pszAttribute, &var);
        if (S_OK == hr)
        {
            VariantToStr(&var, pszBuffer, cch);
            VariantClear(&var);
        }
        pdel->Release();
    }
    return (hr == S_FALSE) ? E_FAIL:hr;
}

HRESULT GetIntFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, int *piValue)
{
    TCHAR szBuffer[64];
    HRESULT hr = GetStrFromAttribute(pdn, pszAttribute, szBuffer, ARRAYSIZE(szBuffer));
    if (SUCCEEDED(hr))
    {
        hr = StrToIntEx(szBuffer, STIF_SUPPORT_HEX, piValue) ? S_OK:E_FAIL;
    }
    return hr;
}

HRESULT CreateElement(IXMLDOMDocument *pdoc, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelResult)
{
    IXMLDOMElement *pdel;
    HRESULT hr = pdoc->createElement((BSTR)pszName, &pdel);
    if (SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_I4;
        var.lVal = NODE_TEXT;

        IXMLDOMNode *pdnText;
        hr = pdoc->createNode(var, NULL, NULL, &pdnText);
        if (SUCCEEDED(hr))
        {
            if (pvar)
                hr = pdnText->put_nodeTypedValue(*pvar);

            if (SUCCEEDED(hr))
            {
                IXMLDOMNode *pdn;
                hr = pdel->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdn));
                if (SUCCEEDED(hr))
                {
                    hr = pdn->appendChild(pdnText, NULL);
                    pdn->Release();
                }
            }
            pdnText->Release();
        }

        hr = pdel->QueryInterface(IID_PPV_ARG(IXMLDOMElement, ppdelResult));
        pdel->Release();
    }
    return hr;
}

HRESULT CreateAndAppendElement(IXMLDOMDocument *pdoc, IXMLDOMNode *pdnParent, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelOut)
{
    IXMLDOMElement *pdel;
    HRESULT hr = CreateElement(pdoc, pszName, pvar, &pdel);
    if (SUCCEEDED(hr))
    {
        hr = pdnParent->appendChild(pdel, NULL);
        if (SUCCEEDED(hr) && ppdelOut)
        {
            hr = pdel->QueryInterface(IID_PPV_ARG(IXMLDOMElement, ppdelOut));
        }
        pdel->Release();
    }
    return hr;
}

void SpewXML(IUnknown *punk)
{
    IXMLDOMNode *pdn;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdn));
    if (SUCCEEDED(hr))
    {
        BSTR bstrXML;
        hr = pdn->get_xml(&bstrXML);
        if (SUCCEEDED(hr))
        {
            MessageBox(NULL, bstrXML, NULL, MB_OK);
            SysFreeString(bstrXML);
        }
        pdn->Release();
    }
}


// this helper is here for compatibility with previous manifest formats, first look for
// a HREF attribute, if its not defined then look for the body text to be the URL.

HRESULT GetURLFromElement(IXMLDOMNode *pdn, LPCTSTR pszElement, LPTSTR pszBuffer, int cch)
{
    IXMLDOMNode *pdnElement;
    HRESULT hr = pdn->selectSingleNode((BSTR)pszElement, &pdnElement);
    if (hr == S_OK)
    {
        hr = GetStrFromAttribute(pdnElement, L"href", pszBuffer, cch);
        pdnElement->Release();
    }

    if (hr != S_OK)
        hr = GetStrFromElement(pdn, pszElement, pszBuffer, cch);

    return hr;
}


// set an attribute to a string

HRESULT SetAttributeFromStr(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPCTSTR pszValue)
{
    VARIANT var;
    HRESULT hr = InitVariantFromStr(&var, pszValue);
    if (SUCCEEDED(hr))
    {
        IXMLDOMElement *pdel;
        hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
        if (SUCCEEDED(hr))
        {
            hr = pdel->setAttribute((BSTR)pszAttribute, var);
            pdel->Release();
        }
        VariantClear(&var);
    }
    return hr;
}


// wrapper for WNetGetConnection to fix drive root case.

DWORD SHWNetGetConnection(LPCTSTR lpLocalName, LPCTSTR lpRemoteName, LPDWORD lpnLength)
{
    WCHAR szLocalName[3];

    // Kludge allert, don't pass c:\ to API, instead only pass C:
    if (lpLocalName && lstrlen(lpLocalName) > 2)
    {
        szLocalName[0] = lpLocalName[0];
        szLocalName[1] = L':';
        szLocalName[2] = 0;
        lpLocalName = szLocalName;
    }

    return WNetGetConnection(lpLocalName, (LPWSTR)lpRemoteName, lpnLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\passportmisc.cpp ===
#include <stdafx.h>
#include "misc.h"

#define HTTPS_URL_SCHEME            L"https://"
#define HTTPS_URL_SCHEME_CCH        (ARRAYSIZE(HTTPS_URL_SCHEME) - 1)

//  wininet reg key
#define WININET_REG_LOC   L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\passport"
#define WININET_NEXUS_API   "ForceNexusLookupExW"
#define PASSPORT_MAX_URL    1024

typedef BOOL (STDAPICALLTYPE *PFNFORCENEXUSLOOKUPEXW) (
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    );

// Misc functions
HRESULT PassportGetURL(PCWSTR pszName, PWSTR pszBuf, PDWORD pdwBufLen);
VOID    PassportForceNexusRepopulate();

class CPassportClientServices : 
    public CObjectSafety,
    public CImpIDispatch,
    public IPassportClientServices
{
public:
    CPassportClientServices() : 
        CImpIDispatch(LIBID_Shell32, 1, 0, IID_IPassportClientServices),
        _cRef(1) {}

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo)
    { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
    { return CImpIDispatch::GetTypeInfo(iTInfo, lcid, ppTInfo); }
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
    { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId); }
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    { return CImpIDispatch::Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr); }

    // IPassportClientServices
    STDMETHOD(MemberExists)(BSTR bstrUser, BSTR bstrPassword, VARIANT_BOOL* pvfExists);

private:
    long _cRef;
};

STDAPI CPassportClientServices_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPassportClientServices *pPCS = new CPassportClientServices();
    if (!pPCS)
        return E_OUTOFMEMORY;

    HRESULT hr = pPCS->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pPCS->Release();
    return hr;
}

ULONG CPassportClientServices::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPassportClientServices::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPassportClientServices::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPassportClientServices, IObjectSafety),             // IID_IObjectSafety
        QITABENT(CPassportClientServices, IDispatch),                 // IID_IDispatch
        QITABENT(CPassportClientServices, IPassportClientServices),   // IID_IPassportClientServices
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

// DONT_USE_HTTPS - Uncomment this #define to turn off secure sending of information - for debugging purposes only
HRESULT CPassportClientServices::MemberExists(BSTR bstrUser, BSTR bstrPassword, VARIANT_BOOL* pvfExists)
{
    *pvfExists = VARIANT_FALSE;

    WCHAR szURL[PASSPORT_MAX_URL];
    DWORD cch = PASSPORT_MAX_URL;
    HRESULT hr = PassportGetURL(PASSPORTURL_LOGON, szURL, &cch);
    if (SUCCEEDED(hr))
    {
        PBYTE lpBuffer = NULL;
        if (0 == StrCmpNI(szURL, HTTPS_URL_SCHEME, HTTPS_URL_SCHEME_CCH))
        {
            PWSTR pszServer = szURL + HTTPS_URL_SCHEME_CCH;
            //  NULL terminate
            PWSTR psz = wcschr(pszServer, L'/');
            if (psz)
            {
                *psz = L'\0';
            }

            HINTERNET hInternet = InternetOpen(L"Shell Registration",
                                         INTERNET_OPEN_TYPE_PRECONFIG,
                                         NULL,
                                         NULL,
                                         0);
            if (hInternet)
            {
                HINTERNET hConnection = InternetConnectW(hInternet,
                                                  pszServer,
                                                  INTERNET_DEFAULT_HTTPS_PORT,
                                                  bstrUser,
                                                  bstrPassword,
                                                  INTERNET_SERVICE_HTTP,
                                                  0,
                                                  0);
                if (psz)
                {
                    *psz = L'/';
                }

                if (hConnection)
                {
                    //  set username/pwd
                    //  send the GET request
                    HINTERNET hRequest = HttpOpenRequest(hConnection,
                                                     NULL,
                                                     psz,
                                                     L"HTTP/1.1",
                                                     NULL,
                                                     NULL,
                                                     INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_SECURE,
                                                     0);
                    if (hRequest)
                    {
                        if (HttpSendRequest(hRequest, NULL, 0, NULL, 0))
                        {
                            DWORD dwStatus, dwLength = sizeof(dwStatus);
                            if (HttpQueryInfo(hRequest,
                                              HTTP_QUERY_STATUS_CODE |
                                                HTTP_QUERY_FLAG_NUMBER,
                                              &dwStatus,
                                              &dwLength,
                                              NULL))
                            {
                                //  if 200, member is there ...
                                if (dwStatus == 200)
                                {
                                    *pvfExists = VARIANT_TRUE;
                                }
                            }
                        }
                        InternetCloseHandle(hRequest);
                    }
                    InternetCloseHandle(hConnection);
                }
                InternetCloseHandle(hInternet);
            }
        }
    }

    return S_OK;
}

//
//  read registry for the desired URL
//

HRESULT _PassportGetURLFromHKey(HKEY hkey, PCWSTR pszName, PWSTR pszBuf, PDWORD pdwBufLen)
{
    HRESULT hr = E_FAIL;

    HKEY hk;
    LONG lErr = RegOpenKeyExW(hkey,
                              WININET_REG_LOC,
                              0,
                              KEY_READ,
                              &hk);
    if (!lErr)
    {
        DWORD type;
        lErr = RegQueryValueExW(hk,
                               pszName,
                               0,
                               &type,
                               (PBYTE)pszBuf,
                               pdwBufLen);
        if ((!lErr) &&
            (L'\0' != *pszBuf))
        {
           hr = S_OK;
        }

        RegCloseKey(hk);
    }

    return hr;
}

HRESULT PassportGetURL(PCWSTR pszName, PWSTR pszBuf, PDWORD pdwBufLen)
{
    PassportForceNexusRepopulate();
    
    HRESULT hr = _PassportGetURLFromHKey(HKEY_LOCAL_MACHINE, pszName, pszBuf, pdwBufLen);

    if (FAILED(hr))
    {
        hr = _PassportGetURLFromHKey(HKEY_CURRENT_USER, pszName, pszBuf, pdwBufLen);
    }

    return hr;
}

//
//  populate nexus values
//

// #define USE_PRIVATE_WININET
VOID PassportForceNexusRepopulate()
{
#ifdef USE_PRIVATE_WININET
    HMODULE hm = LoadLibraryA(".\\wininet.dll");
#else
    HMODULE hm = LoadLibraryA("wininet.dll");
#endif
    if (hm)
    {
        PFNFORCENEXUSLOOKUPEXW pfnForceNexusLookupExW = (PFNFORCENEXUSLOOKUPEXW) GetProcAddress(hm, WININET_NEXUS_API);
        if (pfnForceNexusLookupExW)
        {
            pfnForceNexusLookupExW(TRUE, NULL, 0, NULL, 0);
        }
        FreeLibrary(hm);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\pubpost.cpp ===
#include "stdafx.h"
#include "pubwiz.h"
#include "netplace.h"
#pragma hdrstop


// this code works by building a multi-part post

LARGE_INTEGER g_li0 = {0};


// IStream class that wraps up the multi-part post into a single object.

#define BOUNDARY TEXT("------WindowsPublishWizard")

LPCTSTR c_pszBoundary    = (TEXT("--") BOUNDARY);
LPCTSTR c_pszBoundaryEOF = (TEXT("\r\n") TEXT("--") BOUNDARY TEXT("--"));
LPWSTR  c_pszContentType = (TEXT("multipart/form-data; boundary=") BOUNDARY);

LPCTSTR c_szFmtContent   = (TEXT("content-disposition: form-data; name=\"%s\""));
LPCTSTR c_szFmtFilename  = (TEXT("; filename=\"%s\""));
LPCTSTR c_szCRLF         = (TEXT("\r\n"));


/* 8c1e9993-7a84-431d-8c03-527f0fb147c5 */
CLSID IID_IPostStream = {0x8c1e9993, 0x7a84, 0x431d, {0x8c, 0x03, 0x52, 0x7f, 0x0f, 0xb1, 0x47, 0xc5}};

DECLARE_INTERFACE_(IPostStream, IStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // **** IPostStream ****
    STDMETHOD(SetTransferSink)(ITransferAdviseSink *ptas, ULONGLONG ulTotal, ULONGLONG ulCurrent);
};


// stream wrapper that expoes the binary data for the file as a multi-part stream object

class CPostStream : public IPostStream
{
public:
    CPostStream();

    HRESULT Initialize(IStorage *pstg, TRANSFERITEM *pti);

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)( REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // *** IStream methods ***
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(VOID const *pv, ULONG cb, ULONG *pcbWritten)
        { return E_NOTIMPL; }
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
        { return E_NOTIMPL; }
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize)
        { return E_NOTIMPL; }
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
        { return E_NOTIMPL; }
    STDMETHOD(Commit)(DWORD grfCommitFlags)
        { return E_NOTIMPL; }
    STDMETHOD(Revert)()
        { return E_NOTIMPL; }
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return E_NOTIMPL; }
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
        { return E_NOTIMPL; }
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm)
        { return E_NOTIMPL; }

    STDMETHOD(SetTransferSink)(ITransferAdviseSink *ptas, ULONGLONG ulTotal, ULONGLONG ulCurrent);

protected:
    ~CPostStream();

    static int s_ReleaseStream(IStream *pstrm, void *pv);

    HRESULT _WriteString(IStream *pstrm, LPCTSTR pszString);
    HRESULT _WriteStringCRLF(IStream *pstrm, LPCTSTR pszString);
    HRESULT _AddBoundaryMarker(IStream *pstrm, BOOL fLeadingCRLF, LPCTSTR pszName, LPCTSTR pszFilename);
    HRESULT _AddStream(IStream *pstrm);
    HRESULT _CreateMemoryStream(REFIID riid, void **ppv);

    LONG _cRef;

    IShellItem *_psi;
    ITransferAdviseSink *_ptas;

    // stream array we use to transfer the bits
    CDPA<IStream> _dpaStreams;
    int _iCurStream;

    // current seek pointers into the stream
    ULONGLONG _ulCurrent;
    ULONGLONG _ulTotal;

    // current seek pointers overal into the transfer
    ULONGLONG _ulOverallCurrent;
    ULONGLONG _ulOverallTotal;
};


// unknown / qi handler

CPostStream::CPostStream() :
    _cRef(1)
{
}

CPostStream::~CPostStream()
{
    if (_dpaStreams != NULL)
    {
        _dpaStreams.DestroyCallback(s_ReleaseStream, this);
        _iCurStream = 0;
    }

    if (_ptas)
        _ptas->Release();
}


// handle IUnknown

ULONG CPostStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPostStream::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPostStream::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPostStream, IStream),    // IID_IStream
        QITABENT(CPostStream, IPostStream),    // IID_IPostStream
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}



// handle writing data into a stream for building the post

HRESULT CPostStream::_WriteString(IStream *pstrm, LPCTSTR pszString)
{
    USES_CONVERSION;
    ULONG cb = lstrlen(pszString) * sizeof(CHAR);
    return pstrm->Write(T2A(pszString), cb, NULL);
}

HRESULT CPostStream::_WriteStringCRLF(IStream *pstrm, LPCTSTR pszString)
{
    HRESULT hr = _WriteString(pstrm, pszString);
    if (SUCCEEDED(hr))
    {
        hr = _WriteString(pstrm, c_szCRLF);
    }
    return hr;
}

HRESULT CPostStream::_AddBoundaryMarker(IStream *pstrm, BOOL fLeadingCRLF, LPCTSTR pszName, LPCTSTR pszFilename)
{
    HRESULT hr = S_OK;

    // add the boundary marker
    if (fLeadingCRLF)
        hr = _WriteString(pstrm, c_szCRLF);

    if (SUCCEEDED(hr))
    {
        hr = _WriteStringCRLF(pstrm, c_pszBoundary);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[MAX_PATH];        
            
            // format up the content disp + name attribute           
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), c_szFmtContent, pszName);
            hr = _WriteString(pstrm, szBuffer);
       
            // if we have a filename then lets put that into the line also
            if (SUCCEEDED(hr) && pszFilename)
            {
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), c_szFmtFilename, pszFilename);
                hr = _WriteString(pstrm, szBuffer);
            }

            // finish it off with a CR/LF            
            if (SUCCEEDED(hr))
            {
                _WriteString(pstrm, c_szCRLF);
                _WriteString(pstrm, c_szCRLF);
            }
        }
    }

    return hr;
}


// stream management functions

int CPostStream::s_ReleaseStream(IStream *pstrm, void *pv)
{
    pstrm->Release();
    return 1;
}

HRESULT CPostStream::_AddStream(IStream *pstrm)
{
    HRESULT hr = (-1 == _dpaStreams.AppendPtr(pstrm)) ? E_FAIL:S_OK;
    if (SUCCEEDED(hr))
    {
        pstrm->AddRef();
    }
    return hr;
}

HRESULT CPostStream::_CreateMemoryStream(REFIID riid, void **ppv)
{
    IStream *pstrm = SHCreateMemStream(NULL, 0);
    if (!pstrm)
        return E_OUTOFMEMORY;

    // lets add it to our list and return a refernce if needed

    HRESULT hr = _AddStream(pstrm);
    if (SUCCEEDED(hr))
    {
        hr = pstrm->QueryInterface(riid, ppv);
    }
    pstrm->Release();
    return hr;
}


// handle initialising the handler

HRESULT CPostStream::Initialize(IStorage *pstg, TRANSFERITEM *pti)
{
    HRESULT hr = pti->psi->QueryInterface(IID_PPV_ARG(IShellItem, &_psi));
    if (SUCCEEDED(hr))
    {
        hr = _dpaStreams.Create(4) ? S_OK:E_FAIL;
        if (SUCCEEDED(hr))
        {
            // first comes the file bits, this consists of two stream:
            //
            //  1) boundary marker
            //  2) file bits (reference to real bits on file system)

            IStream *pstrm;
            hr = _CreateMemoryStream(IID_PPV_ARG(IStream, &pstrm));
            if (SUCCEEDED(hr))
            {
                hr = _AddBoundaryMarker(pstrm, FALSE, pti->szName, pti->szFilename);
                if (SUCCEEDED(hr))
                {
                    IStream *pstrmFile;

                    // if we are recompressing this stream then apply it accordingly by
                    // creating an in memory stream that represents the file bits.

                    if (pti->fResizeOnUpload)
                    {
                        IImageRecompress *pir;
                        hr = CoCreateInstance(CLSID_ImageRecompress, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImageRecompress, &pir));
                        if (SUCCEEDED(hr))
                        {
                            hr = pir->RecompressImage(_psi, pti->cxResize, pti->cyResize, pti->iQuality, pstg, &pstrmFile);
                            pir->Release();
                        }
                    }

                    if (!pti->fResizeOnUpload || (hr != S_OK))
                        hr = _psi->BindToHandler(NULL, BHID_Stream, IID_PPV_ARG(IStream, &pstrmFile));

                    if (SUCCEEDED(hr))
                    {
                        hr = _AddStream(pstrmFile);
                        pstrmFile->Release();
                    }
                }
                pstrm->Release();
            }

            // now do we have any form data we need to write into the stream?

            if (pti->dsaFormData != NULL)
            {
                for (int iFormData = 0; SUCCEEDED(hr) && (iFormData < pti->dsaFormData.GetItemCount()); iFormData++)
                {
                    FORMDATA *pfd = pti->dsaFormData.GetItemPtr(iFormData);
                    ASSERT(pfd != NULL);

                    IStream *pstrm;
                    hr = _CreateMemoryStream(IID_PPV_ARG(IStream, &pstrm));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szBuffer[MAX_PATH];
                
                        // convert the variants - useful for passing across thread boundary
                        // to strings and form into a stream.

                        VariantToStr(&pfd->varName, szBuffer, ARRAYSIZE(szBuffer));                        
                        hr = _AddBoundaryMarker(pstrm, TRUE, szBuffer, NULL);
                        if (SUCCEEDED(hr))
                        {
                            VariantToStr(&pfd->varValue, szBuffer, ARRAYSIZE(szBuffer));
                            hr = _WriteString(pstrm, szBuffer);
                        }
                        pstrm->Release();
                    }
                }
            }

            // write EOF into a stream which will be returned.

            if (SUCCEEDED(hr))
            {
                IStream *pstrm;
                hr = _CreateMemoryStream(IID_PPV_ARG(IStream, &pstrm));
                if (SUCCEEDED(hr))
                {
                    hr = _WriteStringCRLF(pstrm, c_pszBoundaryEOF);
                    pstrm->Release();
                }
            }

            // now handle our prep for post, this consists of walking all the streams
            // and processing the data.

            if (SUCCEEDED(hr))
            {
                // now get the total for the stream object that we are going to upload to the site
                STATSTG ststg;
                hr = this->Stat(&ststg, STATFLAG_NONAME);
                if (SUCCEEDED(hr))
                {
                    _ulTotal = ststg.cbSize.QuadPart;
                }

                // seek all the streams to the begining so that we can read from them
                for (int iStream = 0; iStream < _dpaStreams.GetPtrCount(); iStream++)
                {
                    IStream *pstrm = _dpaStreams.GetPtr(iStream);
                    ASSERT(pstrm != NULL);

                    pstrm->Seek(g_li0, 0, NULL);
                }
            }
        }
    }
    return hr;
}

HRESULT CPostStream::SetTransferSink(ITransferAdviseSink *ptas, ULONGLONG ulMax, ULONGLONG ulCurrent)
{
    _ulOverallTotal = ulMax;
    _ulOverallCurrent = ulCurrent;
       
    return ptas->QueryInterface(IID_PPV_ARG(ITransferAdviseSink, &_ptas));
}


// IStream methods

HRESULT CPostStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;
    ULONG cbReadTotal = 0;
    ULONG cbLeftToRead = cb;

    // cancel the stream

    if (_ptas && (_ptas->QueryContinue() == S_FALSE))
    {    
        hr = ERROR_CANCELLED;
    }

    // loop over the streams reading the bits from them

    while ((SUCCEEDED(hr) && hr != S_FALSE) && cbLeftToRead && (_iCurStream < _dpaStreams.GetPtrCount()))
    {
        IStream *pstrm = _dpaStreams.GetPtr(_iCurStream);
        ASSERT(pstrm != NULL);

        ULONG cbReadThisStream;
        hr = pstrm->Read(pv, cbLeftToRead, &cbReadThisStream);
    
        if (SUCCEEDED(hr))
        {
            cbLeftToRead -= cbReadThisStream;
            cbReadTotal += cbReadThisStream;
            pv = (char *)pv + cbReadThisStream;

            if (cbLeftToRead)
            {
                _iCurStream++;
                hr = S_OK;
            }
        }
    }

    // update our seek pointer so we know where we are and notify the progress object

    _ulCurrent = min(_ulTotal, (_ulCurrent + cbReadTotal));
    _ulOverallCurrent = min(_ulOverallTotal, (_ulOverallCurrent + cbReadTotal));
    
    if (_ptas)
    {
        _ptas->OperationProgress(STGOP_COPY, NULL, NULL, _ulOverallTotal, _ulOverallCurrent);
        _ptas->OperationProgress(STGOP_COPY, _psi, NULL, _ulTotal, _ulCurrent);
    }

    // write back the count for the caller
    if (pcbRead)
        *pcbRead = cbReadTotal;

    return hr;
}

HRESULT CPostStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    if (grfStatFlag != STATFLAG_NONAME)
        return E_INVALIDARG;

    ZeroMemory(pstatstg, sizeof(*pstatstg));

    HRESULT hr = S_OK;
    for (int iStream = 0 ; SUCCEEDED(hr) && (iStream < _dpaStreams.GetPtrCount()); iStream++)
    {
        IStream *pstrm = _dpaStreams.GetPtr(iStream);
        ASSERT(pstrm != NULL);

        STATSTG ststg;
        hr = pstrm->Stat(&ststg, STATFLAG_NONAME);
        if (SUCCEEDED(hr))
        {
            pstatstg->cbSize.QuadPart += ststg.cbSize.QuadPart;
        }        
    }
    return hr;
}


// create wrapper, this initializes the object and returns a reference to it.

HRESULT CreatePostStream(TRANSFERITEM *pti, IStorage *pstg, IStream **ppstrm)
{
    CPostStream *pps = new CPostStream();
    if (!pps)
        return E_OUTOFMEMORY;

    HRESULT hr = pps->Initialize(pstg, pti);
    if (SUCCEEDED(hr))
    {
        hr = pps->QueryInterface(IID_PPV_ARG(IStream, ppstrm));
    }
    pps->Release();
    return hr;
}


// this engine posts the files to the site using the manifest

class CPostThread : public IUnknown
{
public:
    CPostThread(TRANSFERINFO *pti);

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT BeginTransfer(CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
    
protected:
    ~CPostThread();

    static DWORD CALLBACK s_ThreadProc(void *pv);
    DWORD _ThreadProc();

    LONG _cRef;

    TRANSFERINFO _ti;                   // transfer info structure 
    CDPA<TRANSFERITEM> _dpaItems;
    IStream *_pstrmSink;
    IStorage *_pstg;

    ULONGLONG _ulTotal;
    ULONGLONG _ulCurrent;
};


// construction destruction

CPostThread::CPostThread(TRANSFERINFO *pti) :
    _cRef(1),
    _ti(*pti)
{
    DllAddRef();
}

CPostThread::~CPostThread()
{
    if (_pstrmSink)
        _pstrmSink->Release();

    if (_pstg)
        _pstg->Release();

    _dpaItems.DestroyCallback(_FreeTransferItems, NULL);

    DllRelease();
}

ULONG CPostThread::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPostThread::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPostThread::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// thread which handles the posting of the files to the site we walk the DPA that we
// have and post each individual file.

DWORD CPostThread::s_ThreadProc(void *pv)
{
    CPostThread *ppt = (CPostThread*)pv;
    return ppt->_ThreadProc();
}   

DWORD CPostThread::_ThreadProc()
{
    ITransferAdviseSink *ptas;
    HRESULT hr = CoGetInterfaceAndReleaseStream(_pstrmSink, IID_PPV_ARG(ITransferAdviseSink, &ptas));
    _pstrmSink = NULL;

    if (SUCCEEDED(hr))
    {
        _ulTotal = 0;
        _ulCurrent = 0;

        // lets create a dyanmic storage that we can use for building the post
        // data into, this will be passed to the stream creator to us.

        hr = CoCreateInstance(CLSID_DynamicStorage, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IStorage, &_pstg));

        // our pre flight sets the global size of the transfer and creates streams for
        // the objects we want to move over.   now get the advise sink and start
        // processing the files.

        for (int iItem = 0 ; SUCCEEDED(hr) && (iItem < _dpaItems.GetPtrCount()); iItem++)
        {   
            TRANSFERITEM *pti = _dpaItems.GetPtr(iItem);

            hr = SHCreateShellItem(NULL, NULL, pti->pidl, &pti->psi);
            if (SUCCEEDED(hr))
            {
                ptas->PreOperation(STGOP_STATS, pti->psi, NULL);

                hr = CreatePostStream(pti, _pstg, &pti->pstrm);
                if (SUCCEEDED(hr))
                {
                    hr = pti->pstrm->Stat(&pti->ststg, STATFLAG_NONAME);
                    if (SUCCEEDED(hr))
                    {
                        _ulTotal += pti->ststg.cbSize.QuadPart;
                    }
                }                

                ptas->PostOperation(STGOP_STATS, pti->psi, NULL, hr);
            }
        }
        
        for (int iItem = 0 ; SUCCEEDED(hr) && (iItem < _dpaItems.GetPtrCount()); iItem++)
        {   
            TRANSFERITEM *pti = _dpaItems.GetPtr(iItem);

            if (ptas->QueryContinue() == S_FALSE)
            {    
                hr = STRESPONSE_CANCEL;
            }
    
            if (SUCCEEDED(hr))
            {
                // notify the object that we are going to transfer
                ptas->PreOperation(STGOP_COPY, pti->psi, NULL);

                IPostStream *pps;
                if (ptas && SUCCEEDED(pti->pstrm->QueryInterface(IID_PPV_ARG(IPostStream, &pps))))
                {
                    pps->SetTransferSink(ptas, _ulTotal, _ulCurrent);
                    pps->Release();
                }

                IXMLHttpRequest *preq;
                hr = CoCreateInstance(CLSID_XMLHTTPRequest, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLHttpRequest, &preq));
                if (SUCCEEDED(hr))
                {
                    VARIANT varNULL = {0};
                    VARIANT varAsync = {VT_BOOL};
                    varAsync.boolVal = VARIANT_FALSE;

                    // open a post request to the destination that we have
                    hr = preq->open(pti->szVerb, pti->szURL, varAsync, varNULL, varNULL);
                    if (SUCCEEDED(hr))
                    {
                        // set it up to post with a multi-part
                        hr = preq->setRequestHeader(L"content-type", c_pszContentType);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT varBody = {VT_UNKNOWN};
                            varBody.punkVal = pti->pstrm;

                            hr = preq->send(varBody);
                            if (SUCCEEDED(hr))
                            {
                                long lStatus;
                                hr = preq->get_status(&lStatus);
                                if (SUCCEEDED(hr))
                                {
                                    switch (lStatus)
                                    {
                                        case HTTP_STATUS_OK:
                                        case HTTP_STATUS_CREATED:
                                            hr = S_OK;
                                            break;

                                        default:
                                            hr = E_FAIL;
                                            break;
                                    }
                                }
                            }
                        }
                    }
                    preq->Release();
                }

                // notify the site that the transfer is complete
                ptas->PostOperation(STGOP_COPY, pti->psi, NULL, hr);

                // update our seek pointer for progress
                _ulCurrent = min((_ulCurrent + pti->ststg.cbSize.QuadPart), _ulTotal);
            }
        }

        // notify the foreground that the wizard has finished uploading the bits to the site.

        PostMessage(_ti.hwnd, PWM_TRANSFERCOMPLETE, 0, (LPARAM)hr);

        // if that succeeded then lets try and create a net place that points to the place
        // we are uploading the files to.  of course we can only do this if they place
        // a shortcut entry into the 

        if (_ti.szLinkTarget[0] && !(_ti.dwFlags & SHPWHF_NONETPLACECREATE))
        {
            CNetworkPlace np;
            if (SUCCEEDED(np.SetTarget(_ti.hwnd, _ti.szLinkTarget, 0x0)))
            {
                if (_ti.szLinkName[0])
                    np.SetName(NULL, _ti.szLinkName);
                if (_ti.szLinkDesc[0])
                    np.SetDescription(_ti.szLinkDesc);            

                np.CreatePlace(_ti.hwnd, FALSE);
            }
        }

        ptas->Release();
    }

    Release();
    return 0L;
}


// handle initializing and kicking off the post thread which will handle the transter of the bits.

HRESULT CPostThread::BeginTransfer(CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    _dpaItems.Attach(pdpaItems->Detach()); // we have ownership of the DPA now

    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_ITransferAdviseSink, ptas, &_pstrmSink);
    if (SUCCEEDED(hr))
    {
        AddRef();
        hr = SHCreateThread(s_ThreadProc, this, CTF_INSIST | CTF_COINIT, NULL) ? S_OK:E_FAIL;
        if (FAILED(hr))
        {
            Release();
        }
    }

    return hr;
}


// create the posting object and initialize it

HRESULT PublishViaPost(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas)
{
    CPostThread *ppt = new CPostThread(pti);
    if (!ppt)
        return E_OUTOFMEMORY;

    HRESULT hr = ppt->BeginTransfer(pdpaItems, ptas);
    ppt->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\pubwiz.cpp ===
#include "stdafx.h"
#include "shimgdata.h"
#include "shui.h"
#include "netplace.h"
#include <Ntquery.h>
#include <shellp.h>
#include "pubwiz.h"
#include "gdiplus\gdiplus.h"
#include "imgprop.h"
#include "shdguid.h"
#include "urlmon.h"
#include "xmldomdid.h"
#include "winnlsp.h"
#pragma hdrstop


// handle the events from the DOM as we load

#define XMLDOC_LOADING      1
#define XMLDOC_LOADED       2
#define XMLDOC_INTERACTIVE  3
#define XMLDOC_COMPLETED    4


// this message is posted to the parent HWND, the lParam parse result

#define MSG_XMLDOC_COMPLETED    WM_APP

class CXMLDOMStateChange : public IDispatch
{
public:
    CXMLDOMStateChange(IXMLDOMDocument *pdoc, HWND hwnd); 
    ~CXMLDOMStateChange();
    HRESULT Advise(BOOL fAdvise);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();        
    STDMETHODIMP_(ULONG) Release();

    // IDispatch
    STDMETHODIMP GetTypeInfoCount( UINT *pctinfo) 
        { return E_NOTIMPL; }
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
        { return E_NOTIMPL; }    
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
        { return E_NOTIMPL; }    
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pvar, EXCEPINFO *pExcepInfo, UINT *puArgErr);

private:
    long _cRef;
    IXMLDOMDocument *_pdoc;
    DWORD _dwCookie;
    HWND _hwnd;
};


// construction and IUnknown

CXMLDOMStateChange::CXMLDOMStateChange(IXMLDOMDocument *pdoc, HWND hwnd) :
    _cRef(1), _dwCookie(0), _hwnd(hwnd)
{
    IUnknown_Set((IUnknown**)&_pdoc, pdoc);
}

CXMLDOMStateChange::~CXMLDOMStateChange()
{
    IUnknown_Set((IUnknown**)&_pdoc, NULL);
}

ULONG CXMLDOMStateChange::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CXMLDOMStateChange::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CXMLDOMStateChange::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CXMLDOMStateChange, IDispatch),
        { 0 },                             
    };
    return QISearch(this, qit, riid, ppv);
}


// handle the advise/unadvise to the parent object

HRESULT CXMLDOMStateChange::Advise(BOOL fAdvise)
{
    IConnectionPointContainer *pcpc;
    HRESULT hr = _pdoc->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpc));
    if (SUCCEEDED(hr))
    {
        IConnectionPoint *pcp;
        hr = pcpc->FindConnectionPoint(DIID_XMLDOMDocumentEvents, &pcp);
        if (SUCCEEDED(hr))
        {
            if (fAdvise)
            {
                hr = pcp->Advise(SAFECAST(this, IDispatch *), &_dwCookie);
            }
            else if (_dwCookie)
            {
                hr = pcp->Unadvise(_dwCookie);
                _dwCookie = 0;
            }
            pcp->Release();
        }
        pcpc->Release();
    }
    return hr;
}


// handle the invoke for the doc state changing

HRESULT CXMLDOMStateChange::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pvar, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    HRESULT hr = S_OK;
    switch (dispIdMember)
    {
        case DISPID_XMLDOMEVENT_ONREADYSTATECHANGE:
        {            
            long lReadyState;
            if (SUCCEEDED(_pdoc->get_readyState(&lReadyState)))
            {
                if (lReadyState == XMLDOC_COMPLETED)
                {
                    IXMLDOMParseError *pdpe;
                    hr = _pdoc->get_parseError(&pdpe);
                    if (SUCCEEDED(hr))
                    {
                        long lError;
                        hr = pdpe->get_errorCode(&lError);
                        if (SUCCEEDED(hr))
                        {
                            hr = (HRESULT)lError;
                        }
                        PostMessage(_hwnd, MSG_XMLDOC_COMPLETED, 0, (LPARAM)hr);
                        pdpe->Release();
                    }
                }
            }
            break;
        }
    }
    return hr;
}


// copied from shell stuff - should be in public header

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

DEFINE_SCID(SCID_NAME,              PSGUID_STORAGE, PID_STG_NAME);
DEFINE_SCID(SCID_TYPE,              PSGUID_STORAGE, PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_SIZE,              PSGUID_STORAGE, PID_STG_SIZE);
DEFINE_SCID(SCID_WRITETIME,         PSGUID_STORAGE, PID_STG_WRITETIME);

DEFINE_SCID(SCID_ImageCX,           PSGUID_IMAGESUMMARYINFORMATION, PIDISI_CX);
DEFINE_SCID(SCID_ImageCY,           PSGUID_IMAGESUMMARYINFORMATION, PIDISI_CY);


// provider XML defines the following properties for each of the 

#define DEFAULT_PROVIDER_SCOPE          TEXT("PublishingWizard")

#define FMT_PROVIDER                    TEXT("providermanifest/providers[@scope='%s']")
#define FMT_PROVIDERS                   TEXT("providermanifest/providers[@scope='%s']/provider")

#define ELEMENT_PROVIDERMANIFEST        L"providermanifest"
#define ELEMENT_PROVIDERS               L"providers"

#define ELEMENT_PROVIDER                L"provider"
#define ATTRIBUTE_ID                    L"id"
#define ATTRIBUTE_SUPPORTEDTYPES        L"supportedtypes"
#define ATTRIBUTE_DISPLAYNAME           L"displayname"
#define ATTRIBUTE_DESCRIPTION           L"description"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_ICONPATH              L"iconpath"
#define ATTRIBUTE_ICON                  L"icon"

#define ELEMENT_STRINGS                 L"strings"
#define ATTRIBUTE_LANGID                L"langid"

#define ELEMENT_STRING                  L"string"
#define ATTRIBUTE_LANGID                L"langid"
#define ATTRIBUTE_ID                    L"id"


// registry state is stored under the this key

#define SZ_REGKEY_PUBWIZ                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\PublishingWizard")

// per machine values in the registry

#define SZ_REGVAL_SERVICEPARTNERID      TEXT("PartnerID")


// these are stored per machine under the provider

#define SZ_REGVAL_FILEFILTER            TEXT("ContentTypeFilter")
#define SZ_REGVAL_DEFAULTPROVIDERICON   TEXT("DefaultIcon")

// per user values in the registry

#define SZ_REGVAL_DEFAULTPROVIDER       TEXT("DefaultProvider")

// per provider settings

#define SZ_REGVAL_MRU                   TEXT("LocationMRU")
#define SZ_REGVAL_ALTPROVIDERS          TEXT("Providers")


// Properties exposed by the property bag (from the Web Service)

#define PROPERTY_EXTENSIONCOUNT         TEXT("UniqueExtensionCount")
#define PROPERTY_EXTENSION              TEXT("UniqueExtension")

#define PROPERTY_TRANSFERMANIFEST       TEXT("TransferManifest")


// This is the COM object that exposes the publishing wizard

#define WIZPAGE_WHICHFILE           0   // which file should we publish
#define WIZPAGE_FETCHINGPROVIDERS   1   // provider download page
#define WIZPAGE_PROVIDERS           2   // pick a service provider
#define WIZPAGE_RESIZE              3   // resample the data?
#define WIZPAGE_COPYING             4   // copying page
#define WIZPAGE_LOCATION            5   // location page (advanced)
#define WIZPAGE_FTPUSER             6   // username / password (advanced)
#define WIZPAGE_FRIENDLYNAME        7   // friendly name
#define WIZPAGE_MAX                 8


// resize information

struct
{
    int cx;
    int cy;
    int iQuality;
} 
_aResizeSettings[] = 
{
    { 0, 0, 0 },
    { 640,  480, 80 },          // low quality
    { 800,  600, 80 },          // medium quality
    { 1024, 768, 80 },          // high quality
};

typedef enum
{
    RESIZE_NONE = 0,
    RESIZE_SMALL,
    RESIZE_MEDIUM,
    RESIZE_LARGE,
} RESIZEOPTION;


class CPublishingWizard : public IServiceProvider, IPublishingWizard, CObjectWithSite, ITransferAdviseSink, ICommDlgBrowser, IOleWindow, IWizardSite
{
public:
    CPublishingWizard();
    ~CPublishingWizard();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IWizardExtension
    STDMETHODIMP AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages);
    STDMETHODIMP GetFirstPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetLastPage(HPROPSHEETPAGE *phPage);

    // IWizardSite
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage);

    // IPublishingWizard
    STDMETHODIMP Initialize(IDataObject *pdo, DWORD dwFlags, LPCTSTR pszServiceProvider);
    STDMETHODIMP GetTransferManifest(HRESULT *phrFromTransfer, IXMLDOMDocument **pdocManifest);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd)
        { *phwnd = _hwndCopyingPage; return S_OK; }
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnter)
        { return E_NOTIMPL; }

    // ICommDlgBrowser
    STDMETHOD(OnDefaultCommand)(IShellView *ppshv)
        { return E_NOTIMPL; }
    STDMETHOD(OnStateChange)(IShellView *ppshv, ULONG uChange);
    STDMETHOD(IncludeObject)(IShellView *ppshv, LPCITEMIDLIST lpItem);

    // ITransferAdviseSink
    STDMETHODIMP PreOperation (const STGOP op, IShellItem *psiItem, IShellItem *psiDest);
    STDMETHODIMP ConfirmOperation(IShellItem *psiItem, IShellItem *psiDest, STGTRANSCONFIRMATION stc, LPCUSTOMCONFIRMATION pcc)
        { return STRESPONSE_CONTINUE; }
    STDMETHODIMP OperationProgress(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ulTotal, ULONGLONG ulComplete);
    STDMETHODIMP PostOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, HRESULT hrResult)
        { return S_OK; }
    STDMETHODIMP QueryContinue()
        { return _fCancelled ? S_FALSE : S_OK; }

private:
    LONG _cRef;                                 // object lifetime count

    IDataObject *_pdo;                          // data object provided by the site
    IDataObject *_pdoSelection;                 // this is the selection IDataObject - used instead of _pdo if defined

    DWORD _dwFlags;                             // flags provided by the site
    TCHAR _szProviderScope[MAX_PATH];           // provider scope (eg. Web Publishing)

    BOOL _fOfferResize;                         // show the resize page - pictures/music etc
    RESIZEOPTION _ro;                           // resize setting we will use

    BOOL _fUsingTemporaryProviders;             // temporary provider listed pull in, replace when we can
    BOOL _fRecomputeManifest;                   // recompute the manifest
    BOOL _fRepopulateProviders;                 // repopulate the providers list
    BOOL _fShownCustomLocation;                 // show the custom locaiton page
    BOOL _fShownUserName;                       // password page was shown
    BOOL _fValidating;                          // validating a server (Advanced path);
    BOOL _fCancelled;                           // operation was cancelled
    BOOL _fTransferComplete;                    // transfer completed.

    HWND _hwndSelector;                         // hwnd for the selector dialog
    HWND _hwndCopyingPage;

    int _iPercentageComplete;                   // % compelte of this transfer
    DWORD _dwTotal;
    DWORD _dwCompleted;

    int _cFiles;                                // maximum number of files
    int _iFile;                                 // current file we are on

    HRESULT _hrFromTransfer;                    // result of the transfer performed

    HPROPSHEETPAGE _aWizPages[WIZPAGE_MAX];     // page handles for this wizard (so we can navigate)

    IPropertyBag *_ppb;                         // property bag object exposed from the site
    IWebWizardExtension *_pwwe;                 // host for the HTML wizard pages
    IResourceMap *_prm;                         // resource map object we create if we can't query from the host

    IXMLDOMDocument *_pdocProviders;            // XML dom which exposes the providers
    CXMLDOMStateChange *_pdscProviders;         // DOMStateChange for the provider list

    IXMLDOMDocument *_pdocManifest;             // document describing the files to be transfered
    LPITEMIDLIST *_aItems;                      // array of items we copied
    UINT _cItems;

    IAutoComplete2 *_pac;                       // auto complete object
    IUnknown *_punkACLMulti;                    // IObjMgr object that exposes all the enumerators
    IACLCustomMRU *_pmru;                       // custom MRU for the objects we want to list
    CNetworkPlace _npCustom;                    // net place object for handling the custom entry

    HCURSOR _hCursor;

    IFolderView *_pfv;                          // file selector view object
    TCHAR _szFilter[MAX_PATH];                  // filter string read from the registry

    static CPublishingWizard* s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam);
    static int s_FreeStringProc(void* pFreeMe, void* pData);
    static HRESULT s_SetPropertyFromDisp(IPropertyBag *ppb, LPCWSTR pszID, IDispatch *pdsp);
    static DWORD CALLBACK s_ValidateThreadProc(void *pv);
    static int s_CompareItems(TRANSFERITEM *pti1, TRANSFERITEM *pti2, CPublishingWizard *ppw);
    static UINT s_SelectorPropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp);

    static INT_PTR s_SelectorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_SelectorDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_FetchProvidersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_FetchProvidersDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_ProviderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_ProviderDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_ResizeDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_CopyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_CopyDlgProc(hwnd, uMsg, wParam, lParam); }

    static INT_PTR s_LocationDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_LocationDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_UserNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_UserNameDlgProc(hwnd, uMsg, wParam, lParam); }
    static INT_PTR s_FriendlyNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CPublishingWizard *ppw = s_GetPPW(hwnd, uMsg, lParam); return ppw->_FriendlyNameDlgProc(hwnd, uMsg, wParam, lParam); }

    // these are used for publishing
    INT_PTR _SelectorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _FetchProvidersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ProviderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _CopyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // these are used for ANP
    INT_PTR _LocationDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _UserNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _FriendlyNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void _FreeProviderList();
    HRESULT _GetProviderKey(HKEY hkRoot, DWORD dwAccess, LPCTSTR pszSubKey, HKEY *phkResult);
    void _MapDlgItemText(HWND hwnd, UINT idc, LPCTSTR pszDlgID, LPCTSTR pszResourceID);
    HRESULT _GetResourceMap(IResourceMap **pprm);
    HRESULT _LoadMappedString(LPCTSTR pszDlgID, LPCTSTR pszResourceID, LPTSTR pszBuffer, int cch);
    HRESULT _CreateWizardPages();
    INT_PTR _WizardNext(HWND hwnd, int iPage);            
    HRESULT _AddExtenisonToList(HDPA hdpa, LPCTSTR pszExtension);
    HRESULT _InitPropertyBag(LPCTSTR pszURL);
    int _GetSelectedItem(HWND hwndList);
    void _GetDefaultProvider(LPTSTR pszProvider, int cch);
    void _SetDefaultProvider(IXMLDOMNode *pdn);
    HRESULT _FetchProviderList(HWND hwnd);
    HRESULT _MergeLocalProviders();
    int _AddProvider(HWND hwnd, IXMLDOMNode *pdn);
    void _PopulateProviderList(HWND hwnd);
    void _ProviderEnableNext(HWND hwnd);
    void _ProviderGetDispInfo(LV_DISPINFO *plvdi);
    HRESULT _ProviderNext(HWND hwnd, HPROPSHEETPAGE *phPage);
    void _SetWaitCursor(BOOL bOn);
    void _ShowExampleTip(HWND hwnd);
    void _LocationChanged(HWND hwnd);
    void _UserNameChanged(HWND hwnd);
    DWORD _GetAutoCompleteFlags(DWORD dwFlags);
    HRESULT _InitAutoComplete();
    void _InitLocation(HWND hwnd);
    HRESULT _AddCommonItemInfo(IXMLDOMNode *pdn, TRANSFERITEM *pti);
    HRESULT _AddTransferItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn);
    HRESULT _AddPostItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn);
    void _FreeTransferManifest();
    HRESULT _AddFilesToManifest(IXMLDOMDocument *pdocManifest);
    HRESULT _BuildTransferManifest();
    HRESULT _GetUniqueTypeList(BOOL fIncludeFolder, HDPA *phdpa);
    HRESULT _InitTransferInfo(IXMLDOMDocument *pdocManifest, TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems);
    void _TryToValidateDestination(HWND hwnd);
    void _InitProvidersDialog(HWND hwnd);    
    void _SetProgress(DWORD dwCompleted, DWORD dwTotal);
    BOOL _HasAttributes(IShellItem *psi, SFGAOF flags);
    HRESULT _BeginTransfer(HWND hwnd);
    HPROPSHEETPAGE _TransferComplete(HRESULT hrFromTransfer);
    void _FriendlyNameChanged(HWND hwnd);
    HRESULT _CreateFavorite(IXMLDOMNode *pdnUploadInfo);
    int _GetRemoteIcon(LPCTSTR pszID, BOOL fCanRefresh);
    HRESULT _GetSiteURL(LPTSTR pszBuffer, int cchBuffer, LPCTSTR pszFilenameToCombine);
    void _StateChanged();
    void _ShowHideFetchProgress(HWND hwnd, BOOL fShow);
    void _FetchComplete(HWND hwnd, HRESULT hrFromFetch);
    HRESULT _GetProviderString(IXMLDOMNode *pdn, USHORT idPrimary, USHORT idSub, LPCTSTR pszID, LPTSTR pszBuffer, int cch);
    HRESULT _GetProviderString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch);
    HRESULT _GeoFromLocaleInfo(LCID lcid, GEOID *pgeoID);
    HRESULT _GetProviderListFilename(LPTSTR pszFile, int cchFile);
};


// publishing wizard obj

CPublishingWizard::CPublishingWizard() :
    _cRef(1), _fRecomputeManifest(TRUE), _hrFromTransfer(S_FALSE)
{  
    StrCpyN(_szProviderScope, DEFAULT_PROVIDER_SCOPE, ARRAYSIZE(_szProviderScope));  // fill the default provider scope
    DllAddRef();
}

CPublishingWizard::~CPublishingWizard()
{   
    if (_pwwe)
    {
        IUnknown_SetSite(_pwwe, NULL);
        _pwwe->Release();
    }

    ATOMICRELEASE(_pdo);
    ATOMICRELEASE(_pdoSelection);
    ATOMICRELEASE(_prm);

    _FreeProviderList();
    _FreeTransferManifest();

    DllRelease();
}

ULONG CPublishingWizard::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPublishingWizard::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPublishingWizard::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPublishingWizard, IWizardSite),         // IID_IWizardSite
        QITABENT(CPublishingWizard, IObjectWithSite),     // IID_IObjectWithSite
        QITABENT(CPublishingWizard, IServiceProvider),    // IID_IServiceProvider
        QITABENT(CPublishingWizard, IPublishingWizard),   // IID_IPublishingWizard
        QITABENT(CPublishingWizard, ITransferAdviseSink), // IID_ITransferAdviseSink
        QITABENTMULTI(CPublishingWizard, IQueryContinue, ITransferAdviseSink), // IID_IQueryContinue        
        QITABENT(CPublishingWizard, IOleWindow),          // IID_IOleWindow
        QITABENT(CPublishingWizard, ICommDlgBrowser),     // IID_ICommDlgBrowser
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CPublishingWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPublishingWizard *pwiz = new CPublishingWizard();
    if (!pwiz)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pwiz->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pwiz->Release();
    return hr;
}


// IPublishingWizard methods

HRESULT CPublishingWizard::Initialize(IDataObject *pdo, DWORD dwOptions, LPCTSTR pszServiceProvider)
{
    IUnknown_Set((IUnknown**)&_pdo, pdo);
    IUnknown_Set((IUnknown**)&_pdoSelection, NULL);

    _dwFlags = dwOptions;
    _fRecomputeManifest = TRUE;     // _fRepopulateProviders set when manifest rebuilt

    if (!pszServiceProvider)
        pszServiceProvider = DEFAULT_PROVIDER_SCOPE;

    StrCpyN(_szProviderScope, pszServiceProvider, ARRAYSIZE(_szProviderScope));

    return S_OK;
}

HRESULT CPublishingWizard::GetTransferManifest(HRESULT *phrFromTransfer, IXMLDOMDocument **ppdocManifest)
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppb)
    {
        if (phrFromTransfer)
            *phrFromTransfer = _hrFromTransfer;

        if (ppdocManifest)
        {
            VARIANT var = {VT_DISPATCH};
            hr = _ppb->Read(PROPERTY_TRANSFERMANIFEST, &var, NULL);
            if (SUCCEEDED(hr))
            {
                hr = var.pdispVal->QueryInterface(IID_PPV_ARG(IXMLDOMDocument, ppdocManifest));
                VariantClear(&var);
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}


// Wizard site methods

STDMETHODIMP CPublishingWizard::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _aWizPages[WIZPAGE_FETCHINGPROVIDERS];
    return S_OK;
}

STDMETHODIMP CPublishingWizard::GetNextPage(HPROPSHEETPAGE *phPage)
{
    // lets get the next page we'd need to show if all else fails.

    IWizardSite *pws;
    HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
    if (SUCCEEDED(hr))
    {
        hr = pws->GetNextPage(phPage);
        pws->Release();
    }

    // if we have not transfered and we have a IDataObject then we should
    // advance to one of the special pages we are supposed to show.

    if (!_fTransferComplete && _pdo)
    {
        *phPage = _aWizPages[_fOfferResize ? WIZPAGE_RESIZE:WIZPAGE_COPYING];
    }

    return hr;
}

STDMETHODIMP CPublishingWizard::GetCancelledPage(HPROPSHEETPAGE *phPage)
{
    HRESULT hr = E_NOTIMPL;
    if (!_fTransferComplete)
    {
        *phPage = _TransferComplete(HRESULT_FROM_WIN32(ERROR_CANCELLED)); 
        if (*phPage)
            hr = S_OK;
    }
    else
    {
        IWizardSite *pws;
        hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
        if (SUCCEEDED(hr))
        {
            hr = pws->GetCancelledPage(phPage);
            pws->Release();
        }
    }
    return hr;
}


// Service provider object

STDMETHODIMP CPublishingWizard::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (guidService == SID_WebWizardHost)
    {
        if (riid == IID_IPropertyBag)
        {
            return _ppb->QueryInterface(riid, ppv);
        }
    }
    else if (guidService == SID_SCommDlgBrowser)
    {
        return this->QueryInterface(riid, ppv);
    }
    else if (_punkSite)
    {
        return IUnknown_QueryService(_punkSite, guidService, riid, ppv);
    }
    return E_FAIL;
}


// IWizardExtension methods

HRESULT CPublishingWizard::_CreateWizardPages()
{
    const struct
    {
        LPCTSTR pszID;
        int idPage;
        DLGPROC dlgproc;
        UINT idsHeading;
        UINT idsSubHeading;
        LPFNPSPCALLBACK pfnCallback;
    } 
    _wp[] = 
    {
        {TEXT("wp:selector"),    IDD_PUB_SELECTOR,       CPublishingWizard::s_SelectorDlgProc, IDS_PUB_SELECTOR, IDS_PUB_SELECTOR_SUB, NULL},
        {TEXT("wp:fetching"),    IDD_PUB_FETCHPROVIDERS, CPublishingWizard::s_FetchProvidersDlgProc, IDS_PUB_FETCHINGPROVIDERS, IDS_PUB_FETCHINGPROVIDERS_SUB, CPublishingWizard::s_SelectorPropPageProc},
        {TEXT("wp:destination"), IDD_PUB_DESTINATION,    CPublishingWizard::s_ProviderDlgProc, IDS_PUB_DESTINATION, IDS_PUB_DESTINATION_SUB, NULL},
        {TEXT("wp:resize"),      IDD_PUB_RESIZE,         CPublishingWizard::s_ResizeDlgProc, IDS_PUB_RESIZE, IDS_PUB_RESIZE_SUB, NULL},
        {TEXT("wp:copying"),     IDD_PUB_COPY,           CPublishingWizard::s_CopyDlgProc, IDS_PUB_COPY, IDS_PUB_COPY_SUB, NULL},
        {TEXT("wp:location"),    IDD_PUB_LOCATION,       CPublishingWizard::s_LocationDlgProc, IDS_PUB_LOCATION, IDS_PUB_LOCATION_SUB, NULL},
        {TEXT("wp:ftppassword"), IDD_PUB_FTPPASSWORD,    CPublishingWizard::s_UserNameDlgProc, IDS_PUB_FTPPASSWORD, IDS_PUB_FTPPASSWORD_SUB, NULL},
        {TEXT("wp:friendlyname"),IDD_ANP_FRIENDLYNAME,   CPublishingWizard::s_FriendlyNameDlgProc, IDS_ANP_FRIENDLYNAME, IDS_ANP_FRIENDLYNAME_SUB, NULL},
    };

    // if we haven't created the pages yet, then lets initialize our array of handlers.

    HRESULT hr = S_OK;
    if (!_aWizPages[0])
    {
        INITCOMMONCONTROLSEX iccex = { 0 };
        iccex.dwSize = sizeof (iccex);
        iccex.dwICC = ICC_LISTVIEW_CLASSES | ICC_PROGRESS_CLASS | ICC_LINK_CLASS;
        InitCommonControlsEx(&iccex);

        LinkWindow_RegisterClass();             // we will use the link window (can this be removed)

        for (int i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(_wp)) ; i++ )
        {                           
            TCHAR szHeading[MAX_PATH], szSubHeading[MAX_PATH];

            // if we have a resource map then load the heading and sub heading text
            // if there is no resource map from the parent object then we must default
            // the strings.

            IResourceMap *prm;
            hr = _GetResourceMap(&prm);
            if (SUCCEEDED(hr))
            {
                IXMLDOMNode *pdn;
                hr = prm->SelectResourceScope(TEXT("dialog"), _wp[i].pszID, &pdn);
                if (SUCCEEDED(hr))
                {
                    prm->LoadString(pdn, L"heading", szHeading, ARRAYSIZE(szHeading));
                    prm->LoadString(pdn, L"subheading", szSubHeading, ARRAYSIZE(szSubHeading));
                    pdn->Release();
                }
                prm->Release();
            }

            if (FAILED(hr))
            {
                LoadString(g_hinst, _wp[i].idsHeading, szHeading, ARRAYSIZE(szHeading));
                LoadString(g_hinst, _wp[i].idsSubHeading, szSubHeading, ARRAYSIZE(szSubHeading));
            }

            // lets create the page now that we have loaded the relevant strings, more mapping
            // will occur later (during dialog initialization)

            PROPSHEETPAGE psp = { 0 };
            psp.dwSize = SIZEOF(PROPSHEETPAGE);
            psp.hInstance = g_hinst;
            psp.lParam = (LPARAM)this;
            psp.dwFlags = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.pszTemplate = MAKEINTRESOURCE(_wp[i].idPage);
            psp.pfnDlgProc = _wp[i].dlgproc;

            psp.pszHeaderTitle = szHeading;
            psp.pszHeaderSubTitle = szSubHeading;

            if (_wp[i].pfnCallback)
            {
                psp.dwFlags |= PSP_USECALLBACK;
                psp.pfnCallback = _wp[i].pfnCallback;
            }

            _aWizPages[i] = CreatePropertySheetPage(&psp);
            hr = _aWizPages[i] ? S_OK:E_FAIL;
        }
    }

    return hr;
}

STDMETHODIMP CPublishingWizard::AddPages(HPROPSHEETPAGE* aPages, UINT cPages, UINT *pnPages)
{ 
    // create our pages and then copy the handles to the buffer

    HRESULT hr = _CreateWizardPages();
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < ARRAYSIZE(_aWizPages); i++)
        {
            aPages[i] = _aWizPages[i];
        }

        // we also leverage the HTML host for showing pages from the sites we are
        // interacting with.

        hr = CoCreateInstance(CLSID_WebWizardHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWebWizardExtension, &_pwwe));
        if (SUCCEEDED(hr))
        {

// NOTE: this site should be broken into a seperate object so we avoid any circular reference issues
// NOTE: there is code in websvc.cpp that attempts to break this by listening for the page 
// NOTE: destruction and then releasing its site.

            IUnknown_SetSite(_pwwe, (IObjectWithSite*)this);

            UINT nPages;
            if (SUCCEEDED(_pwwe->AddPages(&aPages[i], cPages-i, &nPages)))
            {
                i += nPages;
            }
        }

        *pnPages = i;           // the number of pages we added
    }
    return hr;
}


// navigation pages

STDMETHODIMP CPublishingWizard::GetFirstPage(HPROPSHEETPAGE *phPage)
{ 
    if (_dwFlags & SHPWHF_NOFILESELECTOR)
    {
        *phPage = _aWizPages[WIZPAGE_FETCHINGPROVIDERS];
    }
    else
    {
        *phPage = _aWizPages[WIZPAGE_WHICHFILE];
    }
    return S_OK;
}

STDMETHODIMP CPublishingWizard::GetLastPage(HPROPSHEETPAGE *phPage)
{ 
    if (_fShownCustomLocation)
    {
        *phPage = _aWizPages[WIZPAGE_FRIENDLYNAME];
    }
    else
    {
        *phPage = _aWizPages[WIZPAGE_FETCHINGPROVIDERS];
    }

    return S_OK;
}


// computer this pointers for the page objects

CPublishingWizard* CPublishingWizard::s_GetPPW(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CPublishingWizard*)ppsp->lParam;
    }
    return (CPublishingWizard*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}


// initialize a property in the property bag from an IUnknown pointer.

HRESULT CPublishingWizard::s_SetPropertyFromDisp(IPropertyBag *ppb, LPCWSTR pszID, IDispatch *pdsp)
{
    VARIANT var = { VT_DISPATCH };
    HRESULT hr = pdsp->QueryInterface(IID_PPV_ARG(IDispatch, &var.pdispVal));
    if (SUCCEEDED(hr))
    {
        hr = ppb->Write(pszID, &var);
        VariantClear(&var);
    }
    return hr;
}


// get the resource map from the site, if we can get it then us it, otherwise
// we need to load the resouce map local to this DLL. 

HRESULT CPublishingWizard::_GetResourceMap(IResourceMap **pprm)
{
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_ResourceMap, IID_PPV_ARG(IResourceMap, pprm));
    if (FAILED(hr))
    {
        if (!_prm)
        {
            hr = CResourceMap_Initialize(L"res://netplwiz.dll/xml/resourcemap.xml", &_prm);
            if (SUCCEEDED(hr))
            {
                hr = _prm->LoadResourceMap(TEXT("wizard"), _szProviderScope);
                if (SUCCEEDED(hr))
                {
                    hr = _prm->QueryInterface(IID_PPV_ARG(IResourceMap, pprm));
                }
            }
        }
        else 
        {
            hr = _prm->QueryInterface(IID_PPV_ARG(IResourceMap, pprm));
        }
    }
    return hr;
}


// handle loading resource map strings

HRESULT CPublishingWizard::_LoadMappedString(LPCTSTR pszDlgID, LPCTSTR pszResourceID, LPTSTR pszBuffer, int cch)
{
    IResourceMap *prm;
    HRESULT hr = _GetResourceMap(&prm);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdn;
        hr = prm->SelectResourceScope(TEXT("dialog"), pszDlgID, &pdn);
        if (SUCCEEDED(hr))
        {
            hr = prm->LoadString(pdn, pszResourceID, pszBuffer, cch);
            pdn->Release();
        }
        prm->Release();
    }
    return hr;
}

void CPublishingWizard::_MapDlgItemText(HWND hwnd, UINT idc, LPCTSTR pszDlgID, LPCTSTR pszResourceID)
{
    TCHAR szBuffer[MAX_PATH];
    if (SUCCEEDED(_LoadMappedString(pszDlgID, pszResourceID, szBuffer, ARRAYSIZE(szBuffer))))
    {
        SetDlgItemText(hwnd, idc, szBuffer);
    }
}


// Set the wizard next (index to hpage translation)

INT_PTR CPublishingWizard::_WizardNext(HWND hwnd, int iPage)
{
    PropSheet_SetCurSel(GetParent(hwnd), _aWizPages[iPage], -1);
    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
    return TRUE;
}


// get a provider key from the registry

HRESULT CPublishingWizard::_GetProviderKey(HKEY hkBase, DWORD dwAccess, LPCTSTR pszSubKey, HKEY *phkResult)
{
    TCHAR szBuffer[MAX_PATH];
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), (SZ_REGKEY_PUBWIZ TEXT("\\%s")), _szProviderScope);

    if (pszSubKey)
    {
        StrCatBuff(szBuffer, TEXT("\\"), ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, pszSubKey, ARRAYSIZE(szBuffer));
    }

    DWORD dwResult = RegOpenKeyEx(hkBase, szBuffer, 0, dwAccess, phkResult);
    if ((dwResult != ERROR_SUCCESS) && (dwAccess != KEY_READ))
    {
        dwResult = RegCreateKey(hkBase, szBuffer, phkResult);
    }

    return (ERROR_SUCCESS == dwResult) ? S_OK:E_FAIL;
}


// compute the site URL based on the stored information we have

HRESULT CPublishingWizard::_GetSiteURL(LPTSTR pszBuffer, int cchBuffer, LPCTSTR pszFilenameToCombine)
{
    DWORD cch = cchBuffer;
    return UrlCombine(TEXT("http://shell.windows.com/publishwizard/"), pszFilenameToCombine, pszBuffer, &cch, 0);
}


// get the data object from the site that we have

CLIPFORMAT g_cfHIDA = 0;

void InitClipboardFormats()
{
    if (g_cfHIDA == 0)
        g_cfHIDA = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
}


// DPA helpers for comparing and destroying a TRANSFERITEM structure

int CALLBACK CPublishingWizard::s_CompareItems(TRANSFERITEM *pti1, TRANSFERITEM *pti2, CPublishingWizard *ppw)
{
    return StrCmpI(pti1->szFilename, pti2->szFilename);
}

int _FreeFormData(FORMDATA *pfd, void *pvState)
{
    VariantClear(&pfd->varName);
    VariantClear(&pfd->varValue);
    return 1;
}

int _FreeTransferItems(TRANSFERITEM *pti, void *pvState)
{
    ILFree(pti->pidl);

    if (pti->psi)
        pti->psi->Release();

    if (pti->pstrm)
        pti->pstrm->Release();

    if (pti->dsaFormData != NULL)
        pti->dsaFormData.DestroyCallback(_FreeFormData, NULL);

    LocalFree(pti);
    return 1;
}

HRESULT CPublishingWizard::_AddCommonItemInfo(IXMLDOMNode *pdn, TRANSFERITEM *pti)
{
    // default to the user selected resize (this will only be set if
    // we are using the Web Publishing Wizard).

    if (_ro != RESIZE_NONE)
    {
        pti->fResizeOnUpload = TRUE;
        pti->cxResize = _aResizeSettings[_ro].cx;
        pti->cyResize = _aResizeSettings[_ro].cy;
        pti->iQuality = _aResizeSettings[_ro].iQuality;
    }

    // give the site ultimate control over the resizing that is performed,
    // by checking for the <resize/> element in the manifest.

    IXMLDOMNode *pdnResize;
    HRESULT hr = pdn->selectSingleNode(ELEMENT_RESIZE, &pdnResize);
    if (hr == S_OK)
    {
        int cx, cy, iQuality;

        hr = GetIntFromAttribute(pdnResize, ATTRIBUTE_CX, &cx);
        if (SUCCEEDED(hr))
            hr = GetIntFromAttribute(pdnResize, ATTRIBUTE_CY, &cy);
        if (SUCCEEDED(hr))
            hr = GetIntFromAttribute(pdnResize, ATTRIBUTE_QUALITY, &iQuality);
        
        if (SUCCEEDED(hr))
        {
            pti->fResizeOnUpload = TRUE;
            pti->cxResize = cx;
            pti->cyResize = cy;
            pti->iQuality = iQuality;
        }

        pdnResize->Release();
    }

    return S_OK;
}

HRESULT CPublishingWizard::_AddTransferItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn)
{
    HRESULT hr = E_OUTOFMEMORY;
    TRANSFERITEM *pti = (TRANSFERITEM*)LocalAlloc(LPTR, sizeof(*pti));
    if (pti)
    {
        // copy the destination
        hr = GetStrFromAttribute(pdn, ATTRIBUTE_DESTINATION, pti->szFilename, ARRAYSIZE(pti->szFilename));

        // copy the source IDList - read the index and use that
        if (SUCCEEDED(hr))
        {
            int iItem;
            hr = GetIntFromAttribute(pdn, ATTRIBUTE_ID, &iItem);
            if (SUCCEEDED(hr))
            {
                hr = SHILClone(_aItems[iItem], &pti->pidl);
            }
        }   

        // lets add the common transfer item info
        if (SUCCEEDED(hr))
            hr = _AddCommonItemInfo(pdn, pti);

        // if we have a structure then lets append it to the DPA
        if (SUCCEEDED(hr))
            hr = (-1 == pdpaItems->AppendPtr(pti)) ? E_OUTOFMEMORY:S_OK;

        // failed
        if (FAILED(hr))
        {
            _FreeTransferItems(pti);
        }
    }
    return hr;
}

HRESULT CPublishingWizard::_AddPostItem(CDPA<TRANSFERITEM> *pdpaItems, IXMLDOMNode *pdn)
{
    HRESULT hr = E_OUTOFMEMORY;
    TRANSFERITEM *pti = (TRANSFERITEM*)LocalAlloc(LPTR, sizeof(*pti));
    if (pti)
    {
        // get the post data, from thiswe can work out how to post the data
        IXMLDOMNode *pdnPostData;
        if (pdn->selectSingleNode(ELEMENT_POSTDATA, &pdnPostData) == S_OK)
        {
            // we must have a HREF for the post value
            hr = GetStrFromAttribute(pdnPostData, ATTRIBUTE_HREF, pti->szURL, ARRAYSIZE(pti->szURL));
            if (SUCCEEDED(hr))
            {
                // we must be able to get a posting name from the element
                hr = GetStrFromAttribute(pdnPostData, ATTRIBUTE_NAME, pti->szName, ARRAYSIZE(pti->szName));
                if (SUCCEEDED(hr))
                {
                    // lets get the posting name, we get that from the filename attribute, if that
                    // is not defined then try and compute it from the source information
                    // if that isn't defined the use the name attribute they gave us earlier.

                    if (FAILED(GetStrFromAttribute(pdnPostData, ATTRIBUTE_FILENAME, pti->szFilename, ARRAYSIZE(pti->szFilename))))
                    {
                        TCHAR szSource[MAX_PATH];
                        if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_SOURCE, szSource, ARRAYSIZE(szSource))))
                        {
                            StrCpyN(pti->szFilename, PathFindFileName(szSource), ARRAYSIZE(pti->szFilename));
                        }
                        else
                        {
                            StrCpyN(pti->szFilename, pti->szName, ARRAYSIZE(pti->szFilename));
                        }
                    }

                    // lets get the verb we should be using (and default accordingly), therefore
                    // we can ignore the result.

                    StrCpyN(pti->szVerb, TEXT("POST"), ARRAYSIZE(pti->szVerb));
                    GetStrFromAttribute(pdnPostData, ATTRIBUTE_VERB, pti->szVerb, ARRAYSIZE(pti->szVerb));

                    // pick up the IDLIST for the item

                    int iItem;
                    hr = GetIntFromAttribute(pdn, ATTRIBUTE_ID, &iItem);
                    if (SUCCEEDED(hr))
                    {
                        hr = SHILClone(_aItems[iItem], &pti->pidl);
                    }

                    // do we have any form data that needs to be passed to the transfer engine
                    // and therefore to the site.  if so lets package it up now.

                    IXMLDOMNodeList *pnl;
                    if (SUCCEEDED(hr) && (S_OK == pdnPostData->selectNodes(ELEMENT_FORMDATA, &pnl)))
                    {
                        hr = pti->dsaFormData.Create(4) ? S_OK:E_FAIL;
                        if (SUCCEEDED(hr))
                        {
                            // walk the selection filling the DSA, each structure contains
                            // two VARIANTs which we can push across to the bg thread describing the
                            // form data we want the site to receive.

                            long cSelection;
                            hr = pnl->get_length(&cSelection);
                            for (long lNode = 0; SUCCEEDED(hr) && (lNode != cSelection); lNode++)
                            {
                                IXMLDOMNode *pdnFormData;
                                hr = pnl->get_item(lNode, &pdnFormData);
                                if (SUCCEEDED(hr))
                                {
                                    FORMDATA fd = {0};

                                    hr = pdnFormData->get_nodeTypedValue(&fd.varValue);
                                    if (SUCCEEDED(hr))
                                    {
                                        IXMLDOMElement *pdelFormData;
                                        hr = pdnFormData->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdelFormData));
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = pdelFormData->getAttribute(ATTRIBUTE_NAME, &fd.varName);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = (-1 == pti->dsaFormData.AppendItem(&fd)) ? E_FAIL:S_OK;
                                            }
                                            pdelFormData->Release();
                                        }
                                    }

                                    // failed to fully create the form data, so lets release
                                    if (FAILED(hr))
                                        _FreeFormData(&fd, NULL);

                                    pdnFormData->Release();
                                }
                            }
                            pnl->Release();
                        }
                    }
                }
            }
        }   
        else
        {
            hr = E_FAIL;
        }

        // lets add the common transfer item info
        if (SUCCEEDED(hr))
            hr = _AddCommonItemInfo(pdn, pti);

        // if we have a structure then lets append it to the DPA
        if (SUCCEEDED(hr))
            hr = (-1 == pdpaItems->AppendPtr(pti)) ? E_OUTOFMEMORY:S_OK;

        // failed
        if (FAILED(hr))
            _FreeTransferItems(pti);
    }
    return hr;
}


HRESULT CPublishingWizard::_InitTransferInfo(IXMLDOMDocument *pdocManifest, TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems)
{
    // pull the destination and shortcut information from the manifest into the 
    // transfer info structure.

    IXMLDOMNode *pdn;
    HRESULT hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdn);
    if (SUCCEEDED(hr))
    {
        if (hr == S_OK)
        {
            // get the friendly name for the site, this is stored in the upload information, this can fail.

            if (FAILED(GetStrFromAttribute(pdn, ATTRIBUTE_FRIENDLYNAME, pti->szSiteName, ARRAYSIZE(pti->szSiteName))))
            {
                // B2: handle this so that MSN still works, we moved the friendly name attribute to
                //     a to the <uploadinfo/> element, however they were locked down and couldn't take
                //     that change, therefore ensure that we pick this up from its previous location.

                IXMLDOMNode *pdnTarget;
                if (S_OK == pdn->selectSingleNode(ELEMENT_TARGET, &pdnTarget))
                {
                    GetStrFromAttribute(pdnTarget, ATTRIBUTE_FRIENDLYNAME, pti->szSiteName, ARRAYSIZE(pti->szSiteName));
                    pdnTarget->Release();
                }
            }

            // from the manifest lets read the file location and then the net place creation information
            // this is then placed into the transfer info strucuture which we used on the bg thread
            // to both upload the files and also create a net place.

            if (FAILED(GetURLFromElement(pdn, ELEMENT_TARGET, pti->szFileTarget, ARRAYSIZE(pti->szFileTarget))))
            {
                pti->fUsePost = TRUE; // if we don't get the target string then we are posting
            }

            // we have the target for upload to, then lets pick up the optional information about
            // the site, and the net place.

            if (SUCCEEDED(GetURLFromElement(pdn, ELEMENT_NETPLACE, pti->szLinkTarget, ARRAYSIZE(pti->szLinkTarget))))
            {
                IXMLDOMNode *pdnNetPlace;
                if (pdn->selectSingleNode(ELEMENT_NETPLACE, &pdnNetPlace) == S_OK)
                {
                    GetStrFromAttribute(pdnNetPlace, ATTRIBUTE_FILENAME, pti->szLinkName, ARRAYSIZE(pti->szLinkName));
                    GetStrFromAttribute(pdnNetPlace, ATTRIBUTE_COMMENT, pti->szLinkDesc, ARRAYSIZE(pti->szLinkDesc));
                    pdnNetPlace->Release();
                }

                // fix up the site name from the link description if its not defined.

                if (!pti->szSiteName[0] && pti->szLinkDesc)
                {
                    StrCpyN(pti->szSiteName, pti->szLinkDesc, ARRAYSIZE(pti->szSiteName));
                }
            }

            // get the site URL
            GetURLFromElement(pdn, ELEMENT_HTMLUI, pti->szSiteURL, ARRAYSIZE(pti->szSiteURL));
        }
        else
        {
            hr = E_FAIL;
        }
    }

    // if they want a DPA of items then lets create them one, this is also based on the manifest.

    if (SUCCEEDED(hr) && pdpaItems)
    {
        hr = (pdpaItems->Create(16)) ? S_OK:E_OUTOFMEMORY;
        if (SUCCEEDED(hr))
        {
            IXMLDOMNodeList *pnl;
            hr = pdocManifest->selectNodes(XPATH_ALLFILESTOUPLOAD, &pnl);
            if (hr == S_OK)
            {
                long cSelection;
                hr = pnl->get_length(&cSelection);
                for (long lNode = 0; SUCCEEDED(hr) && (lNode != cSelection); lNode++)
                {
                    IXMLDOMNode *pdn;
                    hr = pnl->get_item(lNode, &pdn);
                    if (SUCCEEDED(hr))
                    {
                        if (pti->fUsePost)
                            hr = _AddPostItem(pdpaItems, pdn);
                        else
                            hr = _AddTransferItem(pdpaItems, pdn);

                        pdn->Release();
                    }
                }
                pnl->Release();
            }

            // if we are *NOT* posting then sort the DPA so that we can support 
            // enum items correctly.

            if (!pti->fUsePost)
            {
                pdpaItems->SortEx(s_CompareItems, this);             // sort the DPA so we can search better
            }
        }
    }

    return hr;
}


// File selector dialog

HRESULT CPublishingWizard::IncludeObject(IShellView *ppshv, LPCITEMIDLIST pidl)
{
    BOOL fInclude = FALSE;

    LPITEMIDLIST pidlFolder;
    HRESULT hr = SHGetIDListFromUnk(ppshv, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlFolder, &psf));
        if (SUCCEEDED(hr))
        {
            // cannot publish folders, but can publish ZIP files (which are both folder and stream at the same time)
            if (!(SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER))
            {
                // filter based on the content type if we are given a filter string
                if (_szFilter[0])
                {
                    TCHAR szBuffer[MAX_PATH];
                    hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szBuffer, ARRAYSIZE(szBuffer));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szContentType[MAX_PATH];
                        DWORD cch = ARRAYSIZE(szContentType);
                        hr = AssocQueryString(0, ASSOCSTR_CONTENTTYPE, szBuffer, NULL, szContentType, &cch);
                        fInclude = SUCCEEDED(hr) && PathMatchSpec(szContentType, _szFilter);
                    }
                }
                else
                {
                    fInclude = TRUE;
                }
            }
            psf->Release();
        }
        ILFree(pidlFolder);
    }

    return fInclude ? S_OK:S_FALSE;
}


// handle the state changing in the dialog and therefore us updating the buttons & status

void CPublishingWizard::_StateChanged()
{
    int cItemsChecked = 0;
    int cItems = 0;

    if (_pfv)
    {
        _pfv->ItemCount(SVGIO_ALLVIEW, &cItems);
        _pfv->ItemCount(SVGIO_CHECKED, &cItemsChecked);
    }

    // format and display the status bar for this item

    TCHAR szFmt[MAX_PATH];
    if (FAILED(_LoadMappedString(L"wp:selector", L"countfmt", szFmt, ARRAYSIZE(szFmt))))
    {
        LoadString(g_hinst, IDS_PUB_SELECTOR_FMT, szFmt, ARRAYSIZE(szFmt));
    }

    TCHAR szBuffer[MAX_PATH];
    FormatMessageTemplate(szFmt, szBuffer, ARRAYSIZE(szBuffer), cItemsChecked, cItems);
    SetDlgItemText(_hwndSelector, IDC_PUB_SELECTORSTATUS, szBuffer);

    // ensure that Next is only enabled when we have checked some items in the view
    PropSheet_SetWizButtons(GetParent(_hwndSelector), ((cItemsChecked > 0) ? PSWIZB_NEXT:0) | PSWIZB_BACK);
}

HRESULT CPublishingWizard::OnStateChange(IShellView *pshv, ULONG uChange)
{
    if (uChange == CDBOSC_STATECHANGE)
    {
        _StateChanged();
        _fRecomputeManifest = TRUE;
    }
    return S_OK;
}


UINT CPublishingWizard::s_SelectorPropPageProc(HWND hwndDlg, UINT uMsg, PROPSHEETPAGE *ppsp)
{
    CPublishingWizard *ppw = (CPublishingWizard*)ppsp->lParam;
    switch (uMsg)
    {
        case PSPCB_CREATE:
            return TRUE;

        // we are cleaning up the page, lets ensure that we release file view object
        // if we have one.  that way our reference count correctly reflects our state
        // rather than us ending up with a circular reference to other objects

        case PSPCB_RELEASE:
            if (ppw->_pfv)
            {
                IUnknown_SetSite(ppw->_pfv, NULL);
                ATOMICRELEASE(ppw->_pfv);
            }
            break;
    }
    return FALSE;
}

INT_PTR CPublishingWizard::_SelectorDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _hwndSelector = hwnd;

            // lets read the default state for this provider from a key in the registry
            // this will define the types of files we are going to allow, the format is
            // a spec (eg. image/* means all images), each element can be seperated by a ;

            HKEY hkProvider;
            HRESULT hr = _GetProviderKey(HKEY_LOCAL_MACHINE, KEY_READ, NULL, &hkProvider);
            if (SUCCEEDED(hr))
            {
                DWORD cbFilter = sizeof(TCHAR)*ARRAYSIZE(_szFilter);
                SHGetValue(hkProvider, NULL, SZ_REGVAL_FILEFILTER, NULL, _szFilter, &cbFilter);
                RegCloseKey(hkProvider);
            }

            // create the file picker object, align with the hidden control on the window
            // and initialize with the IDataObject which contains the selection.

            hr = CoCreateInstance(CLSID_FolderViewHost, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IFolderView, &_pfv));
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite(_pfv, (IObjectWithSite*)this);

                IFolderViewHost *pfvh;
                hr = _pfv->QueryInterface(IID_PPV_ARG(IFolderViewHost, &pfvh));
                if (SUCCEEDED(hr))
                {
                    RECT rc;
                    GetWindowRect(GetDlgItem(hwnd, IDC_PUB_SELECTOR), &rc);
                    MapWindowRect(HWND_DESKTOP, hwnd, &rc);

                    InitClipboardFormats(); // initialize walks data object
                    hr = pfvh->Initialize(hwnd, _pdo, &rc);
                    if (SUCCEEDED(hr))
                    {
                        HWND hwndPicker;
                        hr = IUnknown_GetWindow(_pfv, &hwndPicker);
                        if (SUCCEEDED(hr))
                        {
                            SetWindowPos(hwndPicker, HWND_TOP, 0,0,0,0, SWP_NOMOVE|SWP_NOSIZE);
                        }
                    }
                    pfvh->Release();
                }

                if (FAILED(hr))
                {
                    ATOMICRELEASE(_pfv);
                }
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            if (HIWORD(wParam) == BN_CLICKED)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_PUB_ALL:
                    case IDC_PUB_NOTHING:
                        if (_pfv)
                        {
                            int cItems;
                            HRESULT hr = _pfv->ItemCount(SVGIO_ALLVIEW, &cItems);            
                            for (int iItem = 0; SUCCEEDED(hr) && (iItem != cItems); iItem++)
                            {
                                BOOL fSelect = (LOWORD(wParam) == IDC_PUB_ALL);
                                hr = _pfv->SelectItem(iItem, SVSI_NOSTATECHANGE | (fSelect ? SVSI_CHECK:0));
                            }
                            break;
                        }
                }
                break;
            }
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    if (_pfv)
                    {
                        _StateChanged();
                        PostMessage(hwnd, WM_APP, 0, 0);
                    }
                    else
                    {
                        // no IFolderView, so lets skip this page.
                        int i = PropSheet_PageToIndex(GetParent(hwnd), _aWizPages[WIZPAGE_FETCHINGPROVIDERS]);
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)PropSheet_IndexToId(GetParent(hwnd), i));
                    }
                    return TRUE;
                }

                case PSN_WIZNEXT:
                {
                    if (_fRecomputeManifest && _pfv)
                    {
                        IDataObject *pdo;
                        HRESULT hr = _pfv->Items(SVGIO_CHECKED, IID_PPV_ARG(IDataObject, &pdo));
                        if (SUCCEEDED(hr))
                        {
                            IUnknown_Set((IUnknown**)&_pdoSelection, pdo); 
                            pdo->Release();
                        }
                    }
                    return _WizardNext(hwnd, WIZPAGE_FETCHINGPROVIDERS);
                }

                case PSN_WIZBACK:
                {
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                            }
                            pws->Release();
                        }
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }

        // this is to work around the issue where defview (listview) forces a redraw of itself
        // in a non-async way when it receives a SetFocus, therefore causing it to render
        // incorrectly in the wizard frame.  to fix this we post ourselves a WM_APP during the
        // handle of PSN_SETACTIVE, and then turn around and call RedrawWindow.

        case WM_APP:
        {
            HWND hwndPicker;
            if (SUCCEEDED(IUnknown_GetWindow(_pfv, &hwndPicker)))
            {
                RedrawWindow(hwndPicker, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
            }
            break;
        }
    }
    return FALSE;
}


// tidy up and release the providers list

void CPublishingWizard::_FreeProviderList()
{   
    if (_pdscProviders)
        _pdscProviders->Advise(FALSE);

    IUnknown_Set((IUnknown**)&_pdscProviders, NULL);
    IUnknown_Set((IUnknown**)&_pdocProviders, NULL);            // discard the previous providers.
}


// begin a download of the provider list, we pull the providers list async from the server
// therefore we need to register a state change monitor so that we can pull the information
// dynamically and then receive a message to merge in our extra data.

#define FETCH_TIMERID 1
#define FETCH_TIMEOUT 1000

HRESULT CPublishingWizard::_GeoFromLocaleInfo(LCID lcid, GEOID *pgeoID)
{
    TCHAR szBuf[128] = {0};
    if (GetLocaleInfo(lcid, LOCALE_IGEOID | LOCALE_RETURN_NUMBER, szBuf, ARRAYSIZE(szBuf)) > 0)
    {
        *pgeoID = *((LPDWORD)szBuf);
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CPublishingWizard::_GetProviderListFilename(LPTSTR pszFile, int cchFile)
{
    HRESULT hr = S_OK;

    GEOID idGEO = GetUserGeoID(GEOCLASS_NATION);
    if (idGEO == GEOID_NOT_AVAILABLE)
    {
        hr = _GeoFromLocaleInfo(GetUserDefaultLCID(), &idGEO);
        if (FAILED(hr))
            hr = _GeoFromLocaleInfo(GetSystemDefaultLCID(), &idGEO);
        if (FAILED(hr))
            hr = _GeoFromLocaleInfo((MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US)), &idGEO); // default to US English
    }

    if (SUCCEEDED(hr) && (idGEO != GEOID_NOT_AVAILABLE))
    {
        // read the provider prefix from the registry
    
        int cchProvider = 0;
        DWORD cbFile = sizeof(TCHAR)*cchFile;
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_PUBWIZ, SZ_REGVAL_SERVICEPARTNERID, NULL, pszFile, &cbFile))
        {
            StrCatBuff(pszFile, TEXT("."), cchFile);
            cchProvider = lstrlen(pszFile);
        }        

        // build <contrycode>.xml into the buffer (as a suffix of the partner if needed)

        GetGeoInfo(idGEO, GEO_ISO3, pszFile + cchProvider, cchFile - cchProvider, 0);
        StrCatBuff(pszFile, TEXT(".xml"), cchFile);
        CharLowerBuff(pszFile, lstrlen(pszFile));
    }
    else if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CPublishingWizard::_FetchProviderList(HWND hwnd)
{    
    _FreeProviderList();
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &_pdocProviders));
    if (SUCCEEDED(hr))
    {
        TCHAR szFile[MAX_PATH];
        hr = _GetProviderListFilename(szFile, ARRAYSIZE(szFile));
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[INTERNET_MAX_URL_LENGTH];                
            hr = _GetSiteURL(szBuffer, ARRAYSIZE(szBuffer), szFile);
            if (SUCCEEDED(hr))
            {
                LaunchICW();

                if (InternetGoOnline(szBuffer, hwnd, 0))
                {
                    _pdscProviders = new CXMLDOMStateChange(_pdocProviders, hwnd);
                    if (_pdscProviders)
                    {
                        hr = _pdscProviders->Advise(TRUE);
                        if (SUCCEEDED(hr))
                        {
                            VARIANT varName;
                            hr = InitVariantFromStr(&varName, szBuffer);
                            if (SUCCEEDED(hr))
                            {
                                VARIANT_BOOL fSuccess;
                                hr = _pdocProviders->load(varName, &fSuccess);
                                if (FAILED(hr) || (fSuccess != VARIANT_TRUE))
                                {
                                    hr = FAILED(hr) ? hr:E_FAIL;
                                }
                                VariantClear(&varName);
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    // if any of this failed then lets post ourselves the completed message 
    // with the failure code, at which point we can then load the default document.

    if (FAILED(hr))
        PostMessage(hwnd, MSG_XMLDOC_COMPLETED, 0, (LPARAM)hr);                   

    return hr;
}

void CPublishingWizard::_FetchComplete(HWND hwnd, HRESULT hr)
{
    // if we failed to load the document then lets pull in the default provider
    // list from our DLL, this can also fail, but its unlikely to.  we recreate
    // the XML DOM object to ensure our state is pure.

    _fUsingTemporaryProviders = FAILED(hr);         
    _fRepopulateProviders = TRUE;               // provider list will have changed!

    if (FAILED(hr))
    {
        _FreeProviderList();
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &_pdocProviders));
        if (SUCCEEDED(hr))
        {
            VARIANT varName;
            hr = InitVariantFromStr(&varName, TEXT("res://netplwiz.dll/xml/providers.xml"));
            if (SUCCEEDED(hr))
            {
                VARIANT_BOOL fSuccess = VARIANT_FALSE;
                hr = _pdocProviders->load(varName, &fSuccess);
                if (FAILED(hr) || (fSuccess != VARIANT_TRUE))
                {
                    hr = FAILED(hr) ? hr:E_FAIL;
                }
                VariantClear(&varName);
            }
        }
    }

    KillTimer(hwnd, FETCH_TIMERID);
    _ShowHideFetchProgress(hwnd, FALSE);
    _WizardNext(hwnd, WIZPAGE_PROVIDERS);
}

void CPublishingWizard::_ShowHideFetchProgress(HWND hwnd, BOOL fShow)
{
    ShowWindow(GetDlgItem(hwnd, IDC_PUB_SRCHPROVIDERS), fShow ? SW_SHOW:SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_PUB_SRCHPROVIDERS_STATIC1), fShow ? SW_SHOW:SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_PUB_SRCHPROVIDERS_STATIC2), fShow ? SW_SHOW:SW_HIDE);
    SendDlgItemMessage(hwnd, IDC_PUB_SRCHPROVIDERS, PBM_SETMARQUEE, (WPARAM)fShow, 0);
}

INT_PTR CPublishingWizard::_FetchProvidersDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _MapDlgItemText(hwnd, IDC_PUB_SRCHPROVIDERS_STATIC1, L"wp:destination", L"downloading");
            break;

        case MSG_XMLDOC_COMPLETED:
            _FetchComplete(hwnd, (HRESULT)lParam);
            break;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    BOOL fFetch = TRUE;
                    if (_pdocProviders && !_fUsingTemporaryProviders)
                    {
                        long lReadyState;
                        HRESULT hr = _pdocProviders->get_readyState(&lReadyState);
                        if (SUCCEEDED(hr) && (lReadyState == XMLDOC_COMPLETED))
                        {
                            _WizardNext(hwnd, WIZPAGE_PROVIDERS);
                            fFetch = FALSE;
                        }
                    }
                    
                    if (fFetch)
                    {                        
                        SetTimer(hwnd, FETCH_TIMERID, FETCH_TIMEOUT, NULL);
                        _FetchProviderList(hwnd);
                        PropSheet_SetWizButtons(GetParent(hwnd), 0x0);
                    }
                    return TRUE;
                }
            }
            break;
        }

        case WM_TIMER:
        {
            KillTimer(hwnd, FETCH_TIMERID);
            _ShowHideFetchProgress(hwnd, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}



// Destination page

int CPublishingWizard::_GetSelectedItem(HWND hwndList)
{
    int iSelected = ListView_GetNextItem(hwndList, -1, LVNI_FOCUSED|LVNI_SELECTED);
    if (iSelected == -1)
    {
        iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    }
    return iSelected;
}

void CPublishingWizard::_ProviderEnableNext(HWND hwnd)
{
    DWORD dwButtons = PSWIZB_BACK;
    
    // there must be an item available in the list, and it must have a ID property defined
    // for it so it can be enabled.

    int iSelected = _GetSelectedItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS));
    if (iSelected != -1)
    {
        LVITEM lvi = { 0 };
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;

        if (ListView_GetItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), &lvi))
        {
            IXMLDOMNode *pdn = (IXMLDOMNode*)lvi.lParam;
            TCHAR szID[INTERNET_MAX_URL_LENGTH];                
            if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_ID, szID, ARRAYSIZE(szID))))
            {
                dwButtons |= PSWIZB_NEXT;
            }
        }
    }

    PropSheet_SetWizButtons(GetParent(hwnd), dwButtons);
}


// extract an icon resource from the provider XML documents.  the icons are stored as
// mime encoded bitmaps that we decode into files in the users settings folder.  we return
// an index to the shared image list.

int CPublishingWizard::_GetRemoteIcon(LPCTSTR pszID, BOOL fCanRefresh)
{
    int iResult = -1;

    TCHAR szURL[INTERNET_MAX_URL_LENGTH];                
    HRESULT hr = _GetSiteURL(szURL, ARRAYSIZE(szURL), pszID);
    if (SUCCEEDED(hr))
    {
        TCHAR szFilename[MAX_PATH];
        hr = URLDownloadToCacheFile(NULL, szURL, szFilename, ARRAYSIZE(szFilename), 0x0, NULL);
        if (SUCCEEDED(hr))
        {
            iResult = Shell_GetCachedImageIndex(szFilename, 0x0, 0x0);
        }
    }

    return iResult;
}


// get the provider list from the internet

struct 
{
    LPTSTR pszAttribute;
    BOOL fIsString;
}
aProviderElements[] =
{
    { ATTRIBUTE_SUPPORTEDTYPES, FALSE },
    { ATTRIBUTE_DISPLAYNAME,    TRUE },
    { ATTRIBUTE_DESCRIPTION,    TRUE },
    { ATTRIBUTE_HREF,           FALSE },
    { ATTRIBUTE_ICONPATH,       FALSE },
    { ATTRIBUTE_ICON,           FALSE },
};

HRESULT CPublishingWizard::_MergeLocalProviders()
{
    TCHAR szBuffer[MAX_PATH];
    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), FMT_PROVIDER, _szProviderScope);

    IXMLDOMNode *pdn;
    HRESULT hr = _pdocProviders->selectSingleNode(szBuffer, &pdn);
    if (hr == S_OK)
    {
        HKEY hk;
        hr = _GetProviderKey(HKEY_CURRENT_USER, KEY_READ, SZ_REGVAL_ALTPROVIDERS, &hk);
        if (SUCCEEDED(hr))
        {
            for (int i =0; SUCCEEDED(hr) && (RegEnumKey(hk, i, szBuffer, ARRAYSIZE(szBuffer)) == ERROR_SUCCESS); i++)
            {
                // the manifest always overrides the entries that are stored in the registry,
                // therefore if there is an element in the document that has a matching ID to the
                // one in the registry then lets handle it.

                TCHAR szSelectValue[MAX_PATH];
                wnsprintf(szSelectValue, ARRAYSIZE(szSelectValue), TEXT("provider[@id=\"%s\"]"), szBuffer);
    
                IXMLDOMNode *pdnProvider;
                if (pdn->selectSingleNode(szSelectValue, &pdnProvider) == S_FALSE)
                {
                    IPropertyBag *ppb;
                    hr = SHCreatePropertyBagOnRegKey(hk, szBuffer, STGM_READ, IID_PPV_ARG(IPropertyBag, &ppb));
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMElement *pdel;
                        hr = _pdocProviders->createElement(ELEMENT_PROVIDER, &pdel);
                        if (SUCCEEDED(hr))
                        {
                            hr = SetAttributeFromStr(pdel, ATTRIBUTE_ID, szBuffer);
                            if (SUCCEEDED(hr))
                            {
                                // loop and replicate all the attributes from the property bag 
                                // into the element.  once we have done that we can add
                                // the element to the provider list.

                                for (int i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(aProviderElements)); i++)
                                {
                                    VARIANT var = {0};
                                    if (SUCCEEDED(ppb->Read(aProviderElements[i].pszAttribute, &var, NULL)))
                                    {
                                        hr = pdel->setAttribute(aProviderElements[i].pszAttribute, var);
                                        VariantClear(&var);
                                    }
                                }
                                               
                                if (SUCCEEDED(hr))
                                {
                                    hr = pdn->appendChild(pdel, NULL);
                                }
                            }
                            pdel->Release();
                        }
                        ppb->Release();
                    }
                }
                else
                {
                    pdnProvider->Release();
                }
            }
            RegCloseKey(hk);
        }            
        pdn->Release();
    }
    return hr;
}

void CPublishingWizard::_GetDefaultProvider(LPTSTR pszProvider, int cch)
{
    HKEY hk;
    HRESULT hr = _GetProviderKey(HKEY_CURRENT_USER, KEY_READ, NULL, &hk);
    if (SUCCEEDED(hr))
    {
        DWORD cb = cch*sizeof(*pszProvider);
        SHGetValue(hk, NULL, SZ_REGVAL_DEFAULTPROVIDER, NULL, pszProvider, &cb);
        RegCloseKey(hk);
    }
}

void CPublishingWizard::_SetDefaultProvider(IXMLDOMNode *pdn)
{
    TCHAR szProvider[MAX_PATH];
    HRESULT hr = GetStrFromAttribute(pdn, ATTRIBUTE_ID, szProvider, ARRAYSIZE(szProvider));
    if (SUCCEEDED(hr))
    {
        HKEY hk;
        hr = _GetProviderKey(HKEY_CURRENT_USER, KEY_WRITE, NULL, &hk);
        if (SUCCEEDED(hr))
        {
            // store the default provider value
            DWORD cb = (lstrlen(szProvider)+1)*sizeof(*szProvider);
            SHSetValue(hk, NULL, SZ_REGVAL_DEFAULTPROVIDER, REG_SZ, szProvider, cb);

            // we now need to replicate the properties from the DOM into the registry so that 
            // the user can always get to the specified site.  to make this easier we 
            // will create a property bag that we will copy values using.

            TCHAR szBuffer[MAX_PATH];
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), (SZ_REGVAL_ALTPROVIDERS TEXT("\\%s")), szProvider);

            IPropertyBag *ppb;
            hr = SHCreatePropertyBagOnRegKey(hk, szBuffer, STGM_CREATE | STGM_WRITE, IID_PPV_ARG(IPropertyBag, &ppb));
            if (SUCCEEDED(hr))
            {
                IXMLDOMElement *pdel;
                hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
                if (SUCCEEDED(hr))
                {
                    for (int i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(aProviderElements)); i++)
                    {
                        if (aProviderElements[i].fIsString)
                        {
                            hr = _GetProviderString(pdn, aProviderElements[i].pszAttribute, szBuffer, ARRAYSIZE(szBuffer));
                            if (SUCCEEDED(hr))
                            {
                                hr = SHPropertyBag_WriteStr(ppb, aProviderElements[i].pszAttribute, szBuffer);
                            }
                        }
                        else
                        {
                            VARIANT var = {0};
                            if (S_OK == pdel->getAttribute(aProviderElements[i].pszAttribute, &var))
                            {
                                hr = ppb->Write(aProviderElements[i].pszAttribute, &var);
                                VariantClear(&var);
                            }
                        }
                    }
                    pdel->Release();
                }
                ppb->Release();
            }

            RegCloseKey(hk);
        }
    }
}


// load a localized string from the XML node for the provider

HRESULT CPublishingWizard::_GetProviderString(IXMLDOMNode *pdn, USHORT idPrimary, USHORT idSub, LPCTSTR pszID, LPTSTR pszBuffer, int cch)
{
    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("strings[@langid='%04x']/string[@id='%s'][@langid='%04x']"), idPrimary, pszID, idSub);

    IXMLDOMNode *pdnString;
    HRESULT hr = pdn->selectSingleNode(szPath, &pdnString);
    if (hr == S_OK)
    {
        VARIANT var = {VT_BSTR};
        hr = pdnString->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            VariantToStr(&var, pszBuffer, cch);
            VariantClear(&var);
        }
        pdnString->Release();
    }

    return hr;
}

HRESULT CPublishingWizard::_GetProviderString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch)
{
    *pszBuffer = TEXT('\0');

    LANGID idLang = GetUserDefaultLangID();
    HRESULT hr = _GetProviderString(pdn, PRIMARYLANGID(idLang), SUBLANGID(idLang), pszID, pszBuffer, cch);
    if (hr == S_FALSE)
    {
        hr = _GetProviderString(pdn, PRIMARYLANGID(idLang), SUBLANG_NEUTRAL, pszID, pszBuffer, cch);
        if (hr == S_FALSE)
        {
            hr = _GetProviderString(pdn, LANG_NEUTRAL, SUBLANG_NEUTRAL, pszID, pszBuffer, cch);
            if (hr == S_FALSE)
            {
                hr = GetStrFromAttribute(pdn, pszID, pszBuffer, cch);
            }
        }
    }
    
    SHLoadIndirectString(pszBuffer, pszBuffer, cch, NULL);
    return hr;
}


// populate the provider list on the destination page

#define TILE_DISPLAYNAME    0
#define TILE_DESCRIPTION    1
#define TILE_MAX            1

const UINT c_auTileColumns[] = {TILE_DISPLAYNAME, TILE_DESCRIPTION};
const UINT c_auTileSubItems[] = {TILE_DESCRIPTION};

int CPublishingWizard::_AddProvider(HWND hwnd, IXMLDOMNode *pdn)
{
    // fill out the item information

    LV_ITEM lvi = { 0 };
    lvi.mask = LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE;
    lvi.iItem = ListView_GetItemCount(hwnd);            // always append!
    lvi.lParam = (LPARAM)pdn;  
    lvi.pszText = LPSTR_TEXTCALLBACK;
    lvi.iImage = -1;                                    // set to the default state

    // read the icon location and put that onto the item

    TCHAR szIcon[MAX_PATH];
    if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_ICONPATH, szIcon, ARRAYSIZE(szIcon))))
    {
        int resid = PathParseIconLocation(szIcon);
        lvi.iImage =  Shell_GetCachedImageIndex(szIcon, resid, 0x0);
    }
    else if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_ICON, szIcon, ARRAYSIZE(szIcon))))
    {
        lvi.iImage = _GetRemoteIcon(szIcon, TRUE);
    }   
    
    // if that failed then lets try and compute a sensible default icon for us to use

    if (lvi.iImage == -1)
    {
        // under the provider key for the install lets see if there is a default icon that we
        // should be using.  if not, or if that fails to extract then lets use the publishing one.

        HKEY hk;
        if (SUCCEEDED(_GetProviderKey(HKEY_LOCAL_MACHINE, KEY_READ, NULL, &hk)))
        {
            DWORD cb = ARRAYSIZE(szIcon)*sizeof(*szIcon);
            if (ERROR_SUCCESS == SHGetValue(hk, NULL, SZ_REGVAL_DEFAULTPROVIDERICON, NULL, szIcon, &cb))
            {
                int resid = PathParseIconLocation(szIcon);
                lvi.iImage = Shell_GetCachedImageIndex(szIcon, resid, 0x0);         // default to the publishing icon
            }
            RegCloseKey(hk);
        }

        if (lvi.iImage == -1)
            lvi.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), -244, 0x0);
    }

    int iResult = ListView_InsertItem(hwnd, &lvi);
    if (iResult != -1)
    {
        pdn->AddRef();                                  // it was added to the view, so take reference

        LVTILEINFO lvti;
        lvti.cbSize = sizeof(LVTILEINFO);
        lvti.iItem = iResult;
        lvti.cColumns = ARRAYSIZE(c_auTileSubItems);
        lvti.puColumns = (UINT*)c_auTileSubItems;
        ListView_SetTileInfo(hwnd, &lvti);
    }

    return iResult;
}

void CPublishingWizard::_PopulateProviderList(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_PUB_PROVIDERS);

    // setup the view with the tiles that we want to show and the
    // icon lists - shared with the shell.

    ListView_DeleteAllItems(hwndList);
    ListView_SetView(hwndList, LV_VIEW_TILE);

    for (int i=0; i<ARRAYSIZE(c_auTileColumns); i++)
    {
        LV_COLUMN col;
        col.mask = LVCF_SUBITEM;
        col.iSubItem = c_auTileColumns[i];
        ListView_InsertColumn(hwndList, i, &col);
    }

    RECT rc;
    GetClientRect(hwndList, &rc);

    LVTILEVIEWINFO lvtvi;
    lvtvi.cbSize = sizeof(LVTILEVIEWINFO);
    lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
    lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    lvtvi.sizeTile.cx = RECTWIDTH(rc) - GetSystemMetrics(SM_CXVSCROLL);
    lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
    ListView_SetTileViewInfo(hwndList, &lvtvi);

    if (_pdocProviders)
    {
        long lReadyState;
        HRESULT hr = _pdocProviders->get_readyState(&lReadyState);
        if (SUCCEEDED(hr) && (lReadyState == XMLDOC_COMPLETED))
        {
            // lets merge in the local providers, these are local to this user,
            // we check for duplicates so this shouldn't present too much hardship.

            _MergeLocalProviders();

            // format a query to return the providers that match our publishing scope,
            // this will allow the wizard to show different lists of providers for
            // web publishing vs. internet printing

            WCHAR szBuffer[MAX_PATH];
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), FMT_PROVIDERS, _szProviderScope);

            IXMLDOMNodeList *pnl;
            hr = _pdocProviders->selectNodes(szBuffer, &pnl);
            if (hr == S_OK)
            {
                long cSelection;
                hr = pnl->get_length(&cSelection);
                if (SUCCEEDED(hr) && (cSelection > 0))
                {
                    // get the list of unique types from the selection we are going to try and publish

                    HDPA hdpaUniqueTypes = NULL;
                    _GetUniqueTypeList(FALSE, &hdpaUniqueTypes);      // don't care if this fails - ptr is NULL

                    // we need the default provider to highlight correctly, using this we can then 
                    // populate the list from the provider manfiest

                    TCHAR szDefaultProvider[MAX_PATH] = {0};
                    _GetDefaultProvider(szDefaultProvider, ARRAYSIZE(szDefaultProvider));

                    int iDefault = 0;
                    for (long lNode = 0; lNode != cSelection; lNode++)
                    {
                        IXMLDOMNode *pdn;
                        hr = pnl->get_item(lNode, &pdn);
                        if (SUCCEEDED(hr))
                        {
                            // filter based on the list of types they support, this is optional
                            // if they don't specify anything then they are in the list,
                            // otherwise the format is assumed to be a file spec, eg *.bmp;*.jpg; etc.

                            BOOL fSupported = TRUE;
                            if (hdpaUniqueTypes)
                            {
                                hr = GetStrFromAttribute(pdn, ATTRIBUTE_SUPPORTEDTYPES, szBuffer, ARRAYSIZE(szBuffer));
                                if (SUCCEEDED(hr))
                                {
                                    fSupported = FALSE;
                                    for (int i = 0; !fSupported && (i < DPA_GetPtrCount(hdpaUniqueTypes)); i++)
                                    {
                                        LPCTSTR pszExtension = (LPCTSTR)DPA_GetPtr(hdpaUniqueTypes, i);
                                        fSupported = PathMatchSpec(pszExtension, szBuffer);
                                    }                            
                                }
                            }

                            // if this is a supported item then lets add it to the list

                            if (fSupported)
                            {
                                 hr = GetStrFromAttribute(pdn, ATTRIBUTE_ID, szBuffer, ARRAYSIZE(szBuffer));
                                 if (SUCCEEDED(hr))
                                 {
                                    int i = _AddProvider(hwndList, pdn); 
                                    if ((i != -1) && (0 == StrCmpI(szBuffer, szDefaultProvider)))
                                    {
                                        iDefault = i;
                                    }
                                }
                            }

                            pdn->Release();
                        }
                    }

                    ListView_SetItemState(hwndList, iDefault, LVIS_SELECTED, LVIS_SELECTED);
                    ListView_EnsureVisible(hwndList, iDefault, FALSE);

                    if (hdpaUniqueTypes)
                        DPA_DestroyCallback(hdpaUniqueTypes, s_FreeStringProc, 0);
                }            
                else
                {
                    // we have no providers that match this criteria therefore lets
                    // create a dummy one which shows this to the caller

                    IXMLDOMElement *pdelProvider;
                    hr = _pdocManifest->createElement(ELEMENT_FILE, &pdelProvider);
                    if (SUCCEEDED(hr))
                    {
                        IResourceMap *prm;
                        hr = _GetResourceMap(&prm);
                        if (SUCCEEDED(hr))
                        {
                            // get the no providers string
                            if (FAILED(_LoadMappedString(L"wp:selector", L"noprovider", szBuffer, ARRAYSIZE(szBuffer))))
                                LoadString(g_hinst, IDS_PUB_NOPROVIDER, szBuffer, ARRAYSIZE(szBuffer));

                            hr = SetAttributeFromStr(pdelProvider, ATTRIBUTE_DISPLAYNAME, szBuffer);

                            // get the sub-text for the no providers
                            if (SUCCEEDED(hr))
                            {
                                if (FAILED(_LoadMappedString(L"wp:selector", L"noproviderdesc", szBuffer, ARRAYSIZE(szBuffer))))
                                    LoadString(g_hinst, IDS_PUB_NOPROVIDERDESC, szBuffer, ARRAYSIZE(szBuffer));
                                
                                hr = SetAttributeFromStr(pdelProvider, ATTRIBUTE_DESCRIPTION, szBuffer);
                            }

                            // lets put together a resource string for the icon we are going to show
                            if (SUCCEEDED(hr))
                            {
                                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("netplwiz.dll,-%d"), IDI_NOPROVIDERS);
                                hr = SetAttributeFromStr(pdelProvider, ATTRIBUTE_ICONPATH, szBuffer);
                            }

                            // lets add a provider from the free standing node
                            if (SUCCEEDED(hr))
                            {
                                IXMLDOMNode *pdnProvider;
                                hr = pdelProvider->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdnProvider));
                                if (SUCCEEDED(hr))
                                {
                                    _AddProvider(hwndList, pdnProvider);
                                    pdnProvider->Release();
                                }
                            }

                            prm->Release();
                        }
                        pdelProvider->Release();
                    }
                }
                pnl->Release();
            }
        }
    }

    _fRepopulateProviders = FALSE;      // providers have been populated
}


// handle next in the provider (destination) page

HRESULT CPublishingWizard::_ProviderNext(HWND hwnd, HPROPSHEETPAGE *phPage)
{
    HRESULT hr = E_FAIL;
    int iSelected = _GetSelectedItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS));
    if (iSelected != -1)
    {
        LVITEM lvi = { 0 };
        lvi.iItem = iSelected;
        lvi.mask = LVIF_PARAM;

        if (ListView_GetItem(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), &lvi))
        {
            IXMLDOMNode *pdn = (IXMLDOMNode*)lvi.lParam;

            // set the default provider from the node value

            _SetDefaultProvider(pdn);

            // now try and navigate to the web page, if no URL then show advanced path

            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
            if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_HREF, szURL, ARRAYSIZE(szURL))))
            {
                // get the folder creation flag from the site so that we can set the HTML wizard 
                // into the correct state.   note that the site doesn't need to specify this
                // and we will default to TRUE - eg. do folder creation, this allows the current
                // hosts to work without modification.

                hr = _InitPropertyBag(szURL);
                if (SUCCEEDED(hr))
                {
                    hr = _pwwe->GetFirstPage(phPage);
                }
            }
            else
            {
                // No URL was specified, so lets go through the advanced path where
                // the user gets to type a location and we create connection to that
                // (replaced the old Add Net Place functionality);

                *phPage = _aWizPages[WIZPAGE_LOCATION];
                hr = S_OK;
            }
        }
    }
    return hr;
}

void CPublishingWizard::_ProviderGetDispInfo(LV_DISPINFO *plvdi)
{
    if (plvdi->item.mask & LVIF_TEXT)
    {
        IXMLDOMNode *pdn = (IXMLDOMNode*)plvdi->item.lParam;
        switch (plvdi->item.iSubItem)
        {
            case TILE_DISPLAYNAME:
                _GetProviderString(pdn, ATTRIBUTE_DISPLAYNAME, plvdi->item.pszText, plvdi->item.cchTextMax);
                break;
            
            case TILE_DESCRIPTION:
                _GetProviderString(pdn, ATTRIBUTE_DESCRIPTION, plvdi->item.pszText, plvdi->item.cchTextMax);
                break;
            default:
                ASSERTMSG(0, "ListView is asking for wrong column in publishing wizard");
                break;
        }
    }
}
    
void CPublishingWizard::_InitProvidersDialog(HWND hwnd)
{
    // initial the dialog accordingly
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr = _LoadMappedString(L"wp:destination", L"providercaption", szBuffer, ARRAYSIZE(szBuffer));
    if (SUCCEEDED(hr))
    {
        SetDlgItemText(hwnd, IDC_PUB_PROVIDERSCAPTION, szBuffer);

        // lets size the caption area as needed, and move controls around as needed
        UINT ctls[] = { IDC_PUB_PROVIDERSLABEL, IDC_PUB_PROVIDERS};
        int dy = SizeControlFromText(hwnd, IDC_PUB_PROVIDERSCAPTION, szBuffer);
        MoveControls(hwnd, ctls, ARRAYSIZE(ctls), 0, dy);

        // adjust the provider dialog size as needed
        RECT rc;
        GetWindowRect(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), &rc);
        SetWindowPos(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), NULL, 0, 0, RECTWIDTH(rc), RECTHEIGHT(rc)-dy, SWP_NOZORDER|SWP_NOMOVE);
    }    

    // set the caption for the providers control
    _MapDlgItemText(hwnd, IDC_PUB_PROVIDERSLABEL, L"wp:destination", L"providerslabel");

    // set the image list to the list view
    HIMAGELIST himlLarge, himlSmall;
    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(GetDlgItem(hwnd, IDC_PUB_PROVIDERS), himlSmall, LVSIL_SMALL);
};

INT_PTR CPublishingWizard::_ProviderDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _InitProvidersDialog(hwnd);
            return TRUE;
           
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case LVN_GETDISPINFO:
                    _ProviderGetDispInfo((LV_DISPINFO*)pnmh);
                    return TRUE;

                case LVN_ITEMCHANGED:
                    _ProviderEnableNext(hwnd);
                    return TRUE;

                case LVN_DELETEITEM:
                {
                    NMLISTVIEW *nmlv = (NMLISTVIEW*)lParam;
                    IXMLDOMNode *pdn = (IXMLDOMNode*)nmlv->lParam;
                    pdn->Release();
                    return TRUE;
                }

                case PSN_SETACTIVE:
                {
                    _fTransferComplete = FALSE;             // we haven't started to tranfser yet
                    _fShownCustomLocation = FALSE;          // we haven't shown the custom location page
                    
                    if (_fRecomputeManifest)
                        _BuildTransferManifest();   

                    if (_fRepopulateProviders)
                        _PopulateProviderList(hwnd);        // if the manifest changes, so might the providers!

                    _ProviderEnableNext(hwnd);
                    return TRUE;              
                }                                 

                // when going back from the destination page, lets determine from the
                // site where we should be going.

                case PSN_WIZBACK:
                {
                    if (_dwFlags & SHPWHF_NOFILESELECTOR)
                    {
                        if (_punkSite) 
                        {
                            IWizardSite *pws;
                            if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                            {
                                HPROPSHEETPAGE hpage;
                                if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                                {
                                    PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                }
                                pws->Release();
                            }
                        }
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    }
                    else
                    {
                        _WizardNext(hwnd, WIZPAGE_WHICHFILE);
                    }
                    return TRUE;
                }

                // when going forward lets query the next page, set the selection
                // and then let the foreground know whats going on.

                case PSN_WIZNEXT:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ProviderNext(hwnd, &hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }

                // the item was activated, therefore we need to goto the next (in this case the page for the provider).

                case LVN_ITEMACTIVATE:
                {
                    HPROPSHEETPAGE hpage;
                    if (SUCCEEDED(_ProviderNext(hwnd, &hpage)))
                    {
                        PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                    }
                    return TRUE;
                }

            }
            break;
        }
    }

    return FALSE;
}                                    


// Resample/Resize dialog.  This dialog is displayed when we determine that there
// are images that need to be resized.

INT_PTR CPublishingWizard::_ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            Button_SetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZE), BST_CHECKED);
            Button_SetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZESMALL), BST_CHECKED);
            return TRUE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
                    return TRUE;
                
                case PSN_WIZBACK:
                {
                    // if we went through the custom location stuff then navigate back into there.

                    if (_fShownCustomLocation)
                        return _WizardNext(hwnd, _fShownUserName ? WIZPAGE_FTPUSER:WIZPAGE_LOCATION);

                    return _WizardNext(hwnd, WIZPAGE_PROVIDERS);
                }

                case PSN_WIZNEXT:
                {
                    if (Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZE)) == BST_CHECKED)
                    {   
                        if (Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZESMALL)) == BST_CHECKED)
                            _ro = RESIZE_SMALL;
                        else if (Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZEMEDIUM)) == BST_CHECKED)
                            _ro = RESIZE_MEDIUM;
                        else 
                            _ro = RESIZE_LARGE;
                    }                
                    else
                    {
                        _ro = RESIZE_NONE;
                    }
                    return _WizardNext(hwnd, WIZPAGE_COPYING);
                }
            }
            break;
        }

        case WM_COMMAND:
        {
            if ((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDC_PUB_RESIZE))
            {
                BOOL fEnable = Button_GetCheck(GetDlgItem(hwnd, IDC_PUB_RESIZE)) == BST_CHECKED;
                EnableWindow(GetDlgItem(hwnd, IDC_PUB_RESIZESMALL), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_PUB_RESIZEMEDIUM), fEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_PUB_RESIZELARGE), fEnable);
            }
            break;
        }
    }
    return FALSE;
}                                    


// this is called before we transfer each item, we look at the IShellItem we have and
// try to update either our stats, or the indicator that this is a new file we are processing.

BOOL CPublishingWizard::_HasAttributes(IShellItem *psi, SFGAOF flags)
{
    BOOL fReturn = FALSE;
    SFGAOF flagsOut;
    if (SUCCEEDED(psi->GetAttributes(flags, &flagsOut)) && (flags & flagsOut))
    {
        fReturn = TRUE;
    }
    return fReturn;
}

HRESULT CPublishingWizard::PreOperation(const STGOP op, IShellItem *psiItem, IShellItem *psiDest)
{
    if (psiItem && _HasAttributes(psiItem, SFGAO_STREAM))
    {
        if (STGOP_COPY == op)
        {
            // lets fill in the details of the file

            LPOLESTR pstrName;
            HRESULT hr = psiItem->GetDisplayName(SIGDN_PARENTRELATIVEEDITING, &pstrName);
            if (SUCCEEDED(hr))
            {
                SetDlgItemText(_hwndCopyingPage, IDC_PUB_COPYFILE, pstrName);
                CoTaskMemFree(pstrName);
            }

            // lets update the progress bar for the number of files we are transfering.

            _iFile++;       

            SendDlgItemMessage(_hwndCopyingPage, IDC_PUB_TRANSPROGRESS, PBM_SETRANGE32, 0, (LPARAM)_cFiles);
            SendDlgItemMessage(_hwndCopyingPage, IDC_PUB_TRANSPROGRESS, PBM_SETPOS, (WPARAM)_iFile, 0);

            TCHAR szBuffer[MAX_PATH];
            FormatMessageString(IDS_PUB_COPYINGFMT, szBuffer, ARRAYSIZE(szBuffer), _iFile, _cFiles);
            SetDlgItemText(_hwndCopyingPage, IDC_PUB_LABELTRANSPROG, szBuffer);

            // get the thumbnail and show it.

            IExtractImage *pei;
            hr = psiItem->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractImage, &pei));
            if (SUCCEEDED(hr))
            {
                SIZE sz = {120,120};
                WCHAR szImage[MAX_PATH];
                DWORD dwFlags = 0;

                hr = pei->GetLocation(szImage, ARRAYSIZE(szImage), NULL, &sz, 24, &dwFlags);
                if (SUCCEEDED(hr))
                {
                    HBITMAP hbmp;
                    hr = pei->Extract(&hbmp);
                    if (SUCCEEDED(hr))
                    {
                        if (!PostMessage(_hwndCopyingPage, PWM_UPDATEICON, (WPARAM)IMAGE_BITMAP, (LPARAM)hbmp))
                        {
                            DeleteObject(hbmp);
                        }
                    }
                }
                pei->Release();
            }

            // if that failed then lets get the icon for the file and place that into the dialog,
            // this is less likely to fail - I hope.

            if (FAILED(hr))
            {
                IPersistIDList *ppid;
                hr = psiItem->QueryInterface(IID_PPV_ARG(IPersistIDList, &ppid));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = ppid->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCWSTR)pidl, -1, &sfi, sizeof(sfi), SHGFI_ICON|SHGFI_PIDL|SHGFI_ADDOVERLAYS))
                        {
                            if (!PostMessage(_hwndCopyingPage, PWM_UPDATEICON, (WPARAM)IMAGE_ICON, (LPARAM)sfi.hIcon))
                            {
                                DeleteObject(sfi.hIcon);
                            }
                        }
                        ILFree(pidl);
                    }
                    ppid->Release();
                }
            }
        }
        else if (STGOP_STATS == op)
        {
            _cFiles++;
        }
    }
    return S_OK;
}


// while we are moving the bits of the file ensure that we update the progress bar accordingly.

void CPublishingWizard::_SetProgress(DWORD dwCompleted, DWORD dwTotal)
{
    if (_dwTotal != dwTotal)
        _dwTotal = dwTotal;
        
    if (_dwCompleted != dwCompleted)
        _dwCompleted = dwCompleted;

    PostMessage(_hwndCopyingPage, PWM_UPDATE, (WPARAM)dwCompleted, (LPARAM)dwTotal);
}

HRESULT CPublishingWizard::OperationProgress(const STGOP op, IShellItem *psiItem, IShellItem *psiDest, ULONGLONG ulTotal, ULONGLONG ulComplete)
{
    if (psiItem && (op == STGOP_COPY))
    {
        ULARGE_INTEGER uliCompleted, uliTotal;

        uliCompleted.QuadPart = ulComplete;
        uliTotal.QuadPart = ulTotal;

        // If we are using the top 32 bits, scale both numbers down.
        // Note that I'm using the attribute that dwTotalHi is always larger than dwCompleted

        ASSERT(uliTotal.HighPart >= uliCompleted.HighPart);
        while (uliTotal.HighPart)
        {
            uliCompleted.QuadPart >>= 1;
            uliTotal.QuadPart >>= 1;
        }

        ASSERT((0 == uliCompleted.HighPart) && (0 == uliTotal.HighPart));       // Make sure we finished scaling down.
        _SetProgress(uliCompleted.LowPart, uliTotal.LowPart);
    }

    return S_OK;
}


// Method to invoke the transfer engine

HRESULT CPublishingWizard::_BeginTransfer(HWND hwnd)
{
    // initialize the dialog before we start the copy process.

    _dwCompleted = -1;                  // progress bars are reset
    _dwTotal = -1;
    _iPercentageComplete = -1;

    _cFiles = 0;                        // haven't transfered any files yet
    _iFile = 0;

    _hrFromTransfer = S_FALSE;
    _fCancelled = FALSE;

    // set the state of the controls ready to perform the transfer

    SetDlgItemText(hwnd, IDC_PUB_COPYFILE, TEXT(""));
    SendMessage(hwnd, PWM_UPDATE, 0, 0);
    PropSheet_SetWizButtons(GetParent(hwnd), 0x0);

    // initialize the transfer object ready to move the bits to the site

    ITransferAdviseSink *ptas;
    HRESULT hr = this->QueryInterface(IID_PPV_ARG(ITransferAdviseSink, &ptas));
    if (SUCCEEDED(hr))
    {
        // build the list of files for use to transfer to the site, this we
        // key of the transfer manifest which is stored in our property bag.

        IXMLDOMDocument *pdocManifest;
        hr = GetTransferManifest(NULL, &pdocManifest);
        if (SUCCEEDED(hr))
        {
            TRANSFERINFO ti = {0};
            ti.hwnd = hwnd;
            ti.dwFlags = _dwFlags;

            CDPA<TRANSFERITEM> dpaItems;
            hr = _InitTransferInfo(pdocManifest, &ti, &dpaItems);
            if (SUCCEEDED(hr))
            {
                if (ti.fUsePost)
                {
                    hr = PublishViaPost(&ti, &dpaItems, ptas);
                }
                else
                {
                    hr = PublishViaCopyEngine(&ti, &dpaItems, ptas);
                }
            }                                            

            dpaItems.DestroyCallback(_FreeTransferItems, NULL); // will have been detached by thread if handled
            pdocManifest->Release();
        }

        if (FAILED(hr))           
            PostMessage(hwnd, PWM_TRANSFERCOMPLETE, 0, (LPARAM)hr);

        ptas->Release();
    }
    return hr;
}


// create a link back to the site, this is keyed off information stored in the manifest.

HRESULT CPublishingWizard::_CreateFavorite(IXMLDOMNode *pdnUploadInfo)
{
    // lets pick up the favorite element from the manifest, this should define all
    // that is needed for us to create a link in to the favorites menu.

    IXMLDOMNode *pdn;
    HRESULT hr = pdnUploadInfo->selectSingleNode(ELEMENT_FAVORITE, &pdn);
    if (S_OK == hr)
    {
        // we need an URL to create the link using.

        WCHAR szURL[INTERNET_MAX_URL_LENGTH] = {0};
        hr = GetStrFromAttribute(pdn, ATTRIBUTE_HREF, szURL, ARRAYSIZE(szURL));
        if (SUCCEEDED(hr))
        {
            // we need a name to save the link as.

            WCHAR szName[MAX_PATH] = {0};
            hr = GetStrFromAttribute(pdn, ATTRIBUTE_NAME, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                IShellLink *psl;
                hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    hr = psl->SetPath(szURL);                    // set the target

                    // if that works then lets try and put a comment onto the link - this is an optional
                    // value for the <favorite/> element.

                    if (SUCCEEDED(hr))
                    {
                        WCHAR szComment[MAX_PATH] = {0};
                        if (SUCCEEDED(GetStrFromAttribute(pdn, ATTRIBUTE_COMMENT, szComment, ARRAYSIZE(szComment))))
                        {
                            hr = psl->SetDescription(szComment);     // set the comment
                        }
                    }

                    // assuming all that works then lets persist the link into the users
                    // favorites folder, this inturn will create it on their favaorites menu.

                    if (SUCCEEDED(hr))
                    {
                        WCHAR szFilename[MAX_PATH];
                        if (SHGetSpecialFolderPath(NULL, szFilename, CSIDL_FAVORITES, TRUE))
                        {
                            PathAppend(szFilename, szName);
                            PathRenameExtension(szFilename, TEXT(".lnk"));

                            IPersistFile *ppf;
                            hr = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                            if (SUCCEEDED(hr))
                            {
                                hr = ppf->Save(szFilename, TRUE);
                                ppf->Release();
                            }
                        }
                    }

                    psl->Release();
                }
            }
        }
        pdn->Release();
    }

    return hr;
}


// When transfer is complete we need to determine which page we are going to show
// this will either come from the site or it will be a HTML page hosted
// on the site.

HPROPSHEETPAGE CPublishingWizard::_TransferComplete(HRESULT hrFromTransfer)
{
    HPROPSHEETPAGE hpResult = NULL;

    // convert the HRESULT From something that will have come from the 
    // transfer engine into something the outside world will understand.

    if (hrFromTransfer == STRESPONSE_CANCEL)
        hrFromTransfer = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    
    // tag ourselves as in the "completed transfer" state, therefore the site knows where to
    // navigate to next.

    _fTransferComplete = TRUE;
    _hrFromTransfer = hrFromTransfer;

    // get the next page from the site, this will either be the done or 
    // cancelled page based on the result of the site.

    IWizardSite *pws;
    HRESULT hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
    if (SUCCEEDED(hr))
    {
        if (_hrFromTransfer == HRESULT_FROM_WIN32(ERROR_CANCELLED))
        {
            hr = pws->GetCancelledPage(&hpResult);
        }
        else
        {
            hr = pws->GetNextPage(&hpResult);
        }
        pws->Release();
    }

    // lets put the result into the manifest that we we can read it back later.

    IXMLDOMDocument *pdocManifest;
    hr = GetTransferManifest(NULL, &pdocManifest);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode *pdn;
        hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdn);
        if (hr == S_OK)
        {
            // if there is a success/failure page defined then lets handle it accordingly

            WCHAR szPageToShow[INTERNET_MAX_URL_LENGTH] = {0};
            if (SUCCEEDED(_hrFromTransfer))
            {
                hr = GetURLFromElement(pdn, ELEMENT_SUCCESSPAGE, szPageToShow, ARRAYSIZE(szPageToShow));
            }
            else
            {
                if (_hrFromTransfer == HRESULT_FROM_WIN32(ERROR_CANCELLED))
                    hr = GetURLFromElement(pdn, ELEMENT_CANCELLEDPAGE, szPageToShow, ARRAYSIZE(szPageToShow));

                if ((_hrFromTransfer != HRESULT_FROM_WIN32(ERROR_CANCELLED)) || FAILED(hr))
                    hr = GetURLFromElement(pdn, ELEMENT_FAILUREPAGE, szPageToShow, ARRAYSIZE(szPageToShow));
            }

            // if we have the page then lets navigate to it, this will give us the succes
            // failure pages from the site.

            if (SUCCEEDED(hr) && szPageToShow[0])
            {
                hr = _pwwe->SetInitialURL(szPageToShow);
                if (SUCCEEDED(hr))
                {
                    hr = _pwwe->GetFirstPage(&hpResult);
                }
            }

            // lets do the final processing of the transfer (creating net places, favorites etc)

            _CreateFavorite(pdn);

            pdn->Release();
        }

        pdocManifest->Release();
    }

    return hpResult;
}


// this is the copying dialog.   this displays the progress bar and other information as
// we transfer the files from the users m/c to the site.

INT_PTR CPublishingWizard::_CopyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
            _hwndCopyingPage = hwnd;
            return FALSE;

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    _BeginTransfer(hwnd);
                    return TRUE;

                case PSN_QUERYCANCEL:
                {
                    _fCancelled = TRUE;
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)TRUE);
                    return TRUE;
                }
            }
            break;
        }

        case WM_CTLCOLORSTATIC:
        {
            // we want the preview filled with a white background.
            if (GetDlgCtrlID((HWND)lParam) == IDC_PUB_PREVIEW)
            {
                return (INT_PTR)(COLOR_3DHILIGHT+1);
            }
            return FALSE;
        }

        case PWM_TRANSFERCOMPLETE:
        {
            PropSheet_SetCurSel(GetParent(hwnd), _TransferComplete((HRESULT)lParam), -1);
            break;
        }

        case PWM_UPDATE:
        {
            DWORD dwTotal = (DWORD)lParam;
            DWORD dwCompleted = (DWORD)wParam;

            SendDlgItemMessage(hwnd, IDC_PUB_FILEPROGRESS, PBM_SETRANGE32, 0, (LPARAM)dwTotal);
            SendDlgItemMessage(hwnd, IDC_PUB_FILEPROGRESS, PBM_SETPOS, (WPARAM)dwCompleted, 0);

            // compute the percentage of the file copied.

            int iPercentage = 0;
            if (dwTotal > 0)
                iPercentage = (dwCompleted * 100) / dwTotal;

            if (_iPercentageComplete != iPercentage)
            {
                TCHAR szBuffer[MAX_PATH];
                FormatMessageString(IDS_PUB_COMPLETEFMT, szBuffer, ARRAYSIZE(szBuffer), iPercentage);
                SetDlgItemText(_hwndCopyingPage, IDC_PUB_LABELFILEPROG, szBuffer);
            }

            break;
        }

        case PWM_UPDATEICON:
        {
            HWND hwndThumbnail = GetDlgItem(hwnd, IDC_PUB_PREVIEW);
            DWORD dwStyle = (DWORD)GetWindowLongPtr(hwndThumbnail, GWL_STYLE) & ~(SS_BITMAP|SS_ICON);
            if (wParam == IMAGE_BITMAP)
            {
                SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_BITMAP);
                HBITMAP hbmp = (HBITMAP)SendMessage(hwndThumbnail, STM_SETIMAGE, wParam, lParam);
                if (hbmp)
                {
                    DeleteObject(hbmp);
                }               
            }
            else if (wParam == IMAGE_ICON)
            {
                SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_ICON);
                HICON hIcon = (HICON)SendMessage(hwndThumbnail, STM_SETIMAGE, wParam, lParam);
                if (hIcon)
                {
                    DeleteObject(hIcon);
                }
            }
            else
            {
                DeleteObject((HGDIOBJ)lParam);
            }
            break;
        }
    }

    return FALSE;
}


// Manage the list of file types

HRESULT CPublishingWizard::_AddExtenisonToList(HDPA hdpa, LPCTSTR pszExtension)
{
    UINT iItem = 0;
    UINT nItems = DPA_GetPtrCount(hdpa);
    BOOL fFound = FALSE;

    for ( ;(iItem < nItems) && !fFound; iItem++)
    {
        LPCTSTR pszExtensionInDPA = (LPCTSTR) DPA_GetPtr(hdpa, iItem);
        if (pszExtensionInDPA)
        {
            fFound = (0 == StrCmpI(pszExtension, pszExtensionInDPA));
        }
    }

    HRESULT hr = S_OK;
    if (!fFound)
    {
        LPTSTR pszAlloc;
        hr = E_OUTOFMEMORY;
        pszAlloc = StrDup(pszExtension);
        if (pszAlloc)
        {
            if (DPA_ERR == DPA_AppendPtr(hdpa, (void*)pszAlloc))
            {
                LocalFree(pszAlloc);
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

int CPublishingWizard::s_FreeStringProc(void* pFreeMe, void* pData)
{
    LocalFree(pFreeMe);
    return 1;
}

HRESULT CPublishingWizard::_GetUniqueTypeList(BOOL fIncludeFolder, HDPA *phdpa)
{
    *phdpa = NULL;

    HRESULT hr = (*phdpa = DPA_Create(10)) ? S_OK:E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        // check for the folders type - eg. we have folders

        if (fIncludeFolder)
        {
            IXMLDOMNode *pdn;
            hr = _pdocManifest->selectSingleNode(XPATH_FILESROOT, &pdn);
            if (hr == S_OK)
            {
                IXMLDOMElement *pdel;
                hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
                if (SUCCEEDED(hr))
                {
                    VARIANT var;                    
                    if (pdel->getAttribute(ATTRIBUTE_HASFOLDERS, &var) == S_OK)
                    {
                        if ((var.vt == VT_BOOL) && (var.boolVal == VARIANT_TRUE))
                        {
                            hr = _AddExtenisonToList(*phdpa, TEXT("Folder"));
                        }
                        VariantClear(&var);    
                    }
                    pdel->Release();
                }
                pdn->Release();
            }
        }

        // walk the file nodes building the extension list for us            

        IXMLDOMNodeList *pnl;
        hr = _pdocManifest->selectNodes(XPATH_ALLFILESTOUPLOAD, &pnl);
        if (hr == S_OK)
        {
            long cSelection;
            hr = pnl->get_length(&cSelection);
            for (long lNode = 0; SUCCEEDED(hr) && (lNode != cSelection); lNode++)
            {
                IXMLDOMNode *pdn;
                hr = pnl->get_item(lNode, &pdn);
                if (SUCCEEDED(hr))
                {
                    TCHAR szBuffer[MAX_PATH];
                    hr = GetStrFromAttribute(pdn, ATTRIBUTE_EXTENSION, szBuffer, ARRAYSIZE(szBuffer));
                    if (SUCCEEDED(hr))
                    {
                        hr = _AddExtenisonToList(*phdpa, szBuffer);
                    }
                    pdn->Release();
                }
            }
            pnl->Release();
        }

        // clean up the type DPA if we failed....

        if (FAILED(hr))
        {
            DPA_DestroyCallback(*phdpa, s_FreeStringProc, 0);
            *phdpa = NULL;
        }
    }
    return hr;
}


// initialize the property bag we want to give to the site so that
// they can display the correct HTML and direct the user in the 
// right direction.

HRESULT CPublishingWizard::_InitPropertyBag(LPCTSTR pszURL)
{
    HRESULT hr = S_OK;

    // lets initialize the wizard object so that we show the correct
    // pages, to determine this we need to 

    if (pszURL)
        hr = _pwwe->SetInitialURL(pszURL);

    // now compile a list of the unique types, this will be placed into the
    // property bag.  at this time we can also determine if there
    // are any images in our list, and therefore if we should prompt accordingly.

    _fOfferResize = FALSE;              // no resize

    ATOMICRELEASE(_ppb);
    hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &_ppb));
    if (SUCCEEDED(hr))
    {
        INT cExtensions = 0;

        // get the list of unique extensions and put those into the
        // property bag for the site to query - this should be removed in time and
        // we should have the site favor the file Manifest

        HDPA hdpa;
        hr = _GetUniqueTypeList(TRUE, &hdpa);
        if (SUCCEEDED(hr))
        {
            for (int i = 0; (i < DPA_GetPtrCount(hdpa)) && (SUCCEEDED(hr)); i++)
            {
                LPCTSTR pszExtension = (LPCTSTR)DPA_GetPtr(hdpa, i);
                if (pszExtension)
                {
                    if (!(_dwFlags & SHPWHF_NORECOMPRESS))
                        _fOfferResize = (_fOfferResize || PathIsImage(pszExtension));

                    TCHAR szProperty[255];
                    wnsprintf(szProperty, ARRAYSIZE(szProperty), PROPERTY_EXTENSION TEXT("%d"), PROPERTY_EXTENSION, i);

                    hr = SHPropertyBag_WriteStr(_ppb, szProperty, pszExtension);
                    if (SUCCEEDED(hr))
                    {
                        cExtensions++;
                    }
                }
            }
            DPA_DestroyCallback(hdpa, s_FreeStringProc, 0);
        }

        // initialize property bag with UI elements (ignoring the error from above, just won't have an
        // extension list to present)

        SHPropertyBag_WriteInt(_ppb, PROPERTY_EXTENSIONCOUNT, cExtensions);

        // we should always have a manifest object, therefore lets put it into the
        // property bag so that the site can extract it.

        IXMLDOMDocument *pdocManifest;
        hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &pdocManifest));
        if (SUCCEEDED(hr))
        {
            VARIANT varCurManifest = { VT_DISPATCH };
            hr = _pdocManifest->QueryInterface(IID_PPV_ARG(IDispatch, &varCurManifest.pdispVal));
            if (SUCCEEDED(hr))
            {
                // load the manifest into the new document that we have.
                VARIANT_BOOL fSuccess;
                hr = pdocManifest->load(varCurManifest, &fSuccess);
                if ((fSuccess == VARIANT_TRUE) && (hr == S_OK))
                {
                    hr = s_SetPropertyFromDisp(_ppb, PROPERTY_TRANSFERMANIFEST, pdocManifest);
                }
                VariantClear(&varCurManifest);
            }
        }
    }

    return hr;
}


// handle building the file manifest from the IDataObject, this consists of walking the list of
// files and putting together a 

class CPubWizardWalkCB : public INamespaceWalkCB
{
public:
    CPubWizardWalkCB(IXMLDOMDocument *pdocManifest);
    ~CPubWizardWalkCB();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

private:
    LONG _cRef;                                 // object lifetime count

    TCHAR _szWalkPath[MAX_PATH];                // path of the folder we are walking
    INT _idFile;                                // id of file we have walked    
    IXMLDOMDocument *_pdocManifest;             // manifest we are populating

    void _AddImageMetaData(IShellFolder2 *psf2, LPCITEMIDLIST pidl, IXMLDOMElement *pdel);
};

CPubWizardWalkCB::CPubWizardWalkCB(IXMLDOMDocument *pdocManifest) :
    _cRef(1), _pdocManifest(pdocManifest)
{
    _pdocManifest->AddRef();
    _szWalkPath[0] = TEXT('\0');                // no path yet.
}

CPubWizardWalkCB::~CPubWizardWalkCB()
{
    _pdocManifest->Release();
}


// IUnknown

ULONG CPubWizardWalkCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPubWizardWalkCB::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPubWizardWalkCB::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPubWizardWalkCB, INamespaceWalkCB),    // IID_INamespaceWalkCB
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


void CPubWizardWalkCB::_AddImageMetaData(IShellFolder2 *psf2, LPCITEMIDLIST pidl, IXMLDOMElement *pdel)
{
    struct
    {
        LPWSTR pszID;
        const SHCOLUMNID *pscid;
    } 
    _aMetaData[] = 
    {
        {L"cx", &SCID_ImageCX},
        {L"cy", &SCID_ImageCY},
    };

// eventually break this into a helper function, or read this from the info tip

    for (int i = 0; i < ARRAYSIZE(_aMetaData); i++)
    {
        VARIANT var = {0};
        HRESULT hr = psf2->GetDetailsEx(pidl, _aMetaData[i].pscid, &var);
        if (hr == S_OK)
        {
            IXMLDOMElement *pdelProperty;
            hr = CreateAndAppendElement(_pdocManifest, pdel, ELEMENT_IMAGEDATA, &var, &pdelProperty);
            if (SUCCEEDED(hr))
            {
                hr = SetAttributeFromStr(pdelProperty, ATTRIBUTE_ID, _aMetaData[i].pszID);
                pdelProperty->Release();
            }
            VariantClear(&var);
        }
    }
}


// INamepsaceWalkCB

HRESULT CPubWizardWalkCB::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    IXMLDOMNode *pdn;
    HRESULT hr = _pdocManifest->selectSingleNode(XPATH_FILESROOT, &pdn);
    if (hr == S_OK)
    {
        IXMLDOMElement *pdel;
        hr = _pdocManifest->createElement(ELEMENT_FILE, &pdel);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuffer[MAX_PATH];
            VARIANT var;

            // pass out the unique IDs for each of the elements in the tree
            var.vt = VT_I4;
            var.lVal = _idFile++;
            pdel->setAttribute(ATTRIBUTE_ID, var);
            
            // must be able to get the path for the item so that we can 
            hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szBuffer, ARRAYSIZE(szBuffer));
            if (SUCCEEDED(hr))
            {
                // source path
                hr = SetAttributeFromStr(pdel, ATTRIBUTE_SOURCE, szBuffer);

                // extension = (extension to file)
                hr = SetAttributeFromStr(pdel, ATTRIBUTE_EXTENSION, PathFindExtension(szBuffer));

                // lets put the content type
                TCHAR szContentType[MAX_PATH];
                DWORD cch = ARRAYSIZE(szContentType);
                if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, szBuffer, NULL, szContentType, &cch)))
                {
                    hr = SetAttributeFromStr(pdel, ATTRIBUTE_CONTENTTYPE, szContentType);
                }
            }

            // put the proposed destination into the node
            hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING|SHGDN_INFOLDER, szBuffer, ARRAYSIZE(szBuffer));
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];
                PathCombine(szPath, _szWalkPath, szBuffer);
                hr = SetAttributeFromStr(pdel, ATTRIBUTE_DESTINATION, szBuffer);
            }

            // handle those properties we can get from the shell folder via GetDetailsEx 
            IShellFolder2 *psf2;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                // push the size into the attribute list for the item
                if (SUCCEEDED(psf2->GetDetailsEx(pidl, &SCID_SIZE, &var)))
                {
                    pdel->setAttribute(ATTRIBUTE_SIZE, var);
                    VariantClear(&var);
                }

                // lets inject the meta data
                IXMLDOMElement *pdelMetaData;
                hr = CreateAndAppendElement(_pdocManifest, pdel, ELEMENT_METADATA, NULL, &pdelMetaData);
                if (SUCCEEDED(hr))
                {
                    _AddImageMetaData(psf2, pidl, pdelMetaData);
                    pdelMetaData->Release();
                }

                psf2->Release();
            }        

            // append the node to the list that we already have
            hr = pdn->appendChild(pdel, NULL);
            pdel->Release();
        }
        pdn->Release();
    }
    return S_OK;                            
}

HRESULT CPubWizardWalkCB::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    // build the name of the folder we have entered.

    TCHAR szBuffer[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING|SHGDN_INFOLDER|SHGDN_FORADDRESSBAR, szBuffer, ARRAYSIZE(szBuffer))))
    {
        PathAppend(_szWalkPath, szBuffer);
    }
    
    // lets update the files root to indicate that we are going to be using folders.

    IXMLDOMNode *pdn;
    HRESULT hr = _pdocManifest->selectSingleNode(XPATH_FILESROOT, &pdn);
    if (hr == S_OK)
    {
        IXMLDOMElement *pdel;
        hr = pdn->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdel));
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            var.vt = VT_BOOL;
            var.boolVal = VARIANT_TRUE;
            hr = pdel->setAttribute(ATTRIBUTE_HASFOLDERS, var);
            pdel->Release();
        }
        pdn->Release();
    }

    // now update the folders list with the new folder that we have just entered, first
    // try to find the folder list, if not found then create it.

    IXMLDOMNode *pdnFolders;
    hr = _pdocManifest->selectSingleNode(XPATH_FOLDERSROOT, &pdnFolders);
    if (hr == S_FALSE)
    {
        IXMLDOMNode *pdnRoot;
        hr = _pdocManifest->selectSingleNode(XPATH_MANIFEST, &pdnRoot);
        if (hr == S_OK)
        {
            IXMLDOMElement *pdelRoot;
            hr = pdnRoot->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdelRoot));
            if (SUCCEEDED(hr))
            {
                IXMLDOMElement *pdelFolders;
                hr = CreateAndAppendElement(_pdocManifest, pdelRoot, ELEMENT_FOLDERS, NULL, &pdelFolders);
                if (SUCCEEDED(hr))
                {
                    hr = pdelFolders->QueryInterface(IID_PPV_ARG(IXMLDOMNode, &pdnFolders));
                    pdelFolders->Release();
                }
                pdelRoot->Release();
            }
            pdnRoot->Release();
        }
    }    

    // assuming we now have the folder list, lets now create a new element for this folder.

    if (SUCCEEDED(hr) && pdnFolders)
    {
        IXMLDOMElement *pdelFolder;
        hr = _pdocManifest->createElement(ELEMENT_FOLDER, &pdelFolder);
        if (SUCCEEDED(hr))
        {
            hr = SetAttributeFromStr(pdelFolder, ATTRIBUTE_DESTINATION, _szWalkPath);
            if (SUCCEEDED(hr))
            {
                hr = pdnFolders->appendChild(pdelFolder, NULL);
            }
            pdelFolder->Release();
        }
    }

    return S_OK;                            // always succeed so we can transfer folders
}

HRESULT CPubWizardWalkCB::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    PathRemoveFileSpec(_szWalkPath);
    return S_OK;
}


// construct the manifest based on the document we have

HRESULT CPublishingWizard::_AddFilesToManifest(IXMLDOMDocument *pdocManifest)
{
    HRESULT hr = S_OK;
    if (_pdo || _pdoSelection)
    {
        CWaitCursor cur;        // might take some time

        INamespaceWalk *pnsw;
        hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
        if (SUCCEEDED(hr))
        {
            InitClipboardFormats();

            CPubWizardWalkCB *pwcb = new CPubWizardWalkCB(pdocManifest);
            if (pwcb)
            {
                hr = pnsw->Walk(_pdoSelection ? _pdoSelection:_pdo, NSWF_NONE_IMPLIES_ALL, 0, SAFECAST(pwcb, INamespaceWalkCB *));
                if (SUCCEEDED(hr))
                {
                    hr = pnsw->GetIDArrayResult(&_cItems, &_aItems);
                }
                pwcb->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            pnsw->Release();
        }
    }
    return hr;
}

HRESULT CPublishingWizard::_BuildTransferManifest()
{
    _FreeTransferManifest();

    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &_pdocManifest));
    if (SUCCEEDED(hr))
    {
        IXMLDOMElement *pdelDoc;
        hr = CreateElement(_pdocManifest, ELEMENT_TRANSFERMANIFEST, NULL, &pdelDoc);
        if (SUCCEEDED(hr))
        {
            hr = _pdocManifest->putref_documentElement(pdelDoc);
            if (SUCCEEDED(hr))
            {
                hr = CreateAndAppendElement(_pdocManifest, pdelDoc, ELEMENT_FILES, NULL, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = _AddFilesToManifest(_pdocManifest);
                }
            }
            pdelDoc->Release();
        }
    }

    _fRecomputeManifest = FALSE;        // the manifest has been recomputed, therefore we don't need to this again.
    _fRepopulateProviders = TRUE;       // the provider list may have changed b/c the manifest changed.

    return hr;
}

void CPublishingWizard::_FreeTransferManifest()
{
    ATOMICRELEASE(_pdocManifest);
    if (_aItems)
    {
        FreeIDListArray(_aItems, _cItems);
        _aItems = NULL;
        _cItems = 0;
    }
}



// Advanced location dialog, including the browse button....

typedef struct
{
    LPTSTR pszPath;
    IDataObject *pdo;
} BROWSEINIT;

int _BrowseCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    BROWSEINIT *pbi = (BROWSEINIT *)lpData;
    switch (uMsg)
    {
        case BFFM_INITIALIZED:
        {
            LPTSTR pszPath = pbi->pszPath;
            if (pszPath && pszPath[0])
            {
                int i = lstrlen(pszPath) - 1;
                if ((pszPath[i] == TEXT('\\')) || (pszPath[i] == TEXT('/')))
                {
                    pszPath[i] = 0;
                }   
                SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM) TRUE, (LPARAM) (LPTSTR)pszPath);
            }
            else
            {
                LPITEMIDLIST pidl;
                HRESULT hr = SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidl);
                if (SUCCEEDED(hr))
                {
                    SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)FALSE, (LPARAM)((LPTSTR)pidl));
                    ILFree(pidl);
                }
            }
            break;
        }

        case BFFM_SELCHANGED:
        {
            BOOL fEnableOK = FALSE;
            LPCITEMIDLIST pidl = (LPCITEMIDLIST)lParam;

            // if we have a IDataObject then check to see if we can drop it onto the
            // destination we are given.  this is used by the publishing process
            // to ensure that we enable/disable the OK.

            if (pbi->pdo)
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
                {
                    IDropTarget *pdt;
                    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_PPV_ARG_NULL(IDropTarget, &pdt))))
                    {
                        POINTL ptl = {0};
                        DWORD dwEffect = DROPEFFECT_COPY;
                        if (SUCCEEDED(pdt->DragEnter(pbi->pdo, 0, ptl, &dwEffect)))
                        {
                            fEnableOK = (dwEffect & DROPEFFECT_COPY);
                            pdt->DragLeave();
                        }
                        pdt->Release();
                    }
                    psf->Release();
                }
            }
            else
            {
                ULONG rgInfo = SFGAO_STORAGE;
                if (SUCCEEDED(SHGetNameAndFlags(pidl, 0, NULL, 0, &rgInfo)))
                {
                    fEnableOK = (rgInfo & SFGAO_STORAGE);
                }
                else
                {
                    fEnableOK = TRUE;
                }
            }

            SendMessage(hwnd, BFFM_ENABLEOK, (WPARAM) 0, (LPARAM)fEnableOK);
            break;
        }
    }
    return 0;
}

void CPublishingWizard::_SetWaitCursor(BOOL bOn)
{
    if (bOn)
    {
        _hCursor = SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
    }
    else if (_hCursor)
    {
        SetCursor(_hCursor); 
        _hCursor = NULL; 
    }
}

// Publishing location pages

void CPublishingWizard::_ShowExampleTip(HWND hwnd)
{
    TCHAR szTitle[256], szExamples[256];
    LoadString(g_hinst, IDS_NETPLACE_EXAMPLES_TITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(g_hinst, IDS_NETPLACE_EXAMPLES, szExamples, ARRAYSIZE(szExamples));

    EDITBALLOONTIP ebt = {0};
    ebt.cbStruct = sizeof(ebt);
    ebt.pszTitle = szTitle;
    ebt.pszText = szExamples;

    SetFocus(GetDlgItem(hwnd, IDC_FOLDER_EDIT));         // set focus before the balloon

    HWND hwndEdit = (HWND)SendDlgItemMessage(hwnd, IDC_FOLDER_EDIT, CBEM_GETEDITCONTROL, 0, 0L);
    Edit_ShowBalloonTip(hwndEdit, &ebt);
}

void CPublishingWizard::_LocationChanged(HWND hwnd)
{
    if (_fValidating)
    {
        PropSheet_SetWizButtons(GetParent(hwnd), 0);
    }
    else
    {
        int cchLocation = FetchTextLength(hwnd, IDC_FOLDER_EDIT);
        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK|((cchLocation >0) ? PSWIZB_NEXT:0));
    }
}


// auto complete bits

#define SZ_REGKEY_AUTOCOMPLETE_TAB      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_AUTOCOMPLETE_TAB    TEXT("Always Use Tab")

#define REGSTR_PATH_AUTOCOMPLETE        TEXT("Software\\Microsoft\\windows\\CurrentVersion\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

#define BOOL_NOT_SET                    0x00000005

DWORD CPublishingWizard::_GetAutoCompleteFlags(DWORD dwFlags)
{
    DWORD dwACOptions = 0;

    if (!(SHACF_AUTOAPPEND_FORCE_OFF & dwFlags) &&
          ((SHACF_AUTOAPPEND_FORCE_ON & dwFlags) ||
            SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, FALSE)))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (!(SHACF_AUTOSUGGEST_FORCE_OFF & dwFlags) &&
          ((SHACF_AUTOSUGGEST_FORCE_ON & dwFlags) ||
            SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, TRUE)))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    if (SHACF_USETAB & dwFlags)
        dwACOptions |= ACO_USETAB;
    
    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 

    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;
    
    return dwACOptions;
}

HRESULT CPublishingWizard::_InitAutoComplete()
{
    HRESULT hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &_pac));
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ACLMulti, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &_punkACLMulti));
        if (SUCCEEDED(hr))
        {
            IObjMgr *pomMulti;
            hr = _punkACLMulti->QueryInterface(IID_PPV_ARG(IObjMgr, &pomMulti));
            if (SUCCEEDED(hr))
            {
                // add the file system auto complete object (for handling UNC's etc)

                IUnknown *punk;
                hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punk);
                    punk->Release();
                }

                // add the publishing wizard auto complete object (for handling HTTP etc)

                IUnknown *punkCustomACL;
                hr = CoCreateInstance(CLSID_ACLCustomMRU, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punkCustomACL));
                if (SUCCEEDED(hr))
                {
                    hr = punkCustomACL->QueryInterface(IID_PPV_ARG(IACLCustomMRU, &_pmru));
                    if (SUCCEEDED(hr))
                    {
                        TCHAR szKey[MAX_PATH];
                        wnsprintf(szKey, ARRAYSIZE(szKey), (SZ_REGKEY_PUBWIZ TEXT("\\%s\\") SZ_REGVAL_MRU), _szProviderScope);

                        hr = _pmru->Initialize(szKey, 26);
                        if (SUCCEEDED(hr))
                        {
                            hr = pomMulti->Append(punkCustomACL);
                        }
                    }
                    punkCustomACL->Release();
                }
                
                pomMulti->Release();
            }
        }
    }

    return hr;
}


// handle MRU of places you can publish to

void CPublishingWizard::_InitLocation(HWND hwnd)
{
    // lets initialize the auto complete list of folders that we have
    HRESULT hr = _InitAutoComplete();
    if (SUCCEEDED(hr))
    {
        IEnumString *penum;
        hr = _pmru->QueryInterface(IID_PPV_ARG(IEnumString, &penum));
        if (SUCCEEDED(hr))
        {
            penum->Reset();           // reset the enumerator ready for us to populate the list

            LPOLESTR pszEntry;
            ULONG ulFetched;

            while ((penum->Next(1, &pszEntry, &ulFetched) == S_OK) && ulFetched == 1)
            {
                COMBOBOXEXITEM cbei = {0};
                cbei.mask = CBEIF_TEXT;
                cbei.pszText = pszEntry;
                SendDlgItemMessage(hwnd, IDC_FOLDER_EDIT, CBEM_INSERTITEM, 0, (LPARAM)&cbei);

                CoTaskMemFree(pszEntry);
            }
            penum->Release();
        }

        // enable auto complete for this control.
        HWND hwndEdit = (HWND)SendDlgItemMessage(hwnd, IDC_FOLDER_EDIT, CBEM_GETEDITCONTROL, 0, 0L);
        _pac->Init(hwndEdit, _punkACLMulti, NULL, NULL);
        _pac->SetOptions(_GetAutoCompleteFlags(0));

        // limit text on the edit control
        ComboBox_LimitText(GetDlgItem(hwnd, IDC_FOLDER_EDIT), INTERNET_MAX_URL_LENGTH);

        // if the policy says no map drive etc, then lets remove it
        BOOL fHide = SHRestricted(REST_NOENTIRENETWORK) || SHRestricted(REST_NONETCONNECTDISCONNECT);
        ShowWindow(GetDlgItem(hwnd, IDC_BROWSE), fHide ? SW_HIDE:SW_SHOW);
    }
}


// validation thread, this is performed on a background thread to compute if
// the resource is valid.

#define PWM_VALIDATEDONE (WM_APP)  // -> validate done (HRESULT passed in LPARAM)

typedef struct
{
    HWND hwnd;                                      // parent HWND
    BOOL fAllowWebFolders;                          // allow web folders during validation
    TCHAR szFileTarget[INTERNET_MAX_URL_LENGTH];    // destination for file copy
} VALIDATETHREADDATA;

DWORD CALLBACK CPublishingWizard::s_ValidateThreadProc(void *pv)
{
    VALIDATETHREADDATA *pvtd = (VALIDATETHREADDATA*)pv;
    HRESULT hr = E_FAIL;

    // validate the site
    CNetworkPlace np;    
    hr = np.SetTarget(pvtd->hwnd, pvtd->szFileTarget, NPTF_VALIDATE | (pvtd->fAllowWebFolders ? NPTF_ALLOWWEBFOLDERS:0));
    np.SetTarget(NULL, NULL, 0);

    PostMessage(pvtd->hwnd, PWM_VALIDATEDONE, 0, (LPARAM)hr);
    LocalFree(pvtd);
    return 0;
}

void CPublishingWizard::_TryToValidateDestination(HWND hwnd)
{
    TCHAR szDestination[INTERNET_MAX_URL_LENGTH];
    FetchText(hwnd, IDC_FOLDER_EDIT, szDestination, ARRAYSIZE(szDestination));

    // lets walk the list source files and try to match to the destination we have.
    // we don't want to let source be the destination

    BOOL fHitItem = FALSE;    
    LPITEMIDLIST pidl = ILCreateFromPath(szDestination);
    if (pidl)
    {
        BOOL fUNC = PathIsUNC(szDestination); //only if destination is UNC Path do we need to check if source is a mapped drive
        for (UINT iItem = 0; (iItem != _cItems) && !fHitItem; iItem++)
        {
            LPITEMIDLIST pidlSrcDir = ILClone(_aItems[iItem]);
            if (pidlSrcDir)
            {
                ILRemoveLastID(pidlSrcDir);
                fHitItem = ILIsEqual(pidlSrcDir, pidl) || (!ILIsEmpty(pidlSrcDir) && ILIsParent(pidlSrcDir, pidl, FALSE));
                if (!fHitItem && fUNC)
                {
                    WCHAR szPath[MAX_PATH];
                    if (SUCCEEDED(SHGetPathFromIDList(pidlSrcDir, szPath)) && !PathIsUNC(szPath))
                    {
                        WCHAR szSource[MAX_PATH];
                        DWORD cchSource = ARRAYSIZE(szSource);
                        DWORD dwType = SHWNetGetConnection(szPath, szSource, &cchSource);
                        if ((dwType == NO_ERROR) || (dwType == ERROR_CONNECTION_UNAVAIL))
                        {
                            fHitItem = (StrCmpNI(szSource, szDestination, lstrlen(szSource)) == 0);
                        }
                    }
                }
                ILFree(pidlSrcDir);
            }
        }
        ILFree(pidl);
    }

    // if we didn't get a hit that way then lets spin up a thread which will do the
    // validation of the server and the connection - this is a lengthy operation
    // and will post a result to the window.

    if (!fHitItem)
    {
        VALIDATETHREADDATA *pvtd = (VALIDATETHREADDATA*)LocalAlloc(LPTR, sizeof(*pvtd));
        if (pvtd)
        {
            pvtd->hwnd = hwnd;
            pvtd->fAllowWebFolders = (_dwFlags & SHPWHF_VALIDATEVIAWEBFOLDERS) != 0;

            // fetch the user typed url
            StrCpy(pvtd->szFileTarget, szDestination);

            // we have the thread data read, so lets begin the validation
            // by creating the thread - our state is set to indicate we are in the
            // validate mode.

            _fValidating = TRUE;                        // we are going to begin validating
            _SetWaitCursor(TRUE);               

            if (!SHCreateThread(s_ValidateThreadProc, pvtd, CTF_INSIST | CTF_COINIT, NULL))
            {
                LocalFree(pvtd);

                _fValidating = FALSE;
                _SetWaitCursor(FALSE);
            }
        }
    }
    else
    {
        ShellMessageBox(g_hinst, hwnd, MAKEINTRESOURCE(IDS_PUB_SAMETARGET), NULL, MB_ICONEXCLAMATION | MB_OK);
        PostMessage(hwnd, PWM_VALIDATEDONE, 0, (LPARAM)E_FAIL);
    }

    // ensure the state of the controls reflects what we are trying to do.

    _LocationChanged(hwnd);
    EnableWindow(GetDlgItem(hwnd, IDC_FOLDER_EDIT), !_fValidating);
    EnableWindow(GetDlgItem(hwnd, IDC_BROWSE), !_fValidating);
}


// this is the dialog proc for the location dialog.

INT_PTR CPublishingWizard::_LocationDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            _MapDlgItemText(hwnd, IDC_PUB_LOCATIONCAPTION, L"wp:location", L"locationcaption");
            _InitLocation(hwnd);
            return TRUE;
        }

        case WM_DESTROY:
        {
            ATOMICRELEASE(_pac);
            ATOMICRELEASE(_punkACLMulti);
            ATOMICRELEASE(_pmru);
            return FALSE;
        }
        
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_BROWSE:
                {
                    LPITEMIDLIST pidl;
                    if (SHGetSpecialFolderLocation(hwnd, CSIDL_NETWORK, &pidl) == S_OK)
                    {
                        TCHAR szPath[MAX_PATH];
                        FetchText(hwnd, IDC_FOLDER_EDIT, szPath, ARRAYSIZE(szPath));
                        
                        TCHAR szTitle[MAX_PATH];
                        if (FAILED(_LoadMappedString(L"wp:location", L"browsecaption", szTitle, ARRAYSIZE(szTitle))))
                        {
                            LoadString(g_hinst, IDS_PUB_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
                        }

                        // lets initialize our state structure for the browse dialog.  based on this we can then
                        // attempt to select a network place.  from here we will also pass the IDataObject
                        // we have (there may not be one of course)

                        BROWSEINIT binit = {szPath};      

                        if (_pdoSelection)
                            _pdoSelection->QueryInterface(IID_PPV_ARG(IDataObject, &binit.pdo));
                        else if (_pdo)
                            _pdo->QueryInterface(IID_PPV_ARG(IDataObject, &binit.pdo));

                        BROWSEINFO bi = {0};
                        bi.hwndOwner = hwnd;
                        bi.pidlRoot = pidl;
                        bi.lpszTitle = szTitle;
                        bi.ulFlags = BIF_NEWDIALOGSTYLE;
                        bi.lpfn = _BrowseCallback;
                        bi.lParam = (LPARAM)&binit;

                        LPITEMIDLIST pidlReturned = SHBrowseForFolder(&bi);
                        if (pidlReturned)
                        {
                            if (SUCCEEDED(SHGetNameAndFlags(pidlReturned, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
                                SetDlgItemText(hwnd, IDC_FOLDER_EDIT, szPath);

                            ILFree(pidlReturned);
                        }

                        if (binit.pdo)
                            binit.pdo->Release();

                        ILFree(pidl);
                    }
                    return TRUE;
                }

                case IDC_FOLDER_EDIT:
                    if (HIWORD(wParam) == CBN_EDITCHANGE)
                    {
                        _LocationChanged(hwnd);
                    }
                    return TRUE;
            }
            break;
        }

        case WM_SETCURSOR:
            if (_fValidating)
            {
                SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
                return TRUE;
            }
            return FALSE;

        case PWM_VALIDATEDONE:
        {
            _fValidating = FALSE;
            _LocationChanged(hwnd);
            _SetWaitCursor(FALSE);

            HRESULT hr = _InitPropertyBag(NULL);
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[MAX_PATH], szURL[INTERNET_MAX_URL_LENGTH];
                FetchText(hwnd, IDC_FOLDER_EDIT, szURL, ARRAYSIZE(szURL));
               
                // push the destination site into the property bag, and then initialize
                // our site with the right information
                
                IXMLDOMDocument *pdocManifest;
                hr = GetTransferManifest(NULL, &pdocManifest);
                if (SUCCEEDED(hr))
                {
                    IXMLDOMNode *pdnRoot;
                    hr = pdocManifest->selectSingleNode(XPATH_MANIFEST, &pdnRoot);
                    if (hr == S_OK)
                    {
                        IXMLDOMElement *pdelRoot;
                        hr = pdnRoot->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pdelRoot));
                        if (SUCCEEDED(hr))
                        {
                            IXMLDOMElement *pdelUploadInfo;
                            hr = CreateAndAppendElement(_pdocManifest, pdelRoot, ELEMENT_UPLOADINFO, NULL, &pdelUploadInfo);
                            if (SUCCEEDED(hr))
                            {
                                IXMLDOMElement *pdelTarget;
                                hr = CreateAndAppendElement(_pdocManifest, pdelUploadInfo, ELEMENT_TARGET, NULL, &pdelTarget);
                                if (SUCCEEDED(hr))
                                {
                                    hr = SetAttributeFromStr(pdelTarget, ATTRIBUTE_HREF, szURL);
                                    pdelTarget->Release();
                                }
                                pdelUploadInfo->Release();
                            }
                            pdelRoot->Release();
                        }
                        pdnRoot->Release();
                    }
                    pdocManifest->Release();
                }

                // lets now process the result

                hr = (HRESULT)lParam;
                if (S_OK == hr)
                {
                    BOOL fGotoNextPage = TRUE;

                    // fake a return so auto complete can do its thing
                    SendMessage(GetDlgItem(hwnd, IDC_FOLDER_EDIT), WM_KEYDOWN, VK_RETURN, 0x1c0001);

                    // add the string to the MRU
                    if (_pmru)
                        _pmru->AddMRUString(szURL);

                    // lets sniff the string they entered, if its a URL and its FTP
                    // then we must special case the password in the URL, otherwise
                    // we jump directly to the friendly name handling.

                    URL_COMPONENTS urlComps = {0};
                    urlComps.dwStructSize = sizeof(urlComps);
                    urlComps.lpszScheme = szBuffer;
                    urlComps.dwSchemeLength = ARRAYSIZE(szBuffer);

                    if (InternetCrackUrl(szURL, 0, ICU_DECODE, &urlComps) 
                                    && (INTERNET_SCHEME_FTP == urlComps.nScheme))
                    {
                        URL_COMPONENTS urlComps = {0};
                        urlComps.dwStructSize = sizeof(URL_COMPONENTS);
                        urlComps.nScheme = INTERNET_SCHEME_FTP;
                        urlComps.lpszUserName = szBuffer;
                        urlComps.dwUserNameLength = ARRAYSIZE(szBuffer);

                        // if the user specified a user name, if not then goto the FTP user
                        // page (we known its a FTP location)

                        if (!InternetCrackUrl(szURL, 0, 0, &urlComps) || !szBuffer[0])
                        {
                            _WizardNext(hwnd, WIZPAGE_FTPUSER);
                            fGotoNextPage = FALSE;
                        }
                    }

                    if (fGotoNextPage)
                        _WizardNext(hwnd, WIZPAGE_FRIENDLYNAME);
                }
            }

            EnableWindow(GetDlgItem(hwnd, IDC_FOLDER_EDIT), TRUE);
            EnableWindow(GetDlgItem(hwnd, IDC_BROWSE), TRUE);

            if (FAILED(((HRESULT)lParam)))
                _ShowExampleTip(hwnd);

            return TRUE;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    _fShownCustomLocation = TRUE;           // so we navigate back to this page
                    _fShownUserName = FALSE;
                    _LocationChanged(hwnd);
                    return TRUE;

                case PSN_WIZBACK:
                    return _WizardNext(hwnd, WIZPAGE_PROVIDERS);
        
                case PSN_WIZNEXT:
                    _TryToValidateDestination(hwnd);
                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;

                case NM_CLICK:
                case NM_RETURN:
                {
                    if (pnmh->idFrom == IDC_EXAMPLESLINK)
                    {
                        _ShowExampleTip(hwnd);
                        return TRUE;
                    }
                }
            }
            break;
        }
    }
    return FALSE;
}


// FTP login dialog - handle the messages for this

void CPublishingWizard::_UserNameChanged(HWND hwnd)
{
    BOOL fAnonymousLogin = IsDlgButtonChecked(hwnd, IDC_PASSWORD_ANONYMOUS);

    ShowWindow(GetDlgItem(hwnd, IDC_USER), (fAnonymousLogin ? SW_HIDE : SW_SHOW));
    ShowWindow(GetDlgItem(hwnd, IDC_USERNAME_LABEL), (fAnonymousLogin ? SW_HIDE : SW_SHOW));
    ShowWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME), (fAnonymousLogin ? SW_SHOW : SW_HIDE));
    ShowWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME_LABEL), (fAnonymousLogin ? SW_SHOW : SW_HIDE));

    // Hide the "You will be prompted for the password when you connect to the FTP server" text on anonymous
    EnableWindow(GetDlgItem(hwnd, IDC_PWD_PROMPT), !fAnonymousLogin);
    ShowWindow(GetDlgItem(hwnd, IDC_PWD_PROMPT), (fAnonymousLogin ? SW_HIDE : SW_SHOW));
}

INT_PTR CPublishingWizard::_UserNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            CheckDlgButton(hwnd, IDC_PASSWORD_ANONYMOUS, BST_CHECKED);
            EnableWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_ANON_USERNAME_LABEL), FALSE);
            SetWindowText(GetDlgItem(hwnd, IDC_ANON_USERNAME), TEXT("Anonymous"));
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_PASSWORD_ANONYMOUS:
                    _UserNameChanged(hwnd);
                    return TRUE;
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {
                    _fShownUserName = TRUE;     // so we can navigate back properly
                    _UserNameChanged(hwnd);
                    return TRUE;
                }

                case PSN_WIZBACK:
                    return _WizardNext(hwnd, WIZPAGE_LOCATION);
        
                case PSN_WIZNEXT:
                {
                    // if we can get a user name then lets push it into the property
                    // bag, a NULL string == anonymous logon

                    TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH] = {0};
                    if (!IsDlgButtonChecked(hwnd, IDC_PASSWORD_ANONYMOUS))
                    {
                        FetchText(hwnd, IDC_USER, szUserName, ARRAYSIZE(szUserName));
                    }
            
                    // get the sites property bag, and persist the string into it,
                    // if we have done that then we can go to the next page.

                    IXMLDOMDocument *pdocManifest;
                    HRESULT hr = GetTransferManifest(NULL, &pdocManifest);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode *pdn;
                        hr = pdocManifest->selectSingleNode(XPATH_UPLOADTARGET, &pdn);
                        if (hr == S_OK)
                        {
                            hr = SetAttributeFromStr(pdn, ATTRIBUTE_USERNAME, szUserName);
                            pdn->Release();
                        }
                        pdocManifest->Release();
                    }

                    return _WizardNext(hwnd, WIZPAGE_FRIENDLYNAME);
                }
            }
            break;
        }
    }
    return FALSE;
}


// set the friendly name for the web place - if it doesn't already exist

void CPublishingWizard::_FriendlyNameChanged(HWND hwnd)
{
    int cchLocation = FetchTextLength(hwnd, IDC_NETPLNAME_EDIT);
    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK |((cchLocation >0) ? PSWIZB_NEXT:0));
}

INT_PTR CPublishingWizard::_FriendlyNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        // lets get the limit information for the nethood folder

        case WM_INITDIALOG:
        {
            LPITEMIDLIST pidlNetHood;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_NETHOOD, &pidlNetHood)))
            {
                IShellFolder *psf;
                if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlNetHood, &psf))))
                {
                    SHLimitInputEdit(GetDlgItem(hwnd, IDC_NETPLNAME_EDIT), psf);
                    psf->Release();
                }
                ILFree(pidlNetHood);
            }
            _FriendlyNameChanged(hwnd);
            break;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_NETPLNAME_EDIT:
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        _FriendlyNameChanged(hwnd);
                        return TRUE;
                    }
                    break;
                }
            }
            break;
        }

        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                {     
                    // read from the manifest the target URL that we are going to be putting the
                    // files to, from this we can compute the friendly name information.

                    IXMLDOMDocument *pdocManifest;
                    HRESULT hr = GetTransferManifest(NULL, &pdocManifest);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode *pdn;
                        hr = pdocManifest->selectSingleNode(XPATH_UPLOADTARGET, &pdn);
                        if (hr == S_OK)
                        {
                            TCHAR szURL[INTERNET_MAX_URL_LENGTH];            
                            hr = GetStrFromAttribute(pdn, ATTRIBUTE_HREF, szURL, ARRAYSIZE(szURL));
                            if (SUCCEEDED(hr))
                            {
                                _npCustom.SetTarget(hwnd, szURL, (_dwFlags & SHPWHF_VALIDATEVIAWEBFOLDERS) ? NPTF_ALLOWWEBFOLDERS:0);

                                TCHAR szUserName[INTERNET_MAX_USER_NAME_LENGTH];
                                hr = GetStrFromAttribute(pdn, ATTRIBUTE_USERNAME, szUserName, ARRAYSIZE(szUserName));
                                if (SUCCEEDED(hr))
                                    _npCustom.SetLoginInfo(szUserName, NULL);                        

                                TCHAR szBuffer[MAX_PATH + INTERNET_MAX_URL_LENGTH];
                                if (FormatMessageString(IDS_COMPLETION_STATIC, szBuffer, ARRAYSIZE(szBuffer), szURL))
                                {
                                    SetDlgItemText(hwnd, IDC_COMPLETION_STATIC, szBuffer);
                                }

                                // Create a default name and display it
                                hr = _npCustom.GetName(szBuffer, ARRAYSIZE(szBuffer));
                                SetDlgItemText(hwnd, IDC_NETPLNAME_EDIT, SUCCEEDED(hr) ? szBuffer:TEXT(""));

                                // Update the button state for the page etc.
                                _FriendlyNameChanged(hwnd);
                            }                                    
                            pdn->Release();
                        }
                    }
                    return TRUE;
                }

                case PSN_WIZBACK:
                    _WizardNext(hwnd, _fShownUserName ? WIZPAGE_FTPUSER:WIZPAGE_LOCATION);
                    return TRUE;

                case PSN_WIZNEXT:
                {
                    TCHAR szFriendlyName[MAX_PATH];
                    FetchText(hwnd, IDC_NETPLNAME_EDIT, szFriendlyName, ARRAYSIZE(szFriendlyName));

                    // set the name of the new place, if this fails then the name is already taken
                    // and UI will have been displayed saying so, and they responded with a 
                    // NO to the overwrite prompt.

                    HRESULT hr = _npCustom.SetName(hwnd, szFriendlyName);
                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMDocument *pdocManifest;
                        HRESULT hr = GetTransferManifest(NULL, &pdocManifest);
                        if (SUCCEEDED(hr))
                        {
                            IXMLDOMNode *pdn;
                            hr = pdocManifest->selectSingleNode(XPATH_UPLOADINFO, &pdn);
                            if (hr == S_OK)
                            {
                                hr = SetAttributeFromStr(pdn, ATTRIBUTE_FRIENDLYNAME, szFriendlyName);
                                pdn->Release();
                            }
                            pdocManifest->Release();
                        }

                        // Clean up after our custom netplace now.
                        // This way everything works for webfolders when the outer ANP netplace
                        // creates the webfolder. DSheldon 387476
                        _npCustom.SetTarget(NULL, NULL, 0x0);

                        if (_pdo)
                        {
                            _WizardNext(hwnd, _fOfferResize ? WIZPAGE_RESIZE:WIZPAGE_COPYING);
                        }
                        else
                        {
                            IWizardSite *pws;
                            hr = _punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws));
                            if (SUCCEEDED(hr))
                            {
                                HPROPSHEETPAGE hpage;
                                hr = pws->GetNextPage(&hpage);
                                if (SUCCEEDED(hr))
                                {
                                    PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                }
                                pws->Release();
                            }
                        }
                    }                    

                    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                    return TRUE;
                }
            }
            break;
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

#define IDI_USR_USERS                   102
#define IDI_ADDNETPLACE                 107
#define IDI_USR_LOCALUSER_ICON          108
#define IDI_CERTIFICATES                111
#define IDI_USR_GROUP_ICON              112
#define IDI_USR_DOMAINUSER_ICON         110
#define IDI_WIZ_BULLET                  124
#define IDI_REQUIRECAD                  125
#define IDI_SECURITYCHECK               126

#define IDD_USR_FINDNETUSER_WIZARD_PAGE 111
#define IDD_USR_USERLIST_PAGE           105

#define IDB_MND_WATERMARK               100
#define IDB_USR_BANNER                  102
#define IDB_GETPP_DOTNET                103

#define IDD_MND_DLG                     106
#define IDD_MND_PAGE                    106
#define IDD_MND_PROGRESS_DLG            112
#define IDD_MND_CONNECTAS               124

#define IDD_USR_AUTOLOGON_DLG           113
#define IDD_USR_CHOOSEGROUP_PROP_PAGE   114
#define IDD_USR_USERNAME_PROP_PAGE      115
#define IDD_USR_SETPASSWORD_DLG         116
#define IDD_USR_SECURITYCHECK_DLG       117
#define IDD_USR_ADVANCED_PAGE           118

#define IDD_WIZ_NETPASSWORD             119

#define IDI_NOPROVIDERS                 200

#define IDC_CREDENTIALS                 512

#define IDC_WELCOME_STATIC              1000
#define IDC_WELCOME_TITLE               1000
#define IDC_USER_LIST                   1001
#define IDC_FOLDER_STATIC               1002
#define IDC_REMOVEUSER_BUTTON           1003
#define IDC_NETPLNAME_EDIT              1004
#define IDC_ADVANCED_BUTTON             1005
#define IDC_LOGGEDON_STATIC             1006
#define IDC_LOGGEDIN_STATIC             1007
#define IDC_FINDUSER_BUTTON             1008
#define IDC_CONFIRMPASSWORD             1009
#define IDC_USER                        1010
#define IDC_BROWSE                      1011
#define IDC_FULLNAME                    1012
#define IDC_PASSWORD                    1013
#define IDC_ADDUSER_BUTTON              1014
#define IDC_PWGROUP_STATIC              1015
#define IDC_SERVER_LIST                 1016
#define IDC_USERPROPERTIES_BUTTON       1017
#define IDC_PASSWORD_STATIC             1019
#define IDC_LOGON_RADIO1                1019
#define IDC_NOAUTOLOGON                 1019
#define IDC_LOGON_RADIO2                1020
#define IDC_AUTOLOGON                   1020
#define IDC_PASSWORD_BUTTON             1021
#define IDC_NETWORKED                   1021
#define IDC_AUTOLOGON_CHECK             1022
#define IDC_NOTNETWORKED                1022
#define IDC_DESCRIPTION                 1023
#define IDC_USERSLABEL                  1023
#define IDC_GROUPS                      1024
#define IDC_PASSWORDLABEL               1024
#define IDC_GROUPDESC                   1025
#define IDC_CONFIRMPASSWORDLABEL        1025
#define IDC_USERS                       1026
#define IDC_BROWSE_BUTTON               1027
#define IDC_DOMAIN                      1028
#define IDC_CANTRUNCPL_STATIC           1029
#define IDC_DOMAIN_STATIC               1030
#define IDC_USERLISTPAGE_ICON           1032
#define IDC_LISTTITLE_STATIC            1033
#define IDC_CURRENTUSER_ICON            1034
#define IDC_FOLDER                      1034
#define IDC_FOLDERBROWSE                1035
#define IDC_DRIVELETTER                 1036
#define IDC_RECONNECT                   1038
#define IDC_DIFFUSER                    1039
#define IDC_USER_STATIC                 1041
#define IDC_FINDINDSLINK                1044
#define IDC_CONNECTASLINK               1044
#define IDC_ADDPLACELINK                1045
#define IDC_ADVANCEDLINK                1046
#define IDC_CONNECTING                  1047
#define IDC_REQUIRECAD                  1048
#define IDC_POWERUSERS                  1050
#define IDC_ADDUSER                     1051
#define IDC_DONTADDUSER                 1052
#define IDC_OTHER                       1053
#define IDC_WHATACCESS                  1054
#define IDC_COMPLETE_TITLE              1055
#define IDC_EXAMPLESLINK                1056
#define IDC_FINISHSTATIC                1057
#define IDC_ERROR                       1059
#define IDC_ULISTPG_TEXT                1060
#define IDC_CERT_ICON                   1061
#define IDC_CERT_TEXT                   1062
#define IDC_BOOT_ICON                   1063
#define IDC_BOOT_TEXT                   1064
#define IDC_PROVIDERS                   1066
#define IDC_MANAGEPWD_BUTTON            1068
#define IDC_DRIVELIST                   1071
#define IDC_MYWEBDOCUMENTSLINK          1073
#define IDC_PRIVACYLINK                 1074
#define IDC_OTHEROPTIONS_LINK           1075

// add net place wizard

#define IDB_ANP_BANNER                  2000
#define IDB_ANP_WATERMARK               2001

#define IDD_ANP_WELCOME                 2000
#define IDD_ANP_DONE                    2001
#define IDD_ANP_FRIENDLYNAME            2002

#define IDC_ANP_SUCCESS                 2001

#define IDS_ANP_CAPTION                 2000
#define IDS_ANP_FRIENDLYNAME            2001
#define IDS_ANP_FRIENDLYNAME_SUB        2002

#define IDS_ANP_PROVIDER                2010
#define IDS_ANP_PROVIDER_SUB            2011
#define IDS_ANP_PROVIDER_CAP            2012

#define IDS_ANP_LOCATION                2013
#define IDS_ANP_LOCATION_SUB            2014
#define IDS_ANP_LOCATION_BROWSE         2016

#define IDS_ANP_OTHERNAME               2017
#define IDS_ANP_OTHERDESCRIPTION        2018

#define IDS_ANP_WELCOME_PROMPT          2020
#define IDS_ANP_WELCOME_DESC            2021

#define IDS_ANP_SUCCESS                 2030


// internet printing wizard

#define IDB_IPP_BANNER                  2100
#define IDB_IPP_WATERMARK               2101

#define IDD_IPP_WELCOME                 2100
#define IDD_IPP_DONE                    2101
#define IDD_IPP_COPY                    2102

#define IDS_IPP_CAPTION                 2100
#define IDS_IPP_WELCOME_PROMPT          2101
#define IDS_IPP_WELCOME_DESC            2102

#define IDS_IPP_COPY                    2110
#define IDS_IPP_COPY_SUB                2111

#define IDS_IPP_COMPLETED               2120
#define IDS_IPP_SUCCESS                 2121
#define IDS_IPP_FAILURE                 2122

#define IDS_IPP_PROVIDER                2123
#define IDS_IPP_PROVIDER_SUB            2124
#define IDS_IPP_PROVIDER_CAP            2125

#define IDS_IPP_CANCEL                  2126

#define IDS_IPP_PROVIDER_LABEL          2127

#define IDS_IPP_SELECTOR                2128
#define IDS_IPP_SELECTOR_SUB            2129
#define IDS_IPP_SELECTOR_FMT            2130

#define IDS_IPP_PROVIDER_DLOAD          2131

#define IDS_IPP_HASLINK                 2132

#define IDS_IPP_NOPROVIDER              2135
#define IDS_IPP_NOPROVIDERDESC          2136

#define IDS_WEBSVC_HEADER               2140

// publish to the web wizard

#define IDB_PUB_BANNER                  2200
#define IDB_PUB_WATERMARK               2201

#define IDD_PUB_WELCOME                 2200
#define IDD_PUB_DONE                    2201
#define IDD_PUB_COPY                    2202

#define IDS_PUB_CAPTION                 2200
#define IDS_PUB_WELCOME_PROMPT          2201
#define IDS_PUB_WELCOME_DESC            2202

#define IDS_PUB_COPY                    2210
#define IDS_PUB_COPY_SUB                2211

#define IDS_PUB_COMPLETED               2220
#define IDS_PUB_SUCCESS                 2221
#define IDS_PUB_FAILURE                 2222
#define IDS_PUB_CANCEL                  2223

#define IDS_PUB_HASLINK                 2224
#define IDS_PUB_HASNETPLACE             2225
#define IDS_PUB_HASFAVORITE             2226
#define IDS_PUB_HASNETPLACEANDFAVORITE  2227

#define IDS_PUB_SELECTOR                2231
#define IDS_PUB_SELECTOR_SUB            2232
#define IDS_PUB_SELECTOR_FMT            2233

#define IDS_PUB_NOPROVIDER              2235
#define IDS_PUB_NOPROVIDERDESC          2236



// other controls etc

#define IDC_FOLDER_EDIT                 4199
#define IDC_SELECTFOLDER_STATIC         4211
#define IDC_SELECTFOLDER_LIST           4213
#define IDC_COMPLETION_STATIC           4221
#define IDC_COMPLETION_RECONNECT_CHECK  4223
#define IDC_COMPLETION_DRIVE_COMBO      4226
#define IDC_PWD_STATIC                  4246
#define IDC_PASSWORD_ANONYMOUS          4249
#define IDC_ANON_USERNAME               4250
#define IDC_USERNAME_LABEL              4251
#define IDC_PWD_PROMPT                  4252
#define IDC_COMPINFO                    4253
#define IDC_YOURPASSPORT                4254
#define IDC_PASSPORTWIZARD              4258
#define IDC_BOLD1                       4259

#define IDI_PSW                         4400

#define IDB_PSW_BANNER                  4410
#define IDB_PSW_WATERMARK               4411

#define IDB_GETPP_BANNER                4412
#define IDB_GETPP_WATERMARK             4413

#define IDD_PSW_PERMISSIONS             4420
#define IDD_PSW_DOMAININFO              4421
#define IDD_PSW_USERINFO                4422
#define IDD_PSW_DONE                    4423
#define IDD_PSW_WHICHNET                4424
#define IDD_PSW_WORKGROUP               4425
#define IDD_PSW_AUTOLOGON               4426
#define IDD_PSW_WELCOME                 4427
#define IDD_PSW_JOINCREDENTIALS         4428
#define IDD_PSW_COMPINFO                4429

#define IDD_USR_CHOOSEGROUP_WIZARD_PAGE 4430
#define IDD_USR_PASSWORD_WIZARD_PAGE    4431
#define IDD_USR_USERNAME_WIZARD_PAGE    4432

#define IDD_PSW_HOWUSE                  4433
#define IDD_PSW_ADDUSER                 4434

#define IDD_GETPP_WELCOME               4435
#define IDD_GETPP_FINISH                4437

#define IDS_MAPDRIVE_CAPTION            4449
#define IDS_NETWIZCAPTION               4450
#define IDS_WORKGROUP                   4451
#define IDS_PERMISSIONS                 4456
#define IDS_PERMISSIONS_SUB             4457
#define IDS_WHICHNET                    4458
#define IDS_WHICHNET_SUB                4459
#define IDS_WORKGROUP_SUB               4460
#define IDS_DOMAININFO                  4461
#define IDS_DOMAININFO_SUB              4462
#define IDS_COMPINFO                    4463
#define IDS_COMPINFO_SUB                4464
#define IDS_USERINFO                    4465
#define IDS_USERINFO_SUB                4466
#define IDS_DONE                        4467
#define IDS_DONE_SUB                    4468
#define IDS_WELCOME_SUB                 4470
#define IDS_ABOUTTOJOIN                 4471
#define IDS_AUTOLOGON                   4475
#define IDS_AUTOLOGON_SUB               4476
#define IDS_HOWUSE                      4477
#define IDS_HOWUSE_SUB                  4478
#define IDS_COMPNOTFOUND                4479
#define IDS_NETWIZFINISHREBOOT          4480
#define IDS_NETWIZFINISH                4481
#define IDS_RESTARTREQUIRED             4482

#define IDS_PUB_DESTINATION             4529
#define IDS_PUB_DESTINATION_SUB         4530
#define IDS_PUB_BROWSETITLE             4536
#define IDS_PUB_RESIZE                  4547
#define IDS_PUB_RESIZE_SUB              4548
#define IDS_PUB_PATHNOTTHERE            4554
#define IDS_PUB_PATHNOTTHERETITLE       4555
#define IDS_PUB_INVALIDRESOURCE         4557
#define IDS_PUB_ONLYSERVER              4558

#define IDS_PUB_COMPLETEFMT             4559
#define IDS_PUB_COPYINGFMT              4560

#define IDS_PUB_FETCHINGPROVIDERS       4561
#define IDS_PUB_FETCHINGPROVIDERS_SUB   4562
#define IDS_PUB_SAMETARGET              4563

#define IDS_PUB_LOCATION                4570
#define IDS_PUB_LOCATION_SUB            4571
#define IDS_PUB_FTPPASSWORD             4572
#define IDS_PUB_FTPPASSWORD_SUB         4573
#define IDS_PUB_FRIENDLYNAME            4574
#define IDS_PUB_FRIENDLYNAME_SUB        4575

#define IDC_NONE                        4500
#define IDC_DIALUP                      4501
#define IDC_WORKGROUP                   4504
#define IDC_COMPUTERNAME                4505
#define IDC_TITLE                       4508
#define IDC_MESSAGE                     4509
#define IDC_ANON_USERNAME_LABEL         4510
#define IDC_OTHER_STATIC                4511

#define IDC_PUB_WELCOME                 4513
#define IDC_PUB_WELCOMEPROMPT           4514
#define IDC_PUB_DONE                    4521
#define IDC_PUB_COMPLETEMSG             4526
#define IDC_PUB_COPYPROMPT              4524
#define IDC_PUB_COPYPROGRESS            4525
#define IDC_PUB_LOCATIONCAPTION         4526
#define IDC_PUB_OPENFILES               4527
#define IDC_PUB_PREVIEW                 4528

#define IDC_PUB_ALL                     4529
#define IDC_PUB_NOTHING                 4530
#define IDC_PUB_SELECTOR                4531
#define IDC_PUB_SELECTORSTATUS          4532

#define IDC_PUB_SRCHPROVIDERS           4533
#define IDC_PUB_SRCHPROVIDERS_STATIC1   4534
#define IDC_PUB_SRCHPROVIDERS_STATIC2   4535

#define IDC_PUB_PROVIDERSCAPTION        4540
#define IDC_PUB_PROVIDERS               4541
#define IDC_PUB_PROVIDERSLABEL          4542

#define IDC_PUB_RESIZE                  4545
#define IDC_PUB_RESIZESMALL             4546
#define IDC_PUB_RESIZEMEDIUM            4547
#define IDC_PUB_RESIZELARGE             4548

#define IDC_PUB_COPYFILE                4550
#define IDC_PUB_LABELFILEPROG           4551
#define IDC_PUB_FILEPROGRESS            4552
#define IDC_PUB_LABELTRANSPROG          4553
#define IDC_PUB_TRANSPROGRESS           4554

#define IDS_ERR_BADUSER                 12009
#define IDS_ERR_NOSUCHUSER              12010
#define IDS_ERR_JOINWGFAIL              12011
#define IDS_ERR_FAILTOFIND              12012
#define IDS_ERR_BADPWUSER               12013
#define IDS_ERR_PWDNOMATCH              12014
#define IDS_ERR_BADDOMAIN               12015
#define IDS_CONNECT_DRIVE_CAPTION       12053
#define IDS_OPENFILES_WARNING           12062
#define IDS_MPRHELPFILENAME             12067
#define IDS_WELCOME                     12101
#define IDS_COMPLETION                  12104
#define IDS_COMPLETION_STATIC           12110
#define IDS_CLOSE                       12111
#define IDS_ERR_CAPTION                 12120
#define IDS_ERR_OPENFILES               12121
#define IDS_ERR_ALREADYASSIGNED         12122
#define IDS_ERR_ALREADYREMEMBERED       12123
#define IDS_ERR_INVALIDREMOTEPATH       12124
#define IDS_ERR_PROVIDERBUSY            12125
#define IDS_ERR_NONETWORK               12126
#define IDS_ERR_UNEXPECTED              12127
#define IDS_FIRSTCOLUMN                 12140
#define IDS_SECONDCOLUMN                12141
#define IDS_PWD_STATIC                  12150
#define IDS_TITLEFONTNAME               12152
#define IDS_TITLEFONTSIZE               12153
#define IDS_NONE                        12154
#define IDS_CANTFINDFOLDER              12155
#define IDS_CONNECTASUSER               12156
#define IDS_CANTCLOSEFILES_WARNING      12164

#define IDS_USR_DESC                    12165
#define IDS_USR_NEWUSERWIZARD_CAPTION   12166
#define IDS_USR_TITLEFONTNAME           12167
#define IDS_USR_TITLEFONTSIZE           12168
#define IDS_USR_NAME_COLUMN             12169
#define IDS_USR_DOMAIN_COLUMN           12170
#define IDS_USR_GROUP_COLUMN            12171
#define IDS_USR_LOGGEDINAS              12172
#define IDS_USR_LOGGEDINAS_NOFULLNAME   12173
#define IDS_USR_TOOLTIPFULLNAME_FORMAT  12174
#define IDS_USR_TOOLTIPCOMMENT_FORMAT   12175
#define IDS_USR_TOOLTIPBOTH_FORMAT      12176
#define IDS_USR_PASSWORDSDONTMATCH_ERROR 12177
#define IDS_USR_NOUSERNAMEENTERED_ERROR 12178
#define IDS_USR_DEFAULTGROUP            12179
#define IDS_USR_NETUSERNAME_ERROR       12180
#define IDS_USR_REMOVEUSER_WARNING      12181
#define IDS_USR_APPLET_CAPTION          12182
#define IDS_USR_REMOVE_MISC_ERROR       12183
#define IDS_USR_COULDNTFINDUSER_ERROR   12184
#define IDS_USR_PWGROUP_FORMAT          12185
#define IDS_USR_PWMESSAGE_FORMAT        12186
#define IDS_USR_CREATE_MISC_ERROR       12187
#define IDS_USR_CREATE_USEREXISTS_ERROR 12188
#define IDS_USR_BADUSERINFO_ERROR       12189
#define IDS_USR_PROPERTIES_ERROR        12190
#define IDS_USR_CREATE_GROUPEXISTS_ERROR 12191
#define IDS_USR_YOURPWMESSAGE_FORMAT    12195
#define IDS_USR_CANTCHANGEPW_FORMAT     12196
#define IDS_USR_CANTRUNCPL_FORMAT       12197
#define IDS_USR_CANTOPENCPLASUSER_ERROR 12198
#define IDS_USR_UPDATE_PASSWORD_TOOSHORT_ERROR 12199
#define IDS_USR_UPDATE_FULLNAME_ERROR   12200
#define IDS_USR_UPDATE_GROUP_ERROR      12201
#define IDS_USR_UPDATE_PASSWORD_ERROR   12202
#define IDS_USR_UPDATE_USERNAME_ERROR   12203
#define IDS_USR_UPDATE_DESCRIPTION_ERROR 12204
#define IDS_USR_CREATE_PASSWORDTOOSHORT_ERROR 12205
#define IDS_ADMINISTRATOR               12206
#define IDS_MND_ADDPLACELINK            12207
#define IDS_MND_HIDEADVANCED            12208
#define IDS_MND_SHOWADVANCED            12209
#define IDS_MND_SHAREBROWSE             12210
#define IDS_MND_FINDINDS                12211
#define IDS_MND_ADDPLACEERR             12212
#define IDS_MND_PROGRESS                12213
#define IDS_MND_ALREADYMAPPED           12214
#define IDS_USR_POWERUSERS              12215
#define IDS_USR_USERS                   12216
#define IDS_USR_GUESTS                  12217
#define IDS_ADDUSER                     12218
#define IDS_ADDUSER_SUB                 12219
#define IDS_WHATACCESS_FORMAT           12220
#define IDS_USR_CHANGEGROUP_ERR         12222
#define IDS_NETPLACE_EXAMPLES           12223
#define IDS_NETPLACE_EXAMPLES_TITLE     12224
#define IDS_BADFRIENDLYNAME             12225
#define IDS_COULDNTRENAMEPLACE          12226
#define IDS_MND_GENERICERROR            12228
#define IDS_NAW_JOIN_GENERICERROR       12229
#define IDS_NAW_NAMECHANGE_ERROR        12230
#define IDS_COMPNAME_EXISTS             12231
#define IDS_ERR_ADDUSER                 12232
#define IDS_LOGOFFREQUIRED              12233
#define IDS_USERSANDPASSWORDS           12234
#define IDS_USERCREATE_GENERICERROR     12235
#define IDS_BADSTANDARDUSER             12236
#define IDS_BADRESTRICTEDUSER           12237
#define IDS_MACHINENAMEINUSE            12238
#define IDS_FRIENDLYNAMEINUSE           12239
#define IDS_ERR_BADUSERNAME             12240
#define IDS_ERR_BADWORKGROUP            12241

#define IDS_GETPP_HEADER_WELCOME        12243
#define IDS_GETPP_SUBHEADER_WELCOME     12244
#define IDS_GETPP_HEADER_FINISH         12247
#define IDS_GETPP_SUBHEADER_FINISH      12248
#define IDS_GETPP_CAPTION               12249

#define IDS_DISCONNECTDRIVETITLE        13000
#define IDS_DISCONNECT_CONFIRM          13001
#define IDS_DISCONNECTERROR             13002
#define IDS_NONETDRIVES                 13003
#define IDS_DISCONNECT_CONFIRM_NODEV    13004
#define IDS_DISCONNECT_CAPTION          13005

// These are extension wizard pages, therefore they must be defined
// within this range (see shpriv.idl for details).

#define IDD_PUB_DESTINATION             20480
#define IDD_PUB_RESIZE                  20481
#define IDD_WEB_DLG                     20483
#define IDD_PUB_LOCATION                20484
#define IDD_PUB_FTPPASSWORD             20485
#define IDD_PUB_SELECTOR                20486
#define IDD_PUB_FETCHPROVIDERS          20487

#define IDD_DISCONNECTDRIVES            21000

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1072
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\resourcemap.cpp ===
#include "stdafx.h"
#pragma hdrstop


class CResourceMap : public IResourceMap, IPersistFile
{
public:
    CResourceMap();
    ~CResourceMap();

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID)
        { *pClassID = CLSID_NULL; return S_OK; }

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IResourceMap
    STDMETHODIMP LoadResourceMap(LPCTSTR pszClass, LPCTSTR pszID);
    STDMETHODIMP SelectResourceScope(LPCTSTR pszResourceType, LPCTSTR pszID, IXMLDOMNode **ppdn);
    STDMETHODIMP LoadBitmap(IXMLDOMNode *pdn, LPCTSTR pszID, HBITMAP *pbm);
    STDMETHODIMP LoadString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch);

private:
    LONG _cRef;
    TCHAR _szMapURL[MAX_PATH];
    IXMLDOMNode *_pdnRsrcMap;           // XML node which describes this wizard
};


CResourceMap::CResourceMap() : 
    _cRef(1)
{
}

CResourceMap::~CResourceMap()
{
    ATOMICRELEASE(_pdnRsrcMap);
}


ULONG CResourceMap::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CResourceMap::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CResourceMap::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CResourceMap, IResourceMap),             // IID_IResourceMap
        QITABENTMULTI(CResourceMap, IPersist, IPersistFile), // rare IID_IPersist
        QITABENT(CResourceMap, IPersistFile),             // IID_IPersistFile
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


STDAPI CResourceMap_Initialize(LPCWSTR pszURL, IResourceMap **pprm)
{
    CResourceMap *prm = new CResourceMap;
    if (!prm)
        return E_OUTOFMEMORY;

    // load from the URL we were given
    IPersistFile *ppf;
    HRESULT hr = prm->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        hr = ppf->Load(pszURL, 0x0);
        ppf->Release();
    }

    // if that succeeded then lets get the IResourceMap for the caller
    if (SUCCEEDED(hr))
        hr = prm->QueryInterface(IID_PPV_ARG(IResourceMap, pprm));

    prm->Release();
    return hr;
}


// IPersistFile support

HRESULT CResourceMap::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    StrCpyN(_szMapURL, pszFileName, ARRAYSIZE(_szMapURL));
    ATOMICRELEASE(_pdnRsrcMap);
    return S_OK;
}
HRESULT CResourceMap::GetCurFile(LPOLESTR *ppszFileName)
{
    HRESULT hr = E_FAIL;
    if (_szMapURL[0])
    {
        *ppszFileName = SysAllocString(_szMapURL);
        hr = *ppszFileName ? S_OK:E_OUTOFMEMORY;
    }
    return hr;
}


// IResourceMap support

HRESULT CResourceMap::LoadResourceMap(LPCTSTR pszResourceClass, LPCTSTR pszID)
{
    IXMLDOMDocument *pdocWizardDefn;
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IXMLDOMDocument, &pdocWizardDefn));
    if (SUCCEEDED(hr))
    {
        ATOMICRELEASE(_pdnRsrcMap);    

        VARIANT varName;
        hr = InitVariantFromStr(&varName, _szMapURL);
        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL fSuccess;
            hr = pdocWizardDefn->load(varName, &fSuccess);
            if (hr == S_OK)
            {
                if (fSuccess == VARIANT_TRUE)
                {
                    TCHAR szPath[MAX_PATH];
                    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("resourcemap/%s[@id='%s']"), pszResourceClass, pszID);
                    hr = pdocWizardDefn->selectSingleNode(szPath, &_pdnRsrcMap);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            VariantClear(&varName);
        }
        pdocWizardDefn->Release();
    }
    return (SUCCEEDED(hr) && (hr != S_OK)) ? E_FAIL:hr;
}


HRESULT CResourceMap::SelectResourceScope(LPCTSTR pszResourceType, LPCTSTR pszID, IXMLDOMNode **ppdn)
{
    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("%s[@id='%s']"), pszResourceType, pszID);

    HRESULT hr = _pdnRsrcMap->selectSingleNode(szPath, ppdn);
    return (SUCCEEDED(hr) && (hr != S_OK)) ? E_FAIL:hr;         // the call can return S_FALSE  
}


HRESULT CResourceMap::LoadBitmap(IXMLDOMNode *pdn, LPCTSTR pszID, HBITMAP *phbm)
{
    *phbm = NULL;

    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("bitmap[@id='%s']"), pszID);

    IXMLDOMNode *pn;
    HRESULT hr = (pdn ? pdn:_pdnRsrcMap)->selectSingleNode(szPath, &pn);
    if (hr == S_OK)
    {
        VARIANT var;    
        hr = pn->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            VariantToStr(&var, szPath, ARRAYSIZE(szPath));
            VariantClear(&var);

            INT idRes = PathParseIconLocation(szPath) * -1;      // fix -ve resource ID
            HINSTANCE hinst = LoadLibrary(szPath);
            if (hinst)
            {
                *phbm = (HBITMAP)LoadImage(hinst, MAKEINTRESOURCE(idRes),IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
                FreeLibrary(hinst);
            }
        }
        pn->Release();
    }
    return *phbm ? S_OK:E_FAIL;;
}


HRESULT CResourceMap::LoadString(IXMLDOMNode *pdn, LPCTSTR pszID, LPTSTR pszBuffer, int cch)
{
    TCHAR szPath[MAX_PATH];
    wnsprintf(szPath, ARRAYSIZE(szPath), TEXT("text[@id='%s']"), pszID);

    IXMLDOMNode *pn;
    HRESULT hr = (pdn ? pdn:_pdnRsrcMap)->selectSingleNode(szPath, &pn);
    if (hr == S_OK)
    {
        VARIANT var;    
        hr = pn->get_nodeTypedValue(&var);
        if (SUCCEEDED(hr))
        {
            VariantToStr(&var, pszBuffer, cch);
            SHLoadIndirectString(pszBuffer, pszBuffer, cch, NULL);
            VariantClear(&var);
        }
        pn->Release();
    }

    // try global strings if this load fails

    if (((FAILED(hr)) || (hr != S_OK)) && (pdn != NULL))
    {
        hr = LoadString(NULL, pszID, pszBuffer, cch);
    }

    return (SUCCEEDED(hr) && (hr != S_OK)) ? E_FAIL:hr;         // the call can return S_FALSE  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\stdafx.h ===
#ifndef STDAFX_H_INCLUDED
#define STDAFX_H_INCLUDED

#undef ATL_MIN_CRT

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "ntlsa.h"

#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <security.h>

#include <windows.h>        // basic windows functionality
#include <windowsx.h>
#include <commctrl.h>       // ImageList, ListView
#include <comctrlp.h>
#include <shfusion.h>
#include <string.h>         // string functions
#include <crtdbg.h>         // _ASSERT macro
#include <objbase.h>
#include <shconv.h>
#include <wininet.h>
#include <lm.h>
#include <validc.h>         // specifies valid characters for user names, etc.
#include <wincrui.h>        // credui

#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobj.h>         // Needed by dsclient.h
#include <shlobjp.h>
#include <shlguid.h>
#include <shlguidp.h>
#include <ieguidp.h>
#include <shellp.h>         
#include <ccstock.h>
#include <dpa.h>
#include <varutil.h>
#include <cowsite.h>
#include <objsafe.h>
#include <cobjsafe.h>

// our concept of what domain, password and user names should be

#define MAX_COMPUTERNAME    LM20_CNLEN
#define MAX_USER            LM20_UNLEN
#define MAX_UPN             UNLEN
#define MAX_PASSWORD        PWLEN
#define MAX_DOMAIN          MAX_PATH
#define MAX_WORKGROUP       LM20_DNLEN      
#define MAX_GROUP           GNLEN

// MAX_DOMAINUSER can hold: <domain>/<username> or <upn>
#define MAX_DOMAINUSER      MAX(MAX_UPN, MAX_USER + MAX_DOMAIN + 1)


// our headers

#include "dialog.h"
#include "helpids.h"
#include "misc.h"
#include "cfdefs.h"
#include "dspsprt.h"
#include "resource.h"
#include "userinfo.h"
#include "dialog.h"
#include "data.h"


// global state

EXTERN_C HINSTANCE g_hinst;
extern LONG g_cLocks;

// resource mapper object - used for wizard chaining

STDAPI CResourceMap_Initialize(LPCWSTR pszURL, IResourceMap **pprm);


// constructors for COM objects

STDAPI CPublishingWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CUserPropertyPages_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CUserSidDataObject_CreateInstance(PSID psid, IDataObject **ppdo);
STDAPI CPassportWizard_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CPassportClientServices_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

extern const CLSID CLISD_PublishDropTarget;
STDAPI CPublishDropTarget_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);


// template for defining wizard pages

typedef struct 
{
    LPCWSTR idPage;
    DLGPROC pDlgProc;
    LPCWSTR pHeading;
    LPCWSTR pSubHeading;
    DWORD dwFlags;
} WIZPAGE;

typedef struct
{
    LPWSTR pszUser;
    INT cchUser;
    LPWSTR pszDomain;
    INT cchDomain;
    LPWSTR pszPassword;
    INT cchPassword;
} CREDINFO, * LPCREDINFO;

HRESULT JoinDomain(HWND hwnd, BOOL fDomain, LPCWSTR pDomain, CREDINFO* pci, BOOL *pfReboot);
VOID SetAutoLogon(LPCWSTR pszUserName, LPCWSTR pszPassword);
VOID SetDefAccount(LPCWSTR pszUserName, LPCWSTR pszDomain);


// for the users.cpl (shared between usercpl.cpp & userlist.cpp)

// All "add user to list" operations are done on the main UI thread - the
// filler thread posts this message to add a user
#define WM_ADDUSERTOLIST (WM_USER + 101)
//                  (LPARAM) CUserInfo* - the user to add to the listview
//                  (WPARAM) BOOL       - select this user (should always be 0 for now)


// Wizard text-related constants
#define MAX_CAPTION         256      // Maximum size of a caption in the Wizard
#define MAX_STATIC          1024     // Maximum size of static text in the Wizard


// Wizard error return value
#define RETCODE_CANCEL      0xffffffff


// keep the debug libraries working...
#ifdef DBG
 #if !defined (DEBUG)
  #define DEBUG
 #endif
#else
 #undef DEBUG
#endif

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)

#endif // !STDAFX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\sources.inc ===
SELFREGNAME= $(O)\netplwiz_selfreg.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)

USE_NT_PRODUCT_VER = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME= netplwiz
TARGETTYPE= DYNLINK
TARGETPATH= obj

#VERIFY_LC = 1
LC_PATH   = $(PROJECT_ROOT)\lcinf

DLLENTRY=DllMain
DLLDEF=$(O)\netplwiz.def

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\stdafx.h

#
# Fusionized
#
SXS_ASSEMBLY_NAME=Microsoft.Windows.Shell.NetPlacesWizard
SXS_ASSEMBLY_VERSION=1.0
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=placeswizard.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_MANIFEST_RESOURCE_ID=123
SXS_NO_BINPLACE=1

NTTARGETFILE0   = $(SELFREGNAME)

MISCFILES=\
    $(MISCFILES)        \
    ..\res\lusrmgr.msc

MSC_WARNING_LEVEL=/W3 /WX

USE_MSVCRT=1

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS=\
            $(SDK_LIB_PATH)\kernel32.lib \
            $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\gdi32.lib    \
            $(SHELL_LIB_PATH)\shell32p.lib \
            $(SHELL_LIB_PATH)\shlwapip.lib \
            $(SHELL_LIB_PATH)\shuuid.lib \
            $(SHELL_LIB_PATH)\shguidp.lib \
            $(SHELL_LIB_PATH)\ieguidp.lib \
            $(SHELL_LIB_PATH)\shfusion.lib    \
            $(SDK_LIB_PATH)\wininet.lib  \
            $(SDK_LIB_PATH)\netapi32.lib \
            $(SDK_LIB_PATH)\activeds.lib \
            $(SDK_LIB_PATH)\adsiid.lib   \
            $(SDK_LIB_PATH)\ole32.lib    \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\mpr.lib      \
            $(SDK_LIB_PATH)\uuid.lib     \
            $(SDK_LIB_PATH)\ntdsapi.lib  \
            $(SDK_LIB_PATH)\rasdlg.lib   \
            $(SDK_LIB_PATH)\rasapi32.lib \
            $(SDK_LIB_PATH)\secur32.lib  \
            $(SDK_LIB_PATH)\msdasc.lib   \
            $(DS_LIB_PATH)\creduip.lib   \
            $(SDK_LIB_PATH)\urlmon.lib   \
            $(CCSHELL_DIR)\lib\$O\stock.lib

C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE -D_UNICODE -DUSE_MIRRORING -DUXCTRL_VERSION=0x0100

DELAYLOAD= WININET.DLL;RASDLG.DLL;RASAPI32.DLL;ACTIVEDS.DLL;CREDUI.DLL

# BASE_INC_PATH for validc.h, DS_INC_PATH for iadsp.h
INCLUDES=..\;$(BASE_INC_PATH);$(DS_INC_PATH);$(PROJECT_ROOT)\lib\$(O)
	
USE_ATL=1	

SOURCES=\
        ..\resource.rc  \
        ..\anp.cpp      \
        ..\dll.cpp      \
        ..\dialog.cpp   \
        ..\misc.cpp     \
        ..\netwiz.cpp   \
        ..\join.cpp     \
        ..\data.cpp     \
        ..\netpage.cpp  \
        ..\netplace.cpp \
        ..\misc.cpp     \
        ..\password.cpp \
        ..\userinfo.cpp \
        ..\resourcemap.cpp \
        ..\grpinfo.cpp  \
        ..\mnddlg.cpp   \
        ..\unpage.cpp   \
        ..\pubwiz.cpp   \
        ..\pubcopy.cpp  \
        ..\pubdrop.cpp  \
        ..\pubhelp.cpp  \
        ..\pubpost.cpp  \
        ..\usercpl.cpp  \
        ..\getpp.cpp    \
        ..\disconndlg.cpp \
        ..\passportmisc.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\unpage.cpp ===
#include "stdafx.h"
#include "unpage.h"
#pragma hdrstop



HRESULT ValidateName(LPCTSTR pszName)
{
    // We need to use illegal fat chars, says SBurns
    TCHAR* pszBadChars = ILLEGAL_FAT_CHARS;
    HRESULT hrStringOK = S_OK;

    while ((NULL != *pszBadChars) && (hrStringOK == S_OK))
    {
        if (NULL != StrChr(pszName, *pszBadChars))
        {
            hrStringOK = E_FAIL;
        }
        else
        {
            pszBadChars = CharNext(pszBadChars);
        }
    }

    if (SUCCEEDED(hrStringOK))
    {
        // See if the whole string is dots
        TCHAR* pszChar = const_cast<TCHAR*>(pszName);
        BOOL fAllDots = TRUE;

        while (fAllDots && (0 != *pszChar))
        {
            if (TEXT('.') == *pszChar)
            {
                pszChar = CharNext(pszChar);
            }
            else
            {
                fAllDots = FALSE;
            }
        }
        
        if (fAllDots)
        {
            hrStringOK = E_FAIL;
        }
    }

    return hrStringOK;
}


/*************************************
 CUsernamePageBase Implementation
*************************************/

BOOL CUsernamePageBase::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Limit the text of the username, fullname and description fields
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    HWND hwndFullName = GetDlgItem(hwnd, IDC_FULLNAME);
    HWND hwndDescription = GetDlgItem(hwnd, IDC_DESCRIPTION);

    Edit_LimitText(hwndUsername, ARRAYSIZE(m_pUserInfo->m_szUsername) - 1);
    SetWindowText(hwndUsername, m_pUserInfo->m_szUsername);

    Edit_LimitText(hwndFullName, ARRAYSIZE(m_pUserInfo->m_szFullName) - 1);
    SetWindowText(hwndFullName, m_pUserInfo->m_szFullName);

    Edit_LimitText(hwndDescription, ARRAYSIZE(m_pUserInfo->m_szComment) - 1);
    SetWindowText(hwndDescription, m_pUserInfo->m_szComment);

    return TRUE;
}


/*************************************
 CUsernameWizardPage Implementation
*************************************/

INT_PTR CUsernameWizardPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }
    return FALSE;
}

BOOL CUsernameWizardPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_SETACTIVE:
            SetWizardButtons(hwnd, GetParent(hwnd));
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            return TRUE;

        case PSN_WIZNEXT:
            // Save the data the user has entered
            FetchText(hwnd, IDC_USER, m_pUserInfo->m_szUsername, ARRAYSIZE(m_pUserInfo->m_szUsername));
            FetchText(hwnd, IDC_FULLNAME, m_pUserInfo->m_szFullName, ARRAYSIZE(m_pUserInfo->m_szFullName));
            FetchText(hwnd, IDC_DESCRIPTION, m_pUserInfo->m_szComment, ARRAYSIZE(m_pUserInfo->m_szComment));

            if (S_OK != ValidateName(m_pUserInfo->m_szUsername))
            {
                // Username is invalid. warn now
                ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_ERR_BADUSERNAME, MB_ICONERROR | MB_OK);
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            else if (::UserAlreadyHasPermission(m_pUserInfo, hwnd))
            {
                // Don't let the user continue if the user they've selected already
                // has permission to use this machine
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
            }
            else
            {
                // We have a username (otherwise next would be disabled)
                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, 0);
            }
            return TRUE;
    }
    return FALSE;
}

BOOL CUsernameWizardPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify == EN_CHANGE)
    {
        SetWizardButtons(hwnd, GetParent(hwnd));
        return TRUE;
    }
    return FALSE;
}

void CUsernameWizardPage::SetWizardButtons(HWND hwnd, HWND hwndPropSheet)
{
    HWND hwndEdit = GetDlgItem(hwnd, IDC_USER);
    DWORD dwUNLength = GetWindowTextLength(hwndEdit);
    PropSheet_SetWizButtons(hwndPropSheet, (dwUNLength == 0) ? 0 : PSWIZB_NEXT);
}

/*************************************
 CUsernamePropertyPage Implementation
*************************************/

INT_PTR CUsernamePropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }
    return FALSE;
}

BOOL CUsernamePropertyPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify == EN_CHANGE)
    {
        PropSheet_Changed(GetParent(hwnd), hwnd);
        return TRUE;
    }
    return FALSE;
}

BOOL CUsernamePropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
            TCHAR szTemp[256];
            HRESULT hr;
            LONG lResult = PSNRET_NOERROR;

            // Try to update the username
            FetchText(hwnd, IDC_USER, szTemp, ARRAYSIZE(szTemp));

            TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
            ::MakeDomainUserString(m_pUserInfo->m_szDomain, m_pUserInfo->m_szUsername,
                                        szDomainUser, ARRAYSIZE(szDomainUser));

            if (StrCmp(szTemp, m_pUserInfo->m_szUsername) != 0)
            {
                hr = m_pUserInfo->UpdateUsername(szTemp);
                if (FAILED(hr))
                {
                    ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, 
                        IDS_USR_UPDATE_USERNAME_ERROR, MB_ICONERROR | MB_OK, szDomainUser);

                    lResult = PSNRET_INVALID_NOCHANGEPAGE;
                }
            }

            // Try to update the full name
            FetchText(hwnd, IDC_FULLNAME, szTemp, ARRAYSIZE(szTemp));
            if (StrCmp(szTemp, m_pUserInfo->m_szFullName) != 0)
            {
                hr = m_pUserInfo->UpdateFullName(szTemp);
                if (FAILED(hr))
                {
                    ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                        IDS_USR_UPDATE_FULLNAME_ERROR, MB_ICONERROR | MB_OK, szDomainUser);

                    lResult = PSNRET_INVALID_NOCHANGEPAGE;
                }
            }

            // Try to update the description
            FetchText(hwnd, IDC_DESCRIPTION, szTemp, ARRAYSIZE(szTemp));
            if (StrCmp(szTemp, m_pUserInfo->m_szComment) != 0)
            {
                hr = m_pUserInfo->UpdateDescription(szTemp);
                if (FAILED(hr))
                {
                    ::DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                        IDS_USR_UPDATE_DESCRIPTION_ERROR, MB_ICONERROR | MB_OK, szDomainUser);

                    lResult = PSNRET_INVALID_NOCHANGEPAGE;
                }
            }

            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, lResult);
            return TRUE;
        }

        default:
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\unpage.h ===
#ifndef UNPAGE_H
#define UNPAGE_H


class CUsernamePageBase
{
protected:
    CUsernamePageBase(CUserInfo* pUserInfo): m_pUserInfo(pUserInfo) {}

protected:
    // Message handlers
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

protected:
    // Data
    CUserInfo* m_pUserInfo;
};

class CUsernameWizardPage: public CPropertyPage, public CUsernamePageBase
{
public:
    CUsernameWizardPage(CUserInfo* pUserInfo): CUsernamePageBase(pUserInfo) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
    // Functions
    void SetWizardButtons(HWND hwnd, HWND hwndPropSheet);
};

class CUsernamePropertyPage: public CPropertyPage, public CUsernamePageBase
{
public:
    CUsernamePropertyPage(CUserInfo* pUserInfo): CUsernamePageBase(pUserInfo) {}

protected:
    // Message handlers
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
};

#endif //!UNPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\userinfo.h ===
#ifndef USERINFO_H_INCLUDED
#define USERINFO_H_INCLUDED


class CUserInfo
{
public:
    // Typedefs
    enum USERTYPE
    {
        LOCALUSER = 0,
        DOMAINUSER,
        GROUP
    };

    // Group pseudonym tells any functions that may change a user's group that the
    // user selected an option button that says something like "standard user" or
    // "restricted user" instead of selecting the real group name from a list.
    // In this case, the group change functions may display custom error messages that
    // mention "standard user access" instead of "power users group", for example.
    enum GROUPPSEUDONYM
    {
        RESTRICTED = 0,
        STANDARD,
        USEGROUPNAME
    };

public:
    // Functions
    CUserInfo();
    ~CUserInfo();
    HRESULT Load(PSID psid, BOOL fLoadExtraInfo = NULL);
    HRESULT Reload(BOOL fLoadExtraInfo = NULL);

    HRESULT Create(HWND hwndError, GROUPPSEUDONYM grouppseudonym);
    
    HRESULT UpdateUsername(LPTSTR pszNewUsername);
    HRESULT UpdateFullName(LPTSTR pszFullName);
    HRESULT UpdatePassword(BOOL* pfBadPWFormat);
    HRESULT UpdateGroup(HWND hwndError, LPTSTR pszGroup, GROUPPSEUDONYM grouppseudonym);
    HRESULT UpdateDescription(LPTSTR pszDescription);
    
    HRESULT Remove();
    HRESULT InitializeForNewUser();
    HRESULT GetExtraUserInfo();
    HRESULT SetUserType();
    HRESULT SetLocalGroups();

    void HidePassword();
    void RevealPassword();
    void ZeroPassword();

public:
    // Data

    // Index of this user's icon (local, domain, group)
    USERTYPE m_userType;

    TCHAR m_szUsername[MAX_USER + 1];
    TCHAR m_szDomain[MAX_DOMAIN + 1];
    TCHAR m_szComment[MAXCOMMENTSZ];
    TCHAR m_szFullName[MAXCOMMENTSZ];

    // Only if we're creating a new user:
    TCHAR m_szPasswordBuffer[MAX_PASSWORD + 1];
    UNICODE_STRING m_Password;
    UCHAR m_Seed;

    // Room for AT LEAST two group names plus a ';' a ' ' and a '\0'
    TCHAR m_szGroups[MAX_GROUP * 2 + 3];

    // The user's SID
    PSID m_psid;
    SID_NAME_USE m_sUse;

    // Is the account disabled
    BOOL m_fAccountDisabled;

    // Have we read the user's full name and comment yet?
    BOOL m_fHaveExtraUserInfo;
private:
    // Helpers
    HRESULT RemoveFromLocalGroups();
    HRESULT ChangeLocalGroups(HWND hwndError, GROUPPSEUDONYM grouppseudonym);
    HRESULT SetAccountDisabled();
};

class CUserListLoader
{
public:
    CUserListLoader();
    ~CUserListLoader();

    HRESULT Initialize(HWND hwndUserListPage);

    void EndInitNow() {m_fEndInitNow = TRUE;}
    BOOL InitInProgress() 
    {return (WAIT_OBJECT_0 != WaitForSingleObject(m_hInitDoneEvent, 0));}

private:
    HRESULT UpdateFromLocalGroup(LPWSTR szLocalGroup);
    HRESULT AddUserInformation(PSID psid);
    BOOL HasUserBeenAdded(PSID psid);    

    static DWORD WINAPI InitializeThread(LPVOID pvoid);
private:
    // Data
    HWND m_hwndUserListPage;
    HANDLE m_hInitDoneEvent;
    BOOL m_fEndInitNow;
    CDPA<CUserInfo> m_dpaAddedUsers;
};

// User info functions
BOOL UserAlreadyHasPermission(CUserInfo* pUserInfo, HWND hwndMsgParent);

#endif // !USERINFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\userinfo.cpp ===
#include "stdafx.h"
#include "userinfo.h"
#pragma hdrstop

/*******************************************************************
 CUserInfo implementation
*******************************************************************/

CUserInfo::CUserInfo() 
{
    m_fHaveExtraUserInfo = FALSE;
    m_psid = NULL;
}

CUserInfo::~CUserInfo()
{
    if (m_psid != NULL)
        LocalFree(m_psid);

    ZeroPassword();
}

HRESULT CUserInfo::Reload(BOOL fLoadExtraInfo /* = NULL */)
{
    // Initialize the structure and add it to the head of the list
    DWORD cchUsername = ARRAYSIZE(m_szUsername);
    DWORD cchDomain = ARRAYSIZE(m_szDomain);

    if (LookupAccountSid(NULL, m_psid, m_szUsername, &cchUsername, m_szDomain, &cchDomain, &m_sUse))
    {
        m_fHaveExtraUserInfo = FALSE;
        if (fLoadExtraInfo)
            GetExtraUserInfo();

        SetUserType();
        SetAccountDisabled();
        return SetLocalGroups();
    }
    return E_FAIL;
}

HRESULT CUserInfo::SetLocalGroups()
{
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    ::MakeDomainUserString(m_szDomain, m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

    DWORD dwEntriesRead;
    DWORD dwTotalEntries;
    BOOL fMore = TRUE;
    DWORD iNextGroupName = 0;
    BOOL fAddElipses = FALSE;

    HRESULT hr = S_OK;
    while (fMore)
    {
        LOCALGROUP_USERS_INFO_0* prglgrui0;
        NET_API_STATUS status = NetUserGetLocalGroups(NULL, szDomainUser, 0, 0, 
                                                       (BYTE**) &prglgrui0, 2048, 
                                                       &dwEntriesRead, &dwTotalEntries);

        if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
        {
            for (DWORD i = 0; i < dwEntriesRead; i++)
            {
                DWORD iThisGroupName = iNextGroupName;
                iNextGroupName += lstrlen(prglgrui0[i].lgrui0_name) + 2;

                if (iNextGroupName < (ARRAYSIZE(m_szGroups) - 1))
                {
                    lstrcpy(&m_szGroups[iThisGroupName], prglgrui0[i].lgrui0_name);
                    lstrcpy(&m_szGroups[iNextGroupName - 2], TEXT("; "));
                }
                else
                {
                    fAddElipses = TRUE;
                    if (iThisGroupName + 3 >= (ARRAYSIZE(m_szGroups)))
                        iThisGroupName -= 3;

                    lstrcpy(&m_szGroups[iThisGroupName], TEXT("..."));

                    // No need to read more; we're out o' buffer
                    fMore = FALSE;
                }
            }
            NetApiBufferFree((void*) prglgrui0);
        }
        else
        {
            hr = E_FAIL;
        }

        if (status != ERROR_MORE_DATA)
        {
            fMore = FALSE;
        }
    }

    // There is an extra ';' at the end. Nuke it
    if (!fAddElipses && ((iNextGroupName - 2) < (ARRAYSIZE(m_szGroups))))
    {
        m_szGroups[iNextGroupName - 2] = TEXT('\0');
    }

    // Absolutely guarantee the string ends in a null
    m_szGroups[ARRAYSIZE(m_szGroups) - 1] = TEXT('\0');

    return hr;
}

HRESULT CUserInfo::Load(PSID psid, BOOL fLoadExtraInfo /* = NULL */)
{
    CUserInfo();            // Nuke the record first

    // Make a copy of the SID
    DWORD cbSid = GetLengthSid(psid);
    m_psid = (PSID) LocalAlloc(NULL, cbSid);
    if (!m_psid)
        return E_OUTOFMEMORY;

    CopySid(cbSid, m_psid, psid);
    return Reload(fLoadExtraInfo);
}

HRESULT CUserInfo::Create(HWND hwndError, GROUPPSEUDONYM grouppseudonym)
{
    NET_API_STATUS status = NERR_Success;

    CWaitCursor cur;

    HRESULT hr = E_FAIL;
    if (m_userType == CUserInfo::LOCALUSER)
    {
        // Fill in the big, ugly structure containing information about our new user
        USER_INFO_2 usri2 = {0};
        usri2.usri2_name = T2W(m_szUsername);

        // Reveal the password
        RevealPassword();

        usri2.usri2_password = T2W(m_szPasswordBuffer);
        usri2.usri2_priv = USER_PRIV_USER;
        usri2.usri2_comment = T2W(m_szComment);

        if (m_szPasswordBuffer[0] == TEXT('\0'))
            usri2.usri2_flags = UF_NORMAL_ACCOUNT | UF_SCRIPT | UF_PASSWD_NOTREQD;
        else
            usri2.usri2_flags = UF_NORMAL_ACCOUNT | UF_SCRIPT;

        usri2.usri2_full_name = T2W(m_szFullName);
        usri2.usri2_acct_expires = TIMEQ_FOREVER;
        usri2.usri2_max_storage = USER_MAXSTORAGE_UNLIMITED;

        TCHAR szCountryCode[7];
        if (0 < GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ICOUNTRY, szCountryCode, ARRAYSIZE(szCountryCode)))
        {
            usri2.usri2_country_code = (DWORD) StrToLong(szCountryCode);
        }

        usri2.usri2_code_page = GetACP();

        // Create the user
        status = NetUserAdd(NULL, 2, (BYTE*) &usri2, NULL);

        // Hide the password
        HidePassword();

        switch (status)
        {
            case NERR_Success:
                hr = S_OK;
                break;
            
            case NERR_PasswordTooShort:
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_PASSWORDTOOSHORT_ERROR, MB_ICONERROR | MB_OK);

                break;
            case NERR_GroupExists:
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_GROUPEXISTS_ERROR, MB_ICONERROR | MB_OK);
                break;

            case NERR_UserExists:
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_USEREXISTS_ERROR, MB_ICONERROR | MB_OK, 
                                        m_szUsername);
                break;

            default:
            {
                TCHAR szMessage[512];

                if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                    LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, IDS_USERCREATE_GENERICERROR, MB_ICONERROR | MB_OK, szMessage);
                break;
            }
        }
    }
    else 
    {
        hr = S_OK;          // m_userType == DOMAINUSER or GROUP
    }

    if (SUCCEEDED(hr))
    {
        hr = ChangeLocalGroups(hwndError, grouppseudonym);
        if (SUCCEEDED(hr))
        {
            // User type may have been updated by ChangeLocalGroups -  // relect that!
            SetUserType();
        }
    }

    return hr;
}

HRESULT CUserInfo::Remove()
{
    CWaitCursor cur;
    if (m_userType == CUserInfo::LOCALUSER)
    {
        // Try to actually remove this local user (this may fail!)

        NET_API_STATUS status = NetUserDel(NULL, m_szUsername);
        if (status != NERR_Success)
        {
            return E_FAIL;
        }
    }
    else
    {
        // We can only delete local users. For all others the best we can do is 
        // remove them from all local groups

        return RemoveFromLocalGroups();
    }
    return S_OK;
}

HRESULT CUserInfo::InitializeForNewUser()
{
    CUserInfo();                // Nuke the record first

    m_fHaveExtraUserInfo = TRUE;
    m_sUse = SidTypeUser;
    m_userType = LOCALUSER;

    return S_OK;
}

HRESULT CUserInfo::RemoveFromLocalGroups()
{
    // Create a data structure we'll need to pass to NetLocalGroupxxx functions
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
    ::MakeDomainUserString(m_szDomain, m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));    
    LOCALGROUP_MEMBERS_INFO_3 rglgrmi3[] = {{szDomainUser}};

    // Try and remove the user/group from ALL local groups. The reason
    // for this is the NetUserGetLocalGroups won't work for groups, even
    // well-known ones. For instance, it will fail for "Everyone" even
    // though "Everyone" may very well belong to local groups.

    DWORD_PTR dwResumeHandle = 0;

    BOOL fMoreData = TRUE;
    while (fMoreData)
    {
        DWORD dwEntriesRead;
        DWORD dwTotalEntries;
        LOCALGROUP_INFO_0* plgrpi0 = NULL;

        NET_API_STATUS status = NetLocalGroupEnum(NULL, 0, (BYTE**)&plgrpi0, 8192, 
                                                   &dwEntriesRead, &dwTotalEntries, &dwResumeHandle);
 
        if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
        {
            for (DWORD i = 0; i < dwEntriesRead; i ++)
            {
                status = NetLocalGroupDelMembers(NULL, plgrpi0[i].lgrpi0_name, 3,
                                                  (BYTE*) rglgrmi3, ARRAYSIZE(rglgrmi3));
            }

            if (dwEntriesRead == dwTotalEntries)
            {
                fMoreData = FALSE;
            }

            NetApiBufferFree(plgrpi0);
        }
        else
        {
            fMoreData = FALSE;
        }
    }
    return S_OK;
}

HRESULT CUserInfo::SetUserType()
{
    TCHAR szComputerName[MAX_COMPUTERNAME + 1];
    DWORD cchComputerName = ARRAYSIZE(szComputerName);
    ::GetComputerName(szComputerName, &cchComputerName);

    // Figure out what type of user we're talking about
    
    if ((m_sUse == SidTypeWellKnownGroup) || (m_sUse == SidTypeGroup))
    {
        m_userType = GROUP;
    }
    else
    {
        // User type - see if this user is a local one
        if ((m_szDomain[0] == TEXT('\0')) || 
                (StrCmpI(m_szDomain, szComputerName) == 0))
        {
            m_userType = LOCALUSER;             // Local user
        }
        else
        {
            m_userType = DOMAINUSER;            // User is a network one
        }
    }

    return S_OK;
}

HRESULT CUserInfo::SetAccountDisabled()
{
    m_fAccountDisabled = FALSE;

    USER_INFO_1* pusri1 = NULL;
    NET_API_STATUS status = NetUserGetInfo(NULL, T2W(m_szUsername), 1, (BYTE**)&pusri1);
    if (NERR_Success == status)
    {
        if (pusri1->usri1_flags & UF_ACCOUNTDISABLE)
        {
            m_fAccountDisabled = TRUE;
        }

        NetApiBufferFree(pusri1);
    }

    return S_OK;
}

HRESULT CUserInfo::GetExtraUserInfo()
{
    USES_CONVERSION;

    CWaitCursor cur;

    if (!m_fHaveExtraUserInfo)
    {
        NET_API_STATUS status;
        USER_INFO_11* pusri11 = NULL;

        // Even if we fail to the info, we only want to try once since it may take a long time
        m_fHaveExtraUserInfo = TRUE;

        // Get the name of the domain's DC if we aren't talking about a local user
#ifdef _0 // Turns out this is REALLY slow to fail if the DsGetDcName call fails
        if (m_userType != LOCALUSER)
        {

            DOMAIN_CONTROLLER_INFO* pDCInfo;
            DWORD dwErr = DsGetDcName(NULL,  m_szDomain, NULL,  NULL, DS_IS_FLAT_NAME, &pDCInfo);
            if (dwErr != NO_ERROR)
                return E_FAIL;

            // Get the user's detailed information (we really need full name and comment)
            // Need to use level 11 here since this allows a domain user to query their
            // information

            status = NetUserGetInfo(T2W(pDCInfo->DomainControllerName), T2W(m_szUsername), 11, (BYTE**)&pusri11);   
            NetApiBufferFree(pDCInfo);
        }
        else
#endif //0
        {
            status = NetUserGetInfo(NULL, T2W(m_szUsername), 11, (BYTE**)&pusri11);
        }

        if (status != NERR_Success)
            return E_FAIL;

        lstrcpyn(m_szComment, W2T(pusri11->usri11_comment), ARRAYSIZE(m_szComment));
        lstrcpyn(m_szFullName, W2T(pusri11->usri11_full_name), ARRAYSIZE(m_szFullName));

        NetApiBufferFree(pusri11);
    }
    return S_OK;
}

// ChangeLocalGroups
// Removes the specified user from all current local groups and adds them to the
// SINGLE local group specified in pUserInfo->szGroups
HRESULT CUserInfo::ChangeLocalGroups(HWND hwndError, GROUPPSEUDONYM grouppseudonym)
{
    // First, remove the user from all existing local groups
    HRESULT hr = RemoveFromLocalGroups();
    if (SUCCEEDED(hr))
    {
        TCHAR szDomainAndUser[MAX_USER + MAX_DOMAIN + 2];
        ::MakeDomainUserString(m_szDomain, m_szUsername, szDomainAndUser, ARRAYSIZE(szDomainAndUser));

        // Create a data structure we'll need to pass to NetLocalGroupxxx functions
        LOCALGROUP_MEMBERS_INFO_3 rglgrmi3[] = {{szDomainAndUser}};
    
        // Now add the user to the SINGLE localgroup that should be specified in 
        // m_szGroups; Assert this is the case!
        NET_API_STATUS status = NetLocalGroupAddMembers(NULL, T2W(m_szGroups), 3, 
                                                            (BYTE*) rglgrmi3, ARRAYSIZE(rglgrmi3));
        if (status == NERR_Success)
        {
            // We may now need to get the user's SID. This happens if we are
            // changing local groups for a domain user and we couldn't read their
            // SID since they weren't in the local SAM.

            DWORD cchDomain = ARRAYSIZE(m_szDomain);
            hr = ::AttemptLookupAccountName(szDomainAndUser, &m_psid, m_szDomain, &cchDomain, &m_sUse);
            if (FAILED(hr))
            {
                ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_CREATE_MISC_ERROR, MB_ICONERROR | MB_OK);
            }
        }
        else
        {
            switch(status)
            {
                case ERROR_NO_SUCH_MEMBER:
                {
                    switch (grouppseudonym)
                    {
                        case RESTRICTED:
                            ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, 
                                                    IDS_BADRESTRICTEDUSER, MB_ICONERROR | MB_OK, szDomainAndUser);
                            break;
    
                        case STANDARD:
                            ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, 
                                                    IDS_BADSTANDARDUSER, MB_ICONERROR | MB_OK, szDomainAndUser);
                            break;
    
                        case USEGROUPNAME:
                        default:
                            ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION,
                                                    IDS_USR_CHANGEGROUP_ERR, MB_ICONERROR | MB_OK, szDomainAndUser, m_szGroups);
                            break;
                    }
                    break;
                }

                default:
                {
                    TCHAR szMessage[512];

                    if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD) status, 0, szMessage, ARRAYSIZE(szMessage), NULL))
                        LoadString(g_hinst, IDS_ERR_UNEXPECTED, szMessage, ARRAYSIZE(szMessage));

                    ::DisplayFormatMessage(hwndError, IDS_USR_APPLET_CAPTION, IDS_ERR_ADDUSER, MB_ICONERROR | MB_OK, szMessage);
                }            
            }            
            hr = E_FAIL;
        }
    }
    
    return hr;;
}

HRESULT CUserInfo::UpdateUsername(LPTSTR pszNewUsername)
{
    CWaitCursor cur;

    USER_INFO_0 usri0;
    usri0.usri0_name = T2W(pszNewUsername);

    DWORD dwErr;
    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 0, (BYTE*) &usri0, &dwErr);
    if (status != NERR_Success)
        return E_FAIL;

    lstrcpyn(m_szUsername, pszNewUsername, ARRAYSIZE(m_szUsername));
    return S_OK;
}

HRESULT CUserInfo::UpdateFullName(LPTSTR pszFullName)
{
    CWaitCursor cur;

    USER_INFO_1011 usri1011;
    usri1011.usri1011_full_name = T2W(pszFullName);
    DWORD dwErr;

    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 1011, (BYTE*) &usri1011, &dwErr);
    if (status != NERR_Success)
        return E_FAIL;

    lstrcpyn(m_szFullName, pszFullName, ARRAYSIZE(m_szFullName));
    return S_OK;
}

HRESULT CUserInfo::UpdatePassword(BOOL* pfBadPWFormat)
{
    CWaitCursor cur;

    RevealPassword();

    USER_INFO_1003 usri1003;
    usri1003.usri1003_password = T2W(m_szPasswordBuffer);

    DWORD dwErr;
    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 1003, (BYTE*)&usri1003, &dwErr);

    ZeroPassword();     // Kill the password

    if (pfBadPWFormat != NULL)
        *pfBadPWFormat = (status == NERR_PasswordTooShort);

    return (status == NERR_Success) ? S_OK:E_FAIL;
}

HRESULT CUserInfo::UpdateGroup(HWND hwndError, LPTSTR pszGroup, GROUPPSEUDONYM grouppseudonym)
{
    CWaitCursor cur;

    // Save the old group before we change it
    TCHAR szOldGroups[MAX_GROUP * 2 + 3];
    lstrcpyn(szOldGroups, m_szGroups, ARRAYSIZE(szOldGroups));

    // Try to change the local group
    lstrcpyn(m_szGroups, pszGroup, ARRAYSIZE(m_szGroups));
    HRESULT hr = ChangeLocalGroups(hwndError, grouppseudonym);

    if (FAILED(hr))
        lstrcpyn(m_szGroups, szOldGroups, ARRAYSIZE(m_szGroups));           // Restore the old group in case of failure

    return hr;
}

HRESULT CUserInfo::UpdateDescription(LPTSTR pszDescription)
{
    CWaitCursor cur;

    USER_INFO_1007 usri1007;
    usri1007.usri1007_comment = T2W(pszDescription);

    DWORD dwErr;
    NET_API_STATUS status = NetUserSetInfo(NULL, T2W(m_szUsername), 1007,  (BYTE*) &usri1007, &dwErr);

    if (status != NERR_Success)
        return E_FAIL;

    lstrcpyn(m_szComment, pszDescription, ARRAYSIZE(m_szComment));
    return S_OK;
}

void CUserInfo::HidePassword()
{
    m_Seed = 0;
    RtlInitUnicodeString(&m_Password, m_szPasswordBuffer);
    RtlRunEncodeUnicodeString(&m_Seed, &m_Password);
}

void CUserInfo::RevealPassword()
{
    RtlRunDecodeUnicodeString(m_Seed, &m_Password);
}

void CUserInfo::ZeroPassword()
{
    ZeroMemory(m_szPasswordBuffer, ARRAYSIZE(m_szPasswordBuffer));
}


/*******************************************************************
 CUserListLoader implementation
*******************************************************************/

CUserListLoader::CUserListLoader()
{
    m_hInitDoneEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
}

CUserListLoader::~CUserListLoader()
{
    EndInitNow();
    WaitForSingleObject(m_hInitDoneEvent, INFINITE);
}

BOOL CUserListLoader::HasUserBeenAdded(PSID psid)
{
    // Walk the user list looking for a given username and domain
    CUserInfo* pUserInfo = NULL;
    BOOL fFound = FALSE;
    for (int i = 0; i < m_dpaAddedUsers.GetPtrCount(); i ++)
    {
        pUserInfo = m_dpaAddedUsers.GetPtr(i);
        if (pUserInfo->m_psid && psid && EqualSid(pUserInfo->m_psid, psid))
        {
            fFound = TRUE;
            break;
        }
    }
    return fFound;
}

HRESULT CUserListLoader::Initialize(HWND hwndUserListPage)
{
    USES_CONVERSION;    
    
    // Tell any existing init thread to exit and wait for it to do so
    m_fEndInitNow = TRUE;
    WaitForSingleObject(m_hInitDoneEvent, INFINITE);
    ResetEvent(m_hInitDoneEvent);

    m_fEndInitNow = FALSE;
    m_hwndUserListPage = hwndUserListPage;

    // Launch the initialize thread
    DWORD InitThreadId;
    HANDLE hInitThread = CreateThread(NULL, 0, CUserListLoader::InitializeThread, (LPVOID) this, 0, &InitThreadId);
    if (hInitThread == NULL)
        return E_FAIL;

    CloseHandle(hInitThread);           // Let this thread go about his/her merry way
    return S_OK;
}

HRESULT CUserListLoader::UpdateFromLocalGroup(LPWSTR szLocalGroup)
{
    USES_CONVERSION;
    DWORD_PTR dwResumeHandle = 0;

    HRESULT hr = S_OK;
    BOOL fBreakLoop = FALSE;
    while(!fBreakLoop)
    {
        LOCALGROUP_MEMBERS_INFO_0* prgMembersInfo;
        DWORD dwEntriesRead = 0;
        DWORD dwTotalEntries = 0;

        NET_API_STATUS status = NetLocalGroupGetMembers(NULL, szLocalGroup, 0, (BYTE**) &prgMembersInfo,        
                                                         8192, &dwEntriesRead, 
                                                         &dwTotalEntries, &dwResumeHandle);
    
        if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
        {
            // for all the members in the structure, lets add them
            DWORD iMember;
            for (iMember = 0; ((iMember < dwEntriesRead) && (!m_fEndInitNow)); iMember ++)
            {
                hr = AddUserInformation(prgMembersInfo[iMember].lgrmi0_sid);
            }

            NetApiBufferFree((BYTE*) prgMembersInfo);

            // See if we can avoid calling NetLocalGroupGetMembers again
            fBreakLoop = ((dwEntriesRead == dwTotalEntries) || m_fEndInitNow);
        }
        else
        {
            fBreakLoop = TRUE;
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CUserListLoader::AddUserInformation(PSID psid)
{
    // Only add this user if we haven't already
    if (!HasUserBeenAdded(psid))
    {
        CUserInfo *pUserInfo = new CUserInfo;
        if (!pUserInfo)
            return E_OUTOFMEMORY;

        if (SUCCEEDED(pUserInfo->Load(psid, FALSE)))
        {
            PostMessage(m_hwndUserListPage, WM_ADDUSERTOLIST, (WPARAM) FALSE, (LPARAM)pUserInfo);
            m_dpaAddedUsers.AppendPtr(pUserInfo);            // Remember we've added this user
        }
    }
    return S_OK;
}

DWORD CUserListLoader::InitializeThread(LPVOID pvoid)
{
    CUserListLoader *pthis = (CUserListLoader*)pvoid;

    // First delete any old list
    PostMessage(GetDlgItem(pthis->m_hwndUserListPage, IDC_USER_LIST), LVM_DELETEALLITEMS, 0, 0);

    // Create a list of adready-added users so we don't add a user twice
    // if they're in multiple local groups
    if (pthis->m_dpaAddedUsers.Create(8))
    {
        // Read each local group
        DWORD_PTR dwResumeHandle = 0;

        BOOL fBreakLoop = FALSE;
        while (!fBreakLoop)
        {
            DWORD dwEntriesRead = 0;
            DWORD dwTotalEntries = 0;
            LOCALGROUP_INFO_1* prgGroupInfo;
            NET_API_STATUS status = NetLocalGroupEnum(NULL, 1, (BYTE**) &prgGroupInfo, 
                                                      8192, &dwEntriesRead, &dwTotalEntries, 
                                                      &dwResumeHandle);

            if ((status == NERR_Success) || (status == ERROR_MORE_DATA))
            {
                // We got some local groups - add information for all users in these local groups to our list
                DWORD iGroup;
                for (iGroup = 0; ((iGroup < dwEntriesRead) && (!pthis->m_fEndInitNow)); iGroup ++)
                {
                    pthis->UpdateFromLocalGroup(prgGroupInfo[iGroup].lgrpi1_name);
                }

                NetApiBufferFree((BYTE*) prgGroupInfo);
    
                // Maybe we don't have to try NetLocalGroupEnum again (if we got all the groups)
                fBreakLoop = ((dwEntriesRead == dwTotalEntries) || pthis->m_fEndInitNow);
            }
            else
            {
                fBreakLoop = TRUE;
            }
        }

        // Its okay to orphan any CUserInfo pointers stored here; they'll be
        // released when the ulistpg exits or reinits.
        pthis->m_dpaAddedUsers.Destroy();
    }

    SetEvent(pthis->m_hInitDoneEvent);
    SetCursor(LoadCursor(NULL, IDC_ARROW));
    return 0;
}

// User utility functions

BOOL UserAlreadyHasPermission(CUserInfo* pUserInfo, HWND hwndMsgParent)
{
    TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
    ::MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

    BOOL fHasPermission = FALSE;

    // See if this user is already in local groups on this machine
    DWORD dwEntriesRead, dwIgnore2;
    LOCALGROUP_USERS_INFO_0* plgrui0 = NULL;
    if (NERR_Success == NetUserGetLocalGroups(NULL, szDomainUser, 0, 0, 
                                                (LPBYTE*)&plgrui0, 8192, 
                                                &dwEntriesRead, &dwIgnore2))
    {
        fHasPermission = (0 != dwEntriesRead);
        NetApiBufferFree((LPVOID) plgrui0);
    }

    if ((NULL != hwndMsgParent) && (fHasPermission))
    {
        // Display an error; the user doesn't have permission
        TCHAR szDomainUser[MAX_DOMAIN + MAX_USER + 2];
        MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, 
                                szDomainUser, ARRAYSIZE(szDomainUser));

        DisplayFormatMessage(hwndMsgParent, IDS_USR_NEWUSERWIZARD_CAPTION, 
                                IDS_USR_CREATE_USEREXISTS_ERROR, MB_OK | MB_ICONINFORMATION, 
                                szDomainUser);
    }

    return fHasPermission;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\pubwiz.h ===
HRESULT GetStrFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPTSTR pszBuffer, int cch);
HRESULT SetAttributeFromStr(IXMLDOMNode *pdn, LPCTSTR pszAttribute, LPCTSTR pszValue);
HRESULT GetIntFromAttribute(IXMLDOMNode *pdn, LPCTSTR pszAttribute, int *piValue);
HRESULT CreateElement(IXMLDOMDocument *pdoc, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelResult);
HRESULT CreateAndAppendElement(IXMLDOMDocument *pdoc, IXMLDOMNode *pdnParent, LPCTSTR pszName, VARIANT *pvar, IXMLDOMElement **ppdelOut);
void SpewXML(IUnknown *punk);
HRESULT GetURLFromElement(IXMLDOMNode *pdn, LPCTSTR pszElement, LPTSTR pszBuffer, int cch);
DWORD SHWNetGetConnection(LPCWSTR lpLocalName, LPCTSTR lpRemoteName, LPDWORD lpnLength);


// used to communicate between the transfer logic and the main page.

#define PWM_UPDATE              WM_APP+1
#define PWM_TRANSFERCOMPLETE    WM_APP+2
#define PWM_UPDATEICON          WM_APP+3


// transfer manifest information, this is used to communicate between the site and the publishing
// wizard to move the files between the local storage and the site.

// <transfermanfiest>
//      <folderlist>
//          <folder destination="xyz"/>
//      </folderlist>
//      <filelist [usesfolders=-1]/>
//          <file id=x source="path" size="xyz" destination="xyz" extension=".jpg">
//              [<resize cx=<width> cy=<height> quality=<0-100>>]
//              <metadata>
//                  <imageproperty id=""></imageproperty>
//              </metadata>    
//              <post href="href" name="<name section>" [verb=""] [filename="filename"]
//                  <formdata name="<name section>"></formdata>
//              </post>
//      </filelist>
//      <uploadinfo friendlyname="site name">
//          <target [username="username"] href="http://www.diz.com</target"/>
//          <netplace filename="filename" comment="link comment" href="http:/www.diz.com"/>
//          <htmlui href="href://toopenwhenwizardcloses"/>
//          <successpage href="http://www.diz.com/uploadok.htm"/>
//          <favorite href="http://somesite.com" filename="" comment=""/>
//          <failurepage href="http://www.diz.com/uploadok.htm/">
//      </uploadinfo>
// </transfermanifest>

#define ELEMENT_TRANSFERMANIFEST        L"transfermanifest"

#define ELEMENT_FOLDERS                 L"folderlist"

#define ELEMENT_FOLDER                  L"folder"
#define ATTRIBUTE_DESTINATION           L"destination"

#define ELEMENT_FILES                   L"filelist"
#define ATTRIBUTE_HASFOLDERS            L"usesfolders"

#define ELEMENT_FILE                    L"file"             
#define ATTRIBUTE_ID                    L"id"
#define ATTRIBUTE_EXTENSION             L"extension"
#define ATTRIBUTE_CONTENTTYPE           L"contenttype"
#define ATTRIBUTE_SIZE                  L"size"
#define ATTRIBUTE_SOURCE                L"source"
#define ATTRIBUTE_DESTINATION           L"destination"

#define ELEMENT_METADATA                L"metadata"

#define ELEMENT_IMAGEDATA               L"imageproperty"
#define ATTRIBUTE_ID                    L"id"

#define ELEMENT_RESIZE                  L"resize"
#define ATTRIBUTE_CX                    L"cx"
#define ATTRIBUTE_CY                    L"cy"
#define ATTRIBUTE_QUALITY               L"quality"

#define ELEMENT_POSTDATA                L"post"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_VERB                  L"verb"
#define ATTRIBUTE_NAME                  L"name"
#define ATTRIBUTE_FILENAME              L"filename"

#define ELEMENT_FORMDATA                L"formdata"
#define ATTRIBUTE_NAME                  L"name"

#define ELEMENT_UPLOADINFO              L"uploadinfo"
#define ATTRIBUTE_FRIENDLYNAME          L"friendlyname"

#define ELEMENT_TARGET                  L"target"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_USERNAME              L"username"

#define ELEMENT_NETPLACE                L"netplace"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_FILENAME              L"filename"
#define ATTRIBUTE_COMMENT               L"comment"

#define ELEMENT_HTMLUI                  L"htmlui"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_PUBLISHWIZARD           L"publishwizard"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_SUCCESSPAGE             L"successpage"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_FAILUREPAGE             L"failurepage"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_CANCELLEDPAGE           L"cancelledpage"
#define ATTRIBUTE_HREF                  L"href"

#define ELEMENT_FAVORITE                L"favorite"
#define ATTRIBUTE_HREF                  L"href"
#define ATTRIBUTE_NAME                  L"name"
#define ATTRIBUTE_COMMENT               L"comment"    


// xpaths for common items

#define XPATH_MANIFEST                  ELEMENT_TRANSFERMANIFEST 
#define XPATH_FOLDERSROOT               ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_FOLDERS
#define XPATH_FILESROOT                 ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_FILES
#define XPATH_ALLFILESTOUPLOAD          ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_FILES L"/" ELEMENT_FILE
#define XPATH_UPLOADINFO                ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_UPLOADINFO
#define XPATH_UPLOADTARGET              ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_UPLOADINFO  L"/" ELEMENT_TARGET
#define XPATH_PUBLISHWIZARD             ELEMENT_TRANSFERMANIFEST L"/" ELEMENT_PUBLISHWIZARD


// stuff relating to the file transfer engine

typedef struct
{
    HWND hwnd;                                      // parent HWND for any messages / dialogs
    DWORD dwFlags;                                  // flags from original wizard ::SetOptions

    BOOL fUsePost;                                  // use post to transfer the bits

    TCHAR szSiteName[MAX_PATH];                     // site name - shown in wizard
    TCHAR szSiteURL[MAX_PATH];                      // site URL - opened in the browser

    TCHAR szFileTarget[INTERNET_MAX_URL_LENGTH];    // destination for file copy

    TCHAR szLinkTarget[INTERNET_MAX_URL_LENGTH];    // destination for favorites link etc
    TCHAR szLinkName[MAX_PATH];
    TCHAR szLinkDesc[MAX_PATH];
} TRANSFERINFO;

typedef struct
{
    VARIANT varName;                                // name of the form value
    VARIANT varValue;                               // its value
} FORMDATA;

typedef struct
{
    BOOL fResizeOnUpload;                           // this item should be resized

    LPITEMIDLIST pidl;                              // pidl of the item we are posting    
    TCHAR szFilename[MAX_PATH];                     // filename to associate with the object

    TCHAR szVerb[10];                               // verb used for transfer
    TCHAR szName[MAX_PATH];                         // name for the object we are posting 
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];           // destination for file copy
    CDSA<FORMDATA> dsaFormData;                     // form data for extra information published

    int cxResize;                                   // height and width of item for resizing
    int cyResize;
    int iQuality;

    IShellItem *psi;                                // shell item for each of the objects
    IStream *pstrm;                                 // posting stream (for file bits)
    STATSTG ststg;                                  // stat of the file
} TRANSFERITEM;


// post engines which handle the transfer of files accordingly

int _FreeTransferItems(TRANSFERITEM *pti, void *pvState = NULL);
HRESULT PublishViaCopyEngine(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
HRESULT PublishViaPost(TRANSFERINFO *pti, CDPA<TRANSFERITEM> *pdpaItems, ITransferAdviseSink *ptas);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Map Network Drives/Network Places Wizard"
#define VER_INTERNALNAME_STR            "netplwiz"
#define VER_LEGALCOPYRIGHT_YEARS        "1998"
#define VER_ORIGINALFILENAME_STR        "netplwiz.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\netplwiz\usercpl.cpp ===
#include "stdafx.h"
#include "grpinfo.h"
#include "unpage.h"
#include "netpage.h"
#include "password.h"
#include "cryptui.h"        // for certificate mgr
#pragma hdrstop


// Certificate Manager helper static functions and delay-load stuff
class CCertificateAPI
{
public:
    static BOOL ManagePasswords(HWND hwnd);
    static BOOL Wizard(HWND hwnd);

private:
    static BOOL m_fFailed;
    static HINSTANCE m_hInstCryptUI;
};

BOOL CCertificateAPI::m_fFailed = FALSE;
HINSTANCE CCertificateAPI::m_hInstCryptUI = NULL;


// CCertificateAPI::ManagePasswords - launch certificate manager
typedef BOOL (WINAPI *PFNCRYPTUIDLGCERTMGR)(IN PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr);
BOOL CCertificateAPI::ManagePasswords(HWND hwnd)
{
    // Use shellexecuteex to open up the keyring control panel
    SHELLEXECUTEINFO shexinfo = {0};
    shexinfo.cbSize = sizeof (shexinfo);
    shexinfo.fMask = SEE_MASK_DOENVSUBST;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpFile = L"%windir%\\system32\\rundll32.exe";
    shexinfo.lpParameters = L"shell32.dll,Control_RunDLL keymgr.dll";
    shexinfo.lpVerb = TEXT("open");

    return ShellExecuteEx(&shexinfo);
}


// CCertificateAPI::Wizard - launch the enrollment wizard

typedef BOOL (WINAPI *PFNCRYPTUIWIZCERTREQUEST)(IN DWORD dwFlags,
                                                IN OPTIONAL HWND, IN OPTIONAL LPCWSTR pwszWizardTitle,
                                                IN PCCRYPTUI_WIZ_CERT_REQUEST_INFO pCertRequestInfo,
                                                OUT OPTIONAL PCCERT_CONTEXT *ppCertContext, 
                                                OUT OPTIONAL DWORD *pCAdwStatus);

BOOL CCertificateAPI::Wizard(HWND hwnd)
{
    static PFNCRYPTUIWIZCERTREQUEST pCryptUIWizCertRequest = NULL;

    if ((m_hInstCryptUI == NULL) && (!m_fFailed))
    {
        m_hInstCryptUI = LoadLibrary(TEXT("cryptui.dll"));
    }

    if (m_hInstCryptUI != NULL)
    {
        pCryptUIWizCertRequest = (PFNCRYPTUIWIZCERTREQUEST)
            GetProcAddress(m_hInstCryptUI, "CryptUIWizCertRequest");
    }

    if (pCryptUIWizCertRequest)
    {
        CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW CertRequestPvkNew = {0};
        CertRequestPvkNew.dwSize=sizeof(CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW); 

        CRYPTUI_WIZ_CERT_REQUEST_INFO CertRequestInfo = {0}; 
        CertRequestInfo.dwSize=sizeof(CRYPTUI_WIZ_CERT_REQUEST_INFO);
        CertRequestInfo.dwPurpose=CRYPTUI_WIZ_CERT_ENROLL;
        CertRequestInfo.dwPvkChoice=CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
        CertRequestInfo.pPvkNew=&CertRequestPvkNew;

        // This can take a while!
        CWaitCursor cur;
        pCryptUIWizCertRequest(0, hwnd, NULL, &CertRequestInfo, NULL, NULL);  
    }
    else
    {
        m_fFailed = TRUE;
    }
    
    return (!m_fFailed);
}


// handle auto logon of users

class CAutologonUserDlg: public CDialog
{
public:
    CAutologonUserDlg(LPTSTR szInitialUser)
        {m_pszUsername = szInitialUser;}

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

    LPTSTR m_pszUsername;
};


INT_PTR CAutologonUserDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
    }

    return FALSE;
}

BOOL CAutologonUserDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    HWND hwndPassword = GetDlgItem(hwnd, IDC_PASSWORD);
    HWND hwndConfirm = GetDlgItem(hwnd, IDC_CONFIRMPASSWORD);

    // limit the text with of the controls
    Edit_LimitText(hwndUsername, MAX_USER);
    Edit_LimitText(hwndPassword, MAX_PASSWORD);
    Edit_LimitText(hwndConfirm, MAX_PASSWORD);

    // Populate the username field and set focus to password
    SetWindowText(hwndUsername, m_pszUsername);
    SetFocus(hwndPassword);
    BOOL fSetDefaultFocus = FALSE;

    return (fSetDefaultFocus);
}

BOOL CAutologonUserDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            {
                TCHAR szUsername[MAX_USER + 1];
                TCHAR szPassword[MAX_PASSWORD + 1];
                TCHAR szConfirm[MAX_PASSWORD + 1];

                FetchText(hwnd, IDC_USER, szUsername, ARRAYSIZE(szUsername));
                GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
                GetWindowText(GetDlgItem(hwnd, IDC_CONFIRMPASSWORD), szConfirm, ARRAYSIZE(szConfirm));

                if (StrCmp(szConfirm, szPassword) != 0)
                {
                    // Display a message saying the passwords don't match
                    DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_ERR_PWDNOMATCH, MB_OK | MB_ICONERROR);
                    break;
                }
                else
                {
                    // Actually apply the autologon
                    SetAutoLogon(szUsername, szPassword);
                    ZeroMemory(szPassword, ARRAYSIZE(szPassword));
                }
            }
        
            // Fall through
        case IDCANCEL:
            EndDialog(hwnd, id);
    }

    return (TRUE);
}


// user list page (the main page the user sees)

class CUserlistPropertyPage: public CPropertyPage
{
public:
    CUserlistPropertyPage(CUserManagerData* pdata): m_pData(pdata) 
        {m_himlLarge = NULL;}
    ~CUserlistPropertyPage();

    static HRESULT AddUserToListView(HWND hwndList, CUserInfo* pUserInfo, BOOL fSelectUser = FALSE);

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnGetInfoTip(HWND hwndList, LPNMLVGETINFOTIP pGetInfoTip);
    BOOL OnListViewItemChanged(HWND hwnd);
    BOOL OnListViewDeleteItem(HWND hwndList, int iItem);
    BOOL OnHelp(HWND hwnd, LPHELPINFO pHelpInfo);
    BOOL OnContextMenu(HWND hwnd);
    BOOL OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg);
    long OnApply(HWND hwnd);
    HRESULT InitializeListView(HWND hwndList, BOOL fShowDomain);
    HRESULT LaunchNewUserWizard(HWND hwndParent);
    HRESULT LaunchAddNetUserWizard(HWND hwndParent);
    HRESULT LaunchUserProperties(HWND hwndParent);
    HRESULT LaunchSetPasswordDialog(HWND hwndParent);
    CUserInfo* GetSelectedUserInfo(HWND hwndList);
    void OnRemove(HWND hwnd);
    int ConfirmRemove(HWND hwnd, CUserInfo* pUserInfo);
    void RemoveSelectedUserFromList(HWND hwndList, BOOL fFreeUserInfo);
    void SetPageState(HWND hwnd);
    HRESULT SetAutologonState(HWND hwnd, BOOL fAutologon);
    void SetupList(HWND hwnd);
    HPSXA AddExtraUserPropPages(ADDPROPSHEETDATA* ppsd, PSID psid);
    
    static int CALLBACK ListCompare(LPARAM lParam1, LPARAM lParam2, 
	    LPARAM lParamSort);

    CUserManagerData* m_pData;
    HIMAGELIST m_himlLarge;

    // When a column header is clicked, the list is sorted based on that column
    // When this happens, we store the column number here so that if the same
    // column is clicked again, we sort it in reverse. A 0 is stored if no
    // column should be sorted in reverse when clicked.
    int m_iReverseColumnIfSelected;

    BOOL m_fAutologonCheckChanged;
};


// Help ID array
static const DWORD rgUserListHelpIds[] =
{
    IDC_AUTOLOGON_CHECK,        IDH_AUTOLOGON_CHECK,
    IDC_LISTTITLE_STATIC,       IDH_USER_LIST,
    IDC_USER_LIST,              IDH_USER_LIST,
    IDC_ADDUSER_BUTTON,         IDH_ADDUSER_BUTTON,
    IDC_REMOVEUSER_BUTTON,      IDH_REMOVEUSER_BUTTON,
    IDC_USERPROPERTIES_BUTTON,  IDH_USERPROPERTIES_BUTTON,
    IDC_PASSWORD_STATIC,        IDH_PASSWORD_BUTTON,
    IDC_CURRENTUSER_ICON,       IDH_PASSWORD_BUTTON,
    IDC_PASSWORD_BUTTON,        IDH_PASSWORD_BUTTON,
    IDC_PWGROUP_STATIC,         (DWORD) -1,
    IDC_ULISTPG_TEXT,           (DWORD) -1,
    IDC_USERLISTPAGE_ICON,      (DWORD) -1,
    0, 0
};

// Control ID arrays for enabling/disabling/moving
static const UINT rgidDisableOnAutologon[] =
{
    IDC_USER_LIST,
    IDC_ADDUSER_BUTTON,
    IDC_REMOVEUSER_BUTTON,
    IDC_USERPROPERTIES_BUTTON,
    IDC_PASSWORD_BUTTON
};

static const UINT rgidDisableOnNoSelection[] =
{
    IDC_REMOVEUSER_BUTTON,
    IDC_USERPROPERTIES_BUTTON,
    IDC_PASSWORD_BUTTON
};

static const UINT rgidMoveOnNoAutologonCheck[] =
{
    IDC_LISTTITLE_STATIC,
    IDC_USER_LIST,
    // IDC_ADDUSER_BUTTON,
    // IDC_e_BUTTON,
    // IDC_USERPROPERTIES_BUTTON,
    // IDC_PWGROUP_STATIC,
    // IDC_CURRENTUSER_ICON,
    // IDC_PASSWORD_STATIC,
    // IDC_PASSWORD_BUTTON
};

CUserlistPropertyPage::~CUserlistPropertyPage()
{
    if (m_himlLarge != NULL)
        ImageList_Destroy(m_himlLarge);
}

INT_PTR CUserlistPropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_SETCURSOR, OnSetCursor);

        case WM_HELP: 
            return OnHelp(hwndDlg, (LPHELPINFO) lParam);

        case WM_CONTEXTMENU: 
            return OnContextMenu((HWND) wParam);

        case WM_ADDUSERTOLIST: 
            return SUCCEEDED(AddUserToListView(GetDlgItem(hwndDlg, IDC_USER_LIST), (CUserInfo*)lParam, (BOOL) wParam));
    }
    
    return FALSE;
}

BOOL CUserlistPropertyPage::OnHelp(HWND hwnd, LPHELPINFO pHelpInfo)
{
    WinHelp((HWND) pHelpInfo->hItemHandle, m_pData->GetHelpfilePath(), 
                    HELP_WM_HELP, (ULONG_PTR) (LPTSTR)rgUserListHelpIds);

    return TRUE;
}

BOOL CUserlistPropertyPage::OnContextMenu(HWND hwnd)
{
    WinHelp(hwnd, m_pData->GetHelpfilePath(), 
                    HELP_CONTEXTMENU, (ULONG_PTR) (LPTSTR)rgUserListHelpIds);

    return TRUE;
}

BOOL CUserlistPropertyPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);
    InitializeListView(hwndList, m_pData->IsComputerInDomain());
    m_pData->Initialize(hwnd);

    SetupList(hwnd);
    
    m_fAutologonCheckChanged = FALSE;

    return TRUE;
}

BOOL CUserlistPropertyPage::OnListViewDeleteItem(HWND hwndList, int iItem)
{
    LVITEM lvi = {0};
    lvi.iItem = iItem;
    lvi.mask = LVIF_PARAM;
    ListView_GetItem(hwndList, &lvi);

    CUserInfo* pUserInfo = (CUserInfo*)lvi.lParam;
    if (NULL != pUserInfo)
    {
        delete pUserInfo;
    }
    return TRUE;
}

BOOL CUserlistPropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    switch (pnmh->code)
    {
        case PSN_APPLY:
        {
            long applyEffect = OnApply(hwnd);
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, applyEffect);
            break;
        }

        case LVN_GETINFOTIP:
            return OnGetInfoTip(pnmh->hwndFrom, (LPNMLVGETINFOTIP) pnmh);
            break;

        case LVN_ITEMCHANGED:
            return OnListViewItemChanged(hwnd);
            break;

        case LVN_DELETEITEM:
            return OnListViewDeleteItem(GetDlgItem(hwnd, IDC_USER_LIST), ((LPNMLISTVIEW) pnmh)->iItem);

        case NM_DBLCLK:
            LaunchUserProperties(hwnd);
            return TRUE;

        case LVN_COLUMNCLICK:
        {
            int iColumn = ((LPNMLISTVIEW) pnmh)->iSubItem;
        
            // Want to work with 1-based columns so we can use zero as
            // a special value
            iColumn += 1;

            // If we aren't showing the domain column because we're in
            // non-domain mode, then map column 2 (group since we're not in
            // domain mode to column 3 since the callback always expects 
            // the columns to be, "username", "domain", "group".
            if ((iColumn == 2) && (!m_pData->IsComputerInDomain()))
            {
                iColumn = 3;
            }

            if (m_iReverseColumnIfSelected == iColumn)
            {
                m_iReverseColumnIfSelected = 0;
                iColumn = -iColumn;
            }
            else
            {
                m_iReverseColumnIfSelected = iColumn;
            }

            ListView_SortItems(pnmh->hwndFrom, ListCompare, (LPARAM) iColumn);
            return TRUE;
        }

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL CUserlistPropertyPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDC_ADDUSER_BUTTON:
            if (m_pData->IsComputerInDomain())
            {
                // Launch the wizard to add a network user to a local group
                LaunchAddNetUserWizard(hwnd);
            }
            else
            {
                // No domain; create a new local machine user
                LaunchNewUserWizard(hwnd);
            }
            return TRUE;

        case IDC_REMOVEUSER_BUTTON:
            OnRemove(hwnd);
            return TRUE;
        
        case IDC_AUTOLOGON_CHECK:
        {
            m_fAutologonCheckChanged = TRUE;
            BOOL fAutoLogon = (BST_UNCHECKED == SendMessage(GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK), BM_GETCHECK, 0, 0));
            SetAutologonState(hwnd, fAutoLogon);
            SetPageState(hwnd);
            break;
        }

        case IDC_ADVANCED_BUTTON:
        {
            // Consider using env. vars and ExpandEnvironmentString here
            static const TCHAR szMMCCommandLineFormat[] = TEXT("mmc.exe /computer=%s %%systemroot%%\\system32\\lusrmgr.msc");
        
            TCHAR szMMCCommandLine[MAX_PATH];
            TCHAR szExpandedCommandLine[MAX_PATH];

            wnsprintf(szMMCCommandLine, ARRAYSIZE(szMMCCommandLine), szMMCCommandLineFormat, m_pData->GetComputerName());
            if (ExpandEnvironmentStrings(szMMCCommandLine, szExpandedCommandLine,  ARRAYSIZE(szExpandedCommandLine)) > 0)
            {
                PROCESS_INFORMATION pi;
                STARTUPINFO si = {0};
                si.cb = sizeof (si);
                if (CreateProcess(NULL, szExpandedCommandLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
                {
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
            break;
        }

        case IDC_PASSWORD_BUTTON:
            LaunchSetPasswordDialog(hwnd);
            break;

        case IDC_USERPROPERTIES_BUTTON:
            LaunchUserProperties(hwnd);
            break;
    }

    return FALSE;
}

BOOL CUserlistPropertyPage::OnSetCursor(HWND hwnd, HWND hwndCursor, UINT codeHitTest, UINT msg)
{
    BOOL fHandled = FALSE;

    if (m_pData->GetUserListLoader()->InitInProgress())
    {
        // If the thread is filling, handle by setting the appstarting cursor
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        fHandled = TRUE;
    }

    SetWindowLongPtr(hwnd, DWLP_MSGRESULT, fHandled);
    return TRUE;
}


BOOL CUserlistPropertyPage::OnGetInfoTip(HWND hwndList, LPNMLVGETINFOTIP pGetInfoTip)
{
    // Get the UserInfo structure for the selected item
    LVITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pGetInfoTip->iItem;
    lvi.iSubItem = 0;

    if ((lvi.iItem >= 0) && (ListView_GetItem(hwndList, &lvi)))
    {
        // Ensure full name and comment are available
        CUserInfo* pUserInfo = (CUserInfo*)lvi.lParam;
        pUserInfo->GetExtraUserInfo();

        // Make a string containing our "Full Name: %s\nComment: %s" message
        if ((pUserInfo->m_szFullName[0] != TEXT('\0')) &&
                        (pUserInfo->m_szComment[0] != TEXT('\0')))
        {
            // We have a full name and comment
            FormatMessageString(IDS_USR_TOOLTIPBOTH_FORMAT, pGetInfoTip->pszText, pGetInfoTip->cchTextMax, pUserInfo->m_szFullName, pUserInfo->m_szComment);
        }
        else if (pUserInfo->m_szFullName[0] != TEXT('\0'))
        {
            // We only have full name
            FormatMessageString(IDS_USR_TOOLTIPFULLNAME_FORMAT, pGetInfoTip->pszText, pGetInfoTip->cchTextMax, pUserInfo->m_szFullName);
        }
        else if (pUserInfo->m_szComment[0] != TEXT('\0'))
        {
            // We only have comment
            FormatMessageString(IDS_USR_TOOLTIPCOMMENT_FORMAT, pGetInfoTip->pszText, pGetInfoTip->cchTextMax, pUserInfo->m_szComment);
        }
        else
        {
            // We have no extra information - do nothing (show no tip)
        }
    }

    return TRUE;
}

struct MYCOLINFO
{
    int percentWidth;
    UINT idString;
};

HRESULT CUserlistPropertyPage::InitializeListView(HWND hwndList, BOOL fShowDomain)
{
    // Array of icon ids icons 0, 1, and 2 respectively
    static const UINT rgIcons[] = 
    {
        IDI_USR_LOCALUSER_ICON,
        IDI_USR_DOMAINUSER_ICON,
        IDI_USR_GROUP_ICON
    };

    // Array of relative column widths, for columns 0, 1, and 2 respectively
    static const MYCOLINFO rgColWidthsWithDomain[] = 
    {
        {40, IDS_USR_NAME_COLUMN},
        {30, IDS_USR_DOMAIN_COLUMN},
        {30, IDS_USR_GROUP_COLUMN}
    };

    static const MYCOLINFO rgColWidthsNoDomain[] =
    {
        {50, IDS_USR_NAME_COLUMN},
        {50, IDS_USR_GROUP_COLUMN}
    };

    // Create a listview with three columns
    RECT rect;
    GetClientRect(hwndList, &rect);

    // Width of our window minus width of a verticle scroll bar minus one for the
    // little bevel at the far right of the header.
    int cxListView = (rect.right - rect.left) - GetSystemMetrics(SM_CXVSCROLL) - 1;

    // Make our columns
    int i;
    int nColumns; 
    const MYCOLINFO* pColInfo;
    if (fShowDomain)
    {
        nColumns = ARRAYSIZE(rgColWidthsWithDomain);
        pColInfo = rgColWidthsWithDomain;
    }
    else
    {
        nColumns = ARRAYSIZE(rgColWidthsNoDomain);
        pColInfo = rgColWidthsNoDomain;
    }      

    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    for (i = 0; i < nColumns; i++)
    {
        TCHAR szText[MAX_PATH];
        // Load this column's caption
        LoadString(g_hinst, pColInfo[i].idString, szText, ARRAYSIZE(szText));

        lvc.iSubItem = i;
        lvc.cx = (int) MulDiv(pColInfo[i].percentWidth, cxListView, 100);
        lvc.pszText = szText;

        ListView_InsertColumn(hwndList, i, &lvc);
    }

    UINT flags = ILC_MASK;
    if(IS_WINDOW_RTL_MIRRORED(hwndList))
    {
        flags |= ILC_MIRROR;
    }

    // Create an image list for the listview
    HIMAGELIST himlSmall = ImageList_Create(16, 16, flags, 0, ARRAYSIZE(rgIcons));

    // Large image lists for the "set password" group icon
    m_himlLarge = ImageList_Create(32, 32, flags, 0, ARRAYSIZE(rgIcons));
    if (himlSmall && m_himlLarge)
    {
        // Add our icons to the image list
        for(i = 0; i < ARRAYSIZE(rgIcons); i ++)
        {
            HICON hIconSmall = (HICON) LoadImage(g_hinst, MAKEINTRESOURCE(rgIcons[i]), IMAGE_ICON, 16, 16, 0);
            if (hIconSmall)
            {
                ImageList_AddIcon(himlSmall, hIconSmall);
                DestroyIcon(hIconSmall);
            }

            HICON hIconLarge = (HICON) LoadImage(g_hinst, MAKEINTRESOURCE(rgIcons[i]), IMAGE_ICON, 32, 32, 0);
            if (hIconLarge)
            {
                ImageList_AddIcon(m_himlLarge, hIconLarge);
                DestroyIcon(hIconLarge);
            }
        }
    }

    ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);

    // Set extended styles for the listview
    ListView_SetExtendedListViewStyleEx(hwndList, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP, 
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    // Set some settings for our tooltips - stolen from defview.cpp code
    HWND hwndInfoTip = ListView_GetToolTips(hwndList);
    if (hwndInfoTip != NULL)
    {
        //make the tooltip window  to be topmost window
        SetWindowPos(hwndInfoTip, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        // increase the ShowTime (the delay before we show the tooltip) to 2 times the default value
        LRESULT uiShowTime = SendMessage(hwndInfoTip, TTM_GETDELAYTIME, TTDT_INITIAL, 0);
        SendMessage(hwndInfoTip, TTM_SETDELAYTIME, TTDT_INITIAL, uiShowTime * 2);
    }

    return S_OK;
}

HRESULT CUserlistPropertyPage::AddUserToListView(HWND hwndList, 
                                                 CUserInfo* pUserInfo,
                                                 BOOL fSelectUser /* = FALSE */)
{
    if (!pUserInfo->m_fAccountDisabled)
    {
        LVITEM lvi = { 0 };

        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM; 
        lvi.pszText = pUserInfo->m_szUsername;
        lvi.iImage = pUserInfo->m_userType;
        lvi.lParam = (LPARAM) pUserInfo;

        // Always select the first loaded user
        if (ListView_GetItemCount(hwndList) == 0)
            fSelectUser = TRUE;

        if (fSelectUser)
        {
            lvi.mask |= LVIF_STATE;
            lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        }

        int iItem = ListView_InsertItem(hwndList, &lvi);
        if (iItem >= 0)
        {
            if (fSelectUser)
                ListView_EnsureVisible(hwndList, iItem, FALSE);           // Make the item visible

            // Success! Now add the subitems (domain, groups)
            lvi.iItem = iItem;
            lvi.mask = LVIF_TEXT;
    
            // Only add the domain field if the user is in a domain
            if (::IsComputerInDomain())
            {
                lvi.iSubItem = 1;
                lvi.pszText = pUserInfo->m_szDomain;
                ListView_SetItem(hwndList, &lvi);

                // User is in a domain; group should be third column
                lvi.iSubItem = 2;
            }
            else
            {
                // User isn't in a domain, group should be second column
                lvi.iSubItem = 1;
            }

            // Add group regardless of whether user is in a domain
            lvi.pszText = pUserInfo->m_szGroups;
            ListView_SetItem(hwndList, &lvi);
        }
    }

    return S_OK;
}

HRESULT CUserlistPropertyPage::LaunchNewUserWizard(HWND hwndParent)
{
    static const int nPages = 3;
    int cPages = 0;
    HPROPSHEETPAGE rghPages[nPages];

    // Create a new user record
    CUserInfo* pNewUser = new CUserInfo;
    if ( !pNewUser )
    {
        DisplayFormatMessage(hwndParent, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_USR_CREATE_MISC_ERROR, MB_OK | MB_ICONERROR);
        return E_OUTOFMEMORY;
    }

    pNewUser->InitializeForNewUser();
    pNewUser->m_userType = CUserInfo::LOCALUSER;

    PROPSHEETPAGE psp = {0};
    // Common propsheetpage settings
    psp.dwSize = sizeof (psp);
    psp.hInstance = g_hinst;
    psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;

    // Page 1: Username entry page
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERNAME_WIZARD_PAGE);
    CUsernameWizardPage page1(pNewUser);
    page1.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    // Page 2: Password page
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_PASSWORD_WIZARD_PAGE);
    CPasswordWizardPage page2(pNewUser);
    page2.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    // Page 3: Local group addition
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_WIZARD_PAGE);
    CGroupWizardPage page3(pNewUser, m_pData->GetGroupList());
    page3.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    PROPSHEETHEADER psh = {0};
    psh.dwSize = sizeof (psh);
    psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hinst;
    psh.nPages = nPages;
    psh.phpage = rghPages;

    if (PropertySheet(&psh) == IDOK)
    {
        AddUserToListView(GetDlgItem(hwndParent, IDC_USER_LIST), pNewUser, TRUE);
    }
    else
    {
        // User clicked cancel
        delete pNewUser;
        pNewUser = NULL;
    }
    
    return S_OK;
}

HRESULT CUserlistPropertyPage::LaunchAddNetUserWizard(HWND hwndParent)
{
    HRESULT hr = S_OK;

    static const int nPages = 2;
    int cPages = 0;
    HPROPSHEETPAGE rghPages[nPages];

    // Create a new user record
    CUserInfo* pNewUser = new CUserInfo;
    if ( !pNewUser )
    {
        DisplayFormatMessage(hwndParent, IDS_USR_NEWUSERWIZARD_CAPTION, IDS_USR_CREATE_MISC_ERROR, MB_OK | MB_ICONERROR);
        return E_OUTOFMEMORY;
    }

    pNewUser->InitializeForNewUser();
    pNewUser->m_userType = CUserInfo::DOMAINUSER;

    PROPSHEETPAGE psp = {0};
    // Common propsheetpage settings
    psp.dwSize = sizeof (psp);
    psp.hInstance = g_hinst;
    psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;

    // Page 1: Find a network user page
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_FINDNETUSER_WIZARD_PAGE);
    CNetworkUserWizardPage page1(pNewUser);
    page1.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    // Page 2: Local group addition
    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_WIZARD_PAGE);
    CGroupWizardPage page2(pNewUser, m_pData->GetGroupList());
    page2.SetPropSheetPageMembers(&psp);
    rghPages[cPages++] = CreatePropertySheetPage(&psp);

    PROPSHEETHEADER psh = {0};
    psh.dwSize = sizeof (psh);
    psh.dwFlags = PSH_NOCONTEXTHELP | PSH_WIZARD | PSH_WIZARD_LITE;
    psh.hwndParent = hwndParent;
    psh.hInstance = g_hinst;
    psh.nPages = nPages;
    psh.phpage = rghPages;

    if (PropertySheet(&psh) == IDOK)
    {
        AddUserToListView(GetDlgItem(hwndParent, IDC_USER_LIST), pNewUser, TRUE);
        m_pData->UserInfoChanged(pNewUser->m_szUsername, pNewUser->m_szDomain);
    }
    else
    {
        // No errors, but the user clicked Cancel...
        delete pNewUser;
        pNewUser = NULL;
    }

    return S_OK;
}

HRESULT CUserlistPropertyPage::LaunchUserProperties(HWND hwndParent)
{
    HRESULT hr = S_OK;

    // Create a new user record
    HWND hwndList = GetDlgItem(hwndParent, IDC_USER_LIST);
    CUserInfo* pUserInfo = GetSelectedUserInfo(hwndList);
    if (pUserInfo != NULL)
    {
        pUserInfo->GetExtraUserInfo();

        // page addition information
        ADDPROPSHEETDATA apsd;
        apsd.nPages = 0;

        // Common propsheetpage settings
        PROPSHEETPAGE psp = {0};
        psp.dwSize = sizeof (psp);
        psp.hInstance = g_hinst;
        psp.dwFlags = PSP_DEFAULT;

        // If we have a local user, show both the username and group page, ow
        // just the group page
        // Page 1: Username entry page
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERNAME_PROP_PAGE);
        CUsernamePropertyPage page1(pUserInfo);
        page1.SetPropSheetPageMembers(&psp);

        // Only actually create the prop page if we have a local user
        if (pUserInfo->m_userType == CUserInfo::LOCALUSER)
        {
            apsd.rgPages[apsd.nPages++] = CreatePropertySheetPage(&psp);
        }

        // Always add the second page
        // Page 2: Local group addition
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_PROP_PAGE);
        CGroupPropertyPage page2(pUserInfo, m_pData->GetGroupList());
        page2.SetPropSheetPageMembers(&psp);
        apsd.rgPages[apsd.nPages++] = CreatePropertySheetPage(&psp);

        HPSXA hpsxa = AddExtraUserPropPages(&apsd, pUserInfo->m_psid);

        PROPSHEETHEADER psh = {0};
        psh.dwSize = sizeof (psh);
        psh.dwFlags = PSH_DEFAULT | PSH_PROPTITLE;

        TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
        MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));

        psh.pszCaption = szDomainUser;
        psh.hwndParent = hwndParent;
        psh.hInstance = g_hinst;
        psh.nPages = apsd.nPages;
        psh.phpage = apsd.rgPages;
 
        int iRetCode = (int)PropertySheet(&psh);

        if (hpsxa != NULL)
            SHDestroyPropSheetExtArray(hpsxa);

        if (iRetCode == IDOK)
        {
            // PropSheet_Changed(GetParent(hwndParent), hwndParent);

            // So that we don't delete this pUserInfo when we remove
            // this user from the list:
            m_pData->UserInfoChanged(pUserInfo->m_szUsername, (pUserInfo->m_szDomain[0] == 0) ? NULL : pUserInfo->m_szDomain);
            RemoveSelectedUserFromList(hwndList, FALSE);
            AddUserToListView(hwndList, pUserInfo, TRUE);
        }
    }

    return S_OK;
}


CUserInfo* CUserlistPropertyPage::GetSelectedUserInfo(HWND hwndList)
{
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);
    if (iItem >= 0)
    {
        LVITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;
        if (ListView_GetItem(hwndList, &lvi))
        {
            return (CUserInfo*)lvi.lParam;
        }
    }
    return NULL;
}


void CUserlistPropertyPage::RemoveSelectedUserFromList(HWND hwndList, BOOL fFreeUserInfo)
{
    int iItem = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    // If we don't want to delete this user info, better set it to NULL
    if (!fFreeUserInfo)
    {
        LVITEM lvi = {0};
        lvi.iItem = iItem;
        lvi.mask = LVIF_PARAM;
        lvi.lParam = (LPARAM) (CUserInfo*) NULL;
        ListView_SetItem(hwndList, &lvi);
    }

    ListView_DeleteItem(hwndList, iItem);

    int iSelect = iItem > 0 ? iItem - 1 : 0;
    ListView_SetItemState(hwndList, iSelect, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
    
    SetFocus(hwndList);
}


void CUserlistPropertyPage::OnRemove(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);

    CUserInfo* pUserInfo = GetSelectedUserInfo(hwndList);
    if (pUserInfo)
    {
        if (ConfirmRemove(hwnd, pUserInfo) == IDYES)
        {
            if (SUCCEEDED(pUserInfo->Remove()))
            {
                RemoveSelectedUserFromList(hwndList, TRUE);
            }
            else
            {
               TCHAR szDisplayName[MAX_USER + MAX_DOMAIN + 2];
                ::MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, 
                                        szDisplayName, ARRAYSIZE(szDisplayName));

                DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION,
                                        IDS_USR_REMOVE_MISC_ERROR, MB_ICONERROR | MB_OK, szDisplayName);
            }
        }
    }
}

int CUserlistPropertyPage::ConfirmRemove(HWND hwnd, CUserInfo* pUserInfo)
{
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
    MakeDomainUserString(pUserInfo->m_szDomain, pUserInfo->m_szUsername, szDomainUser, ARRAYSIZE(szDomainUser));
    return DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_USR_REMOVEUSER_WARNING, 
                                                    MB_ICONEXCLAMATION | MB_YESNO, szDomainUser);
}

void CUserlistPropertyPage::SetPageState(HWND hwnd)
{
    BOOL fAutologon = (BST_UNCHECKED == 
                SendMessage(GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK), BM_GETCHECK, 0, 0));

    EnableControls(hwnd, rgidDisableOnAutologon, ARRAYSIZE(rgidDisableOnAutologon),
                !fAutologon);

    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);
    CUserInfo* pUserInfo = GetSelectedUserInfo(hwndList);
    if (pUserInfo)
    {
        TCHAR szPWGroup[128];
        FormatMessageString(IDS_USR_PWGROUP_FORMAT, szPWGroup, ARRAYSIZE(szPWGroup), pUserInfo->m_szUsername);
        SetWindowText(GetDlgItem(hwnd, IDC_PWGROUP_STATIC), szPWGroup);

        TCHAR szPWMessage[128];

        // If the logged on user is the selected user
        CUserInfo* pLoggedOnUser = m_pData->GetLoggedOnUserInfo();
        if ((StrCmpI(pUserInfo->m_szUsername, pLoggedOnUser->m_szUsername) == 0) &&
                        (StrCmpI(pUserInfo->m_szDomain, pLoggedOnUser->m_szDomain) == 0))
        {
            LoadString(g_hinst, IDS_USR_YOURPWMESSAGE_FORMAT, szPWMessage, ARRAYSIZE(szPWMessage));
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_BUTTON), FALSE);
        }
        // If the user is a local user
        else if (pUserInfo->m_userType == CUserInfo::LOCALUSER)
        {
            // We can set this user's password
            FormatMessageString(IDS_USR_PWMESSAGE_FORMAT, szPWMessage, ARRAYSIZE(szPWMessage), pUserInfo->m_szUsername);
        }
        else
        {
            // Nothing can be done with this user's password
            // the selected user may be a domain user or a group or something
            // We can set this user's password
            FormatMessageString(IDS_USR_CANTCHANGEPW_FORMAT, szPWMessage, ARRAYSIZE(szPWMessage), pUserInfo->m_szUsername);
            EnableWindow(GetDlgItem(hwnd, IDC_PASSWORD_BUTTON), FALSE);
        }

        SetWindowText(GetDlgItem(hwnd, IDC_PASSWORD_STATIC), szPWMessage);

        // Set the icon for the user
        HICON hIcon = ImageList_GetIcon(m_himlLarge, pUserInfo->m_userType, ILD_NORMAL);
        Static_SetIcon(GetDlgItem(hwnd, IDC_CURRENTUSER_ICON), hIcon);
    }
    else
    {
        EnableControls(hwnd, rgidDisableOnNoSelection, ARRAYSIZE(rgidDisableOnNoSelection), FALSE);
    }
}

HRESULT CUserlistPropertyPage::SetAutologonState(HWND hwnd, BOOL fAutologon)
{
    PropSheet_Changed(GetParent(hwnd), hwnd);
    return S_OK;
}

BOOL CUserlistPropertyPage::OnListViewItemChanged(HWND hwnd)
{
    SetPageState(hwnd);
    return TRUE;
}

long CUserlistPropertyPage::OnApply(HWND hwnd)
{
    long applyEffect = PSNRET_NOERROR;

    BOOL fAutologonSet = (BST_UNCHECKED == SendMessage(GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK), BM_GETCHECK, 0, 0));
    if (!fAutologonSet)
    {
        ClearAutoLogon();           // Ensure autologon is cleared
    }
    else if (m_fAutologonCheckChanged)
    {
        CUserInfo* pSelectedUser = GetSelectedUserInfo(GetDlgItem(hwnd, IDC_USER_LIST));

        TCHAR szNullName[] = TEXT("");
        CAutologonUserDlg dlg((pSelectedUser != NULL) ? pSelectedUser->m_szUsername : szNullName);
        if (dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_USR_AUTOLOGON_DLG), hwnd) == IDCANCEL)
        {
            applyEffect = PSNRET_INVALID_NOCHANGEPAGE;
        }
    }

    m_fAutologonCheckChanged = FALSE;

    if (applyEffect == PSNRET_INVALID_NOCHANGEPAGE)
    {
        m_pData->Initialize(hwnd);          // Reload the data and list
        SetupList(hwnd);
    }

    return applyEffect;
}

void CUserlistPropertyPage::SetupList(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_USER_LIST);
    
    // Disable autologon check box in the domain case where autologon isn't // enabled
    HWND hwndCheck = GetDlgItem(hwnd, IDC_AUTOLOGON_CHECK);
    if (m_pData->IsComputerInDomain() && !m_pData->IsAutologonEnabled())
    {
        ShowWindow(hwndCheck, SW_HIDE);
        EnableWindow(hwndCheck, FALSE);

        // Move most controls up a bit if the autologon is not visible
        RECT rcBottom;
        GetWindowRect(GetDlgItem(hwnd, IDC_LISTTITLE_STATIC), &rcBottom);

        RECT rcTop;
        GetWindowRect(hwndCheck, &rcTop);

        int dy = rcTop.top - rcBottom.top;

        OffsetControls(hwnd, rgidMoveOnNoAutologonCheck, 
                          ARRAYSIZE(rgidMoveOnNoAutologonCheck), 0, dy);

        // Grow the list by this amount also
        RECT rcList;
        GetWindowRect(hwndList, &rcList);

        SetWindowPos(hwndList, NULL, 0, 0, rcList.right - rcList.left, 
                           rcList.bottom - rcList.top - dy, SWP_NOZORDER|SWP_NOMOVE);
    }

    SendMessage(hwndCheck, BM_SETCHECK, 
                            m_pData->IsAutologonEnabled() ? BST_UNCHECKED : BST_CHECKED, 0);

    // Set the text in the set password group.
    SetPageState(hwnd);
}

HRESULT CUserlistPropertyPage::LaunchSetPasswordDialog(HWND hwndParent)
{
    CUserInfo* pUserInfo = GetSelectedUserInfo(GetDlgItem(hwndParent, IDC_USER_LIST));
    if ((pUserInfo != NULL) && (pUserInfo->m_userType == CUserInfo::LOCALUSER))
    {
        CChangePasswordDlg dlg(pUserInfo);
        dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_USR_SETPASSWORD_DLG), hwndParent);
        return S_OK;
    }
    return E_FAIL;
}

#define MAX_EXTRA_PAGES   10

HPSXA CUserlistPropertyPage::AddExtraUserPropPages(ADDPROPSHEETDATA* ppsd, PSID psid)
{
    HPSXA hpsxa = NULL;

    IDataObject *pdo;
    HRESULT hr = CUserSidDataObject_CreateInstance(psid, &pdo);
    if (SUCCEEDED(hr))
    {
        hpsxa = SHCreatePropSheetExtArrayEx(HKEY_LOCAL_MACHINE, REGSTR_USERPROPERTIES_SHEET, MAX_EXTRA_PAGES, pdo);
        if (hpsxa)
        {
            SHAddFromPropSheetExtArray(hpsxa, AddPropSheetPageCallback, (LPARAM) ppsd);
        }
        pdo->Release();
    }
    return hpsxa;
}


// ListCompare
//  Compares list items in for sorting the listview by column
//  lParamSort gets the 1-based column index. If lParamSort is negative
//  it indicates that the given column should be sorted in reverse.

int CUserlistPropertyPage::ListCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CUserInfo* pUserInfo1 = (CUserInfo*)lParam1;
    CUserInfo* pUserInfo2 = (CUserInfo*)lParam2;
    int iColumn = (int)lParamSort;

    BOOL fReverse = FALSE;
    if (iColumn < 0)
    {
        fReverse = TRUE;
        iColumn = -iColumn;
    }

    int iResult = 0;            // they match...    
    switch (iColumn)
    {
        case 1:
            iResult = lstrcmpi(pUserInfo1->m_szUsername, pUserInfo2->m_szUsername);
            break;

        case 2:
            iResult = lstrcmpi(pUserInfo1->m_szDomain, pUserInfo2->m_szDomain);
            break;

        case 3:
            iResult = lstrcmpi(pUserInfo1->m_szGroups, pUserInfo2->m_szGroups);
            break;
    }
    
    if (fReverse)
        iResult = -iResult;
    
    return iResult;
}


// The DoModal call for this dialog will return IDOK if the applet should be
// shown or IDCANCEL if the users.cpl should exit without displaying the applet.

class CSecurityCheckDlg: public CDialog
{
public:
    CSecurityCheckDlg(LPCTSTR pszDomainUser):
        m_pszDomainUser(pszDomainUser)
        {}

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnNotify(HWND hwnd, int id, NMHDR* pnmhdr);
    HRESULT RelaunchAsUser(HWND hwnd);

    LPCTSTR m_pszDomainUser;
};


// implementation

INT_PTR CSecurityCheckDlg::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
    }
    return FALSE;
}

BOOL CSecurityCheckDlg::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // First we must check if the current user is a local administrator; if this is
    // the case, our dialog doesn't even display
    
    BOOL fIsLocalAdmin;
    if (SUCCEEDED(IsUserLocalAdmin(NULL, &fIsLocalAdmin)))
    {
        if (fIsLocalAdmin)
        {
            EndDialog(hwnd, IDOK);  // We want to continue and launch the applet (don't display the security check dlg)
        }
    }
    else
    {
        EndDialog(hwnd, IDCANCEL);
    }

    // Set the "can't launch User Options" message
    TCHAR szUsername[MAX_USER + 1];
    DWORD cchUsername = ARRAYSIZE(szUsername);

    TCHAR szDomain[MAX_DOMAIN + 1];
    DWORD cchDomain = ARRAYSIZE(szDomain);
    if (GetCurrentUserAndDomainName(szUsername, &cchUsername, szDomain, &cchDomain))
    {
        TCHAR szDomainAndUsername[MAX_DOMAIN + MAX_USER + 2];

        MakeDomainUserString(szDomain, szUsername, szDomainAndUsername, ARRAYSIZE(szDomainAndUsername));

        TCHAR szMessage[256];
        if (FormatMessageString(IDS_USR_CANTRUNCPL_FORMAT, szMessage, ARRAYSIZE(szMessage), szDomainAndUsername))
        {
            SetWindowText(GetDlgItem(hwnd, IDC_CANTRUNCPL_STATIC), szMessage);
        }

        TCHAR szAdministrator[MAX_USER + 1];

        LoadString(g_hinst, IDS_ADMINISTRATOR, szAdministrator, ARRAYSIZE(szAdministrator));

        SetWindowText(GetDlgItem(hwnd, IDC_USER), szAdministrator);

        TCHAR szMachine[MAX_COMPUTERNAME + 1];
        
        DWORD dwSize = ARRAYSIZE(szMachine);
        ::GetComputerName(szMachine, &dwSize);

        SetWindowText(GetDlgItem(hwnd, IDC_DOMAIN), szMachine);
    }

    // Limit the text in the edit fields
    HWND hwndUsername = GetDlgItem(hwnd, IDC_USER);
    Edit_LimitText(hwndUsername, MAX_USER);

    HWND hwndDomain = GetDlgItem(hwnd, IDC_DOMAIN);
    Edit_LimitText(hwndDomain, MAX_DOMAIN);

    HWND hwndPassword = GetDlgItem(hwnd, IDC_PASSWORD);
    Edit_LimitText(hwndPassword, MAX_PASSWORD);

    if (!IsComputerInDomain())
    {
        // Don't need domain box
        EnableWindow(hwndDomain, FALSE);
        ShowWindow(hwndDomain, SW_HIDE);
        ShowWindow(GetDlgItem(hwnd, IDC_DOMAIN_STATIC), SW_HIDE);

        // Move up the OK/Cancel buttons and text and shrink the dialog
        RECT rcDomain;
        GetWindowRect(hwndDomain, &rcDomain);

        RECT rcPassword;
        GetWindowRect(hwndPassword, &rcPassword);
        
        int dy = (rcPassword.top - rcDomain.top);
        // dy is negative 

        OffsetWindow(GetDlgItem(hwnd, IDOK), 0, dy);
        OffsetWindow(GetDlgItem(hwnd, IDCANCEL), 0, dy);
        OffsetWindow(GetDlgItem(hwnd, IDC_PASSWORD_STATIC), 0, dy);
        OffsetWindow(GetDlgItem(hwnd, IDC_OTHEROPTIONS_LINK), 0, dy);

        RECT rcDialog;
        GetWindowRect(hwnd, &rcDialog);

        rcDialog.bottom += dy;  

        MoveWindow(hwnd, rcDialog.left, rcDialog.top, rcDialog.right-rcDialog.left,
                    rcDialog.bottom-rcDialog.top, FALSE);
    }

    return TRUE;
}

BOOL CSecurityCheckDlg::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
        case IDOK:
            if (SUCCEEDED(RelaunchAsUser(hwnd)))
            {
                EndDialog(hwnd, IDCANCEL);
            }
            return TRUE;

        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return TRUE;
    }
    return FALSE;
}

BOOL CSecurityCheckDlg::OnNotify(HWND hwnd, int id, NMHDR *pnmhdr)
{
    BOOL fHandled = FALSE;

    switch (pnmhdr->code)
    {
    // Handle link window clicks
    case NM_CLICK:
    case NM_RETURN:
        {
            if (IDC_OTHEROPTIONS_LINK == id)
            {
                // First link in the control is "manage passwords", second is "passport wizard"

                NMLINKWND* pnm = (NMLINKWND*) pnmhdr;
                if (0 == pnm->item.iLink)
                {
                    // Launch "manage passwords"
                    CCertificateAPI::ManagePasswords(hwnd);
                }
                else if (1 == pnm->item.iLink)
                {
                    // Launch passport wizard
                    IPassportWizard *pPW;
                    if (SUCCEEDED(CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW))))
                    {
                        pPW->SetOptions(PPW_LAUNCHEDBYUSER);
                        pPW->Show(hwnd);
                        pPW->Release();
                    }
                }
                fHandled = TRUE;
            }
        }
        break;
    };

    return fHandled;
}

HRESULT CSecurityCheckDlg::RelaunchAsUser(HWND hwnd)
{
    USES_CONVERSION;
    HRESULT hr = E_FAIL;

    TCHAR szUsername[MAX_USER + 1];
    FetchText(hwnd, IDC_USER, szUsername, ARRAYSIZE(szUsername));

    TCHAR szDomain[MAX_DOMAIN + 1];
    FetchText(hwnd, IDC_DOMAIN, szDomain, ARRAYSIZE(szDomain));

    // If the user didn't type a domain
    if (szDomain[0] == TEXT('\0'))
    {
        // Use this machine as the domain
        DWORD cchComputername = ARRAYSIZE(szDomain);
        ::GetComputerName(szDomain, &cchComputername);
    }

    TCHAR szPassword[MAX_PASSWORD + 1];
    GetWindowText(GetDlgItem(hwnd, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
    
    // Now relaunch ourselves with this information
    STARTUPINFO startupinfo = {0};
    startupinfo.cb = sizeof (startupinfo);

    WCHAR c_szCommandLineFormat[] = L"rundll32.exe netplwiz.dll,UsersRunDll %s";

    // Put the "real" user name in the command-line so that we know what user is
    // actually logged on to the machine even though we are re-launching in a different
    // user context
    WCHAR szCommandLine[ARRAYSIZE(c_szCommandLineFormat) + MAX_DOMAIN + MAX_USER + 2];
    wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), c_szCommandLineFormat, m_pszDomainUser);

    PROCESS_INFORMATION process_information;
    if (CreateProcessWithLogonW(szUsername, szDomain, szPassword, LOGON_WITH_PROFILE, NULL,
        szCommandLine, 0, NULL, NULL, &startupinfo, &process_information))
    {
        CloseHandle(process_information.hProcess);
        CloseHandle(process_information.hThread);
        hr = S_OK;
    }
    else
    {
        DisplayFormatMessage(hwnd, IDS_USR_APPLET_CAPTION, IDS_USR_CANTOPENCPLASUSER_ERROR, MB_OK|MB_ICONERROR);
    }
    return hr;
}

// Advanced Property Page

class CAdvancedPropertyPage: public CPropertyPage
{
public:
    CAdvancedPropertyPage(CUserManagerData* pdata): 
      m_pData(pdata),
      m_fRebootRequired(FALSE) {}

private:
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);
    BOOL OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh);
    BOOL OnHelp(HWND hwnd, LPHELPINFO pHelpInfo);
    BOOL OnContextMenu(HWND hwnd);
    void ReadRequireCad(BOOL* pfRequireCad, BOOL* pfSetInPolicy);
    void WriteRequireCad(BOOL fRequireCad);

    CUserManagerData* m_pData;
    BOOL m_fRebootRequired;

};

// Relevant regkeys/regvals
#define REGKEY_WINLOGON         \
         TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")

#define REGKEY_WINLOGON_POLICY  \
         TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System")

#define REGVAL_DISABLE_CAD      TEXT("DisableCAD")

void CAdvancedPropertyPage::ReadRequireCad(BOOL* pfRequireCad, BOOL* pfSetInPolicy)
{
    HKEY hkey;
    DWORD dwSize;
    DWORD dwType;
    BOOL fDisableCad;
    NT_PRODUCT_TYPE nttype;

    *pfRequireCad = TRUE;
    *pfSetInPolicy = FALSE; 

    if (!RtlGetNtProductType(&nttype))
    {
        nttype = NtProductWinNt;
    }

    // By default, don't require CAD for workstations not
    // on a domain only
    if ((NtProductWinNt == nttype) && !IsComputerInDomain())
    {
        *pfRequireCad = FALSE;
    }

    // Read the setting from the machine preferences
    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WINLOGON, 0, 
        KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(fDisableCad);

        if (ERROR_SUCCESS == RegQueryValueEx (hkey, REGVAL_DISABLE_CAD, NULL, &dwType,
                        (LPBYTE) &fDisableCad, &dwSize))
        {
            *pfRequireCad = !fDisableCad;
        }

        RegCloseKey (hkey);
    }

    // Check if C-A-D is disabled via policy

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WINLOGON_POLICY, 0, KEY_READ,
                     &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(fDisableCad);

        if (ERROR_SUCCESS == RegQueryValueEx (hkey, REGVAL_DISABLE_CAD, NULL, &dwType,
                            (LPBYTE) &fDisableCad, &dwSize))
        {
            *pfRequireCad = !fDisableCad;
            *pfSetInPolicy = TRUE;
        }

        RegCloseKey (hkey);
    }
}

void CAdvancedPropertyPage::WriteRequireCad(BOOL fRequireCad)
{
    HKEY hkey;
    DWORD dwDisp;
    BOOL fDisableCad = !fRequireCad;

    if (ERROR_SUCCESS == RegCreateKeyEx( HKEY_LOCAL_MACHINE, REGKEY_WINLOGON, 0, 
        NULL, 0, KEY_WRITE, NULL, &hkey, &dwDisp))
    {
        RegSetValueEx(hkey, REGVAL_DISABLE_CAD, 0, REG_DWORD,
                        (LPBYTE) &fDisableCad, sizeof(fDisableCad));

        RegCloseKey (hkey);
    }
}

static const DWORD rgAdvHelpIds[] = 
{
    IDC_ADVANCED_BUTTON,        IDH_ADVANCED_BUTTON,
    IDC_BOOT_ICON,              IDH_SECUREBOOT_CHECK,
    IDC_BOOT_TEXT,              IDH_SECUREBOOT_CHECK,
    IDC_REQUIRECAD,             IDH_SECUREBOOT_CHECK,
    IDC_MANAGEPWD_BUTTON,       IDH_MANAGEPWD_BUTTON,
    IDC_PASSPORTWIZARD,         IDH_PASSPORTWIZARD,
    IDC_CERT_ICON,              (DWORD) -1,
    IDC_CERT_TEXT,              (DWORD) -1,
    0, 0
};

INT_PTR CAdvancedPropertyPage::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwndDlg, WM_INITDIALOG, OnInitDialog);
        HANDLE_MSG(hwndDlg, WM_COMMAND, OnCommand);
        HANDLE_MSG(hwndDlg, WM_NOTIFY, OnNotify);
        case WM_HELP: return OnHelp(hwndDlg, (LPHELPINFO) lParam);
        case WM_CONTEXTMENU: return OnContextMenu((HWND) wParam);
    }
    
    return FALSE;
}

BOOL CAdvancedPropertyPage::OnNotify(HWND hwnd, int idCtrl, LPNMHDR pnmh)
{
    BOOL fReturn = FALSE;
    switch (pnmh->code)
    {
        case PSN_APPLY:
            {
                HWND hwndCheck = GetDlgItem(hwnd, IDC_REQUIRECAD);
                BOOL fRequireCad = (BST_CHECKED == Button_GetCheck(hwndCheck));

                // See if a change is really necessary
                BOOL fOldRequireCad;
                BOOL fDummy;

                ReadRequireCad(&fOldRequireCad, &fDummy);

                if (fRequireCad != fOldRequireCad)
                {
                    WriteRequireCad(fRequireCad);
                    // m_fRebootRequired = TRUE;
                    // Uncomment the line above if it ever becomes necessary to reboot the machine - it isn't now.
                }

                // xxx->lParam == 0 means Ok as opposed to Apply
                if ((((PSHNOTIFY*) pnmh)->lParam) && m_fRebootRequired) 
                {
                    PropSheet_RebootSystem(GetParent(hwnd));
                }

                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PSNRET_NOERROR);
                fReturn = TRUE;
            }
            break;
    }
    return fReturn;
}

BOOL CAdvancedPropertyPage::OnHelp(HWND hwnd, LPHELPINFO pHelpInfo)
{
    WinHelp((HWND) pHelpInfo->hItemHandle, m_pData->GetHelpfilePath(), 
            HELP_WM_HELP, (ULONG_PTR) (LPTSTR)rgAdvHelpIds);

    return TRUE;
}

BOOL CAdvancedPropertyPage::OnContextMenu(HWND hwnd)
{
    WinHelp(hwnd, m_pData->GetHelpfilePath(), HELP_CONTEXTMENU, (ULONG_PTR) (LPTSTR)rgAdvHelpIds);

    return TRUE;
}

BOOL CAdvancedPropertyPage::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Do the required mucking for the Require C-A-D checkbox...
    // Read the setting for the require CAD checkbox
    BOOL fRequireCad;
    BOOL fSetInPolicy;

    ReadRequireCad(&fRequireCad, &fSetInPolicy);

    HWND hwndCheck = GetDlgItem(hwnd, IDC_REQUIRECAD);
    // Disable the check if set in policy
    EnableWindow(hwndCheck, !fSetInPolicy);

    // Set the check accordingly
    Button_SetCheck(hwndCheck, 
        fRequireCad ? BST_CHECKED : BST_UNCHECKED);

    return TRUE;
}
    
BOOL CAdvancedPropertyPage::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDC_MANAGEPWD_BUTTON:
        {
            CCertificateAPI::ManagePasswords(hwnd);
        }
        break;

    case IDC_PASSPORTWIZARD:
        {
            IPassportWizard *pPW;
            if (SUCCEEDED(CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW))))
            {
                pPW->SetOptions(PPW_LAUNCHEDBYUSER);
                pPW->Show(hwnd);
                pPW->Release();
            }
        }
        break;

    case IDC_ADVANCED_BUTTON:
        {
            // Launch the MMC local user manager
            STARTUPINFO startupinfo = {0};
            startupinfo.cb = sizeof (startupinfo);

            PROCESS_INFORMATION process_information;

            static const TCHAR szMMCCommandLine[] = 
                TEXT("mmc.exe %systemroot%\\system32\\lusrmgr.msc computername=localmachine");
            
            TCHAR szExpandedCommandLine[MAX_PATH];

            if (ExpandEnvironmentStrings(szMMCCommandLine, szExpandedCommandLine, 
                ARRAYSIZE(szExpandedCommandLine)) > 0)
            {
                if (CreateProcess(NULL, szExpandedCommandLine, NULL, NULL, FALSE, 0, NULL, NULL,
                    &startupinfo, &process_information))
                {
                    CloseHandle(process_information.hProcess);
                    CloseHandle(process_information.hThread);
                }
            }
        }
        break;

    case IDC_REQUIRECAD:
        PropSheet_Changed(GetParent(hwnd), hwnd);
        break;
    }

    return FALSE;
}


// users control panel entry point

void APIENTRY UsersRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = S_OK;
    TCHAR szDomainUser[MAX_USER + MAX_DOMAIN + 2];
    *szDomainUser = 0;

    // Get the "real" user of this machine - this may be passed in the cmdline
    if (0 == *pszCmdLine)
    {
        // user wasn't passed, assume its the currently logged on user
        TCHAR szUser[MAX_USER + 1];
        DWORD cchUser = ARRAYSIZE(szUser);
        TCHAR szDomain[MAX_DOMAIN + 1];
        DWORD cchDomain = ARRAYSIZE(szDomain);

        if (0 != GetCurrentUserAndDomainName(szUser, &cchUser, szDomain, &cchDomain))
        {
            MakeDomainUserString(szDomain, szUser, szDomainUser, ARRAYSIZE(szDomainUser));
        }
    }
    else
    {
        // User name was passed in, just copy it
        MultiByteToWideChar(GetACP(), 0, pszCmdLine, -1, szDomainUser, ARRAYSIZE(szDomainUser));
    }

    // Initialize COM, but continue even if this fails.
    BOOL fComInited = SUCCEEDED(CoInitialize(NULL));

    // See if we're already running
    TCHAR szCaption[256];
    LoadString(g_hinst, IDS_USR_APPLET_CAPTION, szCaption, ARRAYSIZE(szCaption));
    CEnsureSingleInstance ESI(szCaption);

    if (!ESI.ShouldExit())
    {
        LinkWindow_RegisterClass();

        // Create the security check dialog to ensure the logged-on user
        // is a local admin
        CSecurityCheckDlg dlg(szDomainUser);

        if (dlg.DoModal(g_hinst, MAKEINTRESOURCE(IDD_USR_SECURITYCHECK_DLG), NULL) == IDOK)
        {
            // Create the shared user mgr object
            CUserManagerData data(szDomainUser);

            // Create the property sheet and page template
            // Maximum number of pages
            ADDPROPSHEETDATA ppd;
            ppd.nPages = 0;

            // Settings common to all pages
            PROPSHEETPAGE psp = {0};
            psp.dwSize = sizeof (psp);
            psp.hInstance = g_hinst;

            // Create the userlist property sheet page and its managing object
            psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERLIST_PAGE);
            CUserlistPropertyPage userListPage(&data);
            userListPage.SetPropSheetPageMembers(&psp);
            ppd.rgPages[ppd.nPages++] = CreatePropertySheetPage(&psp);
    
            psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_ADVANCED_PAGE);
            CAdvancedPropertyPage advancedPage(&data);
            advancedPage.SetPropSheetPageMembers(&psp);
            ppd.rgPages[ppd.nPages++] = CreatePropertySheetPage(&psp);

            HPSXA hpsxa = SHCreatePropSheetExtArrayEx(HKEY_LOCAL_MACHINE, REGSTR_USERSANDPASSWORDS_CPL, 10, NULL);
            if (hpsxa != NULL)
                SHAddFromPropSheetExtArray(hpsxa, AddPropSheetPageCallback, (LPARAM)&ppd);

            // Create the prop sheet
            PROPSHEETHEADER psh = {0};
            psh.dwSize = sizeof (psh);
            psh.dwFlags = PSH_DEFAULT;
            psh.hwndParent = hwndStub;
            psh.hInstance = g_hinst;
            psh.pszCaption = szCaption;
            psh.nPages = ppd.nPages;
            psh.phpage = ppd.rgPages;

            // Show the property sheet
            int iRetCode = PropertySheetIcon(&psh, MAKEINTRESOURCE(IDI_USR_USERS));
    
            if (hpsxa != NULL)
            {
                SHDestroyPropSheetExtArray(hpsxa);
            }

            if (iRetCode == -1)
            {
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;
                // Special case when we must restart or reboot
                if (iRetCode == ID_PSREBOOTSYSTEM)
                {
                    RestartDialogEx(NULL, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);                
                }
                else if (iRetCode == ID_PSRESTARTWINDOWS)
                {
                    RestartDialogEx(NULL, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG);                
                }
                else if (data.LogoffRequired())
                {
                    int iLogoff = DisplayFormatMessage(NULL, IDS_USERSANDPASSWORDS, IDS_LOGOFFREQUIRED, MB_YESNO | MB_ICONQUESTION);

                    if (iLogoff == IDYES)
                    {
                        // Tell explorer to log off the "real" logged on user. We need to do this
                        // since they may be running U&P as a different user.
                        HWND hwnd = FindWindow(TEXT("Shell_TrayWnd"), TEXT(""));
                        if ( hwnd )
                        {
                            UINT uMsg = RegisterWindowMessage(TEXT("Logoff User"));

                            PostMessage(hwnd, uMsg, 0,0);
                        } 
                    }
                }
            }
        }
        else
        {
            // Security check told us to exit; either another instance of the CPL is starting
            // with admin priviledges or the user cancelled on the sec. check. dlg.
            hr = E_FAIL;
        }
    }

    if (fComInited)
        CoUninitialize();
}


// user property property page object

class CUserPropertyPages: public IShellExtInit, IShellPropSheetExt
{
public:
    CUserPropertyPages();
    ~CUserPropertyPages();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdo, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
        { return E_NOTIMPL; }

private:
    LONG _cRef;

    CUserInfo *_pUserInfo;                     // The user for the property sheet
    CUsernamePropertyPage *_pUserNamePage;     // Basic info page, only shown for local users
    CGroupPropertyPage *_pGroupPage;           // The group page, which is common to both local and domain users
    CGroupInfoList _GroupList;                 // The group list, used by the group page
};


CUserPropertyPages::CUserPropertyPages() : 
    _cRef(1)
{   
    DllAddRef();
}
    
CUserPropertyPages::~CUserPropertyPages()
{
    if (_pUserInfo)
        delete _pUserInfo;
    if (_pUserNamePage)
        delete _pUserNamePage;
    if (_pGroupPage)
        delete _pGroupPage;

    DllRelease();
}

ULONG CUserPropertyPages::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CUserPropertyPages::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CUserPropertyPages::QueryInterface(REFIID riid, LPVOID* ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CUserPropertyPages, IShellExtInit),            // IID_IShellExtInit
        QITABENT(CUserPropertyPages, IShellPropSheetExt),       // IID_IShellPropSheetExt
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IShellExtInit

HRESULT CUserPropertyPages::Initialize(LPCITEMIDLIST pidlFolder, LPDATAOBJECT pdo, HKEY hkeyProgID)
{
    // Request the user's SID from the data object
    FORMATETC fmt = {0};
    fmt.cfFormat = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_USERPROPPAGESSID);
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.tymed = TYMED_HGLOBAL;

    STGMEDIUM medium = { 0 };
    HRESULT hr = pdo->GetData(&fmt, &medium);
    if (SUCCEEDED(hr))
    {
        // medium.hGlobal is the user's SID; make sure it isn't null and that
        // we haven't already set our copy of the SID
        if ((medium.hGlobal != NULL) && (_pUserInfo == NULL))
        {
            PSID psid = (PSID) GlobalLock(medium.hGlobal);
            if (IsValidSid(psid))
            {
                // Create a user info structure to party on
                _pUserInfo = new CUserInfo;
                if (_pUserInfo)
                {
                    hr = _pUserInfo->Load(psid, TRUE);
                    if (SUCCEEDED(hr))
                    {
                        hr = _GroupList.Initialize();                          // Get the groups
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;              // hGlobal was NULL or prop sheet was already init'ed
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


// AddPages - handles adding the property pages

HRESULT CUserPropertyPages::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    PROPSHEETPAGE psp = {0};
    psp.dwSize = sizeof (psp);
    psp.hInstance = g_hinst;

    if (_pUserInfo->m_userType == CUserInfo::LOCALUSER)
    {
        // Add the local user prop pages
        psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_USERNAME_PROP_PAGE);

        _pUserNamePage = new CUsernamePropertyPage(_pUserInfo);
        if (_pUserNamePage != NULL)
        {
            _pUserNamePage->SetPropSheetPageMembers(&psp);
            lpfnAddPage(CreatePropertySheetPage(&psp), lParam);
        }
    }

    psp.pszTemplate = MAKEINTRESOURCE(IDD_USR_CHOOSEGROUP_PROP_PAGE);

    _pGroupPage = new CGroupPropertyPage(_pUserInfo, &_GroupList);
    if (_pGroupPage != NULL)
    {
        _pGroupPage->SetPropSheetPageMembers(&psp);
        lpfnAddPage(CreatePropertySheetPage(&psp), lParam);
    }

    return S_OK;
}

STDAPI CUserPropertyPages_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CUserPropertyPages *pupp = new CUserPropertyPages();
    if (!pupp)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pupp->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pupp->Release();
    return hr;
}



// expose the SID for a user via an IDataObject

class CUserSidDataObject: public IDataObject
{
public:
    CUserSidDataObject();
    ~CUserSidDataObject();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDataObject
    STDMETHODIMP GetData(FORMATETC* pFormatEtc, STGMEDIUM* pMedium);
    STDMETHODIMP GetDataHere(FORMATETC* pFormatEtc, STGMEDIUM* pMedium)
        { return E_NOTIMPL; }
    STDMETHODIMP QueryGetData(FORMATETC* pFormatEtc)
        { return E_NOTIMPL; }
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC* pFormatetcIn, FORMATETC* pFormatetcOut)
        { return E_NOTIMPL; }
    STDMETHODIMP SetData(FORMATETC* pFormatetc, STGMEDIUM* pmedium, BOOL fRelease)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC ** ppenumFormatetc)
        { return E_NOTIMPL; }
    STDMETHODIMP DAdvise(FORMATETC* pFormatetc, DWORD advf, IAdviseSink* pAdvSink, DWORD * pdwConnection)
        { return E_NOTIMPL; }
    STDMETHODIMP DUnadvise(DWORD dwConnection)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA ** ppenumAdvise)
        { return E_NOTIMPL; }

    HRESULT SetSid(PSID psid);

private:
    LONG _cRef;
    PSID _psid;
};


CUserSidDataObject::CUserSidDataObject() :
    _cRef(1)
{
    DllAddRef();
}

CUserSidDataObject::~CUserSidDataObject()
{
    if (_psid)
        LocalFree(_psid);

    DllRelease();
}

ULONG CUserSidDataObject::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CUserSidDataObject::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CUserSidDataObject::QueryInterface(REFIID riid, LPVOID* ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CUserSidDataObject, IDataObject),    // IID_IDataObject
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CUserSidDataObject::GetData(FORMATETC* pFormatEtc, STGMEDIUM* pMedium)
{
    HRESULT hr = QueryGetData(pFormatEtc);
    if (SUCCEEDED(hr))
    {
        pMedium->pUnkForRelease = (IDataObject*)this;
        AddRef();                                              // reference to ourself

        pMedium->tymed = TYMED_HGLOBAL;
        pMedium->hGlobal = (HGLOBAL)_psid;
    }
    return hr;
}

HRESULT CUserSidDataObject::SetSid(PSID psid)
{
    if (!psid)
        return E_INVALIDARG;

    if (_psid == NULL)
    {
        DWORD cbSid = GetLengthSid(psid);

        _psid = (PSID)LocalAlloc(0, cbSid);
        if (!_psid)
            return E_OUTOFMEMORY;

        if (CopySid(cbSid, _psid, psid))
            return S_OK;
    }

    return E_FAIL;
}

STDAPI CUserSidDataObject_CreateInstance(PSID psid, IDataObject **ppdo)
{
    CUserSidDataObject *pusdo = new CUserSidDataObject();
    
    if (!pusdo)
        return E_OUTOFMEMORY;

    HRESULT hr = pusdo->SetSid(psid);
    if (SUCCEEDED(hr))
    {
        hr = pusdo->QueryInterface(IID_PPV_ARG(IDataObject, ppdo));
    }
    pusdo->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\autoscrl.c ===
//===========================================================================
// Image dragging API (definitely private)
//===========================================================================
#include <windows.h>
#include <windowsx.h>

#include "autoscrl.h"
#include "common.h"
#include "debug.h"

#if 0
BOOL DAD_SetDragImage(HIMAGELIST him, POINT FAR* pptOffset);
BOOL DAD_DragEnter(HWND hwndTarget);
BOOL DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
BOOL DAD_ShowDragImage(BOOL fShow);
BOOL DAD_DragMove(POINT pt);
BOOL DAD_DragLeave(void);
BOOL DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);
#endif


// -------------- auto scroll stuff --------------

BOOL _AddTimeSample(AUTO_SCROLL_DATA *pad, const POINT *ppt, DWORD dwTime)
{
    pad->pts[pad->iNextSample] = *ppt;
    pad->dwTimes[pad->iNextSample] = dwTime;

    pad->iNextSample++;

    if (pad->iNextSample == ARRAYSIZE(pad->pts))
        pad->bFull = TRUE;

    pad->iNextSample = pad->iNextSample % ARRAYSIZE(pad->pts);

    return pad->bFull;
}

#ifdef DEBUG
// for debugging, verify we have good averages
DWORD g_time = 0;
int g_distance = 0;
#endif

int _CurrentVelocity(AUTO_SCROLL_DATA *pad)
{
    int i, iStart, iNext;
    int dx, dy, distance;
    DWORD time;

    Assert(pad->bFull);

    distance = 0;
    time = 1;	// avoid div by zero

    i = iStart = pad->iNextSample % ARRAYSIZE(pad->pts);

    do {
	iNext = (i + 1) % ARRAYSIZE(pad->pts);

	dx = abs(pad->pts[i].x - pad->pts[iNext].x);
	dy = abs(pad->pts[i].y - pad->pts[iNext].y);
	distance += (dx + dy);
	time += abs(pad->dwTimes[i] - pad->dwTimes[iNext]);

	i = iNext;

    } while (i != iStart);

#ifdef DEBUG
    g_time = time;
    g_distance = distance;
#endif

    // scale this so we don't loose accuracy
    return (distance * 1024) / time;
}



// NOTE: this is duplicated in shell32.dll
//
// checks to see if we are at the end position of a scroll bar
// to avoid scrolling when not needed (avoid flashing)
//
// in:
//      code        SB_VERT or SB_HORZ
//      bDown       FALSE is up or left
//                  TRUE  is down or right

BOOL CanScroll(HWND hwnd, int code, BOOL bDown)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_ALL;
    GetScrollInfo(hwnd, code, &si);

    if (bDown)
    {
    	if (si.nPage)
    	    si.nMax -= si.nPage - 1;
    	return si.nPos < si.nMax;
    }
    else
    {
    	return si.nPos > si.nMin;
    }
}

#define DSD_NONE		0x0000
#define DSD_UP			0x0001
#define DSD_DOWN		0x0002
#define DSD_LEFT		0x0004
#define DSD_RIGHT		0x0008

//---------------------------------------------------------------------------
DWORD DAD_DragScrollDirection(HWND hwnd, const POINT *ppt)
{
    RECT rcOuter, rc;
    DWORD dwDSD = DSD_NONE;	// 0
    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);

    // BUGBUG: do these as globals
#define g_cxVScroll GetSystemMetrics(SM_CXVSCROLL)
#define g_cyHScroll GetSystemMetrics(SM_CYHSCROLL)
#define g_cxSmIcon  GetSystemMetrics(SM_CXSMICON)
#define g_cySmIcon  GetSystemMetrics(SM_CYSMICON)
#define g_cxIcon    GetSystemMetrics(SM_CXICON)
#define g_cyIcon    GetSystemMetrics(SM_CXICON)

    GetClientRect(hwnd, &rc);

    if (dwStyle & WS_HSCROLL)
	rc.bottom -= g_cyHScroll;

    if (dwStyle & WS_VSCROLL)
	rc.right -= g_cxVScroll;

    // the explorer forwards us drag/drop things outside of our client area
    // so we need to explictly test for that before we do things
    //
    rcOuter = rc;
    InflateRect(&rcOuter, g_cxSmIcon, g_cySmIcon);

    InflateRect(&rc, -g_cxIcon, -g_cyIcon);

    if (!PtInRect(&rc, *ppt) && PtInRect(&rcOuter, *ppt))
    {
    	// Yep - can we scroll?
    	if (dwStyle & WS_HSCROLL)
    	{
    	    if (ppt->x < rc.left)
    	    {
    	    	if (CanScroll(hwnd, SB_HORZ, FALSE))
    	    	    dwDSD |= DSD_LEFT;
    	    }
    	    else if (ppt->x > rc.right)
    	    {
    	    	if (CanScroll(hwnd, SB_HORZ, TRUE))
    	    	    dwDSD |= DSD_RIGHT;
    	    }
    	}
    	if (dwStyle & WS_VSCROLL)
    	{
    	    if (ppt->y < rc.top)
    	    {
    	    	if (CanScroll(hwnd, SB_VERT, FALSE))
    	    	    dwDSD |= DSD_UP;
    	    }
    	    else if (ppt->y > rc.bottom)
    	    {
    	    	if (CanScroll(hwnd, SB_VERT, TRUE))
    	    	    dwDSD |= DSD_DOWN;
    	    }
    	}
    }
    return dwDSD;
}


#define SCROLL_FREQUENCY	(GetDoubleClickTime()/4)	// 1 line scroll every 1/4 second
#define MIN_SCROLL_VELOCITY	20	// scaled mouse velocity

#define DAD_ShowDragImage(f)	// BUGBUG

BOOL DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow)
{
    // first time we've been called, init our state
    int v;
    DWORD dwTimeNow = GetTickCount();
    DWORD dwDSD = DAD_DragScrollDirection(hwnd, pptNow);

    if (!_AddTimeSample(pad, pptNow, dwTimeNow))
	return dwDSD;

    v = _CurrentVelocity(pad);

    if (v <= MIN_SCROLL_VELOCITY)
    {
        // Nope, do some scrolling.
        if ((dwTimeNow - pad->dwLastScroll) < SCROLL_FREQUENCY)
    	    dwDSD = 0;

	if (dwDSD & (DSD_UP | DSD_DOWN | DSD_LEFT | DSD_RIGHT))
            DAD_ShowDragImage(FALSE);

        if (dwDSD & DSD_UP)
        {
            FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEUP, 1, SendMessage);
        }
        else if (dwDSD & DSD_DOWN)
        {
            FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEDOWN, 1, SendMessage);
        }
        if (dwDSD & DSD_LEFT)
        {
            FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEUP, 1, SendMessage);
        }
        else if (dwDSD & DSD_RIGHT)
        {
            FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEDOWN, 1, SendMessage);
        }

        DAD_ShowDragImage(TRUE);

	if (dwDSD)
	{
    	    DebugMsg(DM_TRACE, "v=%d", v);
	    pad->dwLastScroll = dwTimeNow;
	}
    }
    return dwDSD;	// bits set if in scroll region
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\debug.c ===
#include <windows.h>

#include "debug.h"

// #define DEBUG_BREAK        __try { _asm { int 3 } } __except (EXCEPTION_EXECUTE_HANDLER) {;}
#define DEBUG_BREAK        _try { DebugBreak(); } _except (EXCEPTION_EXECUTE_HANDLER) {;}

#ifdef _DEBUG

UINT g_fDebugMask = 0x00ff;

UINT SetDebugMask(UINT mask)
{
    UINT wOld = g_fDebugMask;
    g_fDebugMask = mask;

    return wOld;
}

UINT GetDebugMask()
{
    return g_fDebugMask;
}

void AssertFailed(LPCSTR pszFile, int line)
{
    LPCSTR psz;
    char ach[256];
    static char szAssertFailed[] = "Assertion failed in %s on line %d\r\n";

    // Strip off path info from filename string, if present.
    //
    if (g_fDebugMask & DM_ASSERT)
    {
        for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
        {
            if ((AnsiPrev(pszFile, psz)!= (psz-2)) && *(psz - 1) == '\\')
                break;
        }
        wsprintf(ach, szAssertFailed, psz, line);
        OutputDebugString(ach);
	
	DEBUG_BREAK
    }
}

void _cdecl _AssertMsg(BOOL f, LPCSTR pszMsg, ...)
{
    char ach[256];

    if (!f && (g_fDebugMask & DM_ASSERT))
    {
        wvsprintf(ach, pszMsg, (LPVOID)(&pszMsg + 1));
        lstrcat(ach, "\r\n");
        OutputDebugString(ach);
	DEBUG_BREAK
    }
}

void _cdecl _DebugMsg(UINT mask, LPCSTR pszMsg, ...)
{
    char ach[2*MAX_PATH+40];  // Handles 2*largest path + slop for message

    if (g_fDebugMask & mask)
    {
        wvsprintf(ach, pszMsg, (LPVOID)(&pszMsg + 1));
        lstrcat(ach, "\r\n");
        OutputDebugString(ach);
    }
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\browse.c ===
//###########################################################################
// Code for the Browse For Starting Folder
//###########################################################################
// Structure to pass information to browse for folder dialog
typedef struct _bfsf
{
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;      // Root of search.  Typically desktop or my net
    LPSTR        pszDisplayName;// Return display name of item selected.
    int          *piImage;      // where to return the Image index.
    LPCSTR      lpszTitle;      // resource (or text to go in the banner over the tree.
    UINT         ulFlags;       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM      lParam;
    HWND         hwndDlg;       // The window handle to the dialog
    HWND         hwndTree;      // The tree control.
    HTREEITEM    htiCurParent;  // tree item associated with Current shell folder
    IShellFolder * psfParent;    // Cache of the last IShell folder I needed...
    LPITEMIDLIST pidlCurrent;   // IDlist of current folder to select
    BOOL         fShowAllObjects; // Should we Show all ?
} BFSF, *PBFSF;


BOOL CALLBACK _BFSFDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
LPITEMIDLIST _BFSFUpdateISHCache(PBFSF pbfsf, HTREEITEM hti, LPITEMIDLIST pidlItem);


// _BrowseForStartingFolder - Browse for a folder to start the
//         search from.



// BUGBUG, give them a way to turn off the ok button.

LPITEMIDLIST WINAPI SHBrowseForFolder(LPBROWSEINFO lpbi)
{
    LPITEMIDLIST lpRet;
    BFSF bfsf =
        {
          lpbi->hwndOwner,
          lpbi->pidlRoot,
          lpbi->pszDisplayName,
          &lpbi->iImage,
          lpbi->lpszTitle,
          lpbi->ulFlags,
          lpbi->lpfn,
          lpbi->lParam,
        };
    HCURSOR hcOld = SetCursor(LoadCursor(NULL,IDC_WAIT));
    SHELLSTATE ss;

    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
    bfsf.fShowAllObjects = ss.fShowAllObjects;

    // Now Create the dialog that will be doing the browsing.
    if (DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_BROWSEFORFOLDER),
                       lpbi->hwndOwner, _BFSFDlgProc, (LPARAM)&bfsf))
        lpRet = bfsf.pidlCurrent;
    else
        lpRet = NULL;

    if (hcOld)
        SetCursor(hcOld);

    return lpRet;
}

void BFSFCallback(PBFSF pbfsf, UINT uMsg, LPARAM lParam)
{
    if (pbfsf->lpfn) {
        pbfsf->lpfn(pbfsf->hwndDlg, uMsg, lParam, pbfsf->lParam);
    }
}


// Some helper functions for processing the dialog

HTREEITEM _AddItemToTree(HWND hwndTree, HTREEITEM htiParent, LPITEMIDLIST pidl, int cChildren)
{
    TV_INSERTSTRUCT tii;

    // Initialize item to add with callback for everything
    tii.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE |
            TVIF_PARAM | TVIF_CHILDREN;
    tii.hParent = htiParent;
    tii.hInsertAfter = TVI_FIRST;
    tii.item.iImage = I_IMAGECALLBACK;
    tii.item.iSelectedImage = I_IMAGECALLBACK;
    tii.item.pszText = LPSTR_TEXTCALLBACK;   //
    tii.item.cChildren = cChildren; //  Assume it has children
    tii.item.lParam = (LPARAM)pidl;

    return TreeView_InsertItem(hwndTree, &tii);
}


LPITEMIDLIST _GetIDListFromTreeItem(HWND hwndTree, HTREEITEM hti)
{
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlT;
    TV_ITEM tvi;

    // If no hti passed in, get the selected on.
    if (hti == NULL)
    {
        hti = TreeView_GetSelection(hwndTree);
        if (hti == NULL)
            return(NULL);
    }

    // now lets get the information about the item
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    tvi.hItem = hti;
    if (!TreeView_GetItem(hwndTree, &tvi))
        return NULL;   // Failed again

    pidl = ILClone((LPITEMIDLIST)tvi.lParam);

    // Now walk up parents.
    while ((tvi.hItem = TreeView_GetParent(hwndTree, tvi.hItem)) && pidl)
    {
        if (!TreeView_GetItem(hwndTree, &tvi))
            return(pidl);   // will assume I messed up...
        pidlT = ILCombine((LPITEMIDLIST)tvi.lParam, pidl);

        ILFree(pidl);

        pidl = pidlT;

    }
    return(pidl);
}


int CALLBACK _BFSFTreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    IShellFolder *psfParent = (IShellFolder *)lParamSort;
    HRESULT hres = psfParent->lpVtbl->CompareIDs(psfParent, 0, (LPITEMIDLIST)lParam1, (LPITEMIDLIST)lParam2);

    Assert(SUCCEEDED(hres));

    return (short)SCODE_CODE(GetScode(hres));
}

void _BFSFSort(PBFSF pbfsf, HTREEITEM hti, IShellFolder * psf)
{
    TV_SORTCB sSortCB;

    sSortCB.hParent = hti;
    sSortCB.lpfnCompare = _BFSFTreeCompare;

    psf->lpVtbl->AddRef(psf);
    sSortCB.lParam = (LPARAM)psf;
    TreeView_SortChildrenCB(pbfsf->hwndTree, &sSortCB, FALSE);
    psf->lpVtbl->Release(psf);
}


BOOL _BFSFHandleItemExpanding(PBFSF pbfsf, LPNM_TREEVIEW pnmtv)
{
    LPITEMIDLIST pidlToExpand;
    LPITEMIDLIST pidl;
    IShellFolder * psf;
    IShellFolder * psfDesktop = Desktop_GetShellFolder(TRUE);
    BYTE bType;
    DWORD grfFlags;
    BOOL fPrinterTest = FALSE;
    int cAdded = 0;
    TV_ITEM tvi;

    IEnumIDList *   penum;              // Enumerator in use.

    if (pnmtv->action != TVE_EXPAND)
        return FALSE;

    if ((pnmtv->itemNew.state & TVIS_EXPANDEDONCE))
        return FALSE;

    // set this bit now because we might be reentered via the wnet apis
    tvi.mask = TVIF_STATE;
    tvi.hItem = pnmtv->itemNew.hItem;
    tvi.state = TVIS_EXPANDEDONCE;
    tvi.stateMask = TVIS_EXPANDEDONCE;
    TreeView_SetItem(pbfsf->hwndTree, &tvi);


    if (pnmtv->itemNew.hItem == NULL)
    {
        pnmtv->itemNew.hItem = TreeView_GetSelection(pbfsf->hwndTree);
        if (pnmtv->itemNew.hItem == NULL)
            return FALSE;
    }

    pidlToExpand = _GetIDListFromTreeItem(pbfsf->hwndTree, pnmtv->itemNew.hItem);

    if (pidlToExpand == NULL)
        return FALSE;

    // Now lets get the IShellFolder and iterator for this object
    // special case to handle if the Pidl is the desktop
    // This is rather gross, but the desktop appears to be simply a pidl
    // of length 0 and ILIsEqual will not work...
    if (pidlToExpand->mkid.cb == 0)
    {
        psf = psfDesktop;
        psfDesktop->lpVtbl->AddRef(psf);
    }
    else
    {
        if (FAILED(psfDesktop->lpVtbl->BindToObject(psfDesktop,
                pidlToExpand, NULL, &IID_IShellFolder, &psf)))
        {
            ILFree(pidlToExpand);
            return FALSE; // Could not get IShellFolder.
        }
    }

    // Need to do a couple of special cases here to allow us to
    // browse for a network printer.  In this case if we are at server
    // level we then need to change what we search for non folders when
    // we are the level of a server.
    if (pbfsf->ulFlags & BIF_BROWSEFORPRINTER)
    {
        grfFlags = SHCONTF_FOLDERS | SHCONTF_NETPRINTERSRCH;
        pidl = ILFindLastID(pidlToExpand);
        bType = SIL_GetType(pidl);
        fPrinterTest = ((bType & (SHID_NET|SHID_INGROUPMASK))==SHID_NET_SERVER);
        if (fPrinterTest)
            grfFlags |= SHCONTF_NONFOLDERS;
    }
    else
        grfFlags = SHCONTF_FOLDERS;

    if (pbfsf->fShowAllObjects)
        grfFlags |= SHCONTF_INCLUDEHIDDEN;



    if (FAILED(psf->lpVtbl->EnumObjects(psf, pbfsf->hwndDlg, grfFlags, &penum)))
    {
        psf->lpVtbl->Release(psf);
        ILFree(pidlToExpand);
        return FALSE;
    }
    // psf->lpVtbl->AddRef(psf);

    while (pidl = _NextIDL(psf, penum))
    {
        int cChildren = I_CHILDRENCALLBACK;  // Do call back for children
        //
        // We need to special case here in the netcase where we onlyu
        // browse down to workgroups...
        //
        //
        // Here is where I also need to special case to not go below
        // workgroups when the appropriate option is set.
        //
        bType = SIL_GetType(pidl);
        if ((pbfsf->ulFlags & BIF_DONTGOBELOWDOMAIN) && (bType & SHID_NET))
        {
            switch (bType & (SHID_NET | SHID_INGROUPMASK))
            {
            case SHID_NET_SERVER:
                ILFree(pidl);       // Dont want to add this one
                continue;           // Try the next one
            case SHID_NET_DOMAIN:
                cChildren = 0;      // Force to not have children;
            }
        }

        else if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) && (bType & SHID_NET))
        {
            if ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER)
                cChildren = 0;  // Don't expand below it...
        }
        else if (fPrinterTest)
        {
            // Special case when we are only allowing printers.
            // for now I will simply key on the fact that it is non-FS.
            ULONG ulAttr = SFGAO_FILESYSTEM;

            psf->lpVtbl->GetAttributesOf(psf, 1, &pidl, &ulAttr);

            if ((ulAttr & SFGAO_FILESYSTEM)== 0)
            {
                cChildren = 0;      // Force to not have children;
            }
            else
            {
                ILFree(pidl);       // Dont want to add this one
                continue;           // Try the next one
            }
        }

        _AddItemToTree(pbfsf->hwndTree, pnmtv->itemNew.hItem,
                pidl, cChildren);
        cAdded++;
    }

    // Now Cleanup after ourself
    penum->lpVtbl->Release(penum);

    _BFSFSort(pbfsf, pnmtv->itemNew.hItem, psf);
    psf->lpVtbl->Release(psf);
    ILFree(pidlToExpand);

    // If we did not add anything we should update this item to let
    // the user know something happened.
    //
    if (cAdded == 0)
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;   // only change the number of children
        tvi.hItem = pnmtv->itemNew.hItem;
        tvi.cChildren = 0;

        TreeView_SetItem(pbfsf->hwndTree, &tvi);

    }

    return TRUE;
}



void _BFSFHandleDeleteItem(PBFSF pbfsf, LPNM_TREEVIEW pnmtv)
{
    // We need to free the IDLists that we allocated previously
    if (pnmtv->itemOld.lParam != 0)
        ILFree((LPITEMIDLIST)pnmtv->itemOld.lParam);
}


LPITEMIDLIST _BFSFUpdateISHCache(PBFSF pbfsf, HTREEITEM hti,
        LPITEMIDLIST pidlItem)
{
    HTREEITEM htiParent;
    IShellFolder * psfDesktop = Desktop_GetShellFolder(TRUE);

    if (pidlItem == NULL)
        return(NULL);

    // Need to handle the root case here!
    htiParent = TreeView_GetParent(pbfsf->hwndTree, hti);
    if ((htiParent != pbfsf->htiCurParent) || (pbfsf->psfParent == NULL))
    {
        LPITEMIDLIST pidl;

        if (pbfsf->psfParent)
        {

            if (pbfsf->psfParent != psfDesktop)
                pbfsf->psfParent->lpVtbl->Release(pbfsf->psfParent);
            pbfsf->psfParent = NULL;
        }

        if (htiParent)
        {
            pidl = _GetIDListFromTreeItem(pbfsf->hwndTree, htiParent);
        }
        else
        {
            //
            // If No Parent then the item here is one of our roots which
            // should be fully qualified.  So try to get the parent by
            // decomposing the ID.
            //
            LPITEMIDLIST pidlT = (LPITEMIDLIST)ILFindLastID(pidlItem);
            if (pidlT != pidlItem)
            {
                pidl = ILClone(pidlItem);
                ILRemoveLastID(pidl);
                pidlItem = pidlT;
            }
            else
                pidl = NULL;
        }

        pbfsf->htiCurParent = htiParent;

        // If still NULL then we use root of evil...
        if (pidl == NULL || (pidl->mkid.cb == 0))
        {
            // Still one m
            pbfsf->psfParent = psfDesktop;

            if (pidl)
                ILFree(pidl);
        }

        else
        {
            psfDesktop->lpVtbl->BindToObject(psfDesktop,
                     pidl, NULL, &IID_IShellFolder, &pbfsf->psfParent);
            ILFree(pidl);

            if (pbfsf->psfParent == NULL)
                return NULL;
        }
    }
    return(ILFindLastID(pidlItem));
}



void _BFSFGetDisplayInfo(PBFSF pbfsf, TV_DISPINFO *pnm)
{
    TV_ITEM ti;
    LPITEMIDLIST pidlItem = (LPITEMIDLIST)pnm->item.lParam;

    if ((pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN)) == 0)
        return; // nothing for us to do here.

    pidlItem = _BFSFUpdateISHCache(pbfsf, pnm->item.hItem, pidlItem);

    ti.mask = 0;
    ti.hItem = (HTREEITEM)pnm->item.hItem;

    // They are asking for IconIndex.  See if we can find it now.
    // Once found update their list, such that they wont call us back for
    // it again.
    if (pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE))
    {
        // We now need to map the item into the right image index.
        ti.iImage = pnm->item.iImage = SHMapPIDLToSystemImageListIndex(
                pbfsf->psfParent, pidlItem, &ti.iSelectedImage);
        // we should save it back away to
        pnm->item.iSelectedImage = ti.iSelectedImage;
        ti.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    }
    // Also see if this guy has any child folders
    if (pnm->item.mask & TVIF_CHILDREN)
    {
        ULONG ulAttrs;

        ulAttrs = SFGAO_HASSUBFOLDER;
        pbfsf->psfParent->lpVtbl->GetAttributesOf(pbfsf->psfParent,
                1, &pidlItem, &ulAttrs);

        ti.cChildren = pnm->item.cChildren =
                (ulAttrs & SFGAO_HASSUBFOLDER)? 1 : 0;

        ti.mask |= TVIF_CHILDREN;

    }

    if (pnm->item.mask & TVIF_TEXT)
    {
        STRRET str;
        pbfsf->psfParent->lpVtbl->GetDisplayNameOf(pbfsf->psfParent,
                pidlItem, SHGDN_INFOLDER, &str);

        StrRetToStrN(pnm->item.pszText, pnm->item.cchTextMax, &str, pidlItem);
        ti.mask |= TVIF_TEXT;
        ti.pszText = pnm->item.pszText;
    }

    // Update the item now
    TreeView_SetItem(pbfsf->hwndTree, &ti);
}


void _BFSFHandleSelChanged(PBFSF pbfsf, LPNM_TREEVIEW pnmtv)
{
    LPITEMIDLIST pidl;
    ULONG ulAttrs = SFGAO_FILESYSTEM;
    BYTE bType;

    // We only need to do anything if we only want to return File system
    // level objects.
    if ((pbfsf->ulFlags & (BIF_RETURNONLYFSDIRS|BIF_RETURNFSANCESTORS|BIF_BROWSEFORPRINTER|BIF_BROWSEFORCOMPUTER)) == 0)
        goto NotifySelChange;

    // We need to get the attributes of this object...
    pidl = _BFSFUpdateISHCache(pbfsf, pnmtv->itemNew.hItem,
            (LPITEMIDLIST)pnmtv->itemNew.lParam);

    if (pidl)
    {
        BOOL fEnable;

        bType = SIL_GetType(pidl);
        if ((pbfsf->ulFlags & (BIF_RETURNFSANCESTORS|BIF_RETURNONLYFSDIRS)) != 0)
        {
            int i;
            // if this is the root pidl, then do a get attribs on 0
            // so that we'll get the attributes on the root, rather than
            // random returned values returned by FSFolder
            if (ILIsEmpty(pidl)) {
                i = 0;
            } else
                i = 1;

            pbfsf->psfParent->lpVtbl->GetAttributesOf(pbfsf->psfParent,
                                                      i, &pidl, &ulAttrs);

            fEnable = (((ulAttrs & SFGAO_FILESYSTEM) && (pbfsf->ulFlags & BIF_RETURNONLYFSDIRS)) ||
                ((ulAttrs & SFGAO_FILESYSANCESTOR) && (pbfsf->ulFlags & BIF_RETURNFSANCESTORS))) ||
                    ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        }
        else if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        else if ((pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
        {
            // Printers are of type Share and usage Print...
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SHARE);
        }

        EnableWindow(GetDlgItem(pbfsf->hwndDlg, IDOK),fEnable);

    }

NotifySelChange:
    if (pbfsf->lpfn) {
        pidl = _GetIDListFromTreeItem(pbfsf->hwndTree, pnmtv->itemNew.hItem);
        BFSFCallback(pbfsf, BFFM_SELCHANGED, (LPARAM)pidl);
        ILFree(pidl);
    }
}

BOOL BrowseSelectPidl(PBFSF pbfsf, LPCITEMIDLIST pidl)
{
    HTREEITEM htiParent;
    LPITEMIDLIST pidlTemp;
    LPITEMIDLIST pidlNext = NULL;
    LPITEMIDLIST pidlParent = NULL;
    BOOL fRet = FALSE;

    htiParent = TreeView_GetChild(pbfsf->hwndTree, NULL);
    if (htiParent) {

        // step through each item of the pidl
        for (;;) {
            TreeView_Expand(pbfsf->hwndTree, htiParent, TVE_EXPAND);
            pidlParent = _GetIDListFromTreeItem(pbfsf->hwndTree, htiParent);
            if (!pidlParent)
                break;

            pidlNext = ILClone(pidl);
            if (!pidlNext)
                break;

            pidlTemp = ILFindChild(pidlParent, pidlNext);
            if (!pidlTemp)
                break;

            if (ILIsEmpty(pidlTemp)) {
                // found it!
                //
                TreeView_SelectItem(pbfsf->hwndTree, htiParent);
                fRet = TRUE;
                break;
            } else {
                // loop to find the next item
                HTREEITEM htiChild;

                pidlTemp = ILGetNext(pidlTemp);
                if (!pidlTemp)
                    break;
                else
                    pidlTemp->mkid.cb = 0;


                htiChild = TreeView_GetChild(pbfsf->hwndTree, htiParent);
                while (htiChild) {
                    BOOL fEqual;
                    pidlTemp = _GetIDListFromTreeItem(pbfsf->hwndTree, htiChild);
                    if (!pidlTemp) {
                        htiChild = NULL;
                        break;
                    }
                    fEqual = ILIsEqual(pidlTemp, pidlNext);

                    ILFree(pidlTemp);
                    if (fEqual) {
                        break;
                    } else {
                        htiChild = TreeView_GetNextSibling(pbfsf->hwndTree, htiChild);
                    }
                }

                if (!htiChild) {
                    // we didn't find the next one... bail
                    break;
                } else {
                    // the found child becomes the next parent
                    htiParent = htiChild;
                    ILFree(pidlParent);
                    ILFree(pidlNext);
                }
            }

        }
    }

    if (pidlParent) ILFree(pidlParent);
    if (pidlNext) ILFree(pidlNext);
    return fRet;
}


// _BFSFOnInitDlg - Process the init dialog

BOOL _BFSFOnInitDlg(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HTREEITEM hti;
    PBFSF pbfsf = (PBFSF)lParam;
    HIMAGELIST himl;
    LPSTR lpsz;
    char szTitle[80];    // no title should be bigger than this!
    HWND hwndTree;

    lpsz = ResourceCStrToStr(HINST_THISDLL, pbfsf->lpszTitle);
    SetDlgItemText(hwnd, IDD_BROWSETITLE, lpsz);
    if (lpsz != pbfsf->lpszTitle)
    {
        LocalFree(lpsz);
        lpsz = NULL;
    }


    SetWindowLong(hwnd, DWL_USER, (LONG)lParam);
    pbfsf->hwndDlg = hwnd;
    hwndTree = pbfsf->hwndTree = GetDlgItem(hwnd, IDD_FOLDERLIST);

    if (hwndTree)
    {
        UINT swpFlags = SWP_FRAMECHANGED | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER
                | SWP_NOACTIVATE;
        RECT rc;
        POINT pt = {0,0};

        if (!(pbfsf->ulFlags & BIF_STATUSTEXT)) {
            HWND hwndStatus = GetDlgItem(hwnd, IDD_BROWSESTATUS);
            // nuke the status window
            ShowWindow(hwndStatus, SW_HIDE);
            MapWindowPoints(hwndStatus, hwnd, &pt, 1);
            GetClientRect(hwndTree, &rc);
            MapWindowPoints(hwndTree, hwnd, (POINT*)&rc, 2);
            rc.top = pt.y;
            swpFlags =  SWP_FRAMECHANGED | SWP_NOZORDER | SWP_NOACTIVATE;
        }

        Shell_GetImageLists(NULL, &himl);
	TreeView_SetImageList(hwndTree, himl, TVSIL_NORMAL);

        SetWindowLong(hwndTree, GWL_EXSTYLE,
                GetWindowLong(hwndTree, GWL_EXSTYLE) | WS_EX_CLIENTEDGE);

        // Now try to get this window to know to recalc
        SetWindowPos(hwndTree, NULL, rc.left, rc.top,
                     rc.right - rc.left, rc.bottom - rc.top, swpFlags);

    }

    // If they passed in a root, add it, else add the contents of the
    // Root of evil... to the list as ROOT objects.
    if (pbfsf->pidlRoot)
    {
        LPITEMIDLIST pidl;
        if (!HIWORD(pbfsf->pidlRoot)) {
            pidl = SHCloneSpecialIDList(NULL, (UINT)pbfsf->pidlRoot, TRUE);
        } else {
            pidl = ILClone(pbfsf->pidlRoot);
        }
        // Now lets insert the Root object
	hti = _AddItemToTree(hwndTree, TVI_ROOT, pidl, 1);
	// Still need to expand below this point. to the starting location
	// That was passed in. But for now expand the first level.
	TreeView_Expand(hwndTree, hti, TVE_EXPAND);
    }
    else
    {
        LPCITEMIDLIST pidlDrives = GetSpecialFolderIDList(NULL, CSIDL_DRIVES, FALSE);
	LPITEMIDLIST pidlDesktop = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, FALSE);
	HTREEITEM htiRoot = _AddItemToTree(hwndTree, TVI_ROOT, pidlDesktop, 1);

        // Expand the first level under the desktop
        TreeView_Expand(hwndTree, htiRoot, TVE_EXPAND);

        // Lets Preexpand the Drives portion....
        hti = TreeView_GetChild(hwndTree, htiRoot);
        while (hti)
        {
            LPITEMIDLIST pidl = _GetIDListFromTreeItem(hwndTree, hti);
            if (ILIsEqual(pidl, pidlDrives))
            {

                TreeView_Expand(hwndTree, hti, TVE_EXPAND);

                TreeView_SelectItem(hwndTree, hti);
                ILFree(pidl);
                break;
            }
            ILFree(pidl);
            hti = TreeView_GetNextSibling(hwndTree, hti);
        }
    }

    // go to our internal selection changed code to do any window enabling needed
    {
        NM_TREEVIEW nmtv;
        hti = TreeView_GetSelection(hwndTree);
        if (hti) {
            TV_ITEM ti;
            ti.mask = TVIF_PARAM;
            ti.hItem = hti;
            TreeView_GetItem(hwndTree, &ti);
            nmtv.itemNew.hItem = hti;
            nmtv.itemNew.lParam = ti.lParam;

            _BFSFHandleSelChanged(pbfsf, &nmtv);
        }
    }

    if ((pbfsf->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
    {
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_COMPUTER, szTitle, sizeof(szTitle));
        SetWindowText(hwnd, szTitle);
    }
    else if ((pbfsf->ulFlags & BIF_BROWSEFORPRINTER) != 0)
    {
        LoadString(HINST_THISDLL, IDS_FINDSEARCH_PRINTER, szTitle, sizeof(szTitle));
        SetWindowText(hwnd, szTitle);
    }

    BFSFCallback(pbfsf, BFFM_INITIALIZED, 0);

    return TRUE;
}

void _BFSFSetStatusText(PBFSF pbfsf, LPCSTR lpszText)
{
    char szText[100];
    if (!HIWORD(lpszText)) {
        LoadString(HINST_THISDLL, LOWORD(lpszText), szText, sizeof(szText));
        lpszText = szText;
    }
    SetDlgItemText(pbfsf->hwndDlg, IDD_BROWSESTATUS, lpszText);
}



// _BFSFOnCommand - Process the WM_COMMAND message

void _BFSFOnCommand(PBFSF pbfsf, int id, HWND hwndCtl, UINT codeNotify)
{
    HTREEITEM hti;
    switch (id)
    {
    case IDOK:
        // We can now update the structure with the idlist of the item selected
        hti = TreeView_GetSelection(pbfsf->hwndTree);
        pbfsf->pidlCurrent = _GetIDListFromTreeItem(pbfsf->hwndTree,
                hti);
        if (pbfsf->pszDisplayName || pbfsf->piImage)
        {
            TV_ITEM tvi;
            tvi.mask = (pbfsf->pszDisplayName)? (TVIF_TEXT | TVIF_IMAGE) :
                    TVIF_IMAGE;
            tvi.hItem = hti;
            tvi.pszText = pbfsf->pszDisplayName;
            tvi.cchTextMax = MAX_PATH;
            TreeView_GetItem(pbfsf->hwndTree, &tvi);

            if (pbfsf->piImage)
                *pbfsf->piImage = tvi.iImage;
        }
        EndDialog(pbfsf->hwndDlg, 1);     // To return TRUE.
        break;
    case IDCANCEL:
        EndDialog(pbfsf->hwndDlg, 0);     // to return FALSE from this.
        break;
    }
}




// _BSFSDlgProc - The dialog procedure for processing the browse
//          for starting folder dialog.

#pragma data_seg(".text", "CODE")
const static DWORD aBrowseHelpIDs[] = {  // Context Help IDs
    IDD_BROWSETITLE,  NO_HELP,
    IDD_BROWSESTATUS, NO_HELP,
    IDD_FOLDERLIST,   IDH_BROWSELIST,

    0, 0
};
#pragma data_seg()

BOOL CALLBACK _BFSFDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PBFSF pbfsf = (PBFSF)GetWindowLong(hwndDlg, DWL_USER);

    switch (msg) {
    HANDLE_MSG(pbfsf, WM_COMMAND, _BFSFOnCommand);
    HANDLE_MSG(hwndDlg, WM_INITDIALOG, _BFSFOnInitDlg);

    case WM_DESTROY:
        if (pbfsf->psfParent && (pbfsf->psfParent != Desktop_GetShellFolder(TRUE)))
        {
            pbfsf->psfParent->lpVtbl->Release(pbfsf->psfParent);
            pbfsf->psfParent = NULL;
        }
        break;

    case BFFM_SETSTATUSTEXT:
        _BFSFSetStatusText(pbfsf, (LPCSTR)lParam);
        break;

    case BFFM_SETSELECTION:
    {
        BOOL fRet;

        // wParam TRUE means path, not pidl
        if (wParam) {
            lParam = (LPARAM)SHSimpleIDListFromPath((LPSTR)lParam);
            if (!lParam)
                return FALSE;
        }
        fRet = BrowseSelectPidl(pbfsf, (LPITEMIDLIST)lParam);

        if (wParam)
            ILFree((LPITEMIDLIST)lParam);
        return fRet;
    }

    case BFFM_ENABLEOK:
        EnableWindow(GetDlgItem(hwndDlg, IDOK), lParam);
        break;


    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case TVN_GETDISPINFO:
            _BFSFGetDisplayInfo(pbfsf, (TV_DISPINFO *)lParam);
            break;

        case TVN_ITEMEXPANDING:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            _BFSFHandleItemExpanding(pbfsf, (LPNM_TREEVIEW)lParam);
            break;

        case TVN_ITEMEXPANDED:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;

        case TVN_DELETEITEM:
            _BFSFHandleDeleteItem(pbfsf, (LPNM_TREEVIEW)lParam);
            break;

        case TVN_SELCHANGED:
            _BFSFHandleSelChanged(pbfsf, (LPNM_TREEVIEW)lParam);
            break;
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (DWORD)(LPSTR) aBrowseHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (DWORD)(LPVOID) aBrowseHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\autoscrl.h ===
// stuff for doing auto scrolling
#define NUM_POINTS	3
typedef struct {	// asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0
BOOL DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\common.h ===
// common.h

#include "debug.h"

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))

#define StrToOleStrN(pwsz, cchWideChar,  psz,  cchMultiByte) MultiByteToWideChar(CP_ACP, 0, psz, cchMultiByte, pwsz, cchWideChar)
#define OleStrToStrN(psz,  cchMultiByte, pwsz, cchWideChar)  WideCharToMultiByte(CP_ACP, 0, pwsz, cchWideChar, psz, cchMultiByte, NULL, NULL)

#define QueryInterface(punk, iid, pobj)	(punk)->lpVtbl->QueryInterface(punk, iid, pobj)
#define AddRef(punk)			(punk)->lpVtbl->AddRef(punk)
#define Release(punk)			(punk)->lpVtbl->Release(punk)

#ifndef IToClass

#define _IOffset(class, itf)         ((UINT)(UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))

#endif

#ifdef _DEBUG

#define ReleaseLast(punk)   Assert(Release(punk) == 0)

#else

#define ReleaseLast(punk)   Release(punk)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\dropsrc.c ===
#include <windows.h>

#include "dropsrc.h"
#include "common.h"

//-----------------------------------------------------------------

typedef struct {
    IDropSource dsrc;
    UINT cRef;
    DWORD grfInitialKeyState;
} CDropSource;

IDropSourceVtbl c_CDropSourceVtbl;	// forward decl

HRESULT CDropSource_CreateInstance(IDropSource **ppdsrc)
{
    CDropSource *this = (CDropSource *)LocalAlloc(LPTR, sizeof(CDropSource));
    if (this)
    {
        this->dsrc.lpVtbl = &c_CDropSourceVtbl;
        this->cRef = 1;
        *ppdsrc = &this->dsrc;

        return S_OK;
    }
    else
    {
	*ppdsrc = NULL;
	return E_OUTOFMEMORY;
    }
}

STDMETHODIMP CDropSource_QueryInterface(IDropSource *pdsrc, REFIID riid, void **ppvObj)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    if (IsEqualIID(riid, &IID_IDropSource) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = this;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDropSource_AddRef(IDropSource *pdsrc)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    this->cRef++;
    return this->cRef;
}

STDMETHODIMP_(ULONG) CDropSource_Release(IDropSource *pdsrc)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    this->cRef--;
    if (this->cRef > 0)
	return this->cRef;

    LocalFree((HLOCAL)this);

    return 0;
}

STDMETHODIMP CDropSource_QueryContinueDrag(IDropSource *pdsrc, BOOL fEscapePressed, DWORD grfKeyState)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);

    if (fEscapePressed)
        return DRAGDROP_S_CANCEL;

    // initialize ourself with the drag begin button
    if (this->grfInitialKeyState == 0)
        this->grfInitialKeyState = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

    Assert(this->grfInitialKeyState);

    if (!(grfKeyState & this->grfInitialKeyState))
        return DRAGDROP_S_DROP;	
    else
        return S_OK;
}

STDMETHODIMP CDropSource_GiveFeedback(IDropSource *pdsrc, DWORD dwEffect)
{
    CDropSource *this = IToClass(CDropSource, dsrc, pdsrc);
    return DRAGDROP_S_USEDEFAULTCURSORS;
}

IDropSourceVtbl c_CDropSourceVtbl = {
    CDropSource_QueryInterface, CDropSource_AddRef, CDropSource_Release,
    CDropSource_QueryContinueDrag,
    CDropSource_GiveFeedback
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\debug.h ===
#define NOSHELLDEBUG	// don't take shell versions of this

// NOTE: You can #define your own DM_* values using bits in the HI BYTE
                                                               
#define DM_TRACE    0x0001      // Trace messages              
#define DM_WARNING  0x0002      // Warning                     
#define DM_ERROR    0x0004      // Error                       
#define DM_ASSERT   0x0008      // Assertions                  
                                                               
// NOTE: Default debug mask is 0x00ff (show everything)        
//                                                             
// Inside debugger, you can modify wDebugMask variable.        
//                                                             
// Set debug mask; returning previous.                         
//                                                             
UINT SetDebugMask(UINT mask);                           
                                                               
// Get debug mask.                                             
//                                                             
UINT GetDebugMask();                                    
                                                               
// Use this macro to declare message text that will be placed  
// in the CODE segment (useful if DS is getting full)          
//                                                             
// Ex: DBGTEXT(szMsg, "Invalid whatever: %d");               
//                                                             
#define DBGTEXT(sz, msg)      static const char sz[] = msg;                    
                                                               
#ifdef _DEBUG
// Assert(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
// AssertMsg(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.                  
//                                                             
// DebugMsg(mask, msg, args...) -                              
//         Generate wsprintf-formatted msg using               
//         specified debug mask.  System debug mask
//         governs whether message is output.
//                                                             
void AssertFailed(LPCSTR szFile, int line);

#define Assert(f)                           \
    {                                       \
        DBGTEXT(szFile, __FILE__);          \
        if (!(f))                           \
            AssertFailed(szFile, __LINE__); \
    }                                       
#define AssertE(f) Assert(f)                
                                                               
void __cdecl _AssertMsg(BOOL f, LPCSTR pszMsg, ...);	       
#define AssertMsg   _AssertMsg                                 
                                                               
void __cdecl _DebugMsg(UINT mask, LPCSTR psz, ...);	       
#define DebugMsg    _DebugMsg                                  
                                                               
#else

// retail versions to produce no code, no data
                                                               
#define Assert(f)                                              
#define AssertE(f)      (f)                                    
#define AssertMsg   1 ? (void)0 : (void)                       
#define DebugMsg    1 ? (void)0 : (void)                       
                                                               
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\idlist.h ===
LPITEMIDLIST  ILGetNext(LPCITEMIDLIST pidl);
UINT          ILGetSize(LPCITEMIDLIST pidl);
LPITEMIDLIST  ILCreate(void);
void          ILFree(LPITEMIDLIST pidl);
LPITEMIDLIST  ILCreateFromPath(LPCSTR szPath);
BOOL 	      ILGetDisplayName(LPCITEMIDLIST pidl, LPSTR pszName);
LPITEMIDLIST  ILFindLastID(LPCITEMIDLIST pidl);
BOOL          ILRemoveLastID(LPITEMIDLIST pidl);
LPITEMIDLIST  ILClone(LPCITEMIDLIST pidl);
LPITEMIDLIST  ILCloneFirst(LPCITEMIDLIST pidl);
BOOL          ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL          ILIsEqualItemID(LPCSHITEMID pmkid1, LPCSHITEMID pmkid2);
BOOL          ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
LPITEMIDLIST  ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
LPITEMIDLIST  ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
HRESULT       ILLoadFromStream(LPSTREAM pstm, LPITEMIDLIST *pidl);
HRESULT       ILSaveToStream(LPSTREAM pstm, LPCITEMIDLIST pidl);

LPITEMIDLIST  ILCreateFromPath(LPCSTR szPath);

// LPITEMIDLIST  ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);

BOOL StrRetToStrN(LPSTR szOut, UINT uszOut, LPSTRRET pStrRet, LPCITEMIDLIST pidl);

// helper macros
#define ILIsEmpty(pidl)	((pidl)->mkid.cb==0)
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

// unsafe macros
#define _ILSkip(pidl, cb)	((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)		_ILSkip(pidl, (pidl)->mkid.cb)

#ifdef _HIDA
//===========================================================================
// HIDA -- IDList Array handle
//===========================================================================

typedef HGLOBAL HIDA;

HIDA HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl);
void HIDA_Free(HIDA hida);
HIDA HIDA_Clone(HIDA hida);
UINT HIDA_GetCount(HIDA hida);
UINT HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax);

LPCITEMIDLIST HIDA_GetIDListPtr(HIDA hida, UINT i);
LPITEMIDLIST  HIDA_ILClone(HIDA hida, UINT i);
LPITEMIDLIST  IDA_ILClone(LPIDA pida, UINT i);
LPITEMIDLIST  HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl);

#define HIDA_Free(HIDA hida) GlobalFree(hida)

#endif _HIDA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\main.c ===
#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include "resource.h"
#include "debug.h"

#include "nsc.h"

typedef struct {
    HWND hDlg;
    HWND hwndNSC;
} DLGDATA;


BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DLGDATA * pdd = (DLGDATA *)GetWindowLong(hDlg, DWL_USER);

    switch (uMessage) {
    case WM_INITDIALOG:
        SetWindowLong(hDlg, DWL_USER, lParam);
	pdd = (DLGDATA *)lParam;
	pdd->hDlg = hDlg;
	pdd->hwndNSC = GetDlgItem(hDlg, IDC_USER1);

	SetWindowLong(pdd->hwndNSC, GWL_STYLE, NSS_DROPTARGET | GetWindowLong(pdd->hwndNSC, GWL_STYLE));

	{
            NSC_SETROOT sr = {NSSR_CREATEPIDL, NULL, (LPCITEMIDLIST)CSIDL_FAVORITES, 5, NULL};
            // NSC_SETROOT sr = {NSSR_CREATEPIDL, NULL, (LPCITEMIDLIST)CSIDL_FAVORITES, 10, NULL};

	    // SetWindowLong(pdd->hwndNSC, GWL_STYLE, GetWindowLong(pdd->hwndNSC, GWL_STYLE));
	    SetWindowLong(pdd->hwndNSC, GWL_STYLE, NSS_SHOWNONFOLDERS | GetWindowLong(pdd->hwndNSC, GWL_STYLE));
	    NameSpace_SetRoot(pdd->hwndNSC, &sr);
	}
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
        case IDCANCEL:
	    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        // case PSN_SETACTIVE:
        // case PSN_APPLY:
    	    break;

	default:
	    return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}



int WINAPI WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR pszCmdLine, int nCmdShow)
{
    DLGDATA dd;

    NameSpace_RegisterClass(hInst);

    OleInitialize(NULL);

    DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_DIALOG1), NULL, DlgProc, (LPARAM)&dd);

    OleUninitialize();

    return 0;
}


// stolen from the CRT, used to shirink our code

int _stdcall WinMainCRTStartup(void)
{
    int i;
    STARTUPINFO si;
    LPSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == '\"' ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
    	     != '\"') );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == '\"' )
    	    pszCmdLine++;
    }
    else {
        while (*pszCmdLine > ' ')
    	    pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= ' ')) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    ExitProcess(i);

    return i;	// We only come here when we are not the shell...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\idlist.c ===
#include <windows.h>
#include <shlobj.h>
#include "debug.h"
#include "idlist.h"

#include "common.h"

#ifdef DEBUG
// Dugging aids for making sure we dont use free pidls
#define VALIDATE_PIDL(pidl) Assert((pidl)->mkid.cb != 0xC5C5)
#else
#define VALIDATE_PIDL(pidl)
#endif


// BUGBUG: should call shell alocator
#define SHAlloc(cb)         (void *)LocalAlloc(LPTR, cb)
#define SHFree(p)           LocalFree((HLOCAL)p)
#define SHGetSize(p)        LocalSize((HLOCAL)p)
#define SHRealloc(p, cb)    (void *)LocalReAlloc((HLOCAL)p, cb, LMEM_MOVEABLE | LMEM_ZEROINIT)

LPITEMIDLIST ILGetNext(LPCITEMIDLIST pidl)
{
    if (pidl && pidl->mkid.cb)
    {
        VALIDATE_PIDL(pidl);
        return _ILNext(pidl);
    }

    return NULL;
}

UINT ILGetSize(LPCITEMIDLIST pidl)
{
    UINT cbTotal = 0;
    if (pidl)
    {
        VALIDATE_PIDL(pidl);
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = _ILNext(pidl);
        }
    }

    return cbTotal;
}

#define CBIDL_MIN       256
#define CBIDL_INCL      256

LPITEMIDLIST _ILCreate(UINT cbSize)
{
    return (LPITEMIDLIST)SHAlloc(cbSize);
}

LPITEMIDLIST ILCreate()
{
    return (LPITEMIDLIST)SHAlloc(CBIDL_MIN);
}

/*
 ** _ILResize
 *
 *  PARAMETERS:
 *      cbExtra is the amount to add to cbRequired if the block needs to grow,
 *      or it is 0 if we want to resize to the exact size
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */

LPITEMIDLIST _ILResize(LPITEMIDLIST pidl, UINT cbRequired, UINT cbExtra)
{
    if (pidl==NULL)
    {
        pidl = _ILCreate(cbRequired+cbExtra);
    }
    else if (!cbExtra || SHGetSize(pidl) < cbRequired)
    {
        pidl = (LPITEMIDLIST)SHRealloc(pidl, cbRequired+cbExtra);
    }
    return pidl;
}

LPITEMIDLIST ILFindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    VALIDATE_PIDL(pidl);
    if (pidl == NULL)
        return NULL;

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = _ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}


BOOL ILRemoveLastID(LPITEMIDLIST pidl)
{
    BOOL fRemoved = FALSE;

    if (pidl == NULL)
        return(FALSE);

    if (pidl->mkid.cb)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST)ILFindLastID(pidl);

        Assert(pidlLast->mkid.cb);
        Assert(_ILNext(pidlLast)->mkid.cb==0);

        // Remove the last one
        pidlLast->mkid.cb = 0; // null-terminator
        fRemoved = TRUE;
    }

    return fRemoved;
}

LPITEMIDLIST ILClone(LPCITEMIDLIST pidl)
{
    UINT cb = ILGetSize(pidl);
    LPITEMIDLIST pidlRet = (LPITEMIDLIST)SHAlloc(cb);

    if (pidlRet)
    {
        // Notes: no need to zero-init.
        CopyMemory(pidlRet, pidl, cb);
    }
    return pidlRet;
}

LPITEMIDLIST ILCloneFirst(LPCITEMIDLIST pidl)
{
    UINT cb = pidl->mkid.cb+sizeof(pidl->mkid.cb);
    LPITEMIDLIST pidlRet = (LPITEMIDLIST)SHAlloc(cb);
    if (pidlRet)
    {
        // Notes: no need to zero-init.
        CopyMemory(pidlRet, pidl, pidl->mkid.cb);
        _ILNext(pidlRet)->mkid.cb = 0;
    }

    return pidlRet;
}

BOOL ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    IShellFolder *psfDesktop;

    if (FAILED(SHGetDesktopFolder(&psfDesktop)))
        return FALSE;

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);
    return psfDesktop->lpVtbl->CompareIDs(psfDesktop, 0, pidl1, pidl2) == 0;
}

// test if
//      pidl1 is a parent of pidl2

BOOL ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate)
{
    LPITEMIDLIST pidl2Prefix;
    UINT cb;
    LPCITEMIDLIST pidl1T;
    LPCITEMIDLIST pidl2T;

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);

    if (!pidl1 || !pidl2)
        return FALSE;

    for (pidl1T = pidl1, pidl2T = pidl2; !ILIsEmpty(pidl1T);
         pidl1T = _ILNext(pidl1T), pidl2T = _ILNext(pidl2T))
    {
        // if pidl2 is shorter than pidl1, pidl1 can't be its parent.
        if (ILIsEmpty(pidl2T))
            return FALSE;
    }

    if (fImmediate)
    {
        // If fImmediate is TRUE, pidl2T should contain exactly one ID.
        if (ILIsEmpty(pidl2T) || !ILIsEmpty(_ILNext(pidl2T)))
            return FALSE;
    }

    //
    // Create a new IDList from a portion of pidl2, which contains the
    // same number of IDs as pidl1.
    //
    cb = (UINT)pidl2T - (UINT)pidl2;
    pidl2Prefix = _ILCreate(cb + sizeof(pidl2->mkid.cb));
    if (pidl2Prefix)
    {
        BOOL fRet;

        CopyMemory(pidl2Prefix, pidl2, cb);

        Assert(ILGetSize(pidl2Prefix) == cb + sizeof(pidl2->mkid.cb));

        fRet = ILIsEqual(pidl1, pidl2Prefix);

        ILFree(pidl2Prefix);

        return fRet;
    }

    return FALSE;
}

// this returns a pointer to the child id ie:
// given pidlParent = \chicago\desktop
//      pidlChild = \chicago\desktop\foo\bar
// the return will point to the ID that represents \foo\bar
// NULL is returned if pidlParent is not a parent of pidlChild
LPITEMIDLIST ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild)
{
    if (ILIsParent(pidlParent, pidlChild, FALSE))
    {
        while (!ILIsEmpty(pidlParent))
        {
            pidlChild = _ILNext(pidlChild);
            pidlParent = _ILNext(pidlParent);
        }
        return (LPITEMIDLIST)pidlChild;
    }
    return NULL;
}

LPITEMIDLIST  ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST pidlNew;
    UINT cb1 = ILGetSize(pidl1) - sizeof(pidl1->mkid.cb);
    UINT cb2 = ILGetSize(pidl2);

    VALIDATE_PIDL(pidl1);
    VALIDATE_PIDL(pidl2);
    pidlNew = _ILCreate(cb1 + cb2);
    if (pidlNew)
    {
        CopyMemory(pidlNew, pidl1, cb1);
        CopyMemory(((LPSTR)pidlNew) + cb1, pidl2, cb2);
        Assert(ILGetSize(pidlNew) == cb1+cb2);
    }
    return pidlNew;
}

void ILFree(LPITEMIDLIST pidl)
{
    if (pidl)
    {
#ifdef DEBUG
        UINT cbSize = SHGetSize(pidl);
        VALIDATE_PIDL(pidl);

        // Fill the memory with some bad value...
        _memset(pidl, 0xE5, cbSize);

        // If large enough try to save the call return address of who
        // freed us in the 3-6 byte of the structure.
        if (cbSize >= 6)
            *((UINT*)((LPSTR)pidl + 2)) =  *(((UINT*)&pidl) - 1);

#endif
        SHFree(pidl);
    }
}

LPITEMIDLIST ILCreateFromPath(LPCSTR pszPath)
{
    LPITEMIDLIST pidl = NULL;
    IShellFolder *psfDesktop;
    if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
    {
        ULONG cchEaten;
        WCHAR wszPath[MAX_PATH];

        StrToOleStrN(wszPath, ARRAYSIZE(wszPath), pszPath, -1);

        psfDesktop->lpVtbl->ParseDisplayName(psfDesktop, NULL, NULL, wszPath, &cchEaten, &pidl, NULL);
    }
    return pidl;
}

//===========================================================================
// IDLIST: Stream access
// BUGBUG: check bytes read on Read calls?
//===========================================================================

HRESULT ILLoadFromStream(LPSTREAM pstm, LPITEMIDLIST * ppidl)
{
    HRESULT hres;
    ULONG cb;

    Assert(ppidl);

    // Delete the old one if any.
    if (*ppidl)
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    // Read the size of the IDLIST
    cb = 0;             // WARNING: We need to fill its HIWORD!
    hres = pstm->lpVtbl->Read(pstm, &cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hres) && cb)
    {
        // Create a IDLIST
        LPITEMIDLIST pidl = _ILCreate(cb);
        if (pidl)
        {
            // Read its contents
            hres = pstm->lpVtbl->Read(pstm, pidl, cb, NULL);
            if (SUCCEEDED(hres))
            {
                *ppidl = pidl;
            }
            else
            {
                ILFree(pidl);
            }
        }
        else
        {
           hres = E_OUTOFMEMORY;
        }
    }

    return hres;
}

// BUGBUG: check bytes written on Write calls?

HRESULT ILSaveToStream(LPSTREAM pstm, LPCITEMIDLIST pidl)
{
    HRESULT hres;
    ULONG cb = ILGetSize(pidl);
    Assert(HIWORD(cb) == 0);
    hres = pstm->lpVtbl->Write(pstm, &cb, sizeof(USHORT), NULL); // Yes, USHORT
    if (SUCCEEDED(hres) && cb)
    {
        if (SUCCEEDED(hres))
        {
            hres = pstm->lpVtbl->Write(pstm, pidl, cb, NULL);
        }
    }

    return hres;
}

#ifdef _HIDA

//===========================================================================
// IDLARRAY stuff
//===========================================================================

#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])


HIDA HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST * apidl)
{
    HIDA hida;
    UINT i;
    UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
    UINT cbTotal = offset + ILGetSize(pidlFolder);
    for (i=0; i<cidl ; i++) {
        cbTotal += ILGetSize(apidl[i]);
    }

    hida = GlobalAlloc(GPTR, cbTotal);  // This MUST be GlobalAlloc!!!
    if (hida)
    {
        LPIDA pida = (LPIDA)hida;       // no need to lock

        LPCITEMIDLIST pidlNext;
        pida->cidl = cidl;

        for (i=0, pidlNext=pidlFolder; ; pidlNext=apidl[i++])
        {
            UINT cbSize = ILGetSize(pidlNext);
            pida->aoffset[i] = offset;
            CopyMemory(((LPBYTE)pida)+offset, pidlNext, cbSize);
            offset += cbSize;

            Assert(ILGetSize(HIDA_GetPIDLItem(pida,i-1)) == cbSize);

            if (i==cidl)
                break;
        }

        Assert(offset == cbTotal);
    }

    return hida;
}

HIDA HIDA_Create2(LPVOID pida, UINT cb)
{
    HIDA hida = GlobalAlloc(GPTR, cb);
    if (hida)
    {
        CopyMemory((LPIDA)hida, pida, cb);      // no need to lock
    }
    return hida;
}

HIDA HIDA_Clone(HIDA hida)
{
    UINT cbTotal = GlobalSize(hida);
    HIDA hidaCopy = GlobalAlloc(GPTR, cbTotal);
    if (hidaCopy)
    {
        LPIDA pida = (LPIDA)GlobalLock(hida);
        CopyMemory((LPIDA)hidaCopy, pida, cbTotal);     // no need to lock
        GlobalUnlock(hida);
    }
    return hidaCopy;
}

UINT HIDA_GetCount(HIDA hida)
{
    UINT count = 0;
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida) {
        count = pida->cidl;
        GlobalUnlock(hida);
    }
    return count;
}

UINT HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
        LPCITEMIDLIST pidlItem   = HIDA_GetPIDLItem(pida, i);
        UINT cbFolder  = ILGetSize(pidlFolder)-sizeof(USHORT);
        UINT cbItem = ILGetSize(pidlItem);
        if (cbMax < cbFolder+cbItem) {
            if (pidlOut) {
                pidlOut->mkid.cb = 0;
            }
        } else {
            CopyMemory(pidlOut, pidlFolder, cbFolder);
            CopyMemory(((LPBYTE)pidlOut)+cbFolder, pidlItem, cbItem);
        }
        GlobalUnlock(hida);

        return (cbFolder+cbItem);
    }
    return 0;
}

//
// This one reallocated pidl if necessary. NULL is valid to pass in as pidl.
//
LPITEMIDLIST HIDA_FillIDList(HIDA hida, UINT i, LPITEMIDLIST pidl)
{
    UINT cbRequired = HIDA_GetIDList(hida, i, NULL, 0);
    pidl = _ILResize(pidl, cbRequired, 32); // extra 32-byte if we realloc
    if (pidl)
    {
        HIDA_GetIDList(hida, i, pidl, cbRequired);
    }

    return pidl;
}

LPCITEMIDLIST IDA_GetIDListPtr(LPIDA pida, UINT i)
{
    if (i == (UINT)-1 || i < pida->cidl)
    {
        return HIDA_GetPIDLItem(pida, i);
    }

    return NULL;
}

LPITEMIDLIST IDA_ILClone(LPIDA pida, UINT i)
{
    if (i < pida->cidl)
        return ILCombine(HIDA_GetPIDLFolder(pida), HIDA_GetPIDLItem(pida, i));
    return NULL;
}

LPITEMIDLIST HIDA_ILClone(HIDA hida, UINT i)
{
    LPIDA pida = (LPIDA)GlobalLock(hida);
    if (pida)
    {
        LPITEMIDLIST pidl = IDA_ILClone(pida, i);
        GlobalUnlock(hida);
        return pidl;
    }
    return NULL;
}

void HIDA_ReleaseStgMedium(LPIDA pida, STGMEDIUM *pmedium)
{
    if (pmedium->hGlobal && (pmedium->tymed==TYMED_HGLOBAL))
    {
#ifdef DEBUG
        if (pida)
        {
            LPIDA pidaT = (LPIDA)GlobalLock(pmedium->hGlobal);
            Assert(pidaT == pida);
            GlobalUnlock(pmedium->hGlobal);
        }
#endif
        GlobalUnlock(pmedium->hGlobal);
    }
    else
    {
        Assert(0);
    }

    SHReleaseStgMedium(pmedium);
}

#endif // _HIDA

BOOL StrRetToStrN(LPSTR szOut, UINT uszOut, LPSTRRET pStrRet, LPCITEMIDLIST pidl)
{
    switch (pStrRet->uType)
    {
    case STRRET_WSTR:
        OleStrToStrN(szOut, uszOut, pStrRet->pOleStr, -1);
        SHFree(pStrRet->pOleStr);
        break;

    case STRRET_CSTR:
        lstrcpyn(szOut, pStrRet->cStr, uszOut);
        break;

    case STRRET_OFFSET:
        if (pidl)
        {
            lstrcpyn(szOut, ((LPCSTR)&pidl->mkid)+pStrRet->uOffset, uszOut);
            break;
        }

        // Fall through
    default:
        if (uszOut)
            *szOut = '\0';
        return FALSE;
    }

    return TRUE;
}


#if 0
//
//  This is a helper function to be called from within IShellFolder::CompareIDs.
// When the first IDs of pidl1 and pidl2 are the (logically) same.
//
// Required:
//  psf && pidl1 && pidl2 && !ILEmpty(pidl1) && !ILEmpty(pidl2)
//
HRESULT ILCompareRelIDs(IShellFolder *psfParent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres;
    LPCITEMIDLIST pidlRel1 = _ILNext(pidl1);
    LPCITEMIDLIST pidlRel2 = _ILNext(pidl2);
    if (ILIsEmpty(pidlRel1))
    {
        if (ILIsEmpty(pidlRel2)) {
            hres = 0;
        } else {
            hres = (HRESULT)-1;
        }
    }
    else
    {
        if (ILIsEmpty(pidlRel2))
        {
            hres = 1;
        }
        else
        {
            //
            // Neither pidlRel1 nor pidlRel2 is empty.
            //  (1) Bind to the next level of the IShellFolder
            //  (2) Call its CompareIDs to let it compare the rest of IDs.
            //
            // Notes: We should create pidlNext not from pidl2 but from pidl1
            //  because fstreex.c may pass simple pidl2.
            //
            LPITEMIDLIST pidlNext = ILClone(pidl1);
            if (pidlNext)
            {
                IShellFolder *psfNext;
                _ILNext(pidlNext)->mkid.cb = 0;
                hres = psfParent->lpVtbl->BindToObject(psfParent, pidlNext, NULL,
                                &IID_IShellFolder, &psfNext);

                if (SUCCEEDED(hres))
                {
                    hres = psfNext->lpVtbl->CompareIDs(psfNext, 0, pidlRel1, pidlRel2);
                    psfNext->lpVtbl->Release(psfNext);
                }
                ILFree(pidlNext);
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }
    return hres;
}

void StrRetFormat(LPSTRRET pStrRet, LPCITEMIDLIST pidlRel, LPCSTR pszTemplate, LPCSTR pszAppend)
{
     LPSTR pszRet;
     char szT[MAX_PATH];

     StrRetToStrN(szT, sizeof(szT), pStrRet, pidlRel);
     pszRet = ShellConstructMessageString(HINST_THISDLL, pszTemplate, pszAppend, szT);
     if (pszRet)
     {
        pStrRet->uType = STRRET_CSTR;
        lstrcpyn(pStrRet->cStr, pszRet, sizeof(pStrRet->cStr));
        Free(pszRet);
     }
}

//
// Notes: This one passes SHGDN_FORMARSING to ISF::GetDisplayNameOf.
//
HRESULT ILGetRelDisplayName(IShellFolder *psf, LPSTRRET pStrRet,
                                   LPCITEMIDLIST pidlRel, LPCSTR pszName,
                                   LPCSTR pszTemplate)
{
    HRESULT hres;
    LPITEMIDLIST pidlLeft = ILCloneFirst(pidlRel);

    if (pidlLeft)
    {
        IShellFolder *psfNext;
        hres = psf->lpVtbl->BindToObject(psf, pidlLeft, NULL,
                    &IID_IShellFolder, &psfNext);
        if (SUCCEEDED(hres))
        {
            LPCITEMIDLIST pidlRight = _ILNext(pidlRel);
            hres = psfNext->lpVtbl->GetDisplayNameOf(psfNext, pidlRight, SHGDN_INFOLDER|SHGDN_FORPARSING, pStrRet);
            if (SUCCEEDED(hres))
            {
                if (pszTemplate)
                {
                    StrRetFormat(pStrRet, pidlRight, pszTemplate, pszName);
                }
                else
                {
                    hres = StrRetCatLeft(pszName, pStrRet, pidlRight);
                }
            }
            psfNext->lpVtbl->Release(psfNext);
        }
        
        ILFree(pidlLeft);
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }
    return hres;
}

LPITEMIDLIST ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend)
{
    UINT cbUsed, cbRequired;

    // Create the ID list, if it is not given.
    if (!pidl)
    {
        pidl = ILCreate();
        if (!pidl)
            return NULL;        // memory overflow
    }

    cbUsed = ILGetSize(pidl);
    cbRequired = cbUsed + pmkid->cb;

    pidl = _ILResize(pidl, cbRequired, CBIDL_INCL);
    if (!pidl)
        return NULL;    // memory overflow

    if (fAppend)
    {
        // Append it.
        CopyMemory(_ILSkip(pidl, cbUsed-sizeof(pidl->mkid.cb)), pmkid, pmkid->cb);
    }
    else
    {
        // Put it at the top
        MoveMemory(_ILSkip(pidl, pmkid->cb), pidl, cbUsed);
        CopyMemory(pidl, pmkid, pmkid->cb);

        Assert(ILGetSize(_ILNext(pidl))==cbUsed);
    }

    // We must put zero-terminator because of LMEM_ZEROINIT.
    _ILSkip(pidl, cbRequired-sizeof(pidl->mkid.cb))->mkid.cb = 0;
    Assert(ILGetSize(pidl) == cbRequired);

    return pidl;
}


BOOL ILGetDisplayName(LPCITEMIDLIST pidl, LPSTR pszPath)
{
    BOOL fSuccess = FALSE; // assume error
    STRRET srName;
    IShellFolder *psfDesktop;

    SHGetDesktopFolder(&psfDesktop);

    VALIDATE_PIDL(pidl);
    if (SUCCEEDED(psfDesktop->lpVtbl->GetDisplayNameOf(psfDesktop, pidl, SHGDN_FORPARSING, &srName)))
    {
        StrRetToStrN(pszPath, MAX_PATH, &srName, pidl);
        fSuccess = TRUE;
    }

    return fSuccess;
}



#endif // not used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\dropsrc.h ===
// dropsource.h

HRESULT CDropSource_CreateInstance(IDropSource **ppdsrc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\nsc.h ===
// Name Space Control definitions

#define NAME_SPACE_CLASS    "NameSpaceControl"	// window class name

// Window Styles

#define NSS_TREE		0x0000	    // tree control
#define NSS_COMBOBOX		0x0001	    // combo box

#define NSS_SHOWNONFOLDERS	0x0002	    // include non folder things (files)
#define NSS_SHOWHIDDEN		0x0004
#define NSS_ONLYFSDIRS		0x0008	    // For finding a folder to start document searching
#define NSS_DONTGOBELOWDOMAIN	0x0010	    // For starting the Find Computer
#define NSS_RETURNFSANCESTORS	0x0020
#define NSS_DROPTARGET		0x0040	    // register as a drop target
#define NSS_BROWSEFORCOMPUTER	0x4000	    // Browsing for Computers.
#define NSS_BROWSEFORPRINTER	0x8000	    // Browsing for Printers


// structures

typedef DWORD HNAMESPACEITEM;	// handle to a name space item

typedef enum {
    NSIF_HITEM		= 0x0001,
    NSIF_FOLDER		= 0x0002,
    NSIF_PARENTFOLDER	= 0x0004,
    NSIF_IDLIST		= 0x0008,
    NSIF_FULLIDLIST	= 0x0010,
    NSIF_ATTRIBUTES	= 0x0020
} NSI_FLAGS;

typedef struct {
    NSI_FLAGS	    flags;
    HNAMESPACEITEM  hitem;
    IShellFolder    *psf;
    LPCITEMIDLIST   pidl;
    DWORD	    dwAttributes;
} NSC_ITEMINFO;

typedef enum {
    NSSR_ENUMBELOWROOT  = 0x0001,
    NSSR_CREATEPIDL     = 0x0002,
} NSSR_FLAGS;

typedef struct {
    NSSR_FLAGS	    flags;
    IShellFolder    *psf;           // NULL -> desktop shell folder
    LPCITEMIDLIST   pidlRoot;       // PIDL, NULL for desktop, or CSIDL for shell special folder
    int             iExpandDepth;   // how many levels to expand the tree
    LPCITEMIDLIST   pidlExpandTo;   // NULL, or PIDL to expand to
} NSC_SETROOT;

// Window Messages

#define NSM_SETROOT	(WM_USER + 1)

#define NameSpace_SetRoot(hwnd, psr) \
    (BOOL)SendMessage(hwnd, NSM_SETROOT, (WPARAM)0, (LPARAM)psr)

#define NSM_GETIDLIST	(WM_USER + 2)

#define NameSpace_GetIDList(hwnd, hitem) \
    (LPITEMIDLIST)SendMessage(hwnd, NSM_GETPIDL, 0, (WPARAM)hitem)

#define NameSpace_GetFullIDList(hwnd, hitem) \
    (LPITEMIDLIST)SendMessage(hwnd, NSM_GETPIDL, 1, (WPARAM)hitem)

#define NSM_GETITEMINFO	(WM_USER + 3)
#define NameSpace_GetItemInfo(hwnd, hitem, pinfo) \
    (BOOL)SendMessage(hwnd, NSM_GETITEMINFO, (WPARAM)hitem, (LPARAM)pinfo)

#define NSM_FINDITEM	(WM_USER + 4)
#define NameSpace_FindItem(hwnd, pidl, pinfo) \
    (HNAMESPACEITEM)SendMessage(hwnd, NSM_FINDITEM, (WPARAM)pidl, (LPARAM)pinfo)

#define NSM_DOVERB      (WM_USER + 5)
#define NameSpace_DoVerb(hwnd, hitem, pszVerb) \
    (HNAMESPACEITEM)SendMessage(hwnd, NSM_DOVERB, (WPARAM)hitem, (LPARAM)pszVerb)

// WM_NOTIFY codes
#define NSN_FIRST       (0U - 800)

#define NSN_SELCHANGE	(NSN_FIRST - 1)
#define NSN_BEGINDRAG   (NSN_FIRST - 2)
#define NSN_ENDDRAG	(NSN_FIRST - 3)
#define NSN_FILTERITEM	(NSN_FIRST - 4)
#define NSN_PREDOVERB   (NSN_FIRST - 5)
#define NSN_AFTERDOVERB (NSN_FIRST - 6)


// structure in lParam for NSN_FILTERITEM
typedef struct {
    NMHDR	    hdr;
    NSC_ITEMINFO    item;
} NS_NOTIFY;

// private stuff --------------------------------------

// API

BOOL NameSpace_RegisterClass(HINSTANCE hinst);


typedef struct
{
    HWND hwnd;			// window handle of this control
    HWND hwndParent;		// parent window to notify
    HWND hwndTree;		// tree or combo box
    DWORD style;
    UINT flags;			// NSCF_ state bits
    UINT id;			// our control ID
    BOOL fCacheIsDesktop : 1;	// state flags
    BOOL fAutoExpanding : 1;    // tree is auto-expanding

    // HWND hwndNextViewer;	// BUGBUG: implement this
    // HTREEITEM htiCut;
    IContextMenu *pcm;		// context menu currently being displayed

    IShellFolder *psfRoot;

    LPITEMIDLIST pidlRoot;

    HTREEITEM htiCache;		// tree item associated with Current shell folder
    IShellFolder *psfCache;	// cache of the last IShellFolder I needed...

    HTREEITEM htiDragging;      // item being dragged

    ULONG nChangeNotifyID;      // SHChangeNotify registration ID
} NSC;


LPITEMIDLIST _CacheParentShellFolder(NSC *pns, HTREEITEM hti, LPITEMIDLIST pidl);

// nscdrop.c

void CTreeDropTarget_Register(NSC *pns);
void CTreeDropTarget_Revoke(NSC *pns);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by nsc.RC
//
#define IDD_DIALOG1                     101
#define IDC_USER1                       1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\nsc.c ===
#define NOSHELLDEBUG    // don't take shell versions of this

// todo:
//
//      "New Folder" capability
//
//      dlb click on folders should expand/collapse
//
//	delayed keyboard selection so keyboard navigation does not generate a sel change
//	
//	drag and drop image drawing (not just OLE cursors)
//
//	name space change notification. hook up notify handler
//
//	default keyboard accelerators (F2 = Rename, etc)
//
//      Partial expanded nodes in the tree "Tree Down" (TVIS_EXPANDPARTIAL) for net cases
//
//      Programbility:
//          notifies - sel changed, node expanded, verb executed, etc.
//          cmds - do verb, get item, etc.

#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>    // for SHChangeNotifyReigster

#include "idlist.h"

#include "nsc.h"
#include "dropsrc.h"
#include "common.h"

#define ID_CONTROL  100

#define WM_CHANGENOTIFY  (WM_USER + 11)

#define SHCNE_FOLDERS                           \
    (SHCNE_MKDIR         | SHCNE_RMDIR |        \
     SHCNE_MEDIAINSERTED | SHCNE_MEDIAREMOVED | \
     SHCNE_DRIVEREMOVED  | SHCNE_DRIVEADD |     \
     SHCNE_RENAMEFOLDER  |                      \
     SHCNE_UPDATEDIR     |                      \
     SHCNE_UPDATEITEM    |                      \
     SHCNE_SERVERDISCONNECT |                   \
     SHCNE_UPDATEIMAGE      |                   \
     SHCNE_DRIVEADDGUI)

#define SHCNE_ITEMS (SHCNE_CREATE | SHCNE_DELETE | SHCNE_RENAMEITEM | SHCNE_ASSOCCHANGED)


void _RegisterNotify(NSC *pns, BOOL fReRegister)
{
    if (pns->nChangeNotifyID)
    {
        SHChangeNotifyDeregister(pns->nChangeNotifyID);
        pns->nChangeNotifyID = 0;
    }

    if (fReRegister)
    {
        SHChangeNotifyEntry fsne;

        fsne.pidl = pns->pidlRoot;
        fsne.fRecursive = TRUE;

        pns->nChangeNotifyID = SHChangeNotifyRegister(pns->hwnd,
            // SHCNRF_NewDelivery | 
            SHCNRF_ShellLevel | SHCNRF_InterruptLevel,
            pns->style & NSS_SHOWNONFOLDERS ? (SHCNE_FOLDERS | SHCNE_ITEMS) : (SHCNE_FOLDERS),
            WM_CHANGENOTIFY, 1, &fsne);
    }
}

LRESULT _OnNCCreate(HWND hwnd, LPCREATESTRUCT pcs)
{
    NSC *pns = LocalAlloc(LPTR, sizeof(NSC));
    if (pns)
    {
	pns->hwnd = hwnd;
	pns->hwndParent = pcs->hwndParent;
	pns->style = pcs->style;
	pns->id = (UINT)pcs->hMenu;

	// remove border styles from our window that we propogated to
	// our child control

	SetWindowLong(hwnd, GWL_STYLE, pcs->style & ~WS_BORDER);
	SetWindowLong(hwnd, GWL_EXSTYLE, pcs->dwExStyle & ~WS_EX_CLIENTEDGE);

	pns->hwndTree = CreateWindowEx(pcs->dwExStyle, WC_TREEVIEW, NULL,
	    (pcs->style & 0xFFFF0000) | (WS_CHILD | TVS_HASBUTTONS | TVS_EDITLABELS | TVS_SHOWSELALWAYS), // TVS_HASLINES | 
	    pcs->x, pcs->y, pcs->cx, pcs->cy,
	    hwnd, (HMENU)ID_CONTROL, pcs->hInstance, NULL);
	if (pns->hwndTree)
	{
	    SHFILEINFO sfi;
	    HIMAGELIST himl = (HIMAGELIST)SHGetFileInfo("C:\\", 0, &sfi, sizeof(SHFILEINFO),  SHGFI_SYSICONINDEX | SHGFI_SMALLICON);

	    SetWindowLong(hwnd, 0, (LONG)pns);

	    TreeView_SetImageList(pns->hwndTree, himl, TVSIL_NORMAL);

	    if (pns->style & NSS_DROPTARGET)
		CTreeDropTarget_Register(pns);

	    return TRUE;	// success
	}
	LocalFree(pns);
    }
    DebugMsg(DM_ERROR, "Failing NameSpaceControl create");

    return FALSE;	// fail the create
}

void _ReleaseCachedShellFolder(NSC *pns)
{
    if (pns->psfCache)
    {
        Release(pns->psfCache);

        pns->psfCache = NULL;
        pns->htiCache = NULL;
    }
}

void _ReleaseRootFolder(NSC *pns)
{
    if (pns->psfRoot)
    {
        Release(pns->psfRoot);
	pns->psfRoot = NULL;

        if (pns->pidlRoot)
	{
	    ILFree(pns->pidlRoot);
	    pns->pidlRoot = NULL;
	}
    }
}

void _OnNCDestroy(NSC *pns)
{
    _ReleaseRootFolder(pns);

    Assert(pns->pidlRoot == NULL);

    // ILFree(pns->pidlRoot);
    // pns->pidlRoot = NULL;

    _ReleaseCachedShellFolder(pns);

    if (pns->style & NSS_DROPTARGET)
        CTreeDropTarget_Revoke(pns);

    _RegisterNotify(pns, FALSE);


    LocalFree(pns);
}

// builds a fully qualified IDLIST from a given tree node by walking up the tree
// be sure to free this when you are done!

LPITEMIDLIST _GetFullIDList(HWND hwndTree, HTREEITEM hti)
{
    LPITEMIDLIST pidl;
    TV_ITEM tvi;

    Assert(hti);

    // now lets get the information about the item
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    tvi.hItem = hti;
    if (!TreeView_GetItem(hwndTree, &tvi))
    {
        DebugMsg(DM_ERROR, "bogus tree item passed");
        return NULL;
    }

    pidl = ILClone((LPITEMIDLIST)tvi.lParam);

    // Now walk up parents.
    while ((tvi.hItem = TreeView_GetParent(hwndTree, tvi.hItem)) && pidl)
    {
        LPITEMIDLIST pidlT;

        if (!TreeView_GetItem(hwndTree, &tvi))
            return pidl;   // will assume I messed up...

        pidlT = ILCombine((LPITEMIDLIST)tvi.lParam, pidl);

        ILFree(pidl);

        pidl = pidlT;

    }
    return pidl;
}

/*
pitem->flags;
pitem->hitem;
pitem->psf;
pitem->pidl;
pitem->dwAttributes;
*/

BOOL _GetItem(NSC *pns, NSC_ITEMINFO *pitem)
{
    // BUGBUG: validate pitem->hitem

    if (pitem->flags & NSIF_HITEM)
    {

    }

    if (pitem->flags & NSIF_FOLDER)
    {
        Assert(!(pitem->flags & NSIF_PARENTFOLDER));	// should be exclusive

    }
    else if (pitem->flags & NSIF_PARENTFOLDER)
    {

    }

    if (pitem->flags & (NSIF_IDLIST | NSIF_FULLIDLIST))
    {
        pitem->pidl = NULL;

        if (pitem->flags & NSIF_FULLIDLIST)
	        pitem->pidl = _GetFullIDList(pns->hwndTree, (HTREEITEM)pitem->hitem);
	}
	else
	{
	    TV_ITEM tvi;

	    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
	    tvi.hItem = (HTREEITEM)pitem->hitem;
	    if (TreeView_GetItem(pns->hwndTree, &tvi))
	    {
	        pitem->pidl = (LPITEMIDLIST)tvi.lParam;
	    }
    }

    if (pitem->flags & NSIF_ATTRIBUTES)
    {

    }
    return TRUE;
}

BOOL _SetItemNotify(NSC *pns, NSI_FLAGS flags)
{
    // NS_NOTIFY nsn;

    return TRUE;
}

// Some helper functions for processing the dialog

HTREEITEM _AddItemToTree(HWND hwndTree, HTREEITEM htiParent, LPCITEMIDLIST pidl, int cChildren)
{
    TV_INSERTSTRUCT tii;

    // Initialize item to add with callback for everything
    tii.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_CHILDREN;
    tii.hParent = htiParent;
    tii.hInsertAfter = TVI_FIRST;
    tii.item.iImage = I_IMAGECALLBACK;
    tii.item.iSelectedImage = I_IMAGECALLBACK;
    tii.item.pszText = LPSTR_TEXTCALLBACK;   //
    tii.item.cChildren = cChildren; //  Assume it has children
    tii.item.lParam = (LPARAM)pidl;

    return TreeView_InsertItem(hwndTree, &tii);
}

void _ExpandTree(NSC *pns, HTREEITEM htiRoot, int iDepth)
{
    HTREEITEM hti;

    if (iDepth == 0)
        return;

    TreeView_Expand(pns->hwndTree, htiRoot, TVE_EXPAND);

    if (iDepth == 1)
        return;     // avoid useless loop

    // recurse to children, expanding them
    for (hti = TreeView_GetChild(pns->hwndTree, htiRoot); hti; hti = TreeView_GetNextSibling(pns->hwndTree, hti))
    {
        _ExpandTree(pns, hti, iDepth - 1);
    }
}

// set the root of the name space control.
//
// in:
//	pidlRoot    NULL means the desktop
//		    HIWORD 0 -> LOWORD == ID of special folder (CSIDL_* values)

BOOL _OnSetRoot(NSC *pns, NSC_SETROOT *psr)
{
    _ReleaseRootFolder(pns);

    if (psr->psf)
    {
        pns->psfRoot = psr->psf;
    }
    else if (FAILED(SHGetDesktopFolder(&pns->psfRoot)))
    {
	DebugMsg(DM_ERROR, "Failed to get desktop folder");
	return FALSE;
    }

    AddRef(pns->psfRoot);	// we hang on to this

    // HIWORD/LOWORD stuff is to support pidl IDs instead of full pidl here
    if (HIWORD(psr->pidlRoot))
        pns->pidlRoot = ILClone(psr->pidlRoot);
    else
    {
	Assert(psr->psf == NULL);	// special folders are only valid for desktop shell folder

	SHGetSpecialFolderLocation(NULL, LOWORD(psr->pidlRoot) ? LOWORD(psr->pidlRoot) : CSIDL_DESKTOP, &pns->pidlRoot);
    }

    if (pns->pidlRoot)
    {
        HTREEITEM htiRoot = _AddItemToTree(pns->hwndTree, TVI_ROOT, pns->pidlRoot, 1);
	if (htiRoot)
	{
            _ExpandTree(pns, htiRoot, psr->iExpandDepth);

            TreeView_SelectItem(pns->hwndTree, htiRoot);

            _RegisterNotify(pns, TRUE);

	    return TRUE;
	}
    }

    DebugMsg(DM_ERROR, "set root failed");

    _ReleaseRootFolder(pns);

    return FALSE;
}


// cache the shell folder for a given tree item
// in:
//	hti	tree node to cache shell folder for. this my be
//		NULL indicating the root item.
//

BOOL _CacheShellFolder(NSC *pns, HTREEITEM hti)
{
    // in the cache?
    if ((hti != pns->htiCache) || (pns->psfCache == NULL))
    {
	// cache miss, do the work
        LPITEMIDLIST pidl;

	_ReleaseCachedShellFolder(pns);

	if (hti)
            pidl = _GetFullIDList(pns->hwndTree, hti);
	else
	{
	    // root item...
	    pidl = ILClone(pns->pidlRoot);
	    if (pidl && pidl->mkid.cb != 0)
	    {
	        ILRemoveLastID(pidl);
	    }
	}

	if (pidl)
	{
	    // special case for root of evil...
	    if (pidl->mkid.cb == 0)
	    {
		pns->psfCache = pns->psfRoot;
		AddRef(pns->psfCache);  // to match ref count
	    }
	    else
	    {
		pns->psfRoot->lpVtbl->BindToObject(pns->psfRoot, pidl, NULL, &IID_IShellFolder, &pns->psfCache);
	    }

	    ILFree(pidl);

	    if (pns->psfCache)
	    {
		pns->htiCache = hti;	// this is for the cache match
		return TRUE;
	    }
	    else
		DebugMsg(DM_ERROR, "failed to get cached shell folder");
	}
	else
	    DebugMsg(DM_ERROR, "failed to get create PIDL for cached shell folder");

	return FALSE;
    }
    return TRUE;
}

// pidlItem is typically a relative pidl, except in the case of the root where
// it can be a fully qualified pidl

LPITEMIDLIST _CacheParentShellFolder(NSC *pns, HTREEITEM hti, LPITEMIDLIST pidl)
{
    Assert(hti);

    if (_CacheShellFolder(pns, TreeView_GetParent(pns->hwndTree, hti)))
    {
	if (pidl == NULL)
	{
	    TV_ITEM tvi;
	    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
	    tvi.hItem = hti;
	    if (!TreeView_GetItem(pns->hwndTree, &tvi))
		return NULL;

	    pidl = (LPITEMIDLIST)tvi.lParam;
	}

        return ILFindLastID(pidl);
    }

    return NULL;
}

int CALLBACK _TreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    IShellFolder *psf = (IShellFolder *)lParamSort;
    HRESULT hres = psf->lpVtbl->CompareIDs(psf, 0, (LPITEMIDLIST)lParam1, (LPITEMIDLIST)lParam2);

    Assert(SUCCEEDED(hres));

    return (short)SCODE_CODE(hres);
}

void _Sort(NSC *pns, HTREEITEM hti, IShellFolder *psf)
{
    TV_SORTCB scb;

    scb.hParent = hti;
    scb.lpfnCompare = _TreeCompare;

    scb.lParam = (LPARAM)psf;
    TreeView_SortChildrenCB(pns->hwndTree, &scb, FALSE);
}

// filter function... let clients filter what gets added here

BOOL _ShouldAdd(NSC *pns, LPCITEMIDLIST pidl)
{
#if 0
    //
    // We need to special case here in the netcase where we onlyu
    // browse down to workgroups...
    //
    //
    // Here is where I also need to special case to not go below
    // workgroups when the appropriate option is set.
    //
    bType = SIL_GetType(pidl);
    if ((pns->ulFlags & BIF_DONTGOBELOWDOMAIN) && (bType & SHID_NET))
    {
	switch (bType & (SHID_NET | SHID_INGROUPMASK))
	{
	case SHID_NET_SERVER:
	    ILFree(pidl);       // Dont want to add this one
	    continue;           // Try the next one
	case SHID_NET_DOMAIN:
	    cChildren = 0;      // Force to not have children;
	}
    }
    else if ((pns->ulFlags & BIF_BROWSEFORCOMPUTER) && (bType & SHID_NET))
    {
	if ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER)
	    cChildren = 0;  // Don't expand below it...
    }
    else if (fPrinterTest)
    {
	// Special case when we are only allowing printers.
	// for now I will simply key on the fact that it is non-FS.
	ULONG ulAttr = SFGAO_FILESYSTEM;

	psf->lpVtbl->GetAttributesOf(psf, 1, &pidl, &ulAttr);

	if ((ulAttr & SFGAO_FILESYSTEM)== 0)
	{
	    cChildren = 0;      // Force to not have children;
	}
	else
	{
	    ILFree(pidl);       // Dont want to add this one
	    continue;           // Try the next one
	}
    }
#endif
    // send notify up to partent to let them filter
    return TRUE;
}

BOOL _OnItemExpanding(NSC *pns, NM_TREEVIEW *pnm)
{
    IShellFolder *psf;
    IEnumIDList *penum;              // Enumerator in use.
    DWORD grfFlags = SHCONTF_FOLDERS;
    int cAdded = 0;

    if ((pnm->action != TVE_EXPAND) || (pnm->itemNew.state & TVIS_EXPANDEDONCE))
        return FALSE;

    Assert(pnm->itemNew.hItem);

    if (!_CacheShellFolder(pns, pnm->itemNew.hItem))
        return FALSE;

    psf = pns->psfCache;
    AddRef(psf);	// hang on as adding items may change the cached psfCache

#if 0
    // Need to do a couple of special cases here to allow us to
    // browse for a network printer.  In this case if we are at server
    // level we then need to change what we search for non folders when
    // we are the level of a server.
    if (pns->ulFlags & BIF_BROWSEFORPRINTER)
    {
        grfFlags = SHCONTF_FOLDERS | SHCONTF_NETPRINTERSRCH;
        pidl = ILFindLastID(pidlToExpand);
        bType = SIL_GetType(pidl);
        fPrinterTest = ((bType & (SHID_NET|SHID_INGROUPMASK))==SHID_NET_SERVER);
        if (fPrinterTest)
            grfFlags |= SHCONTF_NONFOLDERS;
    }
    else
#endif

    if (pns->style & NSS_SHOWNONFOLDERS)
        grfFlags |= SHCONTF_NONFOLDERS;

    if (pns->style & NSS_SHOWHIDDEN)
        grfFlags |= SHCONTF_INCLUDEHIDDEN;

    // passing NULL hwnd makes the enum not put up UI. this is what we want
    // in auto-expand cases

    if (SUCCEEDED(psf->lpVtbl->EnumObjects(psf, 
        pns->fAutoExpanding ? NULL : pns->hwnd, grfFlags, &penum)))
    {
        UINT celt;
	LPITEMIDLIST pidl;

        while (penum->lpVtbl->Next(penum, 1, &pidl, &celt) == S_OK && celt == 1)
	{
	    int cChildren = I_CHILDRENCALLBACK;  // Do call back for children

            if (_ShouldAdd(pns, pidl))
            {
                _AddItemToTree(pns->hwndTree, pnm->itemNew.hItem, pidl, cChildren);
                cAdded++;
            }
            else
            {
                ILFree(pidl);
            }
	}
	ReleaseLast(penum);

	_Sort(pns, pnm->itemNew.hItem, psf);
    }

    Release(psf);

    // If we did not add anything we should update this item to let
    // the user know something happened.
    //
    if (cAdded == 0)
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;   // only change the number of children
        tvi.hItem = pnm->itemNew.hItem;
        tvi.cChildren = 0;

        TreeView_SetItem(pns->hwndTree, &tvi);
    }

    return TRUE;
}

void _OnDeleteItem(NSC *pns, NM_TREEVIEW *pnm)
{
    ILFree((LPITEMIDLIST)pnm->itemOld.lParam);
}

void _GetIconIndex(NSC *pns, LPITEMIDLIST pidl, ULONG ulAttrs, TVITEM *pitem)
{
    IShellIcon *psi;

    if (SUCCEEDED(QueryInterface(pns->psfCache, &IID_IShellIcon, &psi)))
    {
        if (psi->lpVtbl->GetIconOf(psi, pidl, 0, &pitem->iImage) == S_OK)
        {
            if (!(ulAttrs & SFGAO_FOLDER) || FAILED(psi->lpVtbl->GetIconOf(psi, pidl, GIL_OPENICON, &pitem->iSelectedImage)))
            {
                pitem->iSelectedImage = pitem->iImage;
            }

	    Release(psi);
            return;
        }
	Release(psi);
    }

    {
        // slow way...

        LPITEMIDLIST pidlFull = _GetFullIDList(pns->hwndTree, pitem->hItem);
	if (pidlFull)
	{
	    SHFILEINFO sfi;

	    SHGetFileInfo((LPCSTR)pidlFull, 0, &sfi, sizeof(SHFILEINFO), SHGFI_PIDL | SHGFI_SYSICONINDEX); //  | SHGFI_SMALLICON
	    pitem->iImage = sfi.iIcon;

	    if (!(ulAttrs & SFGAO_FOLDER))
                pitem->iSelectedImage = pitem->iImage;
            else
            {
                SHGetFileInfo((LPCSTR)pidlFull, 0, &sfi, sizeof(SHFILEINFO), SHGFI_PIDL | SHGFI_OPENICON | SHGFI_SYSICONINDEX);
                pitem->iSelectedImage = sfi.iIcon;
            }

	    ILFree(pidlFull);
	}
    }
}


int _GetChildren(NSC *pns, IShellFolder *psf, LPCITEMIDLIST pidl, ULONG ulAttrs)
{
    int cChildren = 0;  // assume none

    if (ulAttrs & SFGAO_FOLDER)
    {
        if (pns->style & NSS_SHOWNONFOLDERS)
        {
            // there is no SFGAO_ bit that includes non folders so we need to enum
            IShellFolder *psfItem;
	    if (SUCCEEDED(psf->lpVtbl->BindToObject(psf, pidl, NULL, &IID_IShellFolder, &psfItem)))
            {
                // if we are showing non folders we have to do an enum to peek down at items below
                IEnumIDList *penum;
                DWORD grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

                if (pns->style & NSS_SHOWHIDDEN)
                    grfFlags |= SHCONTF_INCLUDEHIDDEN;

                if (SUCCEEDED(psfItem->lpVtbl->EnumObjects(psfItem, NULL, grfFlags, &penum)))
                {
                    UINT celt;
	            LPITEMIDLIST pidlTemp;

                    if (penum->lpVtbl->Next(penum, 1, &pidlTemp, &celt) == S_OK && celt == 1)
	            {
                        ILFree(pidlTemp);
                        cChildren = 1;
                    }
                    Release(penum);
                }
                Release(psfItem);
            }
        }
        else
        {
            // if just folders we can peek at the attributes
            ULONG ulAttrs = SFGAO_HASSUBFOLDER;
            psf->lpVtbl->GetAttributesOf(psf, 1, &pidl, &ulAttrs);

            cChildren = (ulAttrs & SFGAO_HASSUBFOLDER) ? 1 : 0;
        }
    }
    return cChildren;
}

void _OnGetDisplayInfo(NSC *pns, TV_DISPINFO *pnm)
{
    LPITEMIDLIST pidl = _CacheParentShellFolder(pns, pnm->item.hItem, (LPITEMIDLIST)pnm->item.lParam);

    Assert(pidl);

    if (pidl == NULL)
        return;

    Assert(pns->psfCache);

    Assert(pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN));

    if (pnm->item.mask & TVIF_TEXT)
    {
        STRRET str;
        pns->psfCache->lpVtbl->GetDisplayNameOf(pns->psfCache, pidl, SHGDN_INFOLDER, &str);

        StrRetToStrN(pnm->item.pszText, pnm->item.cchTextMax, &str, pidl);
    }

    // make sure we set the attributes for those flags that need them
    if (pnm->item.mask & (TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE))
    {
        ULONG ulAttrs = SFGAO_FOLDER;
        pns->psfCache->lpVtbl->GetAttributesOf(pns->psfCache, 1, &pidl, &ulAttrs);

        // Also see if this guy has any child folders
        if (pnm->item.mask & TVIF_CHILDREN)
        {
            pnm->item.cChildren = _GetChildren(pns, pns->psfCache, pidl, ulAttrs);
        }

        if (pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE))
        {
            // We now need to map the item into the right image index.
	    _GetIconIndex(pns, pidl, ulAttrs, &pnm->item);
        }
    }

    // force the treeview to store this so we don't get called back again
    pnm->item.mask |= TVIF_DI_SETITEM;	
}

// send up the sel changed to let clients enable/disable buttons, etc.

void _OnSelChanged(NSC *pns, LPNM_TREEVIEW pnm)
{

#if 0
    LPITEMIDLIST pidl;
    ULONG ulAttrs = SFGAO_FILESYSTEM;
    BYTE bType;

    // We only need to do anything if we only want to return File system
    // level objects.
    if ((pns->ulFlags & (BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS | BIF_BROWSEFORPRINTER | BIF_BROWSEFORCOMPUTER)) == 0)
        goto NotifySelChange;

    // We need to get the attributes of this object...
    if (_CacheParentShellFolder(pns, pnm->itemNew.hItem, (LPITEMIDLIST)pnm->itemNew.lParam))
    {
        BOOL fEnable = TRUE;

        bType = SIL_GetType(pidl);
        if ((pns->ulFlags & (BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS)) != 0)
        {
            int i;
            // if this is the root pidl, then do a get attribs on 0
            // so that we'll get the attributes on the root, rather than
            // random returned values returned by FSFolder
            if (ILIsEmpty(pidl)) {
                i = 0;
            } else
                i = 1;

            pns->psfCache->lpVtbl->GetAttributesOf(pns->psfCache,
                                                      i, &pidl, &ulAttrs);

            fEnable = (((ulAttrs & SFGAO_FILESYSTEM) && (pns->ulFlags & BIF_RETURNONLYFSDIRS)) ||
                ((ulAttrs & SFGAO_FILESYSANCESTOR) && (pns->ulFlags & BIF_RETURNFSANCESTORS))) ||
                    ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
        }
        else if ((pns->ulFlags & BIF_BROWSEFORCOMPUTER) != 0)
	{
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SERVER);
	}
        else if ((pns->ulFlags & BIF_BROWSEFORPRINTER) != 0)
        {
            // Printers are of type Share and usage Print...
            fEnable = ((bType & (SHID_NET | SHID_INGROUPMASK)) == SHID_NET_SHARE);
        }

        EnableWindow(GetDlgItem(pns->hwnd, IDOK), fEnable);
    }

NotifySelChange:
    if (pns->lpfn) 
    {
        pidl = _GetFullIDList(pns->hwndTree, pnm->itemNew.hItem);
        BFSFCallback(pns, BFFM_SELCHANGED, (LPARAM)pidl);
        ILFree(pidl);
    }
#endif
}

const char c_szCut[] = "cut";
const char c_szRename[] = "rename";

LRESULT _ContextMenu(NSC *pns, short x, short y)
{
    HTREEITEM hti;
    POINT ptPopup;	// in screen coordinate

    if (x == -1 && y == -1)
    {
	// Keyboard-driven: Get the popup position from the selected item.
        hti = TreeView_GetSelection(pns->hwndTree);
	if (hti)
	{
	    RECT rc;
	    //
	    // Note that TV_GetItemRect returns it in client coordinate!
	    //
	    TreeView_GetItemRect(pns->hwndTree, hti, &rc, TRUE);
	    ptPopup.x = (rc.left + rc.right) / 2;
	    ptPopup.y = (rc.top + rc.bottom) / 2;
	    MapWindowPoints(pns->hwndTree, HWND_DESKTOP, &ptPopup, 1);
	}
    }
    else
    {
        TV_HITTESTINFO tvht;

	// Mouse-driven: Pick the treeitem from the position.
	ptPopup.x = x;
	ptPopup.y = y;

	tvht.pt = ptPopup;
	ScreenToClient(pns->hwndTree, &tvht.pt);

	hti = TreeView_HitTest(pns->hwndTree, &tvht);
    }

    if (hti)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder(pns, hti, NULL);
	if (pidl)
	{
            IContextMenu *pcm;

	    TreeView_SelectDropTarget(pns->hwndTree, hti);

            if (SUCCEEDED(pns->psfCache->lpVtbl->GetUIObjectOf(pns->psfCache, pns->hwnd, 1, &pidl, &IID_IContextMenu, NULL, &pcm)))
            {
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    UINT idCmd;

		    pns->pcm = pcm; // for IContextMenu2 code

                    pcm->lpVtbl->QueryContextMenu(pcm, hmenu, 0, 1, 0x7fff,
			    CMF_EXPLORE | CMF_CANRENAME);

                    // use pns->hwnd so menu msgs go there and I can forward them
                    // using IContextMenu2 so "Sent To" works

                    idCmd = TrackPopupMenu(hmenu,
                        TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                        ptPopup.x, ptPopup.y, 0, pns->hwnd, NULL);

	    	    if (idCmd)
                    {
			char szCommandString[64];
                        BOOL fHandled = FALSE;
			BOOL fCutting = FALSE;

			// We need to special case the rename command
			if (SUCCEEDED(pcm->lpVtbl->GetCommandString(pcm, idCmd - 1,
                            0, NULL, szCommandString, sizeof(szCommandString))))
			{
			    if (lstrcmpi(szCommandString, c_szRename)==0) 
			    {
                                TreeView_EditLabel(pns->hwndTree, hti);
                                fHandled = TRUE;
                            } 
			    else if (!lstrcmpi(szCommandString, c_szCut)) 
			    {
				fCutting = TRUE;
                            }
			}

                        if (!fHandled)
			{
                            CMINVOKECOMMANDINFO ici = {
                                sizeof(CMINVOKECOMMANDINFO),
                                0L,
                                pns->hwndTree,
                                MAKEINTRESOURCE(idCmd - 1),
                                NULL, NULL,
                                SW_NORMAL,
                            };

			    HRESULT hres = pcm->lpVtbl->InvokeCommand(pcm, &ici);
			    if (fCutting && SUCCEEDED(hres))
			    {
				TV_ITEM tvi;
				tvi.mask = TVIF_STATE;
				tvi.stateMask = TVIS_CUT;
				tvi.state = TVIS_CUT;
				tvi.hItem = hti;
				TreeView_SetItem(pns->hwndTree, &tvi);

				// pns->hwndNextViewer = SetClipboardViewer(pns->hwndTree);
				// pns->htiCut = hti;
			    }
			}
	    	    }
	            DestroyMenu(hmenu);
		    pns->pcm = NULL;
                }
                ReleaseLast(pcm);
            }
	    TreeView_SelectDropTarget(pns->hwndTree, NULL);
        }
    }
    return 0;
}


LRESULT _OnBeginLabelEdit(NSC *pns, TV_DISPINFO *ptvdi)
{
    BOOL fCantRename = TRUE;

    LPCITEMIDLIST pidl = _CacheParentShellFolder(pns, ptvdi->item.hItem, NULL);
    if (pidl)
    {
	DWORD dwAttribs = SFGAO_CANRENAME;
	pns->psfCache->lpVtbl->GetAttributesOf(pns->psfCache, 1, &pidl, &dwAttribs);
	if (dwAttribs & SFGAO_CANRENAME)
	    fCantRename = FALSE;
    }

    if (fCantRename)
        MessageBeep(0);

    return fCantRename;
}

LRESULT _OnEndLabelEdit(NSC *pns, TV_DISPINFO *ptvdi)
{
    LPCITEMIDLIST pidl;

    // See if the user cancelled
    if (ptvdi->item.pszText == NULL)
        return TRUE;       // Nothing to do here.

    Assert(ptvdi->item.hItem);

    pidl = _CacheParentShellFolder(pns, ptvdi->item.hItem, NULL);
    if (pidl)
    {
	UINT cch = lstrlen(ptvdi->item.pszText)+1;
	LPOLESTR pwsz = (LPOLESTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
	if (pwsz)
	{
	    StrToOleStrN(pwsz, cch, ptvdi->item.pszText, -1);

	    if (SUCCEEDED(pns->psfCache->lpVtbl->SetNameOf(pns->psfCache, pns->hwnd, pidl, pwsz, 0, NULL)))
	    {
		// SHChangeNotifyHandleEvents();

		// NOTES: pidl is no longer valid here.
	    
		//
		// Set the handle to NULL in the notification to let
		// the system know that the pointer is probably not
		// valid anymore.
		//
		ptvdi->item.hItem = NULL;
	    }
	    else
	    {
		SendMessage(pns->hwndTree, TVM_EDITLABEL, (WPARAM)ptvdi->item.pszText, (LPARAM)ptvdi->item.hItem);
	    }
	    LocalFree((HLOCAL)pwsz);
        }
    }

    return 0;	// We always return 0, "we handled it".
}

void _OnBeginDrag(NSC *pns, NM_TREEVIEW *pnmhdr)
{
    LPCITEMIDLIST pidl = _CacheParentShellFolder(pns, pnmhdr->itemNew.hItem, NULL);
    if (pidl)
    {
	DWORD dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;

	pns->psfCache->lpVtbl->GetAttributesOf(pns->psfCache, 1, &pidl, &dwEffect);

	dwEffect &= DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;

	if (dwEffect)
	{
	    IDataObject *pdtobj;
	    HRESULT hres = pns->psfCache->lpVtbl->GetUIObjectOf(pns->psfCache, pns->hwnd, 1, &pidl, &IID_IDataObject, NULL, &pdtobj);

    	    if (SUCCEEDED(hres))
	    {
		hres = OleInitialize(NULL);

		if (SUCCEEDED(hres))
		{
		    IDropSource *pdsrc;

		    if (SUCCEEDED(CDropSource_CreateInstance(&pdsrc)))
		    {
		        DWORD dwRet;

                        pns->htiDragging = pnmhdr->itemNew.hItem;

			DoDragDrop(pdtobj, pdsrc, dwEffect, &dwRet);

                        pns->htiDragging = NULL;

			DebugMsg(DM_TRACE, "DoDragDrop returns dwRet: %d", dwRet);

			Release(pdsrc);
		    }
		    OleUninitialize();
		}
    #if 0
		HIMAGELIST himlDrag = TreeView_CreateDragImage(pns->hwndTree, pnmhdr->itemNew.hItem);
		if (himlDrag) 
		{
		    if (DAD_SetDragImage(himlDrag, NULL))
		    {
			SHDoDragDrop(hwndOwner, pdtobj, NULL, dwEffect, &dwEffect);

			DAD_SetDragImage((HIMAGELIST)-1, NULL);
		    }
		    else
		    {
			DebugMsg(DM_TRACE, "sh ER - Tree_OnBeginDrag DAD_SetDragImage failed");
			Assert(0);
		    }
		    ImageList_Destroy(himlDrag);
		}
    #endif
		ReleaseLast(pdtobj);
	    }
	}
    }
}

void _InvokeContextMenu(IShellFolder *psf, LPCITEMIDLIST pidl, HWND hwnd, LPCSTR pszVerb)
{
    IContextMenu *pcm;
    if (SUCCEEDED(psf->lpVtbl->GetUIObjectOf(psf, hwnd, 1, &pidl, &IID_IContextMenu, NULL, &pcm)))
    {
        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            pcm->lpVtbl->QueryContextMenu(pcm, hmenu, 0, 1, 255, pszVerb ? 0 : CMF_DEFAULTONLY);
            if (pszVerb == NULL)
                pszVerb = MAKEINTRESOURCE(GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0) - 1);
            if (pszVerb)
            {
                CMINVOKECOMMANDINFOEX ici = {
                    sizeof(CMINVOKECOMMANDINFOEX),
                    0L,
                    hwnd,
                    pszVerb,
                    NULL, NULL,
                    SW_NORMAL,
                };

                pcm->lpVtbl->InvokeCommand(pcm, (LPCMINVOKECOMMANDINFO)&ici);
            }
            DestroyMenu(hmenu);
        }
        Release(pcm);
    }
}

void _DoVerb(NSC *pns, HTREEITEM hti, LPCSTR pszVerb)
{
    hti = hti ? hti : TreeView_GetSelection(pns->hwndTree);
    if (hti)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder(pns, hti, NULL);
	if (pidl)
	{
            _InvokeContextMenu(pns->psfCache, pidl, pns->hwnd, pszVerb);
        }
    }
}

BOOL _DoDlbClick(NSC *pns)
{
    HTREEITEM hti = TreeView_GetSelection(pns->hwndTree);
    if (hti)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder(pns, hti, NULL);
        if (pidl)
        {
            ULONG ulAttrs = SFGAO_FOLDER;
            pns->psfCache->lpVtbl->GetAttributesOf(pns->psfCache, 1, &pidl, &ulAttrs);

            if (ulAttrs & SFGAO_FOLDER)
                return FALSE;       // do default action (expand/collapse)

            _InvokeContextMenu(pns->psfCache, pidl, pns->hwnd, NULL);
        }
    }
    return TRUE;
}


HTREEITEM _GetNodeFromIDList(LPITEMIDLIST pidl)
{
    return NULL;
}

BOOL TryQuickRename(LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra)
{
#if 0
    LPOneTreeNode lpnSrc;
    BOOL fRet = FALSE;

    // This can happen when a folder is moved from a "rooted" Explorer outside
    // of the root
    if (!pidl || !pidlExtra)
        return FALSE;

    // this one was deleted
    lpnSrc = _GetNodeFromIDList(pidl, 0);
    if (!lpnSrc)
        return FALSE;

    if (lpnSrc == s_lpnRoot) 
    {
        OTInvalidateRoot();
        return TRUE;
    } 
    else 
    {
        // this one was created
        LPITEMIDLIST pidlClone = ILClone(pidlExtra);
        if (pidlClone) 
        {
            LPOneTreeNode lpnDestParent;

            ILRemoveLastID(pidlClone);

            // if the parent isn't created yet, let's not bother
            lpnDestParent = _GetNodeFromIDList(pidlClone, 0);
            ILFree(pidlClone);

            if (lpnDestParent) 
            {
                LPITEMIDLIST pidlLast = OTGetRealFolderIDL(lpnDestParent, ILFindLastID(pidlExtra));
                if (pidlLast) 
                {
                    LPSHELLFOLDER psf = OTBindToFolder(lpnDestParent);
                    if (psf) 
                    {
                        OTAddRef(lpnSrc); // addref because AdoptKid doesn't and OTAbandonKid releases

                        // remove lpnSrc from its parent's list.
                        OTAbandonKid(lpnSrc->lpnParent, lpnSrc);

                        // invalidate the new node's parent to get any children flags right
                        OTInvalidateNode(lpnDestParent);

                        // free any cached folders
                        OTSweepFolders(lpnSrc);
                        SFCFreeNode(lpnSrc);

                        OTFreeNodeData(lpnSrc);
                        lpnSrc->pidl = pidlLast;
                        lpnSrc->lpnParent = lpnDestParent;
                        OTUpdateNodeName(psf, lpnSrc);
                        AdoptKid(lpnDestParent, lpnSrc);

                        fRet = TRUE;

                        IUnknown_Release(psf);
                    }
                    else
                    {
                        ILFree(pidlLast);
                    }
                }
            }
        }
    }
    return fRet;
#else
    return FALSE;
#endif
}

void _DoChangeNotify(NSC *pns, LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra)
{
#if 0
    switch(lEvent)
    {
    case SHCNE_RENAMEFOLDER:
        // first try to just swap the nodes if it's  true rename (not a move)
        if (!TryQuickRename(pidl, pidlExtra))
        {
            // Rename is special.  We need to invalidate both
            // the pidl and the pidlExtra. so we call ourselves
            _DoHandleChangeNotify(pns, 0, pidlExtra, NULL);
        }
        break;

    case SHCNE_RMDIR:
        if (ILIsEmpty(pidl)) {
            // we've deleted the desktop dir.
            lpNode = s_lpnRoot;
            OTInvalidateRoot();
            break;
        }

        // Sitemaps are "inserted" items. We need the ability to remove them.
        // Unless the "fInserted" flag is reset, we can not remove them.
        if(lpNode = _GetNodeFromIDList(pidl, 0))
        {
            if(lpNode->fInserted)
                lpNode->fInserted = FALSE;
            lpNode = OTGetParent(lpNode);
            break;
        }

    case 0:
    case SHCNE_MKDIR:
    case SHCNE_DRIVEADD:
    case SHCNE_DRIVEREMOVED:
        if (pidl)
        {
            LPITEMIDLIST pidlClone = ILClone(pidl);
            if (pidlClone)
            {
                ILRemoveLastID(pidlClone);
                lpNode = _GetNodeFromIDList(pidlClone, 0);
                ILFree(pidlClone);
            }
        }
        break;

    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
        lpNode = _GetNodeFromIDList(pidl, 0);
        if (lpNode)
            lpNode = lpNode->lpnParent;
        break;

    case SHCNE_DRIVEADDGUI:
    case SHCNE_UPDATEITEM:
    case SHCNE_NETSHARE:
    case SHCNE_NETUNSHARE:
    case SHCNE_UPDATEDIR:
        lpNode = _GetNodeFromIDList(pidl, 0);
        break;

    case SHCNE_SERVERDISCONNECT:
        // nuke all our kids and mark ourselves invalid
        lpNode = _GetNodeFromIDList(pidl, 0);
        if (lpNode && NodeHasKids(lpNode))
        {
            int i;

            for (i = GetKidCount(lpNode) -1; i >= 0; i--) {
                OTRelease(GetNthKid(lpNode, i));
            }
            DPA_Destroy(lpNode->hdpaKids);
            lpNode->hdpaKids = KIDSUNKNOWN;
            OTInvalidateNode(lpNode);
            SFCFreeNode(lpNode);
        } else {
            lpNode = NULL;
        }
        break;

    case SHCNE_ASSOCCHANGED:
        break;

    case SHCNE_UPDATEIMAGE:
        if (pidl) {
            InvalidateImageIndices();
            DoInvalidateAll(s_lpnRoot, *(int UNALIGNED *)((BYTE*)pidl + 2));
        }
        break;
    }
#endif
}

#if 0
void _OnChangeNotify(NSC *pns, WPARAM wParam, LPARAM lParam)
{
    LPITEMIDLIST *ppidl;
    LONG lEvent;
    LPSHChangeNotificationLock pshcnl;

    pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
    if (pshcnl)
    {
        _DoChangeNotify(pns, lEvent, ppidl[0], ppidl[1]);

        SHChangeNotification_Unlock(pshcnl);
    }
}
#endif

LRESULT CALLBACK NameSpaceWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    NSC *pns = (NSC *)GetWindowLong(hwnd, 0);

    switch (uMsg) {
    case WM_NCCREATE:
        Assert(pns == NULL);
        return _OnNCCreate(hwnd, (LPCREATESTRUCT)lParam);

    case WM_NCDESTROY:
        if (pns)
            _OnNCDestroy(pns);
        break;

    case WM_SIZE:
        if (pns->hwndTree)
	    MoveWindow(pns->hwndTree, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
	break;

    case WM_STYLECHANGED:
        if (pns && wParam == GWL_STYLE)
            pns->style = ((LPSTYLESTRUCT)lParam)->styleNew;
        break;

    case WM_SETFOCUS:
        if (pns && pns->hwndTree)
            SetFocus(pns->hwndTree);
        break;

    case WM_SETFONT:
    case WM_GETFONT:
	if (pns && pns->hwndTree)
	    return SendMessage(pns->hwndTree, uMsg, wParam, lParam);
        break;

    case WM_NOTIFY:
        Assert(((NMHDR *)lParam)->idFrom == ID_CONTROL);

        switch (((NMHDR *)lParam)->code) {

        // we track this through WM_CONTEXTMENU
        // case NM_RCLICK:

        case NM_RETURN:
        case NM_DBLCLK:
            return _DoDlbClick(pns);

        case TVN_GETDISPINFO:
            _OnGetDisplayInfo(pns, (TV_DISPINFO *)lParam);
            break;

        case TVN_ITEMEXPANDING:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            _OnItemExpanding(pns, (LPNM_TREEVIEW)lParam);
            break;

        case TVN_ITEMEXPANDED:
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;

        case TVN_DELETEITEM:
            _OnDeleteItem(pns, (LPNM_TREEVIEW)lParam);
            break;

        case TVN_SELCHANGED:
            _OnSelChanged(pns, (LPNM_TREEVIEW)lParam);
            break;

	case TVN_BEGINLABELEDIT:
	    return _OnBeginLabelEdit(pns, (TV_DISPINFO *)lParam);

	case TVN_ENDLABELEDIT:
	    return _OnEndLabelEdit(pns, (TV_DISPINFO *)lParam);

	case TVN_BEGINDRAG:
	case TVN_BEGINRDRAG:
	    _OnBeginDrag(pns, (NM_TREEVIEW *)lParam);
	    break;
        }
        break;

    case WM_CONTEXTMENU:
        _ContextMenu(pns, (short)LOWORD(lParam), (short)HIWORD(lParam));
	break;

    case WM_INITMENUPOPUP:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (pns->pcm)
	{
            IContextMenu2 *pcm2;
            if (SUCCEEDED(QueryInterface(pns->pcm, &IID_IContextMenu2, &pcm2)))
            {
                pcm2->lpVtbl->HandleMenuMsg(pcm2, uMsg, wParam, lParam);
                Release(pcm2);
            }
	}
	break;

    case WM_CHANGENOTIFY:
        #define ppidl ((LPITEMIDLIST *)wParam)
        _DoChangeNotify(pns, (LONG)lParam, ppidl[0], ppidl[1]);
        break;

    case NSM_SETROOT:
        return _OnSetRoot(pns, (NSC_SETROOT *)lParam);

    case NSM_GETIDLIST:
        if (wParam)
	    return (LRESULT)_GetFullIDList(pns->hwndTree, (HTREEITEM)lParam);
	else
	{
	    TV_ITEM tvi;

	    // now lets get the information about the item
	    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
	    tvi.hItem = (HTREEITEM)lParam;
	    if (!TreeView_GetItem(pns->hwndTree, &tvi))
	        return 0;

	    return (LRESULT)tvi.lParam;	// relative PIDL
	}
	break;

    case NSM_DOVERB:
        _DoVerb(pns, NULL, (LPCSTR)lParam);
        return TRUE;

    default:
    	return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

const char c_szNameSpaceClass[] = NAME_SPACE_CLASS;

BOOL NameSpace_RegisterClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    InitCommonControls();

    if (!GetClassInfo(hinst, c_szNameSpaceClass, &wc)) 
    {
    	wc.lpfnWndProc     = NameSpaceWndProc;
    	wc.hCursor         = NULL;
    	wc.hIcon           = NULL;
    	wc.lpszMenuName    = NULL;
    	wc.hInstance       = hinst;
    	wc.lpszClassName   = c_szNameSpaceClass;
    	wc.hbrBackground   = NULL;
    	wc.style           = 0;
    	wc.cbWndExtra      = sizeof(NSC *);
    	wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "init.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "occache"
#define SZ_MODULE           "OCCACHE"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\cdlbsc.cpp ===
#include <urlmon.h>
#include "cdlbsc.hpp"
#include "resource.h"

CodeDownloadBSC::CodeDownloadBSC( HWND hwnd, HWND hdlg, LPITEMIDLIST pidlUpdate )
{
    _cRef = 1;
    _pIBinding = NULL;
    _hwnd = hwnd;
    _pidlUpdate = pidlUpdate;
    _hdlg = hdlg;  
}

CodeDownloadBSC::~CodeDownloadBSC()
{
    if ( _pidlUpdate )
        ILFree( _pidlUpdate );
}

HRESULT CodeDownloadBSC::Abort()
{
    return _pIBinding->Abort();
}

/*
 *
 * IUnknown Methods
 *
 */

STDMETHODIMP CodeDownloadBSC::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if ( riid == IID_IWindowForBindingUI )
    {
         *ppv = (IWindowForBindingUI *)this;
    }

    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP_(ULONG) CodeDownloadBSC::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CodeDownloadBSC::Release()
{
    if (--_cRef)
    {
        return _cRef;
    }
    delete this;

    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

STDMETHODIMP CodeDownloadBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    if (_pIBinding != NULL)
    {
        _pIBinding->Release();
    }
    _pIBinding = pib;

    if (_pIBinding != NULL)
    {
        _pIBinding->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    if ( _hdlg != NULL )
        PostMessage(_hdlg, WM_COMMAND, DOWNLOAD_COMPLETE,
                    SUCCEEDED(hresult) ? TRUE : FALSE);

    if ( SUCCEEDED(hresult) && _pidlUpdate )
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, _pidlUpdate, NULL);
        SHChangeNotifyHandleEvents();
    }
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    if ( _hdlg != NULL )
        PostMessage(_hdlg, WM_COMMAND, DOWNLOAD_COMPLETE, TRUE );
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}  

STDMETHODIMP CodeDownloadBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    if ( _hdlg != NULL )
    {
        // convert progress to a percentage - 0->100
        LPARAM lprog;
        if ( ulStatusCode == BINDSTATUS_ENDDOWNLOADDATA )
            lprog = 100;
        else
            lprog = (ulProgressMax != 0)? (ulProgress * 100) / ulProgressMax : 0;
        PostMessage(_hdlg, WM_COMMAND, DOWNLOAD_PROGRESS, lprog );
    }

    return S_OK;
}


STDMETHODIMP CodeDownloadBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
   // *pgrfBINDF |= BINDF_SILENTOPERATION;
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    return S_OK;
}

STDMETHODIMP CodeDownloadBSC::GetWindow( REFGUID rguidReason, HWND __RPC_FAR *phwnd )
{
    *phwnd = _hwnd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\cdlbsc.hpp ===
#ifndef __CDLBSC_INCLUDED__
#define __CDLBSC_INCLUDED__

#include "init.h"
#include <urlmon.h>

#define DOWNLOAD_PROGRESS  0x9001
#define DOWNLOAD_COMPLETE  0x9002

class CodeDownloadBSC : public IBindStatusCallback, public IWindowForBindingUI {
    public:
        CodeDownloadBSC( HWND hwnd, HWND hdlg, LPITEMIDLIST pidlUpdate = NULL );
        virtual ~CodeDownloadBSC();
        HRESULT Abort();

        // IUnknown methods
        STDMETHODIMP QueryInterface( REFIID ridd, void **ppv );
        STDMETHODIMP_( ULONG ) AddRef();
        STDMETHODIMP_( ULONG ) Release();
    
        // IBindStatusCallback methods
        STDMETHODIMP GetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pbindinfo);
        STDMETHODIMP OnStartBinding(DWORD grfBSCOption, IBinding *pib);
        STDMETHODIMP GetPriority(LONG *pnPriority);
        STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                ULONG ulStatusCode, LPCWSTR szStatusText);
        STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                      FORMATETC *pformatetc,
                                      STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
        STDMETHODIMP OnLowResource(DWORD dwReserved);
        STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);

        // IWindowForBindingUI
        STDMETHODIMP GetWindow( REFGUID rguidReason, HWND __RPC_FAR *phwnd ); 

        HWND            _hdlg;          // progress dialog

    protected:
        IBinding        *_pIBinding; // ibinding from code dl'er
        DWORD           _cRef;
        HWND            _hwnd;          // owner window
        LPITEMIDLIST    _pidlUpdate;    // pidl for item we are updating
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\nsc\nscdrop.c ===
#include <windows.h>
#include <commctrl.h>
#include <shlobj.h>

#include "debug.h"
#include "common.h"

#include "autoscrl.h"

#include "nsc.h"

// BUGBUG: do nothing for now
#define DAD_DragLeave()
#define DAD_DragEnterEx(hwndLock, pt)
#define DAD_ShowDragImage(f)
#define DAD_DragMove(pt)

typedef struct {	// tdt
    IDropTarget		dtgt;
    UINT		cRef;

    NSC			*pns;

    RECT		_rcLockWindow;
    HTREEITEM		_htiCur;	// current tree item (dragging over)
    IDropTarget		*_pdtgtCur;	// current drop target
    IDataObject		*_pdtobjCur;	// current data object
    DWORD		_dwEffectCur;	// current drag effect
    DWORD		_dwEffectIn;	// *pdwEffect passed-in on last Move/Enter
    DWORD               _grfKeyState;   // cached key state
    POINT		_ptLast;	// last dragged over position
    DWORD               _dwLastTime;
    AUTO_SCROLL_DATA	asd;
} CTreeDropTarget;

STDMETHODIMP CTreeDropTarget_QueryInterface(IDropTarget *pdtgt, REFIID riid, void **ppvObj)
{
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);

    if (IsEqualIID(riid, &IID_IDropTarget) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = pdtgt;
        this->cRef++;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTreeDropTarget_AddRef(IDropTarget *pdtgt)
{
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);

    this->cRef++;
    return this->cRef;
}

void CTreeDropTarget_ReleaseDataObject(CTreeDropTarget *this)
{
    if (this->_pdtobjCur)
	Release(this->_pdtobjCur);

    this->_pdtobjCur = NULL;
}

void CTreeDropTarget_ReleaseCurrentDropTarget(CTreeDropTarget *this)
{
    if (this->_pdtgtCur)
    {
	this->_pdtgtCur->lpVtbl->DragLeave(this->_pdtgtCur);
	Release(this->_pdtgtCur);
        this->_pdtgtCur = NULL;
        this->_htiCur = NULL;
    }
    else
    {
	Assert(this->_htiCur == NULL);
    }
}

STDMETHODIMP_(ULONG) CTreeDropTarget_Release(IDropTarget * pdtgt)
{
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);

    this->cRef--;
    if (this->cRef > 0)
        return this->cRef;

    AssertMsg(this->_pdtgtCur == NULL, "drag leave was not called properly");

    // if above is true we can remove this...
    CTreeDropTarget_ReleaseCurrentDropTarget(this);

    LocalFree(this);

    return 0;
}

STDMETHODIMP CTreeDropTarget_DragEnter(IDropTarget *pdtgt, IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);
    POINT pt;
    HWND hwndLock;

    DebugMsg(DM_TRACE, "sh - TR CTreeDropTarget::DragEnter called");
    CTreeDropTarget_ReleaseDataObject(this);
    this->_pdtobjCur = pdtobj;
    this->_grfKeyState = grfKeyState;
    AddRef(pdtobj);
    Assert(this->_pdtgtCur == NULL);
    Assert(this->_htiCur == NULL);

    hwndLock = this->pns->hwndTree;	    // clip to this
    GetWindowRect(hwndLock, &this->_rcLockWindow);
    pt.x = ptl.x-this->_rcLockWindow.left;
    pt.y = ptl.y-this->_rcLockWindow.top;
    DAD_DragEnterEx(hwndLock, pt);

    this->_ptLast.x = this->_ptLast.y = 0x7ffffff;	// set bogus position

    return S_OK;
}

STDMETHODIMP CTreeDropTarget_DragOver(IDropTarget *pdtgt, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    HRESULT hres = S_OK;
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);
    TV_HITTESTINFO tvht;
    HTREEITEM htiNew;
    POINT pt = { ptl.x, ptl.y };
    BOOL fSameImage = FALSE;
    DWORD dwEffectScroll = 0;

    ScreenToClient(this->pns->hwndTree, &pt);

    if (DAD_AutoScroll(this->pns->hwndTree, &this->asd, &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;

    tvht.pt = pt;

    htiNew = TreeView_HitTest(this->pns->hwndTree, &tvht);

    // don't allow droping on the item being dragged
    if (htiNew == this->pns->htiDragging)
        htiNew = NULL;

    if (this->_htiCur != htiNew)
    {
        // change in target

        this->_dwLastTime = GetTickCount();     // keep track for auto-expanding the tree

	CTreeDropTarget_ReleaseCurrentDropTarget(this);

	this->_dwEffectCur = 0;	// assume error

	DAD_ShowDragImage(FALSE);

	TreeView_SelectDropTarget(this->pns->hwndTree, htiNew);

	DAD_ShowDragImage(TRUE);

	if (htiNew)
	{
            // get the drop target for the item we hit

	    LPITEMIDLIST pidl = _CacheParentShellFolder(this->pns, htiNew, NULL);
	    if (pidl)
	    {
	        IShellFolder *psf = this->pns->psfCache;

		AddRef(psf);

	        if (pidl->mkid.cb == 0)
		{
		    hres = psf->lpVtbl->CreateViewObject(psf, this->pns->hwnd, &IID_IDropTarget, &this->_pdtgtCur);
		}
		else
		{
		    UINT dwAttr = SFGAO_DROPTARGET;

		    hres = psf->lpVtbl->GetAttributesOf(psf, 1, &pidl, &dwAttr);

		    if (SUCCEEDED(hres) && (dwAttr & SFGAO_DROPTARGET))
		    {
			hres = psf->lpVtbl->GetUIObjectOf(psf, this->pns->hwnd, 1, &pidl, &IID_IDropTarget, NULL, &this->_pdtgtCur);
		    }
		    else
		    {
			hres = E_INVALIDARG;
		    }
		}

		Release(psf);
	    }

	    if (SUCCEEDED(hres))
	    {
		this->_htiCur = htiNew;

		this->_dwEffectCur = *pdwEffect;	// pdwEffect is In/Out
		hres = this->_pdtgtCur->lpVtbl->DragEnter(this->_pdtgtCur, this->_pdtobjCur, grfKeyState, ptl, &this->_dwEffectCur);
	    }
	} 
    }
    else
    {
        // No target change

        // auto expand the tree
        if (this->_htiCur)
        {
            DWORD dwNow = GetTickCount();

            if ((dwNow - this->_dwLastTime) >= 1000)
            {
                this->_dwLastTime = dwNow;
                DAD_ShowDragImage(FALSE);
                this->pns->fAutoExpanding = TRUE;
                TreeView_Expand(this->pns->hwndTree, this->_htiCur, TVE_EXPAND);
                this->pns->fAutoExpanding = FALSE;
                DAD_ShowDragImage(TRUE);
            }
        }

	// maybe the key state changed

        if ((this->_grfKeyState != grfKeyState) && this->_pdtgtCur) 
	{
            this->_dwEffectCur = *pdwEffect;
            hres = this->_pdtgtCur->lpVtbl->DragOver(this->_pdtgtCur, grfKeyState, ptl, &this->_dwEffectCur);
        } 
	else 
	{
	    fSameImage = TRUE;
            hres = S_OK;
        }
    }

    DebugMsg(DM_TRACE, "sh TR - CTreeDropTarget_DragOver (In=%x, Out=%x)", *pdwEffect, this->_dwEffectCur);

    this->_grfKeyState = grfKeyState;
    *pdwEffect = this->_dwEffectCur | dwEffectScroll;

    // We need pass pt relative to the locked window (not the client).
    pt.x = ptl.x-this->_rcLockWindow.left;
    pt.y = ptl.y-this->_rcLockWindow.top;

    if (!(fSameImage && this->_ptLast.x == pt.x && this->_ptLast.y == pt.y))
    {
	DAD_DragMove(pt);
	this->_ptLast.x = pt.x;
	this->_ptLast.y = pt.y;
    }

    return hres;
}


STDMETHODIMP CTreeDropTarget_DragLeave(IDropTarget *pdtgt)
{
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);

    DebugMsg(DM_TRACE, "sh - TR CTreeDropTarget::DragLeave called");
    CTreeDropTarget_ReleaseCurrentDropTarget(this);
    CTreeDropTarget_ReleaseDataObject(this);

    DAD_DragLeave();

    TreeView_SelectDropTarget(this->pns->hwndTree, NULL);

    return S_OK;
}

STDMETHODIMP CTreeDropTarget_Drop(IDropTarget *pdtgt, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;
    CTreeDropTarget * this = IToClass(CTreeDropTarget, dtgt, pdtgt);

    if (this->_pdtgtCur)
    {
	hres = this->_pdtgtCur->lpVtbl->Drop(this->_pdtgtCur, pdtobj, grfKeyState, pt, pdwEffect);
    }
    else
    {
	DebugMsg(DM_TRACE, "sh TR - CTreeDropTarget::Drop - this->_pdtgtCur==NULL");
	*pdwEffect = 0;
	hres = S_OK;
    }

    CTreeDropTarget_DragLeave(pdtgt);

    return hres;
}

const IDropTargetVtbl c_CTreeDropTargetVtbl = {
    CTreeDropTarget_QueryInterface, CTreeDropTarget_AddRef, CTreeDropTarget_Release,
    CTreeDropTarget_DragEnter,
    CTreeDropTarget_DragOver,
    CTreeDropTarget_DragLeave,
    CTreeDropTarget_Drop
};


HRESULT CTreeDropTarget_Create(NSC *pns, IDropTarget **ppdtgt)
{
    CTreeDropTarget * this = LocalAlloc(LPTR, sizeof(CTreeDropTarget));
    if (this)
    {
	this->dtgt.lpVtbl = (IDropTargetVtbl *)&c_CTreeDropTargetVtbl;
	this->cRef = 1;
	this->pns = pns;

	*ppdtgt = &this->dtgt;
	return S_OK;
    }

    *ppdtgt = NULL;
    return E_OUTOFMEMORY;
}

void CTreeDropTarget_Register(NSC *pns)
{
    IDropTarget *pdtgt;

    if (SUCCEEDED(CTreeDropTarget_Create(pns, &pdtgt)))
    {
	RegisterDragDrop(pns->hwndTree, pdtgt);
        Release(pdtgt);
    }
}

void CTreeDropTarget_Revoke(NSC *pns)
{
    RevokeDragDrop(pns->hwndTree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\cleanoc.cpp ===
#include "ParseInf.h"
#include "general.h"
#include <shlwapi.h>
#include <wininet.h>

//#define USE_SHORT_PATH_NAME    1

#define REG_PATH_IE_CACHE_LIST  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache")

#define cCachePathsMax 5    // maximum number of legacy caches + the current cache du jour


struct OCCFindData
{
    LPCLSIDLIST_ITEM m_pcliHead;
    LPCLSIDLIST_ITEM m_pcliTail;
    struct {
        TCHAR  m_sz[MAX_PATH];
        DWORD  m_cch;
    } m_aCachePath[cCachePathsMax];

    OCCFindData();
    ~OCCFindData();
 
    BOOL    IsCachePath( LPCTSTR szPath );

    // Control List operations
    HRESULT          AddListItem( LPCTSTR szFileName, LPCTSTR szCLSID, DWORD dwIsDistUnit );
    LPCLSIDLIST_ITEM TakeFirstItem(void);
};

DWORD CCacheLegacyControl::s_dwType = 1;
DWORD CCacheDistUnit::s_dwType = 2;

HRESULT CCacheLegacyControl::Init( HKEY hkeyCLSID, LPCTSTR szFile, LPCTSTR szCLSID )
{
    HRESULT hr = S_OK;

    lstrcpyn(m_szFile, szFile, ARRAYSIZE(m_szFile));
    lstrcpyn(m_szCLSID, szCLSID, ARRAYSIZE(m_szCLSID));

    // Get full user type name
    m_szName[0] = '\0';
    DWORD dw = sizeof(m_szName);
    LRESULT lResult = RegQueryValue(hkeyCLSID, m_szCLSID, m_szName,  (LONG*)&dw);
    // if the fails, we should get a resource string (seanf 5/9/97 )
    // Get type lib id
    TCHAR szTypeLibValName[MAX_PATH];
    CatPathStrN( szTypeLibValName, szCLSID, HKCR_TYPELIB, ARRAYSIZE(szTypeLibValName) );

    dw = sizeof(m_szTypeLibID);
    lResult = RegQueryValue( hkeyCLSID, szTypeLibValName, m_szTypeLibID, (LONG*)&dw);
    if (lResult != ERROR_SUCCESS)
        m_szTypeLibID[0] = TEXT('\0');

    // Set Codebase
    m_szCodeBase[0] = '\0';
    m_szVersion[0] = '\0';
    hr = DoParse( m_szFile, m_szCLSID );

    return hr;
}

HRESULT CCacheDistUnit::Init( HKEY hkeyCLSID, LPCTSTR szFile, LPCTSTR szCLSID, HKEY hkeyDist, LPCTSTR szDU )
{
    HRESULT hr = S_OK;
    HKEY    hkeyDU;
    HKEY    hkeyDLInfo; // DownloadInformation subkey
    HKEY    hkeyVers;   // InstalledVersion subkey
    HKEY    hkeyCOM;    // subkey of HKCR\CLSID, used if outside of cache dir
    LRESULT lResult = ERROR_SUCCESS;
    DWORD   dw;
    TCHAR   szNameT[MAX_PATH];
    UINT    uiVerSize = 0;
    DWORD   dwVerSize = 0;
    DWORD   dwHandle = 0;
    BYTE   *pbBuffer = NULL;
    HANDLE  hFile;
    FILETIME ftLastAccess;
    BOOL bRunOnNT5 = FALSE;
    OSVERSIONINFO osvi;
    VS_FIXEDFILEINFO     *lpVSInfo = NULL;
    
    if ( szFile[0] == '\0' &&
         RegOpenKeyEx( hkeyCLSID, szCLSID, 0, KEY_READ, &hkeyCOM ) == ERROR_SUCCESS )
    {
        LONG lcb = sizeof(szNameT);
        lResult = RegQueryValue( hkeyCOM, INPROCSERVER, szNameT, &lcb );

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVER32, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVERX86, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER32, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVERX86, szNameT, &lcb );
        }

        RegCloseKey( hkeyCOM );
    }
    else
        lstrcpyn( szNameT, szFile, ARRAYSIZE(szNameT));

    if ( lResult != ERROR_SUCCESS ) // needed to find file path but couldn't
        szNameT[0] = '\0';
    
    hr = CCacheLegacyControl::Init( hkeyCLSID, szNameT, szCLSID );

    if ( FAILED(hr) )
        return hr;

    lResult = RegOpenKeyEx(hkeyDist, szDU, 0, KEY_READ, &hkeyDU);
    if (lResult != ERROR_SUCCESS)
        return E_FAIL;

    // Get CLSID
    lstrcpyn(m_szCLSID, szDU, MAX_DIST_UNIT_NAME_LEN);

    // Get full user type name - only override the control name if DU name is not empty
    dw = sizeof(szNameT);
    lResult = RegQueryValue(hkeyDU, NULL, szNameT, (LONG*)&dw);
    if ( lResult == ERROR_SUCCESS && szNameT[0] != '\0' )
    {
        lstrcpyn( m_szName, szNameT, ARRAYSIZE(m_szName) );
    }
    else if ( *m_szName == '\0' ) // worst case, if we still don't have a name, a GUID will suffice
        lstrcpyn( m_szName, szDU, ARRAYSIZE(m_szName) ); 

    // Get type lib id
    // Get type lib id
    TCHAR szTypeLibValName[MAX_PATH];
    CatPathStrN(szTypeLibValName, m_szCLSID, HKCR_TYPELIB, ARRAYSIZE(szTypeLibValName));
    dw = sizeof(m_szTypeLibID);
    lResult = RegQueryValue( hkeyCLSID, szTypeLibValName, m_szTypeLibID, (LONG*)&dw);
    if (lResult != ERROR_SUCCESS)
        (m_szTypeLibID)[0] = TEXT('\0');

    m_szCodeBase[0] ='\0';
    lResult = RegOpenKeyEx(hkeyDU, REGSTR_DOWNLOAD_INFORMATION, 0, KEY_READ, &hkeyDLInfo);
    if (lResult == ERROR_SUCCESS)
    {
        dw = sizeof(m_szCodeBase);
        HRESULT hrErr = RegQueryValueEx(hkeyDLInfo, REGSTR_DLINFO_CODEBASE, NULL, NULL,
                                        (unsigned char *)m_szCodeBase, &dw);
        RegCloseKey( hkeyDLInfo );
    }

    // Get Version from DU branch

    m_szVersion[0] ='\0';
    lResult = RegOpenKeyEx(hkeyDU, REGSTR_INSTALLED_VERSION, 0,
                           KEY_READ, &hkeyVers);
    if (lResult == ERROR_SUCCESS)
    {
        dw = sizeof(m_szVersion);
        RegQueryValueEx(hkeyVers, NULL, NULL, NULL, (LPBYTE)m_szVersion, &dw);
        RegCloseKey(hkeyVers);
    }
    
    // The version specified in the COM branch is the definitive word on
    // what the version is. If a key exists in the COM branch, use the version
    // that is found inside the InProcServer/LocalServer.

    if (RegOpenKeyEx( hkeyCLSID, szCLSID, 0, KEY_READ, &hkeyCOM ) == ERROR_SUCCESS) 
    {
        LONG lcb = sizeof(szNameT);
        lResult = RegQueryValue( hkeyCOM, INPROCSERVER32, szNameT, &lcb );

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVER, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, INPROCSERVERX86, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER32, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVER, szNameT, &lcb );
        }

        if ( lResult != ERROR_SUCCESS )
        {
            lcb = sizeof(szNameT);
            lResult = RegQueryValue( hkeyCOM, LOCALSERVERX86, szNameT, &lcb );
        }

        RegCloseKey( hkeyCOM );

        // HACK! GetFileVersionInfoSize and GetFileVersionInfo modify
        // the last access time of the file under NT5! This causes us
        // to retrieve the wrong last access time when removing expired
        // controls. This hack gets the last access time before the
        // GetFileVersionInfo calls, and sets it back afterwards.
        // See IE5 RAID #56927 for details. This code should be removed
        // when NT5 fixes this bug.
        
        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);

        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.dwMajorVersion == 5) {
            bRunOnNT5 = TRUE;
        }

        if (bRunOnNT5) {
            hFile = CreateFile(szNameT, GENERIC_READ, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
                       
            if (hFile != INVALID_HANDLE_VALUE) {
                GetFileTime(hFile, NULL, &ftLastAccess, NULL);
                CloseHandle(hFile);
            }
        }
        
        dwVerSize = GetFileVersionInfoSize((char *)szNameT, &dwHandle);
        pbBuffer = new BYTE[dwVerSize];
        if (!pbBuffer)
        {
            return E_OUTOFMEMORY;
        }
        if (GetFileVersionInfo((char *)szNameT, 0, dwVerSize, pbBuffer))
        {
            if (VerQueryValue(pbBuffer, "\\", (void **)&lpVSInfo, &uiVerSize))
            {
                wsprintf(m_szVersion, "%d,%d,%d,%d", (lpVSInfo->dwFileVersionMS >> 16) & 0xFFFF
                                                   , lpVSInfo->dwFileVersionMS & 0xFFFF
                                                   , (lpVSInfo->dwFileVersionLS >> 16) & 0xFFFF
                                                   , lpVSInfo->dwFileVersionLS & 0xFFFF);
            }
        }
            
        delete [] pbBuffer;

        if (bRunOnNT5) {
            hFile = CreateFile(szNameT, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile != INVALID_HANDLE_VALUE) {
                SetFileTime(hFile, NULL, &ftLastAccess, NULL);
                CloseHandle(hFile);
            }
        }

    }
        
    RegCloseKey( hkeyDU );

    return DoParseDU( m_szFile, m_szCLSID);
}

HRESULT MakeCacheItemFromControlList( HKEY hkeyClass, // HKCR\CLSID
                                      HKEY hkeyDist,  // HKLM\SOFTWARE\MICROSOFT\Code Store Database\Distribution Units
                                      LPCLSIDLIST_ITEM pcli,
                                      CCacheItem **ppci )
{
    HRESULT hr = E_FAIL;

    *ppci = NULL;
    if ( pcli->bIsDistUnit )
    {
        CCacheDistUnit *pcdu = new CCacheDistUnit();
        if ( pcdu != NULL &&
             SUCCEEDED(hr = pcdu->Init( hkeyClass,
                                   pcli->szFile,
                                   pcli->szCLSID, 
                                   hkeyDist, 
                                   pcli->szCLSID)) )
            *ppci = pcdu;
        else
            hr = E_OUTOFMEMORY;
    } 
    else
    {
        CCacheLegacyControl     *pclc = new CCacheLegacyControl();
        if ( pclc != NULL &&
             SUCCEEDED(hr = pclc->Init( hkeyClass,
                                        pcli->szFile, 
                                        pcli->szCLSID )) )
            *ppci = pclc;
        else
            hr = E_OUTOFMEMORY;

    }

    return hr;
}

OCCFindData::OCCFindData() : m_pcliHead(NULL), m_pcliTail(NULL)
{
    LONG    lResult;
    HKEY  hkeyCacheList;

    for ( int i = 0; i < cCachePathsMax; i++ )
    {
        m_aCachePath[i].m_cch = 0;
        m_aCachePath[i].m_sz[0] = '\0';
    }

    // Unhook occache as a shell extension for the cache folders.
    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            REG_PATH_IE_CACHE_LIST,
                            0x0,
                            KEY_READ,
                            &hkeyCacheList );

    if ( lResult == ERROR_SUCCESS ) {
        DWORD dwIndex;
        TCHAR szName[MAX_PATH];
        DWORD cbName;
        DWORD cbValue;

        for ( dwIndex = 0, cbName = sizeof(szName), cbValue = MAX_PATH * sizeof(TCHAR); 
              dwIndex < cCachePathsMax; 
              dwIndex++, cbName = sizeof(szName), cbValue = MAX_PATH * sizeof(TCHAR) )
        {
            lResult = RegEnumValue( hkeyCacheList, dwIndex,
                                    szName, &cbName, 
                                    NULL, NULL,
                                    (LPBYTE)m_aCachePath[dwIndex].m_sz, &cbValue );
            m_aCachePath[dwIndex].m_cch = lstrlen( m_aCachePath[dwIndex].m_sz );
        }
        // We leave this key in place because it is the only record we have of the
        // cache folders and would be useful to future installations of IE
        RegCloseKey( hkeyCacheList );
    }
}

OCCFindData::~OCCFindData()
{
    if ( m_pcliHead )
        RemoveList(m_pcliHead);
}

BOOL OCCFindData::IsCachePath( LPCTSTR szPath )
{
    BOOL fMatch = FALSE;

    for ( int i = 0; i < cCachePathsMax && !fMatch; i++ )
        fMatch = m_aCachePath[i].m_cch != 0 &&
                 LStrNICmp( szPath, m_aCachePath[i].m_sz, m_aCachePath[i].m_cch ) == 0;
    return fMatch;
}

HRESULT OCCFindData::AddListItem( LPCTSTR szFile, LPCTSTR szCLSID, DWORD dwIsDistUnit )
{
    HRESULT hr = S_OK;

    if ( m_pcliTail == NULL )
    {
        m_pcliTail = new CLSIDLIST_ITEM;
        if (m_pcliHead == NULL)
            m_pcliHead = m_pcliTail;
    }
    else
    {
        m_pcliTail->pNext = new CLSIDLIST_ITEM;
        m_pcliTail = m_pcliTail->pNext;
    }

    if ( m_pcliTail != NULL ) 
    {
        m_pcliTail->pNext = NULL;
        lstrcpyn(m_pcliTail->szFile, szFile, MAX_PATH);
        lstrcpyn(m_pcliTail->szCLSID, szCLSID, MAX_DIST_UNIT_NAME_LEN);
        m_pcliTail->bIsDistUnit = dwIsDistUnit;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

LPCLSIDLIST_ITEM OCCFindData::TakeFirstItem(void)
{
    LPCLSIDLIST_ITEM pcli = m_pcliHead;
 
    if (m_pcliHead != NULL)
    {
        m_pcliHead = m_pcliHead;
        m_pcliHead = m_pcliHead->pNext;
        if ( m_pcliHead == NULL )
            m_pcliTail = NULL;
    }

    return pcli;
}

BOOL IsDUDisplayable(HKEY hkeyDU)
{
    BOOL bRet = FALSE;

    if (hkeyDU) 
    {
        if (IsShowAllFilesEnabled()) 
        {
            bRet = TRUE;
        }
        else
        {
            DWORD dwType = 0, dwSystem = 0, dwSize = sizeof(dwSystem);
            long lResult = RegQueryValueEx(hkeyDU, VALUE_SYSTEM, NULL, &dwType, (LPBYTE)&dwSystem, &dwSize);
            bRet = (lResult == ERROR_SUCCESS && dwSystem == TRUE) ? (FALSE) : (TRUE);
        }
    }
    return bRet;
}

BOOL IsShowAllFilesEnabled()
{
    HKEY hkey = 0;
    BOOL bRet = FALSE;
    DWORD dwShowAll = 0;

    DWORD lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0, KEY_READ, &hkey);
    if (lResult == ERROR_SUCCESS) 
    {
        DWORD dwType, dwSize = sizeof(dwShowAll);
        lResult = RegQueryValueEx(hkey, REGSTR_SHOW_ALL_FILES, NULL, &dwType, (LPBYTE)&dwShowAll, &dwSize);
        if (lResult == ERROR_SUCCESS) 
        {
            bRet = (dwShowAll != 0);
        }
        RegCloseKey(hkey);
    }

    return bRet;
}

void ToggleShowAllFiles()
{
    DWORD dwShowAll = !IsShowAllFilesEnabled();
    HKEY hkey = 0;
    DWORD lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0, KEY_ALL_ACCESS, &hkey);

    if (lResult == ERROR_SUCCESS) 
    {
        RegSetValueEx(hkey, REGSTR_SHOW_ALL_FILES, 0, REG_DWORD, (CONST BYTE *)&dwShowAll, sizeof(dwShowAll));
        RegCloseKey(hkey);
    }
}

LONG WINAPI FindFirstControl(HANDLE& hFindHandle, HANDLE& hControlHandle, LPCTSTR pszCachePath)
{
    LONG lResult = ERROR_SUCCESS;
    HRESULT hr = S_OK;
    DWORD dw = 0;
    HKEY hKeyClass = NULL;
    HKEY hKeyMod = NULL;
    HKEY hKeyDist = NULL;
    TCHAR szT[MAX_PATH];             // scratch buffer
    int cEnum = 0;
    CCacheItem *pci = NULL;
    LPCLSIDLIST_ITEM pcli = NULL;
    TCHAR szDUName[MAX_DIST_UNIT_NAME_LEN];
    
    OCCFindData *poccfd = new OCCFindData();
    if ( poccfd == NULL )
    {
        lResult = ERROR_NOT_ENOUGH_MEMORY;
        goto EXIT_FINDFIRSTCONTROL;
    }
    
    // Open up the HKCR\CLSID key.
    lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, HKCR_CLSID, 0, KEY_READ, &hKeyClass);
    if (ERROR_SUCCESS != lResult)
        goto EXIT_FINDFIRSTCONTROL;

    // Search for legacy controls found in the COM branch
    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MODULE_USAGE, 0, KEY_READ, &hKeyMod);
    if (ERROR_SUCCESS != lResult)
        goto EXIT_FINDFIRSTCONTROL;

    // Enumerate the known modules and build up a list of the owners.
    // This is a search for legacy controls.
    while ((lResult = RegEnumKey(hKeyMod, cEnum++, szT, ARRAYSIZE(szT))) == ERROR_SUCCESS)
    {
        TCHAR szClient[MAX_CLIENT_LEN];
        HKEY hKeyClsid = NULL;
        HKEY hkeyMUEntry = NULL;

        lResult = RegOpenKeyEx( hKeyMod, szT, 0, KEY_READ, &hkeyMUEntry );
        if (ERROR_SUCCESS != lResult)
            continue;

        // Fetch the module owner.
        // If the module owner is in the COM branch AND
        //    ( the owner lives in the cache OR it has an INF in the cache )
        // Then add the _owner_ to our list of legacy controls.
        // In the INF case, we may be looking at a control that was re-registered
        // outside of the cache.
        // If it doesn't have these properties, then it is either a DU module or
        // was installed by something other than MSICD. In either case, we'll skip it
        // at least for now.
        dw = sizeof(szClient);
        lResult = RegQueryValueEx(hkeyMUEntry, VALUE_OWNER, NULL, NULL, (LPBYTE)szClient, &dw);
        if (ERROR_SUCCESS != lResult)
            continue;

        lResult = RegOpenKeyEx(hKeyClass, szClient, 0, KEY_READ, &hKeyClsid);
        if (ERROR_SUCCESS == lResult)
        {
            TCHAR szCLocation[MAX_PATH];     // Canonical path of control
            TCHAR szLocation[MAX_PATH];      // Location in COM CLSID reg tree.

            // Look for InprocServer[32] or LocalServer[32] key
            dw = sizeof(szLocation);
            lResult = RegQueryValue(hKeyClsid, INPROCSERVER32, szLocation, (PLONG)&dw);
            if (lResult != ERROR_SUCCESS)
            {
                dw = sizeof(szLocation);
                lResult = RegQueryValue(hKeyClsid, LOCALSERVER32, szLocation, (PLONG)&dw);
            }

            RegCloseKey(hKeyClsid);
            hKeyClsid = NULL;

            if ( lResult == ERROR_SUCCESS )
            {
                BOOL bAddOwner;

                // see if we've already got an entry for this one.
                for ( pcli = poccfd->m_pcliHead;
                      pcli != NULL && lstrcmp( szClient, pcli->szCLSID ) != 0;
                      pcli = pcli->pNext );
                
                if ( pcli == NULL ) // not found - possibly add new item
                {
                    // Canonicalize the path for use in comparisons with cache dirs
                    if ( OCCGetLongPathName(szCLocation, szLocation, MAX_PATH) == 0 )
                        lstrcpyn( szCLocation, szLocation, MAX_PATH );

                    // Is the owner in our cache?
                    bAddOwner = poccfd->IsCachePath( szCLocation );

                    if ( !bAddOwner )
                    {
                        // does it have an INF in our cache(s)?
                        // We'll appropriate szDCachePath
                        for ( int i = 0; i < cCachePathsMax && !bAddOwner; i++ )
                        {
                            if ( poccfd->m_aCachePath[i].m_sz != '\0' )
                            {
                                CatPathStrN( szT, poccfd->m_aCachePath[i].m_sz, PathFindFileName( szCLocation ), MAX_PATH);

                                // Note if another copy of the owner exists within the cache(s).
                                // This would be a case of re-registration.
                                if ( PathFileExists( szT ) )
                                {
                                    // add our version of the control.
                                    lstrcpyn( szCLocation, szT, MAX_PATH );
                                    bAddOwner = TRUE;
                                }
                                else
                                    bAddOwner =  PathRenameExtension( szT, INF_EXTENSION ) &&
                                                 PathFileExists( szT );
                            } // if cache path
                        } // for each cache directory
                    } // if check for cached INF

                    if ( bAddOwner ) 
                    {
                        HKEY hkeyDUCheck = 0;
                        char achBuf[MAX_REGPATH_LEN];

                        wnsprintfA(achBuf, MAX_REGPATH_LEN, "%s\\%s", REGSTR_PATH_DIST_UNITS, szClient);

                        lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, achBuf, 0, KEY_READ, &hkeyDUCheck);

                        if (lResult != ERROR_SUCCESS) 
                        {
                            // This is a legacy control with no corresponding DU
                            poccfd->AddListItem( szCLocation, szClient, FALSE );
                        }
                        else 
                        {
                            if (IsDUDisplayable(hkeyDUCheck)) 
                            {
                                // Legacy control w/ DU keys that is displayable
                                poccfd->AddListItem( szCLocation, szClient, FALSE );
                            }
                            RegCloseKey(hkeyDUCheck);
                        }
                    }
                } // if owner we haven't seen before
            } // if owner has local or inproc server
        } // if owner has COM entry 
        RegCloseKey( hkeyMUEntry );
    } // while enumerating Module Usage
 
    // we're finished with module usage
    RegCloseKey(hKeyMod);

    // Now search distribution units

    // Check for duplicates - distribution units for controls we detected above

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0, KEY_READ, &hKeyDist);
    if (lResult == ERROR_SUCCESS)
    {
        cEnum = 0;
        // Enumerate distribution units and queue them up in the list
        while ((lResult = RegEnumKey(hKeyDist, cEnum++, szDUName, ARRAYSIZE(szDUName))) == ERROR_SUCCESS)
        {
            // We should only display DU's installed by code download.
            HKEY  hkeyDU;
            DWORD dwType;
            
            lResult = RegOpenKeyEx( hKeyDist, szDUName, 0, KEY_READ, &hkeyDU );
            Assert( lResult == ERROR_SUCCESS );

            if ((ERROR_SUCCESS != lResult) ||
                !IsDUDisplayable(hkeyDU)) 
            {
                continue;
            }

            szT[0] = '\0';
            DWORD cb = sizeof(szT);
            lResult = RegQueryValueEx( hkeyDU, DU_INSTALLER_VALUE, NULL, &dwType, (LPBYTE)szT, &cb );
            
            Assert( lResult == ERROR_SUCCESS ); // properly-formed DU will have this
            Assert( dwType == REG_SZ );         // properly-formed DU's have a string here

            // Check for an installed version. We might just have a DU that has an AvailableVersion
            // but hasn't been installed yet.
            lResult = RegQueryValue( hkeyDU, REGSTR_INSTALLED_VERSION, NULL, NULL );

            RegCloseKey( hkeyDU );

            if ( lstrcmpi( szT, CDL_INSTALLER ) == 0 &&
                 lResult == ERROR_SUCCESS ) // from InstalledVersion RegQueryValue
            {
                // If we can convert the unique name to a GUID, then this DU
                // may have already been added on the first pass through the
                // COM branch.
                CLSID clsidDummy = CLSID_NULL;
                WORD szDummyStr[MAX_CTRL_NAME_SIZE];
                BOOL bFoundDuplicate = FALSE;

                MultiByteToWideChar(CP_ACP, 0, szDUName, -1, szDummyStr, ARRAYSIZE(szDummyStr));
                if ((CLSIDFromString(szDummyStr, &clsidDummy) == S_OK))
                {
                    for (pcli = poccfd->m_pcliHead; pcli; pcli = pcli->pNext)
                    {
                        if (!lstrcmpi(szDUName, pcli->szCLSID))
                        {
                            // Duplicate found. Use dist unit information to
                            // fill in additional fields if it is the first
                            // entry in the list
                            bFoundDuplicate = TRUE;
                            pcli->bIsDistUnit = TRUE;
                            break;
                        }
                    }                     
                }

                if (!bFoundDuplicate)
                {
                    // Okay we're looking at some sort of Java scenario. We have a distribution unit, but
                    // no corresponding entry in the COM branch. This generally means we've got a DU that
                    // consists of java packages. It can also mean that we're dealing with a java/code download
                    // backdoor introduced in IE3. In this case, an Object tag gets a CAB downloaded that
                    // installs Java classes and sets of a CLSID that invokes MSJava.dll on the class ( ESPN's
                    // sportszone control/applet works this way ). In the first case, we get the name
                    // squared-away when we parse the DU. In the latter case, we need to try and pick the name
                    // up from the COM branch.  
                    hr = poccfd->AddListItem( "", szDUName, TRUE );
                    if ( FAILED(hr) )
                    {
                        lResult = ERROR_NOT_ENOUGH_MEMORY;
                        goto EXIT_FINDFIRSTCONTROL;
                    }
                } // if no duplicate - add DU to the list
            } // if installed by MSICD
        } // while enumerating DU's
    } // if we can open the DU key.
    else
        lResult = ERROR_NO_MORE_ITEMS; // if no DU's then make due with our legacy controls, if any

    pcli = poccfd->TakeFirstItem();
    if (pcli)
    {
        hr = MakeCacheItemFromControlList(hKeyClass, hKeyDist, pcli, &pci);
        delete pcli;
        if ( FAILED(hr) )
            lResult = hr;
    }

    if (hKeyDist)
    {
        RegCloseKey(hKeyDist);
        hKeyDist = 0;
    }


    // Clean up

    if (lResult != ERROR_NO_MORE_ITEMS)
        goto EXIT_FINDFIRSTCONTROL;

    if (pci == NULL)
        lResult = ERROR_NO_MORE_ITEMS;
    else
    {
        lResult = ERROR_SUCCESS;
    }

    hFindHandle = (HANDLE)poccfd;
    hControlHandle = (HANDLE)pci;

EXIT_FINDFIRSTCONTROL:

    if (hKeyDist)
        RegCloseKey(hKeyDist);

    if (hKeyClass)
        RegCloseKey(hKeyClass);

    if (lResult != ERROR_SUCCESS)
    {
        if ( pci != NULL )
            delete pci;
        if ( poccfd != NULL )
            delete poccfd;
        hFindHandle = INVALID_HANDLE_VALUE;
        hControlHandle = INVALID_HANDLE_VALUE;
    }

    return lResult;
}

LONG WINAPI FindNextControl(HANDLE& hFindHandle, HANDLE& hControlHandle)
{
    LONG         lResult = ERROR_SUCCESS;
    HRESULT      hr = S_OK;
    HKEY         hKeyClass = NULL;
    
    CCacheItem   *pci = NULL;
    OCCFindData  *poccfd = (OCCFindData *)hFindHandle;

    LPCLSIDLIST_ITEM pcli = poccfd->TakeFirstItem();
    hControlHandle = INVALID_HANDLE_VALUE;

    if (pcli == NULL)
    {
        lResult = ERROR_NO_MORE_ITEMS;
        goto EXIT_FINDNEXTCONTROL;
    }

    if ((lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, HKCR_CLSID, 0, KEY_READ, &hKeyClass)) != ERROR_SUCCESS)
        goto EXIT_FINDNEXTCONTROL;

    if ( pcli->bIsDistUnit )
    {
        HKEY hKeyDist;

        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0,
                                KEY_READ, &hKeyDist);

        if ( lResult == ERROR_SUCCESS ) 
        {
            hr  = MakeCacheItemFromControlList( hKeyClass,
                                                hKeyDist,
                                                pcli,
                                                &pci );
            if ( FAILED(hr) )
                lResult = hr;

            RegCloseKey( hKeyDist );
        }
    }
    else
    {
        // This is not a distribution unit. Fill in CCachItem information
        // from the COM branch.
        hr  = MakeCacheItemFromControlList(hKeyClass, NULL, pcli, &pci );
        if ( FAILED(hr) )
            lResult = hr;
    }

    hControlHandle = (HANDLE)pci;

EXIT_FINDNEXTCONTROL:

    if (hKeyClass)
        RegCloseKey(hKeyClass);

    if (pcli != NULL)
    {
        delete pcli;
    }

    return lResult;
}

void WINAPI FindControlClose(HANDLE hFindHandle)
{
    if (hFindHandle == INVALID_HANDLE_VALUE ||
        hFindHandle == (HANDLE)0)
        return;

    delete (OCCFindData*)hFindHandle;
}

void WINAPI ReleaseControlHandle(HANDLE hControlHandle)
{
    if (hControlHandle == INVALID_HANDLE_VALUE ||
        hControlHandle == (HANDLE)0)
        return;

    delete (CCacheItem *)hControlHandle;
}

HRESULT WINAPI RemoveControlByHandle(HANDLE hControlHandle, BOOL bForceRemove /* = FALSE */)
{
    return RemoveControlByHandle2( hControlHandle, bForceRemove, FALSE );
}


HRESULT WINAPI RemoveControlByName(LPCTSTR lpszFile, LPCTSTR lpszCLSID, LPCTSTR lpszTypeLibID, BOOL bForceRemove, /* = FALSE */ DWORD dwIsDistUnit /* = FALSE */)
{
    return RemoveControlByName2( lpszFile, lpszCLSID, lpszTypeLibID, bForceRemove, dwIsDistUnit, FALSE);
}

LONG WINAPI GetControlDependentFile(int iFile, HANDLE hControlHandle, LPTSTR lpszFile, LPDWORD lpdwSize, BOOL bToUpper /* = FALSE */)
{
    CCacheItem *pci = (CCacheItem *)hControlHandle;

    if (iFile < 0 || lpszFile == NULL || lpdwSize == NULL)
        return ERROR_BAD_ARGUMENTS;

    // loop through the list of files to find the one indicated
    // by the given index.
    // this way is dumb but since a control does not depend on
    // too many files, it's ok
    CFileNode *pFileNode = pci->GetFirstFile();
    for (int i = 0; i < iFile && pFileNode != NULL; i++)
        pFileNode = pci->GetNextFile();

    if (pFileNode == NULL)
    {
        lpszFile[0] = TEXT('\0');
        lpdwSize = 0;
        return ERROR_NO_MORE_FILES;
    }

    // Make a fully qualified filename
    if (pFileNode->GetPath() != NULL)
    {
        CatPathStrN( lpszFile, pFileNode->GetPath(), pFileNode->GetName(), MAX_PATH);
    }
    else
    {
        lstrcpy(lpszFile, pFileNode->GetName());
    }

    if (FAILED(GetSizeOfFile(lpszFile, lpdwSize)))
        *lpdwSize = 0;

    // to upper case if required
    if (bToUpper)
        CharUpper(lpszFile);

    return ERROR_SUCCESS;
}

// determine if a control or one of its associated files can be removed
// by reading its SharedDlls count
BOOL WINAPI IsModuleRemovable(LPCTSTR lpszFile)
{
    TCHAR szFile[MAX_PATH];
    TCHAR szT[MAX_PATH];

    if (lpszFile == NULL)
        return FALSE;

    if ( OCCGetLongPathName(szFile, lpszFile, MAX_PATH) == 0 )
        lstrcpyn( szFile, lpszFile, MAX_PATH );

    // Don't ever pull something out of the system directory.
    // This is a "safe" course of action because it is not reasonable
    // to expect the user to judge whether yanking this file damage other
    // software installations or the system itself.
    GetSystemDirectory(szT, MAX_PATH);
    if (StrStrI(szFile, szT))
        return FALSE;

    // check moduleusage if a control is safe to remove
    if (LookUpModuleUsage(szFile, NULL, szT, MAX_PATH) != S_OK)
        return FALSE;

    // if we don't know who the owner of the module is, it's not
    // safe to remove
    if (lstrcmpi(szT, UNKNOWNOWNER) == 0)
        return FALSE;
    else
    {
        // check shareddlls if a control is safe to remove
        LONG cRef;

        HRESULT hr = SetSharedDllsCount( szFile, -1, &cRef );

        return cRef == 1;
    }
}

BOOL WINAPI GetControlInfo(HANDLE hControlHandle, UINT nFlag, 
                           DWORD *pdwData, LPTSTR pszData, int nBufLen)
{
    if (hControlHandle == 0 || hControlHandle == INVALID_HANDLE_VALUE)
        return FALSE;

    BOOL bResult = TRUE;
    LPCTSTR pStr = NULL;
    DWORD dw = 0;

    switch (nFlag)
    {
    case GCI_NAME:     // get friend name of control
        pStr = ((CCacheItem *)hControlHandle)->m_szName;
        break;

    case GCI_FILE:     // get filename of control (with full path)
        pStr = ((CCacheItem *)hControlHandle)->m_szFile;
        // if there is no file, but there is a package list, fake it
        // with the path to the first package's ZIP file.
        if ( *pStr == '\0' )
        {
            CPNode *ppn = ((CCacheItem *)hControlHandle)->GetFirstPackage();
            if (ppn)
            {
                pStr = ppn->GetPath();
                if (!pStr)
                {
                    return FALSE; // this means hControlHandle is an invalid arg
                }
            }
        }

        if ( pStr && *pStr == TEXT('\0') )
        {
            CPNode *pfn = ((CCacheItem *)hControlHandle)->GetFirstFile();
            if ( pfn != NULL )
                pStr = pfn->GetPath();
        }
        break;

    case GCI_DIST_UNIT_VERSION:
        pStr = ((CCacheItem *)hControlHandle)->m_szVersion;
        break;

    case GCI_CLSID:    // get CLSID of control
        pStr = ((CCacheItem *)hControlHandle)->m_szCLSID;
        break;

    case GCI_TYPELIBID:  // get TYPELIB id of control
        pStr = ((CCacheItem *)hControlHandle)->m_szTypeLibID;
        break;

    case GCI_TOTALSIZE:  // get total size in bytes
        dw = ((CCacheItem *)hControlHandle)->GetTotalFileSize();
        break;

    case GCI_SIZESAVED:  // get total size restored if control is removed
        dw = ((CCacheItem *)hControlHandle)->GetTotalSizeSaved();
        break;

    case GCI_TOTALFILES:  // get total number of files related to control
        dw = (DWORD)(((CCacheItem *)hControlHandle)->GetTotalFiles());
        break;

    case GCI_CODEBASE:  // get CodeBase for control
        pStr = ((CCacheItem *)hControlHandle)->m_szCodeBase;
        break;

    case GCI_ISDISTUNIT:
        dw = ((CCacheItem *)hControlHandle)->ItemType() == CCacheDistUnit::s_dwType;
        break;

    case GCI_STATUS:
        dw = ((CCacheItem *)hControlHandle)->GetStatus();
        break;

    case GCI_HAS_ACTIVEX:
        dw = ((CCacheItem *)hControlHandle)->GetHasActiveX();
        break;

    case GCI_HAS_JAVA:
        dw = ((CCacheItem *)hControlHandle)->GetHasJava();
        break;
    }

    if (nFlag == GCI_TOTALSIZE ||
        nFlag == GCI_SIZESAVED ||
        nFlag == GCI_TOTALFILES ||
        nFlag == GCI_ISDISTUNIT ||
        nFlag == GCI_STATUS ||
        nFlag == GCI_HAS_ACTIVEX ||
        nFlag == GCI_HAS_JAVA)
    {
        bResult = pdwData != NULL;
        if (bResult)
            *pdwData = dw;
    }
    else
    {
        bResult = pszData && pStr;
        if (bResult)
            lstrcpyn(pszData, pStr, nBufLen);
    }

    return bResult;
}

///////////////////////////////////////////////////////////////////////////////
// API to be called by Advpack.dll

// Define list node to be used in a linked list of control
struct tagHANDLENODE;
typedef struct tagHANDLENODE HANDLENODE;
typedef HANDLENODE* LPHANDLENODE;
struct tagHANDLENODE
{
    HANDLE hControl;
    struct tagHANDLENODE* pNext;
};

// Given a handle to a control, get the control's last access time
// Result is stored in a FILETIME struct
HRESULT GetLastAccessTime(HANDLE hControl, FILETIME *pLastAccess)
{
    Assert(hControl != NULL && hControl != INVALID_HANDLE_VALUE);
    Assert(pLastAccess != NULL);

    HRESULT hr = S_OK;
    WIN32_FIND_DATA fdata;
    HANDLE h = INVALID_HANDLE_VALUE;
    LPCTSTR  lpszFile = NULL;
    CCacheItem *pci = (CCacheItem *)hControl;
    CPNode *ppn;

    if (pci->m_szFile[0] != 0)
        lpszFile = pci->m_szFile;
    else if ( (ppn = pci->GetFirstPackage()) != NULL )
        lpszFile = ppn->GetPath();
    else if ( (ppn = pci->GetFirstFile()) != NULL )
        lpszFile = ppn->GetPath();
        
    if ( lpszFile )
        h = FindFirstFile(lpszFile, &fdata);

    if (h == INVALID_HANDLE_VALUE)
    {
        SYSTEMTIME stNow;
        GetLocalTime(&stNow);
        SystemTimeToFileTime(&stNow, pLastAccess); 
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        // Convert file time to local file time, then file time to 
        // system time.  Set those fields to be ignored to 0, and
        // set system time back to file time.
        // FILETIME struct is used because API for time comparison
        // only works on FILETIME.

//        SYSTEMTIME sysTime;

        FindClose(h);
        FileTimeToLocalFileTime(&(fdata.ftLastAccessTime), pLastAccess);
    }

    return hr;
}

HRESULT WINAPI SweepControlsByLastAccessDate(
                              SYSTEMTIME *pLastAccessTime /* = NULL */,
                              PFNDOBEFOREREMOVAL pfnDoBefore /* = NULL */,
                              PFNDOAFTERREMOVAL pfnDoAfter /* = NULL */,
                              DWORD dwSizeLimit /* = 0 */
                              )
{
    LONG lResult = ERROR_SUCCESS;
    HRESULT hr = S_FALSE;
    DWORD dwSize = 0, dwTotalSize = 0;
    HANDLE hFind = NULL, hControl = NULL;
    LPHANDLENODE pHead = NULL, pCur = NULL;
    FILETIME timeLastAccess, timeRemovePrior;
    UINT cCnt = 0;
    TCHAR szFile[MAX_PATH];

    // ignore all fields except wYear, wMonth and wDay
    if (pLastAccessTime != NULL)
    {
        pLastAccessTime->wDayOfWeek = 0; 
        pLastAccessTime->wHour = 0; 
        pLastAccessTime->wMinute = 0; 
        pLastAccessTime->wSecond = 0; 
        pLastAccessTime->wMilliseconds = 0; 
    }

    // loop through all controls and put in a list the
    // ones that are accessed before the given date and
    // are safe to uninstall
    lResult = FindFirstControl(hFind, hControl);
    for (;lResult == ERROR_SUCCESS;
          lResult = FindNextControl(hFind, hControl))
    {
        // check last access time
        if (pLastAccessTime != NULL)
        {
            GetLastAccessTime(hControl, &timeLastAccess);
            SystemTimeToFileTime(pLastAccessTime, &timeRemovePrior);
            if (CompareFileTime(&timeLastAccess, &timeRemovePrior) > 0)
            {
                ReleaseControlHandle(hControl);
                continue;
            }
        }

        // check if control is safe to remove
        GetControlInfo(hControl, GCI_FILE, NULL, szFile, MAX_PATH);
        if (!IsModuleRemovable(szFile))
        {
            ReleaseControlHandle(hControl);
            continue;
        }

        // put control in a list
        if (pHead == NULL)
        {
            pHead = new HANDLENODE;
            pCur = pHead;
        }
        else
        {
            pCur->pNext = new HANDLENODE;
            pCur = pCur->pNext;
        }

        if (pCur == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto EXIT_REMOVECONTROLBYLASTACCESSDATE;
        }
        
        pCur->pNext = NULL;
        pCur->hControl = hControl;
        cCnt += 1;

        // calculate total size
        GetControlInfo(pCur->hControl, GCI_SIZESAVED, &dwSize, NULL, NULL);
        dwTotalSize += dwSize;
    }
        
    // quit if total size restored is less than the given amount
    if (dwTotalSize < dwSizeLimit)
        goto EXIT_REMOVECONTROLBYLASTACCESSDATE;

    // traverse the list and remove each control
    for (pCur = pHead; pCur != NULL; cCnt--)
    {
        hr = S_OK;
        pHead = pHead->pNext;

        // call callback function before removing a control
        if (pfnDoBefore == NULL || SUCCEEDED(pfnDoBefore(pCur->hControl, cCnt)))
        {
            hr = RemoveControlByHandle(pCur->hControl);

            // call callback function after removing a control, passing it the
            // result of the removal
            if (pfnDoAfter != NULL && FAILED(pfnDoAfter(hr, cCnt - 1)))
            {
                pHead = pCur;   // set pHead back to head of list
                goto EXIT_REMOVECONTROLBYLASTACCESSDATE;
            }
        }

        // release memory used by the control handle
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
        pCur = pHead;
    }

EXIT_REMOVECONTROLBYLASTACCESSDATE:

    FindControlClose(hFind);

    // release memory taken up by the list
    for (pCur = pHead; pCur != NULL; pCur = pHead)
    {
        pHead = pHead->pNext;
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
    }

    return hr;
}

HRESULT WINAPI RemoveExpiredControls(DWORD dwFlags, DWORD dwReserved)
{
    LONG lResult = ERROR_SUCCESS;
    HRESULT hr = S_FALSE;
    HANDLE hFind = NULL, hControl = NULL;
    LPHANDLENODE pHead = NULL, pCur = NULL;
    FILETIME ftNow, ftMinLastAccess, ftLastAccess;
    LARGE_INTEGER liMinLastAccess;
    SYSTEMTIME stNow;
    UINT cCnt = 0;

    GetLocalTime( &stNow );
    SystemTimeToFileTime(&stNow, &ftNow);

    // loop through all controls and put in a list the
    // ones that are accessed before the given date and
    // are safe to uninstall
    lResult = FindFirstControl(hFind, hControl);
    for (;lResult == ERROR_SUCCESS;
          lResult = FindNextControl(hFind, hControl))
    {
        CCacheItem *pci = (CCacheItem *)hControl;

        // Controls must have a last access time of at least ftMinLastAccess or they will
        // expire by default. If they have the Office Auto-expire set, then they may
        // have to pass a higher bar.

        liMinLastAccess.LowPart = ftNow.dwLowDateTime;
        liMinLastAccess.HighPart = ftNow.dwHighDateTime;
        // We add one to GetExpireDays to deal with bug  17151. The last access time
        // returned by the file system is truncated down to 12AM, so we need to 
        // expand the expire interval to ensure that this truncation does not cause
        // the control to expire prematurely.
        liMinLastAccess.QuadPart -= ((pci->GetExpireDays()+1) * 864000000000L); //24*3600*10^7
        ftMinLastAccess.dwLowDateTime = liMinLastAccess.LowPart;
        ftMinLastAccess.dwHighDateTime = liMinLastAccess.HighPart;

        GetLastAccessTime(hControl, &ftLastAccess); // ftLastAccess is a local file time

        if (CompareFileTime(&ftLastAccess, &ftMinLastAccess) >= 0)
        {
            ReleaseControlHandle(hControl);
            continue;
        }


        // put control in a list
        if (pHead == NULL)
        {
            pHead = new HANDLENODE;
            pCur = pHead;
        }
        else
        {
            pCur->pNext = new HANDLENODE;
            pCur = pCur->pNext;
        }

        if (pCur == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        pCur->pNext = NULL;
        pCur->hControl = hControl;
        cCnt += 1;
    }

    // traverse the list and remove each control
    for (pCur = pHead; pCur != NULL; cCnt--)
    {
        hr = S_OK;
        pHead = pHead->pNext;

        hr = RemoveControlByHandle2(pCur->hControl, FALSE, TRUE);

        // release memory used by the control handle
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
        pCur = pHead;
    }

cleanup:

    FindControlClose(hFind);

    // release memory taken up by the list, if any left
    for (pCur = pHead; pCur != NULL; pCur = pHead)
    {
        pHead = pHead->pNext;
        ReleaseControlHandle(pCur->hControl);
        delete pCur;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\dlg.cpp ===
#include "dlg.h"
#include "utils.h"

#include <mluisupp.h>

INT_PTR Dlg_MsgProc(const MSD *pmsd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    MMF  mmf;
    INT_PTR fResult = FALSE;

    if (msg == WM_SETFONT) {
//      MACRO_LI_SmartRemoveFlags(LIF_LINE);
//      Out(LI0("Dialog is created..."));
    }

    ASSERT(pmsd != NULL);
    for (; pmsd->ms != ms_end; pmsd++)
        if (pmsd->msg == msg) {
            mmf.pfn = pmsd->pfn;

            switch (pmsd->ms) {
            case ms_lwwwl:
                fResult = (INT_PTR)(*mmf.pfn_lwwwl)(hDlg, msg, wp, lp);
                break;

            case ms_bwwwl:
                fResult = (*mmf.pfn_bwwwl)(hDlg, msg, wp, lp);
                break;

            case ms_vv:
                (*mmf.pfn_vv)();
                fResult = TRUE;
                break;

            case ms_bv:
                fResult = (*mmf.pfn_bv)();
                break;

            case ms_vw:
                (*mmf.pfn_vw)(wp);
                fResult = TRUE;
                break;

            case ms_vh:
                (*mmf.pfn_vh)(hDlg);
                fResult = TRUE;
                break;

            case ms_bh:
                fResult = (*mmf.pfn_bh)(hDlg);
                break;

            case ms_bhl:
                fResult = (*mmf.pfn_bhl)(hDlg, lp);
                break;

            default:
                ASSERT(FALSE);
            }

            break;
        }

    if (msg == WM_NCDESTROY) {
//      MACRO_LI_SmartRemoveFlags(LIF_LINE);
//      Out(LI0("Dialog is destroying..."));
    }

    return fResult;
}

BOOL Msg_OnCmd(const CMD *pcmd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    MMF  mmf;
    UINT nID     = GET_WM_COMMAND_ID(wp, lp);
    BOOL fResult = FALSE;

    //----- Look for message map entry -----
    for (; pcmd->ms != ms_end; pcmd++)
        if ((pcmd->nLastID <= pcmd->nID && pcmd->nID == nID) ||
            (nID >= pcmd->nID && nID <= pcmd->nLastID))
            break;
    if (pcmd->ms == ms_end) {
        if (nID == IDOK || nID == IDCANCEL)
            EndDialog(hDlg, nID);

        return fResult;
    }

    //----- Dispatch based on function signature -----
    mmf.pfn = pcmd->pfn;
    switch (pcmd->ms) {
    case ms_vv:
        (*mmf.pfn_vv)();
        fResult = TRUE;
        break;

    case ms_bv:
        fResult = (*mmf.pfn_bv)();
        break;

    case ms_vw:
        (*mmf.pfn_vw)(nID);
        fResult = TRUE;
        break;

    case ms_vh:
        (*mmf.pfn_vh)(hDlg);
        fResult = TRUE;
        break;

    case ms_bh:
        fResult = (*mmf.pfn_bh)(hDlg);
        break;

    case ms_vhww:
        (*mmf.pfn_vhww)(hDlg, nID, GET_WM_COMMAND_CMD(wp, lp));
        fResult = TRUE;
        break;

    case ms_vhhw:
        (*mmf.pfn_vhhw)(hDlg, GetDlgItem(hDlg, nID),
            GET_WM_COMMAND_CMD(wp, lp));
        fResult = TRUE;
        break;

    default:
        ASSERT(FALSE);
    }

    //----- Special processing -----
    if (nID == IDOK || nID == IDCANCEL)
        if (pcmd->ms != ms_end) {
            if (fResult)
                EndDialog(hDlg, nID);
        }
        else
            EndDialog(hDlg, nID);

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\dlg.h ===
#ifndef DLG_H
#define DLG_H

#include <windows.h>
#include <windowsx.h>
#include <debug.h>

typedef void (*PFN)();

typedef union tagMMF {
    PFN pfn;

    LRESULT (*pfn_lwwwl)(HWND, UINT, WPARAM, LPARAM);
    BOOL    (*pfn_bwwwl)(HWND, UINT, WPARAM, LPARAM);
    void    (*pfn_vv)();
    BOOL    (*pfn_bv)();
    void    (*pfn_vw)(WPARAM);
    BOOL    (*pfn_bw)(WPARAM);
    void    (*pfn_vh)(HANDLE);
    BOOL    (*pfn_bh)(HANDLE);
    BOOL    (*pfn_bhl)(HANDLE, LPARAM);
    void    (*pfn_vhww)(HANDLE, UINT, WORD);
    void    (*pfn_vhhw)(HANDLE, HANDLE, WORD);
} MMF;

typedef enum tagMSIG {
    ms_end = 0,

    ms_lwwwl,   // LRESULT (HWND, UINT, WORD, LPARAM)
    ms_bwwwl,   // BOOL    (HWND, UINT, WORD, LPARAM)
    ms_vv,      // void    (void)
    ms_bv,      // BOOL    (void)
    ms_vw,      // void    (WPARAM)
    ms_bw,      // BOOL    (WPARAM)
    ms_vh,      // void    (HANDLE)
    ms_bh,      // BOOL    (HANDLE)
    ms_bhl,     // BOOL    (HANDLE, LPARAM)
    ms_vhww,    // void    (HANDLE, UINT,   WORD)
    ms_vhhw,    // void    (HANDLE, HANDLE, WORD)
} MSIG;

typedef struct tagMSD {
    UINT msg;
    MSIG ms;
    PFN  pfn;
} MSD;
typedef MSD *PMSD;

typedef struct tagCMD {
    UINT nID, nLastID;
    MSIG ms;
    PFN  pfn;
} CMD;
typedef CMD *PCMD;

INT_PTR Dlg_MsgProc(const MSD *pmsd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp);
BOOL Msg_OnCmd(const CMD *pcmd, HWND hDlg, UINT msg, WPARAM wp, LPARAM lp);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\emptyvol.cpp ===
#include "init.h"
#include <emptyvc.h>
#include <regstr.h>
#include "general.h"
#include "dlg.h"
#include "emptyvol.h"
#include "parseinf.h"

#define MAX_DRIVES                 26   // there are 26 letters only

// {8369AB20-56C9-11d0-94E8-00AA0059CE02}
const CLSID CLSID_EmptyControlVolumeCache = {
                            0x8369ab20, 0x56c9, 0x11d0, 
                            0x94, 0xe8, 0x0, 0xaa, 0x0,
                            0x59, 0xce, 0x2};

/******************************************************************************
    class CEmptyControlVolumeCache
******************************************************************************/

class CEmptyControlVolumeCache : public IEmptyVolumeCache
{
public:
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEmptyVolumeCache Methods
    STDMETHODIMP Initialize(HKEY hRegKey, LPCWSTR pszVolume,
        LPWSTR *ppszDisplayName, LPWSTR *ppszDescription, DWORD *pdwFlags);
    STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwSpaceUsed,
        IEmptyVolumeCacheCallBack *picb);
    STDMETHODIMP Purge(DWORDLONG dwSpaceToFree,
        IEmptyVolumeCacheCallBack *picb);
    STDMETHODIMP ShowProperties(HWND hwnd);
    STDMETHODIMP Deactivate(DWORD *pdwFlags);

// Attributes
public:
    static HRESULT IsControlExpired(HANDLE hControl, BOOL fUseCache = TRUE);

// Implementation
public:
    // Constructor and destructor
    CEmptyControlVolumeCache();
    virtual ~CEmptyControlVolumeCache();

protected:
        // implementation data helpers

    // Note. Write operations are only perfomed by the private functions
    //       prefixed cpl_XXX. Read access is not restricted.
    LPCACHE_PATH_NODE m_pPathsHead,
                      m_pPathsTail;

    // Note. Write operations are only perfomed by the private functions
    //       prefixed chl_XXX. Read access is not restricted.
    LPCONTROL_HANDLE_NODE m_pControlsHead,
                          m_pControlsTail;

    WCHAR     m_szVol[4];
    DWORDLONG m_dwTotalSize;
    ULONG     m_cRef;

        // implementation helper routines

    // cpl prefix stands for CachePathsList
    HRESULT cpl_Add(LPCTSTR pszCachePath);
    void    cpl_Remove();
    HRESULT cpl_CreateForVolume(LPCWSTR pszVolume = NULL);

    // chl prefix stands for ControlHandlesList
    HRESULT chl_Find(HANDLE hControl,
        LPCONTROL_HANDLE_NODE *rgp = NULL, UINT nSize = 1) const;
    HRESULT chl_Add(HANDLE hControl);
    void    chl_Remove(LPCONTROL_HANDLE_NODE rgp[2]);
    HRESULT chl_Remove(HANDLE hControl = NULL);
    HRESULT chl_CreateForPath(LPCTSTR pszCachePath,
        DWORDLONG *pdwUsedInFolder = NULL);

    friend HRESULT _stdcall EmptyControl_CreateInstance(IUnknown *pUnkOuter,
        REFIID riid, LPVOID* ppv);

//  friend BOOL CALLBACK EmptyControl_PropertiesDlgProc(HWND hDlg,
//      UINT msg, WPARAM wp, LPARAM lp);
};


STDAPI EmptyControl_CreateInstance(IUnknown *pUnkOuter, REFIID riid, LPVOID* ppv)
{
    *ppv = NULL;

    if (pUnkOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    CEmptyControlVolumeCache *pCRC = new CEmptyControlVolumeCache;
    if (pCRC == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pCRC->QueryInterface(riid, ppv);
    pCRC->Release();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache constructor and destructor

CEmptyControlVolumeCache::CEmptyControlVolumeCache()
{
    DllAddRef();

    m_pPathsHead = m_pPathsTail = NULL;
    m_pControlsHead = m_pControlsTail = NULL;

    m_szVol[0] = L'\0';
    m_dwTotalSize = 0;
    m_cRef = 1;
}

CEmptyControlVolumeCache::~CEmptyControlVolumeCache()
{
    ASSERT(m_cRef == 0);
    cpl_Remove();
    chl_Remove();

    DllRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache attributes


// CEmptyControlVolumeCache::IsControlExpired
// Check if a control has not been accessed for more than N days. If there is
// no registry entry, default is DEFAULT_DAYS_BEFORE_EXPIRE.
//
// Parameters: fUseCache can be used to not go to the registry for the value
// of N above.
//
// Returns: either the Win32 error converted to HRESULT or
//          S_OK if control is expired and S_FALSE if not;
//
// Used by: only by CEmptyControlVolumeCache::chl_CreateForPath
//
HRESULT CEmptyControlVolumeCache::IsControlExpired(HANDLE hControl,
    BOOL fUseCache /*= TRUE*/)
{
    SYSTEMTIME    stNow;
    FILETIME      ftNow;
    FILETIME      ftLastAccess;
    LARGE_INTEGER timeExpire;
    HRESULT       hr = S_OK;

    ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);

    // don't expire controls with uncertain access time.
    if (FAILED(GetLastAccessTime(hControl, &ftLastAccess)))
        return S_FALSE;
 
    //----- Time calculations (wierd looking) -----
    // Add to last access date the length of time before a control expires
    timeExpire.LowPart  = ftLastAccess.dwLowDateTime;
    timeExpire.HighPart = ftLastAccess.dwHighDateTime;
    timeExpire.QuadPart += (((CCacheItem*)hControl)->GetExpireDays() * 864000000000L); //24*3600*10^7

    GetLocalTime(&stNow);
    SystemTimeToFileTime(&stNow, &ftNow);

    return CompareFileTime((FILETIME*)&timeExpire, &ftNow) <= 0 ?
        S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache CachePathsList routines

// CEmptyControlVolumeCache::cpl_Add
// Check if a control has not been accessed for more than N days. If there is
// no registry entry, default is DEFAULT_DAYS_BEFORE_EXPIRE.
//
// Parameters: a cache folder path to add.
//
// Returns: E_OUTOFMEMORY or
//          S_FALSE if path is already in the list or S_OK if added.
//
// Used by: only by CEmptyControlVolumeCache::cpl_CreateForVolume
//
HRESULT CEmptyControlVolumeCache::cpl_Add(LPCTSTR pszCachePath)
{
    LPCACHE_PATH_NODE pNode;

    ASSERT(pszCachePath != NULL);

    for (pNode = m_pPathsHead; pNode != NULL; pNode = pNode->pNext)
        if (lstrcmpi(pNode->szCachePath, pszCachePath) == 0)
            break;
    if (pNode != NULL)
        return S_FALSE;

    pNode = new CACHE_PATH_NODE;
    if (pNode == NULL)
        return E_OUTOFMEMORY;

    lstrcpyn(pNode->szCachePath, pszCachePath, MAX_PATH);
    pNode->pNext = NULL;
    if (m_pPathsHead == NULL)
        m_pPathsHead = pNode;
    else
        m_pPathsTail->pNext = pNode;
    m_pPathsTail = pNode;

    return S_OK;
}

// CEmptyControlVolumeCache::cpl_Remove
// Remove all paths from the internal list.
//
// Parameters: none;
//
// Returns: void;
//
// Used by: several obvious places
//
void CEmptyControlVolumeCache::cpl_Remove()
{
    // remove cache path list
    for (LPCACHE_PATH_NODE pCur = m_pPathsHead;
         m_pPathsHead != NULL;
         pCur = m_pPathsHead) {

        m_pPathsHead = m_pPathsHead->pNext;
        delete[] pCur;
    }
    m_pPathsTail = NULL;
}

// CEmptyControlVolumeCache::cpl_CreateForVolume
// Build a list of paths to cache folders.
//
// Parameters: volume (or drive) where these folders are;
//
// Returns: S_OK or one out of the bunch of obvious errors;
//
// Used by: only by IEmptyVolumeCache::GetSpaceUsed
//
HRESULT CEmptyControlVolumeCache::cpl_CreateForVolume(LPCWSTR pszVolume)
{
    HKEY    hkey = NULL;
    HRESULT hr   = E_FAIL;
    int     iDriveNum;

    ASSERT(pszVolume != NULL);
    iDriveNum = PathGetDriveNumberW(pszVolume);
    if (iDriveNum < 0)
        return E_INVALIDARG;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_ACTIVEX_CACHE, 0,
            KEY_READ, &hkey) != ERROR_SUCCESS)
        return E_FAIL;

    TCHAR szCachePath[MAX_PATH],
          szValue[MAX_PATH];
    DWORD dwIndex    = 0,
          dwValueLen = MAX_PATH, dwLen = MAX_PATH;

    cpl_Remove();
    while (RegEnumValue(hkey, dwIndex++, szValue, &dwValueLen, NULL, NULL,
               (LPBYTE)szCachePath, &dwLen) == ERROR_SUCCESS) {
        dwLen = dwValueLen = MAX_PATH;

        if (PathGetDriveNumber(szCachePath) != iDriveNum)
            continue;

        // we must have added at least one successfully to get a success code..
        hr = cpl_Add(szCachePath);
        if (FAILED(hr))
            break;
    }
    RegCloseKey(hkey);

    if (FAILED(hr))
        cpl_Remove();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CEmptyControlVolumeCache ControlHandlesList routines

// CEmptyControlVolumeCache::chl_Find
// Find and return a location for the specified handle in the internal list.
// if (rgp == NULL), only result matters;
// if (rgp != NULL),
//     if (nSize == 1), *rgp is going to have found item (if it's there)
//     if (nSize >= 2), *rgp[0] = prev to the found item, and *rgp[1] is the
//                      item.
//
// Parameters: explained above;
//
// Returns: S_OK if the item is found, S_FALSE otherwise or
//          one out of the bunch of obvious errors;
//
// Used by: CEmptyControlVolumeCache::chl_Add and
//          CEmptyControlVolumeCache::chl_Remove
//
HRESULT CEmptyControlVolumeCache::chl_Find(HANDLE hControl,
    LPCONTROL_HANDLE_NODE *rgp /*= NULL*/, UINT nSize /*= 1*/) const
{
    LPCONTROL_HANDLE_NODE pCur,
                          pPrev = NULL;

    ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);
    for (pCur = m_pControlsHead; pCur != NULL; pCur = pCur->pNext) {
        if (pCur->hControl == hControl)
            break;
        pPrev = pCur;
    }
    if (pCur == NULL)
        pPrev = NULL;                           // zero out possible return

    if (rgp != NULL && nSize > 0)
        if (nSize == 1)
            *rgp = pCur;
        else { /* if (nSize >= 2) */
            rgp[0] = pPrev;
            rgp[1] = pCur;
        }

    return (pCur != NULL) ? S_OK : E_FAIL;
}

HRESULT CEmptyControlVolumeCache::chl_Add(HANDLE hControl)
{
    LPCONTROL_HANDLE_NODE pNode;
    DWORD                 dwSize;

    // Note. Retail build assumes that handle is not in the list.
    ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);
    ASSERT(FAILED(chl_Find(hControl)));

    pNode = new CONTROL_HANDLE_NODE;
    if (pNode == NULL)
        return E_OUTOFMEMORY;

    GetControlInfo(hControl, GCI_SIZESAVED, &dwSize, NULL, 0);

    pNode->hControl = hControl;
    pNode->pNext    = NULL;

    if (m_pControlsHead == NULL)
        m_pControlsHead = pNode;
    else {
        ASSERT(m_pControlsHead != NULL);
        m_pControlsTail->pNext = pNode;
    }
    m_pControlsTail = pNode;

    m_dwTotalSize += dwSize;
    return S_OK;
}

void CEmptyControlVolumeCache::chl_Remove(LPCONTROL_HANDLE_NODE rgp[2])
{
    DWORD dwSize;

    if (m_pControlsHead == NULL || (rgp[0] != NULL && rgp[1] == NULL))
        return;

    if (rgp[0] != NULL)
        rgp[0]->pNext = rgp[1]->pNext;
    else {
        rgp[1] = m_pControlsHead;
        m_pControlsHead = m_pControlsHead->pNext;
    }

    if (rgp[1] == m_pControlsTail)
        m_pControlsTail = rgp[0];

    if (GetControlInfo(rgp[1]->hControl, GCI_SIZESAVED, &dwSize, NULL, 0))
    {
        // only proceeed if GetControlInfo succeeds
    
        // Note. This code assumes that the size of a control didn't change since
        //       it was added.
        m_dwTotalSize -= dwSize;
    }
    
    ReleaseControlHandle(rgp[1]->hControl);
    delete rgp[1];
}

HRESULT CEmptyControlVolumeCache::chl_Remove(HANDLE hControl /*= NULL*/)
{
    LPCONTROL_HANDLE_NODE rgp[2] = { NULL, NULL };
    HRESULT hr;

    ASSERT(hControl != INVALID_HANDLE_VALUE);
    if (hControl != NULL) {
        hr = chl_Find(hControl, rgp, 2);
        if (FAILED(hr))
            return hr;

        chl_Remove(rgp);
        return S_OK;
    }

    while (m_pControlsHead != NULL)
        chl_Remove(rgp);

    ASSERT(m_pControlsHead == NULL && m_pControlsTail == NULL);
    return S_OK;
}

// CEmptyControlVolumeCache::chl_CreateForPath
// Calculate the size in bytes taken up by controls in the control cache
// folder specified.
//
// Parameters: pszCachePath is a path to the controls cache folder;
//             pdwSpaceUsed is the result
//
// Used by: only by IEmptyVolumeCache::GetSpaceUsed
//
HRESULT CEmptyControlVolumeCache::chl_CreateForPath(LPCTSTR pszCachePath,
    DWORDLONG *pdwUsedInFolder /*= NULL*/)
{
    DWORDLONG dwCopy;
    HANDLE    hFind    = NULL,
              hControl = NULL;
    LONG      lResult;
    BOOL      fCache   = FALSE;

    dwCopy = m_dwTotalSize;
    for (lResult = FindFirstControl(hFind, hControl, pszCachePath);
         lResult == ERROR_SUCCESS;
         lResult = FindNextControl(hFind, hControl)) {

        lResult = HRESULT_CODE(IsControlExpired(hControl, fCache));
        fCache  = TRUE;
        if (lResult != ERROR_SUCCESS)
            continue;

        lResult = HRESULT_CODE(chl_Add(hControl));
        if (lResult != ERROR_SUCCESS)
            break;
    }
    FindControlClose(hFind);

    if (lResult == ERROR_NO_MORE_ITEMS)
        lResult = ERROR_SUCCESS;

    if (pdwUsedInFolder != NULL) {
        *pdwUsedInFolder = m_dwTotalSize - dwCopy;
    }
    return HRESULT_FROM_WIN32(lResult);
}


/******************************************************************************
    IUnknown Methods
******************************************************************************/

STDMETHODIMP CEmptyControlVolumeCache::QueryInterface(REFIID iid, void** ppv)
{
    if (ppv == NULL)
        return E_POINTER;
    *ppv = NULL;

    if (iid != IID_IUnknown && iid != IID_IEmptyVolumeCache)
        return E_NOINTERFACE;

    *ppv = (void *)this;
    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CEmptyControlVolumeCache::AddRef()
{
    return (++m_cRef);
}

STDMETHODIMP_(ULONG) CEmptyControlVolumeCache::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}


/******************************************************************************
    IEmptyVolumeCache Methods
******************************************************************************/

STDMETHODIMP CEmptyControlVolumeCache::Initialize(HKEY hRegKey,
    LPCWSTR pszVolume, LPWSTR *ppszDisplayName, LPWSTR *ppszDescription,
    DWORD *pdwFlags)
{
    if (pszVolume == NULL)
        return E_POINTER;

    if (ppszDisplayName == NULL || ppszDescription == NULL)
        return E_POINTER;

    if (pdwFlags == NULL)
        return E_POINTER;

    StrCpyNW(m_szVol, pszVolume, ARRAYSIZE(m_szVol));
    cpl_Remove();
    chl_Remove();
    
    if (lstrlenW(m_szVol) == 0) {
        return E_UNEXPECTED;
    }

    if (FAILED(cpl_CreateForVolume(m_szVol))) {
        return E_FAIL;
    }

    *ppszDisplayName = *ppszDescription = NULL;
    *pdwFlags = EVCF_HASSETTINGS | EVCF_ENABLEBYDEFAULT |
        EVCF_ENABLEBYDEFAULT_AUTO;
    return S_OK;
}

STDMETHODIMP CEmptyControlVolumeCache::GetSpaceUsed(DWORDLONG *pdwSpaceUsed,
    IEmptyVolumeCacheCallBack *picb)
{
    LPCACHE_PATH_NODE pCur;
    HRESULT hr = S_OK;

    if (pdwSpaceUsed == NULL) {
        hr = E_POINTER;
        goto LastNotification;
    }
    *pdwSpaceUsed = 0;

    if (lstrlenW(m_szVol) == 0) {
        hr = E_UNEXPECTED;
        goto LastNotification;
    }

    for (pCur = m_pPathsHead; pCur != NULL; pCur = pCur->pNext) {
        DWORDLONG dwlThisItem = 0;
        if (FAILED(chl_CreateForPath(pCur->szCachePath, &dwlThisItem)))
            hr = S_FALSE;                       // at least one failed

        m_dwTotalSize += dwlThisItem;
        
        if (picb != NULL)
            picb->ScanProgress(m_dwTotalSize, 0, NULL);
    }
//  cpl_Remove();                               // because of ShowProperties

    *pdwSpaceUsed = m_dwTotalSize;

LastNotification:
    if (picb != NULL)
        picb->ScanProgress(m_dwTotalSize, EVCCBF_LASTNOTIFICATION, NULL);
    return hr;
}

STDMETHODIMP CEmptyControlVolumeCache::Purge(DWORDLONG dwSpaceToFree,
    IEmptyVolumeCacheCallBack *picb)
{
    LPCONTROL_HANDLE_NODE rgp[2] = { NULL, NULL };
    DWORDLONG dwSpaceFreed;
    HANDLE    hControl;
    DWORD     dwSize;
    HRESULT   hr;

    if (m_pControlsHead == NULL) {
        DWORDLONG dwSpaceUsed;

        hr = GetSpaceUsed(&dwSpaceUsed, picb);
        if (FAILED(hr) || m_pControlsHead == NULL)
            hr = FAILED(hr) ? hr : STG_E_NOMOREFILES;

        if (picb != NULL)
            picb->PurgeProgress(0, dwSpaceToFree, EVCCBF_LASTNOTIFICATION,
                NULL);

        return hr;
    }

    dwSpaceFreed = 0;
    ASSERT(m_pControlsHead != NULL);
    while (m_pControlsHead != NULL) {
        hControl = m_pControlsHead->hControl;
        ASSERT(hControl != NULL && hControl != INVALID_HANDLE_VALUE);

        GetControlInfo(hControl, GCI_SIZESAVED, &dwSize, NULL, 0);

        hr = RemoveControlByHandle2(hControl, FALSE, TRUE);
        if (SUCCEEDED(hr)) {
            dwSpaceFreed += dwSize;

            if (picb != NULL)
                picb->PurgeProgress(dwSpaceFreed, dwSpaceToFree, 0, NULL);
        }
        chl_Remove(rgp);

        if (dwSpaceFreed >= dwSpaceToFree)
            break;
    }

    if (picb != NULL)
        picb->PurgeProgress(dwSpaceFreed, dwSpaceToFree, 0, NULL);

    return S_OK;
}

// Note. This function opens the last cache folder in the internal list.
STDMETHODIMP CEmptyControlVolumeCache::ShowProperties(HWND hwnd)
{
    // Note. (According to SeanF) The codedownload engine will query
    //       ActiveXCache key under HKLM\SOFTWARE\Microsoft\Windows\
    //       CurrentVersion\Internet Settings. The value of this key should
    //       be equal to the last item in the CachePathsList which is why
    //       navigation below is done for the tail.
    if (m_pPathsTail == NULL || m_pPathsTail->szCachePath == NULL)
        return E_UNEXPECTED;

    ShellExecute(hwnd, NULL, m_pPathsTail->szCachePath, NULL, NULL, SW_SHOW);
    return S_OK;
/*
    int iDlgResult;

    iDlgResult = MLDialogBoxWrap(MLGetHinst(), MAKEINTRESOURCE(IDD_PROP_EXPIRE), hwnd,
        EmptyControl_PropertiesDlgProc);

    return iDlgResult == IDOK ? S_OK : S_FALSE;
*/
}

STDMETHODIMP CEmptyControlVolumeCache::Deactivate(DWORD *pdwFlags)
{
    if (pdwFlags == NULL)
        return E_INVALIDARG;
    *pdwFlags = 0;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Implementation helpers routines (private)

/*
static void msg_OnInitDialog(HWND hDlg);
static BOOL msg_OnCommand(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp);

static BOOL cmd_OnOK(HWND hDlg);

INT_PTR CALLBACK EmptyControl_PropertiesDlgProc(HWND hDlg,
    UINT msg, WPARAM wp, LPARAM lp)
{
    static MSD rgmsd[] = {
        { WM_INITDIALOG, ms_vh,    (PFN)msg_OnInitDialog },
        { WM_COMMAND,    ms_bwwwl, (PFN)msg_OnCommand    },
        { WM_NULL,       ms_end,   (PFN)NULL             }
    };

    return Dlg_MsgProc(rgmsd, hDlg, msg, wp, lp);
}

void msg_OnInitDialog(HWND hDlg)
{
    UINT nDays;

    CEmptyControlVolumeCache::GetDaysBeforeExpire(&nDays);
    SetDlgItemInt(hDlg, IDC_EDIT_EXPIRE, nDays, FALSE);
}

BOOL msg_OnCommand(HWND hDlg, UINT msg, WPARAM wp, LPARAM lp)
{
    static CMD rgcmd[] = {
        { IDOK, 0, ms_bh,  (PFN)cmd_OnOK },
        { 0,    0, ms_end, (PFN)NULL     }
    };

    return Msg_OnCmd(rgcmd, hDlg, msg, wp, lp);
}

BOOL cmd_OnOK(HWND hDlg)
{
    UINT nDays;
    BOOL fWorked;

    nDays = GetDlgItemInt(hDlg, IDC_EDIT_EXPIRE, &fWorked, FALSE);
    if (!fWorked) {
        MessageBeep(-1);
        SetFocus(GetDlgItem(hDlg, IDC_EDIT_EXPIRE));
        return FALSE;
    }

    CEmptyControlVolumeCache::SetDaysBeforeExpire(nDays);
    return TRUE;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\emptyvol.h ===
#ifndef __EMPTY_VOLUME_CACHE__
#define __EMPTY_VOLUME_CACHE__

#include "utils.h"

// Define node storing a path read from the registry in a singly-linked list.
typedef struct _TAG_CACHE_PATH_NODE CACHE_PATH_NODE;
typedef CACHE_PATH_NODE* LPCACHE_PATH_NODE;
struct _TAG_CACHE_PATH_NODE
{
    TCHAR szCachePath[MAX_PATH];

    LPCACHE_PATH_NODE pNext;
};

// Define node storing control handles in a singly-linked list.
typedef struct _TAG_CONTROL_HANDLE_NODE CONTROL_HANDLE_NODE;
typedef CONTROL_HANDLE_NODE* LPCONTROL_HANDLE_NODE;
struct _TAG_CONTROL_HANDLE_NODE
{
    HANDLE hControl;

    LPCONTROL_HANDLE_NODE pNext;
};

// Define node storing heads and tails of control handle lists in a 
// singly-linked list.
// There is a control handle list for each volume.
typedef struct _TAG_CONTROL_HANDLE_HEADER CONTROL_HANDLE_HEADER;
typedef CONTROL_HANDLE_HEADER* LPCONTROL_HANDLE_HEADER;
struct _TAG_CONTROL_HANDLE_HEADER
{
    DWORD dwSpaceUsed;
    int   nDriveNum;

    LPCONTROL_HANDLE_NODE pHandlesHead;
    LPCONTROL_HANDLE_NODE pHandlesTail;

    LPCONTROL_HANDLE_HEADER pNext;
};

// Handles to activeX controls are cached in memory during calls to
// GetSpaceUsed so that re-enumeration is not needed for subsequent
// calls to Purge.
//
// The structure for storing control handles for various volumes is:
//
//                                m_pControlsTail -+
//                                                 |
//                                                \|/
//   m_pControlsHead --> Header01 --> Header02 --> Header03 --> NULL
//                       |            |            |
//                       +- C:        +- D:        +- E:
//                       |            |            |
//                       +- Head01    +- Head02    +- Head03
//                       |            |            |
//                       +- Tail01    +- Tail02    +- Tail03
//
// where 
//      HeaderXX is of type CONTROL_HANDLE_HEADER, and
//      HeadXX and TailXX are of type LPCONTROL_HANDLE_NODE.
//
// HeadXX and TailXX are respectively head and tail pointers to a list
// of handles.  Those are handles to controls installed on the drive
// specified in HeaderXX.
//


#endif // __EMPTY_VOLUME_CACHE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\enum.h ===
#ifndef __CONTROL_ENUM__
#define __CONTROL_ENUM__

#include "general.h"

class CControlFolderEnum : public IEnumIDList
{
public:
    CControlFolderEnum(STRRET &str, LPCITEMIDLIST pidl, UINT shcontf);
    
    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList Methods 
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(LPENUMIDLIST *ppenum);

protected:
    ~CControlFolderEnum();

    UINT                m_cRef;      // ref count
    UINT                m_shcontf;   // enumeration flags
    LPMALLOC            m_pMalloc;
    HANDLE              m_hEnumControl;
    BOOL                m_bEnumStarted;
    TCHAR               m_szCachePath[MAX_PATH];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\enum.cpp ===
#include "enum.h"

BOOL GetVersion(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf);
BOOL GetTimeInfo(
               BOOL bCreation, LPCONTROLPIDL pcpidl, 
               FILETIME* lpTime, LPTSTR lpszBuf, BOOL bShowTime);

// Also defined in nt\private\inet\urlmon\isctrl.cxx
const TCHAR *g_pszLastCheckDateKey = "LastCheckDate";
const TCHAR *g_pszUpdateInfo = "UpdateInfo";

#if defined(ALIGNMENT_MACHINE)
BOOL
__inline
static
uaGetControlInfo(
    IN     HANDLE hControlHandle,
    IN     UINT nFlag,
    IN OUT DWORD UNALIGNED *lpdwuData,
    IN OUT LPTSTR lpszBuf,
    IN     int nBufLen
    )
{
    DWORD dwData;
    LPDWORD lpdwData;
    BOOL result;

    if (lpdwuData != NULL) {
        dwData = *lpdwuData;
	lpdwData = &dwData;
    } else {
        lpdwData = NULL;
    }

    result = GetControlInfo( hControlHandle,
                             nFlag,
			     lpdwData,
			     lpszBuf,
			     nBufLen );

    if (lpdwuData != NULL) {
        *lpdwuData = dwData;
    }

    return result;
}

BOOL
__inline
static
uaGetTimeInfo(
    IN     BOOL bCreation,
    IN OUT LPCONTROLPIDL pcpidl,
    IN OUT FILETIME UNALIGNED *lpuTime,
    IN OUT LPTSTR lpszBuf,
    IN     BOOL bShowTime
    )
{
    FILETIME time;
    LPFILETIME lpTime;
    BOOL result;

    if (lpuTime != NULL) {
        time = *lpuTime;
	lpTime = &time;
    } else {
        lpTime = NULL;
    }

    result = GetTimeInfo( bCreation,
                          pcpidl,
			  lpTime,
			  lpszBuf,
			  bShowTime );

    if (lpuTime != NULL) {
        *lpuTime = time;
    }

    return result;
}

#else
#define uaGetControlInfo GetControlInfo
#define uaGetTimeInfo    GetTimeInfo
#endif

    
    

///////////////////////////////////////////////////////////////////////////////
// IEnumIDList methods

CControlFolderEnum::CControlFolderEnum(STRRET &str, LPCITEMIDLIST pidl, UINT shcontf) :
    m_shcontf(shcontf)
{
    DebugMsg(DM_TRACE, TEXT("cfe - CControlFolderEnum() called"));
    m_cRef = 1;
    DllAddRef();

    m_bEnumStarted = FALSE;
    m_hEnumControl = NULL;

    StrRetToBuf(&str, pidl, m_szCachePath, MAX_PATH);

    SHGetMalloc(&m_pMalloc);          // won't fail
}

CControlFolderEnum::~CControlFolderEnum()
{
    Assert(m_cRef == 0);         // we should always have a zero ref count here
    DebugMsg(DM_TRACE, TEXT("cfe - ~CControlFolderEnum() called."));
    DllRelease();
}

HRESULT CControlFolderEnum_CreateInstance(
                                      LPITEMIDLIST pidl, 
                                      UINT shcontf,
                                      LPENUMIDLIST *ppeidl)

{
    DebugMsg(DM_TRACE,("cfe - CreateInstance() called."));

    if (pidl == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    HRESULT hr;
    LPSHELLFOLDER pshf = NULL;
    if (FAILED(hr = SHGetDesktopFolder(&pshf)))
        return hr;

    STRRET name;
    hr = pshf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &name);
    if (FAILED(hr))
        return hr;

    *ppeidl = NULL;                 // null the out param

    CControlFolderEnum *pCFE = new CControlFolderEnum(name, pidl, shcontf);
    if (!pCFE)
        return E_OUTOFMEMORY;
    
    *ppeidl = pCFE;

    return S_OK;
}

BOOL GetVersion(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf)
{
    Assert(pcpidl != NULL);
    LPCTSTR pszLocation = GetStringInfo(pcpidl, SI_LOCATION);

    DWORD dwBufLen;
    DWORD dwHandle;
    BOOL fResult = FALSE;
    UINT uLen;
    VS_FIXEDFILEINFO *pVersionInfo = NULL;

    // Quick copy to handle failure cases
    lstrcpy(lpszBuf, g_szUnknownData);

    if ((dwBufLen = ::GetFileVersionInfoSize(
                                    (LPTSTR)pszLocation, 
                                    &dwHandle)) == 0)
    return FALSE;

    BYTE *pbData = new BYTE[dwBufLen];
    if (pbData == NULL)
        return FALSE;

    if (GetFileVersionInfo((LPTSTR)pszLocation, dwHandle, dwBufLen, pbData))
    {
        fResult = VerQueryValue(pbData, "\\", (LPVOID*)&pVersionInfo, &uLen);
        
        if (fResult)
        {
            wsprintf(lpszBuf, "%d,%d,%d,%d",
                    (pVersionInfo->dwFileVersionMS & 0xffff0000)>>16,
                    (pVersionInfo->dwFileVersionMS & 0xffff),
                    (pVersionInfo->dwFileVersionLS & 0xffff0000)>>16,
                    (pVersionInfo->dwFileVersionLS & 0xffff));
        }

    }

    delete [] pbData;

    return fResult;
}

BOOL GetTimeInfo(
             BOOL bCreation, 
             LPCONTROLPIDL pcpidl, 
             FILETIME* lpTime,
             LPTSTR lpszBuf,
             BOOL bShowTime)
{
    Assert(pcpidl != NULL);
        Assert (lpszBuf != NULL);
    if (pcpidl == NULL || lpszBuf == NULL)
        return FALSE;

    LPCTSTR pszLocation = GetStringInfo(pcpidl, SI_LOCATION);

    BOOL fResult = TRUE;
    HANDLE hFile = NULL;
        WIN32_FIND_DATA findFileData;
        TCHAR szTime[TIMESTAMP_MAXSIZE];
    TCHAR szDate[TIMESTAMP_MAXSIZE];
        SYSTEMTIME sysTime;
        FILETIME localTime;

        hFile = FindFirstFile(pszLocation, &findFileData);

    if (hFile != INVALID_HANDLE_VALUE)
    {
                // Get the creation time and date information.
        if (bCreation)
        {
            *lpTime = findFileData.ftCreationTime;
                    FileTimeToLocalFileTime(&findFileData.ftCreationTime, &localTime);
        }
        else
        {
            *lpTime = findFileData.ftLastAccessTime;
                    FileTimeToLocalFileTime(&findFileData.ftLastAccessTime, &localTime);
        }

        FileTimeToSystemTime(&localTime, &sysTime);

        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &sysTime,
            NULL,
            szDate,
            TIMESTAMP_MAXSIZE);

        lstrcpy(lpszBuf, szDate);

        if (bShowTime)
        {
            GetTimeFormat(
                LOCALE_SYSTEM_DEFAULT,
                TIME_NOSECONDS,
                &sysTime,
                NULL,
                szTime,
                TIMESTAMP_MAXSIZE
                );

            lstrcat(lpszBuf, TEXT(" "));
            lstrcat(lpszBuf, szTime);
        }

            FindClose(hFile);
    }
    else
    {
        fResult = FALSE;
        lstrcpy(lpszBuf, g_szUnknownData);
        lpTime->dwLowDateTime = lpTime->dwHighDateTime = 0;
    }

        return fResult;
}

LPCONTROLPIDL CreateControlPidl(IMalloc *pmalloc, HANDLE hControl)
{
    Assert(pmalloc != NULL);

    DWORD dw;
    GetControlInfo(hControl, GCI_TOTALFILES, &dw, NULL, 0);
    ULONG ulSize = sizeof(CONTROLPIDL) + sizeof(USHORT);
    ulSize += (dw - 1) * sizeof(DEPENDENTFILEINFO);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)pmalloc->Alloc(ulSize);

    if (pcpidl)
    {
        memset(pcpidl, 0, ulSize);
        pcpidl->cb = (USHORT)(ulSize - sizeof(USHORT));

        pcpidl->ci.cTotalFiles = (UINT)dw;
        uaGetControlInfo(hControl, GCI_TOTALSIZE, &(pcpidl->ci.dwTotalFileSize), NULL, 0);
        uaGetControlInfo(hControl, GCI_SIZESAVED, &(pcpidl->ci.dwTotalSizeSaved), NULL, 0);
        GetControlInfo(hControl, GCI_NAME, NULL, pcpidl->ci.szName, CONTROLNAME_MAXSIZE);
        GetControlInfo(hControl, GCI_FILE, NULL, pcpidl->ci.szFile, MAX_PATH);
        GetControlInfo(hControl, GCI_CLSID, NULL, pcpidl->ci.szCLSID, MAX_CLSID_LEN);
        GetControlInfo(hControl, GCI_TYPELIBID, NULL, pcpidl->ci.szTypeLibID, MAX_CLSID_LEN);
        uaGetTimeInfo(TRUE, pcpidl, &(pcpidl->ci.timeCreation), pcpidl->ci.szCreation, TRUE);
        uaGetTimeInfo(FALSE, pcpidl, &(pcpidl->ci.timeLastAccessed), pcpidl->ci.szLastAccess, FALSE);

        GetControlInfo(hControl, GCI_CODEBASE, NULL, pcpidl->ci.szCodeBase, INTERNET_MAX_URL_LENGTH);
        uaGetControlInfo(hControl, GCI_ISDISTUNIT, &(pcpidl->ci.dwIsDistUnit), NULL, 0);
        uaGetControlInfo(hControl, GCI_STATUS, &(pcpidl->ci.dwStatus), NULL, 0);
        uaGetControlInfo(hControl, GCI_HAS_ACTIVEX, &(pcpidl->ci.dwHasActiveX), NULL, 0);
        uaGetControlInfo(hControl, GCI_HAS_JAVA, &(pcpidl->ci.dwHasJava), NULL, 0);
        if (pcpidl->ci.dwIsDistUnit)
        {
            GetControlInfo(hControl, GCI_DIST_UNIT_VERSION, NULL, pcpidl->ci.szVersion, VERSION_MAXSIZE);
        }
        else
        {
            GetVersion(pcpidl, pcpidl->ci.szVersion);
        }

        LONG lResult = ERROR_SUCCESS;
        DEPENDENTFILEINFO UNALIGNED *pInfo = &(pcpidl->ci.dependentFile);
        dw = GetTotalNumOfFiles(pcpidl);
        for (UINT iFile = 0; iFile < (UINT)dw; iFile++)
        {
    	    DWORD alignedSize = pInfo->dwSize;
            lResult = GetControlDependentFile(
                                       iFile,
                                       hControl,
                                       pInfo->szFile,
                                       &alignedSize,
                                       TRUE);
            pInfo->dwSize = alignedSize;
            if (lResult != ERROR_SUCCESS)
                break;
            pInfo = (LPDEPENDENTFILEINFO)(pInfo + 1);
        }
    }

    return pcpidl;
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CControlFolderEnum::QueryInterface(REFIID iid,void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("cfe - QueryInterface called."));
    
    if ((iid == IID_IEnumIDList) || (iid == IID_IUnknown))
    {
        *ppv = (void *)this;
        AddRef();
        return S_OK;
    }
    
    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CControlFolderEnum::AddRef(void)
{
    return ++m_cRef;
}

ULONG CControlFolderEnum::Release(void)
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CControlFolderEnum::Next(
                             ULONG celt, 
                             LPITEMIDLIST *rgelt, 
                             ULONG *pceltFetched)
{
    DebugMsg(DM_TRACE, TEXT("cfe - Next() called."));

    // If asking for stuff we don't have, say we don't have any
    if (!(m_shcontf & SHCONTF_NONFOLDERS))
        return S_FALSE;

    LONG lres = ERROR_SUCCESS;
    HANDLE hControl = NULL;
    LPCONTROLPIDL pcpidl = NULL;

    lres = (!m_bEnumStarted ? 
                  FindFirstControl(m_hEnumControl, hControl, m_szCachePath) :
                  FindNextControl(m_hEnumControl, hControl));

    if (pceltFetched)
        *pceltFetched = (lres == ERROR_SUCCESS ? 1 : 0);

    if (lres != ERROR_SUCCESS)
        goto EXIT_NEXT;

    pcpidl = CreateControlPidl(m_pMalloc, hControl);
    if (pcpidl == NULL)
    {
        lres = ERROR_NOT_ENOUGH_MEMORY;
        goto EXIT_NEXT;
    }

    m_bEnumStarted = TRUE;
    rgelt[0] = (LPITEMIDLIST)pcpidl;

EXIT_NEXT:

    ReleaseControlHandle(hControl);

    if (lres != ERROR_SUCCESS)
    {
        if (pcpidl != NULL)
        {
            m_pMalloc->Free(pcpidl);
            pcpidl = NULL;
        }
        FindControlClose(m_hEnumControl);
        m_bEnumStarted = FALSE;
        rgelt[0] = NULL;
    }

    return HRESULT_FROM_WIN32(lres);
}

HRESULT CControlFolderEnum::Skip(ULONG celt)
{
    DebugMsg(DM_TRACE, TEXT("cfe - Skip() called."));
    return E_NOTIMPL;
}

HRESULT CControlFolderEnum::Reset()
{
    DebugMsg(DM_TRACE, TEXT("cfe - Reset() called."));
    return E_NOTIMPL;
}

HRESULT CControlFolderEnum::Clone(IEnumIDList **ppenum)
{
    DebugMsg(DM_TRACE, TEXT("cfe - Clone() called."));
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\filenode.cpp ===
// Implementation of class CFileNode
//
// During parsing an inf file, information about each file
// is stored in an instance of this class.  Such information
// includes the name of the file, its section in the inf file,
// its location (directory), etc.

#include "filenode.h"

CPNode::CPNode(LPCTSTR szName)
{
    Assert (szName != NULL);
    lstrcpyn(m_szName, szName, MAX_PATH);
    m_pNext = NULL;
    m_bRemovable = FALSE;
}

CPNode::~CPNode()
{
    if (m_pNext != NULL)
        delete m_pNext;
}

// insert a new file node into list
//HRESULT CFileNode::Insert(LPCTSTR szName, LPCTSTR szSection)
HRESULT CPNode::Insert(CPNode* pNewNode)
{
    if (pNewNode == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    m_pNext = pNewNode;
    return S_OK;
}

// get the file node placed right after this one in list
CPNode* CPNode::GetNext() const
{
    return m_pNext;
}

// tell the path in which this file is located
HRESULT CPNode::SetStr(LPTSTR lpszMember, LPCTSTR lpszNew )
{
    Assert (lpszNew != NULL);
    if (lpszNew == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    lstrcpyn(lpszMember, lpszNew, MAX_PATH); // all our string members are MAX_PATH
    return S_OK;
}

// retrieve the name of the file represented by this node
LPCTSTR CPNode::GetName() const
{
    return m_szName;
}


// retrieve the path of the file represented by this node
LPCTSTR CPNode::GetPath() const
{
    return (m_szPath[0] == '\0' ? NULL : m_szPath);
}

// constructor
CPackageNode::CPackageNode(LPCTSTR szName, LPCTSTR szNamespace, LPCTSTR szPath) : CPNode(szName)
{
    Assert (szNamespace != NULL);
    lstrcpyn(m_szName, szName, MAX_PATH);
    lstrcpyn(m_szNamespace, szNamespace, MAX_PATH);
    if (szPath != NULL)
    {
        lstrcpyn(m_szPath, szPath, MAX_PATH);
    }
    else
    {
        m_szPath[0] = '\0';
    }
    m_pNext = NULL;
    m_fIsSystemClass = FALSE;
}

// destructor
CPackageNode::~CPackageNode()
{
}

// retrieve the name of the section in the inf file which
// which the file represented by this node was installed
LPCTSTR CPackageNode::GetNamespace() const
{
    return m_szNamespace;
}

// constructor
CFileNode::CFileNode(LPCTSTR szName, LPCTSTR szSection, LPCTSTR szPath) : CPNode(szName)
{
    Assert (szSection != NULL);
    lstrcpyn(m_szName, szName, MAX_PATH);
    lstrcpyn(m_szSection, szSection, MAX_PATH);
    if (szPath != NULL)
    {
        lstrcpyn(m_szPath, szPath, MAX_PATH);
    }
    else
    {
        m_szPath[0] = '\0';
    }
    m_pNext = NULL;
}

// destructor
CFileNode::~CFileNode()
{
}



// retrieve the name of the section in the inf file which
// which the file represented by this node was installed
LPCTSTR CFileNode::GetSection() const
{
    return m_szSection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\folder.h ===
#ifndef __CONTROL_FOLDER__
#define __CONTROL_FOLDER__

#include "general.h"

// forward declaration
class CControlFolder;
class CControlItem;

HRESULT CControlFolderEnum_CreateInstance(
                                      LPITEMIDLIST pidl,
                                      UINT shcontf,
                                      LPENUMIDLIST *ppeidl);

HRESULT CControlItem_CreateInstance(
                               CControlFolder *pCFolder,
                               UINT cidl, 
                               LPCITEMIDLIST *ppidl, 
                               REFIID riid, 
                               void **ppvOut);

HRESULT ControlFolderView_Command(HWND hwnd, UINT uID);

UINT MergeMenuHierarchy(
                    HMENU hmenuDst, 
                    HMENU hmenuSrc, 
                    UINT idcMin, 
                    UINT idcMax);

///////////////////////////////////////////////////////////////////////////////
// CControlFolder declaration

class CControlFolder : public IShellFolder, 
                       public IPersistFolder2,
                       public IContextMenu
{
    // CControlFolder interfaces
    friend CControlItem;
    friend HRESULT ControlFolderView_CreateInstance(CControlFolder *pHCFolder, LPCITEMIDLIST pidl, void **ppvOut);
    friend HRESULT ControlFolderView_DidDragDrop(
                                            HWND hwnd, 
                                            IDataObject *pdo, 
                                            DWORD dwEffect);
        
public:
    CControlFolder();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
   
    // IShellFolder methods
    STDMETHODIMP ParseDisplayName(
                             HWND hwndOwner, 
                             LPBC pbcReserved,
			                 LPOLESTR lpszDisplayName, 
                             ULONG *pchEaten,
			                 LPITEMIDLIST *ppidl, 
                             ULONG *pdwAttributes);

    STDMETHODIMP EnumObjects(
                        HWND hwndOwner, 
                        DWORD grfFlags,
			            LPENUMIDLIST *ppenumIDList);

    STDMETHODIMP BindToObject(
                          LPCITEMIDLIST pidl, 
                          LPBC pbcReserved,
			              REFIID riid, 
                          void **ppvOut);

    STDMETHODIMP BindToStorage(
                          LPCITEMIDLIST pidl, 
                          LPBC pbcReserved,
			              REFIID riid, 
                          void **ppvObj);

    STDMETHODIMP CompareIDs(
                        LPARAM lParam, 
                        LPCITEMIDLIST pidl1, 
                        LPCITEMIDLIST pidl2);

    STDMETHODIMP CreateViewObject(
                             HWND hwndOwner, 
                             REFIID riid, 
                             void **ppvOut);

    STDMETHODIMP GetAttributesOf(
                            UINT cidl, 
                            LPCITEMIDLIST *apidl,
			                ULONG *rgfInOut);

    STDMETHODIMP GetUIObjectOf(
                          HWND hwndOwner, 
                          UINT cidl, 
                          LPCITEMIDLIST *apidl,
			              REFIID riid, 
                          UINT *prgfInOut, 
                          void **ppvOut);

    STDMETHODIMP GetDisplayNameOf(
                          LPCITEMIDLIST pidl, 
                          DWORD uFlags, 
                          LPSTRRET lpName);

    STDMETHODIMP SetNameOf(
                      HWND hwndOwner, 
                      LPCITEMIDLIST pidl,
			          LPCOLESTR lpszName, 
                      DWORD uFlags, 
                      LPITEMIDLIST *ppidlOut);

    // IShellIcon Methods 
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, LPINT lpIconIndex);

    // IPersist Methods 
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder Methods
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2 Methods
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IContextMenu Methods -- This handles the background context menus
    STDMETHODIMP QueryContextMenu(
                              HMENU hmenu, 
                              UINT indexMenu, 
                              UINT idCmdFirst,
                              UINT idCmdLast, 
                              UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(
                              UINT_PTR idCmd, 
                              UINT uType,
                              UINT *pwReserved,
                              LPTSTR pszName, 
                              UINT cchMax);

protected:
    ~CControlFolder();

    UINT            m_cRef;
    LPITEMIDLIST    m_pidl;
    LPMALLOC        m_pMalloc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\general.h ===
#ifndef __GENERAL__
#define __GENERAL__

#include "resource.h"
#include "init.h"
#include <cleanoc.h>
#include <wininet.h>

#define VERSION_MAXSIZE 50
#define TIMESTAMP_MAXSIZE 64
#define MESSAGE_MAXSIZE 200
#define CONTROLNAME_MAXSIZE 200
#define MAX_KILOBYTE_ABBREV_LEN 16

// Needed for FindFirstControl/FindNextControl
#define MAX_CTRL_NAME_SIZE                      2048
#define MAX_DIST_UNIT_NAME_LEN                  MAX_PATH
#define MAX_CLIENT_LEN                          1024
#define MAX_REGENTRY_SIZE                       1024
#define MAX_CLSID_LEN                           40

// conlumn identifiers
#define NUM_COLUMNS 6
enum {
    SI_CONTROL = 0,    // column
    SI_STATUS,         // column
    SI_TOTALSIZE,      // column
    SI_CREATION,       // column
    SI_LASTACCESS,     // column
    SI_VERSION,        // column
    SI_LOCATION,
    SI_CLSID,
    SI_TYPELIBID,
    SI_CODEBASE
};

// control status flags moved to cleanoc.h ( in iedev\inc )

// struct containing info about a control
struct tagDEPENDENTFILEINFO
{
    TCHAR szFile[MAX_PATH];
    DWORD dwSize;
};
typedef tagDEPENDENTFILEINFO DEPENDENTFILEINFO;
typedef DEPENDENTFILEINFO* LPDEPENDENTFILEINFO;

struct tagCACHECTRLINFO
{
    TCHAR             szName[CONTROLNAME_MAXSIZE];
    TCHAR             szFile[MAX_PATH];
    TCHAR             szCLSID[MAX_CLSID_LEN];
    TCHAR             szTypeLibID[MAX_CLSID_LEN];
    TCHAR             szVersion[VERSION_MAXSIZE];
    TCHAR             szLastAccess[TIMESTAMP_MAXSIZE];
    TCHAR             szCreation[TIMESTAMP_MAXSIZE];
    TCHAR             szLastChecked[TIMESTAMP_MAXSIZE];

    TCHAR             szCodeBase[INTERNET_MAX_URL_LENGTH];
    DWORD             dwIsDistUnit;

    DWORD             dwHasActiveX;
    DWORD             dwHasJava;
    
    DWORD             dwTotalFileSize;
    DWORD             dwTotalSizeSaved;
    UINT              cTotalFiles;
    DWORD             dwStatus;
    FILETIME          timeCreation;
    FILETIME          timeLastAccessed;
    DEPENDENTFILEINFO dependentFile;

};
typedef tagCACHECTRLINFO CACHECTRLINFO;
typedef CACHECTRLINFO* LPCACHECTRLINFO;

// PIDL format for this folder...
struct tagCONTROLPIDL
{
    USHORT cb;
    CACHECTRLINFO ci;
};
typedef tagCONTROLPIDL CONTROLPIDL;
typedef UNALIGNED CONTROLPIDL* LPCONTROLPIDL;

// common expiration
#define DEFAULT_DAYS_BEFORE_EXPIRE 60
#define DEFAULT_DAYS_BEFORE_AUTOEXPIRE 15

// misc macros
#define IS_VALID_CONTROLPIDL(pidl)  (TRUE)
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

// helper functions
LPCTSTR GetStringInfo(LPCONTROLPIDL lpcpidl, int nFlag);
BOOL GetTimeInfo(LPCONTROLPIDL lpcpidl, int nFlag, FILETIME* lpTime);
UINT GetTotalNumOfFiles(LPCONTROLPIDL lpcpidl);
DWORD GetSizeSaved(LPCONTROLPIDL lpcpidl);
BOOL GetSizeSaved(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf);
UINT GetStatus(LPCONTROLPIDL pcpidl);
BOOL GetStatus(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf, int nBufSize);
BOOL GetDependentFile(
                  LPCONTROLPIDL lpcpidl, 
                  UINT iFile, 
                  LPTSTR lpszFile, 
                  DWORD *pdwSize);
HICON GetDefaultOCIcon(LPCONTROLPIDL lpcpidl);
void GetContentBools(LPCONTROLPIDL pcpidl, BOOL *pbHasActiveX, BOOL *pbHasJava );
HRESULT GetLastAccessTime(HANDLE hControl, FILETIME *pLastAccess);


HRESULT CreatePropDialog(
                     HWND hwnd, 
                     LPCONTROLPIDL pcpidl); 
void GenerateEvent(
              LONG lEventId, 
              LPITEMIDLIST pidlFolder, 
              LPITEMIDLIST pidlIn, 
              LPITEMIDLIST pidlNewIn);
HCURSOR StartWaitCur();
void EndWaitCur(HCURSOR hCurOld);

void GetDaysBeforeExpireGeneral(ULONG *pnDays);
void GetDaysBeforeExpireAuto(ULONG *pnDays);

HRESULT WINAPI RemoveControlByName2(
                         LPCTSTR lpszFile,
                         LPCTSTR lpszCLSID,
                         LPCTSTR lpszTypeLibID,
                         BOOL bForceRemove, /* = FALSE */
                         DWORD dwIsDistUnit, /* = FALSE */
                         BOOL bSilent);

HRESULT WINAPI RemoveControlByHandle2(
                         HANDLE hControlHandle,
                         BOOL bForceRemove, /* = FALSE */
                         BOOL bSilent);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\folder.cpp ===
#include "general.h"
#include "folder.h"
#include "utils.h"

#include <mluisupp.h>

#define CPP_FUNCTIONS
#include <crtfree.h>

// string displayed to represent missing data
TCHAR g_szUnknownData[64];

int CompareVersion(LPCTSTR lpszVersion1, LPCTSTR lpszVersion2);

///////////////////////////////////////////////////////////////////////////////
// IShellFolder methods

CControlFolder::CControlFolder()
{
    DebugMsg(DM_TRACE,TEXT("cf - CControlFolder() called."));
    m_cRef = 1;
    DllAddRef();

    // initialize g_szUnknownData, a string used to represent missing data
    if (g_szUnknownData[0] == 0)
        MLLoadString(IDS_UNKNOWNDATA, g_szUnknownData, ARRAYSIZE(g_szUnknownData));
}       

CControlFolder::~CControlFolder()
{
    Assert(m_cRef == 0);                 // should always have zero
    DebugMsg(DM_TRACE, TEXT("cf - ~CControlFolder() called."));

    if (m_pidl)
        ILFree(m_pidl);

    DllRelease();
}    

STDAPI ControlFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;                     // null the out param

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    CControlFolder *pCFolder = new CControlFolder;
    if (!pCFolder)
        return E_OUTOFMEMORY;

    HRESULT hr = pCFolder->QueryInterface(riid, ppvOut);
    pCFolder->Release();

    return hr;
}

HRESULT CControlFolder::QueryInterface(REFIID iid, void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("cf - QueryInterface() called."));
    
    if ((iid == IID_IUnknown) || (iid == IID_IShellFolder))
    {
        *ppv = (void *)(IShellFolder*)this;
    }
    else if ((iid == IID_IPersistFolder) || (iid == IID_IPersist)) 
    {
        *ppv = (void *)(IPersistFolder*)this;
    }
    else if (iid == IID_IPersistFolder2)
    {
        *ppv = (void *)(IPersistFolder2*)this;
    }
    else if (iid == IID_IContextMenu)
    {
        *ppv = (void *)(IContextMenu*)this;
    }
    else if (iid == IID_IShellView)
    {
        // this is a total hack... return our view object from this folder
        //
        // the desktop.ini file for "Temporary Internet Files" has UICLSID={guid of this object}
        // this lets us implment only ths IShellView for this folder, leaving the IShellFolder
        // to the default file system. this enables operations on the pidls that are stored in
        // this folder that would otherwise faile since our IShellFolder is not as complete
        // as the default (this is the same thing the font folder does).
        //
        // to support this with defview we would either have to do a complete wrapper object
        // for the view implemenation, or add this hack that hands out the view object, this
        // assumes we know the order of calls that the shell makes to create this object
        // and get the IShellView implementation
        // 
        return ControlFolderView_CreateInstance(this, m_pidl, ppv);
    }
    else
    {
        *ppv = NULL;     // null the out param
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CControlFolder::AddRef()
{
    return ++m_cRef;
}

ULONG CControlFolder::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}

HRESULT CControlFolder::ParseDisplayName(
                                    HWND hwndOwner, 
                                    LPBC pbcReserved,
                                    LPOLESTR lpszDisplayName, 
                                    ULONG *pchEaten,
                                    LPITEMIDLIST *ppidl, 
                                    ULONG *pdwAttributes)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - ParseDisplayName() called."));
    *ppidl = NULL;              // null the out param
    return E_FAIL;
}

HRESULT CControlFolder::EnumObjects(
                               HWND hwndOwner, 
                               DWORD grfFlags,
                               LPENUMIDLIST *ppenumIDList)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - EnumObjects() called."));

    // Cannot filter on grfFlags yet - Corel Gallery expects to receive
    // an empty enumerator.

    return CControlFolderEnum_CreateInstance(m_pidl, grfFlags, ppenumIDList);
}

HRESULT CControlFolder::BindToObject(
                                LPCITEMIDLIST pidl, 
                                LPBC pbcReserved,
                                REFIID riid, 
                                void **ppvOut)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - BindToObject() called."));
    *ppvOut = NULL;         // null the out param
    return E_FAIL;
}

HRESULT CControlFolder::BindToStorage(
                                   LPCITEMIDLIST pidl, 
                                   LPBC pbcReserved,
                                   REFIID riid, 
                                   void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - BindToStorage() called."));
    *ppv = NULL;         // null the out param
    return E_NOTIMPL;
}

HRESULT CControlFolder::CompareIDs(
                              LPARAM lParam, 
                              LPCITEMIDLIST pidl1, 
                              LPCITEMIDLIST pidl2)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - CompareIDs() called."));

    int iRet;
    LPCONTROLPIDL pcpidl1 = (LPCONTROLPIDL)pidl1;
    LPCONTROLPIDL pcpidl2 = (LPCONTROLPIDL)pidl2;
    LPCSTR lpszStr[2] = {NULL, NULL};

    if (pcpidl1 == NULL || pcpidl2 == NULL)
        return E_INVALIDARG;
        
    switch (lParam) {
    case SI_CONTROL:
        iRet = lstrcmpi(
                 GetStringInfo(pcpidl1, SI_CONTROL),      
                 GetStringInfo(pcpidl2, SI_CONTROL));
        break;

    case SI_VERSION:
        lpszStr[0] = GetStringInfo(pcpidl1, SI_VERSION);
        lpszStr[1] = GetStringInfo(pcpidl2, SI_VERSION);
        if (lstrcmp(lpszStr[0], g_szUnknownData) == 0)
                        iRet = -1;
                else if (lstrcmp(lpszStr[1], g_szUnknownData) == 0)
                        iRet = 1;
        else
            iRet = CompareVersion(lpszStr[0], lpszStr[1]);
        break;

    case SI_CREATION:
    case SI_LASTACCESS:
        {
            FILETIME time[2];
            GetTimeInfo(pcpidl1, (int)lParam, &(time[0]));
            GetTimeInfo(pcpidl2, (int)lParam, &(time[1]));
            iRet = CompareFileTime(&(time[0]), &(time[1]));
        }
        break;

    case SI_STATUS:
        iRet = GetStatus(pcpidl1) - GetStatus(pcpidl2);
        break;
            
    case SI_TOTALSIZE:
        {
            DWORD dwSize1 = GetSizeSaved((LPCONTROLPIDL)pidl1); 
            DWORD dwSize2 = GetSizeSaved((LPCONTROLPIDL)pidl2);
            iRet = (dwSize1 == dwSize2 ? 0 : (dwSize1 > dwSize2 ? 1 : -1));
        }
        break;

    default:
        iRet = -1;
    }

    return ResultFromShort((SHORT)iRet);
}

HRESULT CControlFolder::CreateViewObject(
                                    HWND hwndOwner, 
                                    REFIID riid, 
                                    void **ppvOut)
{
    HRESULT hres;

    DebugMsg(DM_TRACE, TEXT("cf - sf - CreateViewObject() called."));

    if (riid == IID_IShellView)
    {
        hres = ControlFolderView_CreateInstance(this, m_pidl, ppvOut);
    }
    else if (riid == IID_IContextMenu)
    {
        hres = ControlFolder_CreateInstance(NULL, riid, ppvOut);
    }
    else
    {
        *ppvOut = NULL;         // null the out param
        hres = E_NOINTERFACE;
    }
    
    return hres;    
}

HRESULT CControlFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    // Should we initialize this for each item in here?  In other words,
    // if cidl > 1, then we should initialize each entry in the prgInOut array

    Assert(cidl == 1);
    
    *prgfInOut = SFGAO_CANCOPY | SFGAO_HASPROPSHEET | SFGAO_CANMOVE | SFGAO_CANDELETE;
    return NOERROR;
}

HRESULT CControlFolder::GetUIObjectOf(
                                 HWND hwndOwner, 
                                 UINT cidl, 
                                 LPCITEMIDLIST *apidl,
                                 REFIID riid, 
                                 UINT *prgfInOut, 
                                 void **ppvOut)
{
    HRESULT hres;

    if ((riid == IID_IDataObject) || 
        (riid == IID_IExtractIcon) || 
        (riid == IID_IContextMenu))
    {
       hres = CControlItem_CreateInstance(this, cidl, apidl, riid, ppvOut);
    }
    else
    {
        *ppvOut = NULL;         // null the out param
        hres = E_FAIL;
    }
    return hres;    
}

HRESULT CControlFolder::GetDisplayNameOf(
                                    LPCITEMIDLIST pidl, 
                                    DWORD uFlags, 
                                    LPSTRRET lpName)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - GetDisplayNameOf() called."));

    if (pidl)
    {
        lpName->uType = STRRET_CSTR;

        // for the history, we'll use the title if we have one, otherwise we'll use
        // the url filename.
        if (uFlags & SHGDN_FORPARSING)
            lstrcpyn(
                 lpName->cStr, 
                 GetStringInfo((LPCONTROLPIDL)pidl, SI_LOCATION), 
                 ARRAYSIZE(lpName->cStr));
        else
            lstrcpyn(
                 lpName->cStr, 
                 GetStringInfo((LPCONTROLPIDL)pidl, SI_CONTROL), 
                 ARRAYSIZE(lpName->cStr));

        return NOERROR;    
    }
    else
    {
        return E_INVALIDARG;
    }
}

HRESULT CControlFolder::SetNameOf(
                             HWND hwndOwner, 
                             LPCITEMIDLIST pidl,
                             LPCOLESTR lpszName, 
                             DWORD uFlags, 
                             LPITEMIDLIST *ppidlOut)
{
    DebugMsg(DM_TRACE, TEXT("cf - sf - SetNameOf() called."));
    
    *ppidlOut = NULL;               // null the out param
    return E_FAIL;    
}

///////////////////////////////////////////////////////////////////////////////
// Helper functions

int CompareVersion(LPCTSTR lpszVersion1, LPCTSTR lpszVersion2)
{
    LPCTSTR pszVerNum[2] = {lpszVersion1, lpszVersion2};
        int nVerNum[2];
        int nResult = 0;

        while (nResult == 0 && *(pszVerNum[0]) != '\0' && *(pszVerNum[1]) != '\0')
        {
                nVerNum[0] = StrToInt(pszVerNum[0]++);
                nVerNum[1] = StrToInt(pszVerNum[1]++);
                nResult = ((nVerNum[0] < nVerNum[1]) ? 
                                        (-1) :
                                    (nVerNum[0] > nVerNum[1] ? 1 : 0));
        }

        return nResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\general.cpp ===
#include "general.h"
#include "parseinf.h"

#include <mluisupp.h>

///////////////////////////////////////////////////////////////////////////////
// For retriving data from a CONTROLDATA struct

UINT GetTotalNumOfFiles(LPCONTROLPIDL lpcpidl)
{
    return (lpcpidl != NULL ? lpcpidl->ci.cTotalFiles : 0);
}

DWORD GetSizeSaved(LPCONTROLPIDL lpcpidl)
{
    return (lpcpidl != NULL ? lpcpidl->ci.dwTotalSizeSaved : 0);
}

BOOL GetSizeSaved(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf)
{
    Assert(pcpidl != NULL);
    Assert(lpszBuf != NULL);
    if (pcpidl == NULL || lpszBuf == NULL)
        return FALSE;

    DWORD dwTotal = GetSizeSaved(pcpidl);
    if (dwTotal > 0)
    {
        TCHAR szSize[20];
        TCHAR szBuf[MAX_KILOBYTE_ABBREV_LEN + 1];

        dwTotal = (dwTotal < 1024 ? 1024 : dwTotal);
        wsprintf(szSize, "%d", (dwTotal / 1024));

        // insert commas to separate groups of digits
        int nLen = lstrlen(szSize);
        int i = 0, j = (nLen <= 3 ? nLen : (nLen % 3));
        TCHAR *pCh = szSize + j;
        for (; i < j; i++)
            lpszBuf[i] = szSize[i];
        for (; *pCh != '\0'; i++, pCh++)
        {
            if (((pCh - szSize) % 3 == j) && (i > 0))
                lpszBuf[i++] = ',';
            lpszBuf[i] = *pCh;
        }
        lpszBuf[i] = '\0';

        MLLoadString(IDS_KILOBYTE_ABBREV, szBuf, MAX_KILOBYTE_ABBREV_LEN);
        lstrcat(lpszBuf, szBuf);
    }
    else
    {
        lstrcpy(lpszBuf, g_szUnknownData);
    }

    return TRUE;
}

UINT GetStatus(LPCONTROLPIDL pcpidl)
{
    return (pcpidl != NULL ? pcpidl->ci.dwStatus : STATUS_CTRL_UNKNOWN);
}

BOOL GetStatus(LPCONTROLPIDL pcpidl, LPTSTR lpszBuf, int nBufSize)
{
    Assert(pcpidl != NULL);
    Assert(lpszBuf != NULL);
    if (pcpidl == NULL || lpszBuf == NULL)
        return FALSE;

    switch (GetStatus(pcpidl))
    {
    case STATUS_CTRL_UNKNOWN:
        MLLoadString(IDS_STATUS_UNKNOWN, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_INSTALLED:
        MLLoadString(IDS_STATUS_INSTALLED, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_SHARED:
        MLLoadString(IDS_STATUS_SHARED, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_DAMAGED:
        MLLoadString(IDS_STATUS_DAMAGED, lpszBuf, nBufSize);
        break;
    case STATUS_CTRL_UNPLUGGED:
        MLLoadString(IDS_STATUS_UNPLUGGED, lpszBuf, nBufSize);
        break;
    default:
        lstrcpy(lpszBuf, g_szUnknownData);
    }

    return TRUE;
}

BOOL GetTimeInfo(LPCONTROLPIDL lpcpidl, int nFlag, FILETIME* lpTime)
{
    Assert(lpcpidl != NULL && lpTime != NULL);

    if (lpcpidl == NULL || lpTime == NULL)
        return FALSE;

    BOOL fResult = TRUE;

    switch (nFlag)
    {
    case SI_CREATION:
        *lpTime = lpcpidl->ci.timeCreation;
        break;

    case SI_LASTACCESS:
        *lpTime = lpcpidl->ci.timeLastAccessed;
        break;

    default:
        lpTime->dwLowDateTime = lpTime->dwLowDateTime = 0;
        fResult = FALSE;
    }

    return fResult;
}

LPCTSTR GetStringInfo(LPCONTROLPIDL lpcpidl, int nFlag)
{
    switch (nFlag)
    {
    case SI_CONTROL:
        return (lpcpidl != NULL ? lpcpidl->ci.szName : NULL);
    case SI_LOCATION:
        return (lpcpidl != NULL ? lpcpidl->ci.szFile : NULL);
    case SI_VERSION:
        return (lpcpidl != NULL ? lpcpidl->ci.szVersion : NULL);
    case SI_CLSID:
        return (lpcpidl != NULL ? lpcpidl->ci.szCLSID : NULL);
    case SI_CREATION:
        return (lpcpidl != NULL ? lpcpidl->ci.szCreation : NULL);
    case SI_LASTACCESS:
        return (lpcpidl != NULL ? lpcpidl->ci.szLastAccess : NULL);
    case SI_TYPELIBID:
        return (lpcpidl != NULL ? lpcpidl->ci.szTypeLibID : NULL);
    case SI_CODEBASE:
        return (lpcpidl != NULL ? lpcpidl->ci.szCodeBase : NULL);

    }

    return NULL;
}

BOOL GetDependentFile(
                  LPCONTROLPIDL lpcpidl, 
                  UINT iFile, 
                  LPTSTR lpszFile, 
                  DWORD *pdwSize)
{
    if (lpszFile == NULL || 
        pdwSize == NULL ||
        iFile >= GetTotalNumOfFiles(lpcpidl))
    {
        return FALSE;
    }

    DEPENDENTFILEINFO UNALIGNED *pInfo = &(lpcpidl->ci.dependentFile);
    lstrcpy(lpszFile, (pInfo + iFile)->szFile);
    *pdwSize = (pInfo + iFile)->dwSize;

    return TRUE;
}

void GetContentBools( LPCONTROLPIDL lpcpidl, BOOL *pbHasActiveX, BOOL *pbHasJava )
{
    if ( lpcpidl != NULL )
    {
        *pbHasActiveX = lpcpidl->ci.dwHasActiveX != 0;
        *pbHasJava = lpcpidl->ci.dwHasJava != 0;
    }
    else
    {
        *pbHasActiveX = *pbHasJava = FALSE;
    }
}

///////////////////////////////////////////////////////////////////////////////
// Other helper functions

void GenerateEvent(
              LONG lEventId, 
              LPITEMIDLIST pidlFolder, 
              LPITEMIDLIST pidlIn, 
              LPITEMIDLIST pidlNewIn)
{
    LPITEMIDLIST pidl = ILCombine(pidlFolder, pidlIn);
    if (pidl)
    {
        if (pidlNewIn)
        {
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                ILFree(pidlNew);
            }
        }
        else
        {
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }
        SHChangeNotifyHandleEvents();
        ILFree(pidl);
    }
}

HICON GetDefaultOCIcon(LPCONTROLPIDL lpcpidl)
{
    DWORD idIcon = IDI_DEFAULTOCXICON;

    if ( lpcpidl->ci.dwIsDistUnit )
    {
        if ( lpcpidl->ci.dwHasJava )
        {
            if ( lpcpidl->ci.dwHasActiveX )
                idIcon = IDI_DEFAULTMIXEDICON;
            else
                idIcon = IDI_DEFAULTJAVAICON;
        }
    }

    return LoadIcon(g_hInst, MAKEINTRESOURCE(idIcon));
}



HCURSOR StartWaitCur()
{
    HCURSOR hCur = LoadCursor(NULL, IDC_WAIT);
    return (hCur != NULL ? SetCursor(hCur) : NULL);
}

void EndWaitCur(HCURSOR hCurOld)
{
    if (hCurOld != NULL)
        SetCursor(hCurOld);
}


// The place to get the # of days before a control becomes expired.
const LPCTSTR g_lpszKeyExpire = TEXT("SOFTWARE\\Microsoft\\Windows"
    "\\CurrentVersion\\Internet Settings\\ActiveX Cache\\Expire");
const LPCTSTR g_szValueExpire = TEXT("DaysBeforeExpire");
const LPCTSTR g_szValueAutoExpire = TEXT("DaysBeforeAutoExpire");
ULONG g_nDaysGeneral = 0;
ULONG g_nDaysAuto = 0;

void GetDaysBeforeExpire(ULONG *pnDays, BOOL fGeneral)
{
    HKEY  hkey;
    DWORD dwSize  = sizeof(ULONG);
    LONG  lResult;

    ASSERT(pnDays != NULL);

    if ( fGeneral && g_nDaysGeneral )
    {
        *pnDays = g_nDaysGeneral;
        return;
    }
    else if ( !fGeneral && g_nDaysAuto )
    {
        *pnDays = g_nDaysAuto;
        return;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_lpszKeyExpire, 0, KEY_READ,
        &hkey);
    if (lResult == ERROR_SUCCESS) {
        lResult = RegQueryValueEx(hkey, (fGeneral ? g_szValueExpire : g_szValueAutoExpire), NULL, NULL,
            (LPBYTE)pnDays, &dwSize);
        RegCloseKey(hkey);
    }
    if (lResult != ERROR_SUCCESS)
        *pnDays = (fGeneral ? DEFAULT_DAYS_BEFORE_EXPIRE : DEFAULT_DAYS_BEFORE_AUTOEXPIRE);

    if ( fGeneral )
        g_nDaysGeneral = *pnDays;
    else
        g_nDaysAuto = *pnDays;
}

void GetDaysBeforeExpireGeneral(ULONG *pnDays)
{
    GetDaysBeforeExpire(pnDays, TRUE);
}

void GetDaysBeforeExpireAuto(ULONG *pnDays)
{
    GetDaysBeforeExpire(pnDays, FALSE);
}

HRESULT WINAPI RemoveControlByHandle2(
                         HANDLE hControlHandle,
                         BOOL bForceRemove, /* = FALSE */
                         BOOL bSilent)
{
    CCacheItem *pci = (CCacheItem *)hControlHandle;
    CoFreeUnusedLibraries();
    return pci->RemoveFiles( pci->m_szTypeLibID, bForceRemove, pci->ItemType() == CCacheDistUnit::s_dwType, bSilent );
}

HRESULT WINAPI RemoveControlByName2(
                         LPCTSTR lpszFile,
                         LPCTSTR lpszCLSID,
                         LPCTSTR lpszTypeLibID,
                         BOOL bForceRemove, /* = FALSE */
                         DWORD dwIsDistUnit, /* = FALSE */
                         BOOL bSilent)
{
    if (lpszFile == NULL || lpszCLSID == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    CoFreeUnusedLibraries();

    HRESULT hr = S_OK;
    CParseInf parseInf;

    if (!dwIsDistUnit)
    {
        hr = parseInf.DoParse(lpszFile, lpszCLSID);
    }
    else
    {
        hr = parseInf.DoParseDU(lpszFile, lpszCLSID);
    }
    if (SUCCEEDED(hr))
    {
        hr = parseInf.RemoveFiles(lpszTypeLibID, bForceRemove, dwIsDistUnit, bSilent);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\filenode.h ===
///////////////////////////////////////////////////////////////////////////////
// Declaration of class CFileNode

#ifndef __FILE_NODE__
#define __FILE_NODE__

#include "utils.h"

class CPNode
{
// Construction and Destruction
public:
    CPNode(LPCTSTR szName );
    virtual ~CPNode();
// Data members
protected:
    TCHAR   m_szName[MAX_PATH];
    TCHAR   m_szPath[MAX_PATH];
    BOOL    m_bRemovable;
    CPNode  *m_pNext;
// Operations
public:
    HRESULT Insert(CPNode* pNewNode);
    CPNode* GetNext() const;
    HRESULT SetStr( LPTSTR lpszMember, LPCTSTR lpszNew);
    HRESULT SetName(LPCTSTR lpszName) { return SetStr( m_szName, lpszName ); };
    LPCTSTR GetName() const;
    HRESULT SetPath(LPCTSTR lpszPath)  { return SetStr( m_szPath, lpszPath ); };
    LPCTSTR GetPath() const;
    void SetRemovable( BOOL bRemovable ) { m_bRemovable = bRemovable; };
    BOOL GetRemovable(void) { return m_bRemovable; };
};

class CPackageNode : public CPNode
{
// Construction and Destruction
public:
    CPackageNode(LPCTSTR szName, LPCTSTR szNamespace = NULL, LPCTSTR szPath = NULL);
    virtual ~CPackageNode();
// Data members
protected:
    TCHAR m_szNamespace[MAX_PATH];
    BOOL  m_fIsSystemClass;
// Operations
public:
    CPackageNode* GetNextPackageNode() const { return (CPackageNode *)m_pNext; };
    HRESULT SetNamespace(LPCTSTR lpszNamespace)  { return SetStr( m_szNamespace, lpszNamespace ); };
    LPCTSTR GetNamespace() const;
    HRESULT SetIsSystemClass(BOOL fIsSystemClass) { m_fIsSystemClass = fIsSystemClass; return S_OK; };
    BOOL GetIsSystemClass() { return m_fIsSystemClass; };
};

class CFileNode : public CPNode
{
// Construction and Destruction
public:
    CFileNode(LPCTSTR szName, LPCTSTR szSection, LPCTSTR szPath = NULL);
    virtual ~CFileNode();
// Data members
protected:
    TCHAR m_szSection[MAX_PATH];
// Operations
public:
    CFileNode* GetNextFileNode() const { return (CFileNode *)m_pNext; };
    HRESULT SetSection(LPCTSTR lpszSection)  { return SetStr( m_szSection, lpszSection ); };
    LPCTSTR GetSection() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\init.h ===
#ifndef __INIT__
#define __INIT__

#define CONST_VTABLE
#ifndef STRICT
#define STRICT
#endif
#ifndef WINVER
#define WINVER 0x0400
#define _WIN32_WINDOWS 0x0400
#endif

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <shlwapi.h>
#include <shlobj.h>         // in \sdk\inc
#include <shellapi.h>

#include <crtfree.h>        // don't use CRT libs
#include <ccstock.h>        // in ccshell\inc
#include <shsemip.h>        // in ccshell\inc
#include <shellp.h>             // in ccshell\inc
#include <debug.h>              // in ccshell\inc
#include <shguidp.h>        // in ccshell\inc
#include <advpub.h>

#ifdef __cplusplus
extern "C" {
#endif
    
extern HINSTANCE g_hInst;
extern BOOL      g_fAllAccess;
extern const CLSID CLSID_ControlFolder;
extern const CLSID CLSID_EmptyControlVolumeCache;
extern TCHAR g_szUnknownData[64];

#ifdef __cplusplus
};
#endif


STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();

STDAPI ControlFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv); 
STDAPI EmptyControl_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\global.h ===
// New default name for ActiveX cache folder!
#define REG_OCX_CACHE_DIR  TEXT("Downloaded Program Files")
#define REG_OCX_OLD_CACHE_DIR  TEXT("Occache")
#define REG_OCX_CACHE_VALUE_NAME TEXT("ActiveXCache")
#define REG_OCX_CACHE_SUBKEY TEXT("ActiveX Cache")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\occache.inc ===
CCSHELL_DIR = $(PROJECT_ROOT)
!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\init.c ===
#include "init.h"
#include "global.h"
#include <shlwapi.h> // for DllInstall prototype

#define MLUI_INIT
#include <mluisupp.h>

extern HRESULT CanonicalizeModuleUsage(void);

// {88C6C381-2E85-11d0-94DE-444553540000}
const GUID CLSID_ControlFolder = {0x88c6c381, 0x2e85, 0x11d0, 0x94, 0xde, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0};
#define STRING_CLSID_CONTROLFOLDER TEXT("{88C6C381-2E85-11d0-94DE-444553540000}")

// global variables
HINSTANCE   g_hInst = NULL;
LONG        g_cRefDll = 0;
BOOL        g_fAllAccess = FALSE;   // we'll set to true if we can open our keys with KEY_ALL_ACCESS

#define GUID_STR_LEN    40
#define REG_PATH_IE_SETTINGS  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REG_PATH_IE_CACHE_LIST  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache")
#define REG_ACTIVEX_CACHE     TEXT("ActiveXCache")
#define DEFAULT_CACHE_DIRECTORY  TEXT("Occache")

HRESULT CreateShellFolderPath(LPCTSTR pszPath, LPCTSTR pszGUID)
{
    if (!PathFileExists(pszPath))
        CreateDirectory(pszPath, NULL);

    // Mark the folder as a system directory
    if (SetFileAttributes(pszPath, FILE_ATTRIBUTE_SYSTEM))
    {
        TCHAR szDesktopIni[MAX_PATH];
        // Write in the desktop.ini the cache folder class ID
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);

        // (First, flush the cache to make sure the desktop.ini
        // file is really created.)
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID"), pszGUID, szDesktopIni);
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);

        // Hide the desktop.ini since the shell does not selectively
        // hide it.
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN);

        return NOERROR;
    }
    else
    {
        DebugMsg(DM_TRACE, "Cannot make %s a system folder", pszPath);
        return E_FAIL;
    }
}

void CleanupShellFolder(LPCTSTR pszPath)
{
    if (PathFileExists(pszPath))
    {
        TCHAR szDesktopIni[MAX_PATH];

        // make the history a normal folder
        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
        {
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
            // Get the ini file cache to let go of this file
            WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
            DeleteFile(szDesktopIni);
        }

        // remove the history directory
        // RemoveDirectory(pszPath); // don't do this, we haven't uninstalled all the controls therein! 
    }
}

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);
        if (pfnri)
        {
            hr = pfnri(g_hInst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


HRESULT GetControlFolderPath(LPTSTR szCacheDir, DWORD cchBuffer )
{
    /*
    LONG lResult = ERROR_SUCCESS;
    HKEY hKeyIntSetting = NULL;

    Assert(lpszDir != NULL);
    if (lpszDir == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_PATH_IE_SETTINGS,
                        0x0,
                        KEY_READ,
                        &hKeyIntSetting)) == ERROR_SUCCESS)
    {
        ULONG ulSize = ulSizeBuf;
        lResult = RegQueryValueEx(
                            hKeyIntSetting,
                            REG_ACTIVEX_CACHE,
                            NULL,
                            NULL,
                            (unsigned char*)lpszDir,
                            &ulSize);
        RegCloseKey(hKeyIntSetting);
    }

    return (lResult == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(lResult));
    */
       // Compose the default path.
    int len;

    GetWindowsDirectory(szCacheDir, cchBuffer);
    len = lstrlen(szCacheDir);
    if ( len && (szCacheDir[len-1] != '\\'))
        lstrcat(szCacheDir, "\\");
    lstrcat(szCacheDir, REG_OCX_CACHE_DIR);

    return ((len != 0)? S_OK : E_FAIL);
}


STDAPI AddCacheToRegPathList( HKEY hkeyParent, LPCTSTR szCacheDir, DWORD cchCacheDir )
{
    HRESULT hr = E_FAIL;
    LONG    lResult;

    // Check to see if new path already exists in the list of paths under
    // HKLM\...\Windows\CurrentVersion\Internet Settings\ActiveX Cache\Paths.
    // If not, add it.
    HKEY  hkeyCacheList = NULL;

    lResult = RegCreateKey( hkeyParent, REG_OCX_CACHE_SUBKEY, &hkeyCacheList );
    if (lResult == ERROR_SUCCESS) {
        DWORD dwIndex;
        TCHAR szName[MAX_PATH];
        DWORD cbName;
        TCHAR szValue[MAX_PATH];
        DWORD cbValue;
        LONG  lValueIndex = -1;
        BOOL  fFoundValue = FALSE;

        // iterate through the values of the cache subkey of the internet settings key.
        // The values have names which are simple, positive itegers. The idea here is
        // to have collection of values like so:
        // Name         Value                                   Source
        // "1"          "C:\WINNT\OC Cache"                     IE3 legacy controls
        // "2"          "C:\WINNT\Downloaded ActiveXControls"   IE4 PR-1 legacy controls
        // "3"          "C:\WINNT\Downloaded Components"        IE4 controls.
        for ( dwIndex = 0, cbName = sizeof(szName), cbValue = sizeof(szValue); 
              lResult == ERROR_SUCCESS; 
              dwIndex++, cbName = sizeof(szName), cbValue = sizeof(szValue) )
        {
            lResult = RegEnumValue( hkeyCacheList, dwIndex,
                                    szName, &cbName, 
                                    NULL, NULL,
                                    (LPBYTE)szValue, &cbValue );

            if (lResult == ERROR_SUCCESS)
            {
                // for find new unique value name later.
                lValueIndex = max(lValueIndex, StrToInt(szName));

                if ( !fFoundValue )
                    fFoundValue = (lstrcmpi(szCacheDir, szValue) == 0);
                
                // Make sure that we're registered for all the (existing) old cache directories
                if ( !fFoundValue && PathFileExists(szValue) ) {
                    CreateShellFolderPath( szValue, STRING_CLSID_CONTROLFOLDER );
                }
            }
        }

 
        if (lResult == ERROR_NO_MORE_ITEMS)
        {   // we successfully inspected all the values
            if ( !fFoundValue )
            {
                TCHAR szSubKey[20]; // don't foresee  moure than a few billion caches
                // add new path to list of paths
                wsprintf(szSubKey, "%i", ++lValueIndex);
                lResult = RegSetValueEx( hkeyCacheList, szSubKey, 0, REG_SZ, 
                                         (LPBYTE)szCacheDir, cchCacheDir + 1);
                if ( lResult == ERROR_SUCCESS )
                    hr = S_OK;
                else 
                    hr = HRESULT_FROM_WIN32(lResult);
            } else
                hr = S_OK; // it's already there
        } else
            hr = HRESULT_FROM_WIN32(lResult);

        RegCloseKey( hkeyCacheList );
    } else
        hr = HRESULT_FROM_WIN32(lResult);

    return hr;
}

STDAPI SetCacheRegEntries( LPCTSTR szCacheDir )
{
    HRESULT hr = E_FAIL;
    LONG    lResult;
    HKEY    hkeyIS;    // reg key for internet settings;

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            REG_PATH_IE_SETTINGS,
                            0x0,
                            KEY_ALL_ACCESS,
                            &hkeyIS );
    if ( lResult == ERROR_SUCCESS)
    {
        // now the key is ours, oh, yes... it is ours...
        // set the value of the internet settings key used by Code Download.
        int cchCacheDir = lstrlen(szCacheDir);
        TCHAR szCacheDirOld[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD cbOldCache = MAX_PATH;

        // Don't fail if we can't quite hook up with legacy caches
        hr = S_OK;

        // Add our old cache path, if any, to the cache path list if it differs from our new cache.
        lResult = RegQueryValueEx( hkeyIS, REG_OCX_CACHE_VALUE_NAME, 0, &dwType, (LPBYTE)szCacheDirOld, &cbOldCache );
        if ( lResult == ERROR_SUCCESS && dwType == REG_SZ &&
             lstrcmpi( szCacheDirOld, szCacheDir ) != 0 )
            AddCacheToRegPathList( hkeyIS, szCacheDirOld, cbOldCache - 1 );

                // Under NT, IE3 might not have been able to write the old cache path, so we'll cobble one up
                // and add it if that dir is present.
                if ( SUCCEEDED(GetWindowsDirectory( szCacheDirOld, MAX_PATH )) )
                {
            cbOldCache = lstrlen( szCacheDirOld ); 
            if ( cbOldCache && (szCacheDirOld[cbOldCache-1] != '\\'))
                lstrcat(szCacheDirOld, "\\");
                        cbOldCache = lstrlen(lstrcat( szCacheDirOld, REG_OCX_OLD_CACHE_DIR ));         

                        if (PathFileExists(szCacheDirOld))
                        {
                                // Let's not fail if this doesn't work
                                AddCacheToRegPathList( hkeyIS, szCacheDirOld, cbOldCache );
                CreateShellFolderPath( szCacheDirOld, STRING_CLSID_CONTROLFOLDER );
                        }
                }
         
        if ( SUCCEEDED(hr) )
        {
            lResult = RegSetValueEx( hkeyIS, REG_OCX_CACHE_VALUE_NAME, 0, REG_SZ,
                                     (LPBYTE)szCacheDir, cchCacheDir + 1 ); // need '\0'

            if ( lResult == ERROR_SUCCESS )
            {
                // add the new (?) path to the collection of valid paths which are the
                // values for the cache subkey.
                hr = AddCacheToRegPathList( hkeyIS, szCacheDir, cchCacheDir );
            } else
                hr = HRESULT_FROM_WIN32(lResult);
        }

        RegCloseKey( hkeyIS );

    } else
        hr = HRESULT_FROM_WIN32(lResult);
     
    return hr;
}

STDAPI InitCacheFolder(void)
{
    HRESULT hr = E_FAIL;
    TCHAR szCacheDir[MAX_PATH];

    // Compose the default path.
    GetControlFolderPath(szCacheDir, MAX_PATH);
   
    // Okay, now we know where we want to put things.
    // Create the directory, and/or claim it as our own
    hr  = CreateShellFolderPath( szCacheDir, STRING_CLSID_CONTROLFOLDER );
    if ( SUCCEEDED(hr) )
    {
        hr = SetCacheRegEntries( szCacheDir );
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    // Remove a bunch of stuff from the registry.
    //
    CallRegInstall("Unreg");

    return NOERROR;
}

STDAPI DllRegisterServer(void)
{
    //
    // Add a bunch of stuff to the registry.
    //
    if (FAILED(CallRegInstall("Reg")))
    {
        goto CleanUp;
    }

    return NOERROR;

CleanUp:        // cleanup stuff if any of our reg stuff fails

    DllUnregisterServer();
    return E_FAIL;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;

    if ( bInstall )
    {
        hr =InitCacheFolder();
        
        if ( SUCCEEDED(hr) )
            CanonicalizeModuleUsage();
    } 
    else
    {
        LONG  lResult;
        HKEY  hkeyCacheList;

        // Unhook occache as a shell extension for the cache folders.
        lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                REG_PATH_IE_CACHE_LIST,
                                0x0,
                                KEY_ALL_ACCESS,
                                &hkeyCacheList );

        if ( lResult == ERROR_SUCCESS ) {
            DWORD dwIndex;
            TCHAR szName[MAX_PATH];
            DWORD cbName;
            TCHAR szValue[MAX_PATH];
            DWORD cbValue;

            for ( dwIndex = 0, cbName = sizeof(szName), cbValue = sizeof(szValue); 
                  lResult == ERROR_SUCCESS; 
                  dwIndex++, cbName = sizeof(szName), cbValue = sizeof(szValue) )
            {
                lResult = RegEnumValue( hkeyCacheList, dwIndex,
                                        szName, &cbName, 
                                        NULL, NULL,
                                        (LPBYTE)szValue, &cbValue );

                if ( lResult == ERROR_SUCCESS && PathFileExists(szValue) )
                    CleanupShellFolder(szValue);
            }
            // We leave this key in place because it is the only record we have of the
            // cache folders and would be useful to future installations of IE
            RegCloseKey( hkeyCacheList );
        }
    }

    return hr;    
}

STDAPI_(BOOL) DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID dwReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        HKEY hkeyTest;

        g_hInst = hInst;
        DisableThreadLibraryCalls(g_hInst);

        MLLoadResources(g_hInst, TEXT("occachlc.dll"));
        
        // Test to see if we have permissions to modify HKLM subkeys.
        // We'll use this as an early test to see if we can remove controls.
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           REG_PATH_IE_SETTINGS,
                           0x0,
                           KEY_ALL_ACCESS,
                           &hkeyTest ) == ERROR_SUCCESS )
        {
            g_fAllAccess = TRUE;
            RegCloseKey( hkeyTest );
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        MLFreeResources(g_hInst);
    }
    return TRUE;
}

typedef struct {
    const IClassFactoryVtbl *cf;
    const CLSID *pclsid;
    HRESULT (STDMETHODCALLTYPE *pfnCreate)(IUnknown *, REFIID, void **);
} OBJ_ENTRY;

extern const IClassFactoryVtbl c_CFVtbl;        // forward

//
// we always do a linear search here so put your most often used things first
//
const OBJ_ENTRY c_clsmap[] = {
    { &c_CFVtbl, &CLSID_ControlFolder,             ControlFolder_CreateInstance },
    { &c_CFVtbl, &CLSID_EmptyControlVolumeCache,   EmptyControl_CreateInstance },
    // add more entries here
    { NULL, NULL, NULL }
};

// static class factory (no allocs!)

STDMETHODIMP CClassFactory_QueryInterface(IClassFactory *pcf, REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    DllAddRef();
    return NOERROR;
}

STDMETHODIMP_(ULONG) CClassFactory_AddRef(IClassFactory *pcf)
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory_Release(IClassFactory *pcf)
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory_CreateInstance(IClassFactory *pcf, IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
    OBJ_ENTRY *this = IToClass(OBJ_ENTRY, cf, pcf);
    return this->pfnCreate(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(IClassFactory *pcf, BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory_QueryInterface, CClassFactory_AddRef, CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        const OBJ_ENTRY *pcls;
        for (pcls = c_clsmap; pcls->pclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();    // Class Factory keeps dll in memory
                return NOERROR;
            }
        }
    }
    // failure
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\menu.cpp ===
#include "folder.h"
#include "utils.h"

#include <mluisupp.h>

///////////////////////////////////////////////////////////////////////////////
// IContextMenu methods

HRESULT CControlFolder::QueryContextMenu(
                                     HMENU hmenu, 
                                     UINT indexMenu, 
                                     UINT idCmdFirst,
                                     UINT idCmdLast,
                                     UINT uFlags)
{
    USHORT cItems = 0;

    DebugMsg(DM_TRACE, TEXT("cf - cm - QueryContextMenu() called."));
    if (uFlags == CMF_NORMAL)
    {
        HMENU hCtrlMenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_CONTROLFOLDER));
        if (hmenu)
        {
            MENUITEMINFO mii;
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID;
            mii.wID = SFVIDM_MENU_ARRANGE;
            SetMenuItemInfo(hCtrlMenu, 0, TRUE, &mii);
            cItems = (USHORT)MergeMenuHierarchy(hmenu, hCtrlMenu, idCmdFirst, idCmdLast);
            DestroyMenu(hCtrlMenu);
        }
    }
    SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);

    return ResultFromShort(cItems);    // number of menu items    
}

HRESULT CControlFolder::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    // We don't deal with the VERBONLY case
    DebugMsg(DM_TRACE, TEXT("cf - cm - InvokeCommand() called."));
    Assert((DWORD_PTR)(pici->lpVerb) <= 0xFFFF);
    
    int idCmd;
    if ((DWORD_PTR)(pici->lpVerb) > 0xFFFF)
        idCmd = -1;
    else
        idCmd = LOWORD(pici->lpVerb);
    
    return ControlFolderView_Command(pici->hwnd, idCmd);
}

HRESULT CControlFolder::GetCommandString(
                                     UINT_PTR idCmd, 
                                     UINT uFlags, 
                                     UINT *pwReserved,
                                     LPTSTR pszName, 
                                     UINT cchMax)
{
    HRESULT hres = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("cf - cm - GetCommandString() called."));

    if (uFlags == GCS_HELPTEXT)
    {
        MLLoadString((UINT) (idCmd + IDS_HELP_SORTBYNAME), pszName, cchMax);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\item.h ===
#ifndef __CONTROL_ITEM__
#define __CONTROL_ITEM__

#include "folder.h"
#include "cdlbsc.hpp"

class CControlItem : public IDataObject,
                     public IExtractIcon,
                     public IContextMenu
{
    // CControlItem interfaces
    friend HRESULT ControlFolderView_DidDragDrop(
                                            HWND hwnd, 
                                            IDataObject *pdo, 
                                            DWORD dwEffect);

public:
    CControlItem();
    HRESULT Initialize(
                   CControlFolder *pCFolder, 
                   UINT cidl, 
                   LPCITEMIDLIST *ppidl);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IContextMenu Methods
    STDMETHODIMP QueryContextMenu(
                            HMENU hmenu, 
                            UINT indexMenu, 
                            UINT idCmdFirst,
                            UINT idCmdLast, 
                            UINT uFlags);

    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);

    STDMETHODIMP GetCommandString(
                             UINT_PTR idCmd, 
                             UINT uType,
                             UINT *pwReserved,
                             LPTSTR pszName, 
                             UINT cchMax);

    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            LPDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);

    // IDataObject helper functions
    HRESULT CreatePrefDropEffect(STGMEDIUM *pSTM);
    HRESULT Remove(HWND hwnd);
/*
    HRESULT _CreateHDROP(STGMEDIUM *pmedium);
    HRESULT _CreateNameMap(STGMEDIUM *pmedium);
    HRESULT _CreateFileDescriptor(STGMEDIUM *pSTM);
    HRESULT _CreateFileContents(STGMEDIUM *pSTM, LONG lindex);
    HRESULT _CreateURL(STGMEDIUM *pSTM);
    HRESULT _CreatePrefDropEffect(STGMEDIUM *pSTM);
*/

    // IExtractIcon Methods
    STDMETHODIMP GetIconLocation(
                            UINT uFlags,
                            LPSTR szIconFile,
                            UINT cchMax,
                            int *piIndex,
                            UINT *pwFlags);
    STDMETHODIMP Extract(
                    LPCSTR pszFile,
                    UINT nIconIndex,
                    HICON *phiconLarge,
                    HICON *phiconSmall,
                    UINT nIconSize);

    // Support for our progress UI 
    static INT_PTR DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    // Misc helper function

    static BOOL IsGlobalOffline();

protected:

    ~CControlItem();

    HRESULT Update(LPCMINVOKECOMMANDINFO pici, LPCONTROLPIDL pcpidl);

    UINT                 m_cRef;            // reference count
    UINT                 m_cItems;          // number of items we represent
    CControlFolder*  m_pCFolder;    // back pointer to our shell folder
    LPCONTROLPIDL*       m_ppcei;           // variable size array of items
    LPCMINVOKECOMMANDINFO m_piciUpdate;
    LPCONTROLPIDL         m_pcpidlUpdate;
    CodeDownloadBSC      *m_pcdlbsc;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\parseinf.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Implementation of class CParseInf
//
// CParseInf is created to deal with parsing of an INF file.

#include <ole2.h>
#include "ParseInf.h"
#include "resource.h"
#include "init.h"
#include "global.h"
#include <shlwapi.h>
#include <initguid.h>
#include <pkgguid.h>
#include <cleanoc.h>        // for STATUS_CTRL values
#include <mluisupp.h>

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

static BOOL FGetCLSIDFile( LPTSTR szFile, LPCTSTR szCLSID )
{
    BOOL fGotIt = FALSE;
    HKEY hkeyClsid;
    TCHAR szT[MAX_PATH];
    TCHAR *szPath = CatPathStrN( szT, HKCR_CLSID, szCLSID, MAX_PATH );

    if ( RegOpenKeyEx( HKEY_CLASSES_ROOT, szPath, 0, KEY_READ, &hkeyClsid ) == ERROR_SUCCESS )
    {
        DWORD dw;
        LRESULT lResult;

        // Look for InprocServer[32] or LocalServer[32] key
        dw = MAX_PATH;
        lResult = RegQueryValue(hkeyClsid, INPROCSERVER32, szT, (PLONG)&dw);
        if (lResult != ERROR_SUCCESS)
        {
            dw = MAX_PATH;
            lResult = RegQueryValue(hkeyClsid, LOCALSERVER32, szT, (PLONG)&dw);
        }

        if (lResult != ERROR_SUCCESS)
        {
            dw = MAX_PATH;
            lResult = RegQueryValue(hkeyClsid, INPROCSERVERX86, szT, (PLONG)&dw);
        }

        if (lResult != ERROR_SUCCESS)
        {
            dw = MAX_PATH;
            lResult = RegQueryValue(hkeyClsid, LOCALSERVERX86, szT, (PLONG)&dw);
        }

        if ( lResult == ERROR_SUCCESS )
        {
            if ( OCCGetLongPathName( szFile, szT, MAX_PATH ) == 0 )
                lstrcpy( szFile, szT );
            fGotIt = TRUE;
        }
        
        RegCloseKey( hkeyClsid );
    }

    return fGotIt;
}

// constructor
CParseInf::CParseInf()
{
    m_pHeadFileList = NULL;
    m_pCurFileNode = NULL;
    m_pFileRetrievalPtr = NULL;
    m_pHeadPackageList = NULL;
    m_pCurPackageNode = NULL;
    m_pPackageRetrievalPtr = NULL;
    m_bIsDistUnit = FALSE;
    m_bHasActiveX = FALSE;
    m_bHasJava = FALSE;
    m_pijpm = NULL;
    m_bCoInit = FALSE;
    m_dwStatus = STATUS_CTRL_UNKNOWN;
    GetDaysBeforeExpireGeneral( &m_cExpireDays );
}

// destructor
CParseInf::~CParseInf()
{
    DestroyFileList();
    DestroyPackageList();

    if ( m_pijpm != NULL )
        m_pijpm->Release();

    if ( m_bCoInit )
        CoUninitialize();
}

// initialization
void CParseInf::Init()
{
    m_dwFileSizeSaved = 0;
    m_dwTotalFileSize = 0;
    m_nTotalFiles = 0;
    m_pHeadFileList = m_pCurFileNode = NULL;
    m_pHeadPackageList = m_pCurPackageNode = NULL;

    lstrcpyn(m_szInf, m_szFileName, ARRAYSIZE(m_szInf));
    TCHAR *pCh = ReverseStrchr(m_szInf, '.');
    if (pCh != NULL)
        *pCh = '\0';
    if ( lstrlen(m_szInf) + lstrlen(INF_EXTENSION) < ARRAYSIZE(m_szInf))
        lstrcat(m_szInf, INF_EXTENSION);
    else
        m_szInf[0] = 0; // if can't hold it, we can't hold it.
 }

// release memory used by a linked list of files
void CParseInf::DestroyFileList()
{
    if (m_pHeadFileList != NULL)
        delete m_pHeadFileList;
    m_pHeadFileList = m_pCurFileNode = NULL;
}

void CParseInf::DestroyPackageList()
{
    if (m_pHeadPackageList != NULL)
        delete m_pHeadPackageList;
    m_pHeadPackageList = m_pCurPackageNode = NULL;
}


// find inf from cache directory if one with the
// same name as the OCX is not found
HRESULT CParseInf::FindInf(LPTSTR szInf)
{
    HRESULT hr = S_OK;
    WIN32_FIND_DATA dataFile;
    HANDLE h = INVALID_HANDLE_VALUE;
    DWORD dwLen = 0;
    TCHAR szValueBuf[MAX_PATH];        
    TCHAR *szOcxFileName = ReverseStrchr(m_szFileName, '\\');
    int nCachePathLength = 0, i = 0;

    Assert(szOcxFileName != NULL);
    szOcxFileName += 1;
    Assert (szInf != NULL);
    if (szInf == NULL)
        goto ExitFindInf;

    // search for inf file in two directories.  First the dir where the
    // OCX is, then the OC cache dir.
    for (i = 0; dwLen == 0 && i < 2; i++)
    {
        if (i == 0)
            hr = GetDirectory(GD_EXTRACTDIR, szInf, ARRAYSIZE(szInf), m_szFileName);
        else
        {
            TCHAR szTemp[MAX_PATH];
            hr = GetDirectory(GD_CACHEDIR, szTemp, ARRAYSIZE(szTemp));
            if (lstrcmpi(szTemp, szInf) == 0)
                continue;
            lstrcpy(szInf, szTemp);
        }

        if (FAILED(hr))
            goto ExitFindInf;

        lstrcat(szInf, TEXT("\\"));
        nCachePathLength = lstrlen(szInf);
        lstrcat(szInf, TEXT("*"));
        lstrcat(szInf, INF_EXTENSION);
        h = FindFirstFile(szInf, &dataFile);
        if (h == INVALID_HANDLE_VALUE)
        {
            goto ExitFindInf;
        }

        // find an inf file with a section in [Add.Code] dedicated
        // to the OCX file in question
        do {
            szInf[nCachePathLength] = '\0';
            lstrcat(szInf, (LPCTSTR)dataFile.cFileName);
            dwLen = GetPrivateProfileString(
                                    KEY_ADDCODE,
                                    szOcxFileName,
                                    DEFAULT_VALUE,
                                    szValueBuf,
                                    MAX_PATH,
                                    szInf);
        } while(dwLen == 0 && FindNextFile(h, &dataFile));
    }
    
    hr = (dwLen != 0 ? hr : S_FALSE);

ExitFindInf:    

    if (h != INVALID_HANDLE_VALUE)
        FindClose(h);

    if (hr != S_OK)
        szInf[0] = '\0';

    return hr;
}

// initiate parsing of INF file
// szCLSID -- address to a buffer storing CLSID of control
// szOCXFileName -- full path and name (ie. long file name) of OCX file
HRESULT CParseInf::DoParse(
                  LPCTSTR szOCXFileName, 
                  LPCTSTR szCLSID)
{
    Assert(szOCXFileName != NULL);
    Assert(szCLSID != NULL);

    HRESULT hr = S_OK;
    const TCHAR *pszPath = NULL;
    TCHAR szFileName[MAX_PATH];
    DWORD dwFileSize = 0;

    if ( FGetCLSIDFile( szFileName, szCLSID ) &&
         lstrcmpi( szFileName, szOCXFileName ) != 0 )
        m_dwStatus = STATUS_CTRL_UNPLUGGED;


    // If DoParse was called, we are assumed to be a legacy control and not
    // a distribution unit (subsequent call to DoParseDU will change the
    // status). This information is required for control removal purposes.

    m_bIsDistUnit = FALSE;
    m_bHasActiveX = TRUE;  // all legacy controls are ActiveX

    // initialization

    if ( OCCGetLongPathName(m_szFileName, szOCXFileName, MAX_PATH) == 0 )
        lstrcpyn( m_szFileName, szOCXFileName, MAX_PATH );

    lstrcpyn(m_szCLSID, szCLSID, MAX_CLSID_LEN);
    DestroyFileList();
    Init();

    BOOL bOCXRemovable = IsModuleRemovable(m_szFileName);

    // test INF file existance, if not, try to find one in OC cache dir.
    if (!FileExist(m_szInf))
    {
        if (!ReadInfFileNameFromRegistry(m_szCLSID, m_szInf, MAX_PATH))
        {
            FindInf(m_szInf);

            // record inf file name into the registry
            WriteInfFileNameToRegistry(
                               m_szCLSID, 
                               (m_szInf[0] == '\0' ? NULL : m_szInf));
        }
    }

    // enumerate files assocated with a particular OCX
    if (FAILED(hr = EnumSections()))
        goto ExitDoParse;

    // S_FALSE is returned when an ocx has no inf file
    if (hr == S_FALSE)
    {
        m_nTotalFiles = 1;
        if (FAILED(GetSizeOfFile(m_szFileName, &m_dwFileSizeSaved)))
        {
            m_dwFileSizeSaved = 0;
            m_dwTotalFileSize = 0;
        }
        else
        {
            m_dwTotalFileSize = m_dwFileSizeSaved;
        }
        hr = S_OK;
        if ( !PathFileExists( m_szFileName ) )
            m_dwStatus = STATUS_CTRL_DAMAGED;
        else
            m_dwStatus = STATUS_CTRL_INSTALLED;
        goto ExitDoParse;
    }

    // OCX has an corresponding INF file.
    // Loop through the list of assocated files to dig out info for each
    // from their corresponding section in the INF file
    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL;
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode(), hr = S_OK)
    {
        // if m_pCurFileNode->GetNextFileNode() == NULL => it's the inf file itself,
        // which does not need to be processed.
        if (m_pCurFileNode->GetNextFileNode() != NULL)
        {
            pszPath = m_pCurFileNode->GetPath();
            Assert(pszPath != NULL);
            if (pszPath == NULL)
            {
                hr = E_UNEXPECTED;
                goto ExitDoParse;
            }
            CatPathStrN( szFileName, pszPath, m_pCurFileNode->GetName(), ARRAYSIZE(szFileName));
        }
        else
        {
            lstrcpyn(szFileName, m_szInf, ARRAYSIZE(szFileName));
            pszPath = NULL;
        }

        // hr might either be S_OK or S_FALSE
        // S_OK means file can be removed as it has a SharedDlls count of 1
        // S_FALSE if the count is greater than 1

        // calculate total num of files and their sizes
        if (SUCCEEDED(hr = GetSizeOfFile(szFileName, &dwFileSize)))
        {
            if (pszPath == NULL ||
                IsModuleRemovable(szFileName) ||
                lstrcmpi(szFileName, m_szFileName) == 0)
            {
                m_dwFileSizeSaved += dwFileSize;
            }

            m_dwTotalFileSize += dwFileSize;
        } else
            m_dwStatus = STATUS_CTRL_DAMAGED; // failure to get size indicative of missing file.

        m_nTotalFiles += 1;
    }

    // if we didn't detect a problem, flag the control as installed.
    if ( m_dwStatus == STATUS_CTRL_UNKNOWN )
        m_dwStatus = STATUS_CTRL_INSTALLED;

ExitDoParse:
    return hr;
}

HRESULT CParseInf::BuildDUFileList( HKEY hKeyDU )
{
    HRESULT hr = S_OK;
    LRESULT lResult;
    HKEY    hkeyFiles;
    TCHAR   szDUFileName[MAX_PATH + 1];
    DWORD   dwStrSize = MAX_PATH;
    int     cFilesEnum = 0;

    lResult = RegOpenKeyEx(hKeyDU, REGSTR_DU_CONTAINS_FILES, 0,
                           KEY_READ, &hkeyFiles);

    if ( lResult != ERROR_SUCCESS ) // if no files, maybe there's Java
        return hr;

    while ((lResult = RegEnumValue(hkeyFiles, cFilesEnum++, szDUFileName,
                                   &dwStrSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
    {
        TCHAR szPath[MAX_PATH + 1];
        CFileNode *pFileNode;

        lstrcpyn(szPath, szDUFileName, MAX_PATH);
        TCHAR *szFName = ReverseStrchr(szPath, '\\');

        Assert(szFName != NULL);
        // long ago and far away, in the IE4, PP1-2 timeframe, there was a horrible
        // bug that corrupted these entries on Memphis and NT5. We suspect that GetLongPathName
        // was doing something wrong for code download, but repro scenarios were not
        // to be found. Anywho, the damaged registries are out there, so we need to
        // cope with them more gracefully than faulting at the *szFName = NULL;
        if ( szFName == NULL )
            continue;

        *szFName = NULL;
        szFName++;

        pFileNode = new CFileNode(szFName, "", szPath);
        if (pFileNode == NULL)
        {
            hr = E_OUTOFMEMORY;
            break; 
        }

        // create and add node to list
        if (m_pHeadFileList == NULL)
        {
            m_pHeadFileList = pFileNode;
            m_pCurFileNode = m_pHeadFileList;
        }
        else
        {
            hr = m_pCurFileNode->Insert(pFileNode);
            m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
        }
        dwStrSize = MAX_PATH;
    }

    RegCloseKey( hkeyFiles );

    return hr;
}

HRESULT CParseInf::BuildDUPackageList( HKEY hKeyDU )
{
    HRESULT hr = S_OK;
    LRESULT lResult;
    HKEY    hkeyJava;
    ICreateJavaPackageMgr *picjpm;


    DestroyPackageList();

    lResult = RegOpenKeyEx(hKeyDU, REGSTR_DU_CONTAINS_JAVA, 0,
                           KEY_READ, &hkeyJava);

    if ( lResult != ERROR_SUCCESS ) // it's OK if there's no Java
        return hr;

    if ( !m_bCoInit )
        m_bCoInit = SUCCEEDED(hr = CoInitialize(NULL));

    if ( m_bCoInit )
    {
        hr=CoCreateInstance(CLSID_JavaPackageManager,NULL,CLSCTX_INPROC_SERVER,
            IID_ICreateJavaPackageMgr,(LPVOID *) &picjpm);
        if (SUCCEEDED(hr))
        {
            hr = picjpm->GetPackageManager(&m_pijpm);
            picjpm->Release();
        }
    }

    if (FAILED(hr))
        return S_OK; // hr; // quietly fail until we're sure the JavaVM with package manager support is in the build.

    // list the packages under Contains/Java - these are in the gobal namespace
    hr = BuildNamespacePackageList(hkeyJava, "");

    // add packages for each namespace key under Contains\Java
    if ( SUCCEEDED(hr) )
    {
        DWORD   dwIndex;
        TCHAR   szNamespace[MAX_PATH + 1]; // 
        DWORD   dwStrSize;

        for ( dwIndex = 0, dwStrSize = MAX_PATH;
              RegEnumKey( hkeyJava, dwIndex, szNamespace, dwStrSize ) == ERROR_SUCCESS &&
                  SUCCEEDED(hr);
              dwIndex++, dwStrSize = MAX_PATH )
        {
            HKEY  hkeyNamespace;

            lResult = RegOpenKeyEx(hkeyJava, szNamespace, 0, KEY_READ, &hkeyNamespace);
            if ( lResult == ERROR_SUCCESS )
            {
                hr = BuildNamespacePackageList(hkeyNamespace, szNamespace );
                RegCloseKey( hkeyNamespace );
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lResult);
                break;
            }
        } 
        
    }

    RegCloseKey( hkeyJava );

    m_bHasJava = m_pHeadPackageList != NULL;

    return hr;
}

HRESULT CParseInf::BuildNamespacePackageList( HKEY hKeyNS, LPCTSTR szNamespace )
{
    HRESULT hr = S_OK;
    LRESULT lResult;
    int     cPackagesEnum = 0;
    TCHAR   szDUPackageName[MAX_PATH + 1];
    DWORD   dwStrSize = MAX_PATH;
    BOOL    fIsSystemClass = FALSE;

    while ((lResult = RegEnumValue(hKeyNS, cPackagesEnum++, szDUPackageName,
                                   &dwStrSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
    {
        IJavaPackage *pijp;

#ifndef UNICODE
        MAKE_WIDEPTR_FROMANSI(swzPackage, szDUPackageName );
        MAKE_WIDEPTR_FROMANSI(swzNamespace, szNamespace );
#else
        OLESTR swzPackage = szDUPackageName;
        OLESTR swzNamespace = szNamespace;
#endif
        hr = m_pijpm->GetPackage( swzPackage,
                                  ((*szNamespace == '\0')? NULL : swzNamespace),
                                  &pijp );
        if ( SUCCEEDED(hr) )
        {
            BSTR bstrPath;

            hr = pijp->GetFilePath( &bstrPath );
            if ( SUCCEEDED(hr) ) {
                CPackageNode *pPackageNode;

                pPackageNode = new CPackageNode(szDUPackageName, szNamespace);
                if (pPackageNode == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    pijp->Release();
                    break; 
                }
#ifndef UNICODE
                MAKE_ANSIPTR_FROMWIDE(szPath, bstrPath );
#else
                TCHAR *szPath = bstrPath;
#endif
                pPackageNode->SetPath( szPath );

                pijp->IsSystemClass(&fIsSystemClass);
                pPackageNode->SetIsSystemClass(fIsSystemClass);

                if (m_pHeadPackageList == NULL)
                {
                    m_pHeadPackageList = pPackageNode;
                    m_pCurPackageNode = m_pHeadPackageList;
                }
                else
                {
                    hr = m_pCurPackageNode->Insert(pPackageNode);
                    m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode();
                }

                SysFreeString( bstrPath );
                pijp->Release(); // we're done with the package
            }
        }
        else
        {
            m_dwStatus = STATUS_CTRL_DAMAGED;
            hr = S_OK; // don't barf if this doesn't work, some villain might have uninstalled it
        }

        dwStrSize = MAX_PATH;
    }

    return hr;
}


HRESULT CParseInf::DoParseDU(LPCTSTR szOCXFileName, LPCTSTR szCLSID)
{
    HRESULT     hr = S_OK;
    TCHAR       szFileName[MAX_PATH];
    TCHAR       szDUSvrName[MAX_PATH];
    const TCHAR *pszSvrFile = NULL; 
    DWORD       dwFileSize = 0;
    HKEY        hKeyFiles = 0;
    HKEY        hKeyDU = 0;
    HKEY        hKeyDLInfo = 0;
    TCHAR       szDistUnit[MAX_REGPATH_LEN];
    HRESULT     lResult;
    CFileNode   *pFileNode = NULL;
    DWORD       dwExpire;
    DWORD       dw;

    Assert(szCLSID != NULL);

    // Since this function was called, we must be a distribution unit.
    // Set a member flag so that all other member functions realize that
    // we are really part of a DU now.

    m_bIsDistUnit = TRUE;

    // initialization

    if ( szOCXFileName != NULL )
        lstrcpyn(m_szFileName, szOCXFileName, ARRAYSIZE(m_szFileName));
    lstrcpyn(m_szCLSID, szCLSID, ARRAYSIZE(m_szCLSID));
    Init();

    // Add files from ...\Distribution Units\{Name}\Contains\Files
    CatPathStrN( szDistUnit, REGSTR_PATH_DIST_UNITS, szCLSID, ARRAYSIZE(szDistUnit));

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szDistUnit, 0, KEY_READ,
                           &hKeyDU);
    if (lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto ExitDoParseDU;
    }                           

    hr = BuildDUFileList( hKeyDU );
    if (FAILED(hr))
    {
        goto ExitDoParseDU;
    } 

    hr = BuildDUPackageList( hKeyDU );
    if (FAILED(hr))
    {
        goto ExitDoParseDU;
    } 

    // Now add the OSD and INF files

    lResult = RegOpenKeyEx(hKeyDU, REGSTR_DOWNLOAD_INFORMATION, 0,
                           KEY_READ, &hKeyDLInfo);
    if (lResult == ERROR_SUCCESS)
    {
        TCHAR                *pFileName = NULL;
        TCHAR                 szBuffer[MAX_PATH + 1];

        dw = MAX_PATH;
        lResult = RegQueryValueEx(hKeyDLInfo, REGSTR_VALUE_INF, NULL, NULL,
                                  (unsigned char*)szBuffer, &dw);
        if (lResult == ERROR_SUCCESS)
        {
            pFileName = ReverseStrchr(szBuffer, '\\');
            if (pFileName != NULL)
            {
                pFileName++;

                // set INF member variable
                lstrcpyn(m_szInf, szBuffer, ARRAYSIZE(m_szInf));

                pFileNode = new CFileNode(szBuffer, "", NULL);
                if (pFileNode == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto ExitDoParseDU; 
                }
        
                // create and add node to list
                if (m_pHeadFileList == NULL)
                {
                    m_pHeadFileList = pFileNode;
                    m_pCurFileNode = m_pHeadFileList;
                }
                else
                {
                    hr = m_pCurFileNode->Insert(pFileNode);
                    m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
                }
            }
        }

        pFileName = NULL;
        dw = MAX_PATH;
        lResult = RegQueryValueEx(hKeyDLInfo, REGSTR_VALUE_OSD, NULL, NULL,
                                  (unsigned char*)szBuffer, &dw);
        if (lResult == ERROR_SUCCESS)
        {
            pFileName = ReverseStrchr(szBuffer, '\\');
            if (pFileName != NULL)
            {
                pFileName++;
                pFileNode = new CFileNode(szBuffer, "", NULL);
                // create and add node to list
                if (m_pHeadFileList == NULL)
                {
                    m_pHeadFileList = pFileNode;
                    m_pCurFileNode = m_pHeadFileList;
                }
                else
                {
                    hr = m_pCurFileNode->Insert(pFileNode);
                    m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
                }
            }
        }
    }

    // See if there's an Expire value, and if so, override the default/general expire.
    dw = sizeof(DWORD);
    dwExpire = 0;
    if ( RegQueryValueEx(hKeyDU, REGSTR_VALUE_EXPIRE, NULL, NULL, (LPBYTE)&dwExpire, &dw) == ERROR_SUCCESS )
    {
        if ( dwExpire )
            m_cExpireDays = dwExpire;
        else
            GetDaysBeforeExpireAuto(&m_cExpireDays);
    }

    // Find out where COM thinks our CLSID is, and what the server name is.
    if ( FGetCLSIDFile( szDUSvrName, szCLSID ) )
    {
        m_bHasActiveX = TRUE;
        pszSvrFile = PathFindFileName(szDUSvrName);
    }
    else
        szDUSvrName[0] = '\0';


    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL;
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode(), hr = S_OK)
    {
        const TCHAR *pszPath = m_pCurFileNode->GetPath();

        if (pszPath != NULL)
        {
            CatPathStrN( szFileName, m_pCurFileNode->GetPath(), m_pCurFileNode->GetName(), ARRAYSIZE(szFileName));
        }
        else
        {
            lstrcpyn(szFileName, m_pCurFileNode->GetName(),ARRAYSIZE(szFileName));
        }

        if (SUCCEEDED(hr = GetSizeOfFile(szFileName, &dwFileSize)))
        {
            if (pszPath == NULL ||
                IsModuleRemovable(szFileName) ||
                lstrcmpi(szFileName, m_szFileName) == 0)
            {
                m_dwFileSizeSaved += dwFileSize;
            }

            // only play with the status if we haven't already flagged the installation
            // as damaged and we're looking at the the file that should be the host for
            // our control, if any.
            if ( m_dwStatus != STATUS_CTRL_DAMAGED && pszSvrFile != NULL &&
                 lstrcmpi( pszSvrFile, m_pCurFileNode->GetName() ) == 0 )
            {
                TCHAR    szDUSvrNameSPN[MAX_PATH];
                TCHAR    szFileNameSPN[MAX_PATH];

                GetShortPathName(szDUSvrName, szDUSvrNameSPN, MAX_PATH);
                GetShortPathName(szFileName, szFileNameSPN, MAX_PATH);
                
                if ( lstrcmpi( szDUSvrNameSPN, szFileNameSPN ) == 0 )
                    m_dwStatus = STATUS_CTRL_INSTALLED; // no, we're not unplugged
                else // server and our file are in different directories - unplugged scenario
                    m_dwStatus = STATUS_CTRL_UNPLUGGED;
            }

            m_dwTotalFileSize += dwFileSize;
        } else if ( !PathFileExists( szFileName ) ) // if a DU file is missing, then the installation is damaged.
            m_dwStatus = STATUS_CTRL_DAMAGED;

        m_nTotalFiles += 1;
    }

    // If we're still unsure, and there are packages, then this is a pure Java
    // DU and will say we're installed unless a check of the package files indicates otherwise.
    if ( m_pHeadPackageList != NULL && m_dwStatus == STATUS_CTRL_UNKNOWN )
        m_dwStatus = STATUS_CTRL_INSTALLED;

    // Accumulate package sizes and such into our running total
    for (m_pCurPackageNode = m_pHeadPackageList;
         m_pCurPackageNode != NULL;
         m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode(), hr = S_OK)
    {
        // the files can hold more than one of our packages, so only add a package
        // path file to the totals if we haven't already counted it.
        // N^2 to be sure, but the numbers will be small.
        CPackageNode *ppn;
        LPCTSTR szPackagePath = m_pCurPackageNode->GetPath();
        BOOL bAlreadySeen = FALSE;

        for ( ppn = m_pHeadPackageList;
              ppn != m_pCurPackageNode && !bAlreadySeen;
              ppn = ppn->GetNextPackageNode() )
            bAlreadySeen = lstrcmp( szPackagePath, ppn->GetPath() ) == 0;
        if ( bAlreadySeen )
            continue;

        // Must be a new file, 
       if ( SUCCEEDED(GetSizeOfFile(szPackagePath, &dwFileSize)) )
       {
           m_dwFileSizeSaved += dwFileSize;
           m_dwTotalFileSize += dwFileSize;
       }
       else
           m_dwStatus = STATUS_CTRL_DAMAGED;

       // m_nTotalFiles += 1; don't count these files, or the dependency file list will have a bunch of blank entries
    }

    // Some DUs, like SportsZone or Shockwave, have no Contains subkeys.
    // If status is still unknown here, but the server is in place, consider it
    // installed.
    if ( m_dwStatus == STATUS_CTRL_UNKNOWN && PathFileExists( szDUSvrName ) )
        m_dwStatus = STATUS_CTRL_INSTALLED;

ExitDoParseDU:

    if (hKeyDU)
    {
        RegCloseKey(hKeyDU);
    }

    if (hKeyDLInfo)
    {
        RegCloseKey(hKeyDLInfo);
    }

    return hr;
}

// ---------------------------------------------------------------------------
// CParseInf::IsSectionInINF
// Checks if a section is in the INF
// returns:
//      S_OK: lpCurCode has the satellite binary name
//      S_FALSE: ignore this code and use default resources in main dll
//      E_XXX: any other error
BOOL
CParseInf::IsSectionInINF(
    LPCSTR lpCurCode)
{
    const char *szDefault = "";
    DWORD len;
#define FAKE_BUF_SIZE   3
    char szBuf[FAKE_BUF_SIZE];

    len = GetPrivateProfileString(lpCurCode, NULL, szDefault,
                                                szBuf, FAKE_BUF_SIZE, m_szInf);

    if (len == (FAKE_BUF_SIZE - 2)) {   // returns Out Of Buffer Space?
        // yes, section found
        return TRUE;
    } else {
        return FALSE;
    }
}
    
// loop through the keys in [Add.Code} section and enumerate the
// files and their corresponding sections.
HRESULT CParseInf::HandleSatellites(LPCTSTR pszFileName)
{

    HRESULT hr = S_OK;

    // BEGIN NOTE: add vars and values in matching order
    // add a var by adding a new define VAR_NEW_VAR = NUM_VARS++
    const char *szVars[] = {

#define VAR_LANG     0       // expands to 3 letter lang code based on lcid
        "%LANG%",

#define NUM_VARS            1

        ""
    };

    const char *szValues[NUM_VARS + 1];
    szValues[VAR_LANG] = "***"; // unint magic
    szValues[NUM_VARS] = NULL;
    // END NOTE: add vars and values in matching order

    // look for and substitute variables like %EXTRACT_DIR%
    // and expand out the command line

    TCHAR szSectionName[MAX_PATH]; 
    TCHAR szSectionNameCopy[MAX_PATH]; 
    hr = ExpandCommandLine(pszFileName, szSectionName, MAX_PATH, szVars, szValues);

    if (hr != S_OK) 
        return hr;      // no vars to expand ignore section

    lstrcpy(szSectionNameCopy, szSectionName); // preserve


    // OK, this is a satellite DLL. Now we need to find the section(s) that
    // got installed.

    // we first enum the registry's Module Usage looking for DLLs that were
    // installed by (or used by) this CLSID. For each of those we need to
    // check if the base filename matches the pattern of the section, 
    // if it does then we process those sections

    DWORD iSubKey = 0;
    TCHAR szModName[MAX_PATH]; 

    while ( SUCCEEDED(hr = FindDLLInModuleUsage( szModName, m_szCLSID, iSubKey))  ) {

        if (PatternMatch(szModName, szSectionName) && 
            IsSectionInINF(szSectionName) ) {

            // create new node

            CFileNode *pFileNode = new CFileNode(szSectionName, szSectionName);
            if (pFileNode == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            // don't insert file into list if it's path cannot be found
            if (FAILED(GetFilePath(pFileNode)))
            {
                delete pFileNode;
                continue;
            }

            // create and add node to list
            if (m_pHeadFileList == NULL)
            {
                m_pHeadFileList = pFileNode;
                m_pCurFileNode = m_pHeadFileList;
            }
            else if (SUCCEEDED(hr = m_pCurFileNode->Insert(pFileNode)))
            {
                m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
            }
            else
            {
                goto Exit;
            }

            lstrcpy(szSectionName, szSectionNameCopy); // restore

        
        }
    }

    if ( hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
        hr = S_OK;
    }

Exit:

    return hr;

}

// loop through the keys in [Add.Code} section and enumerate the
// files and their corresponding sections.
HRESULT CParseInf::EnumSections()
{
    HRESULT hr = S_OK;
    TCHAR szSectionBuffer[MAX_INF_SECTION_SIZE];
    TCHAR szValueBuffer[MAX_PATH];
    TCHAR *pszFileName = NULL;
    CFileNode *pFileNode = NULL;
    DWORD dwLen = GetPrivateProfileString(
                        KEY_ADDCODE,
                        NULL,
                        DEFAULT_VALUE,
                        szSectionBuffer,
                        MAX_INF_SECTION_SIZE,
                        m_szInf);
    if (dwLen == 0)
    {
        // if inf file or [Add.Code] section 
        // does not exist, just delete the OCX

        Assert (m_pHeadFileList == NULL);

        // separate file name from its directory
        Assert( lstrlen(m_szFileName) < ARRAYSIZE(szValueBuffer) );
        lstrcpy(szValueBuffer, m_szFileName);
        TCHAR *szName = ReverseStrchr(szValueBuffer, '\\');
        Assert (szName != NULL); 
        if (szName == NULL)
        {
            hr = E_UNEXPECTED;
            goto ExitEnumSections;
        }

        // create a node of the OCX and put it in a linked list
        m_pHeadFileList = new CFileNode(szName + 1, DEFAULT_VALUE);
        if (m_pHeadFileList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ExitEnumSections;
        }
        m_pCurFileNode = m_pHeadFileList;

        *szName = '\0';
        if (FAILED(hr = m_pHeadFileList->SetPath(szValueBuffer)))
        {
            goto ExitEnumSections;
        }
        hr = S_FALSE;
        goto ExitEnumSections;
    }

    // For OCX's that have an INF file and [Add.Code] section, loop
    // through the section to get filenames and section names.  Store
    // each file and its section in a node and add the node to a
    // linked list

    for (pszFileName = szSectionBuffer; 
         pszFileName[0] != '\0';
         pszFileName += lstrlen(pszFileName) + 1)
    {
        dwLen = GetPrivateProfileString(
                            KEY_ADDCODE,
                            pszFileName,
                            DEFAULT_VALUE,
                            szValueBuffer,
                            MAX_PATH,
                            m_szInf);

        // skip the file if no section is specified for it
        if (dwLen == 0) {
            continue;
        }

        if (StrChr(pszFileName, '%')) {
            // if section not found and it contains a %
            // could be a variable like %LANG% that gets
            // substituted to install satellite DLLs

            // check if it has any vars that we know about
            // and expand them and add filenodes if reqd.

            if (HandleSatellites(pszFileName) == S_OK) {

                // if this expanded to a satellite dll name then
                // we would have already added that
                // as a node in HandleSatellites

                continue;

            }
            
        }


        // create new node
        pFileNode = new CFileNode(pszFileName, szValueBuffer);
        if (pFileNode == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ExitEnumSections;
        }

        // don't insert file into list if it's path cannot be found
        if (FAILED(GetFilePath(pFileNode)))
        {
            delete pFileNode;
            continue;
        }

        // create and add node to list
        if (m_pHeadFileList == NULL)
        {
            m_pHeadFileList = pFileNode;
            m_pCurFileNode = m_pHeadFileList;
        }
        else if (SUCCEEDED(hr = m_pCurFileNode->Insert(pFileNode)))
        {
            m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
        }
        else
        {
            goto ExitEnumSections;
        }
    }

    // include inf file into file list

    if (m_pHeadFileList && m_pCurFileNode)
    {
        hr = m_pCurFileNode->Insert(new CFileNode(m_szInf, DEFAULT_VALUE));
        if (SUCCEEDED(hr))
            m_pCurFileNode = m_pCurFileNode->GetNextFileNode();
    }

ExitEnumSections:

    return hr;
}

// Loop through all the sections in [Setup Hooks].  For each
// section, call ParseUninstallSection to find its UNINSTALL section
// and execute it.
HRESULT CParseInf::ParseSetupHook()
{
    HRESULT hr = S_FALSE; // Return S_FALSE if we don't run into any errors, but also don't do any work.
    TCHAR szSectionBuffer[MAX_INF_SECTION_SIZE];
    TCHAR szSection[MAX_PATH];
    TCHAR *pszKey = NULL;

    DWORD dwLen = GetPrivateProfileString(
                        KEY_SETUPHOOK,
                        NULL,
                        DEFAULT_VALUE,
                        szSectionBuffer,
                        MAX_INF_SECTION_SIZE,
                        m_szInf);

    // no Setup Hook section found
    if (dwLen == 0)
        goto EXITPARSESETUPHOOK;

    for (pszKey = szSectionBuffer; 
         pszKey[0] != '\0';
         pszKey += lstrlen(pszKey) + 1)
    {
        // For each key, get the section and run the section with RunSetupCommand

        dwLen = GetPrivateProfileString(
                       KEY_SETUPHOOK,
                       pszKey,
                       DEFAULT_VALUE,
                       szSection,
                       MAX_PATH,
                       m_szInf);

        if (dwLen == 0)
            continue;

        hr = ParseUninstallSection(szSection);
        if (FAILED(hr))
            goto EXITPARSESETUPHOOK;
     }

EXITPARSESETUPHOOK:
    return hr;
}

// Go to each file's section, find its conditional hook section, then
// call ParseUninstallSection to execute the conditional hook section.
HRESULT CParseInf::ParseConditionalHook()
{
    HRESULT hr = S_FALSE; // Return S_FALSE if we don't run into any errors, but also don't do any work.
    TCHAR szHookSection[MAX_PATH];
    const TCHAR *pszSection = NULL;
    CFileNode *pNode = NULL;

    if (m_pHeadFileList == NULL)
    {
        hr = S_FALSE;
        goto EXITPARSECONDITIONALHOOK;
    }

    pNode = m_pHeadFileList;
    for (pNode = m_pHeadFileList; pNode != NULL; pNode = pNode->GetNextFileNode())
    {
        pszSection = pNode->GetSection();
        if (pszSection == NULL)
            continue;

        if (GetPrivateProfileString(
                            pszSection,
                            KEY_HOOK,
                            DEFAULT_VALUE,
                            szHookSection,
                            MAX_PATH,
                            m_szInf) == 0)
            continue;

        hr = ParseUninstallSection(szHookSection);
        if (FAILED(hr))
            goto EXITPARSECONDITIONALHOOK;
    }

EXITPARSECONDITIONALHOOK:
    return hr;
}

// Given a file section, find its UNINSTALL section, go to the
// section and executes the commands there
HRESULT CParseInf::ParseUninstallSection(LPCTSTR lpszSection)
{
    HRESULT hr = S_OK;
    TCHAR szUninstallSection[MAX_PATH];
    TCHAR szBuf[MAX_PATH];
    TCHAR szInfSection[MAX_PATH];
    TCHAR szCacheDir[MAX_PATH];
    HANDLE hExe = INVALID_HANDLE_VALUE;
    HINSTANCE hInst = NULL;

    // check for "UNINSTALL" key
    DWORD dwLen = GetPrivateProfileString(
                        lpszSection,
                        KEY_UNINSTALL,
                        DEFAULT_VALUE,
                        szUninstallSection,
                        ARRAYSIZE(szUninstallSection),
                        m_szInf);

    // UNINSTALL key not found, quit.
    if (dwLen == 0)
    {
        return S_FALSE;
    }

    // There are 4 possible combinations inside the uninstall section
    // 1) Both inffile and infsection are specified -> simply to go those
    // 2) Only inffile is given -> go to inffile and do DefaultInstall
    // 3) Only infsection is given -> do infsection in this inf file
    // 4) Nothing is specified -> simply do this section

    GetDirectory(GD_EXTRACTDIR, szCacheDir, ARRAYSIZE(szCacheDir), m_szFileName);

    lstrcpyn(szBuf, szCacheDir, MAX_PATH - 1);
    lstrcat(szBuf, TEXT("\\"));

    int cch = lstrlen(szBuf);

    dwLen = GetPrivateProfileString(
                        szUninstallSection,
                        KEY_INFFILE,
                        DEFAULT_VALUE,
                        szBuf + cch,
                        MAX_PATH - cch,
                        m_szInf);

    if (dwLen == 0)
    {
        szBuf[0] = '\0';
    }

    // get inf section
    dwLen = GetPrivateProfileString(
                        szUninstallSection,
                        KEY_INFSECTION,
                        DEFAULT_VALUE,
                        szInfSection,
                        ARRAYSIZE(szInfSection),
                        m_szInf);

    if (dwLen == 0)
    {
        if (szBuf[0] != '\0')
            lstrcpyn(szInfSection, KEY_DEFAULTUNINSTALL,ARRAYSIZE(szInfSection));
        else
        {
            lstrcpyn(szBuf, m_szInf,ARRAYSIZE(szBuf));
            lstrcpyn(szInfSection, szUninstallSection,ARRAYSIZE(szInfSection));
        }
    }

    // load advpack.dll and call RunSetupCommand() to process
    // any special uninstall commands

    hr = STG_E_FILENOTFOUND;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        RUNSETUPCOMMAND pfnRunSetup = (RUNSETUPCOMMAND)GetProcAddress(
            hinstAdvPack, achRUNSETUPCOMMANDFUNCTION);
        if (pfnRunSetup)
        {
            hr = pfnRunSetup(NULL, szBuf, szInfSection, 
                            szCacheDir, NULL, &hExe, 1, NULL);
        }
    }

    return hr;
}

// For each file specified in the INF file, find its
// path in this order
// 1) OCX path
// 2) System dir
// 3) Windows dir
// 4) PATH directories
HRESULT CParseInf::GetFilePath(CFileNode *pFileNode)
{
    Assert (pFileNode != NULL);
    HRESULT hr = S_OK;
    TCHAR szValueBuf[MAX_PATH];
    TCHAR *pszPathPtr = NULL;
    TCHAR *pszPathEnv = NULL;
    TCHAR *pchPathEnd = NULL;
    DWORD dwLenPATH = 0;

    // ocx directory
    hr = GetDirectory(GD_EXTRACTDIR, szValueBuf, ARRAYSIZE(szValueBuf), m_szFileName);
    CatPathStrN( szValueBuf, szValueBuf, pFileNode->GetName(), ARRAYSIZE(szValueBuf));

    // if file being searched for now is the OCX itself, just leave
    if (lstrcmpi(szValueBuf, m_szFileName) == 0)
    {
        goto EXITGETFILEPATH;
    }

    if (SUCCEEDED(hr) && 
        SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
    {
        goto EXITGETFILEPATH;
    }

    // system directory
    hr = GetDirectory(GD_SYSTEMDIR, szValueBuf, ARRAYSIZE(szValueBuf));
    if (SUCCEEDED(hr) && CatPathStrN( szValueBuf, szValueBuf, pFileNode->GetName(), ARRAYSIZE(szValueBuf)) &&
        SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
    {
        goto EXITGETFILEPATH;
    }

    // windows directory
    hr = GetDirectory(GD_WINDOWSDIR, szValueBuf, ARRAYSIZE(szValueBuf));
    if (SUCCEEDED(hr) && CatPathStrN( szValueBuf, szValueBuf, pFileNode->GetName(), ARRAYSIZE(szValueBuf)) &&
        SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
    {
        goto EXITGETFILEPATH;
    }

    // get PATH envirnment variable
    dwLenPATH = GetEnvironmentVariable(ENV_PATH, szValueBuf, 0);
    if (dwLenPATH == 0)
    {
        hr = E_FAIL;
        goto EXITGETFILEPATH;
    }

    pszPathEnv = new TCHAR[dwLenPATH];
    if (pszPathEnv == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto EXITGETFILEPATH;
    }
    GetEnvironmentVariable(ENV_PATH, pszPathEnv, dwLenPATH);
    pchPathEnd = pszPathPtr = pszPathEnv;

    // walk all directories in PATH and see if file is found
    // in any of them
    while (pchPathEnd != NULL)
    {
        pchPathEnd = StrChr(pszPathPtr, ';');
        if (pchPathEnd != NULL)
            *pchPathEnd = '\0';

        CatPathStrN( szValueBuf, pszPathPtr, pFileNode->GetName(), ARRAYSIZE(szValueBuf));

        if (SUCCEEDED(LookUpModuleUsage(szValueBuf, m_szCLSID)))
            goto EXITGETFILEPATH;

        if (pchPathEnd != NULL)
            *(pchPathEnd++) = ';';

        pszPathPtr = pchPathEnd;
    }

    // file not found anywhere
    hr = E_FAIL;

EXITGETFILEPATH:

    if (pszPathEnv != NULL)
        delete [] pszPathEnv;

    if (SUCCEEDED(hr))
    {
        hr = NullLastSlash(szValueBuf, 0);
        if (SUCCEEDED(hr))
        {
            hr = pFileNode->SetPath(szValueBuf);
        }
    }

    return hr;
}

HRESULT CParseInf::CheckFilesRemovability(void)
{
    HRESULT hr = S_OK;
    TCHAR szFullName[MAX_PATH];
    const TCHAR *pszPath = NULL;
    BOOL bFileExist;

    // Walk through every file and see if it is deletable. If so,
    // then check if for sharing violations on that file.
    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL && SUCCEEDED(hr);
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode())
    {
        pszPath = m_pCurFileNode->GetPath();
        if (pszPath == NULL || pszPath[0] == '\0')
            continue;

        CatPathStrN( szFullName, pszPath, m_pCurFileNode->GetName(), ARRAYSIZE(szFullName) );

        if (IsModuleRemovable(szFullName))
        {
            HANDLE h = CreateFile(
                             szFullName,
                             GENERIC_READ|GENERIC_WRITE,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
                             NULL);
            if (h == INVALID_HANDLE_VALUE)
            {
                bFileExist = (GetLastError() != ERROR_FILE_NOT_FOUND);
                if (bFileExist)
                {
                    hr = STG_E_SHAREVIOLATION;
                    break;
                }
            }
            else
            {
                CloseHandle(h);
                m_pCurFileNode->SetRemovable( TRUE );
            }
        }
    }

    return hr;
}

HRESULT CParseInf::CheckLegacyRemovability(LONG *cOldSharedCount )
{
    HRESULT hr = S_OK;
    BOOL    bFileExist;

    HANDLE h = CreateFile(
                     m_szFileName,
                     GENERIC_READ|GENERIC_WRITE,
                     0,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL|FILE_FLAG_NO_BUFFERING,
                     NULL);
    if (h == INVALID_HANDLE_VALUE)
    {
        bFileExist = (GetLastError() != ERROR_FILE_NOT_FOUND);
        if (bFileExist)
        {
            hr = STG_E_SHAREVIOLATION;
        } else
            hr = S_FALSE;
    }
    else
    {
        CloseHandle(h);
    }

    if ( SUCCEEDED(hr) )
        hr = CheckFilesRemovability();

    return hr;
}

HRESULT CParseInf::CheckDURemovability(HKEY hkeyDUDB, BOOL bSilent)
{
    HRESULT hr = S_OK;
    BOOL    bAskSystemClass = TRUE;

    hr = CheckFilesRemovability();
    if (FAILED(hr)) {
        goto CheckDURemovabilityExit;
    }

    hr = CheckDUDependencies(hkeyDUDB, bSilent);
    if (FAILED(hr)) {
        goto CheckDURemovabilityExit;
    }
    
    // Check for package removability.
    // We shouldn't remove a package if another DU also uses it.
    // TODO: Some sort of package-currently-in-use test. Either test the path file, as above,
    //       or use some groovy new IJavaPackage(Manager) method.
    for (m_pCurPackageNode = m_pHeadPackageList;
         m_pCurPackageNode != NULL;
         m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode())
    {
        TCHAR   szT[MAX_PATH];
        LRESULT lResult;
        BOOL    bFoundInOtherDU = FALSE;
        int     cDistUnitEnum = 0;

        if (!bAskSystemClass && m_pCurPackageNode->GetIsSystemClass()) {
            char lpszBuf[MAX_MSGBOX_STRING_LEN];
            char lpszBufTitle[MAX_MSGBOX_TITLE_LEN];

            MLLoadString(IDS_OCCACHE_WARNING_JAVA_SYSTEM_CLASS,
                         lpszBuf, MAX_MSGBOX_STRING_LEN);
            MLLoadString(IDS_REMOVAL_WARNING,
                         lpszBufTitle, MAX_MSGBOX_TITLE_LEN);

            // Attempting to remove system class. Warn user.
            if ( bSilent || 
                MessageBox(NULL, lpszBuf, lpszBufTitle,
                           MB_YESNO | MB_ICONWARNING) != IDYES) {

                hr = E_FAIL;
                goto CheckDURemovabilityExit;
            }
            bAskSystemClass = FALSE;
        }

        // Enumerate distribution units
        while ( (lResult = RegEnumKey(hkeyDUDB, cDistUnitEnum++, szT, MAX_PATH)) == ERROR_SUCCESS &&
                !bFoundInOtherDU )
        {
            if ( lstrcmp(szT, m_szCLSID) != 0 ) // skip the current DU
            {
                HKEY    hkeyDUCJ;
                DWORD   dw = MAX_PATH;
                lstrcat(szT, REGSTR_DU_CONTAINS_JAVA );
                lResult = RegOpenKeyEx( hkeyDUDB, szT, 0, KEY_READ, &hkeyDUCJ );
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = RegQueryValueEx(hkeyDUCJ, REGSTR_VALUE_INF, NULL, NULL,
                                              (unsigned char*)szT, &dw);
                    // To be safe, assume that anything other than value not found means
                    // that the other DU also uses the package.
                    bFoundInOtherDU = lResult != ERROR_FILE_NOT_FOUND;
                    RegCloseKey( hkeyDUCJ );
                } // if we could open other key's Contains\Java subkey
            } // if it's a different DU
        } // while enumerating DUs
        
        // if we found it in another DU, then we shouldn't remove this package with this DU
        m_pCurPackageNode->SetRemovable( !bFoundInOtherDU );
    } // for each package

CheckDURemovabilityExit:

    return hr;
}


HRESULT CParseInf::RemoveLegacyControl( LPCTSTR lpszTypeLibID, BOOL bSilent )
{
    HRESULT     hr = S_FALSE; 
    const TCHAR *pszPath;
    BOOL        bUnplug = m_dwStatus != STATUS_CTRL_UNPLUGGED;
    BOOL        bFileMissing = !PathFileExists( m_szFileName );
    BOOL        bDidRemove = FALSE;
    TCHAR       szFullName[MAX_PATH];

    // loop through the list of assocated files, remove them as
    // well as their registry entries.
    for (m_pCurFileNode = m_pHeadFileList;
         m_pCurFileNode != NULL;
         m_pCurFileNode = m_pCurFileNode->GetNextFileNode())
    {
        int cOwners;

        pszPath = m_pCurFileNode->GetPath();

        // Process INF file, which as no path since it's not described in INF
        if (pszPath == NULL || pszPath[0] == '\0')
        {
            if ( DeleteFile(m_pCurFileNode->GetName()) )
                hr = S_OK; // hey, we did _something_ - averts the "not enough info" message
            continue;
        }
 
        // If we're where, we had some other file besides the INF. 
        // Even if we don't remove it, we still knock down its module
        // usage, which has gotta count for having done something.
        hr = S_OK;

        CatPathStrN( szFullName, pszPath, m_pCurFileNode->GetName(), MAX_PATH);

        cOwners = SubtractModuleOwner( szFullName, m_szCLSID );
        if (m_pCurFileNode->GetRemovable() && cOwners == 0)
        {
            if ( bUnplug )
                UnregisterOCX(szFullName);
            DeleteFile(szFullName);
            bDidRemove = bDidRemove || StrCmpI(szFullName,m_szFileName) == 0;
        }
    }

    if (hr == S_OK && bDidRemove && lpszTypeLibID != NULL)
        CleanInterfaceEntries(lpszTypeLibID);
    
    if ( bUnplug && bFileMissing )
    {
        if ( m_szFileName[0] != '\0' ) // only do this if there is an ocx to clean up after
            CleanOrphanedRegistry(m_szFileName, m_szCLSID, lpszTypeLibID);
    }

    return hr;
}


HRESULT CParseInf::RemoveDU( LPTSTR szFullName, LPCTSTR lpszTypeLibID, HKEY hkeyDUDB, BOOL bSilent )
{
    HRESULT     hr = S_FALSE;   // only say S_OK if we actually do something beyond yanking the INF
    const TCHAR *pszPath = NULL;

    hr = RemoveLegacyControl( lpszTypeLibID, bSilent );
    if (SUCCEEDED(hr))
    {

        // Remove the packages that we have determined are safe to remove.
        for (m_pCurPackageNode = m_pHeadPackageList;
            m_pCurPackageNode != NULL;
            m_pCurPackageNode = m_pCurPackageNode->GetNextPackageNode())
        {
            if ( m_pCurPackageNode->GetRemovable() )
            {
                Assert(m_pijpm != NULL);
    #ifdef UNICODE
                OLECHAR *swzPkg = m_pCurPackageNode->GetName();
                OLECHAR *swzNamespace = m_pCurPackageNode->GetNamespace();
    #else
                MAKE_WIDEPTR_FROMANSI(swzPkg, m_pCurPackageNode->GetName());
                MAKE_WIDEPTR_FROMANSI(swzNamespace, m_pCurPackageNode->GetNamespace());
    #endif
                hr = m_pijpm->UninstallPackage( swzPkg, 
                                                ((*swzNamespace == 0)? NULL : swzNamespace),
                                                0 );
            }
        }
    }

    DeleteKeyAndSubKeys(hkeyDUDB, m_szCLSID);

    return hr;
}

HRESULT CParseInf::CheckDUDependencies(HKEY hKeyDUDB, BOOL bSilent )
{
    long                    lrDist = 0;
    long                    lResult = 0;
    long                    lr = 0;
    int                     iSubKey = 0;
    HKEY                    hkeyCurrent = 0;
    HKEY                    hkeyCurDU = 0;
    char                    szName[MAX_REGPATH_LEN];
    int                     iValue = 0;
    unsigned long           ulSize;
    char                    szDependency[MAX_REGPATH_LEN];
    HKEY                    hkeyCOM = 0;
    DWORD                   dwType = 0;
    char                    szDepName[MAX_CONTROL_NAME_LEN];
    char                    szDepWarnBuf[MAX_MSGBOX_STRING_LEN];
    char                    szCOMControl[MAX_REGPATH_LEN];
    DWORD                   dwSize = 0;
    HRESULT                 hr = S_OK;

    // Iterate through DUs that have a ...\contains\Distribution Units
    // key in the registry and compare the entries inside with the DU
    // being removed.

    while ((lResult = RegEnumKey(hKeyDUDB, iSubKey++, szName,
                                 MAX_REGPATH_LEN)) == ERROR_SUCCESS)
    {

        if (!lstrcmpi(szName, m_szCLSID))
        {
            // Skip ourselves
            continue;
        }

        if (RegOpenKeyEx(hKeyDUDB, szName, 0, KEY_READ, &hkeyCurrent) ==
                         ERROR_SUCCESS)
        {
            lr = RegOpenKeyEx(hkeyCurrent, REGSTR_DU_CONTAINS_DIST_UNITS,
                              0, KEY_READ, &hkeyCurDU);
            if (lr != ERROR_SUCCESS)
            {
                RegCloseKey(hkeyCurrent);
                continue;
            }

            ulSize = MAX_REGPATH_LEN;
            while ((lResult = RegEnumValue(hkeyCurDU, iValue++, szDependency,
                                           &ulSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS)
            {
                if (!lstrcmpi(szDependency, m_szCLSID))
                {
                    // dependency found

                    // Try to get a friendly name for the dependency control

                    dwSize = MAX_CONTROL_NAME_LEN;
                    lResult = RegQueryValueEx(hkeyCurrent, NULL, NULL,
                                              &dwType, (unsigned char *)szDepName,
                                              &dwSize);

                    if (lResult != ERROR_SUCCESS || szDepName[0] == '\0') {
                        // Couldn't get a friendly name. Try the COM branch.

                        // Technically, this could overflow because
                        // szName and szCOMControl are the same size, but
                        // this is already at our defined maximum size for reg
                        // entries.

                        wsprintf(szCOMControl, "%s\\%s", REGSTR_COM_BRANCH, szName);
                        
                        lResult = RegOpenKeyEx(HKEY_CLASSES_ROOT, szCOMControl,
                                               0, KEY_READ, &hkeyCOM);

                        if (lResult != ERROR_SUCCESS) {                                               
                            MLLoadString(IDS_OCCACHE_WARNING_DEP_REMOVAL_NAME_UNKNOWN,
                                         szDepWarnBuf, MAX_MSGBOX_STRING_LEN);
                        }
                        else {
                            dwSize = MAX_CONTROL_NAME_LEN;
                            lResult = RegQueryValueEx(hkeyCOM, NULL, NULL,
                                                      &dwType, (unsigned char *)szDepName,
                                                      &dwSize);

                            if (lResult != ERROR_SUCCESS || szDepName[0] == '\0') {
                                MLLoadString(IDS_OCCACHE_WARNING_DEP_REMOVAL_NAME_UNKNOWN,
                                             szDepWarnBuf, MAX_MSGBOX_STRING_LEN);
                            }
                            else {
                                char                 lpszBuf[MAX_MSGBOX_STRING_LEN];

                                MLLoadString(IDS_OCCACHE_WARNING_DEPENDENCY_REMOVAL,
                                             lpszBuf, MAX_MSGBOX_STRING_LEN);
                                wsprintf(szDepWarnBuf, lpszBuf, szDepName);
                            }

                            if (hkeyCOM) {
                                RegCloseKey(hkeyCOM);
                            }
                        }
                    }
                    else {
                        char                 lpszBuf[MAX_MSGBOX_STRING_LEN];

                        MLLoadString(IDS_OCCACHE_WARNING_DEPENDENCY_REMOVAL,
                                     lpszBuf, MAX_MSGBOX_STRING_LEN);

                        wsprintf(szDepWarnBuf, lpszBuf, szDepName);
                    }

                    
                    // TODO: Consider using better HWND than desktop
                    char lpszBufTitle[MAX_MSGBOX_TITLE_LEN];
    
                    MLLoadString(IDS_REMOVAL_WARNING,
                                 lpszBufTitle, MAX_MSGBOX_TITLE_LEN);
    
                    if (bSilent ||
                        MessageBox(NULL, szDepWarnBuf, lpszBufTitle,
                                   MB_YESNO | MB_ICONWARNING) != IDYES)
                    {
                        hr = E_FAIL;
                        RegCloseKey(hkeyCurDU);
                        RegCloseKey(hkeyCurrent);
                        RegCloseKey(hKeyDUDB);
                        goto ReturnCheckDUDependencies;
                    }
                }
                ulSize = MAX_REGPATH_LEN;
            }
            RegCloseKey(hkeyCurDU);
            RegCloseKey(hkeyCurrent);
        }
    }


ReturnCheckDUDependencies:
    return hr;
}

// uninstall OCX and its associated files
HRESULT CParseInf::RemoveFiles(
                       LPCTSTR lpszTypeLibID /* = NULL */,
                       BOOL bForceRemove, /* = FALSE */
                       DWORD dwIsDistUnit,
                       BOOL bSilent)
{
    HRESULT hr = S_OK;
    HRESULT hrInf1;
    HRESULT hrInf2;
    TCHAR szFullName[MAX_PATH];
    const TCHAR *pszPath = NULL;
    BOOL bRemovable = (dwIsDistUnit) ? (TRUE) : (IsModuleRemovable(m_szFileName));
    BOOL bIsOCX = FALSE;
    LONG cRefOld = 0;
    HKEY  hKeyDUDB = 0;
    BOOL bUnplug = m_dwStatus == STATUS_CTRL_DAMAGED || m_dwStatus == STATUS_CTRL_INSTALLED;

    if ( !g_fAllAccess || (!bForceRemove && !bRemovable))
    {
        hr = E_ACCESSDENIED;
        goto ExitRemoveFiles;
    }

    // Check sharing violation (if it is a legacy control)
    
    if (!dwIsDistUnit)
    {
        hr = CheckLegacyRemovability( &cRefOld );
        // set SharedDlls count to 1 and save up the old
        // count in case the removal fails
        if (hr == S_OK && !bRemovable && 
            FAILED(hr = SetSharedDllsCount(m_szFileName, 1, &cRefOld)))
        {
            hr = (!PathFileExists( m_szFileName ) ? S_OK : hr);
            goto ExitRemoveFiles;
        }

        if ( FAILED(hr) )
            goto ExitRemoveFiles;
    }
    else
    {
        long lResultDist;

        lResultDist = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS, 0,
                                   KEY_READ, &hKeyDUDB);
        if (lResultDist == ERROR_SUCCESS)
            hr = CheckDURemovability( hKeyDUDB, bSilent );
        else 
            hr = E_FAIL;

        if ( FAILED(hr) )
            goto ReturnRemoveFiles;
    }


    // ** keyword UNINSTALL -- new feature that hasn't been implemented yet **

    // parse [Setup Hook], look for "UNINSTALL" key  
    if (FAILED(hrInf1 = ParseSetupHook()))
    {
        goto ExitRemoveFiles;
    }

    // parse conditional hooks in each of the file sections
    if (FAILED(hrInf2 = ParseConditionalHook()))
    {
        goto ExitRemoveFiles;
    }

    // Okay, if the both didn't do anything, we'll try the DefaultUninstall
    if ( hrInf2 == S_FALSE && hrInf2 == S_FALSE && PathFileExists( m_szInf ) )
    {
        // see if there's anybody home in the default uninstall section
        DWORD dwSize = GetPrivateProfileString( KEY_DEFAULTUNINSTALL,
                                                NULL,
                                                DEFAULT_VALUE,
                                                szFullName,
                                                MAX_PATH,
                                                m_szInf );

        if ( dwSize > 0 )
        {
            HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
            HANDLE hExe = INVALID_HANDLE_VALUE;

            GetDirectory(GD_EXTRACTDIR, szFullName, ARRAYSIZE(szFullName), m_szInf);

            if (hinstAdvPack)
            {
                RUNSETUPCOMMAND pfnRunSetup = (RUNSETUPCOMMAND)GetProcAddress(
                    hinstAdvPack, achRUNSETUPCOMMANDFUNCTION);
                if (pfnRunSetup)
                {
                    // reset hrINf2 to reflect the success of running the default
                    // uninstall section. This will prevent us from pointing to the
                    // Add/Remove control panel in some cases, like Shockwave.
                    hrInf2 = pfnRunSetup(NULL, m_szInf, KEY_DEFAULTUNINSTALL, 
                                    szFullName, NULL, &hExe, RSC_FLAG_INF, NULL);
                }

                FreeLibrary( hinstAdvPack );
            }
        }
    }

    if ( !dwIsDistUnit )
        hr = RemoveLegacyControl( lpszTypeLibID, bSilent );
    else
        hr = RemoveDU( szFullName, lpszTypeLibID, hKeyDUDB, bSilent );
    if ( FAILED(hr) )
        goto ExitRemoveFiles;

    // Return S_FALSE iff none of our uninstall efforts succeeded
    if ( hr == S_FALSE && (hrInf1 == S_OK || hrInf2 == S_OK) )
        hr = S_OK;
        
    // remove conflict directory
    if (SUCCEEDED(GetDirectory(GD_CONFLICTDIR, szFullName, ARRAYSIZE(szFullName))) &&
        LStrNICmp(m_szFileName, szFullName, lstrlen(szFullName)) == 0)
    {
        TCHAR *pCh = ReverseStrchr(m_szFileName, '\\');
        Assert (pCh != NULL);
        TCHAR chTemp = *pCh;
        *pCh = '\0';
        RemoveDirectory(m_szFileName);
        *pCh = chTemp;
    }

    DestroyFileList();

ExitRemoveFiles:

    // set shared dlls count back to where it was if OCX cannot be removed
    if (cRefOld > 0 && FileExist(m_szFileName))
    {
        if (SUCCEEDED(hr))
            hr = SetSharedDllsCount(m_szFileName, cRefOld);
        else
            SetSharedDllsCount(m_szFileName, cRefOld);
    }

    if ( hKeyDUDB )
        RegCloseKey( hKeyDUDB );

ReturnRemoveFiles:

    return hr;
}


void CParseInf::SetIsDistUnit(BOOL bDist)
{
    m_bIsDistUnit = bDist;
}

BOOL CParseInf::GetIsDistUnit() const
{
    return m_bIsDistUnit;
}

// return total size of OCX and its associated files
DWORD CParseInf::GetTotalFileSize() const
{
    return m_dwTotalFileSize;
}

DWORD CParseInf::GetTotalSizeSaved() const
{
    return m_dwFileSizeSaved;
}

DWORD CParseInf::GetStatus() const
{
    return m_dwStatus;
}

// return total number of files which will be removed
// together with the OCX
int CParseInf::GetTotalFiles() const
{
    return m_nTotalFiles;
}

// return first file in the list of associated files
CFileNode* CParseInf::GetFirstFile()
{
    m_pFileRetrievalPtr = m_pHeadFileList;
    return m_pFileRetrievalPtr;
}

// get the next file in the list of associated files
CFileNode* CParseInf::GetNextFile()
{
    m_pFileRetrievalPtr = m_pFileRetrievalPtr->GetNextFileNode();
    return m_pFileRetrievalPtr;
}

// return first file in the list of associated files
CPackageNode* CParseInf::GetFirstPackage()
{
    m_pPackageRetrievalPtr = m_pHeadPackageList;
    return m_pPackageRetrievalPtr;
}

// get the next file in the list of associated files
CPackageNode* CParseInf::GetNextPackage()
{
    m_pPackageRetrievalPtr = (m_pPackageRetrievalPtr != NULL)?
                                m_pPackageRetrievalPtr->GetNextPackageNode() :
                                NULL;
    return m_pPackageRetrievalPtr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\persist.cpp ===
#include "folder.h"

///////////////////////////////////////////////////////////////////////////////
// IPersistFolder Methods

HRESULT CControlFolder::GetClassID(LPCLSID lpClassID)
{
    DebugMsg(DM_TRACE, TEXT("cf - pf - GetClassID() called."));
    
    // NOTE: Need to split cases here.
    *lpClassID = CLSID_ControlFolder;
    return S_OK;
}

HRESULT CControlFolder::Initialize(LPCITEMIDLIST pidlInit)
{
    DebugMsg(DM_TRACE, TEXT("cf - pf - Initialize() called."));
    
    if (m_pidl)
        ILFree(m_pidl);

    m_pidl = ILClone(pidlInit);

    if (!m_pidl)
        return E_OUTOFMEMORY;

    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
// IPersistFolder2 Methods

HRESULT CControlFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    DebugMsg(DM_TRACE, TEXT("cf - pf - GetCurFolder() called."));

    if (m_pidl)
        return SHILClone(m_pidl, ppidl);

    *ppidl = NULL;      
    return S_FALSE; // success but empty
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\parseinf.h ===
///////////////////////////////////////////////////////////////////////////////
// Declaration of class CParseInf
//
// One instance of this class is created for each OCX being removed.  It stores
// all the files associated with the OCX in a linked list.  It also does the
// jobs of determining if the OCX is uninstallable and of the actual file
// removal.

#ifndef __PARSE_INF__
#define __PARSE_INF__

#include "filenode.h"
#include <pkgmgr.h>

#define REGSTR_COM_BRANCH                       "CLSID"
#define REGSTR_DOWNLOAD_INFORMATION             "DownloadInformation"
#define REGSTR_DLINFO_INF_FILE                  "INF"
#define REGSTR_DLINFO_CODEBASE                  "CODEBASE"
#define REGSTR_PATH_DIST_UNITS                  "Software\\Microsoft\\Code Store Database\\Distribution Units"
#define REGSTR_DU_CONTAINS_FILES                "Contains\\Files"
#define REGSTR_DU_CONTAINS_JAVA                 "Contains\\Java"
#define REGSTR_DU_CONTAINS_DIST_UNITS           "Contains\\Distribution Units"
#define REGSTR_VALUE_INF                        "INF"
#define REGSTR_VALUE_OSD                        "OSD"
#define REGSTR_INSTALLED_VERSION                "InstalledVersion"
#define REGSTR_VALUE_EXPIRE                     "Expire"
#define REGSTR_SHOW_ALL_FILES                   "ShowAllFiles"


#define MAX_REGPATH_LEN                           2048
#define MAX_CONTROL_NAME_LEN                      1024
#define MAX_MSGBOX_STRING_LEN                     2048
#define MAX_MSGBOX_TITLE_LEN                      256

#define BYTES_MAXSIZE                             32

BOOL IsShowAllFilesEnabled();
void ToggleShowAllFiles();

class CParseInf
{
// Construction
public:
    CParseInf();
    ~CParseInf();

// Data members
protected:
    DWORD m_dwTotalFileSize;
    DWORD m_dwFileSizeSaved;
    DWORD m_dwStatus;           // status value from the STATUS_CTRL set in <cleanoc.h>
    int m_nTotalFiles;
    CFileNode *m_pHeadFileList;
    CFileNode *m_pCurFileNode;
    CFileNode *m_pFileRetrievalPtr;
    CPackageNode *m_pHeadPackageList;
    CPackageNode *m_pCurPackageNode;
    CPackageNode *m_pPackageRetrievalPtr;

    TCHAR m_szInf[MAX_PATH];
    TCHAR m_szFileName[MAX_PATH];
    TCHAR m_szCLSID[MAX_CLSID_LEN];
    BOOL m_bIsDistUnit;
    BOOL m_bHasActiveX;
    BOOL m_bHasJava;
    IJavaPackageManager *m_pijpm;
    BOOL m_bCoInit;
    ULONG m_cExpireDays;

// Operations
public:
    virtual HRESULT DoParse(
        LPCTSTR szOCXFileName,
        LPCTSTR szCLSID);
    virtual HRESULT RemoveFiles(
        LPCTSTR lpszTypeLibID = NULL,
        BOOL bForceRemove = FALSE,
        DWORD dwIsDistUnit = FALSE,
        BOOL bSilent=FALSE);
    virtual DWORD GetTotalFileSize() const;
    virtual DWORD GetTotalSizeSaved() const;
    virtual int GetTotalFiles() const;
    virtual CFileNode* GetFirstFile();
    virtual CFileNode* GetNextFile();
    virtual CPackageNode* GetFirstPackage();
    virtual CPackageNode* GetNextPackage();
    virtual HRESULT DoParseDU(LPCTSTR szOCXFileName, LPCTSTR szCLSID);
    virtual void SetIsDistUnit(BOOL bDist);
    virtual BOOL GetIsDistUnit() const;
    virtual DWORD GetStatus() const;
    virtual BOOL GetHasActiveX(void) { return m_bHasActiveX; };
    virtual BOOL GetHasJava(void) { return m_bHasJava; };
    virtual ULONG GetExpireDays(void) { return m_cExpireDays; }

// private helper methods
protected:
    void Init();
    void DestroyFileList();
    void DestroyPackageList();
    HRESULT FindInf(LPTSTR szInf);
    HRESULT EnumSections();
    BOOL IsSectionInINF( LPCSTR lpCurCode);
    HRESULT HandleSatellites(LPCTSTR pszFileName);
    HRESULT GetFilePath(CFileNode* pFileNode);
    HRESULT ParseSetupHook();
    HRESULT ParseConditionalHook();
    HRESULT ParseUninstallSection(LPCTSTR lpszSection);
    HRESULT BuildDUFileList( HKEY hKeyDU );
    HRESULT BuildDUPackageList( HKEY hKeyDU );
    HRESULT BuildNamespacePackageList( HKEY hKeyNS, LPCTSTR szNamespace );
    HRESULT CheckFilesRemovability(void);
    HRESULT CheckLegacyRemovability( LONG *cOldSharedCount);
    HRESULT CheckDURemovability( HKEY hkeyDU, BOOL bSilent=FALSE );
    HRESULT RemoveLegacyControl( LPCTSTR lpszTypeLibID, BOOL bSilent=FALSE );
    HRESULT RemoveDU( LPTSTR szFullName, LPCTSTR lpszTypeLibID, HKEY hkeyDUDB, BOOL bSilent=FALSE );
    HRESULT CheckDUDependencies(HKEY hKeyDUDB, BOOL bSilent=FALSE);
};

///////////////////////////////////////////////////////////////////////////////
// Structure storing information about an ActiveX control.
//
// szName           -- descriptive name of control (eg. "Circle control")
// szFile           -- full filename of the control 
//                     (eg. "C:\WINDOWS\OCCACHE\CIRC3.INF")
// szCLSID          -- CLSID of control, in a string
// szTypeLibID      -- TypeLib ID of the control, in a string
// dwTotalFileSize  -- total size in bytes of all control-related files
// dwTotalSizeSaved -- total size in bytes restored when the control is removed
// cTotalFiles      -- total number of control-related files, including the
//                     control itself
// parseInf         -- pointer to an instance of class CParseInf, which does
//                     all the jobs of parsing the inf file and removing the
//                     control.  Users of this struct should not in anyway
//                     manipulate this pointer.
//
class CCacheItem : public CParseInf
{
public:
    TCHAR     m_szName[LENGTH_NAME];
    TCHAR     m_szFile[MAX_PATH];
    TCHAR     m_szCLSID[MAX_DIST_UNIT_NAME_LEN];
    TCHAR     m_szTypeLibID[MAX_CLSID_LEN];
    TCHAR     m_szCodeBase[INTERNET_MAX_URL_LENGTH];
    TCHAR     m_szVersion[VERSION_MAXSIZE];

    CCacheItem(void) {};
    virtual ~CCacheItem(void) {};

    virtual DWORD ItemType(void) const = 0;
};

class CCacheLegacyControl : public CCacheItem 
{
public:
    CCacheLegacyControl(void) {};
    virtual ~CCacheLegacyControl(void) {};

    static DWORD s_dwType;

    virtual DWORD ItemType(void) const { return s_dwType; };
    virtual HRESULT Init( HKEY hkeyCLSID, LPCTSTR szFile,  LPCTSTR szCLSID );
};

class CCacheDistUnit : public CCacheLegacyControl 
{
public:
    CCacheDistUnit(void) {};
    virtual ~CCacheDistUnit() {};

    static DWORD s_dwType;

    virtual DWORD ItemType(void) const { return s_dwType; };
    virtual HRESULT Init( HKEY hkeyCLSID, LPCTSTR szFile, LPCTSTR szCLSID, HKEY hkeyDist, LPCTSTR szDU );

    // override this - we'll do this work when we DoParseDU
    virtual HRESULT DoParse( LPCTSTR szOCXFileName, LPCTSTR szCLSID ) { return S_OK; };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\item.cpp ===
#include <urlmon.h>
#include "item.h"
#include <webcheck.h>
#include "utils.h"
#include "parseinf.h"

#include <mluisupp.h>

extern "C" HRESULT GetControlFolderPath(LPTSTR lpszDir, ULONG ulSizeBuf);
typedef HRESULT (STDAPICALLTYPE *PFNASYNCINSTALLDU)(LPCWSTR,LPCWSTR, LPCWSTR, DWORD,
                                                    DWORD,LPCWSTR, IBindCtx *, LPVOID, DWORD );


// registered clipboard formats
//UINT g_cfFileDescriptor = 0;
//UINT g_cfFileContents = 0;
//UINT g_cfURL = 0;
UINT g_cfPrefDropEffect = 0;

///////////////////////////////////////////////////////////////////////////////
// CControlItem methods.

CControlItem::CControlItem() 
{
    DebugMsg(DM_TRACE, TEXT("ci - CControlItem() called."));
    DllAddRef();
    m_cRef = 1;
    m_piciUpdate = NULL;
    m_pcpidlUpdate = NULL;
    m_pcdlbsc = NULL;
}        

CControlItem::~CControlItem()
{
    Assert(m_cRef == 0);                 // we should have zero ref count here

    DebugMsg(DM_TRACE, TEXT("ci - ~CControlItem() called."));

    LocalFree((HLOCAL)m_ppcei);

    if (m_pCFolder != NULL)
        m_pCFolder->Release();          // release the pointer to the sf

    DllRelease();
}

HRESULT CControlItem::Initialize(CControlFolder *pCFolder, UINT cidl, LPCITEMIDLIST *ppidl)
{
    m_ppcei = (LPCONTROLPIDL*)LocalAlloc(LPTR, cidl * sizeof(LPCONTROLPIDL));
    if (m_ppcei == NULL)
        return E_OUTOFMEMORY;
    
    m_cItems = cidl;
    m_pCFolder = pCFolder;

    for (UINT i = 0; i < cidl; i++)
        m_ppcei[i] = (LPCONTROLPIDL)(ppidl[i]);

    m_pCFolder->AddRef();      // we're going to hold onto this pointer, so
                               // we need to AddRef it.
    return NOERROR;
}        

HRESULT CControlItem_CreateInstance(
                               CControlFolder *pCFolder,
                               UINT cidl, 
                               LPCITEMIDLIST *ppidl, 
                               REFIID riid, 
                               void **ppvOut)
{
    *ppvOut = NULL;                 // null the out param

//    if (!_ValidateIDListArray(cidl, ppidl))
//        return E_FAIL;

    CControlItem *pCItem = new CControlItem;
    if (pCItem == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = pCItem->Initialize(pCFolder, cidl, ppidl);
    if (SUCCEEDED(hr))
    {
        hr = pCItem->QueryInterface(riid, ppvOut);
    }
    pCItem->Release();

    if (g_cfPrefDropEffect == 0)
    {
//        g_cfFileDescriptor = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR); // "FileContents"
//        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);     // "FileDescriptor"
//        g_cfURL = RegisterClipboardFormat(TEXT("UniformResourceLocator"));  // "UniformResourceLocator"
        g_cfPrefDropEffect = RegisterClipboardFormat(TEXT("Preferred DropEffect"));// "Preferred DropEffect"
    }

    return hr;
}

HRESULT CControlItem::QueryInterface(REFIID iid, void **ppv)
{
    DebugMsg(DM_TRACE, TEXT("ci - QueryInterface() called."));
    
    if ((iid == IID_IUnknown) || (iid == IID_IContextMenu))
    {
        *ppv = (LPVOID)(IContextMenu*)this;
    }
    else if (iid == IID_IDataObject) 
    {
        *ppv = (LPVOID)(IDataObject*)this;
    }
    else if (iid == IID_IExtractIcon) 
    {
        *ppv = (LPVOID)(IExtractIcon*)this;
    }
    else if (iid == CLSID_ControlFolder)    // really should be CLSID_ControlFolderItem
    {
        *ppv = (void *)this; // for our friends
    }
    else
    {
        *ppv = NULL;     // null the out param
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CControlItem::AddRef()
{
    return ++m_cRef;
}

ULONG CControlItem::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;
    return 0;   
}

HRESULT CControlItem::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    HRESULT hres;

#ifdef _DEBUG_
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wsprintf(szName, "#%d", pFEIn->cfFormat);

    DebugMsg(DM_TRACE, TEXT("ci - do - GetData(%s)"), szName);
#endif

    pSTM->hGlobal = NULL;
    pSTM->pUnkForRelease = NULL;

    if ((pFEIn->cfFormat == g_cfPrefDropEffect) && (pFEIn->tymed & TYMED_HGLOBAL))
        hres = CreatePrefDropEffect(pSTM);
    else 
        hres = E_FAIL;      // FAIL WHEN YOU DON'T SUPPORT IT!!!

    return hres;
}

HRESULT CControlItem::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - GetDataHere() called."));
    return E_NOTIMPL;
}

HRESULT CControlItem::QueryGetData(LPFORMATETC pFEIn)
{
#ifdef _DEBUG_
    TCHAR szName[64];
    if (!GetClipboardFormatName(pFEIn->cfFormat, szName, sizeof(szName)))
        wsprintf(szName, "#%d", pFEIn->cfFormat);

    DebugMsg(DM_TRACE, TEXT("ci - do - QueryGetData(%s)"), szName);
#endif

    if (pFEIn->cfFormat == g_cfPrefDropEffect)
    {
        DebugMsg(DM_TRACE, TEXT("                  format supported."));
        return NOERROR;
    }

    return S_FALSE;
}

HRESULT CControlItem::GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - GetCanonicalFormatEtc() called."));
    return DATA_S_SAMEFORMATETC;
}

HRESULT CControlItem::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease)
{
    DebugMsg(DM_TRACE,TEXT("ci - do - SetData() called."));
    return E_NOTIMPL;
}

HRESULT CControlItem::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum)
{
    FORMATETC ControlFmte[1] = {
        {(CLIPFORMAT)g_cfPrefDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}
    };

    DebugMsg(DM_TRACE, TEXT("ci - do - EnumFormatEtc() called."));

    return SHCreateStdEnumFmtEtc(ARRAYSIZE(ControlFmte), ControlFmte, ppEnum);
}

HRESULT CControlItem::DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
    LPDWORD pdwConnection)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - DAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CControlItem::DUnadvise(DWORD dwConnection)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - DUnAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CControlItem::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    DebugMsg(DM_TRACE, TEXT("ci - do - EnumAdvise() called."));
    return OLE_E_ADVISENOTSUPPORTED;
}

HRESULT CControlItem::CreatePrefDropEffect(LPSTGMEDIUM pSTM)
{    
    pSTM->tymed = TYMED_HGLOBAL;
    pSTM->pUnkForRelease = NULL;
    
    pSTM->hGlobal = GlobalAlloc(GPTR, sizeof(DWORD));

    if (pSTM->hGlobal)
    {
        *((LPDWORD)pSTM->hGlobal) = DROPEFFECT_COPY;
        return S_OK;
    }

    return E_OUTOFMEMORY;    
}

HRESULT CControlItem::Remove(HWND hwnd)
{
    TCHAR szMsg[MESSAGE_MAXSIZE];
    TCHAR szBuf[MESSAGE_MAXSIZE];

    if ( !g_fAllAccess )
    {
        // The current user does not have the access privileges to modify the
        // keys we need to tweak to remove a control, so let 'em know and bail
        // out quickly.
        MLLoadString(IDS_WARNING_USERNOACCESS, szMsg, ARRAYSIZE(szMsg));
        MLLoadString(IDS_MBTITLE_REMOVECONTROL, szBuf, ARRAYSIZE(szBuf));
        MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONWARNING);
        return S_FALSE;
    }

    szMsg[0] = '\0';

    if (m_cItems == 1)
    {
//        if(!PathFileExists(GetStringInfo(m_ppcei[0], SI_LOCATION)) ||
//           IsModuleRemovable(GetStringInfo(m_ppcei[0], SI_LOCATION)))
        {
            MLLoadString(IDS_WARNING_SINGLEREMOVAL, szBuf, ARRAYSIZE(szBuf));
            wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[0], SI_CONTROL));
        }
    }
    else
    {
        MLLoadString(IDS_WARNING_MULTIPLEREMOVAL, szMsg, ARRAYSIZE(szMsg));
    }

    if (szMsg[0] != '\0')
    {
        MLLoadString(IDS_MBTITLE_REMOVECONTROL, szBuf, ARRAYSIZE(szBuf));

        if (MessageBox(hwnd, szMsg, szBuf, MB_YESNO | MB_ICONWARNING) != IDYES)
        {
            return S_FALSE;
        }
    }

    // set wait cursor
    HRESULT hr = S_OK;
    HCURSOR hCurOld = StartWaitCur();
    LPCTSTR pszTypeLibId = NULL;

    for (UINT i = 0; i < m_cItems; i++)
    {
        Assert(m_ppcei[i] != NULL);
        if (m_ppcei[i] == NULL)
        {
            hr = E_FAIL;
            break;
        }

        pszTypeLibId = GetStringInfo(m_ppcei[i], SI_TYPELIBID);
        if (SUCCEEDED(hr = RemoveControlByName2(
                                   GetStringInfo(m_ppcei[i], SI_LOCATION),
                                   GetStringInfo(m_ppcei[i], SI_CLSID),
                                   (pszTypeLibId[0] == '\0' ? NULL : pszTypeLibId),
                                   TRUE, (m_ppcei[i])->ci.dwIsDistUnit, FALSE)))
        {
            if ( hr == S_FALSE )
            {
                MLLoadString(
                      IDS_ERROR_NOUNINSTALLACTION, 
                      szBuf, 
                      ARRAYSIZE(szBuf));
                wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[i], SI_CONTROL));
                MLLoadString(
                      IDS_MBTITLE_NOUNINSTALLACTION,
                      szBuf,
                      ARRAYSIZE(szBuf));
                MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONWARNING);
            }

            GenerateEvent(
                     SHCNE_DELETE, 
                     m_pCFolder->m_pidl, 
                     (LPITEMIDLIST)(m_ppcei[i]), 
                     NULL);
        }
        else if (hr == STG_E_SHAREVIOLATION)
        {
            MLLoadString(
                  IDS_CONTROL_INUSE, 
                  szBuf, 
                  ARRAYSIZE(szBuf));
            wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[i], SI_CONTROL));
            MLLoadString(
                  IDS_MBTITLE_SHAREVIOLATION,
                  szBuf,
                  ARRAYSIZE(szBuf));
            MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONSTOP);
        }
        else
        {
            MLLoadString(
                  IDS_ERROR_REMOVEFAIL,
                  szBuf, 
                  ARRAYSIZE(szBuf));
            wsprintf(szMsg, szBuf, GetStringInfo(m_ppcei[i], SI_CONTROL));
            MLLoadString(
                  IDS_MBTITLE_REMOVEFAIL,
                  szBuf,
                  ARRAYSIZE(szBuf));
            MessageBox(hwnd, szMsg, szBuf, MB_OK|MB_ICONSTOP);
            break;
        }
    }

    EndWaitCur(hCurOld);

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IExtractIcon Methods

STDMETHODIMP CControlItem::GetIconLocation(
                            UINT uFlags,
                            LPSTR szIconFile,
                            UINT cchMax,
                            int *piIndex,
                            UINT *pwFlags)
{
    Assert(szIconFile != NULL);
    Assert(m_cItems == 1);

    if (szIconFile == NULL)
        return S_FALSE;

    *piIndex = 0;
    *pwFlags = 0;

    if (uFlags != GIL_FORSHELL)
        return S_FALSE;

    *pwFlags = GIL_NOTFILENAME|GIL_PERINSTANCE;

    if (cchMax > (UINT)lstrlen(GetStringInfo(m_ppcei[0], SI_LOCATION)))
    {
        lstrcpy(szIconFile, GetStringInfo(m_ppcei[0], SI_LOCATION));
        return NOERROR;
    }

    szIconFile[0] = '\0';
    return S_FALSE;
}

STDMETHODIMP CControlItem::Extract(
                    LPCSTR pszFile,
                    UINT nIconIndex,
                    HICON *phiconLarge,
                    HICON *phiconSmall,
                    UINT nIconSize)
{
    *phiconLarge = ExtractIcon(g_hInst, pszFile, nIconIndex);
    if (*phiconLarge == NULL)
    {   
        *phiconLarge = GetDefaultOCIcon( m_ppcei[0] );
        Assert(*phiconLarge != NULL);
    }
    *phiconSmall = *phiconLarge;

    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
// IContextMenu Methods

const struct {
    LPCTSTR pszVerb;
    UINT idCmd;
} rgcmds[] = {
    {TEXT("Remove"), IDM_CTRL_REMOVECONTROL},
    {TEXT("Properties"),  IDM_CTRL_PROPERTIES},
    {TEXT("Update"), IDM_CTRL_UPDATE},
    {TEXT("Delete"), IDM_CTRL_REMOVECONTROL},
    {NULL, 0}  // terminator
};

int GetCmdID(LPCTSTR pszCmd)
{
    if ((DWORD_PTR)pszCmd <= 0xFFFF)
        return (int)LOWORD(pszCmd);

    for (int i = 0; rgcmds[i].pszVerb != NULL; i++)
        if (lstrcmpi(pszCmd, rgcmds[i].pszVerb) == 0)
            return rgcmds[i].idCmd;

    return -1;
}

HMENU LoadPopupMenu(UINT id, UINT uSubOffset)
{
    HMENU hmParent, hmPopup;

    hmParent = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(id));
    if (!hmParent)
        return NULL;

    hmPopup = GetSubMenu(hmParent, uSubOffset);
    RemoveMenu(hmParent, uSubOffset, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}

UINT MergePopupMenu(
                HMENU *phMenu, 
                UINT idResource, 
                UINT uSubOffset, 
                UINT indexMenu,  
                UINT idCmdFirst, 
                UINT idCmdLast)
{
    HMENU hmMerge;

    if (*phMenu == NULL)
    {
        *phMenu = CreatePopupMenu();
        if (*phMenu == NULL)
            return 0;

        indexMenu = 0;    // at the bottom
    }

    hmMerge = LoadPopupMenu(idResource, uSubOffset);
    if (!hmMerge)
        return 0;

    idCmdLast = Shell_MergeMenus(*phMenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
    
    DestroyMenu(hmMerge);
    return idCmdLast;
}

HRESULT CControlItem::QueryContextMenu(
                                  HMENU hmenu, 
                                  UINT indexMenu, 
                                  UINT idCmdFirst,
                                  UINT idCmdLast, 
                                  UINT uFlags)
{
    UINT idLastMerged = 0;

    DebugMsg(DM_TRACE, TEXT("ci - cm - QueryContextMenu() called."));
    
    if (uFlags & CMF_DVFILE)
    {
        idLastMerged = MergePopupMenu(
                            &hmenu,
                            IDR_FILE_MERGE, 
                            0, 
                            indexMenu, 
                            idCmdFirst,
                            idCmdLast);
        if (IsShowAllFilesEnabled()) {
            CheckMenuItem(hmenu, 1, MF_BYPOSITION | MF_CHECKED);
        }
        else {
            CheckMenuItem(hmenu, 1, MF_BYPOSITION | MF_UNCHECKED);
        }

    }
    else if (!(uFlags & CMF_VERBSONLY))
    {
        DWORD                     dwState = 0;

        // Must have a connection and not be working offline to be able
        // to update.

        if (InternetGetConnectedState(&dwState, 0) && !IsGlobalOffline()) {
            idLastMerged = MergePopupMenu(
                                &hmenu,
                                IDR_POPUP_CONTROLCONTEXT, 
                                0, 
                                indexMenu, 
                                idCmdFirst,
                                idCmdLast);
        }
        else {
            idLastMerged = MergePopupMenu(
                                &hmenu,
                                IDR_POPUP_CONTROLCONTEXT_NO_UPDATE,
                                0, 
                                indexMenu, 
                                idCmdFirst,
                                idCmdLast);
        }
        SetMenuDefaultItem(hmenu, idLastMerged - idCmdFirst, MF_BYPOSITION); // make the last menu, Properties, the default
    }

    return ResultFromShort(idLastMerged - idCmdFirst);    // number of menu items    
}

HRESULT CControlItem::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT i;
    int idCmd = GetCmdID((LPCTSTR)(pici->lpVerb));
    HRESULT hres = S_OK;
//  LPOLESTR                 szMimeType = NULL;
//  LPOLESTR                 szExtension = NULL;
//  LPOLESTR                 szCodeBase = NULL;
//  IBindCtx                *pbc = NULL;
//  CodeDownloadBSC         *pCDLBSC = NULL;

    DebugMsg(DM_TRACE, TEXT("ci - cm - InvokeCommand() called."));

    if (idCmd == IDM_CTRL_REMOVECONTROL)
    {
        hres = Remove(pici->hwnd);
    }
    else if (idCmd == IDM_CTRL_SHOWALL) {
        ToggleShowAllFiles();
        GenerateEvent(SHCNE_UPDATEITEM, m_pCFolder->m_pidl, 0, NULL);
    }
    else
    {
        for (i = 0; i < m_cItems && SUCCEEDED(hres); i++)
            if (m_ppcei[i]) 
            {
                switch (idCmd)
                {
                case IDM_CTRL_PROPERTIES: 
                    hres = CreatePropDialog(pici->hwnd, m_ppcei[i]);
                    break;;

                case IDM_CTRL_UPDATE:
                    hres = Update( pici, m_ppcei[i] );
 /*
                    hres = CreateBindCtx(0, &pbc);
                    if (SUCCEEDED(hres)) {
                        LPITEMIDLIST pidlUpdate = ILCombine(m_pCFolder->m_pidl,(LPITEMIDLIST)(m_ppcei[i]));
                     
                        // destructor of CodeDownloadBSC will free pidlUpdate 
                        if ( pidlUpdate != NULL &&
                             (pCDLBSC = new CodeDownloadBSC( pici->hwnd, pidlUpdate )) != NULL && 
                             SUCCEEDED(hres = RegisterBindStatusCallback(pbc, pCDLBSC, NULL, 0)))
                        {
                            PFNASYNCINSTALLDU        pfnAsyncInstallDU;
                            HINSTANCE                hModule;

                            pCDLBSC->Release();
                            hModule = LoadLibrary("URLMON.DLL");

#ifdef UNICODE
                            WCHAR swzCodeBase =  (m_ppcei[i])->ci.szCodeBase;
                            WCHAR swzDUName = (m_ppcei[i])->ci.szCLSID;
#else
                            MAKE_WIDEPTR_FROMANSI(swzCodeBase, (m_ppcei[i])->ci.szCodeBase);
                            MAKE_WIDEPTR_FROMANSI(swzDUName, (m_ppcei[i])->ci.szCLSID);
#endif

                            pfnAsyncInstallDU = (PFNASYNCINSTALLDU)GetProcAddress((HMODULE)hModule, "AsyncInstallDistributionUnit");
                            pfnAsyncInstallDU( swzDUName, szMimeType, szExtension,
                                               0xFFFFFFFF, 0xFFFFFFFF,
                                               swzCodeBase,
                                               pbc,
                                               NULL, 0);
                            FreeLibrary(hModule);
                        } 
                        else
                        {
                            if ( pCDLBSC != NULL )
                                delete pCDLBSC;
                            else if ( pidlUpdate != NULL )
                                ILFree( pidlUpdate );
                        }

                        if (pbc != NULL) {
                            pbc->Release();
                        }
                    }
*/
                    break;

                default:
                    hres = E_FAIL;
                    break;
                }
            }
    }

    return hres;
}

HRESULT CControlItem::GetCommandString(
                                   UINT_PTR idCmd, 
                                   UINT uFlags, 
                                   UINT *pwReserved,
                                   LPTSTR pszName, 
                                   UINT cchMax)
{
    HRESULT hres = E_FAIL;

    DebugMsg(DM_TRACE, TEXT("ci - cm - GetCommandString() called."));

    pszName[0] = '\0';

    if (uFlags == GCS_VERB)
    {
        for (int i = 0; rgcmds[i].pszVerb != NULL; i++)
            if (idCmd == rgcmds[i].idCmd)
            {
                lstrcpyn(pszName, rgcmds[i].pszVerb, cchMax);
                hres = NOERROR;
            }
    }
    else if (uFlags == GCS_HELPTEXT)
    {
        hres = NOERROR;

        switch (idCmd)
        {
        case IDM_CTRL_REMOVECONTROL:
            MLLoadString(IDS_HELP_REMOVECONTROL, pszName, cchMax);
            break;
        case IDM_CTRL_PROPERTIES:
            MLLoadString(IDS_HELP_PROPERTIES, pszName, cchMax);
            break;
        case IDM_CTRL_UPDATE:
            MLLoadString(IDS_HELP_UPDATE, pszName, cchMax);
            break;
        default:
            hres = E_FAIL;
        }
    }

    return hres;
}

HRESULT
CControlItem::Update(LPCMINVOKECOMMANDINFO pici, LPCONTROLPIDL pcpidl )
{
    HRESULT         hres = NOERROR;

    m_piciUpdate = pici;
    m_pcpidlUpdate = pcpidl;

    if (pici->hwnd)
    {
        INT_PTR nRes = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_OCUPDATE),
                                  pici->hwnd, CControlItem::DlgProc, (LPARAM)this);
    }

    return hres;
}

INT_PTR CControlItem::DlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = TRUE;
    CControlItem* pctlitem = (CControlItem*)GetWindowLongPtr(hDlg, DWLP_USER);
    HRESULT     hr = S_OK;
    IBindCtx    *pbc = NULL;
    LPOLESTR    szMimeType = NULL;
    LPOLESTR    szExtension = NULL;
    TCHAR       szBuf[MESSAGE_MAXSIZE];

    switch (msg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pctlitem = (CControlItem*)lParam;

        MLLoadString(IDS_UPDATE_CAPTION, szBuf, ARRAYSIZE(szBuf));
        lstrcatn( szBuf, pctlitem->m_pcpidlUpdate->ci.szName, ARRAYSIZE(szBuf));
        SetWindowText( hDlg, szBuf );

        hr = CreateBindCtx(0, &pbc);
        if (SUCCEEDED(hr)) 
        {
            LPITEMIDLIST pidlUpdate = ILCombine(pctlitem->m_pCFolder->m_pidl,(LPITEMIDLIST)(pctlitem->m_pcpidlUpdate));
     
            // destructor of CodeDownloadBSC will free pidlUpdate
            // if new succeeds but register fails, we'll deallocate pidlUpdate twice.
            if ( pidlUpdate != NULL &&
                 (pctlitem->m_pcdlbsc = new CodeDownloadBSC( pctlitem->m_piciUpdate->hwnd, hDlg, pidlUpdate )) != NULL && 
                 SUCCEEDED(hr = RegisterBindStatusCallback(pbc, pctlitem->m_pcdlbsc, NULL, 0)))
            {
                PFNASYNCINSTALLDU        pfnAsyncInstallDU;
                HINSTANCE                hModule;

                hModule = LoadLibrary("URLMON.DLL");

    #ifdef UNICODE
                WCHAR swzCodeBase =  pctlitem->m_pcpidlUpdate->ci.szCodeBase;
                WCHAR swzDUName = pctlitem->m_pcpidlUpdate->ci.szCLSID;
    #else
                MAKE_WIDEPTR_FROMANSI(swzCodeBase, pctlitem->m_pcpidlUpdate->ci.szCodeBase);
                MAKE_WIDEPTR_FROMANSI(swzDUName, pctlitem->m_pcpidlUpdate->ci.szCLSID);
    #endif

                pfnAsyncInstallDU = (PFNASYNCINSTALLDU)GetProcAddress((HMODULE)hModule, "AsyncInstallDistributionUnit");
                if ( pfnAsyncInstallDU != NULL )
                    hr = pfnAsyncInstallDU( swzDUName, szMimeType, szExtension,
                                           0xFFFFFFFF, 0xFFFFFFFF,
                                           swzCodeBase,
                                           pbc,
                                           NULL, 0);
                else
                    hr = E_FAIL;

                FreeLibrary(hModule);
            } 
            else
            {
                if ( pctlitem->m_pcdlbsc != NULL )
                {
                    delete pctlitem->m_pcdlbsc;
                    pctlitem->m_pcdlbsc = NULL;
                }
                else if ( pidlUpdate != NULL )
                    ILFree( pidlUpdate );
            }

            if (pbc != NULL) {
                pbc->Release();
            }
        }

        if ( SUCCEEDED(hr) )
        {
            Animate_Open(GetDlgItem(hDlg, IDC_DOWNLOADANIMATE), IDA_DOWNLOAD);
            Animate_Play(GetDlgItem(hDlg, IDC_DOWNLOADANIMATE), 0, -1, -1);
        }
        else
            EndDialog(hDlg, FALSE);
        fRet = 0;
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            Assert( pctlitem->m_pcdlbsc != NULL );
            hr = pctlitem->m_pcdlbsc->Abort();
            Assert( SUCCEEDED( hr ) );
            EndDialog(hDlg, FALSE);
            break;

        case DOWNLOAD_PROGRESS:
            SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_SETPOS,
                        lParam, 0);
            break;

        case DOWNLOAD_COMPLETE:
            if (lParam)
                SendMessage(GetDlgItem(hDlg, IDC_DOWNLOADPROGRESS), PBM_SETPOS,
                            100, 0);
            EndDialog(hDlg, lParam);
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, FALSE);
        break;

    case WM_DESTROY:
        Assert( pctlitem->m_pcdlbsc != NULL );
        pctlitem->m_pcdlbsc->_hdlg = NULL;
        pctlitem->m_pcdlbsc->Release();
        break;

    default:
        fRet = FALSE;
    }

    return fRet;
}

BOOL CControlItem::IsGlobalOffline()
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\dll\makefile.inc ===
..\occache.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\utils.cpp ===
#include "general.h"
#include "ParseInf.h"
#include "resource.h"
#include "FileNode.h"
#include <shlwapi.h>
#include <shlobj.h>


//#define USE_SHORT_PATH_NAME   1

// also defined in \nt\private\inet\urlmon\download\isctrl.cxx
LPCTSTR g_lpszUpdateInfo = TEXT("UpdateInfo");
LPCTSTR g_lpszCookieValue = TEXT("Cookie");
LPCTSTR g_lpszSavedValue = TEXT("LastSpecifiedInterval");

// This is a 'private' entry point into URLMON that we use
// to convert paths from their current, possibly short-file-name
// form to their canonical long-file-name form.

extern "C" {
#ifdef UNICODE
#define STR_CDLGETLONGPATHNAME "CDLGetLongPathNameW"

typedef DWORD (STDAPICALLTYPE *CDLGetLongPathNamePtr)(LPWSTR lpszLongPath, LPCWSTR  lpszShortPath, DWORD cchBuffer);

#else // not UNICODE

#define STR_CDLGETLONGPATHNAME "CDLGetLongPathNameA"

typedef DWORD (STDAPICALLTYPE *CDLGetLongPathNamePtr)(LPSTR lpszLong, LPCSTR lpszShort, DWORD cchBuffer);
#endif // else not UNICODE
}


// given the typelib id, loop through HKEY_CLASSES_ROOT\Interface section and
// remove those entries with "TypeLib" subkey equal to the given type lib id
HRESULT CleanInterfaceEntries(LPCTSTR lpszTypeLibCLSID)
{
    Assert(lpszTypeLibCLSID != NULL);
    if (lpszTypeLibCLSID == NULL || lpszTypeLibCLSID[0] == '\0')
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    HRESULT hr = S_OK;
    HKEY hkey = NULL;
    DWORD cStrings = 0;
    LONG lResult = ERROR_SUCCESS, lSize = 0;
    TCHAR szKeyName[OLEUI_CCHKEYMAX];
    TCHAR szTmpID[MAX_PATH];

    // open key HKEY_CLASS_ROOT\Interface
    if (RegOpenKeyEx(
             HKEY_CLASSES_ROOT, 
             HKCR_INTERFACE,
             0,
             KEY_ALL_ACCESS,
             &hkey) == ERROR_SUCCESS)
    {
        // loop through all entries
        while ((lResult = RegEnumKey(
                                hkey,
                                cStrings,
                                szKeyName,
                                OLEUI_CCHKEYMAX)) == ERROR_SUCCESS)
        {
            lSize = MAX_PATH;
            lstrcat(szKeyName, TEXT("\\"));
            lstrcat(szKeyName, HKCR_TYPELIB);

            // if typelib id's match, remove the key
            if ((RegQueryValue(
                       hkey, 
                       szKeyName, 
                       szTmpID, 
                       &lSize) == ERROR_SUCCESS) &&
                (lstrcmpi(szTmpID, lpszTypeLibCLSID) == 0))
            {
                hr = NullLastSlash(szKeyName, 0);
                if (SUCCEEDED(hr))
                {
                    DeleteKeyAndSubKeys(hkey, szKeyName);
                }
            }
            else
            {
                cStrings += 1;
            }
        }

        RegCloseKey(hkey);

        if (SUCCEEDED(hr))
        {            
            if (lResult != ERROR_NO_MORE_ITEMS)
                hr = HRESULT_FROM_WIN32(lResult);
        }
    }

    return hr;
}
    
// If the OCX file being removed does not exist, then we cannot prompt the control
// to unregister itself.  In this case, we call this function of clean up as many
// registry entries as we could for the control.
HRESULT CleanOrphanedRegistry(
                LPCTSTR szFileName, 
                LPCTSTR szClientClsId,
                LPCTSTR szTypeLibCLSID)
{
    HRESULT hr = S_OK;
    LONG lResult = 0;
    TCHAR szTmpID[MAX_PATH];
    TCHAR szTmpRev[MAX_PATH];
    TCHAR szKeyName[OLEUI_CCHKEYMAX+50];
    HKEY hkey = NULL, hkeyCLSID = NULL;
    int nKeyLen = 0;
    DWORD cStrings = 0;
    long lSize = MAX_PATH;

    Assert(lstrlen(szFileName) > 0);
    Assert(lstrlen(szClientClsId) > 0);

    // Delete CLSID keys
    CatPathStrN( szTmpID, HKCR_CLSID, szClientClsId, MAX_PATH );

    if (DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szTmpID) != ERROR_SUCCESS)
        hr = S_FALSE;   // Keep going, but mark that there was a failure

    // Delete TypeLib info
    if (szTypeLibCLSID != NULL && szTypeLibCLSID[0] != '\0')
    {    
        CatPathStrN( szTmpID, HKCR_TYPELIB, szTypeLibCLSID, MAX_PATH);
        if (DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szTmpID) != ERROR_SUCCESS)
            hr = S_FALSE;
    }

    // Delete ModuleUsage keys
    // The canonicalizer can fail if the target file isn't there, so in that case, fall back
    // on szFileName, which may well have come in canonical form from the DU file list.
    if ( OCCGetLongPathName(szTmpRev, szFileName, MAX_PATH) == 0 )
        lstrcpy( szTmpRev, szFileName );
    ReverseSlashes(szTmpRev);

    // Guard against the subkey name being empty, as this will cause us to nuke
    // the entire Module Usage subtree, which is a bad thing to do.
    if ( szTmpRev[0] != '\0' )
    {
        CatPathStrN(szTmpID, REGSTR_PATH_MODULE_USAGE, szTmpRev, MAX_PATH);
        if (DeleteKeyAndSubKeys(HKEY_LOCAL_MACHINE, szTmpID) != ERROR_SUCCESS)
            hr = S_FALSE;

        // Delete SharedDLL value
        if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_SHAREDDLLS,
                    0,
                    KEY_ALL_ACCESS,
                    &hkey) == ERROR_SUCCESS)
        {
            hr = (RegDeleteValue(hkey, szFileName) == ERROR_SUCCESS ? hr : S_FALSE);
            RegCloseKey(hkey);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    // loop through entries under HKEY_CLASSES_ROOT to clear entries
    // whose CLSID subsection is equal to the CLSID of the control
    // being removed
    while ((lResult = RegEnumKey(
                HKEY_CLASSES_ROOT,
                cStrings++,
                szKeyName,
                OLEUI_CCHKEYMAX)) == ERROR_SUCCESS)
    {
        lSize = MAX_PATH;
        nKeyLen = lstrlen(szKeyName);
        lstrcat(szKeyName, "\\");
        lstrcat(szKeyName, HKCR_CLSID);
        if ((RegQueryValue(
                HKEY_CLASSES_ROOT, 
                szKeyName, 
                szTmpID, &lSize) == ERROR_SUCCESS) &&    
            (lstrcmpi(szTmpID, szClientClsId) == 0))
        {
            szKeyName[nKeyLen] = '\0';
            DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szKeyName);
            lResult = ERROR_NO_MORE_ITEMS;
            break;
        }

    }

    Assert(lResult == ERROR_NO_MORE_ITEMS);
    if (lResult != ERROR_NO_MORE_ITEMS)
        hr = S_FALSE;

    // loop through all HKEY_CLASSES_ROOT\CLSID entries and remove
    // those with InprocServer32 subsection equal to the name of
    // the OCX file being removed
    if (RegOpenKeyEx(
             HKEY_CLASSES_ROOT, 
             HKCR_CLSID,
             0,
             KEY_ALL_ACCESS,
             &hkey) == ERROR_SUCCESS)
    {
        cStrings = 0;
        while ((lResult = RegEnumKey(
                                hkey,
                                cStrings,
                                szKeyName,
                                OLEUI_CCHKEYMAX)) == ERROR_SUCCESS)
        {
            // check InprocServer32
            lSize = MAX_PATH;
            lstrcat(szKeyName, "\\");
            lstrcat(szKeyName, INPROCSERVER32);
            if ((RegQueryValue(
                       hkey, 
                       szKeyName, 
                       szTmpID, 
                       &lSize) == ERROR_SUCCESS) &&
                (lstrcmpi(szTmpID, szFileName) == 0))
            {
                hr = NullLastSlash(szKeyName, 0);
                if (SUCCEEDED(hr))
                {
                    DeleteKeyAndSubKeys(hkey, szKeyName);
                }
                continue;
            }

            // check LocalServer32
            hr = NullLastSlash(szKeyName, 1);
            if (SUCCEEDED(hr))
            {
                lstrcat(szKeyName, LOCALSERVER32);
                if ((RegQueryValue(
                           hkey, 
                           szKeyName, 
                           szTmpID, 
                           &lSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(szTmpID, szFileName) == 0))
                {
                    hr = NullLastSlash(szKeyName, 0);
                    if (SUCCEEDED(hr))
                    {
                        DeleteKeyAndSubKeys(hkey, szKeyName);                        
                    }
                    continue;
                }
            }

            // check LocalServerX86
            hr = NullLastSlash(szKeyName, 1);
            if (SUCCEEDED(hr))
            {
                lstrcat(szKeyName, LOCALSERVERX86);
                if ((RegQueryValue(
                           hkey, 
                           szKeyName, 
                           szTmpID, 
                           &lSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(szTmpID, szFileName) == 0))
                {
                    hr = NullLastSlash(szKeyName, 0);
                    if (SUCCEEDED(hr))
                    {
                        DeleteKeyAndSubKeys(hkey, szKeyName);                        
                    }
                    continue;
                }
            }

            // check InProcServerX86
            hr = NullLastSlash(szKeyName, 1);
            if (SUCCEEDED(hr))
            {
                lstrcat(szKeyName, INPROCSERVERX86);
                if ((RegQueryValue(
                           hkey, 
                           szKeyName, 
                           szTmpID, 
                           &lSize) == ERROR_SUCCESS) &&
                    (lstrcmpi(szTmpID, szFileName) == 0))
                {
                    hr = NullLastSlash(szKeyName, 0);
                    if (SUCCEEDED(hr))
                    {
                        DeleteKeyAndSubKeys(hkey, szKeyName);                        
                    }
                    continue;
                }
            }

            cStrings += 1;
        }

        RegCloseKey(hkey);

        Assert(lResult == ERROR_NO_MORE_ITEMS);
        if (lResult != ERROR_NO_MORE_ITEMS)
            hr = S_FALSE;
    }

    return hr;
}

// Get from a abbreviated filename its full, long name
// eg. from C:\DOC\MyMath~1.txt to C:\DOC\MyMathFile.txt
// lpszShortFileName must has in it both the file name and its full path
// if bToUpper is TRUE, the name returned will be in uppercase
HRESULT ConvertToLongFileName(
                LPTSTR lpszShortFileName,
                BOOL bToUpper /* = FALSE */)
{
    Assert(lpszShortFileName != NULL);
    if (lpszShortFileName == NULL)
        return HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

    HRESULT hr = S_OK;
    WIN32_FIND_DATA filedata;
    TCHAR *pEndPath = NULL;
    HANDLE h = FindFirstFile(lpszShortFileName, &filedata);

    if (h != INVALID_HANDLE_VALUE)
    {
        FindClose(h);

        // separate filename from path
        pEndPath = ReverseStrchr(lpszShortFileName, '\\');
        if (pEndPath != NULL)
        {
            *(++pEndPath) = '\0';
            lstrcat(pEndPath, filedata.cFileName);
        }
        else
        {
            lstrcpy(lpszShortFileName, filedata.cFileName);
        }

        // to upper case if requested
        if (bToUpper)
            CharUpper(lpszShortFileName);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    LONG                - ERROR_SUCCESS if successful
//                        - else, a nonzero error code defined in WINERROR.H
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Manually removing subkeys is needed for NT.  Win95 does that 
//      automatically
//
// This code was stolen from the ActiveX framework (util.cpp).
LONG DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    LONG  lResult;

    lResult = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (lResult != ERROR_SUCCESS)
        return lResult;

    // loop through all subkeys, blowing them away.
    for (/* DWORD c = 0 */; lResult == ERROR_SUCCESS; /* c++ */)
    {
        dwTmpSize = MAX_PATH;
        lResult = RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (lResult == ERROR_NO_MORE_ITEMS)
            break;
        lResult = DeleteKeyAndSubKeys(hk, szTmp);
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    dwTmpSize = MAX_PATH;
    Assert(RegEnumKeyEx(hk, 0, szTmp, &dwTmpSize, 0, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS);
    RegCloseKey(hk);

    lResult = RegDeleteKey(hkIn, pszSubKey);

    return lResult;
}

// return TRUE if file szFileName exists, FALSE otherwise
BOOL FileExist(LPCTSTR lpszFileName)
{
   DWORD dwErrMode;
   BOOL fResult;

   dwErrMode = SetErrorMode(SEM_FAILCRITICALERRORS);

   fResult = ((UINT)GetFileAttributes(lpszFileName) != (UINT)-1);

   SetErrorMode(dwErrMode);

   return fResult;
}

// given a flag, return the appropriate directory
// possible flags are:
//      GD_WINDOWDIR    : return WINDOWS directory
//      GD_SYSTEMDIR    : return SYSTEM directory
//      GD_CONTAINERDIR : return directory of app used to view control (ie IE)
//      GD_CACHEDIR     : return OCX cache directory, read from registry
//      GD_CONFLICTDIR  : return OCX conflict directory, read from registry
//      GD_EXTRACTDIR   : require an extra parameter szOCXFullName, 
//                        extract and return its path 
HRESULT GetDirectory(
                UINT nDirType, 
                LPTSTR szDirBuffer, 
                int nBufSize,
                LPCTSTR szOCXFullName /* = NULL */)
{
    LONG lResult = 0;
    TCHAR *pCh = NULL, *pszKeyName = NULL;
    HRESULT hr = S_OK;
    HKEY hkeyIntSetting = NULL;
    unsigned long ulSize = nBufSize;

    switch (nDirType)
    {

    case GD_WINDOWSDIR:
        if (GetWindowsDirectory(szDirBuffer, nBufSize) == 0)
            hr = HRESULT_FROM_WIN32(GetLastError());
        break;

    case GD_SYSTEMDIR:
        if (GetSystemDirectory(szDirBuffer, nBufSize) == 0)
            hr = HRESULT_FROM_WIN32(GetLastError());
        break;

    case GD_EXTRACTDIR:
        if (szOCXFullName == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
            break;
        }
        lstrcpy(szDirBuffer, szOCXFullName);
        pCh = ReverseStrchr(szDirBuffer, '\\');
        if (pCh == NULL)
            hr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
        else
            pCh[0] = '\0';
        break;

    case GD_CONTAINERDIR:
        pszKeyName = new TCHAR[MAX_PATH];
        if (pszKeyName == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        CatPathStrN(pszKeyName, REGSTR_PATH_IE, CONTAINER_APP, MAX_PATH);
        if ((lResult = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            pszKeyName,
                            0x0,
                            KEY_READ,
                            &hkeyIntSetting)) == ERROR_SUCCESS)
        {
            lResult = RegQueryValueEx(
                                hkeyIntSetting,
                                VALUE_PATH,
                                NULL,
                                NULL,
                                (unsigned char*)szDirBuffer,
                                &ulSize);
        }
        if (lResult != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(lResult);
        else
            szDirBuffer[lstrlen(szDirBuffer)-1] = '\0';  // take away the ending ';'
        delete [] pszKeyName;
        break;

    case GD_CACHEDIR:
    case GD_CONFLICTDIR:
        if ((lResult = RegOpenKeyEx(
                            HKEY_LOCAL_MACHINE,
                            REGSTR_PATH_IE_SETTINGS,
                            0x0,
                            KEY_READ,
                            &hkeyIntSetting)) == ERROR_SUCCESS)
        {
            lResult = RegQueryValueEx(
                                hkeyIntSetting,
                                VALUE_ACTIVEXCACHE,
                                NULL,
                                NULL,
                                (unsigned char*)szDirBuffer,
                                &ulSize);
        }

        hr = (lResult == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32(lResult));

        // if looking for cache dir, append "\\CONFLICT"
        if (SUCCEEDED(hr) && nDirType == GD_CONFLICTDIR)
            lstrcat(szDirBuffer, DEFAULT_CONFLICT);

        break;

    default:
        Assert(FALSE);
        hr = E_UNEXPECTED;
    }

    if (hkeyIntSetting != NULL)
        RegCloseKey(hkeyIntSetting);

    if (FAILED(hr))
        szDirBuffer[0] = '\0';

    return hr;
}

// retrieve file size for file szFile.  Size returne in pSize.
HRESULT GetSizeOfFile(LPCTSTR lpszFile, LPDWORD lpSize)
{
    HANDLE hFile = NULL;
    WIN32_FIND_DATA fileData;

    *lpSize = 0;
    Assert(lpszFile != NULL);

    hFile = FindFirstFile(lpszFile, &fileData);
    if (hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    FindClose(hFile);
    *lpSize = fileData.nFileSizeLow;

    // Get cluster size to calculate the real # of bytes
    // taken up by the file

    DWORD dwSectorPerCluster, dwBytePerSector;
    DWORD dwFreeCluster, dwTotalCluster;
    TCHAR szRoot[4];
    lstrcpyn(szRoot, lpszFile, 4);

    if (!GetDiskFreeSpace(
                    szRoot, &dwSectorPerCluster, &dwBytePerSector, 
                    &dwFreeCluster, &dwTotalCluster))
        return HRESULT_FROM_WIN32(GetLastError());

    DWORD dwClusterSize =  dwSectorPerCluster * dwBytePerSector;
    *lpSize = ((*lpSize/dwClusterSize) * dwClusterSize +
                        (*lpSize % dwClusterSize ? dwClusterSize : 0));

    return S_OK;
}

// Return S_OK is lpszCLSID is in ModuleUsage section of lpszFileName.
// Return E_... otherwise.
// lpszCLSID can be NULL, in this case it does not search for the CLSID.
// If lpszOwner is not NULL, it must point to a buffer which will be
// used to store the owner of the ModuleUsage section for lpszFileName
// dwOwnerSize is the size of the buffer pointed to by lpszOwner .
HRESULT LookUpModuleUsage(
                      LPCTSTR lpszFileName,
                      LPCTSTR lpszCLSID,
                      LPTSTR lpszOwner /* = NULL */, 
                      DWORD dwOwnerSize /* = 0 */)
{
    HKEY hkey = NULL, hkeyMod = NULL;
    HRESULT hr = S_OK;
    TCHAR szBuf[MAX_PATH];
    LONG lResult = ERROR_SUCCESS;

    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_MODULE_USAGE,
                        0, 
                        KEY_READ, 
                        &hkeyMod)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto EXITLOOKUPMODULEUSAGE;
    }


    if ( OCCGetLongPathName(szBuf, lpszFileName, MAX_PATH) == 0 )
        lstrcpyn( szBuf, lpszFileName, MAX_PATH );
    szBuf[256] = '\0'; // truncate if longer than 255 ude to win95 registry bug


    lResult = RegOpenKeyEx(
                        hkeyMod, 
                        szBuf,
                        0, 
                        KEY_READ, 
                        &hkey);
    if (lResult != ERROR_SUCCESS)
    {
        ReverseSlashes(szBuf);
        lResult = RegOpenKeyEx(hkeyMod, szBuf, 0, KEY_READ, &hkey);
        if (lResult != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto EXITLOOKUPMODULEUSAGE;
        }
    }

    // Get owner if requested
    if (lpszOwner != NULL)
    {
        DWORD dwSize = dwOwnerSize;
        lResult = RegQueryValueEx(
                            hkey,
                            VALUE_OWNER,
                            NULL,
                            NULL,
                            (unsigned char*)lpszOwner,
                            &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            lpszOwner[0] = '\0';
            goto EXITLOOKUPMODULEUSAGE;
        }
    }

    // see if lpszCLSID is a client of this module usage section
    if (lpszCLSID != NULL)
    {
        lResult = RegQueryValueEx(
                            hkey,
                            lpszCLSID,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lResult != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto EXITLOOKUPMODULEUSAGE;
        }
    }

EXITLOOKUPMODULEUSAGE:

    if (hkey)
        RegCloseKey(hkey);

    if (hkeyMod)
        RegCloseKey(hkeyMod);

    return hr;
}

// ReverseSlashes() takes a string, that's assumed to be pointing to a
// valid string and is null-terminated, and reverses all forward slashes
// to backslashes and all backslashes to forward slashes.
void ReverseSlashes(LPTSTR pszStr)
{
    while (*pszStr)
    {
        if (*pszStr == '\\')  *pszStr = '/';
        else if (*pszStr == '/')  *pszStr = '\\';
        pszStr++;
    }
}

// find the last occurance of ch in string szString
TCHAR* ReverseStrchr(LPCTSTR szString, TCHAR ch)
{
    if (szString == NULL || szString[0] == '\0')
        return NULL;
    TCHAR *pCh = (TCHAR*)(szString + lstrlen(szString));
    for (;pCh != szString && *pCh != ch; pCh--);
    return (*pCh == ch ? pCh : NULL);
}

// set the last backslash (or the character offset from that by 1) to NULL
// returns S_OK if fine, E_FAIL if last backslash not found
HRESULT NullLastSlash(LPTSTR pszString, UINT uiOffset)
{
    LPTSTR pszLastSlash;
    HRESULT hr;

    ASSERT(pszString);
    ASSERT((uiOffset == 0) || (uiOffset == 1));

    pszLastSlash = ReverseStrchr(pszString, TEXT('\\'));

    if (!pszLastSlash)
    {
        hr = E_FAIL;
    }
    else
    {        
        *(pszLastSlash + uiOffset) = TEXT('\0');
        hr = S_OK;
    }
    return hr;
}

// If lpszGUID is an owner of the module lpszFileName in Module Usage,
// remove it, updating the .Owner as necessary. If we remove an owner,
// then decrement the SharedDlls count. Never drop the SharedDlls count
// below 1 if the owner is 'Unknown Owner'.
// If modules usage drops to zero, remove MU. If SharedDlls count drops
// to zero, remove that value.
// Return the resulting owner count.
 
DWORD SubtractModuleOwner( LPCTSTR lpszFileName, LPCTSTR lpszGUID )
{
    LONG cRef = 0;
    HRESULT hr = S_OK;
    LONG lResult;
    HKEY hkeyMU = NULL;
    HKEY hkeyMod = NULL;
    TCHAR szBuf[MAX_PATH];
    TCHAR szOwner[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    BOOL bHasUnknownOwner;
    BOOL bGUIDIsOwner;

    Assert(lpszFileName != NULL);
    Assert(lpszGUID != NULL);

    // Get the current ref count, passing -1 to set is a get. Go figure.
    hr = SetSharedDllsCount( lpszFileName, -1, &cRef );
    if ( FAILED(hr) )
        return 1; // in event of failure, say something safe

    // check if Usage section is present for this dll
    // open the file's section we are concerned with

    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_MODULE_USAGE,
                        0, 
                        KEY_ALL_ACCESS, 
                        &hkeyMU)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto ExitSubtractModuleOwner;
    }
    

    if ( OCCGetLongPathName(szBuf, lpszFileName, MAX_PATH) == 0 )
        lstrcpyn( szBuf, lpszFileName, MAX_PATH );

    szBuf[256] = '\0'; // truncate if longer than 255 ude to win95 registry bug
    ReverseSlashes(szBuf);

    // open section for szFileName under ModuleUsage
    if ((lResult = RegOpenKeyEx(
                            hkeyMU, 
                            szBuf,
                            0, 
                            KEY_ALL_ACCESS,
                            &hkeyMod)) != ERROR_SUCCESS)
    {
        goto ExitSubtractModuleOwner;
    }

    dwSize = MAX_PATH;
    if ((lResult = RegQueryValueEx(
                            hkeyMod,
                            VALUE_OWNER,
                            NULL,
                            NULL,
                            (unsigned char*)szOwner,
                            &dwSize)) != ERROR_SUCCESS)
    {
        goto ExitSubtractModuleOwner;
    }

    bHasUnknownOwner = lstrcmp( szOwner, MODULE_UNKNOWN_OWNER ) == 0;

    bGUIDIsOwner = lstrcmp( szOwner, lpszGUID ) == 0;

    // remove the owner value entry, if any.
    lResult = RegDeleteValue(hkeyMod, lpszGUID);
    // if this worked, then we'll need to drop the SharedDlls count,
    // being careful not to let it fall below 1 if bHasUnknownOwner
    if ( lResult == ERROR_SUCCESS )
    {
        if ( !bHasUnknownOwner || cRef > 1 )
            SetSharedDllsCount( lpszFileName, --cRef, NULL );

        if ( cRef > 0 && bGUIDIsOwner )
        {
            DWORD dwEnumIndex; 
            // lpszGUID was the .Owner, now that it's gone, replace it
            // with another owner
            for ( dwEnumIndex = 0, dwSize = MAX_PATH;
                  RegEnumValue(hkeyMod, dwEnumIndex, (char *)szOwner,
                               &dwSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
                  dwEnumIndex++, dwSize = MAX_PATH )
            {
                if (szOwner[0] != '.')
                {
                    lResult = RegSetValueEx( hkeyMod,VALUE_OWNER, 0,
                                             REG_SZ, (LPBYTE)szOwner,
                                             (lstrlen( szOwner ) + 1) * sizeof(TCHAR) );
                    break; // we've done our job
                }
            } // for find a new owner
        } // if there are still owners, but we've nuked the owner of record.
        else if ( cRef == 0 )
        {
            // that was the last ref, so nuke the MU entry
            RegCloseKey( hkeyMod );
            hkeyMod = NULL;
            RegDeleteKey( hkeyMU, szBuf ); // note - we assume this key has no subkeys.

            // Take out the shared DLL's value
            HKEY hkey;

            lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                                    REGSTR_PATH_SHAREDDLLS, 0, KEY_ALL_ACCESS,
                                    &hkey);
            if ( lResult == ERROR_SUCCESS )
            {
                ReverseSlashes(szBuf); // revert to file sys
                lResult = RegDeleteValue( hkey, szBuf );
                RegCloseKey( hkey );
            } // if opened SharedDlls
        } // else last reference
    } // if removed an owner

ExitSubtractModuleOwner:

    if (hkeyMU)
        RegCloseKey(hkeyMU);

    if (hkeyMod)
        RegCloseKey(hkeyMod);

    return cRef;
}

// Set manually the count in SharedDlls.
// If dwCount is < 0, nothing is set.
// If pdwOldCount is non-null, the old count is returned
HRESULT SetSharedDllsCount(
                    LPCTSTR lpszFileName, 
                    LONG cRef, 
                    LONG *pcRefOld /* = NULL */)
{
    HRESULT hr = S_OK;
    LONG lResult = ERROR_SUCCESS;
    DWORD dwSize = 0;
    HKEY hkey = NULL;

    Assert(lpszFileName != NULL);
    if (lpszFileName == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);
        goto EXITSETSHAREDDLLSCOUNT;
    }

    if (cRef < 0 && pcRefOld == NULL)
    {
        goto EXITSETSHAREDDLLSCOUNT;
    }

    // open HKLM, Microsoft\Windows\CurrentVersion\SharedDlls
    lResult = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, 
                    REGSTR_PATH_SHAREDDLLS, 0, KEY_ALL_ACCESS,
                    &hkey);

    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto EXITSETSHAREDDLLSCOUNT;
    }

    // if pdwOldCount is not NULL, save the old count in it
    if (pcRefOld != NULL)
    {
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx(
                    hkey,
                    lpszFileName,
                    0,
                    NULL,
                    (unsigned char*)pcRefOld,
                    &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            *pcRefOld = 0;
            hr = S_FALSE;
            goto EXITSETSHAREDDLLSCOUNT;
        }
    }

    // if dwCount >= 0, set it as the new count
    if (cRef >= 0)
    {
        lResult = RegSetValueEx(
                     hkey, 
                     lpszFileName, 
                     0, 
                     REG_DWORD, 
                     (unsigned char*)&cRef, 
                     sizeof(DWORD)); 
        if (lResult != ERROR_SUCCESS)
        {
            hr = S_FALSE;
            goto EXITSETSHAREDDLLSCOUNT;
        }
    }

EXITSETSHAREDDLLSCOUNT:

    if (hkey != NULL)
        RegCloseKey(hkey);

    return hr;
}

// UnregisterOCX() attempts to unregister a DLL or OCX by calling LoadLibrary
// and then DllUnregisterServer if the LoadLibrary succeeds.  This function
// returns TRUE if the DLL or OCX could be unregistered or if the file isn't
// a loadable module.
HRESULT UnregisterOCX(LPCTSTR pszFile)
{
    HINSTANCE hLib;
    HRESULT hr = S_OK;
    HRESULT (FAR STDAPICALLTYPE * pUnregisterEntry)(void);

    hLib = LoadLibrary(pszFile);

    if (hLib == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        (FARPROC &) pUnregisterEntry = GetProcAddress(
            hLib,
            "DllUnregisterServer"
            );

        if (pUnregisterEntry != NULL)
        {
            hr = (*pUnregisterEntry)();
        }

        FreeLibrary(hLib);
    }

    return hr;
}

// Return S_OK if dll can be removed, or S_FALSE if it cannot.
// Return E_... if an error has occured
HRESULT UpdateSharedDlls(LPCTSTR szFileName, BOOL bUpdate)
{
    HKEY hkeySD = NULL;
    HRESULT hr = S_OK;
    DWORD dwType;
    DWORD dwRef = 1;
    DWORD dwSize = sizeof(DWORD);
    LONG lResult;

    // get the main SHAREDDLLS key ready; this is never freed!
    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, REGSTR_PATH_SHAREDDLLS,
                        0, KEY_ALL_ACCESS, &hkeySD)) != ERROR_SUCCESS)
    {
        hkeySD = NULL;
        hr = HRESULT_FROM_WIN32(lResult);
        goto ExitUpdateSharedDlls;
    }

    // now look for szFileName
    lResult = RegQueryValueEx(hkeySD, szFileName, NULL, &dwType, 
                        (unsigned char*)&dwRef, &dwSize);

    if (lResult != ERROR_SUCCESS)
    {
        hr = S_FALSE;
        goto ExitUpdateSharedDlls;
    }

    // decrement reference count by 1.
    //
    // if (count equals to 0) 
    //    if (bUpdate is TRUE)
    //         remove the key from SharedDlls
    //    return S_OK
    // otherwise
    //    if (bUpdate is TRUE)
    //       update the count
    //    return S_FALSE

    if ((--dwRef) > 0)
    {
        hr = S_FALSE;
        if (bUpdate &&
            (lResult = RegSetValueEx(hkeySD, szFileName, 0, REG_DWORD,
                        (unsigned char *)&dwRef, sizeof(DWORD))) != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
         }
        goto ExitUpdateSharedDlls;
    }

    Assert(dwRef == 0);

    // remove entry from SharedDlls
    if (bUpdate &&
        (lResult = RegDeleteValue(hkeySD, szFileName)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto ExitUpdateSharedDlls;
    }
 
ExitUpdateSharedDlls:

    if (hkeySD)
        RegCloseKey(hkeySD);

    return hr;
}

void RemoveList(LPCLSIDLIST_ITEM lpListHead)
{
    LPCLSIDLIST_ITEM lpItemPtr = NULL; 
    while (TRUE)
    {
        lpItemPtr = lpListHead;
        if (lpItemPtr == NULL)
            break;
        lpListHead = lpItemPtr->pNext;
        delete lpItemPtr;
    }
    lpListHead = NULL;
}

BOOL ReadInfFileNameFromRegistry(
                             LPCTSTR lpszCLSID, 
                             LPTSTR lpszInf,
                             LONG nBufLen)
{
    if (lpszCLSID == NULL || lpszInf == NULL)
        return FALSE;

    HKEY hkey = NULL;
    TCHAR szKey[100];
    LONG lResult = ERROR_SUCCESS;

    CatPathStrN( szKey, HKCR_CLSID, lpszCLSID, 100);
    CatPathStrN( szKey, szKey, INFFILE, 100);

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hkey) != ERROR_SUCCESS)
        return FALSE;

    lResult = RegQueryValue(hkey, NULL, lpszInf, &nBufLen);
    RegCloseKey(hkey);

    if (lResult != ERROR_SUCCESS)
    {
        lpszInf[0] = '\0';
    }

    if (lpszInf[0] == '\0')
        return FALSE;

    return TRUE;
}

BOOL WriteInfFileNameToRegistry(LPCTSTR lpszCLSID, LPTSTR lpszInf)
{
    if (lpszCLSID == NULL)
        return FALSE;

    HKEY hkey = NULL;
    LONG lResult = ERROR_SUCCESS;
    TCHAR szKey[100];
    
    CatPathStrN(szKey, HKCR_CLSID, lpszCLSID, 100);
    CatPathStrN(szKey, szKey, INFFILE, 100);

    if (RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey) != ERROR_SUCCESS)
        return FALSE;

    lResult = RegSetValue(
                         hkey,
                         NULL,
                         REG_SZ,
                         (lpszInf == NULL ? TEXT("") : lpszInf),
                         (lpszInf == NULL ? 0 : lstrlen(lpszInf)));
    RegCloseKey(hkey);

    return (lResult == ERROR_SUCCESS);
} 

// Define a macro to make life easier
#define QUIT_IF_FAIL if (FAILED(hr)) goto Exit


HRESULT
ExpandVar(
    LPCSTR& pchSrc,          // passed by ref!
    LPSTR& pchOut,          // passed by ref!
    DWORD& cbLen,           // passed by ref!
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    HRESULT hr = S_FALSE;
    int cbvar = 0;

    Assert (*pchSrc == '%');

    for (int i=0; szVars[i] && (cbvar = lstrlen(szVars[i])) ; i++) { // for each variable

        int cbneed = 0;

        if ( (szValues[i] == NULL) || !(cbneed = lstrlen(szValues[i])))
            continue;

        cbneed++;   // add for nul

        if (0 == strncmp(szVars[i], pchSrc, cbvar)) {

            // found something we can expand

                if ((cbLen + cbneed) >= cbBuffer) {
                    // out of buffer space
                    *pchOut = '\0'; // term
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                lstrcpy(pchOut, szValues[i]);
                cbLen += (cbneed -1); //don't count the nul

                pchSrc += cbvar;        // skip past the var in pchSrc
                pchOut += (cbneed -1);  // skip past dir in pchOut

                hr = S_OK;
                goto Exit;

        }
    }

Exit:

    return hr;
    
}

// from urlmon\download\hooks.cxx (ExpandCommandLine and ExpandVars)
// used to expand variables
HRESULT
ExpandCommandLine(
    LPCSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    Assert(cbBuffer);


    HRESULT hr = S_FALSE;

    LPCSTR pchSrc = szSrc;     // start parsing at begining of cmdline

    LPSTR pchOut = szBuf;       // set at begin of out buffer
    DWORD cbLen = 0;

    while (*pchSrc) {

        // look for match of any of our env vars
        if (*pchSrc == '%') {

            HRESULT hr1 = ExpandVar(pchSrc, pchOut, cbLen, // all passed by ref!
                cbBuffer, szVars, szValues);  

            if (FAILED(hr1)) {
                hr = hr1;
                goto Exit;
            }


            if (hr1 == S_OK) {    // expand var expanded this
                hr = hr1;
                continue;
            }
        }
            
        // copy till the next % or nul
        if ((cbLen + 1) < cbBuffer) {

            *pchOut++ = *pchSrc++;
            cbLen++;

        } else {

            // out of buffer space
            *pchOut = '\0'; // term
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;

        }


    }

    *pchOut = '\0'; // term


Exit:

    return hr;
}
// Find dependent DLLs in ModuleUsage
// given the clsid it will enumerate all the DLLs in the ModuleUsage
// that were used by this clsid
HRESULT FindDLLInModuleUsage(
      LPTSTR lpszFileName,
      LPCTSTR lpszCLSID,
      DWORD &iSubKey)
{
    HKEY hkey = NULL, hkeyMod = NULL;
    HRESULT hr = S_OK;
    TCHAR szBuf[MAX_PATH];
    LONG lResult = ERROR_SUCCESS;

    if (lpszCLSID == NULL) {
        hr = E_INVALIDARG;  // req clsid
        goto Exit;
    }

    // get the main MODULEUSAGE key
    if ((lResult = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, 
                        REGSTR_PATH_MODULE_USAGE,
                        0, 
                        KEY_READ, 
                        &hkeyMod)) != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    while ( ((lResult = RegEnumKey(
                            hkeyMod, 
                            iSubKey++,
                            szBuf, 
                            MAX_PATH)) == ERROR_SUCCESS) ) {

        lResult = RegOpenKeyEx(
                            hkeyMod, 
                            szBuf,
                            0, 
                            KEY_READ, 
                            &hkey);

        if (lResult != ERROR_SUCCESS)
            break;

        // see if lpszCLSID is a client of this module usage section
        lResult = RegQueryValueEx(
                            hkey,
                            lpszCLSID,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lResult == ERROR_SUCCESS)
        {
            // got the filename, return it
            lstrcpy(lpszFileName, szBuf);
            goto Exit;
        }

        if (hkey) {
            RegCloseKey(hkey);
            hkey = NULL;
        }

    } // while

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
    }

Exit:

    if (hkey)
        RegCloseKey(hkey);

    if (hkeyMod)
        RegCloseKey(hkeyMod);

    return hr;
}

BOOL PatternMatch(LPCTSTR szModName, LPTSTR szSectionName)
{

    LPCTSTR pch = ReverseStrchr(szModName, '/');
    DWORD len = 0;

    if (!pch)
        pch = szModName;
    else
        pch++;

    // pch points at base name of module

    if ((len = lstrlen(pch)) != (DWORD)lstrlen(szSectionName))
        return FALSE;

    LPTSTR pchSecStar = StrChr(szSectionName, '*'); 

    Assert(pchSecStar);

    DWORD cbLen1 = (DWORD) (pchSecStar - szSectionName);

    // compare upto '*'
    if (StrCmpNI(szSectionName, pch, cbLen1) != 0) 
        return FALSE;

    // compare after the 3 stars
    if ( (cbLen1 + 3) < len) // *s not at end
        if (StrCmpNI(pchSecStar+3, pch + (cbLen1+3), len -(cbLen1+3)) != 0) 
            return FALSE;

    // simlar strings but for the stars.

    // modify the szSectionName to hold the value for the stars
    // in-effect this will substitute the original variable with
    // the value that was used when installing the OCX

    lstrcpy(pchSecStar, pch + cbLen1);

    return TRUE;
}

DWORD OCCGetLongPathName( LPTSTR szLong, LPCTSTR szShort, DWORD cchBuffer )
{
    DWORD   dwLen = 0;
    HMODULE hmodUrlMon;
    CDLGetLongPathNamePtr pfnGetLongPathName = NULL;

    hmodUrlMon = LoadLibrary( "URLMON.DLL" );

    // Set up our globals with short and long versions of the base cache path 
    if ( hmodUrlMon != NULL ) {
        pfnGetLongPathName = (CDLGetLongPathNamePtr)GetProcAddress(hmodUrlMon, (LPCSTR)STR_CDLGETLONGPATHNAME );
 
        if ( pfnGetLongPathName != NULL ) {
            dwLen = pfnGetLongPathName( szLong, szShort, cchBuffer );
        }  
        FreeLibrary( hmodUrlMon );
    }

    return dwLen;
}

TCHAR *CatPathStrN( TCHAR *szDst, const TCHAR *szHead, const TCHAR *szTail, int cchDst )
{
    TCHAR *szRet = szDst;
    int cchHead = lstrlen(szHead);
    int cchTail = lstrlen(szTail);

    if ( cchHead + cchTail >= (cchDst - 2) ) {// - 2 for / and null
        Assert(FALSE);
        szRet = NULL;
        *szDst = 0;
    }
    else { // we know the whole thing is safe
        lstrcpy(szDst, szHead);
        lstrcpy(&szDst[cchHead], TEXT("\\"));
        lstrcpy(&szDst[cchHead + 1], szTail);
    }

    return szRet;
}

BOOL IsCanonicalName( LPTSTR szName )
{
    // simple test - if there's a ~ in it, it has a contraction in it
    // and is therefore non-canonical
    for ( ; *szName != '\0' && *szName != '~'; szName++ );
    
    return *szName != '~';
};

struct RegPathName {
    LPTSTR   m_szName;
    LPTSTR   m_szCanonicalName;

    RegPathName(void) : m_szName(NULL), m_szCanonicalName(NULL)
    {};
    ~RegPathName()
    {
         if ( m_szName )
            delete m_szName;

         if ( m_szCanonicalName )
            delete m_szCanonicalName;
    };

    void MakeRegFriendly( LPTSTR szName )
    {
        TCHAR *pch;
        // If szName is going to be a reg key name, we can't have it lookin' like a path
        for ( pch = szName; *pch != '\0'; pch++ )
            if ( *pch == '\\' ) *pch = '/';
    }

    void MakeFileSysFriendly( LPTSTR szName )
    {
        TCHAR *pch;
        // change the slashes back into DOS
        // directory \'s
        for ( pch = szName; *pch != '\0'; pch++ )
            if ( *pch == '/' ) *pch = '\\';
    }

    BOOL FSetCanonicalName(void)
    {
        BOOL fSet = FALSE;
        TCHAR *szT = new TCHAR[MAX_PATH];

        if ( m_szName != NULL && szT != NULL ) {
            LPITEMIDLIST pidl = NULL;
            // WE jump through some hoops to get the all-long
            // name version of szName. First we convert it to
            // an ITEMIDLIST.

            // but first, we must change the slashes back into DOS
            // directory \'s
            MakeFileSysFriendly( m_szName );
            if ( OCCGetLongPathName( szT, m_szName, MAX_PATH ) != 0 ) {
                m_szCanonicalName = szT;
                fSet = TRUE;
            } else
                delete [] szT;

            // restore m_szName to it's registry-friendly form
            MakeRegFriendly( m_szName );
 
        } // if we can get our temp string

        if ( fSet ) { // whatever its source, our canonical form has reversed slashes
           MakeRegFriendly( m_szCanonicalName );
        }
        return fSet;
    };

    BOOL FSetName( LPTSTR szName, int cchName )
    {
        BOOL fSet = FALSE;

        if ( m_szName != NULL ) {
            delete m_szName;
            m_szName = NULL;
        }

        if ( m_szCanonicalName != NULL ) {
            delete m_szCanonicalName;
            m_szCanonicalName = NULL;
        }

        // we got a short name, so szName is the short name
        m_szName = new TCHAR[cchName + 1];
        if ( m_szName != NULL ) {
            lstrcpy( m_szName, szName );
            fSet = FSetCanonicalName();
        }

        return fSet;
    };
}; 

struct ModuleUsageKeys : public RegPathName {
    ModuleUsageKeys   *m_pmukNext;
    HKEY              m_hkeyShort; // key with the short file name name

    ModuleUsageKeys(void) : m_pmukNext(NULL), m_hkeyShort(NULL) {};
    ~ModuleUsageKeys(void)
    {
        if ( m_hkeyShort )
            RegCloseKey( m_hkeyShort );
    };

    HRESULT MergeMU( HKEY hkeyCanon, HKEY hkeyMU )
    {
        HRESULT hr = E_FAIL;
        DWORD   dwIndex = 0;
        DWORD   cchNameMax;
        DWORD   cbValueMax;

        if ( RegQueryInfoKey( m_hkeyShort,
                              NULL, NULL, NULL, NULL, NULL, NULL,
                              &dwIndex, &cchNameMax, &cbValueMax,
                              NULL, NULL ) == ERROR_SUCCESS ) {
            LPTSTR szName = new TCHAR[cchNameMax + 1];

            if (szName != NULL)
            {
                LPBYTE lpbValue = new BYTE[cbValueMax];

                if (lpbValue != NULL)
                {
                    // Examine each value.
                    for ( dwIndex--, hr = S_OK; (LONG)dwIndex >= 0 && SUCCEEDED(hr); dwIndex-- ) {
                        LONG  lResult;
                        DWORD cchName = cchNameMax + 1;
                        DWORD dwType;
                        DWORD dwSize = cbValueMax;
 
                        // fetch key and value
                        lResult = RegEnumValue( m_hkeyShort,
                                                dwIndex, 
                                                szName, 
                                                &cchName,
                                                0,
                                                &dwType,
                                                lpbValue, 
                                                &dwSize );

                        if ( lResult == ERROR_SUCCESS ) {
                            // Do not replace if the canonical entry already has a
                            // .Owner value that is "Unknown Owner"
                            if ( lstrcmp( szName, ".Owner" ) == 0 ) {
                                TCHAR szCanonValue[MAX_PATH];
                                DWORD dwType;
                                DWORD lcbCanonValue = MAX_PATH;
                                if ( RegQueryValueEx( hkeyCanon, ".Owner", NULL, &dwType,
                                                      (LPBYTE)szCanonValue, &lcbCanonValue ) == ERROR_SUCCESS &&
                                     lstrcmp( szCanonValue, "Unknown Owner" ) == 0 )
                                    continue;
                            }

                            // Add the value to the canonical version of the key
                            if ( RegSetValueEx( hkeyCanon, szName, NULL, dwType,
                                                lpbValue, dwSize ) != ERROR_SUCCESS )
                                hr = E_FAIL;
                           
                        } else
                            hr = E_FAIL;
                    } // for each value in the non-canoncical key

                    // Now we are finished with the non-canonical key
                    if ( SUCCEEDED(hr) &&
                         RegDeleteKey( hkeyMU, m_szName ) != ERROR_SUCCESS )
                        hr = E_FAIL;
                }
                else // lpbValue.
                {
                    delete [] szName;
                    hr = E_OUTOFMEMORY;
                }
            }
            else  // szName
            {
                hr = E_OUTOFMEMORY;
            }
        } 

        return hr;
    };

    HRESULT MergeSharedDlls( HKEY hkeySD )
    {
        HRESULT hr = E_FAIL;
        DWORD dwShortVal = 0;
        DWORD dwCanonicalVal = 0;
        DWORD dwType;
        DWORD dwSize;
        
        // The value names under shared DLLs are raw paths
        MakeFileSysFriendly( m_szName );
        MakeFileSysFriendly( m_szCanonicalName );

        dwSize = sizeof(DWORD);
        if ( RegQueryValueEx( hkeySD, m_szName, NULL,
                              &dwType, (LPBYTE)&dwShortVal, &dwSize ) == ERROR_SUCCESS &&
              dwType == REG_DWORD ) {
            dwCanonicalVal = 0;
            dwSize = sizeof(DWORD);
            // the canonical form may not be there, so we don't care if this
            // fails.
            RegQueryValueEx( hkeySD, m_szCanonicalName, NULL,
                             &dwType, (LPBYTE)&dwCanonicalVal, &dwSize );
            dwCanonicalVal += dwShortVal;
            dwSize = sizeof(DWORD);
            if ( RegSetValueEx( hkeySD, m_szCanonicalName, NULL, REG_DWORD,
                                (LPBYTE)&dwCanonicalVal, dwSize ) == ERROR_SUCCESS ) {
                RegDeleteValue( hkeySD, m_szName );
            }
        } else {
            dwCanonicalVal = 1;
            dwSize = sizeof(DWORD);
            if ( RegSetValueEx( hkeySD, m_szCanonicalName, NULL, REG_DWORD,
                                (LPBYTE)&dwCanonicalVal, dwSize ) == ERROR_SUCCESS )
                hr = S_OK;
        }

        MakeRegFriendly( m_szName );
        MakeRegFriendly( m_szCanonicalName );

        return hr;
    }

    HRESULT CanonicalizeMU( HKEY hkeyMU, HKEY hkeySD )
    {
        HRESULT hr = E_FAIL; 
        HKEY    hkeyCanon;
        LONG    lResult = RegOpenKeyEx( hkeyMU, m_szCanonicalName, 0, KEY_ALL_ACCESS, &hkeyCanon);
           
            
        if ( lResult != ERROR_SUCCESS )
            lResult = RegCreateKey( hkeyMU, 
                                    m_szCanonicalName, 
                                    &hkeyCanon );

        if ( lResult == ERROR_SUCCESS ) {
            hr = MergeMU( hkeyCanon, hkeyMU );
            if ( SUCCEEDED(hr) )
                hr = MergeSharedDlls( hkeySD );
            RegCloseKey( hkeyCanon );
        } else
            hr = E_FAIL;

        return S_OK;
    };
};

// FAddModuleUsageKeys adds a module usage key to the list.

BOOL FAddModuleUsageKeys( ModuleUsageKeys*&pmuk, // head of ModuleUsageKeys list
                         LPTSTR szName,          // name of key value
                         DWORD  cchName,         // length of szName, minus null terminator
                         HKEY  hkeyMU            // hkey of parent
                        )
{
    BOOL fAdd = FALSE;
    ModuleUsageKeys* pmukNew;
    HKEY hkeySub = NULL;
    LRESULT lr;

    pmukNew = new ModuleUsageKeys;
    if ( pmukNew &&
         (lr = RegOpenKeyEx( hkeyMU, szName, 0, KEY_ALL_ACCESS, &hkeySub)) == ERROR_SUCCESS ) {
 
        fAdd = pmukNew->FSetName( szName, cchName );

        if ( fAdd ) {
            // append to head of the list
            pmukNew->m_hkeyShort = hkeySub;
            pmukNew->m_pmukNext = pmuk;
            pmuk = pmukNew;
        }
    }

    if ( !fAdd ) {
        if ( hkeySub )
            RegCloseKey( hkeySub );
        if ( pmukNew != NULL )
            delete pmukNew;
    }

    return fAdd;
}

EXTERN_C HRESULT
CanonicalizeModuleUsage(void)
{
    HKEY hkeyMU = NULL;
    HKEY hkeySD = NULL;
    HRESULT hr = S_OK;
    LONG lResult;

    // get the main SHAREDDLLS key ready; this is never freed!


    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_SHAREDDLLS,
                        0, KEY_ALL_ACCESS, &hkeySD)) == ERROR_SUCCESS &&
        (lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_MODULE_USAGE,
                        0, KEY_ALL_ACCESS, &hkeyMU)) == ERROR_SUCCESS )
    {
        DWORD          dwIndex = 0;
        ModuleUsageKeys *pmukUpdate = NULL; // records for values we want to update.
        ModuleUsageKeys *pmuk;
        ModuleUsageKeys *pmukNext;
 
        // Examine each value.
        do  {
            TCHAR szName[MAX_PATH];        // Value name
            DWORD cchName = MAX_PATH;
            FILETIME ftT;

            // fetch key and value
            lResult = RegEnumKeyEx( hkeyMU, dwIndex, szName, &cchName,
                                    0, NULL, NULL, &ftT );

             if ( lResult == ERROR_SUCCESS ) {

                if ( !IsCanonicalName( szName ) )
                    if ( !FAddModuleUsageKeys( pmukUpdate, szName, cchName, hkeyMU ) )
                        hr = E_OUTOFMEMORY;
                dwIndex++;
             } else if ( lResult == ERROR_NO_MORE_ITEMS )
                 hr = S_FALSE;
             else
                 hr = E_FAIL;
        } while ( hr == S_OK );

   
        if ( SUCCEEDED(hr) ) {
            hr = S_OK; // don't need S_FALSE any longer
            for ( pmuk = pmukUpdate; pmuk != NULL; pmuk = pmukNext ) {
                HRESULT hr2 = pmuk->CanonicalizeMU( hkeyMU, hkeySD );
                if ( FAILED(hr2) )
                    hr = hr2;
                pmukNext = pmuk->m_pmukNext; 
                delete pmuk;
            } // for 
        } //  if enumeration succeeded
    } // if keys opened

    if (hkeyMU)
        RegCloseKey(hkeyMU);

    if ( hkeySD )
        RegCloseKey( hkeySD );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\utils.h ===
#ifndef __UTILS__
#define __UTILS__

#include <windows.h>
#include <advpub.h>
#include <CleanOC.h>
#include <debug.h>
#include "general.h"

#define LStrNICmp(sz1, sz2, cch) (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, sz1, cch, sz2, cch) - 2)

#define MODULE_UNKNOWN_OWNER   "Unknown Owner"
#define MAX_MESSAGE_LEN        2048

// numeric constants
#define GD_EXTRACTDIR    0
#define GD_CACHEDIR      1
#define GD_CONFLICTDIR   2
#define GD_CONTAINERDIR  3
#define GD_WINDOWSDIR   10
#define GD_SYSTEMDIR    11

#define LENGTH_NAME             200
#define MAX_INF_SECTION_SIZE    1024
#define OLEUI_CCHKEYMAX         256
#define OLEUI_CCHKEYMAX_SIZE    (OLEUI_CCHKEYMAX*sizeof(TCHAR))
#define TIMESTAMP_MAXSIZE       64
#define VERSUBBLOCK_SIZE        256

#define MAX_VERSION_SIZE      16

// string constants
#define INPROCSERVER       TEXT("InprocServer")
#define LOCALSERVER        TEXT("LocalServer")
#define INPROCSERVERX86    TEXT("InProcServerX86")
#define LOCALSERVERX86     TEXT("LocalServerX86")
#define INPROCSERVER32     TEXT("InprocServer32")
#define LOCALSERVER32      TEXT("LocalServer32")
#define INFFILE            TEXT("InfFile")
#define UNKNOWNDATA        TEXT("n/a")
#define UNKNOWNOWNER       TEXT("Unknown Owner")
#define VARTRANSLATION     TEXT("\\VarFileInfo\\Translation")
#define FILEVERSION        TEXT("\\FileVersion")
#define STRINGFILEINFO     TEXT("\\StringFileInfo\\")
#define HKCR_CLSID         TEXT("CLSID")
#define HKCR_TYPELIB       TEXT("TypeLib")
#define HKCR_INTERFACE     TEXT("Interface")
#define VALUE_OWNER        TEXT(".Owner")
#define VALUE_ACTIVEXCACHE TEXT("ActiveXCache")
#define VALUE_PATH         TEXT("PATH")
#define VALUE_SYSTEM       TEXT("SystemComponent")
#define CONTAINER_APP      TEXT("IEXPLORE.EXE")
#define DEMO_PAGE          TEXT("DemoTmp.html")
#define KEY_HOOK           TEXT("Hook")
#define KEY_INFFILE        TEXT("InfFile")
#define KEY_INFSECTION     TEXT("InfSection")
#define KEY_DEFAULTUNINSTALL TEXT("DefaultUninstall")
#define KEY_UNINSTALL      TEXT("UNINSTALL")
#define KEY_SETUPHOOK      TEXT("SETUP HOOKS")
#define INF_EXTENSION      TEXT(".INF")
#define ENV_PATH           TEXT("PATH")
#define KEY_ADDCODE        TEXT("Add.Code")
#define DEFAULT_VALUE      TEXT("")
#define DEFAULT_CACHE      TEXT("\\OCCACHE")
#define DEFAULT_CONFLICT   TEXT("\\CONFLICT")
#define DU_INSTALLER_VALUE TEXT("Installer")
#define CDL_INSTALLER      TEXT("MSICD")

// registry paths for ModuleUsage
#define REGSTR_PATH_SHAREDDLLS     TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls")
#define REGSTR_PATH_MODULE_USAGE   TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\ModuleUsage")
#define REGSTR_PATH_IE             TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths")
#define REGSTR_PATH_IE_SETTINGS    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
//#define REGSTR_PATH_ACTIVEX_CACHE  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache\\Paths")
#define REGSTR_PATH_ACTIVEX_CACHE  TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\ActiveX Cache")
#define SOFTWARECLASSES            TEXT("SOFTWARE\\CLASSES")

// CLSIDLIST_ITEM declaration
struct tagCLSIDLIST_ITEM;
typedef struct tagCLSIDLIST_ITEM CLSIDLIST_ITEM;
typedef CLSIDLIST_ITEM* LPCLSIDLIST_ITEM;
struct tagCLSIDLIST_ITEM
{
    TCHAR szFile[MAX_PATH];
    TCHAR szCLSID[MAX_DIST_UNIT_NAME_LEN];
    BOOL bIsDistUnit;
    LPCLSIDLIST_ITEM pNext;
};

// function prototypes
// void RemoveObsoleteKeys();
void ReverseSlashes(LPTSTR pszStr);
LPTSTR ReverseStrchr(LPCTSTR szString, TCHAR ch);
HRESULT NullLastSlash(LPTSTR szString, UINT uiOffset); 
LONG DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey);
BOOL FileExist(LPCTSTR lpszFileName);
HRESULT LookUpModuleUsage(
                LPCTSTR lpszFileName, 
                LPCTSTR lpszCLSID,
                LPTSTR lpszOwner = NULL, 
                DWORD dwOwnerSize = 0);
DWORD SubtractModuleOwner( LPCTSTR lpszFileName, LPCTSTR lpszGUID );

HRESULT SetSharedDllsCount(
                LPCTSTR lpszFileName, 
                LONG cRef, 
                LONG *pcRefOld = NULL);
HRESULT GetSizeOfFile(LPCTSTR lpszFile, LPDWORD lpSize);
HRESULT CleanOrphanedRegistry(
                LPCTSTR szFileName, 
                LPCTSTR szClientClsId,
                LPCTSTR szTypeLibCLSID);
HRESULT UnregisterOCX(LPCTSTR pszFile);
HRESULT GetDirectory(
                UINT nDirType, 
                LPTSTR szDirBuffer, 
                int nBufSize, 
                LPCTSTR szOCXFullName = NULL);
/*
HRESULT GetTypeLibId(
                LPCTSTR lpszClientClsId, 
                LPTSTR lpszTypeLibId, 
                LONG* pLibIdSize);
*/
HRESULT CleanInterfaceEntries(LPCTSTR lpszTypeLibCLSID);
HRESULT ConvertToLongFileName(
                LPTSTR lpszShortFileName,
                BOOL bToUpper = FALSE);

void RemoveList(LPCLSIDLIST_ITEM lpListHead);
BOOL ReadInfFileNameFromRegistry(LPCTSTR lpszCLSID, LPTSTR lpszInf, LONG nBufLen);
BOOL WriteInfFileNameToRegistry(LPCTSTR lpszCLSID, LPTSTR lpszInf);

HRESULT FindDLLInModuleUsage(
      LPTSTR lpszFileName,
      LPCTSTR lpszCLSID,
      DWORD &iSubKey);
HRESULT
ExpandCommandLine(
    LPCSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[]);

BOOL PatternMatch(LPCTSTR szModName, LPTSTR szSectionName);

DWORD OCCGetLongPathName( LPTSTR szLong, LPCTSTR szShort, DWORD cchBuffer );

TCHAR *CatPathStrN( TCHAR *szDst, const TCHAR *szHead, const TCHAR *szTail, int cchDst );

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : CoTaskMemAlloc(cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) CoTaskMemFree(m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\view.cpp ===
#include "folder.h"
#include "item.h"
#include "utils.h"

#include <mluisupp.h>

///////////////////////////////////////////////////////////////////////////////
// View functions

const struct {
    short int iCol;
    short int ids;
    short int cchCol;
    short int iFmt;
} s_ControlFolder_cols[] = {
    {SI_CONTROL, IDS_COL_CONTROL, 20, LVCFMT_LEFT},
    {SI_STATUS, IDS_COL_STATUS, 20, LVCFMT_LEFT},
    {SI_TOTALSIZE, IDS_COL_TOTALSIZE, 18, LVCFMT_LEFT},
    {SI_CREATION, IDS_COL_CREATION, 18, LVCFMT_LEFT},
    {SI_LASTACCESS, IDS_COL_LASTACCESS, 18, LVCFMT_LEFT},
    {SI_VERSION, IDS_COL_VERSION, 18, LVCFMT_LEFT}
};

HRESULT ControlFolderView_Command(HWND hwnd, UINT uID)
{
    switch (uID)
    {
    case IDM_SORTBYNAME:
    case IDM_SORTBYSTATUS:
    case IDM_SORTBYTOTALSIZE:
    case IDM_SORTBYCREATION:
    case IDM_SORTBYLASTACCESS:
    case IDM_SORTBYVERSION:
        ShellFolderView_ReArrange(hwnd, uID - IDM_SORTBYNAME);
        break;

    default:
        return E_FAIL;
    }

    return NOERROR;
}

HMENU GetMenuFromID(HMENU hmenu, UINT idm)
{
    MENUITEMINFO mii = {sizeof(mii), MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0};
    GetMenuItemInfo(hmenu, idm, FALSE, &mii);
    return mii.hSubMenu;
}

UINT MergeMenuHierarchy(
                    HMENU hmenuDst, 
                    HMENU hmenuSrc, 
                    UINT idcMin, 
                    UINT idcMax)
{
    UINT idcMaxUsed = idcMin;
    int imi = GetMenuItemCount(hmenuSrc);

    while (--imi >= 0) 
    {
        MENUITEMINFO mii = {sizeof(mii), MIIM_ID | MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0};

        if (GetMenuItemInfo(hmenuSrc, imi, TRUE, &mii)) 
        {
            UINT idcT = Shell_MergeMenus(
                                  GetMenuFromID(hmenuDst, mii.wID),
                                  mii.hSubMenu, 
                                  0, idcMin, idcMax, 
                                  MM_ADDSEPARATOR|MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }
    return idcMaxUsed;
}

HRESULT ControlFolderView_MergeMenu(LPQCMINFO pqcm)
{
    HMENU hmenu = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_CONTROLFOLDER));
    Assert(hmenu != NULL);
    if (hmenu)
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID;
        mii.wID = SFVIDM_MENU_ARRANGE;
        SetMenuItemInfo(hmenu, 0, TRUE, &mii);
        MergeMenuHierarchy(pqcm->hmenu, hmenu, pqcm->idCmdFirst, pqcm->idCmdLast);
        DestroyMenu(hmenu);
    }
    return NOERROR;
}

HRESULT ControlFolderView_InitMenuPopup(
                                   HWND hwnd, 
                                   UINT idCmdFirst, 
                                   int nIndex, 
                                   HMENU hmenu)
{
    return NOERROR;
}

HRESULT ControlFolderView_OnGetDetailsOf(
                                    HWND hwnd, 
                                    UINT iColumn, 
                                    PDETAILSINFO pdi)
{
    BOOL bResult = TRUE;
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)pdi->pidl;

    if (iColumn >= NUM_COLUMNS)
        return E_NOTIMPL;

    pdi->str.uType = STRRET_CSTR;
    pdi->str.cStr[0] = '\0';

    // if NULL, asking for column info
    if (pcpidl == NULL)
    {
        MLLoadString(
              s_ControlFolder_cols[iColumn].ids, 
              pdi->str.cStr, 
              ARRAYSIZE(pdi->str.cStr));

        pdi->fmt = s_ControlFolder_cols[iColumn].iFmt;
        pdi->cxChar = s_ControlFolder_cols[iColumn].cchCol;

        return NOERROR;
    }
           
    switch (iColumn)
    {
    case SI_CONTROL:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_CONTROL));
        break;

    case SI_VERSION:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_VERSION));
        break;

    case SI_CREATION:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_CREATION));
        break;

    case SI_LASTACCESS:
        lstrcpy(pdi->str.cStr, GetStringInfo(pcpidl, SI_LASTACCESS));
        break;

    case SI_TOTALSIZE:
        GetSizeSaved(pcpidl, pdi->str.cStr);
        break;

    case SI_STATUS:
        GetStatus(pcpidl, pdi->str.cStr, sizeof(pdi->str.cStr));
        break;

    default:
        bResult = FALSE;
    }

    return (bResult ? NOERROR : E_FAIL);
}

HRESULT ControlFolderView_OnColumnClick(HWND hwnd, UINT iColumn)
{
    ShellFolderView_ReArrange(hwnd, iColumn);
    return NOERROR;
}

HRESULT ControlFolderView_DidDragDrop(HWND hwnd, IDataObject *pdo, DWORD dwEffect)
{
    HRESULT hr = E_FAIL;

    if (dwEffect & DROPEFFECT_MOVE)
    {
        CControlItem *pCItem;
        if (SUCCEEDED(pdo->QueryInterface(CLSID_ControlFolder, (void **)&pCItem)))
        {
            hr = pCItem->Remove(hwnd);
            pCItem->Release();
        }
    }

    return hr;
}

HRESULT CALLBACK ControlFolderView_ViewCallback(
                                     IShellView *psvOuter,
                                     IShellFolder *psf,
                                     HWND hwnd,
                                     UINT uMsg,
                                     WPARAM wParam,
                                     LPARAM lParam)
{
    HRESULT hres = NOERROR;

    switch (uMsg)
    {
    case DVM_GETHELPTEXT:
        {
            UINT id = LOWORD(wParam);
            UINT cchBuf = HIWORD(wParam);
            LPTSTR pszBuf = (LPTSTR)lParam;
            MLLoadString(id + IDS_HELP_SORTBYNAME ,pszBuf, cchBuf);
        }
        break;

    case DVM_DIDDRAGDROP:
        hres = ControlFolderView_DidDragDrop(
                                        hwnd, 
                                        (IDataObject*)lParam, 
                                        (DWORD)wParam);
        break;

    case DVM_INITMENUPOPUP:
        hres = ControlFolderView_InitMenuPopup(
                                           hwnd, 
                                           LOWORD(wParam), 
                                           HIWORD(wParam), 
                                           (HMENU)lParam);
        break;

    case DVM_INVOKECOMMAND:
        ControlFolderView_Command(hwnd, (UINT)wParam);
        break;

    case DVM_COLUMNCLICK:
        hres = ControlFolderView_OnColumnClick(hwnd, (UINT)wParam);
        break;

    case DVM_GETDETAILSOF:
        hres = ControlFolderView_OnGetDetailsOf(hwnd, (UINT)wParam, (PDETAILSINFO)lParam);
        break;

    case DVM_MERGEMENU:
        hres = ControlFolderView_MergeMenu((LPQCMINFO)lParam);
        break;

    case DVM_DEFVIEWMODE:
        *(FOLDERVIEWMODE *)lParam = FVM_DETAILS;
        break;

    default:
        hres = E_FAIL;
    }

    return hres;
}

HRESULT ControlFolderView_CreateInstance(
                                    CControlFolder *pCFolder, 
                                    LPCITEMIDLIST pidl, 
                                    void **ppvOut)
{
    CSFV csfv;

    csfv.cbSize = sizeof(csfv);
    csfv.pshf = (IShellFolder*)pCFolder;
    csfv.psvOuter = NULL;
    csfv.pidl = pidl;
    csfv.lEvents = SHCNE_DELETE | SHCNE_UPDATEITEM; // SHCNE_DISKEVENTS | SHCNE_ASSOCCHANGED | SHCNE_GLOBALEVENTS;
    csfv.pfnCallback = ControlFolderView_ViewCallback;
    csfv.fvm = (FOLDERVIEWMODE)0;         // Have defview restore the folder view mode

    return SHCreateShellFolderViewEx(&csfv, (IShellView**)ppvOut); // &this->psv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\debug.c ===
//
//
//

// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "packager"
#define SZ_MODULE           "PACKAGER"
#define DECLARE_DEBUG
#include <debug.h>


#undef DebugMsg
#define DebugMsg TraceMsg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by occache.rc
//
#define IDS_COL_CONTROL                 0
#define IDM_CTRL_VIEWCONTROL            0
#define IDS_COL_STATUS                  1
#define IDM_CTRL_REMOVECONTROL          1
#define IDS_COL_TOTALSIZE               2
#define IDM_CTRL_PROPERTIES             2
#define IDS_COL_CREATION                3
#define IDM_CTRL_UPDATE                 3
#define IDM_CTRL_SEND_NOTIFY            4
#define IDS_COL_LASTACCESS              4
#define IDS_COL_VERSION                 6
#define IDS_UNKNOWNDATA                 8
#define IDS_STATUS_INSTALLED            9
#define IDS_STATUS_SHARED               10
#define IDS_STATUS_DAMAGED              11
#define IDS_STATUS_UNKNOWN              12
#define IDS_MBTITLE_REMOVECONTROL       13
#define IDS_MBTITLE_SHARED              14
#define IDS_MBTITLE_SHAREVIOLATION      15
#define IDS_MBTITLE_REMOVEFAIL          16
#define IDS_WARNING_SINGLEREMOVAL       17
#define IDS_WARNING_MULTIPLEREMOVAL     18
#define IDS_WARNING_SHARED              19
#define IDS_ERROR_SHAREVIOLATION        20
#define IDS_ERROR_REMOVEFAIL            21
#define IDS_MSG_DEPENDENCY              22
#define IDS_LISTTITLE_FILENAME          23
#define IDS_LISTTITLE_FILESIZE          24
#define IDS_EXTENSION_INF               26
#define IDS_HELP_VIEWCONTROL            27
#define IDS_HELP_REMOVECONTROL          28
#define IDS_HELP_PROPERTIES             29
#define IDM_SORTBYNAME                  30
#define IDS_HELP_SORTBYNAME             30
#define IDM_SORTBYSTATUS                31
#define IDS_HELP_SORTBYSTATUS           31
#define IDM_SORTBYTOTALSIZE             32
#define IDS_HELP_SORTBYTOTALSIZE        32
#define IDM_SORTBYCREATION              33
#define IDS_HELP_SORTBYCREATION         33
#define IDM_SORTBYLASTACCESS            34
#define IDS_HELP_SORTBYLASTACCESS       34
#define IDM_SORTBYVERSION               35
#define IDS_HELP_SORTBYVERSION          35
#define IDS_MSG_SCHEDULING              36
#define IDS_VERSION_PAGE_HEADER         37
#define IDS_HELP_UPDATE                 38
#define IDS_CONTROL_INUSE               39
#define IDS_LISTTITLE_PACKAGENAME       40
#define IDS_ERROR_NOUNINSTALLACTION     41
#define IDS_MBTITLE_NOUNINSTALLACTION   42
#define IDS_STATUS_UNPLUGGED            43
#define IDS_UPDATE_CAPTION              44
#define IDS_WARNING_USERNOACCESS        45
#define IDS_LISTTITLE_NAMESPACE         46
#define IDS_PROPERTY_TYPE_ACTX          47
#define IDS_PROPERTY_TYPE_JAVA          48
#define IDS_PROPERTY_TYPE_MIXED         49
#define IDM_CTRL_SHOWALL                50
#define IDI_REMOTEFLD                   100
#define IDI_DEFAULTOCXICON              101
#define IDD_PROP_DEPENDENCY             101
#define IDI_DEPENDENCY                  102
#define IDD_PROP_GENERAL                102
#define IDR_CONTROLFOLDER               103
#define IDR_POPUP_CONTROLCONTEXT        104
#define IDR_FILE_MERGE                  105
#define IDD_PROP_UPDATE                 106
#define IDD_PROP_VERSION                108
#define IDD_PROP_EXPIRE                 109
#define IDI_DEFAULTJAVAICON             110
#define IDI_DEFAULTMIXEDICON            111
#define IDC_DEPENDENCYLIST              1001
#define IDC_STATIC_DESCRIPTION          1002
#define IDC_STATIC_ICON2                1003
#define IDC_PACKAGELIST                 1003
#define IDC_STATIC_SEPARATOR            1004
#define IDC_STATIC_ICON                 1005
#define IDC_STATIC_LABEL_VERSION        1006
#define IDC_STATIC_VERSION              1007
#define IDC_STATIC_LABEL_CREATION       1008
#define IDC_STATIC_VER_LABEL_DESCRIPTION 1008
#define IDC_STATIC_TYPE                 1009
#define IDC_STATIC_VER_LABEL_COMPANY    1009
#define IDC_STATIC_LABEL_LASTACCESS     1010
#define IDC_STATIC_VER_LABEL_LANGUAGE   1010
#define IDC_STATIC_LASTACCESS           1011
#define IDC_STATIC_VER_LABEL_COPYRIGHT  1011
#define IDC_STATIC_LABEL_TOTALSIZE      1012
#define IDC_STATIC_TOTALSIZE            1013
#define IDC_STATIC_VER_COMPANY          1013
#define IDC_STATIC_LABEL_CLSID          1014
#define IDC_STATIC_VER_LANGUAGE         1014
#define IDC_STATIC_LABEL_TYPE           1015
#define IDC_STATIC_VER_COPYRIGHT        1015
#define IDC_STATIC_LABEL_STATUS         1016
#define IDC_STATIC_STATUS               1017
#define IDC_STATIC_CONTROL              1018
#define IDC_STATIC_CLSID                1019
#define IDC_STATIC_CREATION             1020
#define IDC_CHECK_NEVERUPDATE           1020
#define IDC_CHECK_UPDATEPERIODICALLY    1021
#define IDC_EDIT_UPDATEINTERVAL         1022
#define IDC_STATIC_TIMELABEL            1023
#define IDC_BUTTON_UPDATENOW            1024
#define IDC_STATIC_VER_VERSION          1026
#define IDC_STATIC_VER_DESCRIPTION      1027
#define IDC_STATIC_VER_LABEL_VERSION    1028
#define IDC_STATIC_VER_HEADING          1029
#define IDR_POPUP_CONTROLCONTEXT_NO_UPDATE 1030
/*
#define IDC_STATIC_EXPIRE               1041
#define IDC_EDIT_EXPIRE                 1042
#define IDC_SPIN_EXPIRE                 1043
#define IDC_STATIC_EXPIRE_DAYS          1044
*/
#define IDC_STATIC_LABEL_CODEBASE       1050
#define IDC_STATIC_CODEBASE             1051
#define IDC_STATIC_CONTROLNAME          -1

#define IDS_OCCACHE_WARNING_DEPENDENCY_REMOVAL        1060
#define IDS_OCCACHE_WARNING_DEP_REMOVAL_NAME_UNKNOWN  1061
#define IDS_OCCACHE_WARNING_JAVA_SYSTEM_CLASS         1062
#define IDS_REMOVAL_WARNING                           1063
#define IDS_PROPERTY_BYTES                            1064
#define IDS_KILOBYTE_ABBREV                           1065

//
// AVI files
//

#define IDA_DOWNLOAD            0x4800

//
// Dialogs
//

#define IDD_OCUPDATE            0x5000
#define IDC_DOWNLOADPROGRESS    0x0100
#define IDC_DOWNLOADMSG         0x0101
#define IDC_DOWNLOADANIMATE     0x0102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\iadvsink.cpp ===
#include "privcpp.h"


CPackage_IAdviseSink::CPackage_IAdviseSink(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0);
}

CPackage_IAdviseSink::~CPackage_IAdviseSink()
{
    DebugMsg(DM_TRACE,"CPackage_IAdviseSink destroyed with ref count %d",_cRef);
}


//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IAdviseSink::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);
}

ULONG CPackage_IAdviseSink::AddRef(void) 
{
    _cRef++;    // interface ref count for debugging
    return _pPackage->AddRef();
}

ULONG CPackage_IAdviseSink::Release(void)
{
    _cRef--;    // interface ref count for debugging
    return _pPackage->Release();
}

//////////////////////////////////
//
// IAdviseSink Methods...
//

void CPackage_IAdviseSink::OnDataChange(LPFORMATETC, LPSTGMEDIUM)
{
    // NOTE: currently, we never set up a data advise connection with
    // anyone, but if we ever do, we'll want to set our dirty flag
    // when we get a datachange notificaiton.
    
    DebugMsg(DM_TRACE, "pack as - OnDataChange() called.");
    // when we get a data change notification, set our dirty flag
    _pPackage->_fIsDirty = TRUE;
    return;
}


void CPackage_IAdviseSink::OnViewChange(DWORD, LONG) 
{
    DebugMsg(DM_TRACE, "pack as - OnViewChange() called.");
    //
    // there's nothing to do here....we don't care about view changes.
    // we are always viewed as an icon and that can't be changed by the server
    // which is run when the contents are activated.  the icon can
    // only be changed through the edit package verb
    //
    return;
}

void CPackage_IAdviseSink::OnRename(LPMONIKER)
{
    DebugMsg(DM_TRACE, "pack as - OnRename() called.");
    //
    // once again, nothing to do here...if the user for some unknown reason
    // tries to save the packaged file by a different name when he's done
    // editing the contents then we'll just give not receive those changes.
    // why would anyone want to rename a temporary file, anyway?
    //
    return;
}

void CPackage_IAdviseSink::OnSave(void)
{
    DebugMsg(DM_TRACE, "pack as - OnSave() called.");

    // if the contents have been saved, then our storage is out of date,
    // so set our dirty flag, then the container can choose to save us or not
    _pPackage->_fIsDirty = TRUE;

    // NOTE: even though Word sends us OnSave, it doesn't actually save
    // the file.  Getting IPersistFile here and calling Save
    // fails with RPC_E_CANTCALLOUT_INASYNCCALL.  W2K didn't pick
    // up Word's save either...

    // we just notifiy our own container that we've been saved and it 
    // can do whatever it wants to.
    if (_pPackage->_pIOleAdviseHolder)
        _pPackage->_pIOleAdviseHolder->SendOnSave();
}

void CPackage_IAdviseSink::OnClose(void) 
{
    DebugMsg(DM_TRACE, "pack as - OnClose() called.");

    switch(_pPackage->_panetype)
    {
    case PEMBED:
        // get rid of advsiory connnection
        _pPackage->_pEmbed->poo->Unadvise(_pPackage->_dwCookie);
        _pPackage->_pEmbed->poo->Release();
        _pPackage->_pEmbed->poo = NULL;

        // this updates the size of the packaged file in our _pPackage->_pEmbed
        if (FAILED(_pPackage->EmbedInitFromFile(_pPackage->_pEmbed->pszTempName, FALSE)))
        {
            ShellMessageBox(g_hinst,
                            NULL,
                            MAKEINTRESOURCE(IDS_UPDATE_ERROR),
                            MAKEINTRESOURCE(IDS_APP_TITLE),
                            MB_TASKMODAL | MB_ICONERROR | MB_OK);
        }

        if (FAILED(_pPackage->_pIOleClientSite->SaveObject()))
        {
            ShellMessageBox(g_hinst,
                            NULL,
                            MAKEINTRESOURCE(IDS_UPDATE_ERROR),
                            MAKEINTRESOURCE(IDS_APP_TITLE),
                            MB_TASKMODAL | MB_ICONERROR | MB_OK);
        }

        if (_pPackage->_pIOleAdviseHolder)
            _pPackage->_pIOleAdviseHolder->SendOnSave();

        if (!_pPackage->_fNoIOleClientSiteCalls)
            _pPackage->_pIOleClientSite->OnShowWindow(FALSE);

        // we just notify out own container that we've been closed and let
        // it do whatever it wants to.
        if (_pPackage->_pIOleAdviseHolder)
            _pPackage->_pIOleAdviseHolder->SendOnClose();

        break;

    case CMDLINK:
        // there shouldn't be anything to do here, since a CMDLINK is always
        // executed using ShellExecute and never through OLE, so who would be
        // setting up an advisory connection with the package?
        break;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\occache\property.cpp ===
#include "item.h"
#include "parseinf.h"
#include <mstask.h>
#include <iehelpid.h>
#include "parseinf.h"

#include <mluisupp.h>

#ifdef AUTO_UPDATE
#define NUM_PAGES 4
#else
#define NUM_PAGES 3
#endif

#define DEFAULT_LANG_CODEPAGE_PAIR                   0x040904B0
#define MAX_QUERYPREFIX_LEN                          512
#define MAX_QUERYSTRING_LEN                          1024

// defined in utils.cpp
extern LPCTSTR g_lpszUpdateInfo;
extern LPCTSTR g_lpszCookieValue;
extern LPCTSTR g_lpszSavedValue;

///////////////////////////////////////////////////////////////////////////////
// functions that deal with web check

// define a macro to make life easier
#define QUIT_IF_FAIL if (FAILED(hr)) goto Exit

void DestroyDialogIcon(HWND hDlg)
{
    HICON hIcon = (HICON)SendDlgItemMessage(
                                   hDlg, IDC_STATIC_ICON, 
                                   STM_GETICON, 0, 0);
    if (hIcon != NULL)
       DestroyIcon(hIcon);

}

  
///////////////////////////////////////////////////////////////////////////////
// functions that deal with property page 1

void InitPropPage1(HWND hDlg, LPARAM lParam)
{
    BOOL bHasActiveX;
    BOOL bHasJava;

    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)((LPPROPSHEETPAGE)lParam)->lParam;
    if (pcpidl)
    {
        // draw control icon
        {
            HICON hIcon = ExtractIcon(g_hInst, GetStringInfo(pcpidl, SI_LOCATION), 0);
            if (hIcon == NULL)
                hIcon = GetDefaultOCIcon( pcpidl );
            Assert(hIcon != NULL);
            SendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);
        }

        SetDlgItemText(hDlg, IDC_STATIC_CONTROL, GetStringInfo(pcpidl, SI_CONTROL));
        SetDlgItemText(hDlg, IDC_STATIC_CREATION, GetStringInfo(pcpidl, SI_CREATION));
        SetDlgItemText(hDlg, IDC_STATIC_LASTACCESS, GetStringInfo(pcpidl, SI_LASTACCESS));
        SetDlgItemText(hDlg, IDC_STATIC_CLSID, GetStringInfo(pcpidl, SI_CLSID));
        SetDlgItemText(hDlg, IDC_STATIC_CODEBASE, GetStringInfo(pcpidl, SI_CODEBASE));

        TCHAR szBuf[MESSAGE_MAXSIZE];


        GetContentBools( pcpidl, &bHasActiveX, &bHasJava );
        if ( bHasJava )
        {
            if ( bHasActiveX )
                MLLoadString(IDS_PROPERTY_TYPE_MIXED, szBuf, MESSAGE_MAXSIZE);
            else
                MLLoadString(IDS_PROPERTY_TYPE_JAVA, szBuf, MESSAGE_MAXSIZE);
        }
        else
            MLLoadString(IDS_PROPERTY_TYPE_ACTX, szBuf, MESSAGE_MAXSIZE);

        SetDlgItemText(hDlg, IDC_STATIC_TYPE, szBuf);

        GetStatus(pcpidl, szBuf, MESSAGE_MAXSIZE);
        SetDlgItemText(hDlg, IDC_STATIC_STATUS, szBuf);

        DWORD dwSizeSaved = GetSizeSaved(pcpidl);
        TCHAR szSize[20];
        wsprintf(szSize, "%u", dwSizeSaved);
    
        // insert commas to separate groups of digits
        int nLen = lstrlen(szSize);
        int i = 0, j = (nLen <= 3 ? nLen : (nLen % 3));
        TCHAR *pCh = szSize + j;

        for (; i < j; i++)
            szBuf[i] = szSize[i];

        for (; *pCh != '\0'; i++, pCh++)
        {
            if (((pCh - szSize) % 3 == j) && (i > 0))
                szBuf[i++] = ',';
            szBuf[i] = *pCh;
        }
        szBuf[i] = '\0';

        TCHAR szBytes[BYTES_MAXSIZE];

        MLLoadString(IDS_PROPERTY_BYTES, szBytes, BYTES_MAXSIZE);
        lstrcat(szBuf, TEXT(" "));
        lstrcat(szBuf, szBytes);
        lstrcat(szBuf, TEXT("  ("));

        GetSizeSaved(pcpidl, szBuf + lstrlen(szBuf));
        lstrcat(szBuf, TEXT(")"));
        SetDlgItemText(hDlg, IDC_STATIC_TOTALSIZE, szBuf);
    }
}

// Dialog proc for page 1
INT_PTR CALLBACK ControlItem_PropPage1Proc(
                                  HWND hDlg, 
                                  UINT message, 
                                  WPARAM wParam, 
                                  LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCONTROLPIDL pcpidl = lpPropSheet ? (LPCONTROLPIDL)lpPropSheet->lParam : NULL;

    const static DWORD aIds[] = {
        IDC_STATIC_LABEL_TYPE, IDH_DLOAD_TYPE,
        IDC_STATIC_LABEL_CREATION, IDH_DLOAD_CREATED,
        IDC_STATIC_LABEL_LASTACCESS, IDH_DLOAD_LASTACC,
        IDC_STATIC_LABEL_TOTALSIZE, IDH_DLOAD_TOTALSIZE,
        IDC_STATIC_LABEL_CLSID, IDH_DLOAD_ID,
        IDC_STATIC_LABEL_STATUS, IDH_DLOAD_STATUS,
        IDC_STATIC_LABEL_CODEBASE, IDH_DLOAD_CODEBASE,
        IDC_STATIC_TYPE, IDH_DLOAD_TYPE,
        IDC_STATIC_CREATION, IDH_DLOAD_CREATED,
        IDC_STATIC_LASTACCESS, IDH_DLOAD_LASTACC,
        IDC_STATIC_TOTALSIZE, IDH_DLOAD_TOTALSIZE,
        IDC_STATIC_CLSID, IDH_DLOAD_ID,
        IDC_STATIC_STATUS, IDH_DLOAD_STATUS,
        IDC_STATIC_CODEBASE, IDH_DLOAD_CODEBASE,
        IDC_STATIC_CONTROL, IDH_DLOAD_OBJNAME,
        0, 0 
    };

    switch(message) 
    {
    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle), "iexplore.hlp", HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND)wParam, "iexplore.hlp", HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aIds);
        break;
    
    case WM_INITDIALOG:
        InitPropPage1(hDlg, lParam);
        break;            
    
    case WM_DESTROY:
        DestroyDialogIcon(hDlg);
        break;

    case WM_COMMAND:
        // user can't change anything, so we don't care about any messages

        break;

    default:
        return FALSE;
        
    } // end of switch
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// functions that deal with property page 2

int ListCtrl_InsertColumn(
                       HWND hwnd,
                       int nCol, 
                       LPCTSTR lpszColumnHeading, 
                       int nFormat,
                           int nWidth, 
                       int nSubItem)
{
        LV_COLUMN column;
        column.mask = LVCF_TEXT|LVCF_FMT;
        column.pszText = (LPTSTR)lpszColumnHeading;
        column.fmt = nFormat;
        if (nWidth != -1)
        {
                column.mask |= LVCF_WIDTH;
                column.cx = nWidth;
        }
        if (nSubItem != -1)
        {
                column.mask |= LVCF_SUBITEM;
                column.iSubItem = nSubItem;
        }

    return (int)::SendMessage(hwnd, LVM_INSERTCOLUMN, nCol, (LPARAM)&column);
}

BOOL ListCtrl_SetItemText(
                     HWND hwnd,
                     int nItem, 
                     int nSubItem, 
                     LPCTSTR lpszItem)
{
        LV_ITEM lvi;
        lvi.mask = LVIF_TEXT;
        lvi.iItem = nItem;
        lvi.iSubItem = nSubItem;
        lvi.stateMask = 0;
        lvi.state = 0;
        lvi.pszText = (LPTSTR) lpszItem;
        lvi.iImage = 0;
        lvi.lParam = 0;
        return (BOOL)::SendMessage(hwnd, LVM_SETITEM, 0, (LPARAM)&lvi);
}

int ListCtrl_InsertItem(
                     HWND hwnd,
                     UINT nMask, 
                     int nItem, 
                     LPCTSTR lpszItem, 
                     UINT nState, 
                     UINT nStateMask,
                         int nImage, 
                     LPARAM lParam)
{
        LV_ITEM item;
        item.mask = nMask;
        item.iItem = nItem;
        item.iSubItem = 0;
        item.pszText = (LPTSTR)lpszItem;
        item.state = nState;
        item.stateMask = nStateMask;
        item.iImage = nImage;
        item.lParam = lParam;

    return (int)::SendMessage(hwnd, LVM_INSERTITEM, 0, (LPARAM)&item);
}

void InitPropPage2(HWND hDlg, LPARAM lParam)
{
    int                iFileNameWidth = 0;

    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)((LPPROPSHEETPAGE)lParam)->lParam;
    UINT cTotalFiles = GetTotalNumOfFiles(pcpidl);

    {
        HICON hIcon = ExtractIcon(g_hInst, GetStringInfo(pcpidl, SI_LOCATION), 0);
        if (hIcon == NULL)
            hIcon = GetDefaultOCIcon( pcpidl );
        Assert(hIcon != NULL);
        SendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    // insert columns into file list box
    RECT rect;
    int nWidth;
    TCHAR szBuf[MAX_PATH];
    HWND hwndCtrl = GetDlgItem(hDlg, IDC_DEPENDENCYLIST);

    Assert(::IsWindow(hwndCtrl));
    GetClientRect(hwndCtrl, &rect);
    nWidth = rect.right - rect.left;

    MLLoadString(IDS_LISTTITLE_FILENAME, szBuf, MAX_PATH);
    iFileNameWidth = nWidth * 7 / 10;
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      0, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      iFileNameWidth, 0);

    MLLoadString(IDS_LISTTITLE_FILESIZE, szBuf, MAX_PATH);
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      1, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      nWidth * 3 / 10, 
                      0);

    // insert dependent files into list box
    int iIndex = -1;
    LONG lResult = ERROR_SUCCESS;
    DWORD dwFileSize = 0;
    BOOL bOCXRemovable = IsModuleRemovable(GetStringInfo(pcpidl, SI_LOCATION));

        for (UINT iFile = 0; iFile < cTotalFiles; iFile++)
        {
            if (!GetDependentFile(pcpidl, iFile, szBuf, &dwFileSize))
            {
                Assert(FALSE);
                break;
            }

            // put a star after file name if file is not safe for removal
            if (!bOCXRemovable)
            {
                lstrcat(szBuf, TEXT("*"));
            }
            else if (!IsModuleRemovable(szBuf))
            {
                // check if it is inf file.
                TCHAR szExt[10];
                MLLoadString(IDS_EXTENSION_INF, szExt, 10);
                int nLen = lstrlen(szBuf);
                int nLenExt = lstrlen(szExt);
                if ((nLen > nLenExt) && 
                    (lstrcmpi(szBuf+(nLen-nLenExt), szExt) != 0))
                    lstrcat(szBuf, TEXT("*"));
            }            

            PathCompactPath(NULL, szBuf, iFileNameWidth);
            iIndex = ListCtrl_InsertItem(hwndCtrl, LVIF_TEXT, iFile, szBuf, 0, 0, 0, 0);

            if (dwFileSize > 0)
            {
                TCHAR szBuf2[100];
                wsprintf(szBuf2, "%u", dwFileSize);
            
                // insert commas to separate groups of digits
                int nLen = lstrlen(szBuf2);
                int i = 0, j = (nLen <= 3 ? nLen : (nLen % 3));
                TCHAR *pCh = szBuf2 + j;

                for (; i < j; i++)
                    szBuf[i] = szBuf2[i];

                for (; *pCh != '\0'; i++, pCh++)
                {
                    if (((pCh - szBuf2) % 3 == j) && (i > 0))
                        szBuf[i++] = ',';
                    szBuf[i] = *pCh;
                }
                szBuf[i] = '\0';
            }
            else
                MLLoadString(IDS_STATUS_DAMAGED, szBuf, MAX_PATH);

            ListCtrl_SetItemText(hwndCtrl, iIndex, 1, szBuf);
        }

    // insert columns into file list box
    hwndCtrl = GetDlgItem(hDlg, IDC_PACKAGELIST);

    Assert(::IsWindow(hwndCtrl));
    GetClientRect(hwndCtrl, &rect);
    nWidth = (rect.right - rect.left) / 2;

    MLLoadString(IDS_LISTTITLE_PACKAGENAME, szBuf, MAX_PATH);
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      0, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      nWidth, 0);

    MLLoadString(IDS_LISTTITLE_NAMESPACE, szBuf, MAX_PATH);
    ListCtrl_InsertColumn(
                      hwndCtrl, 
                      1, 
                      szBuf, 
                      LVCFMT_LEFT, 
                      nWidth, 0);

    // insert dependent packages into list box
    UINT         cTotalPackages = 0;;

    if ( pcpidl->ci.dwIsDistUnit )
    {
        CParseInf    parseInf;

        if ( SUCCEEDED(parseInf.DoParseDU( GetStringInfo( pcpidl, SI_LOCATION), GetStringInfo( pcpidl,SI_CLSID ))) )
        {
            CPackageNode *ppn;

            for ( ppn = parseInf.GetFirstPackage();
                  ppn != NULL;
                  ppn = parseInf.GetNextPackage(), cTotalPackages++ )
            {
                iIndex = ListCtrl_InsertItem(hwndCtrl, LVIF_TEXT, cTotalPackages, ppn->GetName(), 0, 0, 0, 0);
                ListCtrl_SetItemText(hwndCtrl, iIndex, 1, ppn->GetNamespace());
            }
        }
    }

     // update description
    {
        TCHAR szMsg[MESSAGE_MAXSIZE];
        TCHAR szBuf[MESSAGE_MAXSIZE];
        // BUG: This is not the correct way to make va_list for Alpha
        DWORD_PTR adwArgs[3];
        adwArgs[0] =  cTotalFiles;
        adwArgs[1] =  cTotalPackages;
        adwArgs[2] =  (DWORD_PTR) GetStringInfo(pcpidl, SI_CONTROL);
        MLLoadString(IDS_MSG_DEPENDENCY, szBuf, MESSAGE_MAXSIZE);
        FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                       szBuf, 0, 0, szMsg, MESSAGE_MAXSIZE, (va_list*)adwArgs );
        SetDlgItemText(hDlg, IDC_STATIC_DESCRIPTION, szMsg);
    }
}

// Dialog proc for page 2
INT_PTR CALLBACK ControlItem_PropPage2Proc(
                                  HWND hDlg, 
                                  UINT message, 
                                  WPARAM wParam, 
                                  LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCONTROLPIDL pcpidl = lpPropSheet ? (LPCONTROLPIDL)lpPropSheet->lParam : NULL;

    const static DWORD aIds[] = {
        IDC_DEPENDENCYLIST, IDH_DLOAD_FILE_DEP,
        IDC_PACKAGELIST, IDH_DLOAD_JAVAPKG_DEP,
        0, 0 
    };

    switch(message) 
    {
    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle), "iexplore.hlp", HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND)wParam, "iexplore.hlp", HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aIds);
        break;
    
    case WM_INITDIALOG:
        InitPropPage2(hDlg, lParam);
        break;            
    
    case WM_DESTROY:
        DestroyDialogIcon(hDlg);
        break;

    case WM_COMMAND:
        break;

    default:
        return FALSE;
    } // end of switch
    
    return TRUE;
}

#if 0
// Do UI update
BOOL Page3_OnCommand(HWND hDlg, WORD wCmd)
{
    HWND hwnd = GetDlgItem(hDlg, IDC_CHECK_NEVERUPDATE);
    Assert(hwnd != NULL);

    // if top check box is checked, disable the edit box
    BOOL bEnable = ((int)::SendMessage(hwnd, BM_GETCHECK, 0, 0) != 1);

    hwnd = GetDlgItem(hDlg, IDC_EDIT_UPDATEINTERVAL);
    Assert(hwnd != NULL);

    EnableWindow(hwnd, bEnable);

    // if top check box is not checked and edit box does not
    // have the focus and it is empty, put in default interval
    if (bEnable && (GetFocus() != hwnd))
    {
        TCHAR szText[10];
        if (GetWindowText(hwnd, szText, 10) == 0)
        {
            // wsprintf(szText, "%i", g_dwDefaultInterval);
            SetWindowText(hwnd, szText);
        }
    }

    return TRUE;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// functions that deal with property page 4

void InitPropPage4(HWND hDlg, LPARAM lParam)
{
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    LPCONTROLPIDL pcpidl = (LPCONTROLPIDL)((LPPROPSHEETPAGE)lParam)->lParam;

    LPTSTR lpszFileName = (LPTSTR)GetStringInfo(pcpidl, SI_LOCATION);

    TCHAR szBuf[MESSAGE_MAXSIZE];
    DWORD dwHandle = 0, dwSizeVer = 0;
    LPTSTR lpBuffer = NULL;
    UINT uSize = 0;
    LPVOID lpVerData = NULL;
    UINT uLen = 0;
    DWORD dwLangCodePage = 0;
    char szQueryPrefix[MAX_QUERYPREFIX_LEN];
    char szQueryString[MAX_QUERYSTRING_LEN];
            

    // draw control icon
    {
        LPCTSTR pszIcon = GetStringInfo(pcpidl, SI_LOCATION);
        HICON hIcon = NULL;
        if (!pszIcon || !(hIcon = ExtractIcon(g_hInst, pszIcon, 0)))
        {
            hIcon = GetDefaultOCIcon( pcpidl );
        }
        Assert(hIcon != NULL);
        SendDlgItemMessage(hDlg, IDC_STATIC_ICON, STM_SETICON, (WPARAM)hIcon, 0);
    }

    // set page header
    if (MLLoadString(IDS_VERSION_PAGE_HEADER, szBuf, MESSAGE_MAXSIZE))
    {
        TCHAR szHeading[MESSAGE_MAXSIZE];
        LPCTSTR pszControl = GetStringInfo(pcpidl, SI_CONTROL);
        if (pszControl)
        {
            wsprintf(szHeading, szBuf, pszControl);
            SetDlgItemText(hDlg, IDC_STATIC_VER_HEADING, szHeading);
        }
    }

    // set Version field
    LPCTSTR pszVersion = GetStringInfo(pcpidl, SI_VERSION);
    if (!pszVersion)
        return;

    SetDlgItemText(hDlg, IDC_STATIC_VER_VERSION, pszVersion);

    if (!lpszFileName)
        return;

    dwSizeVer = GetFileVersionInfoSize(lpszFileName, &dwHandle);
    if (dwSizeVer <= 0)
        return;

    BYTE *pbData = new BYTE[dwSizeVer];
    if (pbData == NULL)
        return;

    if (GetFileVersionInfo(lpszFileName, 0, dwSizeVer, pbData))
    {
        // Get correct codepage information

        if (!VerQueryValue(pbData, "\\VarFileInfo\\Translation", &lpVerData, &uLen))
        {
            wsprintf(szQueryPrefix, "\\StringFileInfo\\%x\\CompanyName", DEFAULT_LANG_CODEPAGE_PAIR);
        }
        else
        {
            char szLangCodePad[9];
            char szVBufPad[5], szVBuf[5];     // To fit a DWORD (padded)
            ASSERT(lpVerData);
            wnsprintf(szVBuf, ARRAYSIZE(szVBuf), "%x", LOWORD(*((DWORD *)lpVerData)));
            
            // Pad the low word to 4 digits

            lstrcpyn(szVBufPad, "0000", ARRAYSIZE(szVBufPad));
            char *pszTmp = szVBufPad + (4 - lstrlen(szVBuf));
            ASSERT(pszTmp > szVBufPad);
            lstrcpy(pszTmp, szVBuf);

            lstrcpyn(szLangCodePad, szVBufPad, ARRAYSIZE(szLangCodePad));

            // Pad the high word to 4 digits

            wnsprintf(szVBuf, ARRAYSIZE(szVBuf), "%x", HIWORD(*((DWORD *)lpVerData)));
            lstrcpy(szVBufPad, "0000");
            pszTmp = szVBufPad + (4 - lstrlen(szVBuf));
            ASSERT(pszTmp > szVBufPad);
            lstrcpy(pszTmp, szVBuf);

            // Concatenate to get a codepage/lang-id string
            lstrcatn(szLangCodePad, szVBufPad, ARRAYSIZE(szLangCodePad));

            lstrcpy(szQueryPrefix, "\\StringFileInfo\\");
            lstrcat(szQueryPrefix, szLangCodePad);
        }

        // set Company field
        wnsprintf(szQueryString, ARRAYSIZE(szQueryString), "%s\\CompanyName", szQueryPrefix);
        if (VerQueryValue(pbData, szQueryString, (void **)&lpBuffer, &uSize))
            SetDlgItemText(hDlg, IDC_STATIC_VER_COMPANY, lpBuffer);
        
        // set Description field
        wnsprintf(szQueryString, ARRAYSIZE(szQueryString), "%s\\FileDescription", szQueryPrefix);
        if (VerQueryValue(pbData, szQueryString, (void **)&lpBuffer, &uSize))
            SetDlgItemText(hDlg, IDC_STATIC_VER_DESCRIPTION, lpBuffer);

        // set CopyRight field
        wnsprintf(szQueryString, ARRAYSIZE(szQueryString), "%s\\LegalCopyright", szQueryPrefix);
        if (VerQueryValue(pbData, szQueryString, (void **)&lpBuffer, &uSize))
            SetDlgItemText(hDlg, IDC_STATIC_VER_COPYRIGHT, lpBuffer);

        // set Language field
        if (VerQueryValue(pbData, TEXT("\\VarFileInfo\\Translation"), (void **)&lpBuffer, &uSize))
        {
            LPWORD lpLangId = (LPWORD)lpBuffer;
            VerLanguageName(*lpLangId, szBuf, MESSAGE_MAXSIZE);
            SetDlgItemText(hDlg, IDC_STATIC_VER_LANGUAGE, szBuf);
        }
    }

    delete [] pbData;
}

// Dialog proc for page 4
INT_PTR CALLBACK ControlItem_PropPage4Proc(
                                  HWND hDlg, 
                                  UINT message, 
                                  WPARAM wParam, 
                                  LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet = (LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    LPCONTROLPIDL pcpidl = lpPropSheet ? (LPCONTROLPIDL)lpPropSheet->lParam : NULL;

    const static DWORD aIds[] = {
        IDC_STATIC_VER_LABEL_VERSION, IDH_DLOAD_VERSION,
        IDC_STATIC_VER_LABEL_DESCRIPTION, IDH_DLOAD_DESC,
        IDC_STATIC_VER_LABEL_COMPANY, IDH_DLOAD_COMPANY,
        IDC_STATIC_VER_LABEL_LANGUAGE, IDH_DLOAD_LANG,
        IDC_STATIC_VER_LABEL_COPYRIGHT, IDH_DLOAD_COPYRIGHT,
        IDC_STATIC_VER_VERSION, IDH_DLOAD_VERSION,
        IDC_STATIC_VER_DESCRIPTION, IDH_DLOAD_DESC,
        IDC_STATIC_VER_COMPANY, IDH_DLOAD_COMPANY,
        IDC_STATIC_VER_LANGUAGE, IDH_DLOAD_LANG,
        IDC_STATIC_VER_COPYRIGHT, IDH_DLOAD_COPYRIGHT,
        IDC_STATIC_CONTROL, IDH_DLOAD_OBJNAME,
        0, 0 
    };

    switch(message) 
    {
        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle), "iexplore.hlp", HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND)wParam, "iexplore.hlp", HELP_CONTEXTMENU, (DWORD_PTR)(LPVOID)aIds);
            break;
        
        case WM_INITDIALOG:
            InitPropPage4(hDlg, lParam);
            break;            
        
        case WM_DESTROY:
            DestroyDialogIcon(hDlg);
            break;

        case WM_COMMAND:
            // user can't change anything, so we don't care about any messages

            break;

        default:
            return FALSE;
            
    } // end of switch
    
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// functions that deal with property dialog

HRESULT CreatePropDialog(HWND hwnd, LPCONTROLPIDL pcpidl) 
{
#ifdef AUTO_UPDATE
    PROPSHEETPAGE psp[NUM_PAGES] = {{0},{0},{0},{0}};
#else
    PROPSHEETPAGE psp[NUM_PAGES] = {{0},{0},{0}};
#endif
    PROPSHEETHEADER psh = {0};

    // initialize propsheet page 1.
    psp[0].dwSize          = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags         = 0;
    psp[0].hInstance       = MLGetHinst();
    psp[0].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_GENERAL);
    psp[0].pszIcon         = NULL;
    psp[0].pfnDlgProc      = ControlItem_PropPage1Proc;
    psp[0].pszTitle        = NULL;
    psp[0].lParam          = (LPARAM)pcpidl; // send it the cache entry struct

    // initialize propsheet page 2.
    psp[1].dwSize          = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags         = 0;
    psp[1].hInstance       = MLGetHinst();
    psp[1].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_DEPENDENCY);
    psp[1].pszIcon         = NULL;
    psp[1].pfnDlgProc      = ControlItem_PropPage2Proc;
    psp[1].pszTitle        = NULL;
    psp[1].lParam          = (LPARAM)pcpidl; // send it the cache entry struct


#ifdef AUTO_UPDATE
    // initialize propsheet page 3.
    psp[2].dwSize          = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags         = 0;
    psp[2].hInstance       = MLGetHinst();
    psp[2].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_UPDATE);
    psp[2].pszIcon         = NULL;
    psp[2].pfnDlgProc      = ControlItem_PropPage3Proc;
    psp[2].pszTitle        = NULL;
    psp[2].lParam          = (LPARAM)pcpidl; // send it the cache entry struct
#endif

    // initialize propsheet page 4.
    psp[NUM_PAGES-1].dwSize          = sizeof(PROPSHEETPAGE);
    psp[NUM_PAGES-1].dwFlags         = 0;
    psp[NUM_PAGES-1].hInstance       = MLGetHinst();
    psp[NUM_PAGES-1].pszTemplate     = MAKEINTRESOURCE(IDD_PROP_VERSION);
    psp[NUM_PAGES-1].pszIcon         = NULL;
    psp[NUM_PAGES-1].pfnDlgProc      = ControlItem_PropPage4Proc;
    psp[NUM_PAGES-1].pszTitle        = NULL;
    psp[NUM_PAGES-1].lParam          = (LPARAM)pcpidl; // send it the cache entry struct

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPSHEETPAGE|PSH_NOAPPLYNOW|PSH_PROPTITLE;
    psh.hwndParent  = hwnd;
    psh.pszCaption  = GetStringInfo(pcpidl, SI_CONTROL);
    psh.nPages      = NUM_PAGES;
    psh.nStartPage  = 0;
    psh.ppsp        = (LPCPROPSHEETPAGE)&psp;

    // invoke the property sheet
    PropertySheet(&psh);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\ioleobj.cpp ===
#include "privcpp.h"

HWND            g_hTaskWnd;
BOOL CALLBACK GetTaskWndProc(HWND hwnd, DWORD lParam);
DWORD CALLBACK MainWaitOnChildThreadProc(void *lpv);

typedef struct {
    CPackage_IOleObject *pObj;
    HANDLE h;
} MAINWAITONCHILD;

CPackage_IOleObject::CPackage_IOleObject(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0); 
}

CPackage_IOleObject::~CPackage_IOleObject()
{
    DebugMsg(DM_TRACE,"CPackage_IOleObject destroyed with ref count %d",_cRef);
}


//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IOleObject::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);
}

ULONG CPackage_IOleObject::AddRef(void) 
{
    _cRef++;    // interface ref count for debugging
    return _pPackage->AddRef();
}

ULONG CPackage_IOleObject::Release(void)
{
    _cRef--;    // interface ref count for debugging
    return _pPackage->Release();
}

//////////////////////////////////
//
// IOleObject Methods...
//
HRESULT CPackage_IOleObject::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    DebugMsg(DM_TRACE, "pack oo - SetClientSite() called.");

    if (!pClientSite)
        return E_POINTER;

    if (_pPackage->_pIOleClientSite != NULL)
        _pPackage->_pIOleClientSite->Release();
    
    _pPackage->_pIOleClientSite = pClientSite;
    _pPackage->_pIOleClientSite->AddRef();
    return S_OK;
}

HRESULT CPackage_IOleObject::GetClientSite(LPOLECLIENTSITE *ppClientSite) 
{
    DebugMsg(DM_TRACE, "pack oo - GetClientSite() called.");

    if (ppClientSite == NULL)
        return E_INVALIDARG;
    
    // Be sure to AddRef the pointer we're giving away.
    *ppClientSite = _pPackage->_pIOleClientSite;
    _pPackage->_pIOleClientSite->AddRef();
    
    return S_OK;
}

HRESULT CPackage_IOleObject::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    DebugMsg(DM_TRACE, "pack oo - SetHostNames() called.");

    delete _pPackage->_lpszContainerApp;
    
    if (NULL != (_pPackage->_lpszContainerApp = new OLECHAR[lstrlenW(szContainerApp) + 1]))
    {
        lstrcpyW(_pPackage->_lpszContainerApp,szContainerApp);
    }
    
    delete _pPackage->_lpszContainerObj;
    
    if (NULL != (_pPackage->_lpszContainerObj = new OLECHAR[lstrlenW(szContainerObj) + 1]))
    {
        lstrcpyW(_pPackage->_lpszContainerObj,szContainerObj);
    }

    switch(_pPackage->_panetype) {
        case PEMBED:
            if (_pPackage->_pEmbed->poo) 
                _pPackage->_pEmbed->poo->SetHostNames(szContainerApp,szContainerObj);
            break;
        case CMDLINK:
            // nothing to do...we're a link to a file, so we don't ever get
            // opened and need to be edited or some such thing.
            break;
    }
    
    return S_OK;
}

HRESULT CPackage_IOleObject::Close(DWORD dwSaveOption) 
{
    DebugMsg(DM_TRACE, "pack oo - Close() called.");

    switch (_pPackage->_panetype) {
        case PEMBED:
            if (_pPackage->_pEmbed == NULL)
                return S_OK;
            
            // tell the server to close, and release our pointer to it
            if (_pPackage->_pEmbed->poo) {
                _pPackage->_pEmbed->poo->Close(dwSaveOption);
                _pPackage->_pEmbed->poo->Unadvise(_pPackage->_dwCookie);
                _pPackage->_pEmbed->poo->Release();
                _pPackage->_pEmbed->poo = NULL;
            }
            break;
        case CMDLINK:
            // again, nothing to do...we shouldn't be getting close
            // messages since we're never activated through OLE.
            break;
    }
    if ((dwSaveOption != OLECLOSE_NOSAVE) && (_pPackage->_fIsDirty))
    {
        _pPackage->_pIOleClientSite->SaveObject();
        if (_pPackage->_pIOleAdviseHolder)
            _pPackage->_pIOleAdviseHolder->SendOnSave();
    }

    
    
    return S_OK;
}

HRESULT CPackage_IOleObject::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    DebugMsg(DM_TRACE, "pack oo - SetMoniker() called.");
    
    // NOTE: Uninteresting for embeddings only.
    return (E_NOTIMPL);
}

HRESULT CPackage_IOleObject::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, 
                               LPMONIKER *ppmk)
{
    DebugMsg(DM_TRACE, "pack oo - GetMoniker() called.");
    
    // NOTE: Unintersting for embeddings only.
    return (E_NOTIMPL);
}

HRESULT CPackage_IOleObject::InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, 
                                 DWORD dwReserved)
{
    DebugMsg(DM_TRACE, "pack oo - InitFromData() called.");
    
    // NOTE: This isn't supported at this time
    return (E_NOTIMPL);
}

HRESULT CPackage_IOleObject::GetClipboardData(DWORD dwReserved, LPDATAOBJECT *ppDataObject)
{
    DebugMsg(DM_TRACE, "pack oo - GetClipboardData() called.");
    
    if (ppDataObject == NULL) 
        return E_INVALIDARG;
    
    *ppDataObject = _pPackage->_pIDataObject;
    AddRef();
    return S_OK;
}

HRESULT CPackage_IOleObject::DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, 
                           LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    void *lpFileData = NULL;
    BOOL fError = TRUE;
    DWORD id;
    SHELLEXECUTEINFO sheinf = {sizeof(SHELLEXECUTEINFO)};
    
    DebugMsg(DM_TRACE, "pack oo - DoVerb() called.");
    DebugMsg(DM_TRACE, "            iVerb==%d",iVerb);

    // We allow show, primary verb, edit, and context menu verbs on our packages...
    //
    if (iVerb < OLEIVERB_SHOW)
        return E_NOTIMPL;
    
    /////////////////////////////////////////////////////////////////
    // SHOW VERB
    /////////////////////////////////////////////////////////////////
    //
    if (iVerb == OLEIVERB_SHOW) {
        PACKAGER_INFO packInfo = {0};
        
        // Run the Wizard...
        PackWiz_CreateWizard(hwndParent, &packInfo);

        return _pPackage->InitFromPackInfo(&packInfo);
    }

    /////////////////////////////////////////////////////////////////
    // EDIT PACKAGE VERB
    /////////////////////////////////////////////////////////////////
    //
    else if (iVerb == OLEIVERB_EDITPACKAGE) {
        // Call the edit package dialog.  Which dialog is ultimately called will
        // depend on whether we're a cmdline package or an embedded file
        // package.
        int idDlg;
        PACKAGER_INFO packInfo;
        int ret;

        lstrcpy(packInfo.szLabel,_pPackage->_lpic->szIconText);
        lstrcpy(packInfo.szIconPath,_pPackage->_lpic->szIconPath);
        packInfo.iIcon = _pPackage->_lpic->iDlgIcon;
        
        switch(_pPackage->_panetype) {
            case PEMBED:
                lstrcpy(packInfo.szFilename, _pPackage->_pEmbed->fd.cFileName);
                idDlg = IDD_EDITEMBEDPACKAGE;
                break;
            case CMDLINK:
                lstrcpy(packInfo.szFilename, _pPackage->_pCml->szCommandLine);
                idDlg = IDD_EDITCMDPACKAGE;
                break;
        }

        ret = PackWiz_EditPackage(hwndParent,idDlg, &packInfo);

        // If User cancells the edit package...just return.  
        if (ret == -1)
            return S_OK;

        switch(_pPackage->_panetype) {
            case PEMBED:
                // if we have a tempfile, we'll want to delete it
                if (_pPackage->_pEmbed->pszTempName) {
                    DeleteFile(_pPackage->_pEmbed->pszTempName);
                    delete _pPackage->_pEmbed->pszTempName;
                    _pPackage->_pEmbed->pszTempName = NULL;
                    _pPackage->ReleaseContextMenu();
                }
                // fall through
                
            case CMDLINK:
                _pPackage->InitFromPackInfo(&packInfo);
                break;
        }
        return S_OK;
    }
    else if (iVerb == OLEIVERB_PRIMARY)
    {
        /////////////////////////////////////////////////////////////////
        // ACTIVATE CONTENTS VERB
        /////////////////////////////////////////////////////////////////
        // NOTE: This is kind of crazy looking code, partially because we have
        // to worry about two ways of launching things--ShellExecuteEx and 
        // calling through OLE.
        //
        
        switch(_pPackage->_panetype)
        {
            case PEMBED:
                if (FAILED(_pPackage->CreateTempFile()))  // will just return S_OK
                    return E_FAIL;                        // if we have a temp file
        
                // if this is an OLE file then, activate through OLE
                //
                if (_pPackage->_pEmbed->fIsOleFile)
                {
                    // If we've activated the server, then we can just pass this
                    // call along to it.
                    if (_pPackage->_pEmbed->poo) 
                    {
                        return _pPackage->_pEmbed->poo->DoVerb(iVerb,lpmsg,
                            pActiveSite,lindex, hwndParent, lprcPosRect);
                    }

                    // We don't want to use OleCreateFromFile since that can turn around and create a packaged object...
                    CLSID clsid;
                    HRESULT hr = GetClassFile(_pPackage->_pEmbed->pszTempName, &clsid);
                    if (SUCCEEDED(hr)) 
                    {
                        IOleObject* poo;
                        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IOleObject, (void **)&poo);
                        if (SUCCEEDED(hr)) 
                        {
                            hr = poo->Advise(_pPackage->_pIAdviseSink, &_pPackage->_dwCookie);
                            if (SUCCEEDED(hr))
                            {
                                // NOTE: apparently we have to call
                                // OleRun before we can get IPersistFile from some apps, namely
                                // Word and Excel. If we don't call OleRun, they fail our QI
                                // for IPersistfile.
                                OleRun(poo);
            
                                IPersistFile* ppf;
                                hr = poo->QueryInterface(IID_IPersistFile, (void **)&ppf);
                                if (SUCCEEDED(hr))
                                {
                                    hr = ppf->Load(_pPackage->_pEmbed->pszTempName, STGM_READWRITE | STGM_SHARE_DENY_WRITE);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = poo->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
                                        if (SUCCEEDED(hr))
                                        {
                                            poo->SetHostNames(_pPackage->_lpszContainerApp, _pPackage->_lpszContainerObj);
                                            if (!_pPackage->_fNoIOleClientSiteCalls)
                                            {
                                                _pPackage->_pIOleClientSite->ShowObject();
                                                _pPackage->_pIOleClientSite->OnShowWindow(TRUE);
                                            }
                                            _pPackage->_pEmbed->poo = poo;  // save this so when we get a
                                            poo = NULL;
                                        }
                                    }
                                    ppf->Release();
                                }
                                if (FAILED(hr))
                                    poo->Unadvise(_pPackage->_dwCookie);
                            }
                            if (FAILED(hr))
                                poo->Release();
                        }
                    }
                    if (SUCCEEDED(hr))
                        return hr;

                    // We weren't an OLE file after all, change our state to reflect this
                    _pPackage->_pEmbed->fIsOleFile = FALSE;
                    _pPackage->_fIsDirty = TRUE;
                }   

                // Try to execute the file
                _pPackage->_pEmbed->hTask = NULL;

                sheinf.fMask  = SEE_MASK_NOCLOSEPROCESS;
                sheinf.lpFile = _pPackage->_pEmbed->pszTempName;
                sheinf.nShow  = SW_SHOWNORMAL;

                if (ShellExecuteEx(&sheinf))
                {
                    // if we get a valid process handle, we want to create a thread
                    // to wait for the process to exit so we know when we can load
                    // the tempfile back into memory.
                    //
                    if (sheinf.hProcess)
                    {
                        _pPackage->_pEmbed->hTask = sheinf.hProcess;
                        MAINWAITONCHILD *pmwoc = new MAINWAITONCHILD;
                        if (pmwoc)
                        {
                            pmwoc->pObj = this;
                            pmwoc->h = sheinf.hProcess;
                        
                            if (CreateThread(NULL, 0, MainWaitOnChildThreadProc, pmwoc, 0, &id))
                                fError = FALSE;
                            else 
                            {
                                CloseHandle(sheinf.hProcess);
                                return E_FAIL;
                            }
                        }
                    }
                    // NOTE: there's not much we can do if the ShellExecute
                    // succeeds and we don't get a valid handle back.  we'll just
                    // load from the temp file when we're asked to save and hope
                    // for the best.
                }   
                else // ShellExecuteEx failed!
                {
                    return E_FAIL;
                }           
        
                // show that the object is now active
                if (!fError && !_pPackage->_fNoIOleClientSiteCalls)
                {
                    _pPackage->_pIOleClientSite->ShowObject();
                    _pPackage->_pIOleClientSite->OnShowWindow(TRUE);
                }
                return fError ? E_FAIL : S_OK;

            case CMDLINK: 
                {
                    TCHAR szPath[MAX_PATH];
                    TCHAR szArgs[CBCMDLINKMAX-MAX_PATH];

                    lstrcpy(szPath, _pPackage->_pCml->szCommandLine);
                    PathSeparateArgs(szPath, szArgs);

                    sheinf.fMask  = SEE_MASK_NOCLOSEPROCESS;
                    sheinf.lpFile = szPath;
                    sheinf.lpParameters = szArgs;   
                    sheinf.nShow  = SW_SHOWNORMAL;

                    // NOTE: This code is much nicer than ShellExec-ing an embedded
                    // file.  Here, we just need to ShellExec the command line and
                    // the we're done.  We don't need to know when that process
                    // finishes or anything else.

                    return ShellExecuteEx(&sheinf)? S_OK:E_FAIL;                

                }
                break;

            case PACKAGE:  
                {
                    PACKAGER_INFO packInfo = {0};

                    ASSERT(_pPackage->_pCml);
                    lstrcpyn(packInfo.szFilename, _pPackage->_pCml->szCommandLine, ARRAYSIZE(packInfo.szFilename));

                    // Run the Wizard...
                    PackWiz_CreateWizard(hwndParent, &packInfo);

                    return _pPackage->InitFromPackInfo(&packInfo);
                }
                break;
        }
    }
    else
    {
        // Let's see if it is a context menu verb:
        HRESULT hr;
        IContextMenu* pcm;
        if (SUCCEEDED(hr = _pPackage->GetContextMenu(&pcm)))
        {
            HMENU hmenu = CreatePopupMenu();
            if (NULL != hmenu)
            {
                if (SUCCEEDED(hr = pcm->QueryContextMenu(hmenu,
                                                         0,
                                                         OLEIVERB_FIRST_CONTEXT,
                                                         OLEIVERB_LAST_CONTEXT,
                                                         CMF_NORMAL)))
                {
                    MENUITEMINFO mii;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID;
                    if (GetMenuItemInfo(hmenu, (UINT) (iVerb - OLEIVERB_FIRST_CONTEXT), TRUE, &mii))
                    {
                        if (PEMBED == _pPackage->_panetype)
                        {
                            // If we have an embedding, we have to make sure that
                            // the temp file is created before we execute a command:
                            hr =_pPackage->CreateTempFile();
                        }
                        if (SUCCEEDED(hr))
                        {
                            CMINVOKECOMMANDINFO ici;
                            ici.cbSize = sizeof(ici);
                            ici.fMask = 0;
                            ici.hwnd = NULL;
                            ici.lpVerb = (LPCSTR) IntToPtr(mii.wID - OLEIVERB_FIRST_CONTEXT);
                            ici.lpParameters = NULL;
                            ici.lpDirectory = NULL;
                            ici.nShow = SW_SHOWNORMAL;
                            // REVIEW: should we return OLEOBJ_S_CANNOT_DOVERB_NOW if this fails?
                            hr = pcm->InvokeCommand(&ici);
                        }
                    }
                    else
                    {
                        hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
                    }
                }
                DestroyMenu(hmenu);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            pcm->Release();
        }
        return hr;
    }
    return E_FAIL;
}
    
HRESULT CPackage_IOleObject::EnumVerbs(LPENUMOLEVERB *ppEnumOleVerb)
{
    DebugMsg(DM_TRACE, "pack oo - EnumVerbs() called.");
    HRESULT hr;
    
    IContextMenu* pcm;
     // tell the package to release the cached context menu:
    _pPackage->ReleaseContextMenu();
    if (SUCCEEDED(hr = _pPackage->GetContextMenu(&pcm)))
    {
        HMENU hmenu = CreatePopupMenu();
        if (NULL != hmenu)
        {
            if (SUCCEEDED(hr = pcm->QueryContextMenu(hmenu,
                                                     0,
                                                     OLEIVERB_FIRST_CONTEXT,
                                                     OLEIVERB_LAST_CONTEXT,
                                                     CMF_NORMAL)))
            {
                // FEATURE: remove problematic items by canonical names
                int nItems = GetMenuItemCount(hmenu);
                int cOleVerbs = 0;
                if (nItems > 0)
                {
                    // NOTE: we allocate nItems, but we may not use all of them
                    // FEATURE: add in menu items from the registry: "activate" & "edit"
                    OLEVERB* pVerbs = new OLEVERB[nItems];
                    if (NULL != pVerbs)
                    {
                        MENUITEMINFO mii;
                        TCHAR szMenuName[MAX_PATH];
                        mii.cbSize = sizeof(mii);
                        mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE | MIIM_ID;
                        for (int i = 0; i < nItems; i++)
                        {
                            mii.dwTypeData = szMenuName;
                            mii.cch = ARRAYSIZE(szMenuName);
                            // NOTE: use GetMenuState() to avoid converting flags:
                            DWORD dwState = GetMenuState(hmenu, i, MF_BYPOSITION);
                            if (0 == (dwState & (MF_BITMAP | MF_OWNERDRAW | MF_POPUP)))
                            {
                                if (GetMenuItemInfo(hmenu, i, TRUE, &mii) && (MFT_STRING == mii.fType))
                                {
                                    TCHAR szVerb[MAX_PATH];
                                    if (FAILED(pcm->GetCommandString(mii.wID - OLEIVERB_FIRST_CONTEXT,
                                                                     GCS_VERB,
                                                                     NULL,
                                                                     (LPSTR) szVerb,
                                                                     ARRAYSIZE(szVerb))))
                                    {
                                        // Some commands don't have canonical names - just
                                        // set the verb string to empty
                                        szVerb[0] = TEXT('\0');
                                    }
                                    if ((0 != lstrcmp(szVerb, TEXT("cut"))) &&
                                        (0 != lstrcmp(szVerb, TEXT("delete"))))
                                    {
                                        // In the first design, the context menu ID was used as
                                        // the lVerb - however MFC apps only give us a range of
                                        // 16 ID's and context menu ID's are often over 100
                                        // (they aren't contiguous)
                                        // Instead, we use the menu position plus the verb offset
                                        pVerbs[cOleVerbs].lVerb = (LONG) OLEIVERB_FIRST_CONTEXT + i;
                                        int cchMenu = lstrlen(mii.dwTypeData) + 1;
                                        if (NULL != (pVerbs[cOleVerbs].lpszVerbName = new WCHAR[cchMenu]))
                                        {
                                            SHTCharToUnicode(mii.dwTypeData, pVerbs[cOleVerbs].lpszVerbName, cchMenu);
                                        }
                                        pVerbs[cOleVerbs].fuFlags = dwState;
                                        pVerbs[cOleVerbs].grfAttribs = OLEVERBATTRIB_ONCONTAINERMENU;
                                        DebugMsg(DM_TRACE, "  Adding verb: id==%d,name=%s,verb=%s",mii.wID,mii.dwTypeData,szVerb);
                                        cOleVerbs++;
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hr = _pPackage->InitVerbEnum(pVerbs, cOleVerbs)))
                        {
                            hr = _pPackage->QueryInterface(IID_IEnumOLEVERB, (void**) ppEnumOleVerb);
                        }
                        else
                        {
                            delete pVerbs;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = OLEOBJ_E_NOVERBS;
                }
            }
            DestroyMenu(hmenu);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pcm->Release();
    }

    return hr; // OleRegEnumVerbs(CLSID_CPackage, ppEnumOleVerb);
}

HRESULT CPackage_IOleObject::Update(void)
{
    return S_OK;
}

    
HRESULT CPackage_IOleObject::IsUpToDate(void)
{
    return S_OK;
}

    
HRESULT CPackage_IOleObject::GetUserClassID(LPCLSID pClsid)
{
    *pClsid = CLSID_CPackage;
    return S_OK;
}

    
HRESULT CPackage_IOleObject::GetUserType(DWORD dwFromOfType, LPOLESTR *pszUserType)
{
    return OleRegGetUserType(CLSID_CPackage, dwFromOfType, pszUserType);
}

    
HRESULT CPackage_IOleObject::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return E_FAIL;
}

    
HRESULT CPackage_IOleObject::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    return _pPackage->_pIViewObject2->GetExtent(dwDrawAspect,-1,NULL,psizel);
}

    
HRESULT CPackage_IOleObject::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    if (_pPackage->_pIOleAdviseHolder == NULL) 
    {
        HRESULT hr = CreateOleAdviseHolder(&_pPackage->_pIOleAdviseHolder);
        if (FAILED(hr))
            return hr;
    }
    return _pPackage->_pIOleAdviseHolder->Advise(pAdvSink, pdwConnection);
}

    
HRESULT CPackage_IOleObject::Unadvise(DWORD dwConnection)
{
    DebugMsg(DM_TRACE, "pack oo - Unadvise() called.");
    
    if (_pPackage->_pIOleAdviseHolder != NULL)
        return _pPackage->_pIOleAdviseHolder->Unadvise(dwConnection);
    
    return E_FAIL;
}

    
HRESULT CPackage_IOleObject::EnumAdvise(LPENUMSTATDATA *ppenumAdvise)
{
    DebugMsg(DM_TRACE, "pack oo - EnumAdvise() called.");
    
    if (_pPackage->_pIOleAdviseHolder != NULL)
        return _pPackage->_pIOleAdviseHolder->EnumAdvise(ppenumAdvise);
    
    return E_FAIL;
}

    
HRESULT CPackage_IOleObject::GetMiscStatus(DWORD dwAspect, LPDWORD pdwStatus)
{
    return OleRegGetMiscStatus(CLSID_CPackage, dwAspect, pdwStatus);
}


HRESULT CPackage_IOleObject::SetColorScheme(LPLOGPALETTE pLogpal)
{
    return E_NOTIMPL;
}


DWORD CALLBACK MainWaitOnChildThreadProc(void *lpv)
{
    INT ret;
    MAINWAITONCHILD *pmwoc = (MAINWAITONCHILD *)lpv;
    CPackage *pPack = pmwoc->pObj->_pPackage;
    
    DebugMsg(DM_TRACE, "pack oo - MainWaitOnChildThreadProc() called.");
    DebugMsg(DM_TRACE, "            handle = %d",(DWORD_PTR)lpv);
    
    ret = WaitForSingleObject(pmwoc->h, INFINITE);
    DebugMsg(DM_TRACE,"WaitForSingObject exits...ret==%d",ret);
    
    if (ret == -1)
        DebugMsg(DM_TRACE,"GetLastError==%d",GetLastError());
      
    CloseHandle(pmwoc->h);

    // BUGBUG: NONE OF THE BELOW CALLS ARE THREAD-SAFE!!!

    // this will set our dirty flag...
    if (FAILED(pPack->EmbedInitFromFile(pPack->_pEmbed->pszTempName,FALSE)))
    {
        ShellMessageBox(g_hinst,
                        NULL,
                        MAKEINTRESOURCE(IDS_UPDATE_ERROR),
                        MAKEINTRESOURCE(IDS_APP_TITLE),
                        MB_ICONERROR | MB_TASKMODAL | MB_OK);
    }

    pPack->_pIOleClientSite->SaveObject();
    
    if (pPack->_pIOleAdviseHolder)
    {
        pPack->_pIOleAdviseHolder->SendOnSave();
        pPack->_pIOleAdviseHolder->SendOnClose();
    }
    
    if (pPack->_pIOleClientSite && !pPack->_fNoIOleClientSiteCalls)
        pPack->_pIOleClientSite->OnShowWindow(FALSE);
    
    pPack->_pEmbed->hTask = NULL;
    
    // NOTE: we should probably pop up some sort of message box here if we 
    // can't reinit from the temp file.
    DebugMsg(DM_TRACE, "            MainWaitOnChildThreadProc exiting.");
    
    delete pmwoc;
    return 0;
}

BOOL CALLBACK GetTaskWndProc(HWND hwnd, DWORD lParam)
{
    DebugMsg(DM_TRACE, "pack oo - GetTaskWndProc() called.");
    
    if (IsWindowVisible(hwnd))
    {
        g_hTaskWnd = hwnd;
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\iperfile.cpp ===
#include "privcpp.h"

// Constructor
CPackage_IPersistFile::CPackage_IPersistFile(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0); 
}

CPackage_IPersistFile::~CPackage_IPersistFile()
{
    DebugMsg(DM_TRACE,"CPackage_IPersistFile destroyed with ref count %d",_cRef);
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IPersistFile::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);  // delegate to CPackage
}

ULONG CPackage_IPersistFile::AddRef(void) 
{
    _cRef++;                                    // interface ref count for debug
    return _pPackage->AddRef();                 // delegate to CPackage
}

ULONG CPackage_IPersistFile::Release(void)
{
    _cRef--;                                    // interface ref count for debug
    return _pPackage->Release();                // delegate to CPackage
}

//////////////////////////////////
//
// IPersistFile Methods...
//
HRESULT CPackage_IPersistFile::GetClassID(LPCLSID pClassID)
{
    DebugMsg(DM_TRACE, "pack ps - GetClassID() called.");
    
    if (pClassID == NULL)
        return E_INVALIDARG;
    
    *pClassID = CLSID_CPackage;
    return S_OK;
}

HRESULT CPackage_IPersistFile::IsDirty(void)
{
    DebugMsg(DM_TRACE, "pack ps - IsDirty() called.");
    return E_NOTIMPL;
}

    
HRESULT CPackage_IPersistFile::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT     hr;

    DebugMsg(DM_TRACE, "pack pf - Load() called.");

    if (!pszFileName) {
        DebugMsg(DM_TRACE,"            bad pointer!!");
        return E_POINTER;
    }

    //
    // We blow off the mode flags
    //
    hr = _pPackage->EmbedInitFromFile(pszFileName, TRUE);

    DebugMsg(DM_TRACE, "            leaving Load()");
    
    return hr;
}

    
HRESULT CPackage_IPersistFile::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    DebugMsg(DM_TRACE, "pack pf - Save() called.");

    return E_NOTIMPL;    
}

    
HRESULT CPackage_IPersistFile::SaveCompleted(LPCOLESTR pszFileName)
{
    DebugMsg(DM_TRACE, "pack pf - SaveCompleted() called.");

    return E_NOTIMPL;
}

    
HRESULT CPackage_IPersistFile::GetCurFile(LPOLESTR *ppszFileName)
{
    DebugMsg(DM_TRACE, "pack pf - GetCurFile() called.");

    if (!ppszFileName)
        return E_POINTER;
    
    *ppszFileName = NULL;           // null the out param
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\iperstor.cpp ===
#include "privcpp.h"

// Constructor
CPackage_IPersistStorage::CPackage_IPersistStorage(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0); 
    ASSERT(_psState == PSSTATE_UNINIT);
}

CPackage_IPersistStorage::~CPackage_IPersistStorage()
{
    DebugMsg(DM_TRACE,"CPackage_IPersistStorage destroyed with ref count %d",_cRef);
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IPersistStorage::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);  // delegate to CPackage
}

ULONG CPackage_IPersistStorage::AddRef(void) 
{
    _cRef++;                                    // interface ref count for debug
    return _pPackage->AddRef();                 // delegate to CPackage
}

ULONG CPackage_IPersistStorage::Release(void)
{
    _cRef--;                                    // interface ref count for debug
    return _pPackage->Release();                // delegate to CPackage
}

//////////////////////////////////
//
// IPersistStorage Methods...
//
HRESULT CPackage_IPersistStorage::GetClassID(LPCLSID pClassID)
{
    DebugMsg(DM_TRACE, "pack ps - GetClassID() called.");
    
    if (_psState == PSSTATE_UNINIT)  
        return E_UNEXPECTED;
    
    if (pClassID == NULL)
        return E_INVALIDARG;
    
    *pClassID = CLSID_CPackage;
    return S_OK;
}

HRESULT CPackage_IPersistStorage::IsDirty(void)
{
    DebugMsg(DM_TRACE,
        "pack ps - IsDirty() called. _fIsDirty==%d",
        (INT)_pPackage->_fIsDirty);
    if (_psState == PSSTATE_UNINIT)  
        return E_UNEXPECTED;
    
    return (_pPackage->_fIsDirty ? S_OK : S_FALSE);
}

HRESULT CPackage_IPersistStorage::InitNew(IStorage *pstg)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, "pack ps - InitNew() called.");

    if (_psState != PSSTATE_UNINIT)  
        return E_UNEXPECTED;

    if (!pstg)  
        return E_POINTER;

    // Create a stream to save the package and cache the pointer.  By doing 
    // this now we ensure being able to save in low memory conditions.
    //
    hr = pstg->CreateStream(SZCONTENTS,STGM_DIRECT | STGM_CREATE | 
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, 
                            &_pPackage->_pstm);
    if (SUCCEEDED(hr))
    {
        hr = WriteFmtUserTypeStg(pstg, (CLIPFORMAT)_pPackage->_cf,SZUSERTYPE);
        if (SUCCEEDED(hr))
        {     
            _pPackage->_fIsDirty = TRUE;
            _psState = PSSTATE_SCRIBBLE;
            
            _pPackage->_pIStorage = pstg;       // cache the IStorage pointer
            _pPackage->_pIStorage->AddRef();    // but don't forget to addref it!

            DebugMsg(DM_TRACE, "            leaving InitNew()");
        }
        else
        {
            _pPackage->_pstm->Release();
            _pPackage->_pstm = NULL;
        }
    }

    return hr;
}

    
HRESULT CPackage_IPersistStorage::Load(IStorage *pstg)
{
    HRESULT     hr;
    LPSTREAM    pstm = NULL;         // package contents
    CLSID       clsid;

    DebugMsg(DM_TRACE, "pack ps - Load() called.");

    if (_psState != PSSTATE_UNINIT) {
        DebugMsg(DM_TRACE,"            wrong state!!");
        return E_UNEXPECTED;
    }
    
    if (!pstg) {
        DebugMsg(DM_TRACE,"            bad pointer!!");
        return E_POINTER;
    }
    
    
    // check to make sure this is one of our storages
    hr = ReadClassStg(pstg, &clsid);
    if (SUCCEEDED(hr) &&
        (clsid != CLSID_CPackage && clsid != CLSID_OldPackage) || FAILED(hr))
    {
        DebugMsg(DM_TRACE,"            bad storage type!!");
        return E_UNEXPECTED;
    }
    
    hr = pstg->OpenStream(SZCONTENTS,0, STGM_DIRECT | STGM_READWRITE | 
                          STGM_SHARE_EXCLUSIVE, 0, &pstm);
    if (FAILED(hr)) {
        DebugMsg(DM_TRACE,"            couldn't open contents stream!!");
        DebugMsg(DM_TRACE,"            hr==%Xh",hr);
        goto ErrRet;
    }

    hr = _pPackage->PackageReadFromStream(pstm);
    if (FAILED(hr))
        goto ErrRet;
    
    _pPackage->_pstm      = pstm;
    _pPackage->_pIStorage = pstg;
    pstg->AddRef();
    
    _psState = PSSTATE_SCRIBBLE;
    _pPackage->_fIsDirty = FALSE;
    _pPackage->_fLoaded  = TRUE;
    
    DebugMsg(DM_TRACE, "            leaving Load()");
    return S_OK;
    
ErrRet:
    if (pstm)
        pstm->Release();
    return hr;
}

    
HRESULT CPackage_IPersistStorage::Save(IStorage *pstg, BOOL fSameAsLoad)
{
    HRESULT     hr;
    LPSTREAM    pstm=NULL;

    DebugMsg(DM_TRACE, "pack ps - Save() called.");
    
    // must come here from scribble state
    if ((_psState != PSSTATE_SCRIBBLE) && fSameAsLoad) {
        DebugMsg(DM_TRACE,"            bad state!!");
        return E_UNEXPECTED;
    }
    
    // must have an IStorage if not SameAsLoad
    if (!pstg && !fSameAsLoad) {
        DebugMsg(DM_TRACE,"            bad pointer!!");
        return E_POINTER;
    }
    
    // hopefully, the container calls WriteClassStg with our CLSID before
    // we get here, that way we can overwrite that and write out the old
    // packager's CLSID so that the old packager can read new packages.
    //
    if (FAILED(WriteClassStg(pstg,CLSID_OldPackage))) {
        DebugMsg(DM_TRACE,
            "            couldn't write CLSID to storage!!");
        return E_FAIL;
    }
    
    // 
    // ok, we have four possible ways we could be calling Save:
    //          1. we're creating a new package and saving to the same
    //             storage we received in InitNew
    //          2. We're creating a new package and saving to a different
    //             storage than we received in InitNew
    //          3. We were loaded by a container and we're saving to the
    //             same stream we received in Load
    //          4. We were loaded by a container and we're saving to a
    //             different stream than we received in Load
    //
    

    //////////////////////////////////////////////////////////////////
    //
    // Same Storage as Load
    //
    //////////////////////////////////////////////////////////////////
    
    if (fSameAsLoad) {          

        DebugMsg(DM_TRACE,"            Same as load.");
        
        LARGE_INTEGER   li = {0,0};
        pstm = _pPackage->_pstm;

        // If we're not dirty, so there's nothing new to save.
        
        if (FALSE == _pPackage->_fIsDirty) {
            DebugMsg(DM_TRACE, "            not saving cause we're not dirty!!");
            return S_OK;
        }
        
        // if we are dirty, set the seek pointer to the beginning and write
        // the package information to the stream
        hr = pstm->Seek(li, STREAM_SEEK_SET, NULL);
        if (FAILED(hr)) {
            DebugMsg(DM_TRACE, "            couldn't set contents pointer!!");
            return hr;
        }
        
        // case 1: new package
        if (!_pPackage->_fLoaded) {
            switch(_pPackage->_panetype) {
                LPTSTR temp;
                case PEMBED:
                    // if haven't created a temp file yet, then use the the
                    // file to be packaged to get our file contents from,
                    // otherwise we just use the temp file, because if we
                    // have a temp file, it contains the most recent info.
                    //
                    temp = _pPackage->_pEmbed->pszTempName;
            
                    if (!_pPackage->_pEmbed->pszTempName) {
                        DebugMsg(DM_TRACE, "      case 1a:not loaded, using initFile.");
                        _pPackage->_pEmbed->pszTempName = _pPackage->_pEmbed->fd.cFileName;
                    }
                    else {
                        DebugMsg(DM_TRACE, "      case 1b:not loaded, using tempfile.");
                    }
            
                    hr = _pPackage->PackageWriteToStream(pstm);
                    
                    // reset our temp name back, since we might have changed it
                    // basically, this just sets it to NULL if it was before
                    _pPackage->_pEmbed->pszTempName = temp;
                    break;

                case CMDLINK:
                    // nothing screwy to do here...just write out the info
                    // which we already have in memory.
                    hr = _pPackage->PackageWriteToStream(pstm);
                    break;
            }
            
            if (FAILED(hr))
                return hr;
        }
    
        // case 3: loaded package
        else {
            hr = _pPackage->PackageWriteToStream(pstm);
        }
    }
    
    //////////////////////////////////////////////////////////////////
    //
    // NEW Storage  
    //
    //////////////////////////////////////////////////////////////////
    
    else {

        DebugMsg(DM_TRACE,"            NOT same as load.");
        hr = pstg->CreateStream(SZCONTENTS,STGM_DIRECT | STGM_CREATE | 
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, 
                                &pstm);
        if (FAILED(hr)) {
            DebugMsg(DM_TRACE, "            couldn't create contents stream!!");
            return hr;
        }
        WriteFmtUserTypeStg(pstg, (CLIPFORMAT)_pPackage->_cf,SZUSERTYPE);
        
        // case 2:
        if (!_pPackage->_fLoaded) {
            switch(_pPackage->_panetype) {
                LPTSTR temp;
                case PEMBED:
                    temp = _pPackage->_pEmbed->pszTempName;
            
                    if (!_pPackage->_pEmbed->pszTempName) {
                        DebugMsg(DM_TRACE, "      case 2a:not loaded, using initFile.");
                        _pPackage->_pEmbed->pszTempName = _pPackage->_pEmbed->fd.cFileName;
                    }            
                    else {
                        DebugMsg(DM_TRACE, "      case 2b:not loaded, using tempfile.");
                    }
            
                    hr = _pPackage->PackageWriteToStream(pstm);
            
                    // reset our temp name back, since we might have changed it
                    // basically, this just sets it to NULL if it was before
                    _pPackage->_pEmbed->pszTempName = temp;
                    break;

                case CMDLINK:
                    // nothing interesting to do here, other than write out
                    // the package.
                    hr = _pPackage->PackageWriteToStream(pstm);
                    break;
            }

            if (FAILED(hr)) 
                goto ErrRet;
            
        }
        
        // case 4:
        else {
            if (_pPackage->_panetype == PEMBED && _pPackage->_pEmbed->pszTempName ) {
                DebugMsg(DM_TRACE,"    case 4a:loaded, using tempfile.");
                hr = _pPackage->PackageWriteToStream(pstm);
                if (FAILED(hr))
                    goto ErrRet;
            }
            else {
                DebugMsg(DM_TRACE,"    case 4b:loaded, using stream.");
                ULARGE_INTEGER uli = { 0xFFFFFFFF, 0xFFFFFFFF };
                LARGE_INTEGER li = {0,0};
                
                hr = _pPackage->_pstm->Seek(li,STREAM_SEEK_SET,NULL);
                if (FAILED(hr))
                    goto ErrRet;
                
                hr = _pPackage->_pstm->CopyTo(pstm,uli,NULL,NULL);
                if (FAILED(hr))
                    goto ErrRet;
            }
        }
    ErrRet:
        UINT u = pstm->Release();
        DebugMsg(DM_TRACE,"          new stream released.  cRef==%d.",u);
        if (FAILED(hr))
            return hr;
    }
    
    _psState = PSSTATE_ZOMBIE;
    
    DebugMsg(DM_TRACE, "            leaving Save()");
    return S_OK;
}

    
HRESULT CPackage_IPersistStorage::SaveCompleted(IStorage *pstg)
{
    HRESULT     hr;
    LPSTREAM    pstm;
    
    DebugMsg(DM_TRACE, "pack ps - SaveCompleted() called.");

    // must be called from no-scribble or hands-off state
    if (!(_psState == PSSTATE_ZOMBIE || _psState == PSSTATE_HANDSOFF))
        return E_UNEXPECTED;
    
    // if we're hands-off, we'd better get a storage to re-init from
    if (!pstg && _psState == PSSTATE_HANDSOFF)
        return E_UNEXPECTED;
    
    // if pstg is NULL then we have everything we need, otherwise we must
    // release our held pointers and reinitialize.
    //
    if (pstg != NULL) {
        DebugMsg(DM_TRACE, "            getting new storage.");
        hr = pstg->OpenStream(SZCONTENTS, 0, STGM_DIRECT | STGM_READWRITE | 
                              STGM_SHARE_EXCLUSIVE, 0, &pstm);
        if (FAILED(hr))
            return hr;

        if (_pPackage->_pstm != NULL)
            _pPackage->_pstm->Release();
        
        // this will be reinitialized when it's needed
        if (_pPackage->_pstmFileContents != NULL) {
            _pPackage->_pstmFileContents->Release();
            _pPackage->_pstmFileContents = NULL;
        }
        
        if (_pPackage->_pIStorage != NULL)
            _pPackage->_pIStorage->Release();

        _pPackage->_pstm = pstm;
        _pPackage->_pIStorage = pstg;
        _pPackage->_pIStorage->AddRef();
    }
    
    _psState = PSSTATE_SCRIBBLE;
    _pPackage->_fIsDirty = FALSE;
    DebugMsg(DM_TRACE, "            leaving SaveCompleted()");
    return S_OK;
}

    
HRESULT CPackage_IPersistStorage::HandsOffStorage(void)
{
    DebugMsg(DM_TRACE, "pack ps - HandsOffStorage() called.");

    // must come from scribble or no-scribble.  a repeated call to 
    // HandsOffStorage is an unexpected error (bug in client).
    //
    if (_psState == PSSTATE_UNINIT || _psState == PSSTATE_HANDSOFF)
        return E_UNEXPECTED;
    
    // release our held pointers
    //
    if (_pPackage->_pstmFileContents != NULL) {
        _pPackage->_pstmFileContents->Release();
        _pPackage->_pstmFileContents = NULL;
    }
    
    if (_pPackage->_pstm != NULL) {
        _pPackage->_pstm->Release();
        _pPackage->_pstm = NULL;
    }
    
    if (_pPackage->_pIStorage != NULL) {
        _pPackage->_pIStorage->Release();
        _pPackage->_pIStorage = NULL;
    }
    
    _psState = PSSTATE_HANDSOFF;
    DebugMsg(DM_TRACE, "            leaving HandsOffStorage()");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\ids.h ===
#ifndef IDS_H__
#define IDS_H__


// Used by pack2.rc
//

#define IDI_DOCUMENT			1

// Dialogs
#define IDD_SELECTFILE                  102
#define IDD_SELECTICON                  103
#define IDD_SELECTLABEL                 107
#define IDD_EDITEMBEDPACKAGE            108
#define IDD_EDITCMDPACKAGE              109

#define IDC_COMMAND                     1003
#define IDC_BROWSE                      1004
#define IDC_CHANGEICON                  1005
#define IDC_PACKICON                    1007
#define IDC_WIZBMP                      1009
#define IDC_EDIT1                       1013
#define IDC_EDIT2                       1014

// Strings
#define	IDS_BROWSEEXT			2001
#define	IDS_BROWSEFILTER		2002
#define	IDS_BROWSETITLE			2003
#define	IDS_APP_TITLE           3000
#define	IDS_UPDATE_ERROR        3001
#define	IDS_OLD_FORMAT_ERROR    3002
#define	IDS_CREATE_ERROR        3003
#define	IDS_COPY_ERROR          3004
#define	IDS_COPY_COMPLETE       3005

// Icons
#define IDI_PACKAGER                    1500

// Bitmaps
#define IDB_PACKWIZBMP			5000

#define IDC_STATIC                      -1



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\irunobj.cpp ===
#include "privcpp.h"

CPackage_IRunnableObject::CPackage_IRunnableObject(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0);
}

CPackage_IRunnableObject::~CPackage_IRunnableObject()
{
    DebugMsg(DM_TRACE,"CPackage_IRunnableObject destroyed with ref count %d",_cRef);
}


//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IRunnableObject::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);
}

ULONG CPackage_IRunnableObject::AddRef(void) 
{
    _cRef++;    // interface ref count for debugging
    return _pPackage->AddRef();
}

ULONG CPackage_IRunnableObject::Release(void)
{
    _cRef--;    // interface ref count for debugging
    return _pPackage->Release();
}

//////////////////////////////////
//
// IRunnable Object Methods...
//
// NOTE: To answer your question, yes, this is kind of a pointless interface,
// but some apps feel better when it's around.  Basically we just tell what
// they want to hear (ie. return S_OK).
//
HRESULT CPackage_IRunnableObject::GetRunningClass(LPCLSID pclsid)
{
    DebugMsg(DM_TRACE, "pack ro - GetRunningClass() called.");
    
    if (pclsid == NULL)
        return E_INVALIDARG;
    
    *pclsid = CLSID_CPackage;
    return S_OK;
}

HRESULT CPackage_IRunnableObject::Run(LPBC lpbc)
{
    // we're an inproc-server, so telling us to run is kind of pointless
    DebugMsg(DM_TRACE, "pack ro - Run() called.");
    return S_OK;
}

BOOL CPackage_IRunnableObject::IsRunning() 
{
    DebugMsg(DM_TRACE, "pack ro - IsRunning() called.");
    
    // we're an inproc-server, so this is kind of pointless
    return TRUE;
} 

HRESULT CPackage_IRunnableObject::LockRunning(BOOL, BOOL)
{
    DebugMsg(DM_TRACE, "pack ro - LockRunning() called.");
    
    // again, we're an inproc-server, so this is also pointless
    return S_OK;
} 

HRESULT CPackage_IRunnableObject::SetContainedObject(BOOL)
{
    DebugMsg(DM_TRACE, "pack ro - SetContainedObject() called.");
    // again, we don't really care about this
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\idataobj.cpp ===
#include "privcpp.h"

CPackage_IDataObject::CPackage_IDataObject(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0); 

}

CPackage_IDataObject::~CPackage_IDataObject()
{
    DebugMsg(DM_TRACE,"CPackage_IDataObject destroyed with ref count %d",_cRef);
}


//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IDataObject::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);
}

ULONG CPackage_IDataObject::AddRef(void) 
{
    _cRef++;    // interface ref count for debugging
    return _pPackage->AddRef();
}

ULONG CPackage_IDataObject::Release(void)
{
    _cRef--;    // interface ref count for debugging
    return _pPackage->Release();
}


//////////////////////////////////
//
// IDataObject Methods...
//
HRESULT CPackage_IDataObject::GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM)
{
    UINT cf = pFEIn->cfFormat;

    DebugMsg(DM_TRACE, "pack do - GetData() called.");
    
    // Check the aspects we support
    if (!(pFEIn->dwAspect & DVASPECT_CONTENT)) {
        DebugMsg(DM_TRACE, "            Invalid Aspect! dwAspect=%d",pFEIn->dwAspect);
        return DATA_E_FORMATETC;
    }
    
    // we set this to NULL so we aren't responsible for freeing memory
    pSTM->pUnkForRelease = NULL;

    // Go render the appropriate data for the format.
    if (cf == CF_FILEDESCRIPTOR) 
        return _pPackage->GetFileDescriptor(pFEIn,pSTM);
    
    else if (cf == CF_FILECONTENTS) 
        return _pPackage->GetFileContents(pFEIn,pSTM);
    
    else if (cf == CF_METAFILEPICT) 
        return _pPackage->GetMetafilePict(pFEIn,pSTM);

    else if (cf == CF_ENHMETAFILE)
        return _pPackage->GetEnhMetafile(pFEIn,pSTM);

    else if (cf == CF_OBJECTDESCRIPTOR)
        return _pPackage->GetObjectDescriptor(pFEIn,pSTM);
                

#ifdef DEBUG
    else {
        TCHAR szFormat[80];
        GetClipboardFormatName(cf, szFormat, ARRAYSIZE(szFormat));
        DebugMsg(DM_TRACE,"            unknown format: %s",szFormat);
        return DATA_E_FORMATETC;
    }
#endif

    return DATA_E_FORMATETC;
}

HRESULT CPackage_IDataObject::GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DebugMsg(DM_TRACE, "pack do - GetDataHere() called.");
    
    HRESULT     hr;
    
    // The only reasonable time this is called is for CFSTR_EMEDSOURCE and
    // TYMED_ISTORAGE.  This means the same as IPersistStorage::Save
    
    // Aspect is unimportant to us here, as is lindex and ptd.
    if (pFE->cfFormat == CF_EMBEDSOURCE && (pFE->tymed & TYMED_ISTORAGE)) {
        // we have an IStorage we can write into.
        pSTM->tymed = TYMED_ISTORAGE;
        pSTM->pUnkForRelease = NULL;
        
        hr = _pPackage->_pIPersistStorage->Save(pSTM->pstg, FALSE);
        _pPackage->_pIPersistStorage->SaveCompleted(NULL);
        return hr;
    }
    
    return DATA_E_FORMATETC;
}
    
    
HRESULT CPackage_IDataObject::QueryGetData(LPFORMATETC pFE)
{
    UINT cf = pFE->cfFormat;
    BOOL fRet = FALSE;

    DebugMsg(DM_TRACE, "pack do - QueryGetData() called.");

    if (!(pFE->dwAspect & DVASPECT_CONTENT))
        return S_FALSE;

    if (cf == CF_FILEDESCRIPTOR) {
        DebugMsg(DM_TRACE,"            Getting File Descriptor");
        fRet = (BOOL)(pFE->tymed & TYMED_HGLOBAL);
    }
    else if (cf == CF_FILECONTENTS) {
        DebugMsg(DM_TRACE,"            Getting File Contents");
        fRet = (BOOL)(pFE->tymed & (TYMED_HGLOBAL|TYMED_ISTREAM)); 
    }
    else if (cf == CF_EMBEDSOURCE) {
        DebugMsg(DM_TRACE,"            Getting Embed Source");
        fRet = (BOOL)(pFE->tymed & TYMED_ISTORAGE);
    }
    else if (cf == CF_OBJECTDESCRIPTOR) {
        DebugMsg(DM_TRACE,"            Getting Object Descriptor");
        fRet = (BOOL)(pFE->tymed & TYMED_HGLOBAL);
    }
    else if (cf == CF_METAFILEPICT) {
        DebugMsg(DM_TRACE,"            Getting MetafilePict");
        fRet = (BOOL)(pFE->tymed & TYMED_MFPICT);
    }
    else if (cf == CF_ENHMETAFILE) {
        DebugMsg(DM_TRACE,"            Getting EnhancedMetafile");
        fRet = (BOOL)(pFE->tymed & TYMED_ENHMF);
    }


#ifdef DEBUG
    else {
        TCHAR szFormat[255];
        GetClipboardFormatName(cf, szFormat, ARRAYSIZE(szFormat));
        DebugMsg(DM_TRACE,"            unknown format: %s",szFormat);
        fRet = FALSE;
    }
#endif
            
    DebugMsg(DM_TRACE, "            fRet == %s",fRet ? TEXT("TRUE") : TEXT("FALSE"));
    return fRet ? S_OK : S_FALSE;
}

    
HRESULT CPackage_IDataObject::GetCanonicalFormatEtc(LPFORMATETC pFEIn,
LPFORMATETC pFEOut)
{
    DebugMsg(DM_TRACE, "pack do - GetCanonicalFormatEtc() called.");
    
    if (!pFEOut)  
        return E_INVALIDARG;
    
    pFEOut->ptd = NULL;
    return DATA_S_SAMEFORMATETC;
}

    
HRESULT CPackage_IDataObject::SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM,
BOOL fRelease) 
{
    HRESULT hr;
    
    DebugMsg(DM_TRACE, "pack do - SetData() called.");

    if ((pFE->cfFormat == CF_FILENAMEW) && (pFE->tymed & (TYMED_HGLOBAL|TYMED_FILE)))
    {
        LPWSTR pwsz = pSTM->tymed == TYMED_HGLOBAL ? (LPWSTR)pSTM->hGlobal : pSTM->lpszFileName;
        
#ifdef UNICODE
        
        hr = _pPackage->CmlInitFromFile(pwsz, TRUE, CMDLINK);
        
#else
        CHAR szPath[MAX_PATH];
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szPath, ARRAYSIZE(szPath), NULL, NULL);
        hr = _pPackage->CmlInitFromFile(szPath, TRUE, CMDLINK);
        
#endif // UNICODE

        _pPackage->_pCml->fCmdIsLink = TRUE;
    }

    return DATA_E_FORMATETC;
}

    
HRESULT CPackage_IDataObject::EnumFormatEtc(DWORD dwDirection,
LPENUMFORMATETC *ppEnum)
{
    DebugMsg(DM_TRACE, "pack do - EnumFormatEtc() called.");
    
    // NOTE: This means that we'll have to put the appropriate entries in 
    // the registry for this to work.
    //
    return OleRegEnumFormatEtc(CLSID_CPackage, dwDirection, ppEnum);
}

    
HRESULT CPackage_IDataObject::DAdvise(LPFORMATETC pFE, DWORD grfAdv,
LPADVISESINK pAdvSink, LPDWORD pdwConnection)
{
    HRESULT hr;

    DebugMsg(DM_TRACE, "pack do - DAdvise() called.");
    
    if (_pPackage->_pIDataAdviseHolder == NULL) {
        hr = CreateDataAdviseHolder(&_pPackage->_pIDataAdviseHolder);
        if (FAILED(hr))
            return E_OUTOFMEMORY;
    }

    return _pPackage->_pIDataAdviseHolder->Advise(this, pFE, grfAdv, pAdvSink,
        pdwConnection);
}

     
HRESULT CPackage_IDataObject::DUnadvise(DWORD dwConnection)
{
    DebugMsg(DM_TRACE, "pack do - DUnadvise() called.");
    
    if (_pPackage->_pIDataAdviseHolder == NULL) 
        return E_UNEXPECTED;
    
    return _pPackage->_pIDataAdviseHolder->Unadvise(dwConnection);
}

   
HRESULT CPackage_IDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnum)
{
    DebugMsg(DM_TRACE, "pack do - EnumAdvise() called.");
    
    if (_pPackage->_pIDataAdviseHolder == NULL)
        return E_UNEXPECTED;
    
    return _pPackage->_pIDataAdviseHolder->EnumAdvise(ppEnum);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\iviewobj.cpp ===
#include "privcpp.h"

const DWORD g_cookie = 111176;

CPackage_IViewObject2::CPackage_IViewObject2(CPackage *pPackage) : 
    _pPackage(pPackage)
{
    ASSERT(_cRef == 0);
    ASSERT(_fFrozen == FALSE);
}

CPackage_IViewObject2::~CPackage_IViewObject2()
{
    DebugMsg(DM_TRACE, "CPackage_IViewObject2 destroyed with ref count %d",_cRef);
}

//////////////////////////////////
//
// IUnknown Methods...
//
HRESULT CPackage_IViewObject2::QueryInterface(REFIID iid, void ** ppv)
{
    return _pPackage->QueryInterface(iid,ppv);
}

ULONG CPackage_IViewObject2::AddRef(void) 
{
    _cRef++;    // interface ref count for debugging
    return _pPackage->AddRef();
}

ULONG CPackage_IViewObject2::Release(void)
{
    _cRef--;    // interface ref count for debugging
    return _pPackage->Release();
}


//////////////////////////////////
//
// IViewObject2 Methods...
//
HRESULT CPackage_IViewObject2::Draw(DWORD dwDrawAspect, LONG lindex,
    LPVOID pvAspect, DVTARGETDEVICE *ptd, HDC hdcTargetDev, HDC hdcDraw,
    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,BOOL (CALLBACK *pfnContinue)(ULONG_PTR),
    ULONG_PTR dwContinue)
{
    DebugMsg(DM_TRACE,"pack vo - Draw() called.");
    
    //
    // NOTE: If we're frozen, we should use a cached represetation, but
    // the icon doesn't really change all that often, so it's kind of 
    // pointless to freeze it, but here's where we'd do it, if we 
    // wanted to.  About the only place this would ever be necessary if 
    // somebody called to freeze us while the user was in the process of 
    // editing the package or something, but I don't think it's something
    // we need to worry about right away.  (Especially since the user can't
    // change the icon right now.)
    //

    IconDraw(_pPackage->_lpic, hdcDraw, (RECT *)lprcBounds);
    return S_OK;
}

    
HRESULT CPackage_IViewObject2::GetColorSet(DWORD dwAspect, LONG lindex, 
                                LPVOID pvAspect, DVTARGETDEVICE *ptd, 
                                HDC hdcTargetDev, LPLOGPALETTE *ppColorSet)
{
    DebugMsg(DM_TRACE,"pack vo - GetColorSet() called.");
    
    if (ppColorSet == NULL)
        return E_INVALIDARG;
    
    *ppColorSet = NULL;         // null the out param
    return S_FALSE;
}

    
HRESULT CPackage_IViewObject2::Freeze(DWORD dwDrawAspect, LONG lindex, 
                                      LPVOID pvAspect, LPDWORD pdwFreeze)
{
    DebugMsg(DM_TRACE,"pack vo - Freeze() called.");

    if (pdwFreeze == NULL)
        return E_INVALIDARG;
    
    if (_fFrozen) {
        *pdwFreeze = g_cookie;
        return S_OK;
    }
    
    //
    // This is where we would take a snapshot of the icon to use as
    // the "frozen" image in subsequent routines.  For now, we just
    // return the cookie.  Draw() will use the current icon regardless 
    // of the fFrozen flag.
    //
    
    _fFrozen = TRUE;
    *pdwFreeze = g_cookie;
    
    return S_OK;
}

    
HRESULT CPackage_IViewObject2::Unfreeze(DWORD dwFreeze)
{
    DebugMsg(DM_TRACE,"pack vo - Unfreeze() called.");
    
    // If the pass us an invalid cookie or we're not frozen then bail
    if (dwFreeze != g_cookie || !_fFrozen)
        return OLE_E_NOCONNECTION;
    
    // 
    // This is where we'd get rid of the frozen presentation we saved in
    // IViewObject::Freeze().
    //
    _fFrozen = FALSE;
    return S_OK;
}

    
HRESULT CPackage_IViewObject2::SetAdvise(DWORD dwAspects, DWORD dwAdvf,
                              LPADVISESINK pAdvSink)
{
    DebugMsg(DM_TRACE,"pack vo - SetAdvise() called.");
    
    if (_pPackage->_pViewSink)
        _pPackage->_pViewSink->Release();
    
    _pPackage->_pViewSink = pAdvSink;
    _pPackage->_dwViewAspects = dwAspects;
    _pPackage->_dwViewAdvf = dwAdvf;
    
    if (_pPackage->_pViewSink) 
        _pPackage->_pViewSink->AddRef();
    
    return S_OK;
}

    
HRESULT CPackage_IViewObject2::GetAdvise(LPDWORD pdwAspects, LPDWORD pdwAdvf,
                              LPADVISESINK *ppAdvSink)
{
    DebugMsg(DM_TRACE,"pack vo - GetAdvise() called.");
    
    if (!ppAdvSink || !pdwAdvf || !pdwAspects)
        return E_INVALIDARG;
    
    *ppAdvSink = _pPackage->_pViewSink;
    _pPackage->_pViewSink->AddRef();
    
    if (pdwAspects != NULL)
        *pdwAspects = _pPackage->_dwViewAspects;
    
    if (pdwAdvf != NULL)
        *pdwAdvf = _pPackage->_dwViewAdvf;
    
    return S_OK;
}

    
HRESULT CPackage_IViewObject2::GetExtent(DWORD dwAspect, LONG lindex,
DVTARGETDEVICE *ptd, LPSIZEL pszl)
{
    DebugMsg(DM_TRACE,"pack vo - GetExtent() called.");

    if (pszl == NULL)
        return E_INVALIDARG;
    
    if (!_pPackage->_lpic)
        return OLE_E_BLANK;
            
    pszl->cx = _pPackage->_lpic->rc.right;
    pszl->cy = _pPackage->_lpic->rc.bottom;
    
    pszl->cx = MulDiv(pszl->cx,HIMETRIC_PER_INCH,DEF_LOGPIXELSX);
    pszl->cy = MulDiv(pszl->cy,HIMETRIC_PER_INCH,DEF_LOGPIXELSY);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packager.cpp ===
#include "privcpp.h"

class ATL_NO_VTABLE CPackager :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComControl<CPackager>,
        public IOleObjectImpl<CPackager>,
        public IViewObjectExImpl<CPackager>,
        public IDataObject,
        public IPersistStorage,
        public IPersistFile,
        public IAdviseSink,
        public IRunnableObjectImpl<CPackager>
{
BEGIN_COM_MAP(CPackager)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IAdviseSink)
    COM_INTERFACE_ENTRY(IRunnableObject)
END_COM_MAP()

BEGIN_MSG_MAP(CPackager)
CHAIN_MSG_MAP(CComControl<CPackager>)
END_MSG_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\pack2.cpp ===
#include "privcpp.h"

#define CPP_FUNCTIONS
// #include <crtfree.h>

UINT    g_cfFileContents;
UINT    g_cfFileDescriptor;
UINT    g_cfObjectDescriptor;
UINT    g_cfEmbedSource;
UINT    g_cfFileNameW;

INT     g_cxIcon;
INT     g_cyIcon;
INT     g_cxArrange;
INT     g_cyArrange;
HFONT   g_hfontTitle;

static TCHAR szUserType[] = TEXT("Package");
static TCHAR szDefTempFile[] = TEXT("PKG");

CPackage::CPackage() : 
    _cRef(1)
{
    DebugMsg(DM_TRACE, "pack - CPackage() called.");
    g_cRefThisDll++;

    // Excel v.5 - v2000 has a hosting bug when they host an object as a link.
    // They always remove their hpmbed->hpobj object, yet all their methods
    // on the IOleClientSite interface they give us dereference this and fault.
    //
    TCHAR szProcess[MAX_PATH];
    if (GetModuleFileName(NULL, szProcess, ARRAYSIZE(szProcess)) &&
        !lstrcmp(TEXT("EXCEL.EXE"), PathFindFileName(szProcess)))
        _fNoIOleClientSiteCalls = TRUE;
    
    ASSERT(_cf == 0);
    ASSERT(_panetype == NOTHING);
    ASSERT(_pEmbed == NULL);
    ASSERT(_pCml == NULL);
    ASSERT(_fLoaded == FALSE);
    
    ASSERT(_lpszContainerApp == NULL);
    ASSERT(_lpszContainerObj == NULL);
    
    ASSERT(_fIsDirty == FALSE);
    
    ASSERT(_pIStorage == NULL);       
    ASSERT(_pstmFileContents == NULL);
    ASSERT(_pstm == NULL);
    
    ASSERT(_pIPersistStorage == NULL);
    ASSERT(_pIDataObject == NULL);
    ASSERT(_pIOleObject == NULL);    
    ASSERT(_pIViewObject2 == NULL);
    ASSERT(_pIAdviseSink == NULL);
    ASSERT(_pIRunnableObject == NULL);
        
    ASSERT(_pIDataAdviseHolder == NULL);
    ASSERT(_pIOleAdviseHolder == NULL);
    ASSERT(_pIOleClientSite == NULL);
    
    ASSERT(_pViewSink == NULL);
    ASSERT(_dwViewAspects == 0);
    ASSERT(_dwViewAdvf == 0);

    ASSERT(_cVerbs == 0);
    ASSERT(_nCurVerb == 0);
    ASSERT(_pVerbs == NULL);
    ASSERT(_pcm == NULL);
}


CPackage::~CPackage()
{
    DebugMsg(DM_TRACE, "pack - ~CPackage() called.");
   
    // We should never be destroyed unless our ref count is zero.
    ASSERT(_cRef == 0);
    
    g_cRefThisDll--;
    
    // Destroy our interfaces...
    //
    delete _pIOleObject;
    delete _pIViewObject2;
    delete _pIDataObject;
    delete _pIPersistStorage;
    delete _pIAdviseSink;
    delete _pIRunnableObject;

    // Destroy the packaged file structure...
    //
    DestroyIC();
    
    // we destroy depending on which type of object we had packaged
    switch(_panetype)
    {
    case PEMBED:
        if (_pEmbed->pszTempName) {
            DeleteFile(_pEmbed->pszTempName);
            delete _pEmbed->pszTempName;
        }
        delete _pEmbed;
        break;
        
    case CMDLINK:
        delete _pCml;
        break;

    }
    
    // Release Advise pointers...
    //
    if (_pIDataAdviseHolder)
        _pIDataAdviseHolder->Release();
    if (_pIOleAdviseHolder)
        _pIOleAdviseHolder->Release();
    if (_pIOleClientSite)
        _pIOleClientSite->Release();


    // Release Storage pointers...
    //
    if (_pIStorage)
        _pIStorage->Release();
    if (_pstmFileContents)
        _pstmFileContents->Release();
    if (_pstm)
        _pstm->Release();
    
    delete _lpszContainerApp;
    delete _lpszContainerObj;

    ReleaseContextMenu();
    if (NULL != _pVerbs)
    {
        for (ULONG i = 0; i < _cVerbs; i++)
        {
            delete _pVerbs[i].lpszVerbName;
        }
        delete _pVerbs;
    }
    
    DebugMsg(DM_TRACE,"CPackage being destroyed. _cRef == %d",_cRef);
}

HRESULT CPackage::Init() 
{
    // 
    // initializes parts of a package object that have a potential to fail
    // return:  S_OK            -- everything initialized
    //          E_FAIL          -- error in initialzation
    //          E_OUTOFMEMORY   -- out of memory
    //
    
    DebugMsg(DM_TRACE, "pack - Init() called.");

    // Initialize all the interfaces...
    //
    if (!(_pIOleObject        = new CPackage_IOleObject(this)))
        return E_OUTOFMEMORY;
    if (!(_pIViewObject2      = new CPackage_IViewObject2(this)))
        return E_OUTOFMEMORY;
    if (!(_pIDataObject       = new CPackage_IDataObject(this)))
        return E_OUTOFMEMORY;
    if (!(_pIPersistStorage   = new CPackage_IPersistStorage(this)))
        return E_OUTOFMEMORY;
    if (!(_pIPersistFile      = new CPackage_IPersistFile(this)))
        return E_OUTOFMEMORY;
    if (!(_pIAdviseSink       = new CPackage_IAdviseSink(this)))
        return E_OUTOFMEMORY;
    if (!(_pIRunnableObject   = new CPackage_IRunnableObject(this)))
        return E_OUTOFMEMORY;
    
    // Get some system metrics that we'll need later...
    //
    LOGFONT lf;
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    SystemParametersInfo(SPI_ICONHORIZONTALSPACING, 0, &g_cxArrange, FALSE);
    SystemParametersInfo(SPI_ICONVERTICALSPACING, 0, &g_cyArrange, FALSE);
    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_hfontTitle = CreateFontIndirect(&lf);
    
    // register some clipboard formats that we support...
    //
    g_cfFileContents    = RegisterClipboardFormat(CFSTR_FILECONTENTS);
    g_cfFileDescriptor  = RegisterClipboardFormat(CFSTR_FILEDESCRIPTOR);
    g_cfObjectDescriptor= RegisterClipboardFormat(CFSTR_OBJECTDESCRIPTOR);
    g_cfEmbedSource     = RegisterClipboardFormat(CFSTR_EMBEDSOURCE);
    g_cfFileNameW       = RegisterClipboardFormat(TEXT("FileNameW"));
    
    // Initialize a generic icon
    _lpic = IconCreate();
    IconRefresh();
   

    return S_OK;
}

////////////////////////////////////////////////////////////////////////
//
// IUnknown Methods...
//
////////////////////////////////////////////////////////////////////////

HRESULT CPackage::QueryInterface(REFIID iid, void ** ppvObj)
{
    DebugMsg(DM_TRACE, "pack - QueryInterface() called.");
    
    if (iid == IID_IUnknown) {
        DebugMsg(DM_TRACE, "         getting IID_IUnknown");
        *ppvObj = (void *)this;
    }
    else if (iid == IID_IOleObject) {
        DebugMsg(DM_TRACE, "         getting IID_IOleObject");
        *ppvObj = (void *)_pIOleObject;
    }
    else if ((iid == IID_IViewObject2) || (iid == IID_IViewObject)) {
        DebugMsg(DM_TRACE, "         getting IID_IViewObject");
        *ppvObj = (void *)_pIViewObject2;
    }
    else if (iid == IID_IDataObject) {
        DebugMsg(DM_TRACE, "         getting IID_IDataObject");
        *ppvObj = (void *)_pIDataObject;
    }
    else if ((iid == IID_IPersistStorage) || (iid == IID_IPersist)) {
        DebugMsg(DM_TRACE, "         getting IID_IPersistStorage");
        *ppvObj = (void *)_pIPersistStorage;
    }
    else if (iid == IID_IPersistFile) {
        DebugMsg(DM_TRACE, "         getting IID_IPersistFile");
        *ppvObj = (void *)_pIPersistFile;
    }
    else if (iid == IID_IAdviseSink) {
        DebugMsg(DM_TRACE, "         getting IID_IAdviseSink");
        *ppvObj = (void *)_pIAdviseSink;
    }
    else if (iid == IID_IRunnableObject) {
        DebugMsg(DM_TRACE, "         getting IID_IRunnableObject");
        *ppvObj = (void *)_pIRunnableObject;
    }
    else if (iid == IID_IEnumOLEVERB)
    {
        DebugMsg(DM_TRACE, "         getting IID_IEnumOLEVERB");
        *ppvObj = (IEnumOLEVERB*) this;
    }
    else {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppvObj)->AddRef();
    return S_OK;
}

ULONG CPackage::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CPackage::Release()
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CPackage_CreateInstnace(LPUNKNOWN * ppunk)
{
    DebugMsg(DM_TRACE, "pack - CreateInstance called");
    
    *ppunk = NULL;              // null the out param
    
    CPackage* pPack = new CPackage;
    if (!pPack)  
        return E_OUTOFMEMORY;
    
    if (FAILED(pPack->Init())) {
        delete pPack;
        return E_OUTOFMEMORY;
    }

    *ppunk = pPack;
    return S_OK;
}

STDMETHODIMP CPackage::Next(ULONG celt, OLEVERB* rgVerbs, ULONG* pceltFetched)
{
    HRESULT hr;
    if (NULL != rgVerbs)
    {
        if (1 == celt)
        {
            if (_nCurVerb < _cVerbs)
            {
                ASSERT(NULL != _pVerbs);
                *rgVerbs = _pVerbs[_nCurVerb];
                if ((NULL != _pVerbs[_nCurVerb].lpszVerbName) &&
                    (NULL != (rgVerbs->lpszVerbName = (LPWSTR) CoTaskMemAlloc(
                        (lstrlenW(_pVerbs[_nCurVerb].lpszVerbName) + 1) * SIZEOF(WCHAR)))))
                {
                    StrCpyW(rgVerbs->lpszVerbName, _pVerbs[_nCurVerb].lpszVerbName);
                }
                _nCurVerb++;
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
            if (NULL != pceltFetched)
            {
                *pceltFetched = (S_OK == hr) ? 1 : 0;
            }
        }
        else if (NULL != pceltFetched)
        {
            int cVerbsToCopy = min(celt, _cVerbs - _nCurVerb);
            if (cVerbsToCopy > 0)
            {
                ASSERT(NULL != _pVerbs);
                CopyMemory(rgVerbs, &(_pVerbs[_nCurVerb]), cVerbsToCopy * sizeof(OLEVERB));
                for (int i = 0; i < cVerbsToCopy; i++)
                {
                    if ((NULL != _pVerbs[_nCurVerb + i].lpszVerbName) &&
                        (NULL != (rgVerbs[i].lpszVerbName = (LPWSTR) CoTaskMemAlloc(
                            (lstrlenW(_pVerbs[_nCurVerb + i].lpszVerbName) + 1) * SIZEOF(WCHAR)))))
                    {
                        StrCpyW(rgVerbs[i].lpszVerbName, _pVerbs[_nCurVerb + i].lpszVerbName);
                    }
                }
                _nCurVerb += cVerbsToCopy;
            }
            *pceltFetched = (ULONG) cVerbsToCopy;
            hr = (celt == (ULONG) cVerbsToCopy) ? S_OK : S_FALSE;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CPackage::Skip(ULONG celt)
{
    if (_nCurVerb + celt > _cVerbs)
    {
        // there aren't enough elements, go to the end and return S_FALSE
        _nCurVerb = _cVerbs;
        return S_FALSE;
    }
    else
    {
        _nCurVerb += celt;
        return S_OK;
    }
}

STDMETHODIMP CPackage::Reset()
{
    _nCurVerb = 0;
    return S_OK;
}

STDMETHODIMP CPackage::Clone(IEnumOLEVERB** ppEnum)
{
    if (NULL != ppEnum)
    {
        *ppEnum = NULL;
    }
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////
//
// Package helper functions
//
///////////////////////////////////////////////////////////////////

HRESULT  CPackage::EmbedInitFromFile(LPCTSTR lpFileName, BOOL fInitFile) 
{
    //
    // get's the file size of the packaged file and set's the name 
    // of the packaged file if fInitFile == TRUE.
    // return:  S_OK    -- initialized ok
    //          E_FAIL  -- error initializing file
    //
    
    DWORD dwSize;

    
    // if this is the first time we've been called, then we need to allocate
    // memory for the _pEmbed structure
    if (_pEmbed == NULL) 
    {
        _pEmbed = new EMBED;
        if (_pEmbed)
        {
            _pEmbed->pszTempName = NULL;
            _pEmbed->hTask = NULL;
            _pEmbed->poo = NULL;
            _pEmbed->fIsOleFile = TRUE;
        }
    }

    if (_pEmbed == NULL)
        return E_OUTOFMEMORY;

    
    // open the file to package...
    //
    HANDLE fh = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READWRITE, 
            NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL); 
    if (fh == INVALID_HANDLE_VALUE) 
    {
        DWORD dwError = GetLastError();
        return E_FAIL;
    }

    _panetype = PEMBED;
    
    // Get the size of the file
    _pEmbed->fd.nFileSizeLow = GetFileSize(fh, &dwSize);
    if (_pEmbed->fd.nFileSizeLow == 0xFFFFFFFF) 
    {
        DWORD dwError = GetLastError();
        return E_FAIL;
    }
    ASSERT(dwSize == 0);
    _pEmbed->fd.nFileSizeHigh = 0L;
    _pEmbed->fd.dwFlags = FD_FILESIZE;

    // We only want to set the filename if this is the file to be packaged.
    // If it's only a temp file that we're reloading (fInitFile == FALSE) then
    // don't bother setting the filename.
    //
    if (fInitFile) 
    {
        lstrcpy(_pEmbed->fd.cFileName,lpFileName);
        DestroyIC();
        _lpic = IconCreateFromFile(lpFileName);
        if (_pIDataAdviseHolder)
            _pIDataAdviseHolder->SendOnDataChange(_pIDataObject,0, NULL);
        if (_pViewSink)
            _pViewSink->OnViewChange(_dwViewAspects,_dwViewAdvf);
    }

    _fIsDirty = TRUE;
    CloseHandle(fh);
    return S_OK;
}    

HRESULT CPackage::CmlInitFromFile(LPTSTR lpFileName, BOOL fUpdateIcon, PANETYPE paneType) 
{
    // if this is the first time we've been called, then we need to allocate
    // memory for the _pCml structure
    if (_pCml == NULL) 
    {
        _pCml = new CML;
        if (_pCml)
        {
            // we don't use this, but an old packager accessing us might.
            _pCml->fCmdIsLink = FALSE;
        }
    }

    if (_pCml == NULL)
        return E_OUTOFMEMORY;

    _panetype = paneType;
    lstrcpy(_pCml->szCommandLine,lpFileName);
    _fIsDirty = TRUE;
    
    if (fUpdateIcon)
    {
        DestroyIC();
        _lpic = IconCreateFromFile(lpFileName);
    
        if (_pIDataAdviseHolder)
            _pIDataAdviseHolder->SendOnDataChange(_pIDataObject,0, NULL);
    
        if (_pViewSink)
            _pViewSink->OnViewChange(_dwViewAspects,_dwViewAdvf);
    }
    return S_OK;
}    


HRESULT CPackage::InitFromPackInfo(LPPACKAGER_INFO lppi)
{
    HRESULT hr;
    DWORD   dwFileAttributes = GetFileAttributes(lppi->szFilename);
    
    // Ok, we need to test whether the user tried to package a folder
    // instead of a file.  If s/he did, then we'll just create a link
    // to that folder instead of an embedded file.
    //

    if (-1 == dwFileAttributes)
    {
        hr = CmlInitFromFile(lppi->szFilename, FALSE, PACKAGE);
    }
    else if (dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        hr = CmlInitFromFile(lppi->szFilename, FALSE, CMDLINK);
    }
    else
    {
        // we pass FALSE here, because we don't want to write the icon
        // information.
        //      
        hr = EmbedInitFromFile(lppi->szFilename, FALSE);
        lstrcpy(_pEmbed->fd.cFileName,lppi->szFilename);
        _panetype = PEMBED;
    }

    // set the icon information    
    if (PathFileExists(lppi->szFilename))
        lstrcpy(_lpic->szIconPath, *lppi->szIconPath? lppi->szIconPath : lppi->szFilename);

    _lpic->iDlgIcon = lppi->iIcon;
    lstrcpy(_lpic->szIconText,lppi->szLabel);
    
    IconRefresh();

    // we need to tell the client we want to be saved...it should be smart
    // enough to do it anyway, but we can't take any chances.
    if (_pIOleClientSite)
        _pIOleClientSite->SaveObject();

    return hr;
}    

HRESULT CPackage::CreateTempFileName()
{
    ASSERT(NULL != _pEmbed);
    TCHAR szDefPath[MAX_PATH];
    if (_pEmbed->pszTempName)
    {
        return S_OK;
    }
    else if (GetTempPath(ARRAYSIZE(szDefPath), szDefPath))
    {
        LPTSTR pszFile;
        if ((NULL != _lpic) && (TEXT('\0') != _lpic->szIconText[0]))
        {
            pszFile = _lpic->szIconText;
        }
        else
        {
            pszFile = PathFindFileName(_pEmbed->fd.cFileName);
        }
        PathAppend(szDefPath, pszFile);
        if (PathFileExists(szDefPath))
        {
            TCHAR szOriginal[MAX_PATH];
            lstrcpy(szOriginal, szDefPath);
            PathYetAnotherMakeUniqueName(szDefPath, szOriginal, NULL, NULL);
        }
        
        _pEmbed->pszTempName = new TCHAR[lstrlen(szDefPath) + 1];
        if (!_pEmbed->pszTempName) 
        {
            DebugMsg(DM_TRACE,"            couldn't alloc memory for pszTempName!!");
            return E_OUTOFMEMORY;
        }    
        lstrcpy(_pEmbed->pszTempName, szDefPath);
        return S_OK;
    }
    else
    {
        DebugMsg(DM_TRACE,"            couldn't get temp path!!");
        return E_FAIL;
    }
}

HRESULT CPackage::CreateTempFile() 
{
    //
    // used to create a temporary file that holds the file contents of the
    // packaged file.  the old packager used to keep the packaged file in 
    // memory which is just a total waste.  so, being as we're much more 
    // efficient, we create a temp file whenever someone wants to do something
    // with our contents.  we initialze the temp file from the original file
    // to package or our persistent storage depending on whether we are a new
    // package or a loaded package
    // return:  S_OK    -- temp file created
    //          E_FAIL  -- error creating temp file
    //
    
    DebugMsg(DM_TRACE,"            CreateTempFile() called.");

    HRESULT hr = CreateTempFileName();
    if (FAILED(hr))
    {
        return hr;
    }

    if (PathFileExists(_pEmbed->pszTempName))
    {
        DebugMsg(DM_TRACE,"            already have a temp file!!");
        return S_OK;
    }
    
    // if we weren't loaded from a storage then we're in the process of
    // creating a package, and should be able to copy the packaged file
    // to create a temp file
    //
    if (!_fLoaded) 
    {
        if (!(CopyFile(_pEmbed->fd.cFileName, _pEmbed->pszTempName, FALSE))) 
        {
            DebugMsg(DM_TRACE,"            couldn't copy file!!");
            return E_FAIL;
        }
    }
    else 
    {
        TCHAR szTempFile[MAX_PATH];
        // copy the file name because _pEmbed may get re-created below,
        // but we want to hold on to this filename:
        lstrcpy(szTempFile, _pEmbed->pszTempName);
        
        // if we have a valid stream, but not a file contents stream, 
        // it's because we went hands off and didn't know where to put
        // the seek pointer to init the filecontents stream.  so, we
        // call PackageReadFromStream to create the FileContents stream
        //
        if (_pstm && !_pstmFileContents) 
        {
            if (FAILED(PackageReadFromStream(_pstm))) 
            {
                DebugMsg(DM_TRACE,"            couldn't read from stream!!");
                return E_FAIL;
            }
        }
        
        IStream* pstm;
        _pstmFileContents->Clone(&pstm);  // we don't want to move the seek
                                          // pointer on our FileContents stream
        
        if (FAILED(CopyStreamToFile(pstm, szTempFile))) 
        {
            DebugMsg(DM_TRACE,"            couldn't copy from stream!!");
            pstm->Release();
            return E_FAIL;
        }
        else
        {
            ASSERT(_pEmbed);
            delete _pEmbed->pszTempName;
            if (NULL != (_pEmbed->pszTempName = new TCHAR[lstrlen(szTempFile) + 1]))
            {
                lstrcpy(_pEmbed->pszTempName, szTempFile);
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        pstm->Release();
    }

    
    // whenever we create a tempfile we are activating the contents which 
    // means we are dirty until we get a save message
    return S_OK;
}



///////////////////////////////////////////////////////////////////////
//
// Data Transfer Functions
//
///////////////////////////////////////////////////////////////////////

HRESULT CPackage::GetFileDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    FILEGROUPDESCRIPTOR *pfgd;

    
    DebugMsg(DM_TRACE,"            Getting File Descriptor");

    // we only support HGLOBAL at this time
    //
    if (!(pFE->tymed & TYMED_HGLOBAL)) {
        DebugMsg(DM_TRACE,"            does not support HGLOBAL!");
        return DATA_E_FORMATETC;
    }

    //// Copy file descriptor to HGLOBAL ///////////////////////////
    //
    pSTM->tymed = TYMED_HGLOBAL;
    
    // render the file descriptor 
    if (!(pfgd = (FILEGROUPDESCRIPTOR *)GlobalAlloc(GPTR,
        sizeof(FILEGROUPDESCRIPTOR))))
        return E_OUTOFMEMORY;

    pSTM->hGlobal = pfgd;
    
    pfgd->cItems = 1;

    switch(_panetype) 
    {
        case PEMBED:
            pfgd->fgd[0] = _pEmbed->fd;
            GetDisplayName(pfgd->fgd[0].cFileName, _pEmbed->fd.cFileName);
            break;

        case CMDLINK:
            // the label for the package will serve as the filename for the
            // shortcut we're going to create.
            lstrcpy(pfgd->fgd[0].cFileName, _lpic->szIconText);
            // harcoded use of .lnk extension!!
            lstrcat(pfgd->fgd[0].cFileName, TEXT(".lnk"));

            // we want to add the little arrow to the shortcut.
            pfgd->fgd[0].dwFlags = FD_LINKUI;
            break;
    }
    return S_OK;
}

HRESULT CPackage::GetFileContents(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    void *  lpvDest = NULL;
    DWORD   dwSize;
    HANDLE  hFile = NULL;
    DWORD   cb;
    HRESULT hr = E_FAIL;
    
    DebugMsg(DM_TRACE,"            Getting File Contents");
    
    //// Copy file contents to ISTREAM ///////////////////////////
    // 
    // NOTE: Hopefully, everyone using our object supports TYMED_ISTREAM,
    // otherwise we could get some really slow behavior.  We might later
    // want to implement TYMED_ISTORAGE as well and shove our file contents
    // into a single stream named CONTENTS.
    //
    if (pFE->tymed & TYMED_ISTREAM) {
        DebugMsg(DM_TRACE,"            using TYMED_ISTREAM");
        pSTM->tymed = TYMED_ISTREAM;

        switch (_panetype) {
            case PEMBED:
                if (_pstmFileContents)
                    hr = _pstmFileContents->Clone(&pSTM->pstm);
                else 
                    return E_FAIL;
                break;

            case CMDLINK:
                hr = CreateStreamOnHGlobal(NULL, TRUE, &pSTM->pstm);
                if (SUCCEEDED(hr))
                {
                    hr = CreateShortcutOnStream(pSTM->pstm);
                    if (FAILED(hr))
                    {
                        pSTM->pstm->Release();
                        pSTM->pstm = NULL;
                    }
                }
                break;
        }
        return hr;
    }
    
    //// Copy file contents to HGLOBAL ///////////////////////////
    //
    // NOTE: This is really icky and could potentially be very slow if
    // somebody decides to package really large files.  Hopefully, 
    // everyone should be able to get the info it wants through TYMED_ISTREAM,
    // but this is here as a common denominator
    //
    if (pFE->tymed & TYMED_HGLOBAL) {
        DebugMsg(DM_TRACE,"            using TYMED_HGLOBAL");
        pSTM->tymed = TYMED_HGLOBAL;

        if (_panetype == CMDLINK) {
            DebugMsg(DM_TRACE,
                "    H_GLOBAL not supported for CMDLINK");
            return DATA_E_FORMATETC;
        }
        
        dwSize = _pEmbed->fd.nFileSizeLow;
        
        // caller is responsible for freeing this memory, even if we fail.
        if (!(lpvDest = GlobalAlloc(GPTR, dwSize))) {
            DebugMsg(DM_TRACE,"            out o memory!!");
            return E_OUTOFMEMORY;
        }
        pSTM->hGlobal = lpvDest;
        
        // This will reinitialize our FileContents stream if we had to get
        // rid of it.  For instance, we have to get rid of all our storage
        // pointers in HandsOffStorage, but there's no need to reinit our 
        // FileContents stream unless we need it again.
        //
        if (_pstm && !_pstmFileContents)
            PackageReadFromStream(_pstm);
        
        if (_pstmFileContents) {
            IStream* pstm;
            hr = _pstmFileContents->Clone(&pstm);
            if (FAILED(hr))
                return hr;
            hr = pstm->Read(lpvDest, dwSize, &cb);
            pstm->Release();
            if (FAILED(hr))
                return hr;
        }
        else
            return E_FAIL;
        
        if (FAILED(hr) || cb != dwSize) {
            DebugMsg(DM_TRACE,"            error reading from stream!!");
            return E_FAIL;
        }
        return hr;
    }
    
    return DATA_E_FORMATETC;
}

void DrawIconToDC(HDC hdcMF, LPIC lpic)
{
    RECT  rcTemp;
    HFONT hfont = NULL;

    // Initializae the metafile
    SetWindowOrgEx(hdcMF, 0, 0, NULL);
    SetWindowExtEx(hdcMF, lpic->rc.right - 1, lpic->rc.bottom - 1, NULL);

    SetRect(&rcTemp, 0, 0, lpic->rc.right,lpic->rc.bottom);
    hfont = SelectFont(hdcMF, g_hfontTitle);
    
    // Center the icon
    DrawIcon(hdcMF, (rcTemp.right - g_cxIcon) / 2, 0, lpic->hDlgIcon);
    
    // Center the text below the icon
    SetBkMode(hdcMF, TRANSPARENT);
    SetTextAlign(hdcMF, TA_CENTER);
    TextOut(hdcMF, rcTemp.right / 2, g_cxIcon + 1, lpic->szIconText,
            lstrlen(lpic->szIconText));

    if (hfont)
        SelectObject(hdcMF, hfont);
}


HRESULT CPackage::GetMetafilePict(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    LPMETAFILEPICT      lpmfpict;
    RECT                rcTemp;
    LPIC                lpic = _lpic;
    HDC                 hdcMF = NULL;
    
    
    DebugMsg(DM_TRACE,"            Getting MetafilePict");
    
    if (!(pFE->tymed & TYMED_MFPICT)) {
        DebugMsg(DM_TRACE,"            does not support MFPICT!");
        return DATA_E_FORMATETC;
    }
    pSTM->tymed = TYMED_MFPICT;
    
    // Allocate memory for the metafilepict and get a pointer to it
    // NOTE: the caller is responsible for freeing this memory, even on fail
    //
    if (!(pSTM->hMetaFilePict = GlobalAlloc(GPTR, sizeof(METAFILEPICT))))
        return E_OUTOFMEMORY;
    lpmfpict = (LPMETAFILEPICT)pSTM->hMetaFilePict;
        
    // Create the metafile
    if (!(hdcMF = CreateMetaFile(NULL))) 
        return E_OUTOFMEMORY;

    DrawIconToDC(hdcMF, lpic);
    
    // Map to device independent coordinates
    SetRect(&rcTemp, 0, 0, lpic->rc.right,lpic->rc.bottom);
    rcTemp.right =
        MulDiv((rcTemp.right - rcTemp.left), HIMETRIC_PER_INCH, DEF_LOGPIXELSX);
    rcTemp.bottom =
        MulDiv((rcTemp.bottom - rcTemp.top), HIMETRIC_PER_INCH, DEF_LOGPIXELSY);

    // Finish filling in the metafile header
    lpmfpict->mm = MM_ANISOTROPIC;
    lpmfpict->xExt = rcTemp.right;
    lpmfpict->yExt = rcTemp.bottom;
    lpmfpict->hMF = CloseMetaFile(hdcMF);
    
    return S_OK;
}

HRESULT CPackage::GetEnhMetafile(LPFORMATETC pFE, LPSTGMEDIUM pSTM)
{
    DebugMsg(DM_TRACE,"            Getting EnhancedMetafile");
    
    if (!(pFE->tymed & TYMED_ENHMF)) {
        DebugMsg(DM_TRACE,"            does not support ENHMF!");
        return DATA_E_FORMATETC;
    }

    // Map to device independent coordinates
    RECT rcTemp;
    SetRect(&rcTemp, 0, 0, _lpic->rc.right,_lpic->rc.bottom);
    rcTemp.right =
        MulDiv((rcTemp.right - rcTemp.left), HIMETRIC_PER_INCH, DEF_LOGPIXELSX);
    rcTemp.bottom =
        MulDiv((rcTemp.bottom - rcTemp.top), HIMETRIC_PER_INCH, DEF_LOGPIXELSY);

    HDC hdc = CreateEnhMetaFile(NULL, NULL, &rcTemp, NULL);
    if (hdc)
    {
        DrawIconToDC(hdc, _lpic);

        pSTM->tymed = TYMED_ENHMF;
        pSTM->hEnhMetaFile = CloseEnhMetaFile(hdc);

        return S_OK;
    }
    else
    {
        pSTM->tymed = TYMED_NULL;

        return E_OUTOFMEMORY;
    }
}

HRESULT CPackage::GetObjectDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM) 
{
    LPOBJECTDESCRIPTOR lpobj;
    DWORD   dwFullUserTypeNameLen;
    
    DebugMsg(DM_TRACE,"            Getting Object Descriptor");

    // we only support HGLOBAL at this time
    //
    if (!(pFE->tymed & TYMED_HGLOBAL)) {
        DebugMsg(DM_TRACE,"            does not support HGLOBAL!");
        return DATA_E_FORMATETC;
    }

    //// Copy file descriptor to HGLOBAL ///////////////////////////

    dwFullUserTypeNameLen = 0; //lstrlen(szUserType) + 1;
    pSTM->tymed = TYMED_HGLOBAL;

    if (!(lpobj = (OBJECTDESCRIPTOR *)GlobalAlloc(GPTR,
        sizeof(OBJECTDESCRIPTOR)+dwFullUserTypeNameLen)))
        return E_OUTOFMEMORY;

    pSTM->hGlobal = lpobj;
    
    lpobj->cbSize       = sizeof(OBJECTDESCRIPTOR)+dwFullUserTypeNameLen;
    lpobj->clsid        = CLSID_CPackage;
    lpobj->dwDrawAspect = DVASPECT_CONTENT|DVASPECT_ICON;
    _pIOleObject->GetMiscStatus(DVASPECT_CONTENT|DVASPECT_ICON,&(lpobj->dwStatus));
    lpobj->dwFullUserTypeName = 0L; //sizeof(OBJECTDESCRIPTOR);
    lpobj->dwSrcOfCopy = 0L;

    // lstrcpy((LPTSTR)lpobj+lpobj->dwFullUserTypeName, szUserType);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////
//
// Stream I/O Functions
//
/////////////////////////////////////////////////////////////////////////

HRESULT CPackage::PackageReadFromStream(IStream* pstm)
{
    //
    // initialize the package object from a stream
    // return:  s_OK   - package properly initialized
    //          E_FAIL - error initializing package
    //
    
    WORD  w;
    DWORD dw;
    
    DebugMsg(DM_TRACE, "pack - PackageReadFromStream called.");

    // read in the package size, which we don't really need, but the old 
    // packager puts it there.
    if (FAILED(pstm->Read(&dw, sizeof(dw), NULL)))
        return E_FAIL;

    // NOTE: Ok, this is really dumb.  The old packager allowed the user
    // to create packages without giving them icons or labels, which
    // in my opinion is just dumb, it should have at least created a default
    // icon and shoved it in the persistent storage...oh well...
    //     So if the appearance type comes back as NOTHING ( == 0)
    // then we just won't read any icon information.
    
    // read in the appearance type
    pstm->Read(&w, sizeof(w), NULL);
    
    // read in the icon information
    if (w == (WORD)ICON)
    {
        if (FAILED(IconReadFromStream(pstm))) 
        {
            DebugMsg(DM_TRACE,"         error reading icon info!!");
            return E_FAIL;
        }
    }
    else if (w == (WORD)PICTURE)
    {
        DebugMsg(DM_TRACE, "         old Packager Appearance, not supported!!");
        // NOTE: Ideally, we could just ignore the appearance and continue, but to
        // do so, we'll need to know how much information to skip over before continuing
        // to read from the stream
        ShellMessageBox(g_hinst,
                        NULL,
                        MAKEINTRESOURCE(IDS_OLD_FORMAT_ERROR),
                        MAKEINTRESOURCE(IDS_APP_TITLE),
                        MB_OK | MB_ICONERROR | MB_TASKMODAL);
        return E_FAIL;
    }
    
    // read in the contents type
    pstm->Read(&w, sizeof(w), NULL);

    _panetype = (PANETYPE)w;
    
    switch((PANETYPE)w)
    {
    case PEMBED:
        // read in the contents information
        return EmbedReadFromStream(pstm);

    case CMDLINK:
        // read in the contents information
        return CmlReadFromStream(pstm); 

    default:
        return E_FAIL;
    }
}

//
// read the icon info from a stream
// return:  S_OK   -- icon read correctly
//          E_FAIL -- error reading icon
//
HRESULT CPackage::IconReadFromStream(IStream* pstm) 
{
    LPIC lpic = IconCreate();
    if (lpic)
    {
        CHAR szTemp[MAX_PATH];
        StringReadFromStream(pstm, szTemp, ARRAYSIZE(szTemp));
        SHAnsiToTChar(szTemp, lpic->szIconText, ARRAYSIZE(lpic->szIconText));
        
        StringReadFromStream(pstm, szTemp, ARRAYSIZE(szTemp));
        SHAnsiToTChar(szTemp, lpic->szIconPath, ARRAYSIZE(lpic->szIconPath));
        
        WORD wDlgIcon;
        pstm->Read(&wDlgIcon, sizeof(wDlgIcon), NULL);
        lpic->iDlgIcon = (INT) wDlgIcon;
        GetCurrentIcon(lpic);
        IconCalcSize(lpic);
    }

    DestroyIC();
    _lpic = lpic;

    return lpic ? S_OK : E_FAIL;
}

HRESULT CPackage::EmbedReadFromStream(IStream* pstm) 
{
    //
    // reads embedded file contents from a stream
    // return:  S_OK   - contents read succesfully
    //          E_FAIL - error reading contents
    //
    
    DWORD dwSize;
    CHAR  szFileName[MAX_PATH];
    
    DebugMsg(DM_TRACE, "pack - EmbedReadFromStream called.");
    
    pstm->Read(&dwSize, sizeof(dwSize), NULL);  // get string size
    pstm->Read(szFileName, dwSize, NULL);       // get string
    pstm->Read(&dwSize, sizeof(dwSize), NULL);  // get file size

    // we don't do anything with the file contents here, because anything
    // we do could be a potentially expensive operation.  so, we just clone
    // the stream and hold onto it for future use.
    
    if (_pstmFileContents) 
        _pstmFileContents->Release();
        
    if (FAILED(pstm->Clone(&_pstmFileContents)))
        return E_FAIL;

    if (_pEmbed) {
        if (_pEmbed->pszTempName) {
            DeleteFile(_pEmbed->pszTempName);
            delete _pEmbed->pszTempName;
        }
        delete _pEmbed;
    }

    _pEmbed = new EMBED;
    if (NULL != _pEmbed)
    {
        _pEmbed->fd.dwFlags = FD_FILESIZE;
        _pEmbed->fd.nFileSizeLow = dwSize;
        _pEmbed->fd.nFileSizeHigh = 0;
        SHAnsiToTChar(szFileName, _pEmbed->fd.cFileName, ARRAYSIZE(_pEmbed->fd.cFileName));
        DebugMsg(DM_TRACE,"         %s\n\r         %d",_pEmbed->fd.cFileName,_pEmbed->fd.nFileSizeLow);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


HRESULT CPackage::CmlReadFromStream(IStream* pstm)
{
    //
    // reads command line contents from a stream
    // return:  S_OK   - contents read succesfully
    //          E_FAIL - error reading contents
    //

    WORD w;
    CHAR  szCmdLink[CBCMDLINKMAX];
    
    DebugMsg(DM_TRACE, "pack - CmlReadFromStream called.");

    // read in the fCmdIsLink and the command line string
    if (FAILED(pstm->Read(&w, sizeof(w), NULL)))    
        return E_FAIL;
    StringReadFromStream(pstm, szCmdLink, ARRAYSIZE(szCmdLink));

    if (_pCml != NULL)
        delete _pCml;
    
    _pCml = new CML;
    SHAnsiToTChar(szCmdLink, _pCml->szCommandLine, ARRAYSIZE(_pCml->szCommandLine));
    
    return S_OK;
}    
    

HRESULT CPackage::PackageWriteToStream(IStream* pstm)
{
    //
    // write the package object to a stream
    // return:  s_OK   - package properly written
    //          E_FAIL - error writing package
    //
    
    WORD w;
    DWORD cb = 0L;
    DWORD dwSize;
      
    DebugMsg(DM_TRACE, "pack - PackageWriteToStream called.");

    // write out a DWORD where the package size will go
    if (FAILED(pstm->Write(&cb, sizeof(DWORD), NULL)))
        return E_FAIL;
    
    // write out the appearance type
    w = (WORD)ICON;
    if (FAILED(pstm->Write(&w, sizeof(WORD), NULL)))
        return E_FAIL;
    cb += 2*sizeof(WORD);       // for appearance type and contents type
    
    // write out the icon information
    if (FAILED(IconWriteToStream(pstm,&dwSize))) 
    {
        DebugMsg(DM_TRACE,"         error writing icon info!!");
        return E_FAIL;
    }
    cb += dwSize;

    // write out the contents type
    w = (WORD)_panetype;
    if (FAILED(pstm->Write(&_panetype, sizeof(WORD), NULL)))
        return E_FAIL;

    switch(_panetype) 
    {
        case PEMBED:
            
            // write out the contents information
            if (FAILED(EmbedWriteToStream(pstm,&dwSize))) 
            {
                DebugMsg(DM_TRACE,"         error writing embed info!!");
                return E_FAIL;
            }
            cb += dwSize;
            break;

        case CMDLINK:
            // write out the contents information
            if (FAILED(CmlWriteToStream(pstm,&dwSize))) {
                DebugMsg(DM_TRACE,"         error writing cml info!!");
                return E_FAIL;
            }
            cb += dwSize;
            break;
    }

    
    LARGE_INTEGER li = {0, 0};
    if (FAILED(pstm->Seek(li, STREAM_SEEK_SET, NULL)))
        return E_FAIL;
    if (FAILED(pstm->Write(&cb, sizeof(DWORD), NULL)))
        return E_FAIL;
    
    return S_OK;
}


//
// write the icon to a stream
// return:  s_OK   - icon properly written
//          E_FAIL - error writing icon
//
HRESULT CPackage::IconWriteToStream(IStream* pstm, DWORD *pdw)
{
    DWORD cb = 0;
    CHAR szTemp[MAX_PATH];
    SHTCharToAnsi(_lpic->szIconText, szTemp, ARRAYSIZE(szTemp));
    HRESULT hr = StringWriteToStream(pstm, szTemp, &cb);
    if (SUCCEEDED(hr))
    {
        SHTCharToAnsi(_lpic->szIconPath, szTemp, ARRAYSIZE(szTemp));
        hr = StringWriteToStream(pstm, szTemp, &cb);
        if (SUCCEEDED(hr))
        {
            DWORD dwWrite;
            WORD wDlgIcon = (WORD) _lpic->iDlgIcon;
            hr = pstm->Write(&wDlgIcon, sizeof(wDlgIcon), &dwWrite);
            if (SUCCEEDED(hr))
            {
                cb += dwWrite;
                if (pdw)
                    *pdw = cb;
            }
        }
    }
    return hr;
}

//
// write embedded file contents to a stream
// return:  S_OK   - contents written succesfully
//          E_FAIL - error writing contents
//
HRESULT CPackage::EmbedWriteToStream(IStream* pstm, DWORD *pdw)
{
    DWORD cb = 0;
    CHAR szTemp[MAX_PATH];
    SHTCharToAnsi(_pEmbed->fd.cFileName, szTemp, ARRAYSIZE(szTemp));
    DWORD dwSize = lstrlenA(szTemp) + 1;
    HRESULT hr = pstm->Write(&dwSize, sizeof(dwSize), &cb);
    if (SUCCEEDED(hr))
    {
        DWORD dwWrite = 0;
        hr = StringWriteToStream(pstm, szTemp, &dwWrite);
        if (SUCCEEDED(hr))
        {
            cb += dwWrite;
            hr = pstm->Write(&_pEmbed->fd.nFileSizeLow, sizeof(_pEmbed->fd.nFileSizeLow), &dwWrite);
            if (SUCCEEDED(hr))
            {
                cb += dwWrite;

                // we want to make sure our file contents stream always points to latest 
                // saved file contents
                //
                // NOTE: If we're not saving to our loaded stream, we shouldn't keep a
                // pointer to it, because we're in a SaveAs situation, and we don't want
                // to be hanging onto pointers to other peoples streams.
                //
                if (_pstmFileContents && _pstm == pstm)
                {
                    _pstmFileContents->Release();
                    pstm->Clone(&_pstmFileContents);
                }

                // This is for screwy apps, like MSWorks that ask us to save ourselves 
                // before they've even told us to initialize ourselves.  
                //
                if (_pEmbed->fd.cFileName[0])
                {
                    hr = CopyFileToStream(_pEmbed->pszTempName, pstm);
                    if (SUCCEEDED(hr))
                    {
                        cb += _pEmbed->fd.nFileSizeLow;
                    }
                }
                if (pdw)
                    *pdw = cb;
            }
        }
    }
    return hr;
}

//
// write embedded file contents to a stream
// return:  S_OK   - contents written succesfully
//          E_FAIL - error writing contents
//
HRESULT CPackage::CmlWriteToStream(IStream* pstm, DWORD *pdw)
{
    DWORD cb = 0;
    WORD w = (WORD)_pCml->fCmdIsLink;
    
    DebugMsg(DM_TRACE, "pack - CmlWriteToStream called.");

    if (FAILED(pstm->Write(&w, sizeof(w), NULL)))
        return E_FAIL;                                   // write fCmdIsLink
    cb += sizeof(w);      // for fCmdIsLink

    CHAR szTemp[MAX_PATH];
    SHTCharToAnsi(_pCml->szCommandLine, szTemp, ARRAYSIZE(szTemp));
    HRESULT hres = StringWriteToStream(pstm, szTemp, &cb);
    if (FAILED(hres))
        return hres;                                   // write command link

    // return the number of bytes written in the outparam    
    if (pdw)
        *pdw = cb;
    
    return S_OK;
}


HRESULT CPackage::CreateShortcutOnStream(IStream* pstm)
{
    HRESULT hr;
    IShellLink *psl;
    TCHAR szArgs[CBCMDLINKMAX - MAX_PATH];
    TCHAR szPath[MAX_PATH];
    
    hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
        IID_IShellLink, (void **)&psl);
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;

        lstrcpy(szPath,_pCml->szCommandLine);
        PathSeparateArgs(szPath, szArgs);

        psl->SetPath(szPath);
        psl->SetIconLocation(_lpic->szIconPath, _lpic->iDlgIcon);
        psl->SetShowCmd(SW_SHOW);
        psl->SetArguments(szArgs);
        
        hr = psl->QueryInterface(IID_IPersistStream, (void **)&pps);
        if (SUCCEEDED(hr))
        {
            hr = pps->Save(pstm,TRUE);
            pps->Release();
        }
        psl->Release();
    }
    
    LARGE_INTEGER li = {0,0};
    pstm->Seek(li,STREAM_SEEK_SET,NULL);

    return hr;
}

HRESULT CPackage::InitVerbEnum(OLEVERB* pVerbs, ULONG cVerbs)
{
    if (NULL != _pVerbs)
    {
        for (ULONG i = 0; i < _cVerbs; i++)
        {
            delete _pVerbs[i].lpszVerbName;
        }
        delete _pVerbs;
    }
    _pVerbs = pVerbs;
    _cVerbs = cVerbs;
    _nCurVerb = 0;
    return (NULL != pVerbs) ? S_OK : E_FAIL;
}

VOID CPackage::ReleaseContextMenu()
{
    if (NULL != _pcm)
    {
        _pcm->Release();
        _pcm = NULL;
    }
}

HRESULT CPackage::GetContextMenu(IContextMenu** ppcm)
{
    HRESULT hr = E_FAIL;
    ASSERT(NULL != ppcm);
    if (NULL != _pcm)
    {
        _pcm->AddRef();
        *ppcm = _pcm;
        hr = S_OK;
    }
    else if ((PEMBED == _panetype) || (CMDLINK == _panetype))
    {
        if (PEMBED == _panetype)
        {
            hr = CreateTempFileName();
        }
        else
        {
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl = SHSimpleIDListFromPath((PEMBED == _panetype) ?
                                                        _pEmbed->pszTempName :
                                                        _pCml->szCommandLine);
            if (NULL != pidl)
            {
                IShellFolder* psf;
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(hr = SHBindToIDListParent(pidl, IID_IShellFolder, (void **)&psf, &pidlChild)))
                {
                    hr = psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_IContextMenu, NULL, (void**) &_pcm);
                    if (SUCCEEDED(hr))
                    {
                        _pcm->AddRef();
                        *ppcm = _pcm;
                    }
                    psf->Release();
                }
                ILFree(pidl);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT CPackage::IconRefresh()
{
    // we refresh the icon.  typically, this will be called the first time
    // the package is created to load the new icon and calculate how big
    // it should be.  this will also be called after we edit the package,
    // since the user might have changed the icon.
    
    // First, load the appropriate icon.  We'll load the icon specified by
    // lpic->szIconPath and lpic->iDlgIcon if possible, otherwise we'll just
    // use the generic packager icon.
    //
    GetCurrentIcon(_lpic);

    // Next, we need to have the icon recalculate its size, since it's text
    // might have changed, causing it to get bigger or smaller.
    //
    IconCalcSize(_lpic);

    // Next, notify our containers that our view has changed.
    if (_pIDataAdviseHolder)
        _pIDataAdviseHolder->SendOnDataChange(_pIDataObject,0, NULL);
    if (_pViewSink)
        _pViewSink->OnViewChange(_dwViewAspects,_dwViewAdvf);

    // Set our dirty flag
    _fIsDirty = TRUE;

    return S_OK;
}

    
int CPackage::RunWizard()
{
    PACKAGER_INFO packInfo;
    HRESULT hr;
    
    PackWiz_CreateWizard(NULL, &packInfo);

    InitFromPackInfo(&packInfo);

    hr = OleSetClipboard(_pIDataObject);
    if (FAILED(hr))
    {
        ShellMessageBox(g_hinst,
                        NULL,
                        MAKEINTRESOURCE(IDS_COPY_ERROR),
                        MAKEINTRESOURCE(IDS_APP_TITLE),
                        MB_ICONERROR | MB_TASKMODAL | MB_OK);
        return -1;
    }

    // we need to do this.  our OleUninitialze call at the end, free the
    // libarary and our dataobject on the clipboard unless we flush
    // the clipboard.
    
    hr = OleFlushClipboard();
    if (FAILED(hr))
    {
        ShellMessageBox(g_hinst,
                        NULL,
                        MAKEINTRESOURCE(IDS_COPY_ERROR),
                        MAKEINTRESOURCE(IDS_APP_TITLE),
                        MB_ICONERROR | MB_TASKMODAL | MB_OK);
        return -1;
    }
    
    ShellMessageBox(g_hinst,
                    NULL,
                    MAKEINTRESOURCE(IDS_COPY_COMPLETE),
                    MAKEINTRESOURCE(IDS_APP_TITLE),
                    MB_ICONINFORMATION | MB_TASKMODAL | MB_OK);
    
    return 0;
}

void CPackage::DestroyIC()
{
    if (_lpic)
    {
        if (_lpic->hDlgIcon)
            DestroyIcon(_lpic->hDlgIcon);
        
        GlobalFree(_lpic);
    }
}

STDAPI_(BOOL) PackWizRunFromExe()
{
    OleInitialize(NULL);

    CPackage *pPackage = new CPackage;
    if (pPackage)
    {
        pPackage->Init();
        pPackage->RunWizard();
        pPackage->Release();
    }
    
    OleUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packutil.h ===
#ifndef PACKUTIL_H__
#define PACKUTIL_H__

#define CHAR_SPACE          TEXT(' ')
#define CHAR_QUOTE          TEXT('"')
#define SZ_QUOTE            TEXT("\"")
#define BUFFERSIZE          4096    // 4k buffer size for copy operations

/////////////////////////////////
// Icon structure
//
typedef struct _IC                      // ic
{
    HICON hDlgIcon;                     // handle to icon
    TCHAR szIconPath[MAX_PATH];        // path to icon
    TCHAR szIconText[MAX_PATH];        // text for icon
    INT iDlgIcon;                       // index of icon in a resource
    RECT rc;                            // bounding rect of icon and text
} IC, *LPIC;
    

VOID ReplaceExtension(LPTSTR lpstrTempFile,LPTSTR lpstrOrigFile);
LPIC IconCreate(void);
LPIC IconCreateFromFile(LPCTSTR);
BOOL IconCalcSize(LPIC lpic);
VOID IconDraw(LPIC,HDC,LPRECT);
VOID GetCurrentIcon(LPIC lpic);
VOID GetDisplayName(LPTSTR, LPCTSTR);

HRESULT CopyStreamToFile(IStream*, LPTSTR);
HRESULT CopyFileToStream(LPTSTR, IStream*);
HRESULT StringReadFromStream(IStream* pstm, LPSTR pszBuffer, UINT cchChar);
HRESULT StringWriteToStream(IStream* pstm, LPCSTR pszBuffer, DWORD *pdwWrite);
BOOL PathSeparateArgs(LPTSTR pszPath, LPTSTR pszArgs);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packutil.cpp ===
#include "privcpp.h"
#include "shlwapi.h"

extern HINSTANCE g_hinst;

//////////////////////////////////////////////////////////////////////
//
// Icon Helper Functions
//
//////////////////////////////////////////////////////////////////////

void IconDraw(LPIC lpic, HDC hdc, LPRECT lprc)
{
    //
    // draw's the icon and the text to the specfied DC in the given 
    // bounding rect.  
    //    
    DebugMsg(DM_TRACE, "pack - IconDraw() called.");
    DebugMsg(DM_TRACE, "         left==%d,top==%d,right==%d,bottom==%d",
             lprc->left,lprc->top,lprc->right,lprc->bottom);

    // make sure we'll fit in the given rect
    if (((lpic->rc.right-lpic->rc.left) > (lprc->right - lprc->left)) ||
        ((lpic->rc.bottom-lpic->rc.top) > (lprc->bottom - lprc->top)))
        return;
    
    // Draw the icon
    if (lpic->hDlgIcon)
        DrawIcon(hdc, (lprc->left + lprc->right - g_cxIcon) / 2,
            (lprc->top + lprc->bottom - lpic->rc.bottom) / 2, lpic->hDlgIcon);

    if ((lpic->szIconText) && *(lpic->szIconText))
    {    
        HFONT hfont = SelectFont(hdc, g_hfontTitle);
        RECT rcText;

        rcText.left = lprc->left;
        rcText.right = lprc->right;
        rcText.top = (lprc->top + lprc->bottom - lpic->rc.bottom) / 2 + g_cyIcon + 1;
        rcText.bottom = lprc->bottom;
        DrawText(hdc, lpic->szIconText, -1, &rcText,
            DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE | DT_TOP);

        if (hfont)
            SelectObject(hdc, hfont);
    }
}


LPIC IconCreate(void)
{
    // 
    // allocates space for our icon structure which holds icon index,
    // the icon path, the handle to the icon, and the icon text
    // return:  NULL on failure
    //          a valid pointer on success
    //
    
    DebugMsg(DM_TRACE, "pack - IconCreate() called.");

    // Allocate memory for the IC structure
    return (LPIC)GlobalAlloc(GPTR, sizeof(IC));
}

LPIC IconCreateFromFile(LPCTSTR lpstrFile)
{
    //
    // initializes an IC structure (defined in pack2.h) from a given
    // filename.
    // return:  NULL on failure
    //          a valid pointer on success
    //
    
    LPIC lpic;

    DebugMsg(DM_TRACE, "pack - IconCreateFromFile() called.");

    if (lpic = IconCreate())
    {
        // Get the icon
        lstrcpy(lpic->szIconPath, lpstrFile);
        lpic->iDlgIcon = 0;

        if (*(lpic->szIconPath))
            GetCurrentIcon(lpic);

        // Get the icon text -- calls ILGetDisplayName
        // 
        GetDisplayName(lpic->szIconText, lpstrFile);
        if (!IconCalcSize(lpic)) {
            if (lpic->hDlgIcon)
                DestroyIcon(lpic->hDlgIcon);
            GlobalFree(lpic);
            lpic = NULL;
        }
    }
    return lpic;
}


BOOL IconCalcSize(LPIC lpic) 
{
    HDC hdcWnd;
    RECT rcText = { 0 };
    SIZE Image;
    HFONT hfont;
    
    DebugMsg(DM_TRACE, "pack - IconCalcSize called.");
    
    // get the window DC, and make a DC compatible to it
    if (!(hdcWnd = GetDC(NULL)))  {
        DebugMsg(DM_TRACE, "         couldn't get DC!!");
        return FALSE;
    }
    ASSERT(lpic);


    if (lpic->szIconText && *(lpic->szIconText))
    {    
        SetRect(&rcText, 0, 0, g_cxArrange, g_cyArrange);
        
        // Set the icon text rectangle, and the icon font
        hfont = SelectFont(hdcWnd, g_hfontTitle);

        // Figure out how large the text region will be
        rcText.bottom = DrawText(hdcWnd, lpic->szIconText, -1, &rcText,
            DT_CALCRECT | DT_WORDBREAK | DT_NOPREFIX | DT_SINGLELINE);

        if (hfont)
            SelectObject(hdcWnd, hfont);
    }
    
    // Compute the image size
    rcText.right++;
    Image.cx = (rcText.right > g_cxIcon) ? rcText.right : g_cxIcon;
    Image.cy = g_cyIcon + rcText.bottom + 1;
    
    // grow the image a bit
    Image.cx += Image.cx / 4;
    Image.cy += Image.cy / 8;
    
    lpic->rc.right = Image.cx;
    lpic->rc.bottom = Image.cy;
    
    DebugMsg(DM_TRACE,"         lpic->rc.right==%d,lpic->rc.bottom==%d",
             lpic->rc.right,lpic->rc.bottom);
    
    return TRUE;
}    

void GetCurrentIcon(LPIC lpic)
{
    //
    // gets the current icon associated with the path stored in lpic->szIconPath
    // if it can't extract the icon associated with the file, it just gets
    // the standard application icon
    //
    
    WORD wIcon = (WORD)lpic->iDlgIcon;

    
    DebugMsg(DM_TRACE, "pack - GetCurrentIcon() called.");

    if (lpic->hDlgIcon)
        DestroyIcon(lpic->hDlgIcon);

    if (!lpic->szIconPath || *lpic->szIconPath == TEXT('\0'))
        lpic->hDlgIcon = (HICON)LoadImage(g_hinst, MAKEINTRESOURCE(IDI_PACKAGER),
                                   IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    else if (!(lpic->hDlgIcon = ExtractAssociatedIcon(g_hinst, lpic->szIconPath, &wIcon)))
        lpic->hDlgIcon = (HICON)LoadImage(g_hinst, MAKEINTRESOURCE(IDI_PACKAGER),
                                   IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
}


void GetDisplayName(LPTSTR szName, LPCTSTR szPath)
{
    LPTSTR pszTemp = PathFindFileName(szPath);
    lstrcpy(szName, pszTemp);
}


/* ReplaceExtension() - Replaces the extension of the temp file.
 *
 * This routine ensures that the temp file has the same extension as the
 * original file, so that the ShellExecute() will load the same server..
 */
VOID ReplaceExtension(LPTSTR lpstrTempFile,LPTSTR lpstrOrigFile)
{
    LPTSTR lpstrBack = NULL;

    DebugMsg(DM_TRACE, "            ReplaceExtension() called.");
    
    // Get temp file extension
    while (*lpstrTempFile)
    {
        if (*lpstrTempFile == '\\')
            lpstrBack = lpstrTempFile;

        lpstrTempFile++;
    }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
        lpstrBack++;

    if (lpstrBack && *lpstrBack)
        lpstrTempFile = lpstrBack + 1;

    // Get original file extension
    while (*lpstrOrigFile)
    {
        if (*lpstrOrigFile == '\\')
            lpstrBack = lpstrOrigFile;

        lpstrOrigFile++;
    }

    while (lpstrBack && *lpstrBack && *lpstrBack != '.')
        lpstrBack++;

    if (lpstrBack && *lpstrBack)
    {
        lpstrOrigFile = lpstrBack + 1;

        // Move the extension on over
        lstrcpy(lpstrTempFile, lpstrOrigFile);
    }
    else
    {
         /* Wipe out the extension altogether */
        *lpstrTempFile = 0;
    }
}



/////////////////////////////////////////////////////////////////////////
//
// Stream Helper Functions
//
/////////////////////////////////////////////////////////////////////////

HRESULT CopyFileToStream(LPTSTR lpFileName, IStream* pstm) 
{
    //
    // copies the given file to the current seek pointer in the given stream
    // return:  S_OK            -- successfully copied
    //          E_POINTER       -- one of the pointers was NULL
    //          E_OUTOFMEMORY   -- out of memory
    //          E_FAIL          -- other error
    //
    
    LPVOID      lpMem;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HRESULT     hr;
    DWORD       dwSizeLow;
    DWORD       dwSizeHigh;
    DWORD       dwPosLow = 0L;
    LONG        lPosHigh = 0L;
    DWORD       cbRead = BUFFERSIZE;
    DWORD       cbWritten = BUFFERSIZE;
    
    DebugMsg(DM_TRACE,"pack - CopyFileToStream called.");
    
    if (!pstm || !lpFileName) {
        DebugMsg(DM_TRACE,"          bad pointer!!");
        return E_POINTER;
    }    
    
    // Allocate memory buffer for tranfer operation...
    if (!(lpMem = (LPVOID)GlobalAlloc(GPTR, BUFFERSIZE))) {
        DebugMsg(DM_TRACE, "         couldn't alloc memory buffer!!");
        hr = E_OUTOFMEMORY;
        goto ErrRet;
    }
    
    // open file to copy to stream
    hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READWRITE, NULL, 
                       OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        DebugMsg(DM_TRACE, "         couldn't open file!!");
        goto ErrRet;
    }
    
    // Figure out how much to copy...
    dwSizeLow = GetFileSize(hFile, &dwSizeHigh);
    ASSERT(dwSizeHigh == 0);
    
    SetFilePointer(hFile, 0L, NULL, FILE_BEGIN);
        
    // read in the file, and write to stream
    while (cbRead == BUFFERSIZE && cbWritten == BUFFERSIZE)
    {
        ReadFile(hFile, lpMem, BUFFERSIZE, &cbRead, NULL);
        pstm->Write(lpMem, cbRead, &cbWritten);
    }
    
    // verify that we are now at end of block to copy
    dwPosLow = SetFilePointer(hFile, 0L, &lPosHigh, FILE_CURRENT);
    ASSERT(lPosHigh == 0);
    if (dwPosLow != dwSizeLow) {
        DebugMsg(DM_TRACE, "         error copying file!!");
        hr = E_FAIL;
        goto ErrRet;
    }
    
    hr = S_OK;
    
ErrRet:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (lpMem)
        GlobalFree((HANDLE)lpMem);
    return hr;
}   

HRESULT CopyStreamToFile(IStream* pstm, LPTSTR lpFileName) 
{
    //
    // copies the contents of the given stream from the current seek pointer
    // to the end of the stream into the given file.
    //
    // NOTE: the given filename must not exist, if it does, the function fails
    // with E_FAIL
    //
    // return:  S_OK            -- successfully copied
    //          E_POINTER       -- one of the pointers was NULL
    //          E_OUTOFMEMORY   -- out of memory
    //          E_FAIL          -- other error
    //
    
    LPVOID      lpMem;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    HRESULT     hr = S_OK;
    DWORD       cbRead = BUFFERSIZE;
    DWORD       cbWritten = BUFFERSIZE;
    
    ULARGE_INTEGER      uli;
    LARGE_INTEGER       li = { 0L, 0L};
    ULARGE_INTEGER       uliPos;
    
    DebugMsg(DM_TRACE,"pack - CopyStreamToFile called.");
    
    // pstm must be a valid stream that is open for reading
    // lpFileName must be a valid filename to be written
    //
    if (!pstm || !lpFileName)
        return E_POINTER;
    
    // Allocate memory buffer...
    if (!(lpMem = (LPVOID)GlobalAlloc(GPTR, BUFFERSIZE))) {
        DebugMsg(DM_TRACE, "         couldn't alloc memory buffer!!");
        hr = E_OUTOFMEMORY;
        goto ErrRet;
    }
    
    // open file to receive stream data
    hFile = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, 
                       CREATE_NEW, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        DebugMsg(DM_TRACE, "         couldn't open file!!");
        hr = E_FAIL;
        goto ErrRet;
    }
    
    // get the number of bytes to copy
    pstm->Seek(li, STREAM_SEEK_CUR, &uliPos);
    pstm->Seek(li, STREAM_SEEK_END, &uli);
    ASSERT(uliPos.HighPart == uli.HighPart);    // can't copy more than a DWORD
    li.HighPart = uliPos.HighPart;
    li.LowPart = uliPos.LowPart;
    pstm->Seek(li, STREAM_SEEK_SET, NULL);
        
    // read in the stream, and write to the file
    while (cbRead == BUFFERSIZE && cbWritten == BUFFERSIZE)  
    {
        hr = pstm->Read(lpMem, BUFFERSIZE, &cbRead);
        WriteFile(hFile, lpMem, cbRead, &cbWritten, NULL);
    }
    
//    li.HighPart = 0L;
//    li.LowPart = 0L;
  
    // verify that we are now at end of stream
//    pstm->Seek(li, STREAM_SEEK_CUR, &uliPos);
//    if (uliPos.LowPart != uli.LowPart || uliPos.HighPart != uli.HighPart) {

    if (hr != S_OK) 
    {
        DebugMsg(DM_TRACE, "         error copying file!!");
        hr = E_FAIL;
        goto ErrRet;
    }
    
ErrRet:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (lpMem)
        GlobalFree((HANDLE)lpMem);
    return hr;
}   

// FEATURE: write persistence formats in UNICODE!

HRESULT StringReadFromStream(IStream* pstm, LPSTR pszBuf, UINT cchBuf)
{
    //
    // read byte by byte until we hit the null terminating char
    // return: the number of bytes read
    //
    
    UINT cch = 0;
    
    do {
        pstm->Read(pszBuf, sizeof(CHAR), NULL);
        cch++;
    } while (*pszBuf++ && cch <= cchBuf);  
    return cch;
} 

DWORD _CBString(LPCSTR psz)
{
    return sizeof(psz[0]) * (lstrlenA(psz) + 1);
}

HRESULT StringWriteToStream(IStream* pstm, LPCSTR psz, DWORD *pdwWrite)
{
    DWORD dwWrite;
    DWORD dwSize = _CBString(psz);
    HRESULT hr = pstm->Write(psz, dwSize, &dwWrite);
    if (SUCCEEDED(hr))
        *pdwWrite += dwWrite;
    return hr;
}


// parse pszPath into a unquoted path string and put the args in pszArgs
//
// returns:
//      TRUE    we verified the thing exists
//      FALSE   it may not exist
//
// taken from \ccshell\shell32\link.c
//
BOOL PathSeparateArgs(LPTSTR pszPath, LPTSTR pszArgs)
{
    LPTSTR pszT;
    
    PathRemoveBlanks(pszPath);
    
    // if the unquoted sting exists as a file just use it
    
    if (PathFileExists(pszPath))
    {
        *pszArgs = 0;
        return TRUE;
    }
    
    pszT = PathGetArgs(pszPath);
    if (*pszT)
        *(pszT - 1) = TEXT('\0');
    lstrcpy(pszArgs, pszT);
    
    PathUnquoteSpaces(pszPath);
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\pack2cls.cpp ===
#include "privcpp.h"
#include "ids.h"
#include <advpub.h>

#define INITGUID
#include <initguid.h>
#include "packguid.h"

#define DECL_CRTFREE
#include <crtfree.h>

UINT g_cRefThisDll = 0;
HINSTANCE g_hinst = NULL;

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch(dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hinst = hDll;
#ifdef DEBUG
        CcshellGetDebugFlags();
#endif // DEBUG
        break;

    default:
        break;
    }

    return TRUE;
}

class CMyClassFactory : public IClassFactory
{
public:
    CMyClassFactory(REFCLSID rclsid);
    ~CMyClassFactory() { g_cRefThisDll--; }

    // IUnKnown
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

protected:
    UINT   _cRef;
    CLSID  _clsid;
};

CMyClassFactory::CMyClassFactory(REFCLSID rclsid) : _cRef(1), _clsid(rclsid)
{
    g_cRefThisDll++;
}

HRESULT CMyClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    HRESULT hres;
    if (IsEqualGUID(riid, IID_IClassFactory) || IsEqualGUID(riid, IID_IUnknown)) 
    {
        DebugMsg(DM_TRACE, "pack cf - QueryInterface called");

        _cRef++;
        *ppvObject = (IClassFactory *)this;
        hres = NOERROR;
    }
    else
    {
        *ppvObject = NULL;
        hres = E_NOINTERFACE;
    }

    return hres;
}

ULONG CMyClassFactory::AddRef(void)
{
    DebugMsg(DM_TRACE, "pack cf - AddRef called");
    return ++_cRef;
}

ULONG CMyClassFactory::Release(void)
{
    DebugMsg(DM_TRACE, "pack cf - Release called");

    if (--_cRef>0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMyClassFactory::CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvObject)
{
    DebugMsg(DM_TRACE, "CMyClassFactory::CreateInstance called");

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    IUnknown* punk;
    HRESULT hres;
    if (IsEqualGUID(_clsid, CLSID_CPackage))
    {
        hres = CPackage_CreateInstnace(&punk);
    }
    else
    {
        return E_UNEXPECTED;
    }

    if (SUCCEEDED(hres))
    {
        hres = punk->QueryInterface(riid, ppvObject);
        punk->Release();
    }
    return hres;
}

HRESULT CMyClassFactory::LockServer(BOOL fLock)
{
    DebugMsg(DM_TRACE, "pack cf - LockServer called");
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppvOut)
{
    DebugMsg(DM_TRACE, "pack - DllGetClassObject called");

    if (IsEqualGUID(rclsid,CLSID_CPackage))
    {
        CMyClassFactory *pmycls = new CMyClassFactory(rclsid);
        if (pmycls)
        {
            HRESULT hres = pmycls->QueryInterface(riid, ppvOut);
            pmycls->Release();
            return hres;
        }
        return E_OUTOFMEMORY;
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

STDAPI DllCanUnloadNow(void)
{
    DebugMsg(DM_TRACE, "pack - DllCanUnloadNow called");
    if (g_cRefThisDll)
    {
        return S_FALSE;
    }

    DebugMsg(DM_TRACE, "pack - DllCanUnloadNow returning S_OK (bye, bye...)");

    return S_OK;
}

// Call ADVPACK for the given section of our resource based INF>
//   hInstance = resource instance to get REGINST section from
//   szSection = section name to invoke
HRESULT CallRegInstall(HINSTANCE hInstance, LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if ( pfnri )
        {
#ifdef WINNT
            STRENTRY seReg[] =
            {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(hInstance, szSection, &stReg);
#else
            hr = pfnri(hInstance, szSection, NULL);
#endif
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer(void)
{
    CallRegInstall(g_hinst, "RegDll");
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    CallRegInstall(g_hinst, "UnregDll");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packguid.h ===
// {F20DA720-C02F-11CE-927B-0800095AE340}
DEFINE_GUID(CLSID_CPackage, 0xF20DA720L, 0xC02F, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40);

// old packager guid...
// {0003000C-0000-0000-C000-000000000046}
DEFINE_GUID(CLSID_OldPackage, 0x0003000CL, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packwiz.cpp ===
#include <privcpp.h>

#include <windows.h>
#include <prsht.h>
#include <shlwapi.h>

#include <shsemip.h>
#include "ids.h"

//
// FUNCTION: PackWiz_SelectFileDlgProc(HWND,UINT,WPARAM,LPARAM)
//
// PURPOSE:  Dialog procedure for FIRST page of Create New Package Wizard
// 
//
INT_PTR CALLBACK PackWiz_SelectFileDlgProc(HWND hDlg, UINT uMsg , WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (uMsg) 
    {
    case WM_INITDIALOG:
        lppi = (LPPACKAGER_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lppi);
        Edit_LimitText(GetDlgItem(hDlg, IDC_COMMAND), ARRAYSIZE(lppi->szFilename) - 1);

        if (*lppi->szFilename)
            SetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename);

        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDC_COMMAND:
            // Check to see if we have a change in the edit control
            switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
            {
            case EN_CHANGE:
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                break;
            }
            break;
            
            case IDC_BROWSE: 
                {
                    TCHAR szExt[80];		
                    TCHAR szFilter[80];			
                    TCHAR szTitle[80];
                    TCHAR szFilename[MAX_PATH];
                    int ret;
                    LPTSTR lpsz = szFilter;
                    
                    // load the filter and then replace all the @ characters
                    // with NULL.  The end of the string will be doubly
                    // null-terminated
                    LoadString(g_hinst, IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter)-1);
                    while (*lpsz) {
                        if (*lpsz == TEXT('@')) {
                            *lpsz = 0;
                            lpsz++;
                        }
                        else {
                            lpsz = CharNext(lpsz);
                        }
                    }
                    *(lpsz+1) = 0;
                    
                    LoadString(g_hinst, IDS_BROWSEEXT, szExt, ARRAYSIZE(szExt));
                    LoadString(g_hinst, IDS_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
                    
                    GetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
                    
                    // Danger - this is a TCHAR API!
                    ret = GetFileNameFromBrowse(hDlg,szFilename, ARRAYSIZE(lppi->szFilename), NULL, szExt, szFilter, szTitle);
                    if (ret > 0) 
                    {
                        lstrcpy(lppi->szFilename, szFilename);
                    }
                    
                    SetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename);
                    break;
                }
        }
        break;
        
        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code) 
            {
            case PSN_KILLACTIVE:
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;
                
            case PSN_RESET:
                // reset to original values
                *lppi->szFilename = TEXT('\0');
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                break;
                
            case PSN_SETACTIVE:
                Edit_SetText(GetDlgItem(hDlg, IDC_COMMAND), lppi->szFilename);
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                break;
                
            case PSN_WIZNEXT:
                GetDlgItemText(hDlg, IDC_COMMAND, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
                break;
                
            case PSN_QUERYCANCEL:
                *lppi->szFilename = TEXT('\0');
                return FALSE;
                
            default:
                return FALSE;
            }
            break;
            
            case WM_DESTROY:
            case WM_HELP:
            case WM_CONTEXTMENU:
                break;
                
            default:
                return FALSE;
                
    } // end of switch on uMsg
    return TRUE;
}  


//
// FUNCTION: PackWiz_SelectIconDlgProc(HWNDd, UINT, WPARAM, LPARAM)
//
// PURPOSE:  Dialog procedure for SECOND page of Create New Package Wizard
// 
//
INT_PTR CALLBACK PackWiz_SelectIconDlgProc(HWND hDlg, UINT uMsg , WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (uMsg) 
    {
    case WM_INITDIALOG:
        lppi = (LPPACKAGER_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lppi);
        *lppi->szIconPath = TEXT('\0');
        lppi->iIcon = 0;
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDC_CHANGEICON: 
            if (S_OK == PickIconDlg(hDlg, lppi->szIconPath, ARRAYSIZE(lppi->szIconPath), &(lppi->iIcon)))
            {
                HICON hicon = ExtractAssociatedIcon(g_hinst, lppi->szIconPath, (LPWORD)&(lppi->iIcon));
                if (hicon) 
                {
                    HWND hPackIcon = GetDlgItem(hDlg, IDC_PACKICON);
                    SendMessage(hPackIcon, STM_SETICON, (WPARAM)hicon, (LPARAM)0);
                }
            }
            break;
        }
        break;
        
        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code) 
            {
            case PSN_KILLACTIVE:
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;
                
            case PSN_RESET:
                // reset to original values
                *lppi->szIconPath = TEXT('\0');
                lppi->iIcon = 0;
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                break;
                
            case PSN_SETACTIVE: {                
                HICON hicon = NULL;

                if (PathFileExists(lppi->szFilename))
                    hicon = ExtractAssociatedIcon(g_hinst, *lppi->szIconPath? lppi->szIconPath : lppi->szFilename, (LPWORD)&(lppi->iIcon));

                if (!hicon)
                    hicon = LoadIcon(g_hinst,MAKEINTRESOURCE(IDI_PACKAGER));
                
                HWND hPackIcon = GetDlgItem(hDlg, IDC_PACKICON);
                SendMessage(hPackIcon, STM_SETICON, (WPARAM)hicon, (LPARAM)0);
                
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
                                }
                break;
                
            case PSN_WIZBACK:
                break;
                
            case PSN_WIZNEXT:
                break;
                
            case PSN_QUERYCANCEL:
                *lppi->szFilename = TEXT('\0');
                return FALSE;
                break;
                
            default:
                return FALSE;
            }
            break;
            
            case WM_DESTROY:
            case WM_HELP:
            case WM_CONTEXTMENU:
                break;
                
            default:
                return FALSE;
                
    } // end of switch on uMsg
    return TRUE;
}  



//
// FUNCTION: PackWiz_SelectLabelDlgProc(HWND, UINT, WPARAM, LPARAM)
//
// PURPOSE:  Dialog procedure for THIRD page of Create New Package Wizard
// 
//
INT_PTR CALLBACK PackWiz_SelectLabelDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (uMsg) {
        
    case WM_INITDIALOG:
        lppi = (LPPACKAGER_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lppi);
        Edit_LimitText(GetDlgItem(hDlg, IDC_COMMAND), ARRAYSIZE(lppi->szLabel) - 1);
        GetDisplayName(lppi->szLabel,lppi->szFilename);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDC_COMMAND:
            // Check to see if we have a change in the edit control
	    switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
            {
            case EN_CHANGE:
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                break;
            }
            break;
        }
        break;
        
        case WM_NOTIFY:
            switch (((NMHDR *)lParam)->code) 
            {
            case PSN_KILLACTIVE:
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                return TRUE;
                
            case PSN_RESET:
                // reset to original values
                *lppi->szLabel = TEXT('\0');
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                break;
                
            case PSN_SETACTIVE:
                Edit_SetText(GetDlgItem(hDlg, IDC_COMMAND), lppi->szLabel);
                if (GetWindowTextLength(GetDlgItem(hDlg, IDC_COMMAND)) > 0)
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_FINISH);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                break;
                
            case PSN_WIZBACK:
                GetDlgItemText(hDlg, IDC_COMMAND, lppi->szLabel, ARRAYSIZE(lppi->szLabel));
                break;
                
            case PSN_WIZFINISH:
                GetDlgItemText(hDlg, IDC_COMMAND, lppi->szLabel, ARRAYSIZE(lppi->szLabel));
                break;
                
            case PSN_QUERYCANCEL:
                *lppi->szFilename = TEXT('\0');
                return FALSE;
                
            default:
                return FALSE;
            }
            break;
            
            case WM_DESTROY:
            case WM_HELP:
            case WM_CONTEXTMENU:
                break;
                
            default:
                return FALSE;
                
    } // end of switch on uMsg
    return TRUE;
}


//
// FUNCTION: PackWiz_EditPackageDlgProc(HWND,UINT,WPARAM,LPARAM)
//
// PURPOSE:  Dialog procedure for Edit Package
//
// NOTE: We have two different types of packages we could edit, but they
// both have exactly the same dialog layout, except for some static text, which
// doesn't affect the dialog procedure
// 
//
INT_PTR CALLBACK PackWiz_EditPackageDlgProc(HWND hDlg, UINT uMsg , WPARAM wParam, LPARAM lParam)
{
    LPPACKAGER_INFO lppi = (LPPACKAGER_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (uMsg) {
        
    case WM_INITDIALOG: 
        {
            HICON hicon;
            
            lppi = (LPPACKAGER_INFO)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT1), ARRAYSIZE(lppi->szFilename) - 1);
            Edit_LimitText(GetDlgItem(hDlg, IDC_EDIT2), ARRAYSIZE(lppi->szLabel) - 1);
            SetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename);
            SetDlgItemText(hDlg, IDC_EDIT2, lppi->szLabel);
            
            if (*lppi->szIconPath != TEXT('\0'))
                hicon = ExtractAssociatedIcon(g_hinst, lppi->szIconPath, (LPWORD)&(lppi->iIcon));
            else
                hicon = LoadIcon(g_hinst,MAKEINTRESOURCE(IDI_PACKAGER));
            
            HWND hPackIcon = GetDlgItem(hDlg, IDC_PACKICON);
            SendMessage(hPackIcon, STM_SETICON, (WPARAM)hicon, (LPARAM)0);
            
            break; 
        }
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDHELP:
            break;
            
        case IDOK:
            GetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
            GetDlgItemText(hDlg, IDC_EDIT2, lppi->szLabel, ARRAYSIZE(lppi->szLabel));
            EndDialog(hDlg, 1);
            break;
            
        case IDCANCEL:
            EndDialog(hDlg, -1);
            break;
            
        case IDC_CHANGEICON: 
            {
                PickIconDlg(hDlg, lppi->szIconPath, ARRAYSIZE(lppi->szIconPath), &(lppi->iIcon));
                HICON hicon = ExtractAssociatedIcon(g_hinst, lppi->szIconPath, (LPWORD)&(lppi->iIcon));
            
                if (hicon) 
                {
                    HWND hPackIcon = GetDlgItem(hDlg, IDC_PACKICON);
                    SendMessage(hPackIcon, STM_SETICON, (WPARAM)hicon, (LPARAM)0);
                }
            }
            break;
            
        case IDC_BROWSE: 
            {
                TCHAR szExt[80];		
                TCHAR szFilter[80];			
                TCHAR szTitle[80];
                LPTSTR lpsz = szFilter;
            
                // load the filter and then replace all the @ characters
                // with NULL.  The end of the string will be doubly
                // null-terminated
                LoadString(g_hinst, IDS_BROWSEFILTER, szFilter, ARRAYSIZE(szFilter)-1);
                while (*lpsz) {
                    if (*lpsz == TEXT('@')) {
                        *lpsz = 0;
                        lpsz++;
                    }
                    else {
                        lpsz = CharNext(lpsz);
                    }
                }
                *(lpsz+1) = 0;
            
                LoadString(g_hinst, IDS_BROWSEEXT, szExt, ARRAYSIZE(szExt));
                LoadString(g_hinst, IDS_BROWSETITLE, szTitle, ARRAYSIZE(szTitle));
            
                GetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename, ARRAYSIZE(lppi->szFilename));
            
                GetFileNameFromBrowse(hDlg,lppi->szFilename,
                    ARRAYSIZE(lppi->szFilename), NULL, szExt, szFilter, szTitle);
            
                SetDlgItemText(hDlg, IDC_EDIT1, lppi->szFilename);
            }
            break;
        }
        break;
        
        case WM_DESTROY:
        case WM_HELP:
        case WM_CONTEXTMENU:
            break;
            
        default:
            return FALSE;
            
    } // end of switch on uMsg
    return TRUE;
}  


//
//
// FUNCTION: PackWiz_FillInPropertyPage(PROPSHEETPAGE *, int, LPFN) 
//
// PURPOSE: Fills in the given PROPSHEETPAGE structure 
//
// COMMENTS:
//
//      This function fills in a PROPSHEETPAGE structure with the
//      information the system needs to create the page.
// 
void PackWiz_FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg, DLGPROC pfnDlgProc, LPPACKAGER_INFO lppi)
{
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = 0;
    psp->hInstance = g_hinst;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = NULL;
    psp->lParam = (LPARAM)lppi;
}

//
//
// FUNCTION: PackWiz_CreateWizard(HWND)
//
// PURPOSE: Create the Wizard control. 
//
// COMMENTS:
//	
//      This function creates the wizard property sheet.
//
int PackWiz_CreateWizard(HWND hwndOwner, LPPACKAGER_INFO lppi)
{
    PROPSHEETPAGE psp[PACKWIZ_NUM_PAGES];
    PROPSHEETHEADER psh;

    PackWiz_FillInPropertyPage(&psp[0], IDD_SELECTFILE, PackWiz_SelectFileDlgProc,lppi);
    PackWiz_FillInPropertyPage(&psp[1], IDD_SELECTICON, PackWiz_SelectIconDlgProc,lppi);
    PackWiz_FillInPropertyPage(&psp[2], IDD_SELECTLABEL, PackWiz_SelectLabelDlgProc,lppi);
    
    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD;
    psh.hwndParent = hwndOwner;
    psh.nPages = ARRAYSIZE(psp);
    psh.nStartPage = 0;
    psh.pszIcon = NULL;
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return (int)(PropertySheet(&psh));
}


//
// FUNCTION: PackWiz_EditPackage(HWND, WORD, LPPACKAGER_INFO)
//
// PURPOSE:  To Run the Edit Package Dialog Procedure
//
//
int PackWiz_EditPackage(HWND hwnd, int idDlg, LPPACKAGER_INFO lppi)
{
    return (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(idDlg), hwnd, PackWiz_EditPackageDlgProc, (LPARAM)lppi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\stdafx.cpp ===
// stdafx.cpp : (ATL) source file that includes just the standard includes
#include "privcpp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\stdafx.h ===
// stdafx.h : (ATL) include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_)
#define AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packexe\priv.h ===
#define STRICT
#define _INC_OLE        // REVIEW: don't include ole.h in windows.h

#define OEMRESOURCE


#ifdef WINNT

//
// NT uses DBG=1 for its debug builds, but the Win95 shell uses
// DEBUG.  Do the appropriate mapping here.
//
#if DBG
#define DEBUG 1
#endif
#endif

#include <windows.h>
#ifdef WINNT
#include <stddef.h>
#include <wingdip.h>
#endif
#include <commctrl.h>
#ifdef WINNT
#include <comctrlp.h>
#endif
#include <windowsx.h>
#include <ole2.h>
#include <shlobj.h>     // Includes <fcext.h>

#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#include <port32.h>
// #include <heapaloc.h>
#include <..\inc\debug.h>      // our version of Assert etc.
#include <shellp.h>

extern "C" BOOL WINAPI PackWizRunFromExe();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packexe\packager.c ===
#include "priv.h"

int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);

extern "C" int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine = GetCommandLine();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitThread(i);  // We only come here when we are not the shell...
    return i;
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hinst, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    return PackWizRunFromExe();
}

extern "C" int __cdecl _purecall(void) { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\packexe\ids.h ===
#ifndef IDS_H__
#define IDS_H__


// Used by packager.rc
//

#define IDI_DOCUMENT			1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\privcpp.h ===
#ifndef pack2cpp_h__
#define pack2cpp_h__

#include <priv.h>

#ifdef __cplusplus

#undef DebugMsg
#define DebugMsg TraceMsg


////////////////////////////////
// Forward declarations
//
class CPackage_IOleObject;
class CPackage_IViewObject2;
class CPackage_IDataObject;
class CPackage_IPersistStorage;
class CPackage_IAdviseSink;
class CPackage_IRunnableObject;
class CPackage_IPersistFile;


////////////////////////////////
// CPackage Definition
//
class CPackage : public IEnumOLEVERB
{

// CPackage interfaces
    friend CPackage_IOleObject;
    friend CPackage_IViewObject2;
    friend CPackage_IDataObject;
    friend CPackage_IPersistStorage;
    friend CPackage_IAdviseSink;
    friend CPackage_IRunnableObject;
    friend CPackage_IPersistFile;
    
    friend DWORD CALLBACK MainWaitOnChildThreadProc(void *);   // used when we shellexec a package
    
public:
    CPackage();                 // constructor
   ~CPackage();                 // destructor
   
    HRESULT Init();             // used to initialze fields that could fail
    BOOL    RunWizard();

    // IUnknown methods...
    STDMETHODIMP            QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    // IEnumOLEVERB methods...
    STDMETHODIMP            Next(ULONG celt, OLEVERB* rgVerbs, ULONG* pceltFetched);
    STDMETHODIMP            Skip(ULONG celt);
    STDMETHODIMP            Reset();
    STDMETHODIMP            Clone(IEnumOLEVERB** ppEnum);
    
protected:
    UINT        _cRef;          // package reference count
    UINT        _cf;            // package clipboard format

    LPIC        _lpic;          // icon for the packaged object
    PANETYPE    _panetype;      // tells us whether we have a cmdlink or embed

    // These are mutually exclusive, so should probably be made into a union,
    // but that's a minor point.
    LPEMBED     _pEmbed;        // embedded file structure
    LPCML       _pCml;          // command line structure

    BOOL        _fLoaded;       // true if data from persistent storage
    
    // IOleObject vars from SetHostNames
    LPOLESTR    _lpszContainerApp;
    LPOLESTR    _lpszContainerObj;
    
    BOOL        _fIsDirty;      // dirty flag for our internal storage from the pov of our container
    DWORD       _dwCookie;      // connection value for AdviseSink
        
    // Package Storages and streams
    IStorage*   _pIStorage;             // storage used to save the package
    IStream*    _pstm;                  // stream used to save package
    IStream*    _pstmFileContents;      // stream used to get file contents
            
    // CPackage Interfaces...
    CPackage_IPersistStorage*   _pIPersistStorage;
    CPackage_IDataObject*       _pIDataObject;
    CPackage_IOleObject*        _pIOleObject;
    CPackage_IViewObject2*      _pIViewObject2;
    CPackage_IAdviseSink*       _pIAdviseSink;
    CPackage_IRunnableObject*   _pIRunnableObject;
    CPackage_IPersistFile*      _pIPersistFile;
    
    // Advise interfaces
    LPDATAADVISEHOLDER          _pIDataAdviseHolder;
    LPOLEADVISEHOLDER           _pIOleAdviseHolder;
    LPOLECLIENTSITE             _pIOleClientSite;

    // Excel hack: when Excel hosts what it thinks is a link it always NULLs out
    // it's "object" pointer.  If we call anything on IOleClientSite other than
    // save then it will fault.
    BOOL    _fNoIOleClientSiteCalls;

    // to be able to send view change notifications we need these vars
    IAdviseSink                *_pViewSink;
    DWORD                       _dwViewAspects;
    DWORD                       _dwViewAdvf;

    // IEnumOLEVERB variables:
    ULONG       _cVerbs;
    ULONG       _nCurVerb;
    OLEVERB*    _pVerbs;
    IContextMenu* _pcm;

    // IEnumOLEVERB helper methods:
    HRESULT InitVerbEnum(OLEVERB* pVerbs, ULONG cVerbs);
    HRESULT GetContextMenu(IContextMenu** ppcm);
    VOID ReleaseContextMenu();

    // if fInitFile is TRUE, then we will totally initialize ourselves
    // from the given filename.  In other words, all our structures will be
    // initialized after calling this is fInitFile = TRUE.  On the other hand,
    // if it's FALSE, then we'll just reinit our data and not update icon
    // and filename information.
    //
    HRESULT EmbedInitFromFile(LPCTSTR lpFileName, BOOL fInitFile);
    HRESULT CmlInitFromFile(LPTSTR lpFilename, BOOL fUpdateIcon, PANETYPE paneType);
    HRESULT InitFromPackInfo(LPPACKAGER_INFO lppi);
    
    HRESULT CreateTempFile();
    HRESULT CreateTempFileName();
    HRESULT IconRefresh();
    void    DestroyIC();
    
    // Data Transfer functions...
    HRESULT GetFileDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetFileContents(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetMetafilePict(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetEnhMetafile(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    HRESULT GetObjectDescriptor(LPFORMATETC pFE, LPSTGMEDIUM pSTM) ;

    HRESULT CreateShortcutOnStream(IStream* pstm); 

    // Packager Read/Write Functions...
    HRESULT PackageReadFromStream(IStream* pstm);
    HRESULT IconReadFromStream(IStream* pstm);
    HRESULT EmbedReadFromStream(IStream* pstm);
    HRESULT CmlReadFromStream(IStream* pstm);
    HRESULT PackageWriteToStream(IStream* pstm);
    HRESULT IconWriteToStream(IStream* pstm, DWORD *pdw);
    HRESULT EmbedWriteToStream(IStream* pstm, DWORD *pdw);
    HRESULT CmlWriteToStream(IStream* pstm, DWORD *pdw);
};


////////////////////////////////////////////
//
// CPackage_IPersistStorage Interface
//
class CPackage_IPersistStorage : public IPersistStorage
{
public:
    CPackage_IPersistStorage(CPackage *pPackage);
   ~CPackage_IPersistStorage();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IPersistStorage Methods...
    STDMETHODIMP        GetClassID(LPCLSID pClassID);
    STDMETHODIMP        IsDirty(void);
    STDMETHODIMP        InitNew(IStorage* pstg);
    STDMETHODIMP        Load(IStorage* pstg);
    STDMETHODIMP        Save(IStorage* pstg, BOOL fSameAsLoad);
    STDMETHODIMP        SaveCompleted(IStorage* pstg);
    STDMETHODIMP        HandsOffStorage(void);
    
protected:
    UINT        _cRef;                  // interface ref count
    CPackage*   _pPackage;              // back pointer to object
    PSSTATE     _psState;               // persistent storage state
};

////////////////////////////////////////////
//
// CPackage_IPersistFile Interface
//
class CPackage_IPersistFile : public IPersistFile
{
public:
    CPackage_IPersistFile(CPackage *pPackage);
   ~CPackage_IPersistFile();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IPersistStorage Methods...
    STDMETHODIMP        GetClassID(LPCLSID pClassID);
    STDMETHODIMP        IsDirty(void);
    STDMETHODIMP        Load(LPCOLESTR pszFileName, DWORD dwdMode);
    STDMETHODIMP        Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP        SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP        GetCurFile(LPOLESTR *ppszFileName);
    
protected:
    UINT        _cRef;                  // interface ref count
    CPackage*   _pPackage;              // back pointer to object
};





////////////////////////////////////////////
//
// CPackage_IDataObject Interface
//
class CPackage_IDataObject : public IDataObject
{
public:
    CPackage_IDataObject(CPackage *pPackage);
   ~CPackage_IDataObject();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IDataObject Methods...
    STDMETHODIMP GetData(LPFORMATETC pFEIn, LPSTGMEDIUM pSTM);
    STDMETHODIMP GetDataHere(LPFORMATETC pFE, LPSTGMEDIUM pSTM);
    STDMETHODIMP QueryGetData(LPFORMATETC pFE);
    STDMETHODIMP GetCanonicalFormatEtc(LPFORMATETC pFEIn, LPFORMATETC pFEOut);
    STDMETHODIMP SetData(LPFORMATETC pFE, LPSTGMEDIUM pSTM, BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC *ppEnum);
    STDMETHODIMP DAdvise(LPFORMATETC pFE, DWORD grfAdv, LPADVISESINK pAdvSink,
                            DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(LPENUMSTATDATA *ppEnum);
    
protected:
    UINT        _cRef;
    CPackage*   _pPackage;
};





////////////////////////////////////////////
//
// CPackage_IOleObject Interface
//

class CPackage_IOleObject : public IOleObject
{
    
    friend DWORD CALLBACK MainWaitOnChildThreadProc(void *);
    
public:
    CPackage_IOleObject(CPackage *pPackage);
   ~CPackage_IOleObject();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    
    // IOleObject Methods...
    STDMETHODIMP SetClientSite(LPOLECLIENTSITE pClientSite);
    STDMETHODIMP GetClientSite(LPOLECLIENTSITE *ppClientSite);
    STDMETHODIMP SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHODIMP Close(DWORD dwSaveOption);
    STDMETHODIMP SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk);
    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMonkier,LPMONIKER *ppmk);
    STDMETHODIMP InitFromData(LPDATAOBJECT pDataObject, BOOL fCreation, 
                                 DWORD dwReserved);
    STDMETHODIMP GetClipboardData(DWORD dwReserved, LPDATAOBJECT *ppDataObject);
    STDMETHODIMP DoVerb(LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite, 
                           LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHODIMP EnumVerbs(LPENUMOLEVERB *ppEnumOleVerb);
    STDMETHODIMP Update(void);
    STDMETHODIMP IsUpToDate(void);
    STDMETHODIMP GetUserClassID(LPCLSID pClsid);
    STDMETHODIMP GetUserType(DWORD dwFromOfType, LPOLESTR *pszUserType);
    STDMETHODIMP SetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    STDMETHODIMP GetExtent(DWORD dwDrawAspect, LPSIZEL psizel);
    STDMETHODIMP Advise(LPADVISESINK pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP Unadvise(DWORD dwConnection);
    STDMETHODIMP EnumAdvise(LPENUMSTATDATA *ppenumAdvise);
    STDMETHODIMP GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHODIMP SetColorScheme(LPLOGPALETTE pLogpal);
    
protected:
    UINT        _cRef;
    CPackage*   _pPackage;
    
};





////////////////////////////////////////////
//
// CPackage_IViewObject2 Interface
//
class CPackage_IViewObject2 : public IViewObject2
{
public:
    CPackage_IViewObject2(CPackage *pPackage);
   ~CPackage_IViewObject2();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IViewObject2 Methods...
    STDMETHODIMP Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
                         DVTARGETDEVICE *ptd, HDC hdcTargetDev,
                         HDC hdcDraw, LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                         BOOL (CALLBACK *pfnContinue)(ULONG_PTR), ULONG_PTR dwContinue);
    STDMETHODIMP GetColorSet(DWORD dwAspect, LONG lindex, void *pvAspect,
                                DVTARGETDEVICE *ptd, HDC hdcTargetDev,
                                LPLOGPALETTE *ppColorSet);
    STDMETHODIMP Freeze(DWORD dwDrawAspect, LONG lindex, void * pvAspect, 
                           DWORD *pdwFreeze);
    STDMETHODIMP Unfreeze(DWORD dwFreeze);
    STDMETHODIMP SetAdvise(DWORD dwAspects, DWORD dwAdvf,
                              LPADVISESINK pAdvSink);
    STDMETHODIMP GetAdvise(DWORD *pdwAspects, DWORD *pdwAdvf,
                              LPADVISESINK *ppAdvSink);
    STDMETHODIMP GetExtent(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd,
                              LPSIZEL pszl);
                           
protected:
    UINT                _cRef;
    CPackage*           _pPackage;
    BOOL                _fFrozen;
};


////////////////////////////////////////////
//
// CPackage_IAdviseSink Interface
//
class CPackage_IAdviseSink : public IAdviseSink
{
public:
    CPackage_IAdviseSink(CPackage *pPackage);
   ~CPackage_IAdviseSink();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IAdviseSink Methods...
    STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
    STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
    STDMETHODIMP_(void)  OnRename(LPMONIKER);
    STDMETHODIMP_(void)  OnSave(void);
    STDMETHODIMP_(void)  OnClose(void);
                           
protected:
    UINT                _cRef;
    CPackage*           _pPackage;
    
};

////////////////////////////////////////////
//
// CPackage_IRunnableObject Interface
//
class CPackage_IRunnableObject : public IRunnableObject
{
public:
    CPackage_IRunnableObject(CPackage *pPackage);
   ~CPackage_IRunnableObject();
    
    // IUnknown Methods...
    STDMETHODIMP         QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IRunnable Object methods...
    STDMETHODIMP        GetRunningClass(LPCLSID);
    STDMETHODIMP        Run(LPBC);
    STDMETHODIMP_(BOOL) IsRunning();
    STDMETHODIMP        LockRunning(BOOL,BOOL);
    STDMETHODIMP        SetContainedObject(BOOL);
    
protected:
    UINT                _cRef;
    CPackage*           _pPackage;
    
};



////////////////////////////////////////////
//
// Package Wizard and Edit Package Dialog Procs and functions
//

// Pages for Wizard
INT_PTR APIENTRY PackWiz_CreatePackageDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_SelectFileDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_SelectIconDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_SelectLabelDlgProc(HWND, UINT, WPARAM, LPARAM);

// Edit dialog procs
INT_PTR APIENTRY PackWiz_EditEmbedPackageDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY PackWiz_EditCmdPackakgeDlgProc(HWND, UINT, WPARAM, LPARAM);

// functions
int  PackWiz_CreateWizard(HWND,LPPACKAGER_INFO);
int  PackWiz_EditPackage(HWND,int,LPPACKAGER_INFO);
VOID PackWiz_FillInPropertyPage(PROPSHEETPAGE *, INT, DLGPROC);


#endif  // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pack\priv.h ===
#ifndef pack2_h__
#define pack2_h__


#define INC_OLE2        // Prevent windows.h from pulling in OLE 1
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <shlobj.h>         // ;Internal
#include <shellapi.h>       // ;Internal
#include <shlwapi.h>
#include <shlwapip.h>       // ;Internal
#include <ole2.h>

#include <ole2ver.h>
// #include <crtfree.h>    // don't use CRT libs
#include <ccstock.h>
// #include <shsemip.h>    // in ccshell\inc
// #include <shellp.h>     // in ccshell\inc
// #include <debug.h>      // in ccshell\inc
// #include <shguidp.h>    // in ccshell\inc

#include "packutil.h"
#include "packguid.h"
#include "ids.h"



HRESULT CPackage_CreateInstnace(IUnknown ** ppunk);

//////////////////////////////////
// External Variables
//
extern UINT             g_cRefThisDll;        // per-instance
extern HINSTANCE        g_hinst;                
extern UINT             g_cfFileContents;       
extern UINT             g_cfFileDescriptor;
extern UINT             g_cfObjectDescriptor;
extern UINT             g_cfEmbedSource;
extern UINT             g_cfFileNameW;
extern INT              g_cxIcon;
extern INT              g_cyIcon;
extern INT              g_cxArrange;
extern INT              g_cyArrange;
extern HFONT            g_hfontTitle;


//////////////////////////////////
// Global Constants
//
#define HIMETRIC_PER_INCH       2540    // Number of HIMETRIC units per inch
#define DEF_LOGPIXELSX          96      // Default values for pixels per
#define DEF_LOGPIXELSY          96      // logical inch
#define CBCMDLINKMAX            500     // num chars in cmdline package
#define FILE_SHARE_READWRITE    (FILE_SHARE_READ | FILE_SHARE_WRITE)
#define OLEIVERB_EDITPACKAGE    (OLEIVERB_PRIMARY+1)
#define OLEIVERB_FIRST_CONTEXT  (OLEIVERB_PRIMARY+2)
#define OLEIVERB_LAST_CONTEXT   (OLEIVERB_PRIMARY+0xFFFF)
#define PACKWIZ_NUM_PAGES    3    // number of pages in our wizard


//////////////////////////////////
// Clipboard Formats
//
#define CF_FILECONTENTS     g_cfFileContents
#define CF_FILEDESCRIPTOR   g_cfFileDescriptor
#define CF_OBJECTDESCRIPTOR g_cfObjectDescriptor
#define CF_EMBEDSOURCE      g_cfEmbedSource
#define CF_FILENAMEW        g_cfFileNameW
#define CFSTR_EMBEDSOURCE   TEXT("Embed Source")
#define CFSTR_OBJECTDESCRIPTOR TEXT("Object Descriptor")


//////////////////////////////////
// String constants
//
#define SZUSERTYPE              L"OLE Package"
#define SZCONTENTS              L"\001Ole10Native"
#define SZAPPNAME               TEXT("Object Packager")

//////////////////////////////////
// Old packager junk...
//
// NOTE: This enumeration is used to determine what kind of information
// is stored in a packager object.  Currently, the new packager on supports
// ICON and PEMBED.  We will probably want to implement CMDLINK and PICTURE
// to remain back compatible with the old packager.
//
typedef enum
{
    NOTHING,
    CMDLINK,
    ICON,
    PEMBED,
    PICTURE,
    PACKAGE
} PANETYPE;

//////////////////////////////////
// Embedded File structure
//
// NOTE: This is similar to the structure used by the old packager to store
// information about the embedded file, however it is slightly different.
// Most notably, I use a FILEDESCRIPTOR structure to hold onto the filename
// and filesize so this information can be easily transferred in a GetData call
// Also, I've deleted some uncessary fields that the old packager used to 
// deal with OLE 1 ways of dealing with things.

typedef struct _EMBED           // embed
{
    FILEDESCRIPTOR fd;          // file descriptor of embedded file
    LPTSTR  pszTempName;        // temp. file name used when shellexec'ing
    HANDLE hTask;               // handle to task on shellexec'ed objects
    LPOLEOBJECT poo;            // oleobject interface on running contents
    BOOL   fIsOleFile;          // TRUE if OLE can activate this type of file
} EMBED, *LPEMBED;


//////////////////////////////////
// Command line structure
//
// NOTE: This is the structure the old packager used when implementing
// the command line packages.  It will be best to use this structure for
// the new packager for ease of use in reading and writing old packager
// formats.
//
typedef struct _CML             // cml
{
    BOOL fCmdIsLink;
    TCHAR szCommandLine[CBCMDLINKMAX];
} CML, *LPCML;

////////////////////////////////
// PackageInfo Structure
//
// NOTE: This structure is used by the Create New Package Wizard and the
// Edit Package dialogs.  We use it to hold onto package information, so that
// the CPackage Object can initialize/reinitialize itself after one of these
// calls.
//
typedef struct _packageInfo 
{
    TCHAR    szLabel[MAX_PATH];
    TCHAR    szFilename[MAX_PATH];
    TCHAR    szIconPath[MAX_PATH];
    int     iIcon;                // must be an int for PickIconDlg
} PACKAGER_INFO, *LPPACKAGER_INFO;


////////////////////////////////
// PersistStorage enumeration
//
typedef enum
{
        PSSTATE_UNINIT = 0, //Uninitialized
        PSSTATE_SCRIBBLE,   //Scribble
        PSSTATE_ZOMBIE,     //No scribble
        PSSTATE_HANDSOFF    //Hand-off
} PSSTATE;

#endif

#include "debug.h"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\powertoy\resource.h ===
// controls for the resize pictures dialog

#define IDR_SSHOW_EXE                   100

#define DLG_RESIZEPICTURES              256
#define DLG_BURNWIZ_SLIDESHOW           257

#define IDC_RESIZE_SMALL                1024
#define IDC_RESIZE_MEDIUM               1025
#define IDC_RESIZE_LARGE                1026

#define IDC_BURNWIZ_BURNPICTURE         1024
#define IDC_BURNWIZ_BURNDATA            1025

#define IDS_BURNWIZ_SLIDESHOW_HEAD      2000
#define IDS_BURNWIZ_SLIDESHOW_SUB       2001
#define IDS_BURN_WIZTITLE               2002

#define IDS_RESIZEPICTURES              2100
#define IDS_RESIZESMALLSUFFIX           2101
#define IDS_RESIZEMEDIUMSUFFIX          2102
#define IDS_RESIZELARGESUFFIX           2103

#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\powertoy\dll.cpp ===
#include "precomp.h"
#include "advpub.h"         // For REGINSTALL
#pragma hdrstop

#define DECL_CRTFREE
#include <crtfree.h>


// Fix the debug builds
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "resize"
#define SZ_MODULE           "resize"

#define DECLARE_DEBUG
#include "debug.h"


// interface stuff

// CLSID_ResizePhotos  {1530f7ee-5128-43bd-9977-84a4b0fad7df}
const CLSID CLSID_ResizePhotos = {0x1530f7ee,0x5128,0x43bd,{0x99, 0x77, 0x84, 0xa4, 0xb0, 0xfa, 0xd7, 0xdf}};
// CLSID_SlideshowExtension  {efb97cb8-a4a4-4357-a261-002ffaed0267}
const CLSID CLSID_SlideshowExtension = {0xefb97cb8,0xa4a4,0x4357,{0xa2, 0x61, 0x00, 0x2f, 0xfa, 0xed, 0x02, 0x67}};

STDAPI CResizePhotos_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CSlideshowExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);


// shell/lib files look for this instance variable
EXTERN_C HINSTANCE g_hinst = 0;
LONG g_cLocks = 0;
BOOL g_bMirroredOS = FALSE;


// DLL lifetime stuff

STDAPI_(BOOL) DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hinstDLL;                         // For shell/lib files who extern him
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        SHFusionInitializeFromModule(hinstDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }
    
    return TRUE;  // Successful DLL_PROCESS_ATTACH.
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;                        
}

STDAPI DllCanUnloadNow()
{
    return (g_cLocks == 0) ? S_OK:S_FALSE;
}
 
STDAPI_(void) DllAddRef(void)
{
    InterlockedIncrement(&g_cLocks);
}

STDAPI_(void) DllRelease(void)
{
    InterlockedDecrement(&g_cLocks);
}


// helper to handle the SELFREG.INF parsing

HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(g_hinst, szSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer()
{
    return _CallRegInstall("RegDll", FALSE);
}

STDAPI DllUnregisterServer()
{
    return S_OK;
}


//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
#define OIF_ALLOWAGGREGATION  0x0001

CF_TABLE_BEGIN(g_ObjectInfo)

    CF_TABLE_ENTRY( &CLSID_ResizePhotos,       CResizePhotos_CreateInstance,       COCREATEONLY),
    CF_TABLE_ENTRY( &CLSID_SlideshowExtension, CSlideshowExtension_CreateInstance, COCREATEONLY),

CF_TABLE_END(g_ObjectInfo)


// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}


// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        _ASSERT(FAILED(hres) ? *ppv == NULL : TRUE);
        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = CLASS_E_CLASSNOTAVAILABLE;
    *ppv = NULL;
 
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                DllAddRef();        // class factory holds DLL ref count
                hr = S_OK;
            }
        }

    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\powertoy\makefile.inc ===
$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln

resource.rc : $(SELFREGNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\powertoy\precomp.h ===
#include <windows.h>        // basic windows functionality
#include <windowsx.h>
#include <commctrl.h>       // ImageList, ListView
#include <comctrlp.h>
#include "cfdefs.h"
#include <shfusion.h>
#include <crtdbg.h>         // _ASSERT macro

#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobj.h>         // Needed by dsclient.h
#include <shlobjp.h>
#include <shlguid.h>
#include <shlguidp.h>
#include <shellp.h>         
#include <ccstock.h>
#include <varutil.h>
#include <debug.h>

#include "resource.h"

// keep the debug libraries working...
#ifdef DBG
 #if !defined (DEBUG)
  #define DEBUG
 #endif
#else
 #undef DEBUG
#endif

STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

EXTERN_C HINSTANCE g_hinst;

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\classfac.h ===
#ifndef CLASSFAC_H
#define CLASSFAC_H

class CClassFactory : public IClassFactory
{
protected:
    LONG m_ObjRefCount;

public:
    CClassFactory();
    ~CClassFactory();

    //
    // IUnknown methods
    //

    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(DWORD) AddRef();
    STDMETHODIMP_(DWORD) Release();

    //
    // IClassFactory methods
    //

    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
    STDMETHODIMP LockServer(BOOL);
};

#endif   // CLASSFAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\powertoy\slideshow.cpp ===
// handles the downlevel slideshow extension

#include "precomp.h"
#include <cowsite.h>

typedef struct
{
    INT idPage;
    INT idHeading;
    INT idSubHeading;
    DWORD dwFlags;
    DLGPROC dlgproc;
} WIZPAGE;

HPROPSHEETPAGE _CreatePropPageFromInfo(const WIZPAGE *pwp, LPARAM lParam)
{
    PROPSHEETPAGE psp = { 0 };
    psp.dwSize = sizeof(psp);
    psp.hInstance = g_hinst;
    psp.lParam = lParam;
    psp.dwFlags = PSP_USETITLE | PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | pwp->dwFlags;
    psp.pszTemplate = MAKEINTRESOURCE(pwp->idPage);
    psp.pfnDlgProc = pwp->dlgproc;
    psp.pszTitle = MAKEINTRESOURCE(IDS_BURN_WIZTITLE);
    psp.pszHeaderTitle = MAKEINTRESOURCE(pwp->idHeading);
    psp.pszHeaderSubTitle = MAKEINTRESOURCE(pwp->idSubHeading);
    return CreatePropertySheetPage(&psp);
}

HRESULT _CreateDataObject(IDataObject **ppdo)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CDBURN_AREA, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlChild;
        IShellFolder* psf;
        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(NULL, 1, &pidlChild, IID_X_PPV_ARG(IDataObject, NULL, ppdo));
            psf->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

STDAPI CSlideshowExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
class CSlideshowExtension : public CObjectWithSite,
                            public ICDBurnExt,
                            public IDropTarget,
                            public IWizardExtension,
                            public INamespaceWalkCB
{
public:
    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ICDBurnExt methods
    STDMETHOD(GetSupportedActionTypes)(DWORD *pdwActions);

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { return E_NOTIMPL; }
    STDMETHOD(DragLeave)(void)
        { return E_NOTIMPL; }
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IWizardExtension
    STDMETHOD(AddPages)(HPROPSHEETPAGE *aPages, UINT cPages, UINT *pnPages);
    STDMETHOD(GetFirstPage)(HPROPSHEETPAGE *phPage);
    STDMETHOD(GetLastPage)(HPROPSHEETPAGE *phPage);

    // INamespaceWalkCB
    STDMETHOD(FoundItem)(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(EnterFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(LeaveFolder)(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    static INT_PTR s_SlideshowDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
        { CSlideshowExtension *pse = s_GetSlideshowExtension(hwnd, uMsg, lParam); return pse->_SlideshowDlgProc(hwnd, uMsg, wParam, lParam); }

private:
    CSlideshowExtension();
    ~CSlideshowExtension();

    LONG _cRef;

    UINT _cTotalFiles, _cPictureFiles;
    HPROPSHEETPAGE _hpage;
    BOOL _fSelectPictures;

    BOOL _DataObjectHasPictureFiles(IDataObject *pdo);

    // wizard page
    static CSlideshowExtension* s_GetSlideshowExtension(HWND hwnd, UINT uMsg, LPARAM lParam);
    INT_PTR _SlideshowDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _SetCompletionState();

    // copy stuff
    BOOL _FileExistsInStaging(LPCWSTR pszFile);
    BOOL _SafeToWrite();
    HRESULT _CopyGDIPLUS(LPCWSTR pszBase);
    HRESULT _CopySSHOW(LPCWSTR pszBase);
    HRESULT _CreateAutorunINF(LPCWSTR pszBase);

    friend HRESULT CSlideshowExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

CSlideshowExtension::CSlideshowExtension() :
    _cRef(1)
{
    _fSelectPictures = TRUE;
}

CSlideshowExtension::~CSlideshowExtension()
{
    ASSERT(!_punkSite);
}

// IUnknown

STDMETHODIMP_(ULONG) CSlideshowExtension::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSlideshowExtension::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CSlideshowExtension::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSlideshowExtension, ICDBurnExt),
        QITABENT(CSlideshowExtension, IDropTarget),
        QITABENT(CSlideshowExtension, IWizardExtension),
        QITABENT(CSlideshowExtension, IObjectWithSite),
        QITABENT(CSlideshowExtension, INamespaceWalkCB),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CSlideshowExtension_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION; 

    CSlideshowExtension *pse = new CSlideshowExtension();
    if (!pse)
        return E_OUTOFMEMORY;

    HRESULT hr = pse->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pse->Release();
    return hr;
}

CSlideshowExtension* CSlideshowExtension::s_GetSlideshowExtension(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if (uMsg == WM_INITDIALOG)
    {
        PROPSHEETPAGE *ppsp = (PROPSHEETPAGE*)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, ppsp->lParam);
        return (CSlideshowExtension*)ppsp->lParam;
    }
    return (CSlideshowExtension*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
}

HRESULT CSlideshowExtension::GetSupportedActionTypes(DWORD *pdwActions)
{
    *pdwActions = CDBE_TYPE_DATA;
    return S_OK;
}

HRESULT CSlideshowExtension::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    _cTotalFiles++;

    WCHAR szName[MAX_PATH];
    if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))) &&
        PathIsImage(szName))
    {
        _cPictureFiles++;
    }
    return S_OK;
}

BOOL CSlideshowExtension::_DataObjectHasPictureFiles(IDataObject *pdo)
{
    _cTotalFiles = 0;
    _cPictureFiles = 0;

    INamespaceWalk *pnsw;
    if (SUCCEEDED(CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw))))
    {
        pnsw->Walk(pdo, NSWF_DONT_TRAVERSE_LINKS | NSWF_DONT_ACCUMULATE_RESULT, 4, this);
        pnsw->Release();
    }

    // avoid div by zero and check if it's more than 60% pictures
    return _cTotalFiles ? (_cPictureFiles >= (UINT)MulDiv(_cTotalFiles, 3, 5)) : FALSE;
}

BOOL CSlideshowExtension::_FileExistsInStaging(LPCWSTR pszFile)
{
    BOOL fExists = TRUE; // default to true so we dont overwrite in error cases

    WCHAR szFullPath[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_CDBURN_AREA, NULL, 0, szFullPath)))
    {
        if (PathCombine(szFullPath, szFullPath, pszFile) &&
            !PathFileExists(szFullPath))
        {
            fExists = FALSE;
        }
    }
    return fExists;
}

BOOL CSlideshowExtension::_SafeToWrite()
{
    // these filenames aren't localizable or anything.
    return !_FileExistsInStaging(L"autorun.inf") &&
           !_FileExistsInStaging(L"autorun.exe") &&
           !_FileExistsInStaging(L"gdiplus.dll");
}

HRESULT CSlideshowExtension::DragEnter(IDataObject *pdo, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_NONE;

    ICDBurnPriv *pcdbp;
    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_CDBurn, NULL, IID_PPV_ARG(ICDBurnPriv, &pcdbp))))
    {
        BOOL fOnMedia;
        if (SUCCEEDED(pcdbp->GetContentState(NULL, &fOnMedia)) && !fOnMedia &&
            _DataObjectHasPictureFiles(pdo) &&
            _SafeToWrite())
        {
            *pdwEffect = DROPEFFECT_COPY;
        }
        pcdbp->Release();
    }    
    return S_OK;
}

HRESULT CSlideshowExtension::_CopyGDIPLUS(LPCWSTR pszBase)
{
    HRESULT hr = E_FAIL;
    WCHAR szGDIPlus[MAX_PATH];
    if (PathCombine(szGDIPlus, pszBase, L"gdiplus.dll"))
    {
        // this is actually the cleanest way to do it -- we need fusion to go off and get
        // gdiplus from the right place.
        // note: dont have to worry about ia64 since burning got punted for it.
        HMODULE hmodGDI = LoadLibrary(L"gdiplus.dll");
        if (hmodGDI)
        {
            WCHAR szGDISrc[MAX_PATH];
            if (GetModuleFileName(hmodGDI, szGDISrc, ARRAYSIZE(szGDISrc)) &&
                CopyFile(szGDISrc, szGDIPlus, TRUE))
            {
                hr = S_OK;
                SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szGDIPlus, NULL);
            }
            FreeLibrary(hmodGDI);
        }
    }
    return hr;
}

HRESULT CSlideshowExtension::_CopySSHOW(LPCWSTR pszBase)
{
    // todo: maybe use PathYetAnotherMakeUniqueName here, but maybe nobody will ever care.
    HRESULT hr = E_FAIL;
    WCHAR szSSHOW[MAX_PATH];
    if (PathCombine(szSSHOW, pszBase, L"autorun.exe"))
    {
        // note: dont have to worry about ia64 since burning got punted for it.
        HRSRC hrsrc = FindResource(g_hinst, MAKEINTRESOURCE(IDR_SSHOW_EXE), L"BINARY");
        if (hrsrc)
        {
            HGLOBAL hFileHandle = LoadResource(g_hinst, hrsrc);
            if (hFileHandle)
            {
                BYTE *pBuf = (BYTE *)LockResource(hFileHandle);
                if (pBuf)
                {
                    HANDLE hNewFile = CreateFile(szSSHOW, GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, NULL);
                    if (INVALID_HANDLE_VALUE != hNewFile)
                    {
                        DWORD cb, dwSize = SizeofResource(g_hinst, hrsrc);
                        WriteFile(hNewFile, pBuf, dwSize, &cb, NULL);
                        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szSSHOW, NULL);
                        hr = S_OK;

                        CloseHandle(hNewFile);
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CSlideshowExtension::_CreateAutorunINF(LPCWSTR pszBase)
{
    HRESULT hr = E_FAIL;
    WCHAR szAutorun[MAX_PATH];
    if (PathCombine(szAutorun, pszBase, L"autorun.inf"))
    {
        HANDLE hFile = CreateFile(szAutorun, GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            const WCHAR c_szText[] = L"[autorun]\r\nopen=autorun.exe\r\nUseAutoPLAY=1";

            DWORD dw;
            WriteFile(hFile, c_szText, sizeof(c_szText), &dw, NULL);
            CloseHandle(hFile);

            hr = S_OK;
            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szAutorun, NULL);
        }
    }
    return hr;
}

HRESULT CSlideshowExtension::Drop(IDataObject *pdo, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // bring this in when sshow.exe is in the install
    // we know the media is blank, so we dont need to worry about a merged namespace.
    // work on the filesystem.
    HRESULT hr = E_FAIL;
    if (_SafeToWrite())
    {
        // if they somehow add files called "autorun.inf", "autorun.exe", or "gdiplus.dll" between now
        // and when we're done in the next fraction of a second, we wont overwrite those but the autorun
        // may not work... screw em.

        WCHAR szStaging[MAX_PATH];
        hr = SHGetFolderPath(NULL, CSIDL_CDBURN_AREA, NULL, 0, szStaging);
        if (SUCCEEDED(hr))
        {
            _CopyGDIPLUS(szStaging);
            _CopySSHOW(szStaging);
            _CreateAutorunINF(szStaging);
        }
    }
    return hr;
}

HRESULT CSlideshowExtension::GetLastPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hpage;
    return S_OK;
}

HRESULT CSlideshowExtension::GetFirstPage(HPROPSHEETPAGE *phPage)
{
    *phPage = _hpage;
    return S_OK;
}

HRESULT CSlideshowExtension::AddPages(HPROPSHEETPAGE *aPages, UINT cPages, UINT *pnPages)
{
    *pnPages = 0;

    WIZPAGE c_wp =
        {DLG_BURNWIZ_SLIDESHOW, IDS_BURNWIZ_SLIDESHOW_HEAD, IDS_BURNWIZ_SLIDESHOW_SUB, 0, CSlideshowExtension::s_SlideshowDlgProc};

    _hpage = _CreatePropPageFromInfo(&c_wp, (LPARAM)this);
    if (cPages > 0)
    {
        aPages[0] = _hpage;
        *pnPages = 1;
    }
    return S_OK;
}

// pushes the return state back to the main wizard
void CSlideshowExtension::_SetCompletionState()
{
    IPropertyBag *ppb;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_CDWizardHost, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        SHPropertyBag_WriteDWORD(ppb, PROPSTR_EXTENSIONCOMPLETIONSTATE, CDBE_RET_DEFAULT);
        ppb->Release();
    }
}

INT_PTR CSlideshowExtension::_SlideshowDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;
            switch (pnmh->code)
            {
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(pnmh->hwndFrom, PSWIZB_BACK | PSWIZB_NEXT);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNPICTURE), _fSelectPictures ? BST_CHECKED : BST_UNCHECKED);
                    Button_SetCheck(GetDlgItem(hwnd, IDC_BURNWIZ_BURNDATA), _fSelectPictures ? BST_UNCHECKED : BST_CHECKED);
                    fRet = TRUE;
                    break;

                case PSN_WIZBACK:
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetPreviousPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                            }
                            pws->Release();
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNPICTURE) == BST_CHECKED)
                    {
                        IDataObject *pdo;
                        if (SUCCEEDED(_CreateDataObject(&pdo)))
                        {
                            POINTL pt = {0};
                            if (SUCCEEDED(Drop(pdo, 0, pt, NULL)))
                            {
                                _SetCompletionState();
                            }
                            pdo->Release();
                        }
                    }
                    if (_punkSite) 
                    {
                        IWizardSite *pws;
                        if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IWizardSite, &pws))))
                        {
                            HPROPSHEETPAGE hpage;
                            if (SUCCEEDED(pws->GetNextPage(&hpage)))
                            {
                                PropSheet_SetCurSel(GetParent(hwnd), hpage, -1);
                                SetWindowLongPtr(hwnd, DWLP_MSGRESULT, (LPARAM)-1);
                            }
                            pws->Release();
                        }
                    }
                    fRet = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    _fSelectPictures = (IsDlgButtonChecked(hwnd, IDC_BURNWIZ_BURNPICTURE) == BST_CHECKED);
                    break;
            }
            break;
        }
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\classfac.cpp ===
#include <windows.h>
#include <objbase.h>
#include <shlobj.h>

#include <docobj.h>
#include "shfolder.h"

#include "classfac.h"

extern LONG       	g_DllRefCount;



CClassFactory::CClassFactory()
{
    m_ObjRefCount = 1;
    InterlockedIncrement(&g_DllRefCount);
}


CClassFactory::~CClassFactory()
{
    InterlockedDecrement(&g_DllRefCount);
}


STDMETHODIMP
CClassFactory::QueryInterface(
    REFIID riid,
    LPVOID *ppReturn
    )
{
    *ppReturn = NULL;

    if(IsEqualIID(riid, IID_IUnknown))
        *ppReturn = (IUnknown*)(CClassFactory*)this;
    else if(IsEqualIID(riid, IID_IClassFactory))
        *ppReturn = (CClassFactory*)this;

	if(*ppReturn == NULL)
		return E_NOINTERFACE;

    (*(LPUNKNOWN*)ppReturn)->AddRef();
    return S_OK;
}                                             


STDMETHODIMP_(DWORD)
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_ObjRefCount);
}


STDMETHODIMP_(DWORD)
CClassFactory::Release()
{
	LONG lDecremented = InterlockedDecrement(&m_ObjRefCount);
    
    if(lDecremented == 0)
       delete this;

    return lDecremented;
}


STDMETHODIMP
CClassFactory::CreateInstance(
    LPUNKNOWN pUnknown,
    REFIID riid,
    LPVOID *ppObject
    )
{
    if(pUnknown != NULL)
        return CLASS_E_NOAGGREGATION;


    CShellFolder *pShellFolder = new CShellFolder(NULL, NULL);
    if(NULL == pShellFolder)
        return E_OUTOFMEMORY;

    //
    // get the QueryInterface return for our return value
    //

    HRESULT hResult = pShellFolder->QueryInterface(riid, ppObject);

    //
    // call Release to decrement the ref count
    //

    pShellFolder->Release();

    return hResult;
}

STDMETHODIMP
CClassFactory::LockServer(
    BOOL fLock
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\powertoy\resize.cpp ===
#include "precomp.h"
#include "shimgdata.h"
#include <gdiplus.h>
using namespace Gdiplus;
#pragma hdrstop


class CResizePhotos : public IShellExtInit, IContextMenu, INamespaceWalkCB
{
public:
    CResizePhotos();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();        
    STDMETHODIMP_(ULONG) Release();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdto, HKEY hkProgID);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pCMI);
    STDMETHODIMP GetCommandString(UINT_PTR uID, UINT uFlags, UINT *res, LPSTR pName, UINT ccMax)
        { return E_NOTIMPL; }

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_FALSE; }
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
        { return S_OK; }
    STDMETHODIMP InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel);

private:
    ~CResizePhotos();
    HRESULT _ResizeItems(HWND hwnd, IDataObject *pdo);

    long _cRef;
    IDataObject *_pdo;
    int _iDestSize;
};


CResizePhotos::CResizePhotos() :
    _cRef(1), _iDestSize(0)
{  
    DllAddRef();
}

CResizePhotos::~CResizePhotos()
{      
    IUnknown_Set((IUnknown**)&_pdo, NULL);
    DllRelease();
}

STDAPI CResizePhotos_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CResizePhotos *prp = new CResizePhotos();
    if (!prp)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = prp->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    prp->Release();
    return hr;
}


// IUnknown

ULONG CResizePhotos::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CResizePhotos::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CResizePhotos::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CResizePhotos, IShellExtInit),
        QITABENT(CResizePhotos, IContextMenu),
        QITABENT(CResizePhotos, INamespaceWalkCB),
        {0, 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


// IShellExtInit

HRESULT CResizePhotos::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdto, HKEY hkProgID)
{
    IUnknown_Set((IUnknown**)&_pdo, pdto);
    return S_OK;
}


// IContextMenu

HRESULT CResizePhotos::QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags)
{
    if (!_pdo)
        return E_UNEXPECTED;

    if (!(uFlags & CMF_DEFAULTONLY))
    {
        TCHAR szBuffer[64];
        LoadString(g_hinst, IDS_RESIZEPICTURES, szBuffer, ARRAYSIZE(szBuffer));
        InsertMenu(hMenu, uIndex++, MF_BYPOSITION|MF_STRING, uIDFirst + 0x0, szBuffer);
    }

    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 1);
}

HRESULT CResizePhotos::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    if (IS_INTRESOURCE(pici->lpVerb))
    {
        switch(LOWORD(pici->lpVerb))
        {
            case 0:
                hr = _ResizeItems(pici->hwnd, _pdo);
                break;
        }
    }
    return hr; 
}


// Walk the list of files and generate resized versions of them

struct
{
    int cx, cy, idsSuffix;
} 
_aSizes[] =
{
    { 640,  480, IDS_RESIZESMALLSUFFIX },
    { 800,  600, IDS_RESIZEMEDIUMSUFFIX }, 
    { 1024, 768, IDS_RESIZELARGESUFFIX },  
};

HRESULT CResizePhotos::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];
    HRESULT hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szName, ARRAYSIZE(szName));
    if (SUCCEEDED(hr) && PathIsImage(szName))
    {
        // create the decoder for this file and decode it so we know we can scale and
        // persist it again.

        IShellImageDataFactory *psidf;
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &psidf));
        if (SUCCEEDED(hr))
        {
            IShellImageData *psid;
            if (SUCCEEDED(psidf->CreateImageFromFile(szName, &psid)))
            {
                hr = psid->Decode(SHIMGDEC_DEFAULT, 0, 0);
                if (SUCCEEDED(hr))
                {
                    SIZE szImage;
                    hr = psid->GetSize(&szImage);
                    if (SUCCEEDED(hr))
                    {
                        // lets scale based on the largest axis to keep its aspect ratio

                        if (szImage.cx > szImage.cy)
                        {
                            if (szImage.cx >= _aSizes[_iDestSize].cx)
                                hr = psid->Scale(_aSizes[_iDestSize].cx, 0, InterpolationModeHighQuality);
                        }
                        else
                        {
                            if (szImage.cy >= _aSizes[_iDestSize].cy)
                                hr = psid->Scale(0, _aSizes[_iDestSize].cy, InterpolationModeHighQuality);
                        }

                        // format up a new name for the based on its current name, and the size we
                        // are generating

                        TCHAR szNewName[MAX_PATH];
                        lstrcpyn(szNewName, szName, ARRAYSIZE(szNewName));

                        TCHAR szSuffix[MAX_PATH];
                        LoadString(g_hinst, _aSizes[_iDestSize].idsSuffix, szSuffix, ARRAYSIZE(szSuffix));
                        
                        PathRemoveExtension(szNewName);
                        PathRemoveBlanks(szNewName);
                        StrCatBuff(szNewName, szSuffix, ARRAYSIZE(szNewName));
                        StrCatBuff(szNewName, PathFindExtension(szName), ARRAYSIZE(szNewName));
                        PathYetAnotherMakeUniqueName(szNewName, szNewName, NULL, NULL);

                        IPersistFile *ppf;
                        hr = psid->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                        if (SUCCEEDED(hr))
                        {
                            hr = ppf->Save(szNewName, FALSE);
                            ppf->Release();
                        }
                    }
                }
                psid->Release();
            }
            psidf->Release();
        }
    }
    return hr;
}

HRESULT CResizePhotos::InitializeProgressDialog(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
{
    *ppszCancel = NULL; // use default

    TCHAR szMsg[128];
    LoadString(g_hinst, IDS_RESIZEPICTURES, szMsg, ARRAYSIZE(szMsg));
    return SHStrDup(szMsg, ppszTitle);
}


INT_PTR _ResizeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            Button_SetCheck(GetDlgItem(hwnd, IDC_RESIZE_SMALL), BST_CHECKED);
            return TRUE;

        case WM_COMMAND:
        {
            switch (wParam)
            {
                case IDCANCEL:
                    EndDialog(hwnd, -1);
                    break;

                case IDOK:
                {
                    int iResponse;
                    if (IsDlgButtonChecked(hwnd, IDC_RESIZE_SMALL))
                        iResponse = 0;
                    else if (IsDlgButtonChecked(hwnd, IDC_RESIZE_MEDIUM))
                        iResponse = 1;
                    else
                        iResponse = 2;
                    
                    EndDialog(hwnd, iResponse);
                }
            }
        }
    }
    return FALSE;
}                                    

HRESULT CResizePhotos::_ResizeItems(HWND hwnd, IDataObject *pdo)
{
    HRESULT hr = S_OK;

    _iDestSize = (int)DialogBox(g_hinst, MAKEINTRESOURCE(DLG_RESIZEPICTURES), hwnd, _ResizeDlgProc);
    if (_iDestSize >= 0)
    {
        INamespaceWalk *pnsw;
        hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
        if (SUCCEEDED(hr))
        {
            hr = pnsw->Walk(pdo, NSWF_SHOW_PROGRESS|NSWF_DONT_ACCUMULATE_RESULT|NSWF_FILESYSTEM_ONLY|NSWF_FLAG_VIEWORDER, 1, SAFECAST(this, INamespaceWalkCB *));
            pnsw->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\guid.h ===
#ifndef GUID_H
#define GUID_H

//
// {5fe50e0e-8dcb-11d0-8c43-00c04fc2c621}
//

DEFINE_GUID(
    CLSID_PStoreNameSpace,
    0x5fe50e0e,
    0x8dcb,
    0x11d0,
    0x8c,
    0x43,
    0x00,
    0xc0,
    0x4f,
    0xc2,
    0xc6,
    0x21
    );

#define CLSID_CmdGrp CLSID_PStoreNameSpace

#endif   // GUID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\icon.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    icon.h

Abstract:

    This module implements icon handling code for the protected storage
    explorer.

    The shell uses these interfaces to retrieve icons associated with
    folders in the protected storage namespace.

Author:

    Scott Field (sfield)    11-Mar-97

--*/

#ifndef ICON_H
#define ICON_H

class CExtractIcon : public IExtractIcon
{

protected:
    LONG m_ObjRefCount;

public:
    CExtractIcon(LPCITEMIDLIST pidl);
    ~CExtractIcon();

    //
    // IUnknown methods
    //

    STDMETHOD (QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_ (ULONG, AddRef) (void);
    STDMETHOD_ (ULONG, Release) (void);

    //
    // IExtractIcon methods
    //

    STDMETHOD (GetIconLocation) (UINT, LPTSTR, UINT, LPINT, LPUINT);
    STDMETHOD (Extract) (LPCTSTR, UINT, HICON*, HICON*, UINT);

private:
	DWORD m_dwType;
	PST_KEY m_KeyType;
};

#endif   // ICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\enumid.cpp ===
/*++

    Implements IEnumIDList.

--*/

#include <windows.h>
#include <shlobj.h>

#include "pstore.h"

#include "utility.h"

#include "enumid.h"
#include "shfolder.h"



extern LONG       g_DllRefCount;



CEnumIDList::CEnumIDList(
    LPITEMIDLIST pidl,
    BOOL bEnumItems
    )
{


    m_pIEnumProviders = NULL;
    m_pIPStoreProvider = NULL;
    m_pIEnumTypes = NULL;
    m_pIEnumTypesGlobal = NULL;
    m_pIEnumSubtypes = NULL;
    m_pIEnumItems = NULL;

    m_bEnumItems = bEnumItems;


    //
    // get the shell's IMalloc pointer
    // we'll keep this until we get destroyed
    //

    if(FAILED(SHGetMalloc(&m_pMalloc)))
        delete this;

    m_KeyType = PST_KEY_CURRENT_USER;

    if(pidl == NULL) {

        if( PStoreEnumProviders(0, &m_pIEnumProviders) != S_OK )
            m_pIEnumProviders = NULL;

        m_dwType = PIDL_TYPE_PROVIDER;  // top-level
    } else {
        m_dwType = GetLastPidlType(pidl) + 1;   // parent + 1
    }

    //
    // get provider interface
    //

    if(m_dwType > PIDL_TYPE_PROVIDER) {
        PST_PROVIDERID      *ProviderId = GetPidlGuid(pidl);
        if(PStoreCreateInstance(&m_pIPStoreProvider, ProviderId, NULL, 0) != S_OK)
            m_pIPStoreProvider = NULL;
    }

    //
    // prepare two type enumerators, if appropriate:
    // PST_KEY_CURRENT_USER and PST_KEY_LOCAL_MACHINE
    //

    if(m_dwType == PIDL_TYPE_TYPE && m_pIPStoreProvider) {
        m_pIPStoreProvider->EnumTypes(PST_KEY_CURRENT_USER, 0, &m_pIEnumTypes);
        m_pIPStoreProvider->EnumTypes(PST_KEY_LOCAL_MACHINE, 0, &m_pIEnumTypesGlobal);
    }

    //
    // prepare subtype enumerator
    //

    if(m_dwType == PIDL_TYPE_SUBTYPE && m_pIPStoreProvider) {
        GUID    *pguidType;

        m_KeyType = GetLastPidlKeyType(pidl);
        pguidType = GetLastPidlGuid(pidl);
        CopyMemory(&m_guidType, pguidType, sizeof(GUID));

        m_pIPStoreProvider->EnumSubtypes(
                m_KeyType,
                pguidType,
                0,
                &m_pIEnumSubtypes
                );
    }

    //
    // prepare item enumerator if appropriate.
    //

    if(m_dwType == PIDL_TYPE_ITEM && m_bEnumItems && m_pIPStoreProvider) {
        GUID    *pguidType;
        GUID    *pguidSubtype;

        m_KeyType = GetLastPidlKeyType(pidl);
        pguidSubtype = GetLastPidlGuid(pidl);
        CopyMemory(&m_guidSubtype, pguidSubtype, sizeof(GUID));

        pguidType = GetPidlGuid(SearchPidlByType(pidl, PIDL_TYPE_TYPE));
        CopyMemory(&m_guidType, pguidType, sizeof(GUID));

        m_pIPStoreProvider->EnumItems(
                m_KeyType,
                pguidType,
                pguidSubtype,
                0,
                &m_pIEnumItems
                );
    }

    m_ulCurrent = 0;
    m_ObjRefCount = 1;

    InterlockedIncrement(&g_DllRefCount);
}


CEnumIDList::~CEnumIDList()
{
    //
    // free any interfaces we established.
    //

    if(m_pIEnumProviders) {
        m_pIEnumProviders->Release();
        m_pIEnumProviders = NULL;
    }

    if(m_pIPStoreProvider) {
        m_pIPStoreProvider->Release();
        m_pIPStoreProvider = NULL;
    }

    if(m_pIEnumTypes) {
        m_pIEnumTypes->Release();
        m_pIEnumTypes = NULL;
    }

    if(m_pIEnumTypesGlobal) {
        m_pIEnumTypesGlobal->Release();
        m_pIEnumTypesGlobal = NULL;
    }

    if(m_pIEnumSubtypes) {
        m_pIEnumSubtypes->Release();
        m_pIEnumSubtypes = NULL;
    }

    if(m_pIEnumItems) {
        m_pIEnumItems->Release();
        m_pIEnumItems = NULL;
    }

    if(m_pMalloc) {
        m_pMalloc->Release();
        m_pMalloc = NULL;
    }

    InterlockedDecrement(&g_DllRefCount);
}



STDMETHODIMP
CEnumIDList::QueryInterface(
    REFIID riid,
    LPVOID *ppReturn
    )
{
    *ppReturn = NULL;

    if(IsEqualIID(riid, IID_IUnknown))
        *ppReturn = (IUnknown*)(CEnumIDList*)this;
    else if(IsEqualIID(riid, IID_IEnumIDList))
        *ppReturn = (CEnumIDList*)this;

    if(*ppReturn == NULL)
        return E_NOINTERFACE;

    (*(LPUNKNOWN*)ppReturn)->AddRef();
    return S_OK;
}


STDMETHODIMP_(DWORD)
CEnumIDList::AddRef()
{
    return InterlockedIncrement(&m_ObjRefCount);
}


STDMETHODIMP_(DWORD)
CEnumIDList::Release()
{
    LONG lDecremented = InterlockedDecrement(&m_ObjRefCount);

    if(lDecremented == 0)
        delete this;

    return lDecremented;
}

STDMETHODIMP
CEnumIDList::Next(
    ULONG ulElements,
    LPITEMIDLIST *pPidl,
    ULONG *pulFetched
    )
/*++

    Retrieves the specified number of item identifiers in the enumeration
    sequence and advances the current position.

    Returns the NOERROR value if successful,
    Returns S_FALSE value if there are no more items in the enumeration
    or an OLE-defined error value if an error occurs.

--*/
{
    HRESULT hr;

    *pPidl = NULL;
    *pulFetched = 0;

    if(m_bEnumItems) {
        if(m_dwType > PIDL_TYPE_ITEM)
            return S_FALSE;
    } else {
        if(m_dwType > PIDL_TYPE_SUBTYPE)
            return S_FALSE; // nothing left to enumerate
    }


    if(m_dwType == PIDL_TYPE_PROVIDER && m_pIEnumProviders)
    {
        PPST_PROVIDERINFO   pProvInfo;

        if( m_pIEnumProviders->Next(1, &pProvInfo, &m_ulCurrent) != S_OK ) {

            //
            // enumeration of providers complete
            //

            return S_FALSE;
        }

        hr = CreateIDList(m_dwType, m_KeyType, &(pProvInfo->ID), pProvInfo->szProviderName, pPidl);

        CoTaskMemFree(pProvInfo);

        if(hr != S_OK)
            return S_FALSE;

        *pulFetched = 1;
        return NOERROR;
    }

    //
    // must have a valid provider interface at this point
    //

    if(m_pIPStoreProvider == NULL)
        return S_FALSE;

    if(m_dwType == PIDL_TYPE_TYPE) {

        IEnumPStoreTypes    *pIEnumTypes;
        PST_KEY             KeyType = PST_KEY_CURRENT_USER;
        GUID                guidType;

type_enum:

        if(KeyType == PST_KEY_LOCAL_MACHINE)
            pIEnumTypes = m_pIEnumTypesGlobal;
        else
            pIEnumTypes = m_pIEnumTypes;

        if(pIEnumTypes == NULL)
            return S_FALSE;

        if(pIEnumTypes->Next(1, &guidType, &m_ulCurrent) != S_OK) {

            //
            // if enumeration at PST_KEY_CURRENT_USER level complete,
            // continue at the PST_KEY_LOCAL_MACHINE level.
            //

            if(KeyType == PST_KEY_CURRENT_USER) {
                KeyType = PST_KEY_LOCAL_MACHINE;
                goto type_enum;
            }

            //
            // enumeration of types complete
            //

            return S_FALSE;
        }

        PST_TYPEINFO        *pTypeInfo = NULL;

        if(S_OK != m_pIPStoreProvider->GetTypeInfo(
                    KeyType,
                    &guidType,
                    &pTypeInfo,
                    0
                    )) return S_FALSE;

        hr = CreateIDList(m_dwType, KeyType, &guidType, pTypeInfo->szDisplayName, pPidl);

        //
        // free pTypeInfo data
        //

        CoTaskMemFree(pTypeInfo);

        if(hr != S_OK)
            return S_FALSE;

        *pulFetched = 1;
        return NOERROR;
    }

    if (m_dwType == PIDL_TYPE_SUBTYPE && m_pIEnumSubtypes) {

        GUID                guidSubtype;
        GUID                *pguidType = &m_guidType;

        if(m_pIEnumSubtypes->Next(1, &guidSubtype, &m_ulCurrent) != S_OK) {

            //
            // enumeration of types complete
            //

            return S_FALSE;
        }

        PST_TYPEINFO        *pTypeInfo = NULL;

        if(m_pIPStoreProvider->GetSubtypeInfo(m_KeyType, pguidType, &guidSubtype, &pTypeInfo, 0) != S_OK)
            return S_FALSE;

        hr = CreateIDList(m_dwType, m_KeyType, &guidSubtype, pTypeInfo->szDisplayName, pPidl);

        //
        // free pTypeInfo data
        //

        CoTaskMemFree(pTypeInfo);

        if(hr != S_OK)
            return S_FALSE;

        *pulFetched = 1;
        return NOERROR;
    }

    if(m_dwType == PIDL_TYPE_ITEM && m_pIEnumItems) {

        LPWSTR pszItem;

        //
        // enumerate and add items associated with specified subtype
        //

        if(m_pIEnumItems->Next(1, &pszItem, &m_ulCurrent) != S_OK) {

            //
            // enumeration of items complete
            //

            return S_FALSE;
        }

        hr = CreateIDList(
                    m_dwType,
                    m_KeyType,
                    NULL, // no item guid
                    pszItem,
                    pPidl
                    );

        //
        // free pszItem data
        //

        CoTaskMemFree(pszItem);

        if(hr != S_OK)
            return S_FALSE;

        *pulFetched = 1;
        return NOERROR;
    }

    return S_FALSE;
}


STDMETHODIMP
CEnumIDList::CreateIDList(
    DWORD dwType,
    PST_KEY KeyType,
    GUID *guid,
    LPCWSTR szString,
    LPITEMIDLIST *pPidlOut
    )
{
    DWORD cbString = 0;
    DWORD cbPidlContent;

    if(szString) {
        cbString = lstrlenW(szString);
    }

    cbString = (cbString + 1) * sizeof(WCHAR);

    cbPidlContent = sizeof(PIDL_CONTENT) + cbString;

    //
    // allocate the memory
    //

    *pPidlOut = (LPITEMIDLIST)m_pMalloc->Alloc(
            sizeof(ITEMIDLIST) +    // this item's ITEMIDLIST
            cbPidlContent +         // this item's data
            sizeof(ITEMIDLIST)      // terminal ITEMIDLIST
            );

    if(*pPidlOut == NULL)
        return E_OUTOFMEMORY;


    LPITEMIDLIST pidlTemp = *pPidlOut;
    LPPIDL_CONTENT pidlContent = (LPPIDL_CONTENT)&(pidlTemp->mkid.abID);


    //
    // set the size of this item
    //

    pidlTemp->mkid.cb = (unsigned short)(sizeof(ITEMIDLIST) + cbPidlContent);

    //
    // set the data for this item
    //

    pidlContent->dwType = dwType;
    pidlContent->KeyType = KeyType;

    if( guid ) {
        CopyMemory(&(pidlContent->guid), guid, sizeof(GUID));
    } else {
        ZeroMemory(&(pidlContent->guid), sizeof(GUID));
    }

    if(szString) {
        CopyMemory((LPBYTE)(pidlContent+1), szString, cbString);
    } else {
        ((LPWSTR)(pidlContent+1))[0] = L'\0';
    }

    //
    // advance and terminate item ID list
    //

    pidlTemp = (LPITEMIDLIST)GetPidlNextItem(*pPidlOut);
    pidlTemp->mkid.cb = 0;
    pidlTemp->mkid.abID[0] = 0;

    return NOERROR;
}



STDMETHODIMP
CEnumIDList::Skip(
    ULONG ulSkip
    )
{
    m_ulCurrent += ulSkip;

    return NOERROR;
}


STDMETHODIMP
CEnumIDList::Reset(
    void
    )
{
    m_ulCurrent = 0;

    return NOERROR;
}


STDMETHODIMP
CEnumIDList::Clone(
    LPENUMIDLIST *ppEnum
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\icon.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    icon.cpp

Abstract:

    This module implements icon handling code for the protected storage
    explorer.

    The shell uses these interfaces to retrieve icons associated with
    folders in the protected storage namespace.

Author:

    Scott Field (sfield)    11-Mar-97

--*/

#include <windows.h>
#include <shlobj.h>

#include "pstore.h"

#include "enumid.h"
#include "utility.h"

#include "icon.h"
#include "resource.h"

extern HINSTANCE    g_hInst;
extern LONG         g_DllRefCount;


CExtractIcon::CExtractIcon(
    LPCITEMIDLIST pidl
    )
{

    //
    // squirrel away the type value and key type associated with the specified
    // pidl
    //

    m_dwType = GetPidlType(pidl);
    m_KeyType = GetPidlKeyType(pidl);

    m_ObjRefCount = 1;
}


CExtractIcon::~CExtractIcon()
{
}


STDMETHODIMP
CExtractIcon::QueryInterface(
    REFIID riid,
    LPVOID *ppReturn
    )
{
    *ppReturn = NULL;

    if(IsEqualIID(riid, IID_IUnknown))
        *ppReturn = (IUnknown*)(IExtractIcon*)this;
    else if(IsEqualIID(riid, IID_IExtractIcon))
        *ppReturn = (IUnknown*)(IExtractIcon*)this;

    if(*ppReturn == NULL)
        return E_NOINTERFACE;

    (*(LPUNKNOWN*)ppReturn)->AddRef();
    return S_OK;
}


STDMETHODIMP_(DWORD)
CExtractIcon::AddRef()
{
    return InterlockedIncrement(&m_ObjRefCount);
}


STDMETHODIMP_(DWORD)
CExtractIcon::Release()
{
    LONG lDecremented = InterlockedDecrement(&m_ObjRefCount);

    if(lDecremented == 0)
        delete this;

    return lDecremented;
}


STDMETHODIMP
CExtractIcon::GetIconLocation(
    UINT uFlags,
    LPTSTR szIconFile,
    UINT cchMax,
    LPINT piIndex,
    LPUINT puFlags
    )
{
    //
    // tell the shell to always call Extract
    //

    *puFlags = GIL_NOTFILENAME;

    if(uFlags & GIL_OPENICON) {
        *piIndex = 1;  // tell Extract to return the open icon
    } else {
        *piIndex = 0;

        //
        // if the icon request is associated with the "global" local machine,
        // and is at the Type or Subtype level, display a different icon.
        //

        if( m_KeyType == PST_KEY_LOCAL_MACHINE &&
            (m_dwType == PIDL_TYPE_TYPE || m_dwType == PIDL_TYPE_SUBTYPE) )
            *piIndex = 2;
    }

    return NOERROR;
}


STDMETHODIMP
CExtractIcon::Extract(
    LPCTSTR pszFile,
    UINT nIconIndex,
    HICON *phiconLarge,
    HICON *phiconSmall,
    UINT nIconSize
    )
{
    LPTSTR Resource;

    UINT nIconSizeLarge = (UINT)LOWORD(nIconSize);
    UINT nIconSizeSmall = (UINT)HIWORD(nIconSize);

    //
    // note icons are cached for performance reasons.
    //

    switch (nIconIndex) {
    case 0:
        static UINT nIconSizeSmallFolder;
        static UINT nIconSizeLargeFolder;
        static HICON hIconSmallFolder;
        static HICON hIconLargeFolder;

        Resource = MAKEINTRESOURCE(IDI_FOLDER);

        if(nIconSizeSmall != nIconSizeSmallFolder) {
            hIconSmallFolder = (HICON)LoadImage(g_hInst, Resource, IMAGE_ICON, nIconSizeSmall, nIconSizeSmall, LR_DEFAULTCOLOR | LR_SHARED);
            nIconSizeSmallFolder = nIconSizeSmall;
        }
        *phiconSmall = hIconSmallFolder;

        if(nIconSizeLarge != nIconSizeLargeFolder) {
            hIconLargeFolder = (HICON)LoadImage(g_hInst, Resource, IMAGE_ICON, nIconSizeLarge, nIconSizeLarge, LR_DEFAULTCOLOR | LR_SHARED);
            nIconSizeLargeFolder = nIconSizeLarge;
        }
        *phiconLarge = hIconLargeFolder;
        return S_OK;
    case 1:
        static UINT nIconSizeSmallFolderOpen;
        static UINT nIconSizeLargeFolderOpen;
        static HICON hIconSmallFolderOpen;
        static HICON hIconLargeFolderOpen;

        Resource = MAKEINTRESOURCE(IDI_FOLDEROPEN);

        if(nIconSizeSmall != nIconSizeSmallFolderOpen) {
            hIconSmallFolderOpen = (HICON)LoadImage(g_hInst, Resource, IMAGE_ICON, nIconSizeSmall, nIconSizeSmall, LR_DEFAULTCOLOR | LR_SHARED);
            nIconSizeSmallFolderOpen = nIconSizeSmall;
        }
        *phiconSmall = hIconSmallFolderOpen;

        if(nIconSizeLarge != nIconSizeLargeFolderOpen) {
            hIconLargeFolderOpen = (HICON)LoadImage(g_hInst, Resource, IMAGE_ICON, nIconSizeLarge, nIconSizeLarge, LR_DEFAULTCOLOR | LR_SHARED);
            nIconSizeLargeFolderOpen = nIconSizeLarge;
        }
        *phiconLarge = hIconLargeFolderOpen;
        return S_OK;
    case 2:
        static UINT nIconSizeSmallGlobal;
        static UINT nIconSizeLargeGlobal;
        static HICON hIconSmallGlobal;
        static HICON hIconLargeGlobal;

        Resource = MAKEINTRESOURCE(IDI_GLOBAL);

        if(nIconSizeSmall != nIconSizeSmallGlobal) {
            hIconSmallGlobal = (HICON)LoadImage(g_hInst, Resource, IMAGE_ICON, nIconSizeSmall, nIconSizeSmall, LR_DEFAULTCOLOR | LR_SHARED);
            nIconSizeSmallGlobal = nIconSizeSmall;
        }
        *phiconSmall = hIconSmallGlobal;

        if(nIconSizeLarge != nIconSizeLargeGlobal) {
            hIconLargeGlobal = (HICON)LoadImage(g_hInst, Resource, IMAGE_ICON, nIconSizeLarge, nIconSizeLarge, LR_DEFAULTCOLOR | LR_SHARED);
            nIconSizeLargeGlobal = nIconSizeLarge;
        }
        *phiconLarge = hIconLargeGlobal;
        return S_OK;
    default:
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\enumid.h ===
#ifndef ENUMID_H
#define ENUMID_H

#define PIDL_TYPE_PROVIDER  0
#define PIDL_TYPE_TYPE      1
#define PIDL_TYPE_SUBTYPE   2
#define PIDL_TYPE_ITEM      3

typedef struct {
    DWORD dwType;
    PST_KEY KeyType;
    GUID  guid;         // guid associated with Pidl
} PIDL_CONTENT, *PPIDL_CONTENT, *LPPIDL_CONTENT;
// WCHAR Array follows.

class CEnumIDList : public IEnumIDList
{
protected:
    LONG m_ObjRefCount;

public:
    CEnumIDList(LPITEMIDLIST, BOOL);
    ~CEnumIDList();

    //
    // IUnknown methods
    //

    STDMETHOD (QueryInterface)(REFIID, LPVOID*);
    STDMETHOD_ (DWORD, AddRef)();
    STDMETHOD_ (DWORD, Release)();

    //
    // IEnumIDList
    //

    STDMETHOD (Next) (ULONG, LPITEMIDLIST*, ULONG *);
    STDMETHOD (Skip) (ULONG);
    STDMETHOD (Reset) (void);
    STDMETHOD (Clone) (LPENUMIDLIST*);

private:
    LPMALLOC m_pMalloc;

    STDMETHOD (CreateIDList) (DWORD, PST_KEY, GUID *, LPCWSTR, LPITEMIDLIST *);

    ULONG m_ulCurrent;
    DWORD m_dwType;
    PST_KEY m_KeyType;
    GUID m_guidType;
    GUID m_guidSubtype;

    BOOL m_bEnumItems;

    IEnumPStoreProviders    *m_pIEnumProviders;
    IPStore                 *m_pIPStoreProvider;
    IEnumPStoreTypes        *m_pIEnumTypes;
    IEnumPStoreTypes        *m_pIEnumTypesGlobal;
    IEnumPStoreTypes        *m_pIEnumSubtypes;
    IEnumPStoreItems        *m_pIEnumItems;
};

#endif   // ENUMID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\listunic.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    listunic.cpp

Abstract:

    This module implements Unicode -> ANSI string thunking for the listview
    functions on Win95, and Unicode -> Unicode passthru on WinNT.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

//
// make sure we bring in Unicode version of ListView macros + definitions
//

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <shlobj.h>

#include "listu.h"
#include "unicode.h"

int
ListView_InsertItemU(
    HWND hwnd,
    const LV_ITEM FAR *pitem
    )
{
    if(FIsWinNT())
        return ListView_InsertItemUnicode(hwnd, pitem);

    return ListView_InsertItemAnsi(hwnd, pitem);
}

VOID
WINAPI
ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPWSTR pszText
    )
{
    if(FIsWinNT())
        ListView_SetItemTextUnicode(hwnd, i, iSubItem, pszText);
    else
        ListView_SetItemTextAnsi(hwnd, i, iSubItem, pszText);
}



int
ListView_InsertItemUnicode(
    HWND hwnd,
    const LV_ITEM FAR *pitem
    )
{

    //
    // the strings we were passed are already Unicode, just pass control
    // directly to the Unicode version.
    //

    return ListView_InsertItem(hwnd, pitem);
}

VOID
WINAPI
ListView_SetItemTextUnicode(
    HWND hwnd,
    int i,
    int iSubItem,
    LPWSTR pszText
    )
{
    //
    // the strings we were passed are already Unicode, just pass control
    // directly to the Unicode version.
    //

    ListView_SetItemText(hwnd, i, iSubItem, pszText);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\listu.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    listu.h

Abstract:

    This module implements Unicode -> ANSI string thunking for the listview
    functions on Win95, and Unicode -> Unicode passthru on WinNT.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __LISTU_H__
#define __LISTU_H__

#ifdef __cplusplus
extern "C" {
#endif



//
// Unicode to ANSI conversion stubs.
//

int
ListView_InsertItemU(
    HWND hwnd,
    const LV_ITEM FAR *pitem
    );

VOID
WINAPI
ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPWSTR pszText
    );


//
// ANSI function prototypes
//

int
ListView_InsertItemAnsi(
    HWND hwnd,
    const LV_ITEM FAR *pitem
    );

VOID
WINAPI
ListView_SetItemTextAnsi(
    HWND hwnd,
    int i,
    int iSubItem,
    LPWSTR pszText
    );

//
// Unicode function prototypes
//

int
ListView_InsertItemUnicode(
    HWND hwnd,
    const LV_ITEM FAR *pitem
    );

VOID
WINAPI
ListView_SetItemTextUnicode(
    HWND hwnd,
    int i,
    int iSubItem,
    LPWSTR pszText
    );

#ifdef __cplusplus
}
#endif

#endif  // __LISTU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\psexsup.h ===
#ifndef PSEXSUP_H
#define PSEXSUP_H

BOOL InitializePStoreSupport();
BOOL ShutdownPStoreSupport();

#endif // PSEXSUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\psexsup.cpp ===
#include <windows.h>
#include <objbase.h>

#include "psexsup.h"

#include "pstore.h"


BOOL
InitializePStoreSupport(
    VOID
    )
{
    HRESULT hr;

    hr = CoInitialize(NULL);

    //
    // since explorer is likely to have init'ed OLE already, treat that
    // case as success
    //

    if(hr != S_OK && hr != S_FALSE)
        return FALSE;

    return TRUE;
}

BOOL
ShutdownPStoreSupport(
    VOID
    )
{
    CoUninitialize();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\listansi.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    listansi.cpp

Abstract:

    This module implements Unicode -> ANSI string thunking for the listview
    functions on Win95.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

//
// make sure we bring in ANSI version of ListView macros + definitions
//

#undef UNICODE
#include <windows.h>
#include <shlobj.h>

#include "listu.h"

int
ListView_InsertItemAnsi(
    HWND hwnd,
    const LV_ITEM FAR *pitem
    )
{
    LV_ITEM NewItem;
    int iRet;

    LPWSTR pszText = (LPWSTR)(pitem->pszText);

    LPSTR pszTextAnsi;
    CHAR FastBuffer[MAX_PATH + 1];
    LPSTR SlowBuffer = NULL;

    DWORD cchText;

    //
    // convert the input Unicode strings to ANSI and then call the ANSI
    // version (for Win95).
    //


    cchText = lstrlenW(pszText);

    if(cchText == 0 || pszText == NULL) {
        pszTextAnsi = NULL;
    } else {

        DWORD cchRequired;

        //
        // convert supplied Unicode buffer to ANSI
        // try fast buffer first.
        //

        cchRequired = WideCharToMultiByte(
            CP_ACP,
            0,
            pszText,
            cchText + 1, // include NULL
            FastBuffer,
            0,
            NULL,
            NULL
            );

        if(cchRequired > sizeof(FastBuffer)) {
            SlowBuffer = (LPSTR)HeapAlloc(GetProcessHeap(), 0, cchRequired);
            if(SlowBuffer == NULL) return -1;
            pszTextAnsi = SlowBuffer;
        } else {
            pszTextAnsi = FastBuffer;
        }

        cchRequired = WideCharToMultiByte(
            CP_ACP,
            0,
            pszText,
            cchText + 1, // include NULL
            pszTextAnsi,
            cchRequired,
            NULL,
            NULL
            );
    }


    //
    // copy existing structure contents.
    //

    CopyMemory(&NewItem, pitem, sizeof(NewItem));

    NewItem.pszText = pszTextAnsi;

    // make call to ANSI version
    iRet = ListView_InsertItem(hwnd, &NewItem);

    if(SlowBuffer)
        HeapFree(GetProcessHeap(), 0, SlowBuffer);

    return iRet;
}

VOID
WINAPI
ListView_SetItemTextAnsi(
    HWND hwnd,
    int i,
    int iSubItem,
    LPWSTR pszText
    )
{
    LPSTR pszTextAnsi;
    CHAR FastBuffer[MAX_PATH + 1];
    LPSTR SlowBuffer = NULL;

    DWORD cchText;

    cchText = lstrlenW(pszText);

    if(cchText == 0 || pszText == NULL) {
        pszTextAnsi = NULL;
    } else {

        DWORD cchRequired;

        //
        // convert supplied Unicode buffer to ANSI
        // try fast buffer first.
        //

        cchRequired = WideCharToMultiByte(
            CP_ACP,
            0,
            pszText,
            cchText + 1, // include NULL
            FastBuffer,
            0,
            NULL,
            NULL
            );

        if(cchRequired > sizeof(FastBuffer)) {
            SlowBuffer = (LPSTR)HeapAlloc(GetProcessHeap(), 0, cchRequired);
            if(SlowBuffer == NULL) return;
            pszTextAnsi = SlowBuffer;
        } else {
            pszTextAnsi = FastBuffer;
        }

        cchRequired = WideCharToMultiByte(
            CP_ACP,
            0,
            pszText,
            cchText + 1, // include NULL
            pszTextAnsi,
            cchRequired,
            NULL,
            NULL
            );
    }


    //
    // convert the input Unicode strings to ANSI and then call the ANSI
    // version (for Win95).
    //


    ListView_SetItemText(hwnd, i, iSubItem, pszTextAnsi);

    if(SlowBuffer)
        HeapFree(GetProcessHeap(), 0, SlowBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\main.cpp ===
/*++
   
    Contains DLLMain and standard OLE COM object creation stuff.

--*/


#include <windows.h>
#include <objbase.h>
#include <shlobj.h>
#include <olectl.h> // Dll[Un]RegisterServer

#include "classfac.h"
#include "psexsup.h"

#define DECL_CRTFREE
#include <crtfree.h>

//   GUID stuff

// this is only done once
// TODO, see if this is appropriate

#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "guid.h"
#pragma data_seg()


HINSTANCE   g_hInst;
LONG        g_DllRefCount = 0;
BOOL        g_bShowIETB;
BOOL        g_bShowISTB;
int         g_nColumn1;
int         g_nColumn2;


extern "C" BOOL WINAPI DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstance);
            g_hInst = hInstance;

            //
            // initialize Protected Storage Support routines
            //
            
            if(!InitializePStoreSupport())
                return FALSE;

		    //
			// init common controls
			//

		    INITCOMMONCONTROLSEX iccex;
		    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
		    iccex.dwICC = ICC_LISTVIEW_CLASSES;
		    InitCommonControlsEx(&iccex);

            break;

        case DLL_PROCESS_DETACH:
            ShutdownPStoreSupport();
            break;
    }

    return TRUE;
}                                 


STDAPI
DllCanUnloadNow(
    void
    )
{
    return (g_DllRefCount ? S_FALSE : S_OK);
}


STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID *ppReturn
    )
{

    //
    // if we don't support this classid, return the proper error code
    //

    if(!IsEqualCLSID(rclsid, CLSID_PStoreNameSpace))
       return CLASS_E_CLASSNOTAVAILABLE;

    //
    // create a CClassFactory object and check it for validity
    //

    CClassFactory *pClassFactory = new CClassFactory();
    if(NULL == pClassFactory)
       return E_OUTOFMEMORY;

    //
    // get the QueryInterface return for our return value
    //

    HRESULT hResult = pClassFactory->QueryInterface(riid, ppReturn);

    //
    // call Release to decrement the ref count - creating the object set it to
    // one and QueryInterface incremented it - since its being used externally
    // (not by us), we only want the ref count to be 1
    //

    pClassFactory->Release();

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\shfolder.h ===
#ifndef SHFOLDER_H
#define SHFOLDER_H


class CShellFolder : public IShellFolder, public IPersistFolder
{
friend class CShellView;

protected:
    LONG m_ObjRefCount;

public:
    CShellFolder(CShellFolder*, LPCITEMIDLIST);
    ~CShellFolder();

    //
    // IUnknown methods
    //

    STDMETHOD (QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_ (ULONG, AddRef) (void);
    STDMETHOD_ (ULONG, Release) (void);

    //
    // IPersist methods
    //

    STDMETHODIMP GetClassID(LPCLSID);

    //
    // IPersistFolder methods
    //

    STDMETHODIMP Initialize(LPCITEMIDLIST);

    //
    // IShellFolder methods
    //

    STDMETHOD (ParseDisplayName) (HWND, LPBC, LPOLESTR, LPDWORD, LPITEMIDLIST*, LPDWORD);
    STDMETHOD (EnumObjects) (HWND, DWORD, LPENUMIDLIST*);
    STDMETHOD (BindToObject) (LPCITEMIDLIST, LPBC, REFIID, LPVOID*);
    STDMETHOD (BindToStorage) (LPCITEMIDLIST, LPBC, REFIID, LPVOID*);
    STDMETHOD (CompareIDs) (LPARAM, LPCITEMIDLIST, LPCITEMIDLIST);
    STDMETHOD (CreateViewObject) (HWND, REFIID, LPVOID* );
    STDMETHOD (GetAttributesOf) (UINT, LPCITEMIDLIST*, ULONG *);
    STDMETHOD (GetUIObjectOf) (HWND, UINT, LPCITEMIDLIST*, REFIID, LPUINT, LPVOID*);
    STDMETHOD (GetDisplayNameOf) (LPCITEMIDLIST, DWORD, LPSTRRET);
    STDMETHOD (SetNameOf) (HWND, LPCITEMIDLIST, LPCOLESTR, DWORD, LPITEMIDLIST*);

private:
    LPITEMIDLIST m_pidl;
    CShellFolder *m_pSFParent;
    LPMALLOC m_pMalloc;

    //
    // utility functions
    //

	BOOL HasSubFolders(LPCITEMIDLIST pidl);
    BOOL GetPidlFullText(LPCITEMIDLIST, LPTSTR, DWORD);
};

#endif   // SHFOLDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\resource.h ===
#define IDS_PSTORE_TITLE                1
#define IDS_MI_REGISTRY                 2
#define IDS_MI_MESSAGE1                 3
#define IDS_TB_MESSAGE1                 4
#define IDS_MI_MESSAGE2                 5
#define IDS_TB_MESSAGE2                 6
#define IDS_MI_VIEW_ISTB                7
#define IDS_MI_VIEW_IETB                8
#define IDS_COLUMN1                     9
#define IDS_COLUMN2                     10
#define IDS_DEFAULT                     11
#define IDS_NODATA                      12
#define IDI_PSTORE                      100
#define IDI_GLOBAL                      101 // global type folder
#define IDI_FOLDER                      102
#define IDI_FOLDEROPEN                  103
#define IDI_ITEM                        104
#define IDI_PROVIDER                    105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40002
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\shfolder.cpp ===
/*++

    Implements IShellFolder.

    IUnknown
    IPersist
    IPersistFolder
    IShellFolder
    IExtractIcon

Soon:

    IContextMenu
    IDataObject
    IShellPropSheetExt ?

--*/

#include <windows.h>
#include <shlobj.h>

#include <docobj.h> // IOleCommandTarget

#include "pstore.h"

#include "enumid.h"
#include "utility.h"

#include "shfolder.h"
#include "shview.h"
#include "icon.h"   // icon handling
#include "guid.h"
#include "resource.h"


extern HINSTANCE    g_hInst;
extern LONG         g_DllRefCount;


CShellFolder::CShellFolder(
    CShellFolder *pParent,
    LPCITEMIDLIST pidl
    )
{

    m_pSFParent = pParent;
    if(m_pSFParent) {
        m_pSFParent->AddRef();
    }

    //
    // get the shell's IMalloc pointer
    // we'll keep this until we get destroyed
    //

    if(FAILED(SHGetMalloc(&m_pMalloc)))
        delete this;

    //
    // make a copy of the pidl in it's entirety.  We do this so we are free
    // to look at the pidl later.
    //

    m_pidl = CopyPidl(m_pMalloc, pidl);

    m_ObjRefCount = 1;
    InterlockedIncrement(&g_DllRefCount);
}


CShellFolder::~CShellFolder()
{
    if(m_pSFParent)
        m_pSFParent->Release();

    if(m_pidl)
        m_pMalloc->Free(m_pidl);

    if(m_pMalloc)
        m_pMalloc->Release();

    InterlockedDecrement(&g_DllRefCount);
}


STDMETHODIMP
CShellFolder::QueryInterface(
    REFIID riid,
    LPVOID *ppReturn
    )
{
    *ppReturn = NULL;

    if(IsEqualIID(riid, IID_IUnknown))
        *ppReturn = (IUnknown*)(IShellFolder*)this;
    else if(IsEqualIID(riid, IID_IPersistFolder))
        *ppReturn = (IPersistFolder*)(CShellFolder*)this;
    else if(IsEqualIID(riid, IID_IShellFolder))
        *ppReturn = (CShellFolder*)this;

    if(*ppReturn == NULL)
        return E_NOINTERFACE;

    (*(LPUNKNOWN*)ppReturn)->AddRef();
    return S_OK;
}


STDMETHODIMP_(DWORD)
CShellFolder::AddRef()
{
    return InterlockedIncrement(&m_ObjRefCount);
}


STDMETHODIMP_(DWORD)
CShellFolder::Release()
{
    LONG lDecremented = InterlockedDecrement(&m_ObjRefCount);

    if(lDecremented == 0)
        delete this;

    return lDecremented;
}


STDMETHODIMP
CShellFolder::GetClassID(
    LPCLSID lpClassID
    )
/*++

    IPersist::GetClassID

--*/
{
    *lpClassID = CLSID_PStoreNameSpace;

    return S_OK;
}


STDMETHODIMP
CShellFolder::Initialize(
    LPCITEMIDLIST pidl
    )
/*++

    IPersistFolder::Initialize

--*/
{
    return S_OK;
}



STDMETHODIMP
CShellFolder::BindToObject(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID *ppvOut
    )
/*++

    Creates an IShellFolder object for a subfolder.

--*/
{
    CShellFolder   *pShellFolder;

    pShellFolder = new CShellFolder(this, pidl);
    if(pShellFolder == NULL)
        return E_OUTOFMEMORY;

    HRESULT  hr = pShellFolder->QueryInterface(riid, ppvOut);

    pShellFolder->Release();

    return hr;
}

STDMETHODIMP
CShellFolder::CompareIDs(
    LPARAM lParam,
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
/*++
    Determines the relative ordering of two file objects or folders,
    given their item identifier lists.

    Returns a handle to a result code. If this method is successful,
    the CODE field of the status code (SCODE) has the following meaning:

    Less than zero      The first item should precede the second (pidl1 < pidl2).
    Greater than zero   The first item should follow the second (pidl1 > pidl2)
    Zero                The two items are the same (pidl1 = pidl2).

    Passing 0 as the lParam indicates sort by name.
    0x00000001-0x7fffffff are for folder specific sorting rules.
    0x80000000-0xfffffff are used by the system.

--*/
{
    LPCWSTR szString1;
    LPCWSTR szString2;
    DWORD cbLength1;
    DWORD cbLength2;
    DWORD dwCompare;

    //
    // compare strings first, then GUID if equality is encountered
    // this is important because we do not want to return a value indicating
    // equality based on display string only; we also want to account for the
    // GUID associated with the display name, since we can have multiple GUIDs
    // with the same display name.  If we just compared the string values,
    // the shell would not display all types/subtypes.
    //

    szString1 = GetPidlText(pidl1);
    szString2 = GetPidlText(pidl2);

    cbLength1 = lstrlenW(szString1) ;
    cbLength2 = lstrlenW(szString2) ;

    //
    // check via shortest length string
    //

    if(cbLength2 < cbLength1)
        cbLength1 = cbLength2;

    cbLength1 *= sizeof(WCHAR);

    dwCompare = memcmp(szString1, szString2, cbLength1);

    if(dwCompare == 0) {
        GUID *guid1;
        GUID *guid2;

        //
        // now compare the GUIDs.
        //

        guid1 = GetPidlGuid(pidl1);
        guid2 = GetPidlGuid(pidl2);

        dwCompare = memcmp(guid1, guid2, sizeof(GUID));
    }

    //
    // still equal? sort by PST_KEY_CURRENT_USER, then PST_KEY_LOCAL_MACHINE
    //

	if(dwCompare == 0) {
    	dwCompare = GetPidlKeyType(pidl1) - GetPidlKeyType(pidl2);
	}

    return ResultFromDWORD(dwCompare);
}


STDMETHODIMP
CShellFolder::CreateViewObject(
    HWND hwndOwner,
    REFIID riid,
    LPVOID *ppvOut
    )
/*++

    CreateViewWindow creates a view window. This can be either the right pane
    of the Explorer or the client window of a folder window.

--*/
{
    HRESULT     hr;
    CShellView  *pShellView;

    pShellView = new CShellView(this, m_pidl);
    if(pShellView == NULL)
        return E_OUTOFMEMORY;

    hr = pShellView->QueryInterface(riid, ppvOut);

    pShellView->Release();

    return hr;
}

STDMETHODIMP
CShellFolder::EnumObjects(
    HWND hwndOwner,
    DWORD dwFlags,
    LPENUMIDLIST *ppEnumIDList
    )
/*++
    Determines the contents of a folder by creating an item enumeration
    object (a set of item identifiers) that can be retrieved using the
    IEnumIDList interface.

--*/
{
    *ppEnumIDList = new CEnumIDList(m_pidl, FALSE);
    if(*ppEnumIDList == NULL)
        return E_FAIL;

    return NOERROR;
}


STDMETHODIMP
CShellFolder::GetAttributesOf(
    UINT uCount,
    LPCITEMIDLIST aPidls[],
    ULONG *pulAttribs
    )
/*++
    Retrieves the attributes of one or more file objects or subfolders.

    Builds a ULONG value that specifies the common (logically AND'ed)
    attributes of specified file objects, which is supplied to the caller
    via the pdwAttribs parameter.

--*/
{
    UINT  i;

    *pulAttribs = (ULONG)-1; // assume all in common initially

    for(i = 0; i < uCount; i++)
    {
        DWORD dwSubFolder = SFGAO_CANDELETE | SFGAO_HASPROPSHEET;

        if(HasSubFolders(aPidls[i]))
            dwSubFolder |= SFGAO_HASSUBFOLDER;

        *pulAttribs &= (SFGAO_FOLDER | dwSubFolder);
    }

    return NOERROR;
}

BOOL
CShellFolder::HasSubFolders(
    LPCITEMIDLIST pidl
    )
/*++

    This function is used to test if the specified pidl has subfolders.

    The combination of this->m_pidl and the supplied pidl can be used
    to make this determination.

--*/
{
    //
    // If we are at the subtype level, then no subfolders exist
    //

    if(GetPidlType(pidl) >= PIDL_TYPE_SUBTYPE)
        return FALSE;

    //
    // TODO: is there anyway to check if the root has subfolders?
    // m_pidl == NULL or pidl == NULL ???
    // then try to enum providers.
    //


	//
	// make a fully qualified (absolute) pidl out of m_pidl and pidl,
	// then call the enum interface to see if subfolders exist.
	//

	LPITEMIDLIST pidlNew = CopyCatPidl(m_pidl, pidl);
	if(pidlNew == NULL)
		return FALSE;

	BOOL bSubfolder = FALSE;

    LPENUMIDLIST pEnumIDList = new CEnumIDList(pidlNew, FALSE);
    if(pEnumIDList != NULL) {

	    ULONG ulFetched;
    	LPITEMIDLIST pidl = NULL;

		if( NOERROR == pEnumIDList->Next(1, &pidl, &ulFetched) && ulFetched == 1) {
			FreePidl(pidl);
			bSubfolder = TRUE;	
		}

		pEnumIDList->Release();
	}

	FreePidl(pidlNew);

	return bSubfolder;
}


STDMETHODIMP
CShellFolder::GetDisplayNameOf(
    LPCITEMIDLIST pidl,
    DWORD dwFlags,
    LPSTRRET lpName
    )
/*++
    Retrieves the display name for the specified file object or subfolder,
    returning it in a STRRET structure.

    If the ID contains the display name (in the local character set),
    it returns the offset to the name. If not, it returns a pointer to
    the display name string (UNICODE) allocated by the task allocator,
    or it fills in a buffer. The type of string returned depends on the
    type of display specified.

    Values identifying different types of display names are contained
    in the enumeration SHGNO.

--*/
{
    switch(dwFlags)
    {
        case SHGDN_NORMAL:
        case SHGDN_INFOLDER:
        case SHGDN_FORPARSING:
        {
            LPCWSTR szDisplay;
            DWORD cbDisplay;
            LPWSTR pOleStr;

            szDisplay = GetPidlText(pidl);
            cbDisplay = (lstrlenW(szDisplay) + 1) * sizeof(WCHAR);

            pOleStr = (LPWSTR)CoTaskMemAlloc(cbDisplay);
            if(pOleStr == NULL)
                return E_OUTOFMEMORY;

            CopyMemory(pOleStr, szDisplay, cbDisplay);

            lpName->uType = STRRET_WSTR;
            lpName->pOleStr = pOleStr;

            return NOERROR;
        }

        default:
            return E_INVALIDARG;
    }
}




BOOL
CShellFolder::GetPidlFullText(
    LPCITEMIDLIST pidl,
    LPTSTR lpszOut,
    DWORD dwOutSize
    )
/*++
    This function returns a string containing the full-text associated with
    the supplied pidl.  The full text will consist of a "full path" string,
    similiar to a fully qualified directory entry.

--*/
{


    return FALSE;
}



STDMETHODIMP
CShellFolder::BindToStorage(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID *ppvOut
    )
/*++
    ...Reserved for a future use. This method should return E_NOTIMPL. ...

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CShellFolder::GetUIObjectOf(
    HWND hwndOwner,
    UINT cidl,
    LPCITEMIDLIST *pPidl,
    REFIID riid,
    LPUINT puReserved,
    LPVOID *ppvReturn
    )
/*++
    Creates a COM object that can be used to carry out actions on the
    specified file objects or folders, typically, to create context menus
    or carry out drag-and-drop operations.

--*/
{
    *ppvReturn = NULL;

    if(IsEqualIID(riid, IID_IExtractIcon)) {
        if(cidl != 1)
            return E_INVALIDARG;
        *ppvReturn = (IExtractIcon*)( new CExtractIcon( pPidl[0] ) );
    }
    else if(IsEqualIID(riid, IID_IContextMenu)) {
        if(cidl == 0)
            return E_INVALIDARG;
    }
    else if(IsEqualIID(riid, IID_IDataObject)) {
        if(cidl == 0)
            return E_INVALIDARG;
    }

    if(*ppvReturn == NULL)
        return E_NOINTERFACE;

    (*(LPUNKNOWN*)ppvReturn)->AddRef();
    return NOERROR;
}




STDMETHODIMP
CShellFolder::ParseDisplayName(
    HWND hwndOwner,
    LPBC pbcReserved,
    LPOLESTR lpDisplayName,
    LPDWORD pdwEaten,
    LPITEMIDLIST *pPidlNew,
    LPDWORD pdwAttributes
    )
{
    return E_NOTIMPL;
}


STDMETHODIMP
CShellFolder::SetNameOf(
    HWND hwndOwner,
    LPCITEMIDLIST pidl,
    LPCOLESTR lpName,
    DWORD dw,
    LPITEMIDLIST *pPidlOut
    )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\shview.cpp ===
/*++

    Implements IShellView.

--*/

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <shlobj.h>

#include <docobj.h>
#include <shellapi.h>

#include "pstore.h"

#include "shfolder.h"

#include "shview.h"
#include "guid.h"
#include "resource.h"
#include "tools.h"

#include "utility.h"
#include "enumid.h"


#include "listu.h"


extern HINSTANCE  g_hInst;
extern LONG       g_DllRefCount;



BOOL
AddListItem(
    HWND hWnd,
    DWORD dwType,
    PST_KEY KeyType,
    LPCWSTR szName,
    LPITEMIDLIST pidl
    );



#define TOOLBAR_ID   (L"TBar")
#define INITIAL_COLUMN_POS 100

MYTOOLINFO g_Buttons[] =
   {
   IDM_MESSAGE1, 0, IDS_TB_MESSAGE1, IDS_MI_MESSAGE1, TBSTATE_ENABLED, TBSTYLE_BUTTON,
   IDM_MESSAGE2, 0, IDS_TB_MESSAGE2, IDS_MI_MESSAGE2, TBSTATE_ENABLED, TBSTYLE_BUTTON,
   -1, 0, 0, 0, 0,
   };


CShellView::CShellView(
    CShellFolder *pFolder,
    LPCITEMIDLIST pidl
    )
{

    m_hMenu = NULL;
    ZeroMemory(&m_MenuWidths, sizeof(m_MenuWidths));

    m_nColumn1 = INITIAL_COLUMN_POS;
    m_nColumn2 = INITIAL_COLUMN_POS;

    m_pSFParent = pFolder;
    if(m_pSFParent)
        m_pSFParent->AddRef();

    m_pidl = (LPITEMIDLIST)pidl;

    m_uState = SVUIA_DEACTIVATE;

    m_ObjRefCount = 1;
    InterlockedIncrement(&g_DllRefCount);
}


CShellView::~CShellView()
{
    if(m_pSFParent)
        m_pSFParent->Release();

    InterlockedDecrement(&g_DllRefCount);
}


STDMETHODIMP
CShellView::QueryInterface(
    REFIID riid,
    LPVOID *ppReturn
    )
/*++

    IUnknown::QueryInterface

--*/
{
    *ppReturn = NULL;

    if(IsEqualIID(riid, IID_IUnknown))
        *ppReturn = (IUnknown*)(IShellView*)this;
    else if(IsEqualIID(riid, IID_IOleWindow))
        *ppReturn = (IOleWindow*)this;
    else if(IsEqualIID(riid, IID_IShellView))
        *ppReturn = (CShellView*)this;
    else if(IsEqualIID(riid, IID_IOleCommandTarget))
        *ppReturn = (IOleCommandTarget*)this;

    if(*ppReturn == NULL)
        return E_NOINTERFACE;

    (*(LPUNKNOWN*)ppReturn)->AddRef();
    return S_OK;
}


STDMETHODIMP_(DWORD)
CShellView::AddRef()
/*++

    IUnknown::AddRef

--*/
{
    return InterlockedIncrement(&m_ObjRefCount);
}


STDMETHODIMP_(DWORD)
CShellView::Release()
/*++

    IUnknown::Release

--*/
{
    LONG lDecremented = InterlockedDecrement(&m_ObjRefCount);

    if(lDecremented == 0)
        delete this;

    return lDecremented;
}


STDMETHODIMP
CShellView::GetWindow(
    HWND *phWnd
    )
/*++

    IOleWindow::GetWindow

--*/
{
    *phWnd = m_hWnd;

    return S_OK;
}


STDMETHODIMP
CShellView::ContextSensitiveHelp(
    BOOL fEnterMode
    )
/*++

   Inherited from IOleWindow::ContextSensitiveHelp.

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CShellView::QueryStatus(
    const GUID *pguidCmdGroup,
    ULONG cCmds,
    OLECMD prgCmds[],
    OLECMDTEXT *pCmdText
    )
/*++

    IOleCommandTarget::QueryStatus

--*/
{
    ULONG i;

    //
    // only process the commands for our command group
    //

    if(pguidCmdGroup && (*pguidCmdGroup != CLSID_CmdGrp))
        return OLECMDERR_E_UNKNOWNGROUP;

    //
    // make sure prgCmds is not NULL
    //

    if(prgCmds == NULL)
        return E_POINTER;

    //
    // run through all of the commands and supply the correct information
    //

    for(i = 0; i < cCmds;i++)
    {
        switch(prgCmds[i].cmdID)
        {
            case IDM_MESSAGE1:
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                break;

            case IDM_MESSAGE2:
                prgCmds[i].cmdf = OLECMDF_SUPPORTED | OLECMDF_ENABLED;
                break;
        }
    }

    return S_OK;
}


STDMETHODIMP
CShellView::Exec(
    const GUID *pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdExecOpt,
    VARIANTARG *pvaIn,
    VARIANTARG *pvaOut
    )
/*++

    IOleCommandTarget::Exec

--*/
{
    //
    // only process the commands for our command group
    //

    if(pguidCmdGroup && (*pguidCmdGroup == CLSID_CmdGrp))
    {
        OnCommand(nCmdID, 0, NULL);
        return S_OK;
    }

    return OLECMDERR_E_UNKNOWNGROUP;
}


STDMETHODIMP
CShellView::TranslateAccelerator(
    LPMSG pMsg
    )
/*++

  Same as the IOleInPlaceFrame::TranslateAccelerator, but will be
  never called because we don't support EXEs (i.e., the explorer has
  the message loop). This member function is defined here for possible
  future enhancement.

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CShellView::EnableModeless(
    BOOL fEnable
    )
/*++

   Same as the IOleInPlaceFrame::EnableModeless.

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CShellView::UIActivate(
    UINT uState
    )
/*++

    IShellView::UIActivate

--*/
{
    //
    // don't do anything if the state isn't really changing
    //

    if(m_uState == uState)
        return S_OK;

    //
    // Always do this because we will cause problems if we are going from
    // SVUIA_ACTIVATE_FOCUS to SVUIA_ACTIVATE_NOFOCUS or vice versa.
    //

    m_uState = SVUIA_DEACTIVATE;

    m_pShellBrowser->SetMenuSB(NULL, NULL, NULL);

    if(m_hMenu) {
        DestroyMenu(m_hMenu);
        m_hMenu = NULL;
    }

    //
    // only do this if we are active
    //

    if(uState != SVUIA_DEACTIVATE) {
        m_uState = uState;

        //
        // update the Explorer's menu
        //

        if(m_hMenu == NULL)
            m_hMenu = CreateMenu();

        if(m_hMenu) {
            MENUITEMINFO   mii;
            TCHAR szText[MAX_PATH];

            m_pShellBrowser->InsertMenusSB(m_hMenu, &m_MenuWidths);

            //
            // get the menu item's text
            //
            LoadString(g_hInst, IDS_MI_REGISTRY, szText, sizeof(szText));

            //
            // build our menu
            //

            ZeroMemory(&mii, sizeof(mii));
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE;
            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED;
            mii.dwTypeData = szText;
            mii.hSubMenu = BuildMenu();

            //
            // insert our menu
            //

            InsertMenuItem(m_hMenu, FCIDM_MENU_HELP, FALSE, &mii);

            m_pShellBrowser->SetMenuSB(m_hMenu, NULL, m_hWnd);
        }

        //
        // TODO: update the status bar
        //

/*

        TCHAR szName[MAX_PATH];

        LoadString(g_hInst, IDS_PSTORE_TITLE, szName, sizeof(szName));

        m_pSFParent->GetPidlFullText(m_pidl, szName + lstrlen(szName), sizeof(szName) - lstrlen(szName));

        LRESULT  lResult;
        int      nPartArray[1] = {-1};

        //set the number of parts
        m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETPARTS, 1, (LPARAM)nPartArray, &lResult);

        //set the text for the parts
        m_pShellBrowser->SendControlMsg(FCW_STATUS, SB_SETTEXT, 0, (LPARAM)szName, &lResult);

 */
    }

    return S_OK;
}


HMENU
CShellView::BuildMenu(
    void
    )
{
    HMENU hSubMenu = CreatePopupMenu();

    if(hSubMenu == NULL)
        return NULL;

    TCHAR          szText[MAX_PATH];
    MENUITEMINFO   mii;
    int            nButtons, i;

    //
    // get the number of items in our global array
    //

    for(nButtons = 0; g_Buttons[nButtons].idCommand != -1; nButtons++) {
        ;
    }

    //
    // add the menu items
    //

    for(i = 0; i < nButtons; i++) {

        LoadString(g_hInst, g_Buttons[i].idMenuString, szText, sizeof(szText));

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;

        if(TBSTYLE_SEP != g_Buttons[i].bStyle) {

            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED;
            mii.dwTypeData = szText;
            mii.wID = g_Buttons[i].idCommand;
        } else {
            mii.fType = MFT_SEPARATOR;
        }

        //
        // tack this item onto the end of the menu
        //

        InsertMenuItem(hSubMenu, (UINT)-1, TRUE, &mii);
    }

    //
    // add a couple more that aren't in the button array
    //

    LoadString(g_hInst, IDS_MI_VIEW_ISTB, szText, sizeof(szText));

    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;
    mii.dwTypeData = szText;
    mii.wID = IDM_VIEW_ISTB;

    //
    // tack this item onto the end of the menu
    //

    InsertMenuItem(hSubMenu, (UINT)-1, TRUE, &mii);

    LoadString(g_hInst, IDS_MI_VIEW_IETB, szText, sizeof(szText));

    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
    mii.fType = MFT_STRING;
    mii.fState = MFS_ENABLED;
    mii.dwTypeData = szText;
    mii.wID = IDM_VIEW_IETB;

    //
    // tack this item onto the end of the menu
    //

    InsertMenuItem(hSubMenu, (UINT)-1, TRUE, &mii);

    return hSubMenu;
}


STDMETHODIMP
CShellView::Refresh(
    void
    )
/*++

    IShellView::Refresh

--*/
{
    //
    // empty the list
    //

    ListView_DeleteAllItems(m_hwndList);

    //
    // refill the list
    //

    FillList();

    return S_OK;
}

STDMETHODIMP
CShellView::CreateViewWindow(
    LPSHELLVIEW pPrevView,
    LPCFOLDERSETTINGS lpfs,
    LPSHELLBROWSER psb,
    LPRECT prcView,
    HWND *phWnd
    )
/*++

    CreateViewWindow creates a view window. This can be either the right pane
    of the Explorer or the client window of a folder window.

--*/
{
    WNDCLASS wc;

    *phWnd = NULL;

    //
    // if our window class has not been registered, then do so
    //

    if(!GetClassInfo(g_hInst, NS_CLASS_NAME, &wc)) {

        ZeroMemory(&wc, sizeof(wc));
        wc.style          = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc    = WndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;
        wc.hInstance      = g_hInst;
        wc.hIcon          = NULL;
        wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = NS_CLASS_NAME;

        if(!RegisterClass(&wc))
            return E_FAIL;
    }

    //
    // set up the member variables
    //

    m_pShellBrowser = psb;
    m_FolderSettings.ViewMode = lpfs->ViewMode;
    m_FolderSettings.fFlags = lpfs->fFlags;

    //
    // get our parent window
    //

    m_pShellBrowser->GetWindow(&m_hwndParent);

    GetSettings();

    *phWnd = CreateWindowEx(   0,
                               NS_CLASS_NAME,
                               NULL,
                               WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                               prcView->left,
                               prcView->top,
                               prcView->right - prcView->left,
                               prcView->bottom - prcView->top,
                               m_hwndParent,
                               NULL,
                               g_hInst,
                               (LPVOID)this);

    if(*phWnd == NULL)
        return E_FAIL;

    //
    // addref the IShellBrowser interface to allow communication with Explorer
    //

    m_pShellBrowser->AddRef();

    return S_OK;
}


STDMETHODIMP
CShellView::DestroyViewWindow(
    void
    )
/*++

    The Explorer calls this method when a folder window or the Explorer
    is being closed.

--*/
{
    if(m_hMenu)
        DestroyMenu(m_hMenu);

    DestroyWindow(m_hWnd);

    //
    // release the shell browser object
    //

    m_pShellBrowser->Release();

    return S_OK;
}

STDMETHODIMP
CShellView::GetCurrentInfo(
    LPFOLDERSETTINGS lpfs
    )
/*++

    The Explorer uses GetCurrentInfo to query the view for standard settings.

--*/
{
// TODO, check proper approach.

    *lpfs = m_FolderSettings;
//    lpfs->ViewMode = m_FolderSettings.ViewMode;
//    lpfs->fFlags = m_FolderSettings.fFlags;

    return NOERROR;
}


STDMETHODIMP
CShellView::AddPropertySheetPages(
    DWORD dwReserved,
    LPFNADDPROPSHEETPAGE lpfn,
    LPARAM lParam
    )
/*++
    The Explorer calls this method when it is opening the View.Options...
    property sheet. Views can add pages by creating them and calling the
    callback function with the page handles.
--*/
{
    OutputDebugStringA("IShellView::AddPropertySheetPages\n");
    return E_NOTIMPL;
}



STDMETHODIMP
CShellView::SaveViewState(
    void
    )
/*++

    IShellView::SaveViewState

--*/
{
    SaveSettings();
    return S_OK;
}


STDMETHODIMP
CShellView::SelectItem(
    LPCITEMIDLIST pidlItem,
    UINT uFlags
    )
/*++

    IShellView::SelectItem

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CShellView::GetItemObject(
    UINT uItem,
    REFIID riid,
    LPVOID *ppvOut
    )
/*++

    Used by the common dialogs to get the selected items from the view.

--*/
{
    return E_NOTIMPL;
}



LRESULT
CALLBACK
CShellView::WndProc(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CShellView  *pThis = (CShellView*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMessage)
    {
        case WM_NCCREATE:
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
            pThis = (CShellView*)(lpcs->lpCreateParams);
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM)pThis);

            //set the window handle
            pThis->m_hWnd = hWnd;
            break;
        }

        case WM_SIZE:
            return pThis->OnSize(LOWORD(lParam), HIWORD(lParam));

        case WM_CREATE:
            return pThis->OnCreate();

        case WM_SETFOCUS:
            return pThis->OnSetFocus();

        case WM_ACTIVATE:
            return pThis->OnActivate(wParam, lParam);

        case WM_COMMAND:
            return pThis->OnCommand( GET_WM_COMMAND_ID(wParam, lParam),
                                     GET_WM_COMMAND_CMD(wParam, lParam),
                                     GET_WM_COMMAND_HWND(wParam, lParam));

        case WM_INITMENUPOPUP:
            return pThis->UpdateMenu((HMENU)wParam);

        case WM_NOTIFY:
            return pThis->OnNotify((UINT)wParam, (LPNMHDR)lParam);
    }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}


LRESULT
CShellView::OnSetFocus(
    void
    )
{
    //
    // tell the browser we got the focus
    //

    m_pShellBrowser->OnViewWindowActive(this);

    return 0;
}


LRESULT
CShellView::OnActivate(
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    // tell the browser we got the focus
    //

    if(wParam)
        m_pShellBrowser->OnViewWindowActive(this);

    return 0;
}


LRESULT
CShellView::OnCommand(
    DWORD dwCmdID,
    DWORD dwCmd,
    HWND hwndCmd
    )
{
    switch(dwCmdID)
    {
       case IDM_MESSAGE1:
            MessageBox(m_hWnd, TEXT("Message 1 was selected"), TEXT("Notice"), MB_OK | MB_ICONEXCLAMATION);
            break;

       case IDM_MESSAGE2:
            MessageBox(m_hWnd, TEXT("Message 2 was selected"), TEXT("Notice"), MB_OK | MB_ICONEXCLAMATION);
            break;

        case IDM_VIEW_ISTB:
            m_bShowISTB = ! m_bShowISTB;
            UpdateToolbar();
            break;

        case IDM_VIEW_IETB:
            m_bShowIETB = ! m_bShowIETB;
            UpdateToolbar();
            break;
    }

    return 0;
}


HRESULT
CShellView::SaveSettings(
    void
    )
/*++

    Called by IShellView::SaveViewState to store the relevant setting data
    to the browser stream.

--*/
{
    HRESULT  hr;
    LPSTREAM pStream;

    hr = m_pShellBrowser->GetViewStateStream(STGM_WRITE, &pStream);

    if(SUCCEEDED(hr))
    {
        ULONG uWritten;

        pStream->Write(&m_bShowISTB, sizeof(m_bShowISTB), &uWritten);
        pStream->Write(&m_bShowIETB, sizeof(m_bShowIETB), &uWritten);
        pStream->Write(&m_nColumn1, sizeof(m_nColumn1), &uWritten);
        pStream->Write(&m_nColumn2, sizeof(m_nColumn2), &uWritten);

        pStream->Release();
    }

    return hr;
}


HRESULT
CShellView::GetSettings(
    void
    )
{
    HRESULT  hr;
    LPSTREAM pStream;

    hr = m_pShellBrowser->GetViewStateStream(STGM_READ, &pStream);

    if(SUCCEEDED(hr)) {

        ULONG uRead;

        if(S_OK != pStream->Read(&m_bShowISTB, sizeof(m_bShowISTB), &uRead))
            m_bShowISTB = FALSE;

        if(S_OK != pStream->Read(&m_bShowIETB, sizeof(m_bShowIETB), &uRead))
            m_bShowIETB = FALSE;

        if(S_OK != pStream->Read(&m_nColumn1, sizeof(m_nColumn1), &uRead))
            m_nColumn1 = INITIAL_COLUMN_POS;

        if(S_OK != pStream->Read(&m_nColumn2, sizeof(m_nColumn2), &uRead))
            m_nColumn2 = INITIAL_COLUMN_POS;

        pStream->Release();
    }

    return hr;
}

LRESULT
CShellView::UpdateMenu(
    HMENU hMenu
    )
{
    return 0;
}


void
CShellView::UpdateToolbar()
{
    // nothing to update yet
}


LRESULT
CShellView::OnNotify(
    UINT CtlID,
    LPNMHDR pNotify
    )
{
    LPNM_LISTVIEW pNotifyLV = (LPNM_LISTVIEW)pNotify;
    LV_DISPINFO *pNotifyDI = (LV_DISPINFO *)pNotify;
    LPTBNOTIFY pNotifyTB = (LPTBNOTIFY)pNotify;
    LPTOOLTIPTEXT pNotifyTT = (LPTOOLTIPTEXT)pNotify;

    switch(pNotify->code)
    {

		//
		// HDN_BEGINTRACK
		// HDN_DIVIDERDBLCLICK
		// HDN_ENDTRACK
		// HDN_ITEMCHANGED
		// HDN_ITEMCHANGING
		// HDN_ITEMCLICK
		// HDN_ITEMDBLCLICK
		// HDN_TRACK
		//

        case HDN_ENDTRACK:
        {
            m_nColumn1 = ListView_GetColumnWidth(m_hwndList, 0);
            m_nColumn2 = ListView_GetColumnWidth(m_hwndList, 1);

            break;
        }
		
		//
		// LVN_BEGINDRAG
		// LVN_BEGINLABELEDIT
		// LVN_BEGINRDRAG
		// LVN_COLUMNCLICK
		// LVN_DELETEALLITEMS
		// LVN_DELETEITEM
		// LVN_ENDLABELEDIT
		// LVN_GETDISPINFO
		// LVN_INSERTITEM
		// LVN_ITEMCHANGED
		// LVN_ITEMCHANGING
		// LVN_KEYDOWN
		// LVN_SETDISPINFO
		//

        case LVN_DELETEITEM:
        {
            LPITEMIDLIST pidl = (LPITEMIDLIST)(pNotifyLV->lParam);

            //
            // free the memory for the pidl associated with this item.
            //

            if(pidl != NULL)
                FreePidl(pidl);

            break;
        }

		// NM_CLICK
		// NM_DBLCLK
		// NM_KILLFOCUS
		// NM_LISTVIEW
		// NM_OUTOFMEMORY
		// NM_RCLICK
		// NM_RDBLCLK
		// NM_RETURN
		// NM_SETFOCUS
		// NM_TREEVIEW
		// NM_UPDOWN
		//

		case NM_RETURN:
		case NM_DBLCLK:
		{
            UINT wFlags = SBSP_RELATIVE | SBSP_DEFMODE;
            int iItem = -1;

            //
            // if we are in explorer mode, start out in DEFBROWSER mode,
            // otherwise, start in NEWBROWSER mode.
            //

            HWND hwnd = NULL;
            m_pShellBrowser->GetControlWindow(FCW_TREE, &hwnd);

            if(hwnd != NULL) {
                wFlags |= SBSP_DEFBROWSER;
            } else {
                wFlags |= SBSP_NEWBROWSER;
            }


			//
			// loop through all the selected items.
			// TODO: if more than two are selected, we only get to view
            // two.
			//
			 
            do {
	            LV_ITEM item;

				iItem = ListView_GetNextItem(m_hwndList, iItem, LVNI_SELECTED | LVNI_ALL);
				ZeroMemory(&item, sizeof(item));
				item.mask = LVIF_PARAM;
				item.iItem = iItem;

				if(!ListView_GetItem(m_hwndList, &item))
					break;

	            LPCITEMIDLIST pidl = (LPCITEMIDLIST)(item.lParam);
				
	            if(pidl != NULL) {
				
					//
					// don't browse into items.
					//

					if(GetLastPidlType(pidl) > PIDL_TYPE_SUBTYPE)
						break;

					m_pShellBrowser->BrowseObject(pidl, wFlags);
				}
				
				//
				// if multiple items selected, bring up a new browser
				//

				wFlags &= ~SBSP_DEFBROWSER;
				wFlags |= SBSP_NEWBROWSER;
            } while (iItem != -1);

		}

		//
		// TBN_BEGINADJUST
		// TBN_BEGINDRAG
		// TBN_CUSTHELP
		// TBN_ENDADJUST
		// TBN_ENDDRAG
		// TBN_GETBUTTONINFO
		// TBN_QUERYDELETE
		// TBN_QUERYINSERT
		// TBN_RESET
		// TBN_TOOLBARCHANGE
		//

        case TBN_BEGINDRAG:
        default:
            return 0;
    }

    return 0;
}


LRESULT
CShellView::OnSize(
    WORD wWidth,
    WORD wHeight
    )
{
    //
    // resize the ListView to fit our window
    //

    if(m_hwndList)
        MoveWindow(m_hwndList, 0, 0, wWidth, wHeight, TRUE);

    return 0;
}


LRESULT
CShellView::OnCreate(
    void
    )
{
    //
    // create the ListView
    //

    if(CreateList())
    {
        if(InitList())
        {
            FillList();
        }
    }

    return 0;
}


BOOL
CShellView::CreateList(
    void
    )
{
    DWORD dwStyle;

    //
    // fetch the prior listview style and use
    // that as the new listview style.
    //


    switch (m_FolderSettings.ViewMode) {
        case FVM_ICON:
            dwStyle = LVS_ICON;
            break;
        case FVM_SMALLICON:
            dwStyle = LVS_SMALLICON;
            break;
        case FVM_LIST:
            dwStyle = LVS_LIST;
            break;
        case FVM_DETAILS:
            dwStyle = LVS_REPORT;
            break;
        default:
            dwStyle = LVS_ICON;
            break;
    }

    m_hwndList = CreateWindowEx(
                        WS_EX_CLIENTEDGE,
                        WC_LISTVIEW,
                        NULL,
                        WS_TABSTOP |
                        WS_VISIBLE |
                        WS_CHILD |
                        WS_BORDER |
                        LVS_SORTASCENDING |
                        dwStyle |
                        LVS_NOSORTHEADER |
                        0,
                        0,
                        0,
                        0,
                        0,
                        m_hWnd,
                        (HMENU)ID_LISTVIEW,
                        g_hInst,
                        NULL
                        );

    return (BOOL)(NULL != m_hwndList);
}


BOOL
CShellView::InitList(
    void
    )
{
    LV_COLUMN   lvColumn;
    HIMAGELIST  himlSmall;
    HIMAGELIST  himlLarge;
    RECT        rc;
    TCHAR       szString[MAX_PATH];

    //
    // empty the list
    //

    ListView_DeleteAllItems(m_hwndList);

    //
    // initialize the columns
    //

    lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.pszText = szString;

    lvColumn.cx = m_nColumn1;
    LoadString(g_hInst, IDS_COLUMN1, szString, sizeof(szString));
    ListView_InsertColumn(m_hwndList, 0, &lvColumn);

    GetClientRect(m_hWnd, &rc);

    lvColumn.cx = m_nColumn2;
    LoadString(g_hInst, IDS_COLUMN2, szString, sizeof(szString));
    ListView_InsertColumn(m_hwndList, 1, &lvColumn);

	int cxSmall;
	int cySmall;
	int cxLarge;
	int cyLarge;

	SHFILEINFO sfi;
	HIMAGELIST himl;

	//
	// get large and small icon size info from shell
	//

	himl = (HIMAGELIST)SHGetFileInfo(
			NULL,
			0,
			&sfi,
			sizeof(sfi),
			SHGFI_LARGEICON | SHGFI_SYSICONINDEX
			);

	if(!ImageList_GetIconSize(himl, &cxLarge, &cyLarge)) {
    	cxLarge = GetSystemMetrics(SM_CXICON);
    	cyLarge = GetSystemMetrics(SM_CYICON);
	}

	himl = (HIMAGELIST)SHGetFileInfo(
			NULL,
			0,
			&sfi,
			sizeof(sfi),
			SHGFI_SMALLICON | SHGFI_SYSICONINDEX
			);

	if(!ImageList_GetIconSize(himl, &cxSmall, &cySmall)) {
    	cxSmall = GetSystemMetrics(SM_CXSMICON);
    	cySmall = GetSystemMetrics(SM_CYSMICON);
	}


    //
    // Create the full-sized and small icon image lists.
    //

    himlLarge = ImageList_Create(
            cxLarge,
            cyLarge,
            ILC_COLORDDB | ILC_MASK,
            4,  // initial image count
            0
            );

    himlSmall = ImageList_Create(
            cxSmall,
            cySmall,
            ILC_COLORDDB | ILC_MASK,
            4,  // initial image count
            0
            );

    //
    // Add icons to each image list.
	// TODO cache icons
    //

    HICON hIconSmall;
	HICON hIconLarge;

    // icon 0: Provider icon

    hIconSmall = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_PROVIDER), IMAGE_ICON, cxSmall, cySmall, LR_DEFAULTCOLOR | LR_SHARED);
    hIconLarge = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_PROVIDER), IMAGE_ICON, cxLarge, cyLarge, LR_DEFAULTCOLOR | LR_SHARED);

    ImageList_AddIcon(himlSmall, hIconSmall);
    ImageList_AddIcon(himlLarge, hIconLarge);


    // icon 1: type icon

    hIconSmall = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_FOLDER), IMAGE_ICON, cxSmall, cySmall, LR_DEFAULTCOLOR | LR_SHARED);
    hIconLarge = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_FOLDER), IMAGE_ICON, cxLarge, cyLarge, LR_DEFAULTCOLOR | LR_SHARED);

    ImageList_AddIcon(himlSmall, hIconSmall);
    ImageList_AddIcon(himlLarge, hIconLarge);

    // icon 2: item icon

    hIconSmall = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_ITEM), IMAGE_ICON, cxSmall, cySmall, LR_DEFAULTCOLOR | LR_SHARED);
    hIconLarge = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_ITEM), IMAGE_ICON, cxLarge, cyLarge, LR_DEFAULTCOLOR | LR_SHARED);

    ImageList_AddIcon(himlSmall, hIconSmall);
    ImageList_AddIcon(himlLarge, hIconLarge);

    // icon 3: global type

    hIconSmall = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_GLOBAL), IMAGE_ICON, cxSmall, cySmall, LR_DEFAULTCOLOR | LR_SHARED);
    hIconLarge = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_GLOBAL), IMAGE_ICON, cxLarge, cyLarge, LR_DEFAULTCOLOR | LR_SHARED);

    ImageList_AddIcon(himlSmall, hIconSmall);
    ImageList_AddIcon(himlLarge, hIconLarge);


    //
    // Assign the image lists to the list view control.
    //

    ListView_SetImageList(m_hwndList, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(m_hwndList, himlSmall, LVSIL_SMALL);

    return TRUE;
}

BOOL
CShellView::FillList(
    void
    )
{
    LPENUMIDLIST pEnumIDList;
    ULONG ulFetched;
    LPITEMIDLIST pidl = NULL;

    pEnumIDList = new CEnumIDList(m_pidl, TRUE);
    if(pEnumIDList == NULL)
        return FALSE;

    //
    // enumerate the sub folders or items, based on the parent m_pidl.
    // note that storage is allocated for the pidlNew, which is a copy
    // of the current path + pidl - that storage is later freed during
    // the processing of LVN_DELETEITEM
    //

    while( NOERROR == pEnumIDList->Next(1, &pidl, &ulFetched) ) {

        LPCWSTR szText = GetPidlText(pidl);
        PST_KEY KeyType = GetPidlKeyType(pidl);
        DWORD dwPidlType = GetPidlType(pidl);

        //
        // make a fully qualified (absolute) pidl
        //

//        LPITEMIDLIST pidlNew = CopyCatPidl(m_pidl, pidl);

        //
        // free pidl associated with Next enumeration
        //

//        FreePidl(pidl);

        //
        // add item with absolute pidl to listview
        //

        AddListItem(m_hwndList, dwPidlType, KeyType, szText, pidl);
    }

    pEnumIDList->Release();

    return TRUE;
}

BOOL
AddListItem(
    HWND hWnd,
    DWORD dwType,
    PST_KEY KeyType,
    LPCWSTR szName,
    LPITEMIDLIST pidl
    )
/*++

    This function is a temporary hack to support image list add/set data.

    This will be replaced by an Unicode interface that operates on WinNT and
    Win95 in the near future.

--*/
{
    LVITEM lvItem;
    int nIndex;

    DWORD dwIconIndex;

    //
    // determine which icon to use.
    // when PST_KEY is not PST_KEY_LOCAL_MACHINE, use a different folder
    // icon at the type and subtype level.
    //

    switch(dwType) {
        case PIDL_TYPE_PROVIDER:
            dwIconIndex = 0;
            break;
        case PIDL_TYPE_TYPE:
        case PIDL_TYPE_SUBTYPE:
            if(KeyType == PST_KEY_CURRENT_USER)
                dwIconIndex = 1;
            else
                dwIconIndex = 3;    // global (shared) icon
            break;
        case PIDL_TYPE_ITEM:
            dwIconIndex = 2;
            break;
        default:
            dwIconIndex = 0;
    }

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iItem = 0;
    lvItem.lParam = (LPARAM)pidl;
    lvItem.pszText = (LPTSTR)szName;
    lvItem.iImage = dwIconIndex; // image index

    nIndex = ListView_InsertItemU(hWnd, &lvItem);

//    ListView_SetItemTextU(hWnd, nIndex, 1, (LPWSTR)szValue);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\tools.h ===
#include "resource.h"

typedef struct
   {
   int   idCommand;
   int   iImage;
   int   idButtonString;
   int   idMenuString;
   BYTE  bState;
   BYTE  bStyle;
   }MYTOOLINFO, *LPMYTOOLINFO;

extern MYTOOLINFO g_Buttons[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\utility.cpp ===
#include <windows.h>
#include <shlobj.h>

#include "pstore.h"

#include "utility.h"
#include "enumid.h"

LPCITEMIDLIST
SearchPidlByType(
    LPCITEMIDLIST pidl,
    DWORD dwPidlType
    )
/*++

    This function searches a pidl, looking for an entry of the type specified
    by the dwPidlType argument.

    On success, the return value in non-NULL.

--*/
{
    if(pidl == NULL)
        return NULL;

    //
    // travel through pidls in list, then pull out the type and compare
    //

    LPCITEMIDLIST pidlTemp = pidl;
    LPCITEMIDLIST pidlResult = NULL;

    while(pidlTemp->mkid.cb)
    {
        if(GetPidlType(pidlTemp) == dwPidlType) {
            pidlResult = pidlTemp;
            break;
        }

        pidlTemp = GetPidlNextItem(pidlTemp);
    }

    return pidlResult;
}

DWORD
GetLastPidlType(
    LPCITEMIDLIST pidl
    )
/*++

    This function traverses the items in the specified pidl until the end of
    the list, returning the type value associated with the last valid entry.

--*/
{
    if(pidl == NULL)
        return 0;

    //
    // travel to last pidl in list, then pull out the type
    //

    LPCITEMIDLIST pidlTemp = pidl;
    LPCITEMIDLIST pidlLast = pidlTemp;

    while(pidlTemp->mkid.cb)
    {
        pidlLast = pidlTemp;
        pidlTemp = GetPidlNextItem(pidlTemp);
    }

    return GetPidlType(pidlLast);
}

PST_KEY
GetLastPidlKeyType(
    LPCITEMIDLIST pidl
    )
/*++

    This function traverses the items in the specified pidl until the end of
    the list, returning the key type (PST_KEY) value associated with the last
    valid entry.

--*/
{
    if(pidl == NULL)
        return 0;

    //
    // travel to last pidl in list, then pull out the type
    //

    LPCITEMIDLIST pidlTemp = pidl;
    LPCITEMIDLIST pidlLast = pidlTemp;

    while(pidlTemp->mkid.cb)
    {
        pidlLast = pidlTemp;
        pidlTemp = GetPidlNextItem(pidlTemp);
    }

    return GetPidlKeyType(pidlLast);
}


GUID *
GetLastPidlGuid(
    LPCITEMIDLIST pidl
    )
/*++

    This function traverses the items in the specified pidl until the end of
    the list, returning a pointer to the GUID data associated with the last
    valid entry.

    The caller should make a copy of the data if it is to be used persistently.

--*/
{
    if(pidl == NULL)
        return 0;

    //
    // travel to last pidl in list, then pull out the guid
    //

    LPCITEMIDLIST pidlTemp = pidl;
    LPCITEMIDLIST pidlLast = pidlTemp;

    while(pidlTemp->mkid.cb)
    {
        pidlLast = pidlTemp;
        pidlTemp = GetPidlNextItem(pidlTemp);
    }

    return GetPidlGuid(pidlLast);
}

LPCWSTR
GetLastPidlText(
    LPCITEMIDLIST pidl
    )
/*++

    This function traverses the items in the specified pidl until the end of
    the list, returning a pointer to the text data associated with the last
    valid entry.

    The caller should make a copy of the data if it is to be used persistently.

--*/
{
    if(pidl == NULL)
        return 0;

    //
    // travel to last pidl in list, then pull out the guid
    //

    LPCITEMIDLIST pidlTemp = pidl;
    LPCITEMIDLIST pidlLast = pidlTemp;

    while(pidlTemp->mkid.cb)
    {
        pidlLast = pidlTemp;
        pidlTemp = GetPidlNextItem(pidlTemp);
    }

    return GetPidlText(pidlLast);
}



LPCWSTR
GetPidlText(
    LPCITEMIDLIST pidl
    )
/*++

    This helper routine returns the display text associated with the specified
    pidl.

    The caller should make a copy of the string if the string is for persistent
    use.

--*/
{
    LPPIDL_CONTENT pidlContent = (LPPIDL_CONTENT)&(pidl->mkid.abID);

    return (LPCWSTR)(pidlContent + 1);
}


GUID *
GetPidlGuid(
    LPCITEMIDLIST pidl
    )
/*++

    This helper routine is called by IShellFolder::CompareIDs()
    to get the GUID identifiers associated with the specified pidl.

    The caller should make a copy of the output buffer pointer if the item is
    for persistent use.

--*/
{
    LPPIDL_CONTENT pidlContent = (LPPIDL_CONTENT)&(pidl->mkid.abID);

    return &(pidlContent->guid);
}

DWORD
GetPidlType(
    LPCITEMIDLIST pidl
    )
/*++

    This function returns the type value associated with the specified pidl.

--*/
{
    if(pidl == NULL)
        return 0;

    LPPIDL_CONTENT pidlContent = (LPPIDL_CONTENT)&(pidl->mkid.abID);

    return pidlContent->dwType;
}

PST_KEY
GetPidlKeyType(
    LPCITEMIDLIST pidl
    )
/*++

    This function returns the key type associated with the specified pidl.

--*/
{
    if(pidl == NULL)
        return 0;

    LPPIDL_CONTENT pidlContent = (LPPIDL_CONTENT)&(pidl->mkid.abID);

    return pidlContent->KeyType;
}




LPCITEMIDLIST
GetPidlNextItem(
    LPCITEMIDLIST pidl
    )
/*++

    This function examines the specified pidl and returns to the caller
    a pointer to the next pidl entry.

--*/
{
    if(pidl == NULL)
        return NULL;

    return (LPCITEMIDLIST) (LPBYTE)(((LPBYTE)pidl) + pidl->mkid.cb);
}

UINT
GetPidlSize(
    LPCITEMIDLIST pidl
    )
/*++

    This function gets the total size associated with the specified pidl.
    This accounts for all items, item data, and the terminal entry.

--*/
{
    if(pidl == NULL)
        return 0;

    UINT cbTotal = 0;
    LPCITEMIDLIST pidlTemp = pidl;

    while(pidlTemp->mkid.cb)
    {
        cbTotal += pidlTemp->mkid.cb;
        pidlTemp = GetPidlNextItem(pidlTemp);
    }

    //
    // Requires a 16 bit zero value for the NULL terminator
    //

    cbTotal += 2 * sizeof(BYTE);

    return cbTotal;
}

LPITEMIDLIST
CopyPidl(
    LPMALLOC pMalloc,
    LPCITEMIDLIST pidlSource
    )
/*++

    This function copies the specified pidl to new storage allocated by the
    specified allocation interface.

    On success, the return value is non-NULL and points to the copy of the pidl.

--*/
{
    LPITEMIDLIST pidlTarget = NULL;
    UINT cbSource = 0;

    if(NULL == pidlSource)
        return NULL;

    //
    // Allocate the new pidl
    //

    cbSource = GetPidlSize(pidlSource);

    pidlTarget = (LPITEMIDLIST) pMalloc->Alloc(cbSource);
    if(pidlTarget == NULL)
        return NULL;

    // Copy the source to the target
    CopyMemory(pidlTarget, pidlSource, cbSource);

    return pidlTarget;
}

LPITEMIDLIST
CopyCatPidl(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    )
/*++

    This function allocated sufficient storage for a copy of:
    the two specified pidls, catanated together.

    On success, the return value is non-NULL and points to the copy of the pidl.

--*/
{
    LPMALLOC pMalloc;
    LPITEMIDLIST pidlTarget;
    UINT cbSource1;
    UINT cbSource2;


    if( NOERROR != SHGetMalloc(&pMalloc) )
        return NULL;

    //
    // Allocate the new pidl
    //

    cbSource1 = GetPidlSize(pidl1);
    cbSource2 = GetPidlSize(pidl2);

    pidlTarget = (LPITEMIDLIST) pMalloc->Alloc(cbSource1 + cbSource2);

    if(pidlTarget != NULL) {


        //
        // Copy first pidl source to the target
        //

        if( cbSource1 )
            CopyMemory(pidlTarget, pidl1, cbSource1);
        else {

            //
            // no source pidl: insure zero termination for search.
            //

            ZeroMemory(pidlTarget, cbSource2);
        }

        //
        // find the null terminator
        //

        if( cbSource2 ) {
            LPCITEMIDLIST pidlTemp = pidlTarget;

            while(pidlTemp->mkid.cb)
            {
                pidlTemp = GetPidlNextItem(pidlTemp);
            }

            //
            // Copy second pidl source to target.
            //

            CopyMemory((LPBYTE)pidlTemp, pidl2, cbSource2);
        }
    }

    pMalloc->Release();

    return pidlTarget;
}

VOID
FreePidl(
    LPITEMIDLIST pidl
    )
{
    LPMALLOC pMalloc;

    if( NOERROR != SHGetMalloc(&pMalloc) )
        return;

    pMalloc->Free(pidl);
    pMalloc->Release();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\shview.h ===
#ifndef SHVIEW_H
#define SHVIEW_H

#define NS_CLASS_NAME   (TEXT("PStoreNSClass"))

//
// menu items
//

#define IDM_MESSAGE1    (FCIDM_SHVIEWFIRST + 0x500)
#define IDM_MESSAGE2    (FCIDM_SHVIEWFIRST + 0x501)
#define IDM_VIEW_ISTB   (FCIDM_SHVIEWFIRST + 0x502)
#define IDM_VIEW_IETB   (FCIDM_SHVIEWFIRST + 0x503)

//
// control IDs
//

#define ID_LISTVIEW     2000


class CShellView : public IShellView, public IOleCommandTarget
{
protected:
    LONG m_ObjRefCount;

public:
    CShellView(CShellFolder*, LPCITEMIDLIST);
    ~CShellView();

    //
    // IUnknown methods
    //

    STDMETHOD (QueryInterface)(REFIID, LPVOID FAR *);
    STDMETHOD_ (DWORD, AddRef)();
    STDMETHOD_ (DWORD, Release)();

    //
    // IOleWindow methods
    //

    STDMETHOD (GetWindow) (HWND*);
    STDMETHOD (ContextSensitiveHelp) (BOOL);

    //
    // IShellView methods
    //

    STDMETHOD (TranslateAccelerator) (LPMSG);
    STDMETHOD (EnableModeless) (BOOL);
    STDMETHOD (UIActivate) (UINT);
    STDMETHOD (Refresh) (void);
    STDMETHOD (CreateViewWindow) (LPSHELLVIEW, LPCFOLDERSETTINGS, LPSHELLBROWSER, LPRECT, HWND*);
    STDMETHOD (DestroyViewWindow) (void);
    STDMETHOD (GetCurrentInfo) (LPFOLDERSETTINGS);
    STDMETHOD (AddPropertySheetPages) (DWORD, LPFNADDPROPSHEETPAGE, LPARAM);
    STDMETHOD (SaveViewState) (void);
    STDMETHOD (SelectItem) (LPCITEMIDLIST, UINT);
    STDMETHOD (GetItemObject) (UINT, REFIID, LPVOID*);

    //
    // IOleCommandTarget methods
    //

    STDMETHOD (QueryStatus) (const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHOD (Exec) (const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

private:
    //
    // private member variables
    //

    UINT m_uState;
    BOOL m_bShowIETB;
    BOOL m_bShowISTB;
    LPITEMIDLIST m_pidl;
    OLEMENUGROUPWIDTHS m_MenuWidths;
    FOLDERSETTINGS m_FolderSettings;
    LPSHELLBROWSER m_pShellBrowser;
    HWND m_hwndParent;
    HWND m_hWnd;
    HWND m_hwndList;
    HMENU m_hMenu;
    int m_nColumn1;
    int m_nColumn2;
    CShellFolder *m_pSFParent;

    //
    // private member functions
    //

    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    void UpdateToolbar();
    LRESULT UpdateMenu(HMENU hMenu);
    HRESULT GetSettings(void);
    HRESULT SaveSettings(void);
    HMENU BuildMenu(void);
    LRESULT OnCommand(DWORD, DWORD, HWND);
    LRESULT OnActivate(WPARAM wParam, LPARAM lParam);
    LRESULT OnSetFocus(void);
    LRESULT OnNotify(UINT, LPNMHDR);
    LRESULT OnSize(WORD, WORD);
    LRESULT OnCreate(void);
    BOOL CreateList(void);
    BOOL InitList(void);
    BOOL FillList(void);
};

#endif   // SHVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\utility.h ===
#ifndef UTILITY_H
#define UTILITY_H

#define ResultFromDWORD(dw) ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, dw))

//
// pidl utility functions
//

LPCITEMIDLIST
SearchPidlByType(
    LPCITEMIDLIST pidl,
    DWORD dwPidlType
    );

DWORD
GetLastPidlType(
    LPCITEMIDLIST pidl
    );

PST_KEY
GetLastPidlKeyType(
    LPCITEMIDLIST pidl
    );

GUID *
GetLastPidlGuid(
    LPCITEMIDLIST pidl
    );

LPCWSTR
GetLastPidlText(
    LPCITEMIDLIST pidl
    );

LPCWSTR
GetPidlText(
    LPCITEMIDLIST pidl
    );

GUID *
GetPidlGuid(
    LPCITEMIDLIST pidl
    );

DWORD
GetPidlType(
    LPCITEMIDLIST pidl
    );

PST_KEY
GetPidlKeyType(
    LPCITEMIDLIST pidl
    );

LPCITEMIDLIST
GetPidlNextItem(
    LPCITEMIDLIST
    );

UINT
GetPidlSize(
    LPCITEMIDLIST
    );

LPITEMIDLIST
CopyPidl(
    LPMALLOC,
    LPCITEMIDLIST
    );

LPITEMIDLIST
CopyCatPidl(
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2
    );

VOID
FreePidl(
    LPITEMIDLIST pidl
    );

#endif   // UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\inc\unicode.h ===
#ifndef __ECM_UNICODE_H__
#define __ECM_UNICODE_H__

// necessary defns -- remove?
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI FIsWinNT(void);
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW, char ** pszMB, int *pcbConverted);
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB);
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB);

LPWSTR WINAPI MkWStr(char * szMB);
void WINAPI FreeWStr(LPWSTR wsz);

// The following is also needed for non-x86 due to a bug in advapi32 for
// CryptAcquireContextW. 
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );


#ifdef _M_IX86

// Reg.cpp
LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegDeleteKeyU(
    HKEY hKey,
    LPCWSTR lpSubKey
   );

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   );	

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG WINAPI RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,	
    DWORD ulOptions,	
    REGSAM samDesired,	
    PHKEY phkResult 	
   );


// File.cpp
HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    );

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );


// capi.cpp
BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags
    );

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType
    );

// Ole.cpp
RPC_STATUS RPC_ENTRY UuidToStringU( 
    UUID *  Uuid, 	
    WCHAR * *  StringUuid	
   );

// nt.cpp
BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
   );	
 
DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
   );

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName 	// address of module name to return handle for  
   );

// user.cpp
int WINAPI LoadStringU(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer, 
    int nBufferMax
   );

DWORD WINAPI FormatMessageU(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
   );

BOOL WINAPI SetWindowTextU(
    HWND hWnd,
    LPCWSTR lpString
   );

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount
   );	
                 
int WINAPI MessageBoxU(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

int WINAPI LCMapStringU(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,	
    LPWSTR lpDestStr,
    int cchDest
    );

#else

#define RegQueryValueExU	    RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define FormatMessageU          FormatMessageW
#define SetWindowTextU          SetWindowTextW
#define GetDlgItemTextU         GetDlgItemTextW
#define MessageBoxU				MessageBoxW
#define LCMapStringU            LCMapStringW

#endif // _M_IX86

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\qvhack\main.cpp ===
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>

#include "resource.h"

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

HMODULE g_hInstance = NULL;
LPTSTR g_pszFile = NULL;

BOOL FormatMessageString(UINT idTemplate, LPTSTR pszStrOut, DWORD cchSize, ...)
{
    BOOL fResult = FALSE;

    va_list vaParamList;
    
    TCHAR szFormat[512];
    if (LoadString(g_hInstance, idTemplate, szFormat, ARRAYSIZE(szFormat)))
    {
        va_start(vaParamList, cchSize);
        
        fResult = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szFormat, 0, 0, pszStrOut, cchSize, &vaParamList);

        va_end(vaParamList);
    }

    return fResult;
}

INT_PTR QuickviewHackDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fReturn = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // Set the message
            TCHAR szMessage[512];

            BOOL fFormat = FormatMessageString(IDS_QUESTION, szMessage, ARRAYSIZE(szMessage), StrRChr(g_pszFile, NULL, TEXT('\\')) + 1);

            if (fFormat)
            {
                SetWindowText(GetDlgItem(hwnd, IDC_MESSAGE), szMessage);
            }

            // default focus
            fReturn = FALSE;
        }
        break;

    case WM_PAINT:
        {
            HDC hdcPaint = GetDC(hwnd);

            // Set the icon
            HICON hQuestionIcon = (HICON) LoadIcon(NULL, MAKEINTRESOURCE(IDI_QUESTION));

            DrawIcon(hdcPaint, 7, 7, hQuestionIcon);

            // Don't free the icon, its shared.

            ReleaseDC(hwnd, hdcPaint);
        }
        break;

    case WM_COMMAND:
        {
            switch ((UINT) LOWORD(wParam))
            {
            case IDYES:
                {
                    SHELLEXECUTEINFO shexecinfo = {0};
                    shexecinfo.cbSize = sizeof(shexecinfo);
                    shexecinfo.lpVerb = TEXT("openas");
                    shexecinfo.lpClass = TEXT("unknown");
                    shexecinfo.nShow = SW_SHOWNORMAL;
                    shexecinfo.fMask = SEE_MASK_CLASSNAME;
                    shexecinfo.lpFile = g_pszFile;

                    // This may take a while
                    SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));

                    ShellExecuteEx(&shexecinfo);
                }
                // Fall through
            case IDNO:
                EndDialog(hwnd, LOWORD(wParam));
                fReturn = TRUE;
                break;
            }
            break;
        }
        break;
    default:
        break;
    }

    return fReturn;
}

int _stdcall ModuleEntry(void)
{
    UINT uiExit = 0;

    g_hInstance = GetModuleHandle(NULL);

    // The command-line looks like:
    //   "quikview.exe" -v -f:"c:\blah\foo\doc.jpg"
    // We want to take the stuff between the two quotes at the end

    TCHAR szFile[MAX_PATH + 1];

    LPTSTR pszLastQuote = StrRChr(GetCommandLine(), NULL, TEXT('\"'));

    if (pszLastQuote)
    {
        LPTSTR pszSecondLastQuote = StrRChr(GetCommandLine(), pszLastQuote - 1, TEXT('\"'));

        if (pszSecondLastQuote)
        {
            StrCpyN(szFile, pszSecondLastQuote + 1, ARRAYSIZE(szFile));

            // Now find our last quote again
            pszLastQuote = StrRChr(szFile, NULL, TEXT('\"'));

            if (pszLastQuote)
            {
                *pszLastQuote = 0;
     
                // szFile now has what we want
                g_pszFile = szFile;

                DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_QVHACK), NULL,
                    QuickviewHackDialogProc, 0);
            }
        }
    }

    ExitProcess(uiExit);
    return 0;    // We never come here.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\qvhack\resource.h ===
// DIALOG resources
#define IDD_QVHACK      1000

// CONTROL resources
#define IDC_MESSAGE     5000

// STRING resources
#define IDS_QUESTION    10000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\qvhack\version.h ===
// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Quickview .exe stub"
#define VER_INTERNALNAME_STR            "quikview"
#define VER_ORIGINALFILENAME_STR        "quikview.exe"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\pstore\inc\pstore.h ===
/*++

Copyright (c) 1996, 1997  Microsoft Corporation

Module Name:

    pstore.h

Abstract:

    This module defines the Protected Storage COM interface and associated
    data structures.

Author:

    Scott Field (sfield)    13-Mar-97

--*/

#ifndef __PSTORE_H__
#define __PSTORE_H__


/*
    Typedefs, values 
*/

// provider flags

// provider capabilities
typedef DWORD PST_PROVIDERCAPABILITIES;

#define PST_PC_PFX              0x00000001
#define PST_PC_HARDWARE         0x00000002
#define PST_PC_SMARTCARD        0x00000004
#define PST_PC_PCMCIA           0x00000008
#define PST_PC_MULTIPLE_REPOSITORIES    0x00000010
#define PST_PC_ROAMABLE         0x00000020


// NYI (not yet implemented)
typedef DWORD PST_REPOSITORYCAPABILITIES;

#define PST_RC_REMOVABLE        0x80000000


// provider storage area 
typedef DWORD PST_KEY;

#define PST_KEY_CURRENT_USER    0x00000000
#define PST_KEY_LOCAL_MACHINE   0x00000001



/* 
    dwDefaultConfirmationStyle flags
*/

//
// allows user to choose confirmation style
//
#define     PST_CF_DEFAULT              0x00000000

//
// forces silent item creation 
//
#define     PST_CF_NONE                 0x00000001



/*
    dwPromptFlags
*/

//
// app forces confirmation to be shown
//
#define     PST_PF_ALWAYS_SHOW          0x00000001


/* 
    dwFlags values
*/

//
// Allows caller to specify creation not overwrite 
// of item during WriteItem call
//
#define     PST_NO_OVERWRITE            0x00000002

//
// specifies insecure data stream to be written/read
// there is no protection or guarantees for this data
// flag only valid during item read/write calls
// default: item calls are secure
//
#define     PST_UNRESTRICTED_ITEMDATA   0x00000004



/* 
    Security masks, rule modifiers 
*/

//
// models access after NT access mask
//

// read, write
typedef DWORD PST_ACCESSMODE;

#define     PST_READ                0x0001
#define     PST_WRITE               0x0002


// PST_ACCESSCLAUSETYPE 

// memhash, diskhash, authenticode, etc
typedef DWORD PST_ACCESSCLAUSETYPE;

//
// pbClauseData points to PST_AUTHENTICODEDATA structure.
//
#define     PST_AUTHENTICODE            1

//
// pbClauseData points to PST_BINARYCHECKDATA structure.
//
#define     PST_BINARY_CHECK            2

//
// pbClauseData points to valid Windows NT security descriptor.
// note that performance is improved on Set operations if the security
// descriptor is in self-relative format, with valid owner and group Sids
// (non-NULL).
//
#define     PST_SECURITY_DESCRIPTOR     4

//
// pbClauseData is in self-relative format
// (for internal use only)
//
#define     PST_SELF_RELATIVE_CLAUSE    0x80000000L

//
// currently access clause modifiers - NOT to be or'd together
//


//
// specified image is the immediate caller, and is an application (.exe)
//

#define     PST_AC_SINGLE_CALLER        0

//
// specified image is not necessary the immediate caller, and is an
// application (.exe)
//

#define     PST_AC_TOP_LEVEL_CALLER     1

//
// specified image is the immediate caller.  May be
// an application (.exe) or a .dll
//

#define     PST_AC_IMMEDIATE_CALLER     2


/*
    Provider Parameters
*/
//
// flush the internal cache of passwords -- temporary?
//
#define     PST_PP_FLUSH_PW_CACHE       0x1




/*
    Provider Defns
*/

//
// Microsoft Base Provider (MS_BASE_PSTPROVIDER...)
//
#define MS_BASE_PSTPROVIDER_NAME            L"System Protected Storage"

// {8A078C30-3755-11d0-A0BD-00AA0061426A}
#define MS_BASE_PSTPROVIDER_ID              { 0x8a078c30, 0x3755, 0x11d0, { 0xa0, 0xbd, 0x0, 0xaa, 0x0, 0x61, 0x42, 0x6a } }
#define MS_BASE_PSTPROVIDER_SZID            L"8A078C30-3755-11d0-A0BD-00AA0061426A"

//
// Microsoft PFX Provider (MS_PFX_PSTPROVIDER...)
//
#define MS_PFX_PSTPROVIDER_NAME             L"PFX Storage Provider"

// {3ca94f30-7ac1-11d0-8c42-00c04fc299eb}
#define MS_PFX_PSTPROVIDER_ID               { 0x3ca94f30, 0x7ac1, 0x11d0, {0x8c, 0x42, 0x00, 0xc0, 0x4f, 0xc2, 0x99, 0xeb} }
#define MS_PFX_PSTPROVIDER_SZID             L"3ca94f30-7ac1-11d0-8c42-00c04fc299eb"



/*
    Globally registered Type/Subtype guid/name pairs
*/

#define PST_CONFIGDATA_TYPE_STRING              L"Configuration Data"
// 8ec99652-8909-11d0-8c4d-00c04fc297eb
#define PST_CONFIGDATA_TYPE_GUID                        \
{   0x8ec99652,                                         \
    0x8909,                                             \
    0x11d0,                                             \
    {0x8c, 0x4d, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}

#define PST_PROTECTEDSTORAGE_SUBTYPE_STRING     L"Protected Storage"
// d3121b8e-8a7d-11d0-8c4f-00c04fc297eb 
#define PST_PROTECTEDSTORAGE_SUBTYPE_GUID               \
{   0xd3121b8e,                                         \
    0x8a7d,                                             \
    0x11d0,                                             \
    {0x8c, 0x4f, 0x00, 0xc0, 0x4f, 0xc2, 0x97, 0xeb}    \
}


#define PST_PSTORE_PROVIDERS_SUBTYPE_STRING     L"Protected Storage Provider List"
// 8ed17a64-91d0-11d0-8c43-00c04fc2c621
#define PST_PSTORE_PROVIDERS_SUBTYPE_GUID               \
{                                                       \
    0x8ed17a64,                                         \
    0x91d0,                                             \
    0x11d0,                                             \
    {0x8c, 0x43, 0x00, 0xc0, 0x4f, 0xc2, 0xc6, 0x21}    \
}


//
// error codes
//


#ifndef PST_E_OK
#define PST_E_OK                        _HRESULT_TYPEDEF_(0x00000000L)


#define PST_E_FAIL                      _HRESULT_TYPEDEF_(0x800C0001L)
#define PST_E_PROV_DLL_NOT_FOUND        _HRESULT_TYPEDEF_(0x800C0002L)
#define PST_E_INVALID_HANDLE            _HRESULT_TYPEDEF_(0x800C0003L)
#define PST_E_TYPE_EXISTS               _HRESULT_TYPEDEF_(0x800C0004L)
#define PST_E_TYPE_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0005L)
#define PST_E_INVALID_RULESET           _HRESULT_TYPEDEF_(0x800C0006L)
#define PST_E_NO_PERMISSIONS            _HRESULT_TYPEDEF_(0x800C0007L)
#define PST_E_STORAGE_ERROR             _HRESULT_TYPEDEF_(0x800C0008L)
#define PST_E_CALLER_NOT_VERIFIED       _HRESULT_TYPEDEF_(0x800C0009L)
#define PST_E_WRONG_PASSWORD            _HRESULT_TYPEDEF_(0x800C000AL)
#define PST_E_DISK_IMAGE_MISMATCH       _HRESULT_TYPEDEF_(0x800C000BL)
// 000C pending
#define PST_E_UNKNOWN_EXCEPTION         _HRESULT_TYPEDEF_(0x800C000DL)
#define PST_E_BAD_FLAGS                 _HRESULT_TYPEDEF_(0x800C000EL)
#define PST_E_ITEM_EXISTS               _HRESULT_TYPEDEF_(0x800C000FL)
#define PST_E_ITEM_NO_EXISTS            _HRESULT_TYPEDEF_(0x800C0010L)
#define PST_E_SERVICE_UNAVAILABLE       _HRESULT_TYPEDEF_(0x800C0011L)
#define PST_E_NOTEMPTY                  _HRESULT_TYPEDEF_(0x800C0012L)
#define PST_E_INVALID_STRING            _HRESULT_TYPEDEF_(0x800C0013L)
#define PST_E_STATE_INVALID             _HRESULT_TYPEDEF_(0x800C0014L)
#define PST_E_NOT_OPEN                  _HRESULT_TYPEDEF_(0x800C0015L)
#define PST_E_ALREADY_OPEN              _HRESULT_TYPEDEF_(0x800C0016L)
#define PST_E_NYI                       _HRESULT_TYPEDEF_(0x800C0F00L)


#define MIN_PST_ERROR                   0x800C0001
#define MAX_PST_ERROR                   0x800C0F00

#endif  // !PST_OK



/* this ALWAYS GENERATED file contains the definitions for the interfaces */

//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "wtypes.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Wed Apr 23 23:56:10 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


typedef DWORD PST_PROVIDERCAPABILITIES;

typedef DWORD PST_REPOSITORYCAPABILITIES;

typedef DWORD PST_KEY;

typedef DWORD PST_ACCESSMODE;

typedef DWORD PST_ACCESSCLAUSETYPE;

typedef GUID UUID;

typedef ULARGE_INTEGER PST_PROVIDER_HANDLE;

typedef GUID PST_PROVIDERID;

typedef PST_PROVIDERID __RPC_FAR *PPST_PROVIDERID;

typedef struct  _PST_PROVIDERINFO
    {
    DWORD cbSize;
    PST_PROVIDERID ID;
    PST_PROVIDERCAPABILITIES Capabilities;
    LPWSTR szProviderName;
    }	PST_PROVIDERINFO;

typedef struct _PST_PROVIDERINFO __RPC_FAR *PPST_PROVIDERINFO;

typedef struct  _PST_TYPEINFO
    {
    DWORD cbSize;
    LPWSTR szDisplayName;
    }	PST_TYPEINFO;

typedef struct _PST_TYPEINFO __RPC_FAR *PPST_TYPEINFO;

typedef struct  _PST_PROMPTINFO
    {
    DWORD cbSize;
    DWORD dwPromptFlags;
    HWND  hwndApp;
    LPCWSTR szPrompt;
    }	PST_PROMPTINFO;

typedef struct _PST_PROMPTINFO __RPC_FAR *PPST_PROMPTINFO;

typedef struct  _PST_ACCESSCLAUSE
    {
    DWORD cbSize;
    PST_ACCESSCLAUSETYPE ClauseType;
    DWORD cbClauseData;
    /* [size_is] */ VOID __RPC_FAR *pbClauseData;
    }	PST_ACCESSCLAUSE;

typedef struct _PST_ACCESSCLAUSE __RPC_FAR *PPST_ACCESSCLAUSE;

typedef struct  _PST_ACCESSRULE
    {
    DWORD cbSize;
    PST_ACCESSMODE AccessModeFlags;
    DWORD cClauses;
    /* [size_is] */ PST_ACCESSCLAUSE __RPC_FAR *rgClauses;
    }	PST_ACCESSRULE;

typedef struct _PST_ACCESSRULE __RPC_FAR *PPST_ACCESSRULE;

typedef struct  _PST_ACCESSRULESET
    {
    DWORD cbSize;
    DWORD cRules;
    /* [size_is] */ PST_ACCESSRULE __RPC_FAR *rgRules;
    }	PST_ACCESSRULESET;

typedef struct _PST_ACCESSRULESET __RPC_FAR *PPST_ACCESSRULESET;

typedef struct  _PST_AUTHENTICODEDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szRootCA;
    LPCWSTR szIssuer;
    LPCWSTR szPublisher;
    LPCWSTR szProgramName;
    }	PST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *PPST_AUTHENTICODEDATA;

typedef struct _PST_AUTHENTICODEDATA __RPC_FAR *LPPST_AUTHENTICODEDATA;

typedef struct  _PST_BINARYCHECKDATA
    {
    DWORD cbSize;
    DWORD dwModifiers;
    LPCWSTR szFilePath;
    }	PST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *PPST_BINARYCHECKDATA;

typedef struct _PST_BINARYCHECKDATA __RPC_FAR *LPPST_BINARYCHECKDATA;



extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif



/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Wed Apr 23 23:56:14 1997
 */
/* Compiler settings for pstorec.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumPStoreItems_FWD_DEFINED__
#define __IEnumPStoreItems_FWD_DEFINED__
typedef interface IEnumPStoreItems IEnumPStoreItems;
#endif 	/* __IEnumPStoreItems_FWD_DEFINED__ */


#ifndef __IEnumPStoreTypes_FWD_DEFINED__
#define __IEnumPStoreTypes_FWD_DEFINED__
typedef interface IEnumPStoreTypes IEnumPStoreTypes;
#endif 	/* __IEnumPStoreTypes_FWD_DEFINED__ */


#ifndef __IPStore_FWD_DEFINED__
#define __IPStore_FWD_DEFINED__
typedef interface IPStore IPStore;
#endif 	/* __IPStore_FWD_DEFINED__ */


#ifndef __IEnumPStoreProviders_FWD_DEFINED__
#define __IEnumPStoreProviders_FWD_DEFINED__
typedef interface IEnumPStoreProviders IEnumPStoreProviders;
#endif 	/* __IEnumPStoreProviders_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IEnumPStoreItems_INTERFACE_DEFINED__
#define __IEnumPStoreItems_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreItems
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEnumPStoreItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumPStoreItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPStoreItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumPStoreItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumPStoreItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out] */ LPWSTR __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumPStoreItems __RPC_FAR * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumPStoreItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumPStoreItems __RPC_FAR * This,
            /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumPStoreItemsVtbl;

    interface IEnumPStoreItems
    {
        CONST_VTBL struct IEnumPStoreItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPStoreItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreItems_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreItems_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreItems_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreItems_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Next_Proxy( 
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out] */ LPWSTR __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Skip_Proxy( 
    IEnumPStoreItems __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Reset_Proxy( 
    IEnumPStoreItems __RPC_FAR * This);


void __RPC_STUB IEnumPStoreItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreItems_Clone_Proxy( 
    IEnumPStoreItems __RPC_FAR * This,
    /* [out] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPStoreItems_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreTypes_INTERFACE_DEFINED__
#define __IEnumPStoreTypes_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreTypes
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEnumPStoreTypes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumPStoreTypes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPStoreTypesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumPStoreTypes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumPStoreTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ GUID __RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumPStoreTypes __RPC_FAR * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumPStoreTypes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumPStoreTypes __RPC_FAR * This,
            /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumPStoreTypesVtbl;

    interface IEnumPStoreTypes
    {
        CONST_VTBL struct IEnumPStoreTypesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPStoreTypes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreTypes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreTypes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreTypes_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreTypes_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreTypes_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreTypes_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Next_Proxy( 
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ GUID __RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreTypes_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Skip_Proxy( 
    IEnumPStoreTypes __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreTypes_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Reset_Proxy( 
    IEnumPStoreTypes __RPC_FAR * This);


void __RPC_STUB IEnumPStoreTypes_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreTypes_Clone_Proxy( 
    IEnumPStoreTypes __RPC_FAR * This,
    /* [out] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreTypes_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPStoreTypes_INTERFACE_DEFINED__ */


#ifndef __IPStore_INTERFACE_DEFINED__
#define __IPStore_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPStore
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IPStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IPStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProvParam( 
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProvParam( 
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateType( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteType( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSubtype( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSubtypeInfo( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteSubtype( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadAccessRuleset( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteAccessRuleset( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumTypes( 
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSubtypes( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteItem( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadItem( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteItem( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenItem( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseItem( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPStore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPStore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPStore __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInfo )( 
            IPStore __RPC_FAR * This,
            /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProvParam )( 
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProvParam )( 
            IPStore __RPC_FAR * This,
            /* [in] */ DWORD dwParam,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateType )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteType )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSubtype )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_TYPEINFO pInfo,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubtypeInfo )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteSubtype )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadAccessRuleset )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteAccessRuleset )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ const GUID __RPC_FAR *pSubtype,
            /* [in] */ PPST_ACCESSRULESET pRules,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumTypes )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumSubtypes )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteItem )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadItem )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [out] */ DWORD __RPC_FAR *pcbData,
            /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteItem )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE __RPC_FAR *pbData,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwDefaultConfirmationStyle,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenItem )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ PST_ACCESSMODE ModeFlags,
            /* [in] */ PPST_PROMPTINFO pPromptInfo,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseItem )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ LPCWSTR szItemName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumItems )( 
            IPStore __RPC_FAR * This,
            /* [in] */ PST_KEY Key,
            /* [in] */ const GUID __RPC_FAR *pItemType,
            /* [in] */ const GUID __RPC_FAR *pItemSubtype,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IPStoreVtbl;

    interface IPStore
    {
        CONST_VTBL struct IPStoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPStore_GetInfo(This,ppProperties)	\
    (This)->lpVtbl -> GetInfo(This,ppProperties)

#define IPStore_GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)	\
    (This)->lpVtbl -> GetProvParam(This,dwParam,pcbData,ppbData,dwFlags)

#define IPStore_SetProvParam(This,dwParam,cbData,pbData,dwFlags)	\
    (This)->lpVtbl -> SetProvParam(This,dwParam,cbData,pbData,dwFlags)

#define IPStore_CreateType(This,Key,pType,pInfo,dwFlags)	\
    (This)->lpVtbl -> CreateType(This,Key,pType,pInfo,dwFlags)

#define IPStore_GetTypeInfo(This,Key,pType,ppInfo,dwFlags)	\
    (This)->lpVtbl -> GetTypeInfo(This,Key,pType,ppInfo,dwFlags)

#define IPStore_DeleteType(This,Key,pType,dwFlags)	\
    (This)->lpVtbl -> DeleteType(This,Key,pType,dwFlags)

#define IPStore_CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)	\
    (This)->lpVtbl -> CreateSubtype(This,Key,pType,pSubtype,pInfo,pRules,dwFlags)

#define IPStore_GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)	\
    (This)->lpVtbl -> GetSubtypeInfo(This,Key,pType,pSubtype,ppInfo,dwFlags)

#define IPStore_DeleteSubtype(This,Key,pType,pSubtype,dwFlags)	\
    (This)->lpVtbl -> DeleteSubtype(This,Key,pType,pSubtype,dwFlags)

#define IPStore_ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)	\
    (This)->lpVtbl -> ReadAccessRuleset(This,Key,pType,pSubtype,ppRules,dwFlags)

#define IPStore_WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)	\
    (This)->lpVtbl -> WriteAccessRuleset(This,Key,pType,pSubtype,pRules,dwFlags)

#define IPStore_EnumTypes(This,Key,dwFlags,ppenum)	\
    (This)->lpVtbl -> EnumTypes(This,Key,dwFlags,ppenum)

#define IPStore_EnumSubtypes(This,Key,pType,dwFlags,ppenum)	\
    (This)->lpVtbl -> EnumSubtypes(This,Key,pType,dwFlags,ppenum)

#define IPStore_DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)	\
    (This)->lpVtbl -> DeleteItem(This,Key,pItemType,pItemSubtype,szItemName,pPromptInfo,dwFlags)

#define IPStore_ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)	\
    (This)->lpVtbl -> ReadItem(This,Key,pItemType,pItemSubtype,szItemName,pcbData,ppbData,pPromptInfo,dwFlags)

#define IPStore_WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)	\
    (This)->lpVtbl -> WriteItem(This,Key,pItemType,pItemSubtype,szItemName,cbData,pbData,pPromptInfo,dwDefaultConfirmationStyle,dwFlags)

#define IPStore_OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)	\
    (This)->lpVtbl -> OpenItem(This,Key,pItemType,pItemSubtype,szItemName,ModeFlags,pPromptInfo,dwFlags)

#define IPStore_CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)	\
    (This)->lpVtbl -> CloseItem(This,Key,pItemType,pItemSubtype,szItemName,dwFlags)

#define IPStore_EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)	\
    (This)->lpVtbl -> EnumItems(This,Key,pItemType,pItemSubtype,dwFlags,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPStore_GetInfo_Proxy( 
    IPStore __RPC_FAR * This,
    /* [out] */ PPST_PROVIDERINFO __RPC_FAR *ppProperties);


void __RPC_STUB IPStore_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetProvParam_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_SetProvParam_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ DWORD dwParam,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_SetProvParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateType_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetTypeInfo_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteType_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CreateSubtype_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_TYPEINFO pInfo,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CreateSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_GetSubtypeInfo_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_TYPEINFO __RPC_FAR *ppInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_GetSubtypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteSubtype_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteSubtype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadAccessRuleset_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [out] */ PPST_ACCESSRULESET __RPC_FAR *ppRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteAccessRuleset_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ const GUID __RPC_FAR *pSubtype,
    /* [in] */ PPST_ACCESSRULESET pRules,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteAccessRuleset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumTypes_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumTypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumSubtypes_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreTypes __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumSubtypes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_DeleteItem_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_DeleteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_ReadItem_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [out] */ DWORD __RPC_FAR *pcbData,
    /* [size_is][size_is][out] */ BYTE __RPC_FAR *__RPC_FAR *ppbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_ReadItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_WriteItem_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE __RPC_FAR *pbData,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwDefaultConfirmationStyle,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_WriteItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_OpenItem_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ PST_ACCESSMODE ModeFlags,
    /* [in] */ PPST_PROMPTINFO pPromptInfo,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_OpenItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_CloseItem_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ LPCWSTR szItemName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IPStore_CloseItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPStore_EnumItems_Proxy( 
    IPStore __RPC_FAR * This,
    /* [in] */ PST_KEY Key,
    /* [in] */ const GUID __RPC_FAR *pItemType,
    /* [in] */ const GUID __RPC_FAR *pItemSubtype,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IEnumPStoreItems __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPStore_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPStore_INTERFACE_DEFINED__ */


#ifndef __IEnumPStoreProviders_INTERFACE_DEFINED__
#define __IEnumPStoreProviders_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumPStoreProviders
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IEnumPStoreProviders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IEnumPStoreProviders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ DWORD celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumPStoreProvidersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumPStoreProviders __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumPStoreProviders __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt,
            /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out][in] */ DWORD __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumPStoreProviders __RPC_FAR * This,
            /* [in] */ DWORD celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumPStoreProviders __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumPStoreProviders __RPC_FAR * This,
            /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumPStoreProvidersVtbl;

    interface IEnumPStoreProviders
    {
        CONST_VTBL struct IEnumPStoreProvidersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumPStoreProviders_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumPStoreProviders_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumPStoreProviders_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumPStoreProviders_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumPStoreProviders_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumPStoreProviders_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumPStoreProviders_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Next_Proxy( 
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt,
    /* [out][size_is] */ PST_PROVIDERINFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out][in] */ DWORD __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumPStoreProviders_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Skip_Proxy( 
    IEnumPStoreProviders __RPC_FAR * This,
    /* [in] */ DWORD celt);


void __RPC_STUB IEnumPStoreProviders_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Reset_Proxy( 
    IEnumPStoreProviders __RPC_FAR * This);


void __RPC_STUB IEnumPStoreProviders_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumPStoreProviders_Clone_Proxy( 
    IEnumPStoreProviders __RPC_FAR * This,
    /* [out] */ IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumPStoreProviders_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumPStoreProviders_INTERFACE_DEFINED__ */



#ifndef __PSTORECLib_LIBRARY_DEFINED__
#define __PSTORECLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: PSTORECLib
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_PSTORECLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CPStore;

class CPStore;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumTypes;

class CEnumTypes;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CEnumItems;

class CEnumItems;
#endif
#endif /* __PSTORECLib_LIBRARY_DEFINED__ */

/****************************************
 * Generated header for interface: __MIDL__intf_0080
 * at Wed Apr 23 23:56:14 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


HRESULT __stdcall PStoreCreateInstance( 
    IPStore __RPC_FAR *__RPC_FAR *ppProvider,
    PST_PROVIDERID __RPC_FAR *pProviderID,
    void __RPC_FAR *pReserved,
    DWORD dwFlags);

HRESULT __stdcall PStoreEnumProviders( 
    DWORD dwFlags,
    IEnumPStoreProviders __RPC_FAR *__RPC_FAR *ppenum);



extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0080_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif // PSTORE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\ratings.inc ===
#
# Common makefile include for this project
#

C_DEFINES       = $(C_DEFINES) \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) \
                  -DVSTF
!endif

# always expect the latest IE
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

# Do this to assure that we run on NT 4.0 and Win95, even with 
# NT5/Memphis headers.
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400 
SUBSYSTEM_VERSION=4.00

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL = 1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES       = $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif

# !include $(CCSHELL_DIR)\common.inc

LINKER_FLAGS    = $(LINKER_FLAGS) -MERGE:.CRT=.data

LINKER_FLAGS    = $(LINKER_FLAGS) -ignore:4217 

# SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\buffer.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFFER.CPP -- Implementation of BUFFER class.
 *
 * History:
 *	03/24/93	gregj	Created
 *	10/25/93	gregj	Use shell232.dll routines
 */

#include "npcommon.h"
#include "buffer.h"
#include <netlib.h>

BOOL BUFFER::Alloc( UINT cbBuffer )
{
	_lpBuffer = (LPSTR)::MemAlloc(cbBuffer);
	if (_lpBuffer != NULL) {
		_cb = cbBuffer;
		return TRUE;
	}
	return FALSE;
}

BOOL BUFFER::Realloc( UINT cbNew )
{
	LPVOID lpNew = ::MemReAlloc(_lpBuffer, cbNew);
	if (lpNew == NULL)
		return FALSE;

	_lpBuffer = (LPSTR)lpNew;
	_cb = cbNew;
	return TRUE;
}

BUFFER::BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
	_lpBuffer( NULL )
{
	if (cbInitial)
		Alloc( cbInitial );
}

BUFFER::~BUFFER()
{
	if (_lpBuffer != NULL) {
		::MemFree(_lpBuffer);
		_lpBuffer = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\alloc.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* alloc.c -- 
 *
 * History:
 *	10/06/93	gregj	Created.
 *	11/29/93	gregj	Added debug instrumentation.
 *
 */

#include "npcommon.h"
#include <npalloc.h>
#include <netlib.h>


//====== Memory allocation functions =================================

// Alloc a chunk of memory, quickly, with no 64k limit on size of
// individual objects or total object size.
//
void * WINAPI MemAlloc(long cb)
{
	return (void *)::LocalAlloc(LPTR, cb);
}

// Realloc one of above.  If pb is NULL, then this function will do
// an alloc for you.
//
void * WINAPI MemReAlloc(void * pb, long cb)
{
	if (pb == NULL)
		return ::MemAlloc(cb);

	return (void *)::LocalReAlloc((HLOCAL)pb, cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
}

// Free a chunk of memory alloced or realloced with above routines.
//
BOOL WINAPI MemFree(void * pb)
{
    return ::LocalFree((HLOCAL)pb) ? TRUE : FALSE;
}

#ifdef DEBUG

MEMWATCH::MEMWATCH(LPCSTR lpszLabel)
	: _lpszLabel(lpszLabel)
{
	_info.pNext = NULL;
	_info.cAllocs = 0;
	_info.cFrees = 0;
	_info.cbAlloc = 0;
	_info.cbMaxAlloc = 0;
	_info.cbTotalAlloc = 0;
    fStats = TRUE;
	MemRegisterWatcher(&_info);
}

MEMWATCH::~MEMWATCH()
{
	MemDeregisterWatcher(&_info);
    if (fStats || ((_info.cAllocs - _info.cFrees) != 0)) {
        if (!fStats) {
            OutputDebugString("Memory leak: ");
        }
    	OutputDebugString(_lpszLabel);
    	char szBuf[100];
    	wsprintf(szBuf, "%d allocs, %d orphans, %d byte footprint, %d byte usage\r\n",
    			 _info.cAllocs,
    			 _info.cAllocs - _info.cFrees,
    			 _info.cbMaxAlloc,
    			 _info.cbTotalAlloc);
    	OutputDebugString(szBuf);
    }
}

MemLeak::MemLeak(LPCSTR lpszLabel)
	: MEMWATCH(lpszLabel)
{
    fStats = FALSE;
}

MemOff::MemOff()
{
    pvContext = MemUpdateOff();
}

MemOff::~MemOff()
{
    MemUpdateContinue(pvContext);
}

#endif	/* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\bufloc.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFGLOB.CPP -- Implementation of GLOBAL_BUFFER class.
 *
 * History:
 *	03/24/93	gregj	Created
 */

#include "npcommon.h"
#include "buffer.h"

BOOL LOCAL_BUFFER::Alloc( UINT cbBuffer )
{
	_hMem = ::LocalAlloc( LMEM_MOVEABLE, cbBuffer );
	if (_hMem == NULL) {
		_npBuffer = NULL;
		_cb = 0;
		return FALSE;
	}

	_npBuffer = ::LocalLock( _hMem );
	_cb = cbBuffer;
	return TRUE;
}

BOOL LOCAL_BUFFER::Realloc( UINT cbNew )
{
	if (_hMem == NULL)
		return FALSE;

	::LocalUnlock( _hMem );

        HLOCAL hNew = ::LocalReAlloc( _hMem, cbNew, LMEM_MOVEABLE );
	if (hNew == NULL) {
		::LocalLock( _hMem );
		return FALSE;
	}

	_hMem = hNew;
	_npBuffer = ::LocalLock( _hMem );
	_cb = cbNew;
	return TRUE;
}

LOCAL_BUFFER::LOCAL_BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
	_hMem( NULL ),
	_npBuffer( NULL )
{
	if (cbInitial)
		Alloc( cbInitial );
}

LOCAL_BUFFER::~LOCAL_BUFFER()
{
	if (_hMem != NULL) {
		::LocalUnlock( _hMem );
		::LocalFree( _hMem );
		_hMem = NULL;
		_npBuffer = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\bufbase.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFBASE.CPP -- Implementation of BUFFER_BASE class.
 *
 * History:
 *	03/24/93	gregj	Created base class
 *
 */

#include "npcommon.h"
#include "buffer.h"

// The following code would be nice in OOP fashion, but since the
// derived class's virtuals aren't available until after the derived
// class's constructor is done, this Alloc() call will not go anywhere.
// Therefore each derived class must stick the if statement in its
// constructor.
#if 0
BUFFER_BASE::BUFFER_BASE( UINT cbInitial /* =0 */ )
  : _cb( 0 )		// buffer not allocated yet
{
	if (cbInitial)
		Resize( cbInitial );
}
#endif

BOOL BUFFER_BASE::Resize( UINT cbNew )
{
	BOOL fSuccess;

	if (QuerySize() == 0)
		fSuccess = Alloc( cbNew );
	else {
		fSuccess = Realloc( cbNew );
	}
	if (fSuccess)
		_cb = cbNew;
	return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\bufglob.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFGLOB.CPP -- Implementation of GLOBAL_BUFFER class.
 *
 * History:
 *	03/22/93	gregj	Created
 *	03/24/93	gregj	Renamed from plain BUFFER, derived from BUFFER_BASE
 *
 */

#include "npcommon.h"
#include "buffer.h"

BOOL GLOBAL_BUFFER::Alloc( UINT cbBuffer )
{
	_hMem = ::GlobalAlloc( GMEM_DDESHARE | GMEM_MOVEABLE, cbBuffer );
	if (_hMem == NULL) {
		_lpBuffer = NULL;
		_cb = 0;
		return FALSE;
	}

	_lpBuffer = ::GlobalLock( _hMem );
	_cb = cbBuffer;
	return TRUE;
}

BOOL GLOBAL_BUFFER::Realloc( UINT cbNew )
{
	if (_hMem == NULL)
		return FALSE;

	::GlobalUnlock( _hMem );

        HGLOBAL hNew = ::GlobalReAlloc( _hMem, cbNew, GMEM_MOVEABLE );
	if (hNew == NULL) {
		::GlobalLock( _hMem );
		return FALSE;
	}

	_hMem = hNew;
	_lpBuffer = ::GlobalLock( _hMem );
	_cb = cbNew;
	return TRUE;
}

GLOBAL_BUFFER::GLOBAL_BUFFER( UINT cbInitial /* =0 */ )
  : BUFFER_BASE(),
	_hMem( NULL ),
	_lpBuffer( NULL )
{
	if (cbInitial)
		Alloc( cbInitial );
}

GLOBAL_BUFFER::~GLOBAL_BUFFER()
{
	if (_hMem != NULL) {
		::GlobalUnlock( _hMem );
		::GlobalFree( _hMem );
		_hMem = NULL;
		_lpBuffer = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\chr.cpp ===
#include "npcommon.h"

// strchrf(str, ch)
//
// Returns a pointer to the first occurrence of ch in str.
// Returns NULL if not found.
// May search for a double-byte character.

LPSTR WINAPI strchrf(LPCSTR lpString, UINT ch)
{
    while (*lpString) {
        if (ch == (IS_LEAD_BYTE(*lpString) ? GetTwoByteChar(lpString) : *lpString))
            return (LPSTR)lpString;
        ADVANCE(lpString);
    }
    return NULL;
}


// strrchrf(str, ch)
//
// Returns a pointer to the last occurrence of ch in str.
// Returns NULL if not found.
// May search for a double-byte character.

LPSTR WINAPI strrchrf(LPCSTR lpString, UINT ch)
{
    LPSTR lpLast = NULL;

    while (*lpString) {
        if (ch == (IS_LEAD_BYTE(*lpString) ? GetTwoByteChar(lpString) : *lpString))
            lpLast = (LPSTR)lpString;
        ADVANCE(lpString);
    }
    return lpLast;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\cmp.cpp ===
#include "npcommon.h"

#ifdef strcmpf

#undef strcmpf
int WINAPI strcmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    return lstrcmp(lpStr1, lpStr2);
}

#else

// strcmpf(str1, str2)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2

int WINAPI strcmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    for (; *lpStr1 && *lpStr2; ADVANCE(lpStr1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lpStr1) ? GetTwoByteChar(lpStr1) : *lpStr1;
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : *lpStr2;

        if (ch1 > 0xff || ch2 > 0xff)
            nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);
        else
        {
            if (CollateTable[ch1] == CollateTable[ch2])
                nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);
            else
                nCmp = (CollateTable[ch1] < CollateTable[ch2]) ? -1 : 1;
        }

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lpStr1 > *lpStr2) ? -1 : (*lpStr1 == *lpStr2) ? 0 : 1;
}

#endif  /* ifndef strcmpf */


#ifdef stricmpf

#undef stricmpf
int WINAPI stricmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    return lstrcmpi(lpStr1, lpStr2);
}

#else

// stricmpf(str1, str2)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2
// All comparisons are case-insensitive

int WINAPI stricmpf(LPCSTR lpStr1, LPCSTR lpStr2)
{
    for (; *lpStr1 && *lpStr2; ADVANCE(lpStr1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lpStr1) ? GetTwoByteChar(lpStr1) : *lpStr1;
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : *lpStr2;

        if (ch1 > 0xff || ch2 > 0xff)
            nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);
        else
        {
            ch1 = ToUpperCaseTable[ch1];
            ch2 = ToUpperCaseTable[ch2];
            if (CollateTable[ch1] == CollateTable[ch2])
                nCmp = 0;
            else
                nCmp = (CollateTable[ch1] < CollateTable[ch2]) ? -1 : 1;
        }

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lpStr1 > *lpStr2) ? -1 : (*lpStr1 == *lpStr2) ? 0 : 1;
}

#endif  /* ifndef stricmpf */


// strncmpf(str1, str2, cb)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2
// At most cb bytes are compared before returning

int WINAPI strncmpf(LPCSTR lpStr1, LPCSTR lpStr2, UINT cb)
{
    LPCSTR lp1 = lpStr1;

    for (; *lp1 && *lpStr2; ADVANCE(lp1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // see if we've reached the byte limit.  only need
        // to compare one string for length, since if they
        // get out of sync (DBCS only), we will get a compare
        // error immediately.
        if ((UINT)(lp1 - lpStr1) >= cb)
            return 0;   // no failures, reached limit

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lp1) ? GetTwoByteChar(lp1) : *lp1;
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : *lpStr2;

        nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  check the length to see if
    // we have compared as many bytes as needed.
    if ((UINT)(lp1 - lpStr1) >= cb)
        return 0;   // no failures, reached limit

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lp1 > *lpStr2) ? -1 : (*lp1 == *lpStr2) ? 0 : 1;
}


// strnicmpf(str1, str2, cb)
//
// Returns -1 if str1 is lexically less than str2
// Returns 0 if str1 is equal to str2
// Returns 1 if str1 is lexically greater than str2
// All comparisons are case-insensitive
// At most cb bytes are compared

int WINAPI strnicmpf(LPCSTR lpStr1, LPCSTR lpStr2, UINT cb)
{
    LPCSTR lp1 = lpStr1;

    for (; *lp1 && *lpStr2; ADVANCE(lp1), ADVANCE(lpStr2)) {
        UINT ch1, ch2;
        UINT nCmp;

        // see if we've reached the byte limit.  only need
        // to compare one string for length, since if they
        // get out of sync (DBCS only), we will get a compare
        // error immediately.
        if ((UINT)(lp1 - lpStr1) >= cb)
            return 0;   // no failures, reached limit

        // for same-width chars, compare straight;
        // for DBC vs. SBC, compare 0xttll against 0x00ss
        ch1 = IS_LEAD_BYTE(*lp1) ? GetTwoByteChar(lp1) : PtrToUlong(CharUpper((LPTSTR) *((BYTE *)lp1)));
        ch2 = IS_LEAD_BYTE(*lpStr2) ? GetTwoByteChar(lpStr2) : PtrToUlong(CharUpper((LPTSTR) *((BYTE *)lpStr2)));

        nCmp = (ch1 < ch2) ? -1 : ((ch1 == ch2) ? 0 : 1);

        if (nCmp != 0)
            return nCmp;
    }

    // end of one string or the other.  check the length to see if
    // we have compared as many bytes as needed.
    if ((UINT)(lp1 - lpStr1) >= cb)
        return 0;   // no failures, reached limit

    // end of one string or the other.  if different lengths,
    // shorter one must be lexically less, so it's ok to just
    // compare bytes.
    return (*lp1 > *lpStr2) ? -1 : (*lp1 == *lpStr2) ? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\cpycat.cpp ===
#include "npcommon.h"

// strncpyf(dest, src, cb)
//
// Always stores cb bytes to dest.  If total characters copied
// ends up less than cb bytes, zero-fills dest.
// If strlen(src) >= cb, dest is NOT null-terminated.
// Returns dest.

LPSTR WINAPI strncpyf(LPSTR lpDest, LPCSTR lpSrc, UINT cbCopy)
{
    LPCSTR lpChr = lpSrc;
    UINT cbToCopy = 0;

    // find ptr past last char to copy
    while (*lpChr) {
        if (cbToCopy + (IS_LEAD_BYTE(*lpChr) ? 2 : 1) > cbCopy)
            break;  // copying this char would run over the limit
        cbToCopy += IS_LEAD_BYTE(*lpChr) ? 2 : 1;
        ADVANCE(lpChr);
    }

    // copy that many bytes
    memcpyf(lpDest, lpSrc, cbToCopy);
    memsetf(lpDest + cbToCopy, '\0', cbCopy - cbToCopy);

    return lpDest;
}


// strncatf(dest, src, cb)
//
// Concatenates at most cb bytes of src onto the end of dest.
// Unlike strncpyf, does not pad with extra nulls, but does
// guarantee a null-terminated destination.
// Returns dest.

LPSTR WINAPI strncatf(LPSTR lpDest, LPCSTR lpSrc, UINT cbCopy)
{
    LPCSTR lpChr = lpSrc;
    UINT cbToCopy = 0;

    // find ptr past last char to copy
    while (*lpChr) {
        if (cbToCopy + (IS_LEAD_BYTE(*lpChr) ? 2 : 1) > cbCopy)
            break;  // copying this char would run over the limit
        cbToCopy += IS_LEAD_BYTE(*lpChr) ? 2 : 1;
        ADVANCE(lpChr);
    }

    // copy that many bytes
    memcpyf(lpDest, lpSrc, cbToCopy);
    lpDest[cbToCopy] = '\0';

    return lpDest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\convtime.cpp ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4 */

/***	convtime.cpp - map between SYSTEM & NET time formats
 */

#include "npcommon.h"
#include <convtime.h>


void
NetToSystemDate(
DWORD time,
LPSYSTEMTIME pinfo)			// ptr for return data:
{
	UINT secs, days;
	WORD r;

	// Base the time on 1980, not 1970, to make leap year calculation
	// easier -- 1980 is a leap year, but 1970 isn't.  This code is being
	// written in 1996, so we aren't going to be dealing with dates before
	// 1980 anyway.

    time -= _70_to_80_bias;				// # of seconds since 1980
	secs = time % SECS_IN_DAY;			// seconds into day
	days = time / SECS_IN_DAY;			// days since Jan 1 1980
	pinfo->wDayOfWeek = (days + 2) % 7;	// Jan 1 1980 was a Tuesday, hence "+2"

	pinfo->wMilliseconds = 0;
	pinfo->wSecond = secs % 60;					// # of seconds
	secs /= 60;
	pinfo->wMinute = secs % 60;					// # of minutes
	pinfo->wHour = secs / 60;					// # of hours

	r = days / FOURYEARS;			// (r) = four year period past 1980
	days %= FOURYEARS;				// (days) = days into four year period
	r *= 4;							// (r) = years since 1980 (within 3)

	if (days == 31+28) {			// this many days into a 4-year period is feb 29
		//* Special case for FEB 29th
		pinfo->wDay = 29;
		pinfo->wMonth = 2;
	} else {
		if (days > 31+28)
			--days;						// compensate for leap year
		while (days >= 365) {
			++r;
			days -= 365;
		}

		for (secs = 1; days >= MonTotal[secs+1] ; ++secs)
			;
		days -= MonTotal[secs];

		pinfo->wDay = days + 1;
		pinfo->wMonth = (unsigned short) secs;
	}

	pinfo->wYear = r + 1980;
}


DWORD
SystemToNetDate(LPSYSTEMTIME pinfo)
{
    UINT days, secs;

	days = pinfo->wYear - 1980;
	days = days*365 + days/4;			// # of years in days
	days += pinfo->wDay + MonTotal[pinfo->wMonth];
	if (!(pinfo->wYear % 4)
		&& pinfo->wMonth <= 2)
		--days;						// adjust days for early in leap year

	secs = (((pinfo->wHour * 60) + pinfo->wMinute) * 60) + pinfo->wSecond;
	return days*SECS_IN_DAY + _70_to_80_bias + secs;
}


DWORD
GetCurrentNetDate(void)
{
	SYSTEMTIME st;

	GetSystemTime(&st);

	return SystemToNetDate(&st);
}


DWORD
GetLocalNetDate(void)
{
	SYSTEMTIME st;

	GetLocalTime(&st);

	return SystemToNetDate(&st);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\initstr.cpp ===
/*****************************************************************/
/**				  Microsoft Internet Explorer   				**/
/**		      Copyright (C) Microsoft Corp., 1997   			**/
/*****************************************************************/ 

/* INITSTR -- Initialize string library
 *
 * History:
 *	08/11/97	gregj	Created
 */

#include "npcommon.h"

BOOL fDBCSEnabled = FALSE;

void WINAPI InitStringLibrary(void)
{
    ::fDBCSEnabled = ::GetSystemMetrics(SM_DBCSENABLED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\istr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	istr.cxx
	NLS/DBCS-aware string class: string index class

	This file contains the core implementation of the string
	indexer class.

	FILE HISTORY:
		gregj	03/30/93	Removed ISTR to separate module
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:      ISTR::ISTR

	SYNOPSIS:  ISTR construction methods

	ENTRY:
		ISTR::ISTR( ISTR& ) - Copy passed ISTR (both string and positional
							  info is copied).

		ISTR::ISTR( IB, NLS_STR& ) - Private, create an ISTR with index
									 at IB for string NLS_STR

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/20/90	Created

********************************************************************/

ISTR::ISTR( const ISTR& istr )
{
	*this = istr;
}


ISTR::ISTR( const NLS_STR& nls )
{
	*this = nls;
}


/*******************************************************************

	NAME:		ISTR::operator=

	SYNOPSIS:	Copy operator for the ISTR class

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		Johnl	11/20/90	Created
		gregj	03/30/93	Allow assignment of NLS_STR to ISTR

********************************************************************/

ISTR& ISTR::operator=( const ISTR& istr )
{
	_ibString = istr._ibString;
	SetPNLS( (NLS_STR *) istr.QueryPNLS() );
#ifdef DEBUG
	_usVersion = istr._usVersion;
#endif
	return *this;
}


ISTR& ISTR::operator=( const NLS_STR& nls )
{
	_ibString = 0;
	SetPNLS( &nls );
#ifdef DEBUG
	_usVersion = nls.QueryVersion();
#endif
	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\dostime.cpp ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4 */

/***	dostime.cpp - map between DOS & NET time formats
 */

#include "npcommon.h"
#include <convtime.h>


#define YR_MASK		0xFE00
#define LEAPYR_MASK	0x0600
#define YR_BITS		7
#define MON_MASK	0x01E0
#define MON_BITS	4
#define DAY_MASK	0x001F
#define DAY_BITS	5

#define HOUR_MASK	0xF800
#define HOUR_BITS	5
#define MIN_MASK	0x07E0
#define MIN_BITS	6
#define SEC2_MASK	0x001F
#define SEC2_BITS	5

void
NetToDosDate(
DWORD time,
dos_time *pinfo)			// ptr for return data:
{
	UINT secs, days;
	WORD r;

    time = (time - _70_to_80_bias) / 2;	// # of 2 second periods since 1980
	secs = time % SEC2S_IN_DAY;			// 2 second period into day
	days = time / SEC2S_IN_DAY;			// days since Jan 1 1980

	r = secs % 30;					// # of 2 second steps
	secs /= 30;
	r |= (secs % 60) << SEC2_BITS;	// # of minutes
        r |= (secs / 60) << (SEC2_BITS+MIN_BITS);         // # of hours
	pinfo->dt_time = r;

	r = days / FOURYEARS;			// (r) = four year period past 1980
	days %= FOURYEARS;				// (days) = days into four year period
	r *= 4;							// (r) = years since 1980 (within 3)

	if (days == 31+28) {
		//* Special case for FEB 29th
		r = (r<<(MON_BITS+DAY_BITS)) + (2<<DAY_BITS) + 29;
	} else {
		if (days > 31+28)
			--days;						// compensate for leap year
		while (days >= 365) {
			++r;
			days -= 365;
		}

		for (secs = 1; days >= MonTotal[secs+1] ; ++secs)
			;
		days -= MonTotal[secs];
		r <<= MON_BITS;
		r += (unsigned short) secs;
		r <<= DAY_BITS;
		r += (unsigned short) days+1;
	}
	pinfo->dt_date = r;
}


DWORD
DosToNetDate(dos_time dt)
{
    UINT days, secs2;

        days = dt.dt_date >> (MON_BITS + DAY_BITS);
	days = days*365 + days/4;			// # of years in days
	days += (dt.dt_date & DAY_MASK) + MonTotal[(dt.dt_date&MON_MASK) >> DAY_BITS];
	if ((dt.dt_date&LEAPYR_MASK) == 0
				&& (dt.dt_date&MON_MASK) <= (2<<DAY_BITS))
		--days;						// adjust days for early in leap year

        secs2 = ( ((dt.dt_time&HOUR_MASK) >> (MIN_BITS+SEC2_BITS)) * 60
				+ ((dt.dt_time&MIN_MASK) >> SEC2_BITS) ) * 30
				+ (dt.dt_time&SEC2_MASK);
	return (DWORD)days*SECS_IN_DAY + _70_to_80_bias + (DWORD)secs2*2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\istraux.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	istraux.cpp
	NLS/DBCS-aware string class: secondary methods of index class

	This file contains the implementation of the auxiliary methods
	for the ISTR class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx
		beng	04/26/91	Relocated some funcs from string.hxx
		gregj	03/25/93	Ported to Chicago environment
		gregj	04/02/93	Use NLS_STR::IsDBCSLeadByte()
*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		ISTR::Reset

	SYNOPSIS:	Reset the ISTR so the index is 0;
				updates the version number of the string.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		Johnl	11/28/90	Created

********************************************************************/

VOID ISTR::Reset()
{
	_ibString = 0;
#ifdef DEBUG
	_usVersion = QueryPNLS()->QueryVersion();
#endif
}


/*******************************************************************

	NAME:		ISTR::operator-

	SYNOPSIS:	Returns the difference in CB between the two ISTR

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		Johnl	11/28/90	Created

********************************************************************/

INT ISTR::operator-( const ISTR& istr2 ) const
{
	UIASSERT( QueryPNLS() == istr2.QueryPNLS() );

	return ( QueryIB() - istr2.QueryIB() );
}


/*******************************************************************

	NAME:		ISTR::operator++

	SYNOPSIS:	Increment the ISTR to the next logical character

	ENTRY:

	EXIT:

	NOTES:		Stops if we are at the end of the string

	HISTORY:
		Johnl	11/28/90	Created
		beng	07/23/91	Simplified CheckIstr

********************************************************************/

ISTR& ISTR::operator++()
{
	QueryPNLS()->CheckIstr( *this );
	CHAR c = *(QueryPNLS()->QueryPch() + QueryIB());
	if ( c != '\0' )
	{
		SetIB( QueryIB() + (QueryPNLS()->IsDBCSLeadByte(c) ? 2 : 1) );
	}
	return *this;
}


/*******************************************************************

	NAME:		ISTR::operator+=

	SYNOPSIS:	Increment the ISTR to the nth logical character

	NOTES:		Stops if we are at the end of the string

	HISTORY:
		Johnl	01/14/90	Created

********************************************************************/

VOID ISTR::operator+=( INT iChars )
{
	while ( iChars-- )
		operator++();
}


/*******************************************************************

	NAME:		ISTR::operator==

	SYNOPSIS:	Equality operator

	RETURNS:	TRUE if the two ISTRs are equivalent.

	NOTES:		Only valid between two ISTRs of the same string.

	HISTORY:
		beng	07/22/91	Header added

********************************************************************/

BOOL ISTR::operator==( const ISTR& istr ) const
{
	UIASSERT( QueryPNLS() == istr.QueryPNLS() );
	return QueryIB() == istr.QueryIB();
}


/*******************************************************************

	NAME:		ISTR::operator>

	SYNOPSIS:	Greater-than operator

	RETURNS:	TRUE if this ISTR points further into the string
				than the argument.

	NOTES:		Only valid between two ISTRs of the same string.

	HISTORY:
		beng	07/22/91	Header added

********************************************************************/

BOOL ISTR::operator>( const ISTR& istr )  const
{
	UIASSERT( QueryPNLS() == istr.QueryPNLS() );
	return QueryIB() > istr.QueryIB();
}


/*******************************************************************

	NAME:		ISTR::operator<

	SYNOPSIS:	Lesser-than operator

	RETURNS:	TRUE if this ISTR points less further into the string
				than the argument.

	NOTES:		Only valid between two ISTRs of the same string.

	HISTORY:
		beng	07/22/91	Header added

********************************************************************/

BOOL ISTR::operator<( const ISTR& istr )  const
{
	UIASSERT( QueryPNLS() == istr.QueryPNLS() );
	return QueryIB() < istr.QueryIB();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\npassert.cpp ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/*
    uiassert.c
    Environment specific stuff for the UIASSERT & REQUIRE macro

    This file contains the environment specific (windows vs. OS/2/DOS)
    features of the assert macro, specifically, the output method
    (everything is hidden by the standard C-Runtime).

    FILE HISTORY:
        johnl       10/17/90    Created
        johnl       10/18/90    Added OutputDebugString
        beng        04/30/91    Made a 'C' file
        beng        08/05/91    Withdrew expressions; reprototyped
                                all functions
        beng        09/17/91    Withdrew additional consistency checks
        beng        09/26/91    Withdrew nprintf calls
        gregj       03/23/93    Ported to Chicago environment
*/

#include "npcommon.h"
#include "npassert.h"

extern "C" {

const CHAR szShouldBeAnsi[] = "String should be ANSI but isn't";
const CHAR szShouldBeOEM[] = "String should be OEM but isn't";

static CHAR szFmt0[] = "File %.40s, Line %u";
static CHAR szFmt1[] = "%.60s: File %.40s, Line %u";
static CHAR szMBCaption[] = "ASSERTION FAILED";
static CHAR szFAE[] = "ASSERTION FAILURE IN APP";

VOID UIAssertHelper(
    const CHAR* pszFileName,
    UINT    nLine )
{
    CHAR szBuff[sizeof(szFmt0)+60+40];

    wsprintf(szBuff, szFmt0, pszFileName, nLine);
    MessageBox(NULL, szBuff, szMBCaption,
           (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    FatalAppExit(0, szFAE);
}


VOID UIAssertSzHelper(
    const CHAR* pszMessage,
    const CHAR* pszFileName,
    UINT    nLine )
{
    CHAR szBuff[sizeof(szFmt1)+60+40];

    wsprintf(szBuff, szFmt1, pszMessage, pszFileName, nLine);
    MessageBox(NULL, szBuff, szMBCaption,
           (MB_TASKMODAL | MB_ICONSTOP | MB_OK) );

    FatalAppExit(0, szFAE);
}

//========== Debug output routines =========================================

UINT uiNetDebugMask = 0xffff;

UINT WINAPI NetSetDebugMask(UINT mask)
{
#ifdef DEBUG
    UINT uiOld = uiNetDebugMask;
    uiNetDebugMask = mask;

    return uiOld;
#else
    return 0;
#endif
}

UINT WINAPI NetGetDebugMask()
{
#ifdef DEBUG
    return uiNetDebugMask;
#else
    return 0;
#endif
}

#ifndef WINCAPI
#ifdef WIN32
#define WINCAPI __cdecl
#else
#define WINCAPI __far __cdecl
#endif
#endif

#ifdef DEBUG

/* debug message output log file */

UINT 	g_uSpewLine = 0;
PCSTR 	g_pcszSpewFile = NULL;
CHAR	s_cszLogFile[MAX_PATH] = {'\0'};
CHAR	s_cszDebugName[MAX_PATH] = {'\0'};

UINT WINAPI  NetSetDebugParameters(PSTR pszName,PSTR pszLogFile)
{
	lstrcpy(s_cszLogFile,pszLogFile);
	lstrcpy(s_cszDebugName,pszName);

	return 0;
}


BOOL LogOutputDebugString(PCSTR pcsz)
{
   BOOL 	bResult = FALSE;
   UINT 	ucb;
   char 	rgchLogFile[MAX_PATH];

   if (IS_EMPTY_STRING(s_cszLogFile) )
	   return FALSE;

   ucb = GetWindowsDirectory(rgchLogFile, sizeof(rgchLogFile));

   if (ucb > 0 && ucb < sizeof(rgchLogFile)) {

      HANDLE hfLog;

      lstrcat(rgchLogFile, "\\");
      lstrcat(rgchLogFile, s_cszLogFile);

      hfLog = ::CreateFile(rgchLogFile,
						   GENERIC_WRITE,
						   0,
						   NULL,
						   OPEN_ALWAYS,
						   0,
						   NULL);

      if (hfLog != INVALID_HANDLE_VALUE) {

         if (SetFilePointer(hfLog, 0, NULL, FILE_END) != INVALID_FILE_SIZE) {
            DWORD dwcbWritten;

            bResult = WriteFile(hfLog, pcsz, lstrlen(pcsz), &dwcbWritten, NULL);

            if (! CloseHandle(hfLog) && bResult)
               bResult = FALSE;
         }
      }
   }

   return(bResult);
}

CHAR	*achDebugDisplayPrefix[] = {"t ","w ","e ","a ","t ","t ","t ","t ","t ","t ","t "};

void WINCAPI NetDebugMsg(UINT mask, LPCSTR pszMsg, ...)
{
    char 	ach[1024];
	UINT	uiDisplayMask = mask & 0xff;

	// Determine prefix
	*ach = '\0';
	if (uiNetDebugMask & DM_PREFIX) {
		// Add trace type
		::lstrcat(ach,achDebugDisplayPrefix[uiDisplayMask]);

		// Add component name
		::lstrcat(ach,s_cszDebugName);

		// Add thread ID
		CHAR	szThreadId[16];
		::wsprintf(szThreadId,"[%#lx] ",::GetCurrentThreadId());
		::lstrcat(ach,szThreadId);
	}

    ::wvsprintf(ach+::lstrlen(ach), pszMsg, (va_list)((&pszMsg) + 1));
	::lstrcat(ach,"\r\n");

	if (uiNetDebugMask & DM_LOG_FILE) {
		 LogOutputDebugString(ach);
	}

	// Check if we need to display this trace
    if (uiNetDebugMask & uiDisplayMask) {
        OutputDebugString(ach);
    }
}

#endif

}   /* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\npcommon.h ===
#include <npdefs.h>
#include <netlib.h>

#define ADVANCE(p)    (p += IS_LEAD_BYTE(*p) ? 2 : 1)

#define SPN_SET(bits,ch)    bits[(ch)/8] |= (1<<((ch) & 7))
#define SPN_TEST(bits,ch)    (bits[(ch)/8] & (1<<((ch) & 7)))

// The following is created to avoid an alignment fault on Win64 platforms.
inline UINT GetTwoByteChar( LPCSTR lpString )
{
    BYTE        bFirst = *lpString;

    lpString++;

    BYTE        bSecond = *lpString;

    UINT        uiChar = ( bFirst << 8) | bSecond;

    return uiChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\iconlbox.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1993                         **/
/***************************************************************************/

/****************************************************************************

    ICONLBOX.C

    Implementation for IconListBox class

    May 93, JimH

    See ICONLBOX.H for details on use.

****************************************************************************/

#include "npcommon.h"
#include <windows.h>
#include <memory.h>
#include <iconlbox.h>

#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>


/****************************************************************************

IconListBox constructor

Some initialization is done here, and some is done in SetHeight
(when window handles are known.)

****************************************************************************/

IconListBox::IconListBox(HINSTANCE hInst, int nCtlID,
                    int iconWidth, int iconHeight) :
                    _nCtlID(nCtlID), _hInst(hInst),
                    _iconWidth(iconWidth), _iconHeight(iconHeight),
                    _hbrSelected(NULL), _hbrUnselected(NULL),
                    _fCombo(FALSE), _cIcons(0), _cTabs(0),_iCurrentMaxHorzExt(0),
                    _hwndDialog(NULL), _hwndListBox(NULL)
{
    _colSel       = ::GetSysColor(COLOR_HIGHLIGHT);
    _colSelText   = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
    _colUnsel     = ::GetSysColor(COLOR_WINDOW);
    _colUnselText = ::GetSysColor(COLOR_WINDOWTEXT);
}


/****************************************************************************

IconListBox destructor

deletes any GDI objects created by IconListBox

****************************************************************************/

IconListBox::~IconListBox()
{
    for (int i = 0; i < _cIcons; i++)
    {
        if (_aIcons[i].hbmSelected)
        {
            if (_aIcons[i].hbmSelected)
            {
                ::DeleteObject(_aIcons[i].hbmSelected);
                ::DeleteObject(_aIcons[i].hbmUnselected);
            }

            // Subsequent _aIcons may have used the same bitmap.
            // Mark those as already deleted.

            for (int j = i + 1; j < _cIcons; j++)
            {
                if (_aIcons[j].nResID == _aIcons[i].nResID)
                {
                    _aIcons[j].hbmSelected = NULL;
                    _aIcons[j].hbmUnselected = NULL;
                }
            }
        }
    }

    if (_hbrSelected)
        ::DeleteObject(_hbrSelected);

    if (_hbrUnselected)
        ::DeleteObject(_hbrUnselected);
}


/****************************************************************************

IconListBox::SetHeight

This function MUST be called in reponse to the WM_MEASUREITEM message.
It creates some GDI objects, and initializes class variables not known
at construction time.

****************************************************************************/

void IconListBox::SetHeight(HWND hwndDlg,
                        LPMEASUREITEMSTRUCT lpm,
                        int itemHeight)             // defaults to 16
{
    ASSERT(hwndDlg != NULL);
    ASSERT((int)lpm->CtlID == _nCtlID);

    _hwndDialog  = hwndDlg;
    _hwndListBox = ::GetDlgItem(_hwndDialog, _nCtlID);

    // Determine if this is a combo box

    char    szClass[32];
    GetClassName(_hwndListBox,szClass,sizeof(szClass));
    if (::lstrcmpi(szClass,"combobox") == 0 )
         _fCombo = TRUE;


    // Create the background brushes used for filling listbox entries...

    _hbrSelected   = ::CreateSolidBrush(_colSel);
    _hbrUnselected = ::CreateSolidBrush(_colUnsel);

    // Calculate how to centre the text vertically in the listbox item.

    TEXTMETRIC  tm;
    HDC         hDC = ::GetDC(hwndDlg);

    GetTextMetrics(hDC, &tm);

    // Set the only lpm entry that matters

	// allow larger height if passed in - but at least large enough
	// to fit font.

	lpm->itemHeight = max( itemHeight, tm.tmHeight + tm.tmExternalLeading );

    _nTextOffset = tm.tmExternalLeading / 2 + 1;

    ::ReleaseDC(hwndDlg, hDC);
}


/****************************************************************************

IconListBox::DrawItem

This function MUST be called in response to the WM_DRAWITEM message.
It takes care of drawing listbox items in selected or unselected state.

Drawing and undrawing the focus rectangle takes advantage of the fact
that DrawFocusRect uses an XOR pen, and Windows is nice enough to assume
this in the order of the ODA_FOCUS messages.

****************************************************************************/

void IconListBox::DrawItem(LPDRAWITEMSTRUCT lpd)
{
    ASSERT(_hwndDialog != NULL);    // make sure SetHeight has been called

    char string[MAXSTRINGLEN];
    BOOL bSelected = (lpd->itemState & ODS_SELECTED);

    GetString(lpd->itemID, string);

    // fill entire rectangle with background color

    ::FillRect(lpd->hDC, &(lpd->rcItem),
                            bSelected ? _hbrSelected : _hbrUnselected);

    // Look for registered icon to display, and paint it if found

    for (int id = 0; id < _cIcons; id++)
        if (_aIcons[id].nID == (int) lpd->itemData)
            break;

    if (id != _cIcons)              // if we found a bitmap to display
    {
        HDC hdcMem = ::CreateCompatibleDC(lpd->hDC);
        HBITMAP hOldBitmap = (HBITMAP)::SelectObject(hdcMem,
            bSelected ? _aIcons[id].hbmSelected : _aIcons[id].hbmUnselected);

        // draw bitmap ICONSPACE pixels from left and centred vertically

        int x = lpd->rcItem.left + ICONSPACE;
        int y = ((lpd->rcItem.bottom - lpd->rcItem.top) - _iconHeight) / 2;
        y += lpd->rcItem.top;

        ::BitBlt(lpd->hDC, x, y, _iconWidth, _iconHeight, hdcMem,
                    _aIcons[id].x, _aIcons[id].y, SRCCOPY);

        ::SelectObject(hdcMem, hOldBitmap);
        ::DeleteDC(hdcMem);
    }

	if (lpd->itemState & ODS_FOCUS)
        ::DrawFocusRect(lpd->hDC, &(lpd->rcItem));


    lpd->rcItem.left += (_iconWidth + (2 * ICONSPACE));

    // Paint string

    ::SetTextColor(lpd->hDC, bSelected ? _colSelText : _colUnselText);
    ::SetBkColor(lpd->hDC, bSelected ? _colSel : _colUnsel);
    (lpd->rcItem.top) += _nTextOffset;

    if (_cTabs == 0)        // if no tabs registered
    {
        ::DrawText(lpd->hDC, string, lstrlen(string), &(lpd->rcItem),
                        DT_LEFT | DT_EXPANDTABS);
    }
    else
    {
        ::TabbedTextOut(lpd->hDC, lpd->rcItem.left, lpd->rcItem.top,
                string, lstrlen(string), _cTabs, _aTabs, 0);
    }
}


/****************************************************************************

IconListBox::RegisterIcons

Icons must be registered before they can be referenced in AddString.

Note that if you are using several icons from the same bitmap (with different
x and y offsets) they must all have the same background color.

****************************************************************************/

void IconListBox::RegisterIcon( int nIconID,            // caller's code
                                int nResID,             // RC file id
                                int x, int y,           // top left corner
                                COLORREF colTransparent)  // def. bright green
{
    ASSERT( _cIcons < MAXICONS );

    _aIcons[_cIcons].nID    = nIconID;
    _aIcons[_cIcons].nResID = nResID;
    _aIcons[_cIcons].x = x;
    _aIcons[_cIcons].y = y;

    // Check to see if we already have bitmaps for this resource ID
    // (which may have different x and y offsets.)

    for (int i = 0; i < _cIcons; i++)
    {
        if (_aIcons[i].nResID == nResID)
        {
            _aIcons[_cIcons].hbmSelected   = _aIcons[i].hbmSelected;
            _aIcons[_cIcons].hbmUnselected = _aIcons[i].hbmUnselected;
            _cIcons++;
            return;
        }
    }

    // Otherwise, create new selected and unselected bitmaps

    // Get pointer to DIB

    HRSRC h = ::FindResource(_hInst, MAKEINTRESOURCE(nResID), RT_BITMAP);
    if (h == NULL)
        return;

    HANDLE hRes = ::LoadResource(_hInst, h);
    if (hRes == NULL)
        return;

    LPBITMAPINFOHEADER lpInfo = (LPBITMAPINFOHEADER) LockResource(hRes);
    if (NULL == lpInfo)
        return;

    // Get pointers to start of color table, and start of actual bitmap bits

    // Note that we make a copy of the bitmap header info and the color
    // table.  This is so applications that use iconlistbox can keep their
    // resource segments read only.

    LPBYTE lpBits = (LPBYTE)
                (lpInfo + 1) + (1 << (lpInfo->biBitCount)) * sizeof(RGBQUAD);

    int cbCopy = (int) (lpBits - (LPBYTE)lpInfo);

    BYTE *lpCopy = new BYTE[cbCopy];

    if (!lpCopy)
        return;

    memcpy(lpCopy, lpInfo, cbCopy);

    RGBQUAD FAR *lpRGBQ =
                    (RGBQUAD FAR *) ((LPSTR)lpCopy + lpInfo->biSize);

    // Find transparent color in color table

    BOOL bFound = FALSE;            // did we find a transparent match?

    int nColorTableSize = (int) (lpBits - (LPBYTE)lpRGBQ);
    nColorTableSize /= sizeof(RGBQUAD);

    for (i = 0; i < nColorTableSize; i++)
    {
        if (colTransparent ==
                RGB(lpRGBQ[i].rgbRed, lpRGBQ[i].rgbGreen, lpRGBQ[i].rgbBlue))
        {
            bFound = TRUE;
            break;
        }
    }

    // Replace the transparent color with the background for selected and
    // unselected entries.  Use these to create selected and unselected
    // bitmaps, and restore color table.

    RGBQUAD rgbqTemp;                       // color table entry to replace
    HDC hDC = ::GetDC(_hwndDialog);

    if (bFound)
    {
        rgbqTemp = lpRGBQ[i];
        lpRGBQ[i].rgbRed   = GetRValue(_colUnsel);
        lpRGBQ[i].rgbBlue  = GetBValue(_colUnsel);
        lpRGBQ[i].rgbGreen = GetGValue(_colUnsel);
    }
    _aIcons[_cIcons].hbmUnselected = ::CreateDIBitmap(hDC,
                            (LPBITMAPINFOHEADER)lpCopy, CBM_INIT, lpBits,
                            (LPBITMAPINFO)lpCopy, DIB_RGB_COLORS);

    if (bFound)
    {
        lpRGBQ[i].rgbRed   = GetRValue(_colSel);
        lpRGBQ[i].rgbBlue  = GetBValue(_colSel);
        lpRGBQ[i].rgbGreen = GetGValue(_colSel);
    }
    _aIcons[_cIcons].hbmSelected = ::CreateDIBitmap(hDC,
                            (LPBITMAPINFOHEADER)lpCopy, CBM_INIT, lpBits,
                            (LPBITMAPINFO)lpCopy, DIB_RGB_COLORS);

    if (bFound)
        lpRGBQ[i] = rgbqTemp;           // restore original color table entry

    ::ReleaseDC(_hwndDialog, hDC);
    ::FreeResource(hRes);
    delete [] lpCopy;

    _cIcons++;
}


/****************************************************************************

IconListBox::SetTabStops

Since this is an owner-draw listbox, we can't rely on LB_SETTABS.
Instead, tabs are registered here and TabbedTextOut is used to display
strings.  Dialogbox units have to be converted to pixels.

****************************************************************************/

void IconListBox::SetTabStops(int cTabs, const int *pTabs)
{
    ASSERT(cTabs <= MAXTABS);

    int nSize  = (int) LOWORD(GetDialogBaseUnits());

    for (int i = 0; i < cTabs; i++)
        _aTabs[i] = ((nSize * pTabs[i]) / 4);

    _cTabs = cTabs;
}

/****************************************************************************

IconListBox::UpdateHorizontalExtent

****************************************************************************/
int IconListBox::UpdateHorizontalExtent(int	nIcon,const char *string)
{
    ASSERT(_hwndDialog != NULL);    // make sure SetHeight has been called

	if (!string)
		return 0;
	// Calculate width in pixels for given string, taking into account icon, spacing and tabs
    int iItemWidth = ICONSPACE + (_iconWidth + (2 * ICONSPACE));
    HDC	hDC = ::GetDC(_hwndDialog);
	iItemWidth += LOWORD(GetTabbedTextExtent(hDC,string,::lstrlen(string),_cTabs, _aTabs));
    ::ReleaseDC(_hwndDialog, hDC);

	// Update maximum value
    _iCurrentMaxHorzExt = max(_iCurrentMaxHorzExt,iItemWidth);

	return (int)SendDlgItemMessage(_hwndDialog,_nCtlID,
								LB_SETHORIZONTALEXTENT,
								(WPARAM)_iCurrentMaxHorzExt,0L);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\npcrit.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1993-1994			**/
/*****************************************************************/ 

/* npcrit.c -- Implementation of critical section classes.
 *
 * History:
 *	11/01/93	gregj	Created
 */

#include "npcommon.h"
#include <npcrit.h>
#include <npassert.h>

/*
 * Very simple interlock routines, used to stop race conditions when
 * initializing and de-initializing critical sections.  Do NOT use
 * these for anything other than infrequent extremely short-term locks, 
 * since WaitForInterlock contains a spin loop with a millisecond delay!
 */
BYTE InterlockedSet(volatile BYTE *pByte)
{
	BYTE bRet;
	_asm {
		mov		edi, pByte
		mov		al, 1
		xchg	[edi], al		/* store non-zero value, get what was there before */
		mov		bRet, al
	}
	return bRet;
}

void WaitForInterlock(volatile BYTE *pByte)
{
	for (;;) {
		BYTE bAlreadyOwned = InterlockedSet(pByte);	/* attempt to grab the interlock */
		if (!bAlreadyOwned)				/* is someone else in there? */
			break;						/* nope, we now own it */
		Sleep(1);						/* yield to whomever owns it, then try again */
	}
}

void ReleaseInterlock(volatile BYTE *pByte)
{
	*pByte = 0;							/* clear the interlock to release others */
}

#if 0
// Remove CRITSEC code but keep for a while before deleting.
/*******************************************************************

    NAME:		CRITSEC::Init

    SYNOPSIS:	Initializes a global critical section object

    ENTRY:		pszName - name for the critical section

    EXIT:		No return value

    NOTES:		Currently pszName is not used;  it will be used
				for named mutexes later.

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Init(char *pszName)
{
	WaitForInterlock(&_bInterlock);
	if (!_fInitialized) {
		::InitializeCriticalSection(&_critsec);
#ifdef DEBUG
		_wClaimCount = 0;
#endif
		_fInitialized = 1;
	}
	ReleaseInterlock(&_bInterlock);
	_cClients++;
}


/*******************************************************************

    NAME:		CRITSEC::Term

    SYNOPSIS:	Cleans up resources allocated for a critical section

    ENTRY:		No parameters

    EXIT:		No return value

    NOTES:		This function should be callled at process attach.
				It will take care of making sure it only deletes
				the critical section when the last process using
				it calls Term().

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Term()
{
	WaitForInterlock(&_bInterlock);
	BOOL fShouldCleanUp = (--_cClients == 0);
	if (fShouldCleanUp) {
		::DeleteCriticalSection(&_critsec);
		_fInitialized = 0;
	}
	ReleaseInterlock(&_bInterlock);
}


#ifdef DEBUG		/* in retail, these are inline */
/*******************************************************************

    NAME:		CRITSEC::Enter

    SYNOPSIS:	Enters a critical section

    ENTRY:		No parameters

    EXIT:		No return value;  critical section is owned by
				the calling thread

    NOTES:		This function is private, and is invoked indirectly
				by the friend class TAKE_CRITSEC.

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Enter()
{
#ifdef DEBUG
	UIASSERT(_fInitialized != 0);
#endif

	::EnterCriticalSection(&_critsec);

#ifdef DEBUG
	_wClaimCount++;
#endif
}


/*******************************************************************

    NAME:		CRITSEC::Leave

    SYNOPSIS:	Leaves a critical section

    ENTRY:		No parameters

    EXIT:		No return value;  critical section is released

    NOTES:		This function is private, and is invoked indirectly
				by the friend class TAKE_CRITSEC.

    HISTORY:
		gregj	11/01/93	Created

********************************************************************/

void CRITSEC::Leave()
{
#ifdef DEBUG
	UIASSERT(_fInitialized != 0);
	UIASSERT(_wClaimCount > 0);
	_wClaimCount--;
#endif

	::LeaveCriticalSection(&_critsec);
}
#endif	/* DEBUG */
#endif	/* 0 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\purecall.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* PURECALL.C -- Implementation of __purecall function.
 *
 * History:
 *	04/11/94	gregj	Created
 */

#include "npcommon.h"

extern "C" {

/*
 * This function serves to avoid linking CRT code like assert etc.
 * we really don;t do anything when pure virtual function is not redefined
 */

int __cdecl  _purecall(void)
{
#ifdef DEBUG
	DebugBreak();
#endif

	return(FALSE);
}

int __cdecl atexit(void (__cdecl *)(void))
{
	return 0;
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\npgenerr.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* NPGENERR.C -- Implementation of the DisplayGenericError subroutine.
 *
 * History:
 *	10/07/93	gregj	Created
 */

#include "npcommon.h"
#include "npmsg.h"
#include "npstring.h"

/*******************************************************************

	NAME:		DisplayGenericError

	SYNOPSIS:	Displays an error message, substituting in a
				description of an error code.

	ENTRY:		hwnd - parent window handle
				msg  - string ID for message template
				err  - error code to substitute in
				psz1 - main substitution string
				psz2 - error code substitution string
				wFlags - flags to MessageBox
				nMsgBase - bias for error code

	EXIT:		Returns control ID of user's choice

	NOTES:		nMsgBase is so that the error code need not
				be the same as the string ID.  It is added to
				the error code before loading the description,
				but the error code alone is the number inserted
				into the template.

				The text for "msg" should be of the form:

				The following error occurred while trying to fiddle with %1:

				Error %2: %3

				Do you want to continue fiddling?

				The text for "err" (+nMsgBase if appropriate) should
				be of the form:

				%1 cannot be fiddled with.

				In the primary message, %1 is replaced with psz1, %2
				is replaced with atoi(err), and %3 is replaced with
				a LoadString of "err".  In the specific error text,
				%1 is replaced with psz2.

	HISTORY:
		gregj	09/30/93	Created for Chicago

********************************************************************/

UINT DisplayGenericError(HWND hwnd, UINT msg, UINT err, LPCSTR psz1, LPCSTR psz2,
						 WORD wFlags, UINT nMsgBase)
{
	/*
	 * setup the object name
	 */
	NLS_STR nlsObjectName(STR_OWNERALLOC, (LPSTR)psz1);

	/*
	 * now the error number
	 */
	CHAR szErrorCode[16];
	wsprintf(szErrorCode,"%u",err);
	NLS_STR nlsErrorCode(STR_OWNERALLOC, szErrorCode);

	/*
	 * fetch the error string. If cannot get, use "".
	 */
	NLS_STR nlsSub1(STR_OWNERALLOC, (LPSTR)psz2);

	NLS_STR *apnlsParamStrings[4];
	apnlsParamStrings[0] = &nlsSub1;
	apnlsParamStrings[1] = NULL;

	NLS_STR nlsErrorString(NULL) ;
	nlsErrorString.LoadString(err + nMsgBase, (const NLS_STR **)apnlsParamStrings);
	err = nlsErrorString.QueryError() ;
	if (err)
		nlsErrorString = (const CHAR *)NULL;

	/*
	 * then create the insert strings table
	 */
	apnlsParamStrings[0] = &nlsObjectName;
	apnlsParamStrings[1] = &nlsErrorCode;
	apnlsParamStrings[2] = &nlsErrorString;
	apnlsParamStrings[3] = NULL;

    return MsgBox(hwnd, msg, wFlags, (const NLS_STR **)apnlsParamStrings);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\sched.cpp ===
/*****************************************************************/
/**		      	Copyright (C) Microsoft Corp., 1994				**/
/*****************************************************************/ 

/* SCHED.C -- Miscellaneous scheduling helpers
 *
 * History:
 *	gregj	10/17/94	created
 */


#include "npcommon.h"
#include <sched.h>

/* FlushInputQueue is a private routine to collect and dispatch all
 * messages in the input queue.  It returns TRUE if a WM_QUIT message
 * was detected in the queue, FALSE otherwise.
 */
BOOL FlushInputQueue(volatile DWORD *pidOtherThread)
{
	MSG msgTemp;
	while (PeekMessage(&msgTemp, NULL, 0, 0, PM_REMOVE)) {
		DispatchMessage(&msgTemp);

		// If we see a WM_QUIT in the queue, we need to do the same
		// sort of thing that a modal dialog does:  break out of our
		// waiting, and repost the WM_QUIT to the queue so that the
		// next message loop up in the app will also see it.  We also
		// post the message to the server thread's queue so that any
		// dialog stack displayed there will be destroyed as well.
		if (msgTemp.message == WM_QUIT) {
			if (pidOtherThread != NULL && *pidOtherThread != NULL) {
				PostThreadMessage(*pidOtherThread, msgTemp.message, msgTemp.wParam, msgTemp.lParam);
			}
			PostQuitMessage((int)msgTemp.wParam);
			return TRUE;
		}
	}
	return FALSE;
}


/* WaitAndYield() waits for the specified object using
 * MsgWaitForMultipleObjects.  If messages are received,
 * they are dispatched and waiting continues.  The return
 * value is the same as from MsgWaitForMultipleObjects.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread /* = NULL */)
{
	DWORD dwTickCount, dwWakeReason, dwTemp;

	do {
		/* Flush any messages before we wait.  This is because
		 * MsgWaitForMultipleObjects will only return when NEW
		 * messages are put in the queue.
		 */
		if (FlushInputQueue(pidOtherThread)) {
			dwWakeReason = WAIT_TIMEOUT;
			break;
		}

    	// in case we handle messages, we want close to a true timeout
   		if ((dwTimeout != 0) && 
			(dwTimeout != (DWORD)-1)) {
   			// if we can timeout, store the current tick count
    		// every time through
   			dwTickCount = GetTickCount();
		}
		dwWakeReason = MsgWaitForMultipleObjects(1,
												 &hObject,
												 FALSE,
												 dwTimeout,
												 QS_ALLINPUT);
	    // if we got a message, dispatch it, then try again
	    if (dwWakeReason == 1) {
			// if we can timeout, see if we did before processing the message
			// that way, if we haven't timed out yet, we'll get at least one
			// more shot at the event
			if ((dwTimeout != 0) && 
			    (dwTimeout != (DWORD)-1)) {
			    if ((dwTemp = (GetTickCount()-dwTickCount)) >= dwTimeout) {
					// if we timed out, make us drop through
					dwWakeReason = WAIT_TIMEOUT;
				} else {
					// subtract elapsed time from timeout and continue
					// (we don't count time spent dispatching message)
					dwTimeout -= dwTemp;
				}
			}
			if (FlushInputQueue(pidOtherThread)) {
				dwWakeReason = WAIT_TIMEOUT;
				break;
			}
	    }
	} while (dwWakeReason == 1);

	return dwWakeReason;
}


/* WaitAndProcessSends is similar to WaitAndYield, but it only processes
 * SendMessage messages, not input messages.
 */
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout)
{
	DWORD dwWakeReason;

	do {
		dwWakeReason = MsgWaitForMultipleObjects(1,
												 &hObject,
												 FALSE,
												 dwTimeout,
												 QS_SENDMESSAGE);
	    // if we got a message, yield, then try again
	    if (dwWakeReason == 1) {
			MSG msgTemp;
			PeekMessage(&msgTemp, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD);
	    }
	} while (dwWakeReason == 1);

	return dwWakeReason;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\regentry.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	regentry.cxx
	registry access

	This file contains those routines which enable net providers to
    conveniently access the registry for their entries.

	FILE HISTORY:
		lens	03/15/94	Created
*/

#include "npcommon.h"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>
#include <regentry.h>

RegEntry::RegEntry(const char *pszSubKey, HKEY hkey)
{
	_error = RegCreateKey(hkey, pszSubKey, &_hkey);
	if (_error) {
		bhkeyValid = FALSE;
	}
	else {
		bhkeyValid = TRUE;
	}
}

RegEntry::~RegEntry()
{ 
    if (bhkeyValid) {
        RegCloseKey(_hkey); 
    }
}

long RegEntry::SetValue(const char *pszValue, const char *string)
{
    if (bhkeyValid) {
    	_error = RegSetValueEx(_hkey, pszValue, 0, REG_SZ,
    				(unsigned char *)string, lstrlen(string)+1);
    }
	return _error;
}

long RegEntry::SetValue(const char *pszValue, unsigned long dwNumber)
{
    if (bhkeyValid) {
    	_error = RegSetValueEx(_hkey, pszValue, 0, REG_BINARY,
    				(unsigned char *)&dwNumber, sizeof(dwNumber));
    }
	return _error;
}

long RegEntry::DeleteValue(const char *pszValue)
{
    if (bhkeyValid) {
    	_error = RegDeleteValue(_hkey, (LPTSTR) pszValue);
	}
	return _error;
}


char *RegEntry::GetString(const char *pszValue, char *string, unsigned long length)
{
	DWORD 	dwType = REG_SZ;
	
    if (bhkeyValid) {
    	_error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)string,
    				&length);
    }
	if (_error)
		*string = '\0';

	return string;
}

long RegEntry::GetNumber(const char *pszValue, long dwDefault)
{
 	DWORD 	dwType = REG_BINARY;
 	long	dwNumber = 0L;
 	DWORD	dwSize = sizeof(dwNumber);

    if (bhkeyValid) {
    	_error = RegQueryValueEx(_hkey, (LPTSTR) pszValue, 0, &dwType, (LPBYTE)&dwNumber,
    				&dwSize);
	}
	if (_error)
		dwNumber = dwDefault;
	
	return dwNumber;
}

VOID RegEntry::GetValue(const char *pszValueName, NLS_STR *pnlsString)
{
	DWORD 	dwType = REG_SZ;
    DWORD   length = 0;
    CHAR *  string = NULL;
    BOOL    bReallocDoneOK = FALSE;

    if (bhkeyValid) {
        _error = RegQueryValueEx( _hkey,
                                  (LPTSTR) pszValueName,
                                  0,
                                  &dwType,
                                  NULL,
                                  &length );
    	if (_error == ERROR_SUCCESS) {
            if (!pnlsString->IsOwnerAlloc()) {
                bReallocDoneOK = pnlsString->realloc(length);
            }
            else if (length <= (UINT)pnlsString->QueryAllocSize()) {
                bReallocDoneOK = TRUE;
            }
            else {
                _error = ERROR_MORE_DATA;
            }
        }
    	string = pnlsString->Party();
        if (bReallocDoneOK) {
        	_error = RegQueryValueEx( _hkey,
                                      (LPTSTR) pszValueName,
                                      0,
                                      &dwType,
                                      (LPBYTE) string,
                                      &length );
            if (_error == ERROR_SUCCESS) {
                if ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) {
                    _error = ERROR_INVALID_PARAMETER;
                }
            }
        }
        else {
            _error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    if (_error != ERROR_SUCCESS) {
        if (string != NULL) {
    		*string = '\0';
        }
    }
    pnlsString->DonePartying();
}

VOID RegEntry::MoveToSubKey(const char *pszSubKeyName)
{
    HKEY	_hNewKey;

    if (bhkeyValid) {
        _error = RegOpenKey ( _hkey,
                              pszSubKeyName,
                              &_hNewKey );
        if (_error == ERROR_SUCCESS) {
            RegCloseKey(_hkey);
            _hkey = _hNewKey;
        }
    }
}

long RegEntry::FlushKey()
{
    if (bhkeyValid) {
    	_error = RegFlushKey(_hkey);
    }
	return _error;
}

RegEnumValues::RegEnumValues(RegEntry *pReqRegEntry)
 : pRegEntry(pReqRegEntry),
   iEnum(0),
   pchName(NULL),
   pbValue(NULL)
{
    _error = pRegEntry->GetError();
    if (_error == ERROR_SUCCESS) {
        _error = RegQueryInfoKey ( pRegEntry->GetKey(), // Key
                                   NULL,                // Buffer for class string
                                   NULL,                // Size of class string buffer
                                   NULL,                // Reserved
                                   NULL,                // Number of subkeys
                                   NULL,                // Longest subkey name
                                   NULL,                // Longest class string
                                   &cEntries,           // Number of value entries
                                   &cMaxValueName,      // Longest value name
                                   &cMaxData,           // Longest value data
                                   NULL,                // Security descriptor
                                   NULL );              // Last write time
    }
    if (_error == ERROR_SUCCESS) {
        if (cEntries != 0) {
            cMaxValueName = cMaxValueName + 1; // REG_SZ needs one more for null
            cMaxData = cMaxData + 1;           // REG_SZ needs one more for null
            pchName = new CHAR[cMaxValueName];
            if (!pchName) {
                _error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else {
                if (cMaxData) {
                    pbValue = new BYTE[cMaxData];
                    if (!pbValue) {
                        _error = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
            }
        }
    }
}

RegEnumValues::~RegEnumValues()
{
    delete pchName;
    delete pbValue;
}

long RegEnumValues::Next()
{
    if (_error != ERROR_SUCCESS) {
        return _error;
    }
    if (cEntries == iEnum) {
        return ERROR_NO_MORE_ITEMS;
    }

    DWORD   cchName = cMaxValueName;

    dwDataLength = cMaxData;
    _error = RegEnumValue ( pRegEntry->GetKey(), // Key
                            iEnum,               // Index of value
                            pchName,             // Address of buffer for value name
                            &cchName,            // Address for size of buffer
                            NULL,                // Reserved
                            &dwType,             // Data type
                            pbValue,             // Address of buffer for value data
                            &dwDataLength );     // Address for size of data
    iEnum++;
    return _error;
}

NPMachineEntries::NPMachineEntries(const char *pszReqSectionName)
: RegEntry("System\\CurrentControlSet\\Services", HKEY_LOCAL_MACHINE),
  pszSectionName(pszReqSectionName)
{
    if (GetError() == ERROR_SUCCESS) {
        MoveToSubKey(pszSectionName);
        if (GetError() == ERROR_SUCCESS) {
            MoveToSubKey("NetworkProvider");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\npmsg.cpp ===
/*****************************************************************/
/**                  Microsoft Windows for Workgroups                **/
/**              Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/ 

/* NPMSG.CPP -- Implementation of MsgBox subroutine.
 *
 * History:
 *    05/06/93    gregj    Created
 */

#include "npcommon.h"
#include "npmsg.h"
#include "npstring.h"

#include <mluisupp.h>

extern "C" {
#include <netlib.h>
};

LPSTR pszTitle = NULL;

int MsgBox( HWND hwndOwner, UINT idMsg, UINT wFlags, const NLS_STR **apnls /* = NULL */ )
{
    if (pszTitle == NULL) {
        pszTitle = new char[MAX_RES_STR_LEN];
        if (pszTitle != NULL) {
            MLLoadString(IDS_MSGTITLE, pszTitle, MAX_RES_STR_LEN );
            UINT cbTitle = ::strlenf(pszTitle) + 1;
            delete pszTitle;
            pszTitle = new char[cbTitle];
            if (pszTitle != NULL)
                MLLoadStringA(IDS_MSGTITLE, pszTitle, cbTitle);
        }
    }
    NLS_STR nlsMsg( MAX_RES_STR_LEN );
    if (apnls == NULL)
        nlsMsg.LoadString((unsigned short) idMsg );
    else
        nlsMsg.LoadString((unsigned short) idMsg, apnls );
    return ::MessageBox( hwndOwner, nlsMsg, pszTitle, wFlags | MB_SETFOREGROUND );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\str.cpp ===
#include "npcommon.h"

// strstrf(str, srch)
//
// Returns a pointer to the first occurrence of srch within
// str (like strchrf, but search parameter is a string, not
// a single character).  Returns NULL if not found.
// REVIEW: simple algorithm here, but depending on usage,
// might be overkill to complicate it.

LPSTR WINAPI strstrf(LPCSTR lpString, LPCSTR lpSearch)
{
    INT cbSearch = strlenf(lpSearch);
    INT cbToSearch;
    LPSTR lp;

    // calculate the maximum distance to go -- the length
    // of the string to look in less the length of the
    // string to search for, since beyond that the string
    // being searched for would not fit.
    cbToSearch = strlenf(lpString) - cbSearch;
    if (cbToSearch < 0)
        return NULL;    /* string being searched is shorter */

    for (lp = (LPSTR)lpString; lp - lpString <= cbToSearch; ADVANCE(lp)) {
        if (strncmpf(lp, lpSearch, cbSearch) == 0)
            return lp;
    }

    return NULL;
}


// stristrf(str, srch)
//
// Returns a pointer to the first occurrence of srch within
// str, case-insensitive.  Returns NULL if not found.
// REVIEW: simple algorithm here, but depending on usage,
// might be overkill to complicate it.

LPSTR WINAPI stristrf(LPCSTR lpString, LPCSTR lpSearch)
{
    INT cbSearch = strlenf(lpSearch);
    INT cbToSearch;
    LPSTR lp;

    // calculate the maximum distance to go -- the length
    // of the string to look in less the length of the
    // string to search for, since beyond that the string
    // being searched for would not fit.
    cbToSearch = strlenf(lpString) - cbSearch;
    if (cbToSearch < 0)
        return NULL;    /* string being searched is shorter */

    for (lp = (LPSTR)lpString; lp - lpString <= cbToSearch; ADVANCE(lp)) {
        if (strnicmpf(lp, lpSearch, cbSearch) == 0)
            return lp;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strassgn.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strassgn.cxx
	NLS/DBCS-aware string class: assignment operator

	This file contains the implementation of the assignment operator
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx
		beng	07/26/91	Replaced min with local inline
		gregj	04/02/93	Do buffer overflow checks for OWNERALLOC strings
							instead of asserting
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::operator=

	SYNOPSIS:	Assignment operator

	ENTRY:		Either NLS_STR or CHAR*.

	EXIT:		If successful, contents of string overwritten.
				If failed, the original contents of the string remain.

	RETURNS:	Reference to self.

	HISTORY:
		beng	10/23/90	Created
		johnl	11/13/90	Added UIASSERTion checks for using bad
							strings
		beng	02/05/91	Uses CHAR * instead of PCH
		Johnl	03/06/91	Removed assertion check for *this
							being valid
		johnl	04/12/91	Resets error variable on PCH assignment
							if successful.
		beng	07/22/91	Allow assignment of an erroneous string;
							reset error on nls assignment as well
		gregj	04/02/93	Do buffer overflow checks for OWNERALLOC strings
							instead of asserting

********************************************************************/

NLS_STR& NLS_STR::operator=( const NLS_STR& nlsSource )
{
	if ( this == &nlsSource )
		return *this;

	if (!nlsSource)
	{
		// Assignment of an erroneous string
		//
		ReportError((unsigned short)nlsSource.QueryError());
		return *this;
	}

	INT cbToCopy = nlsSource.strlen();

	if ( !IsOwnerAlloc() )
	{
		if ( QueryAllocSize() < nlsSource.strlen()+1 )
		{
			/* Don't use Realloc because we want to retain the contents
			 * of the string if we fail to get the memory.
			 */
			CHAR * pchNew = new CHAR[nlsSource.strlen()+1];

			if ( pchNew == NULL )
			{
				ReportError( WN_OUT_OF_MEMORY );
				return *this;
			}

			delete _pchData;
			_pchData = pchNew;
			_cbData = nlsSource.strlen()+1;
		}

	}
	else
	{
        if (::fDBCSEnabled) {
    		if (QueryAllocSize() <= cbToCopy) {
    			cbToCopy = QueryAllocSize() - 1;	/* leave room for the null */
    			const CHAR *p = nlsSource.QueryPch();
    			while (p < nlsSource.QueryPch() + cbToCopy)
    				p += nlsSource.IsDBCSLeadByte(*p) ? 2 : 1;
    			if (p - nlsSource.QueryPch() != cbToCopy)	/* last char was DB */
    				cbToCopy--;								/* don't copy lead byte either */
    		}
        }
        else {
    		if (QueryAllocSize() <= cbToCopy)
	    		cbToCopy = QueryAllocSize() - 1;
        }
	}

	if (nlsSource.IsOEM())
		SetOEM();
	else
		SetAnsi();

	::memcpyf( _pchData, nlsSource.QueryPch(), cbToCopy );	/* copy string data */
	_pchData[cbToCopy] = '\0';		/* terminate the string */
	_cchLen = cbToCopy;
	IncVers();

	/* Reset the error state, since the string is now valid.
	 */
	ReportError( WN_SUCCESS );
	return *this;
}


NLS_STR& NLS_STR::operator=( const CHAR *pchSource )
{
	if ( pchSource == NULL )
	{
		if ( !IsOwnerAlloc() && !QueryAllocSize() )
		{
			if ( !Alloc(1) )
				ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}

		UIASSERT( QueryAllocSize() > 0 );

		*_pchData = '\0';
		_cchLen = 0;
	}
	else
	{
		INT iSourceLen = ::strlenf( pchSource );
		INT cbToCopy;

		if ( !IsOwnerAlloc() )
		{
			if ( QueryAllocSize() < iSourceLen + 1 )
			{
				CHAR * pchNew = new CHAR[iSourceLen + 1];

				if ( pchNew == NULL )
				{
					ReportError( WN_OUT_OF_MEMORY );
					return *this;
				}

				delete _pchData;
				_pchData = pchNew;
				_cbData = iSourceLen + 1;
			}
			cbToCopy = iSourceLen;
		}
		else
		{
			if (QueryAllocSize() <= iSourceLen) {
                if (::fDBCSEnabled) {
    				cbToCopy = QueryAllocSize() - 1;	/* leave room for the null */
    				const CHAR *p = pchSource;
    				while (p < pchSource + cbToCopy)
    					p += IsDBCSLeadByte(*p) ? 2 : 1;
    				if (p - pchSource != cbToCopy)		/* last char was DB */
    					cbToCopy--;						/* don't copy lead byte either */
    			}
                else
	    			cbToCopy = QueryAllocSize() - 1;
            }
			else
				cbToCopy = iSourceLen;
		}

		::memcpyf( _pchData, pchSource, cbToCopy );
		_pchData[cbToCopy] = '\0';		/* terminate the string */
		_cchLen = cbToCopy;
	}

	IncVers();

	/* Reset the error state, since the string is now valid.
	 */
	ReportError( WN_SUCCESS );
	return *this;
}


#ifdef EXTENDED_STRINGS
/*******************************************************************

	NAME:		NLS_STR::CopyFrom()

	SYNOPSIS:	Assignment method which returns an error code

	ENTRY:
		nlsSource - source argument, either a nlsstr or char vector.
		achSource

	EXIT:
		Copied argument into this.  Error code of string set.

	RETURNS:
		Error code of string - WN_SUCCESS if successful.

	NOTES:
		If the CopyFrom fails, the current string will retain its
		original contents and error state.

	HISTORY:
		beng	09/18/91	Created
		beng	09/19/91	Added content-preserving behavior

********************************************************************/

APIERR NLS_STR::CopyFrom( const NLS_STR & nlsSource )
{
	if (!nlsSource)
		return nlsSource.QueryError();

	*this = nlsSource;

	APIERR err = QueryError();
	if (err)
		Reset();
	else {
		if (nlsSource.IsOEM())
			SetOEM();
		else
			SetAnsi();
	}
	return err;
}


APIERR NLS_STR::CopyFrom( const CHAR * achSource )
{
	*this = achSource;

	APIERR err = QueryError();
	if (err)
		Reset();
	return err;
}
#endif	// EXTENDED_STRINGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\spn.cpp ===
#include "npcommon.h"

void InitSpn(
    char *abBits,
    char *abDBCBits,
    LPCSTR lpSpn
)
{
    LPCSTR lpCur;

    ::memset(abBits, '\0', 256/8);
    if (::fDBCSEnabled)
        ::memset(abDBCBits, '\0', 256/8);

    for (lpCur = lpSpn; *lpCur; ADVANCE(lpCur)) {
        if (IS_LEAD_BYTE(*lpCur)) {
            char chXOR = *lpCur ^ *(lpCur+1);
            SPN_SET(abDBCBits, chXOR);
        }
        else
            SPN_SET(abBits, *lpCur);
    }
}

// strspn(str, spn)
//
// Returns count of leading characters in str which exist
// in spn;  equivalent to returning the index of the first
// character which is not in spn.

UINT WINAPI strspnf(LPCSTR lpString, LPCSTR lpSpn)
{
    char abBits[256/8];
    char abDBCBits[256/8];
    LPCSTR lpCur;

    InitSpn(abBits, abDBCBits, lpSpn);

    for (lpCur = lpString; *lpCur; ADVANCE(lpCur)) {
        if (IS_LEAD_BYTE(*lpCur)) {
            char chXOR = *lpCur ^ *(lpCur + 1);
            if (!SPN_TEST(abDBCBits, chXOR) ||
                (strchrf(lpSpn, GetTwoByteChar(lpCur)) == NULL))
                break;
        }
        else if (!SPN_TEST(abBits, *lpCur))
            break;
    }

    return (UINT) (lpCur - lpString);
}


// strcspn(str, spn)
//
// Returns count of leading characters in str which do not
// exist in spn;  equivalent to returning the index of the
// first character which is in spn.

UINT WINAPI strcspnf(LPCSTR lpString, LPCSTR lpSpn)
{
    char abBits[256/8];
    char abDBCBits[256/8];
    LPCSTR lpCur;

    InitSpn(abBits, abDBCBits, lpSpn);

    for (lpCur = lpString; *lpCur; ADVANCE(lpCur)) {
        if (IS_LEAD_BYTE(*lpCur)) {
            char chXOR = *lpCur ^ *(lpCur + 1);
            if (SPN_TEST(abDBCBits, chXOR) &&
                (strchrf(lpSpn, GetTwoByteChar(lpCur)) != NULL))
                break;
        }
        else if (SPN_TEST(abBits, *lpCur))
            break;
    }
    return (UINT)(lpCur-lpString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strcat.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strcat.cxx
	NLS/DBCS-aware string class: strcat method

	This file contains the implementation of the strcat method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx
		beng	07/26/91	Replaced min with local inline
*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strcat

	SYNOPSIS:	Concantenate string

	ENTRY:		nlsSuffix - appended to end of string
				- or -
				pszSuffix - appended to end of string

	EXIT:

	NOTES:		String doesn't change if a memory allocation failure occurs
				Currently checks to see if we need to reallocate the
				string (but we have to traverse it to determine the
				actual storage required).  We may want to change
				this.

	HISTORY:
		johnl	11/13/90	Written
		beng	07/22/91	Allow on erroneous strings
		gregj	07/05/94	Added LPCSTR overload

********************************************************************/

NLS_STR & NLS_STR::strcat( const NLS_STR & nlsSuffix )
{
	if (QueryError() || !nlsSuffix)
		return *this;

	if ( QueryAllocSize() < (strlen() + nlsSuffix.strlen() + 1) )
	{
		if (IsOwnerAlloc() || !realloc( strlen() + nlsSuffix.strlen() + 1 ))
		{
			ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}
	}

	::strcatf( _pchData, nlsSuffix.QueryPch() );
	_cchLen += nlsSuffix.strlen();

	return *this;
}


NLS_STR & NLS_STR::strcat( LPCSTR pszSuffix )
{
	if (QueryError())
		return *this;

	UINT cbSuffix = ::strlenf(pszSuffix);
	if ( (UINT)QueryAllocSize() < (strlen() + cbSuffix + 1) )
	{
		if (IsOwnerAlloc() || !realloc( strlen() + cbSuffix + 1 ))
		{
			ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}
	}

	::strcatf( _pchData, pszSuffix );
	_cchLen += cbSuffix;

	return *this;
}


#ifdef EXTENDED_STRINGS
/*******************************************************************

    NAME:	NLS_STR::Append

    SYNOPSIS:	Append a string to the end of current string

    ENTRY:	nlsSuffix - appended to end of string

    EXIT:

    RETURNS:

    NOTES:	Little more than a wrapper around strcat.

    HISTORY:
	beng	    22-Jul-1991     Created (parallel of AppendChar)

********************************************************************/

APIERR NLS_STR::Append( const NLS_STR &nlsSuffix )
{
    strcat(nlsSuffix);
    return QueryError();
}


/*******************************************************************

    NAME:	NLS_STR::AppendChar

    SYNOPSIS:	Append a single character to the end of current string

    ENTRY:	wch - appended to end of string

    EXIT:

    RETURNS:	0 if successful

    NOTES:
	CODEWORK: This member would do well to skip the "strcat" step
	and append directly to the subject string.

    HISTORY:
	beng	    23-Jul-1991     Created

********************************************************************/

APIERR NLS_STR::AppendChar( WCHAR wch )
{
#if defined(UNICODE)
    STACK_NLS_STR(nlsTemp, 1);

    nlsTemp._pchData[0] = (CHAR)wch;
    nlsTemp._pchData[1] = 0;
    nlsTemp._cchLen = sizeof(CHAR); // since it's really in bytes

#else
    STACK_NLS_STR(nlsTemp, 2);

    if (HIBYTE(wch) == 0)
    {
	// Single-byte character
	nlsTemp._pchData[0] = LOBYTE(wch);
	nlsTemp._pchData[1] = '\0';
	nlsTemp._cchLen = sizeof(CHAR);
    }
    else
    {
	// Double-byte character
	nlsTemp._pchData[0] = HIBYTE(wch); // lead byte
	nlsTemp._pchData[1] = LOBYTE(wch);
	nlsTemp._pchData[2] = '\0';
	nlsTemp._cchLen = 2*sizeof(CHAR);
    }

#endif

    strcat(nlsTemp);
    return QueryError();
}
#endif	// EXTENDED_STRINGS


/*******************************************************************

	NAME:		NLS_STR::operator+=

	SYNOPSIS:	Append a string to the end of current string

	ENTRY:		wch - character to append

	EXIT:

	RETURNS:

	NOTES:		Little more than a wrapper around strcat.

	HISTORY:
		beng	07/23/91	Header added
		gregj	03/25/93	Added WCHAR version to replace AppendChar
		gregj	07/13/94	NLS_STR version was identical to strcat, so inlined

********************************************************************/

NLS_STR & NLS_STR::operator+=( WCHAR wch )
{
#if defined(UNICODE)
	STACK_NLS_STR(nlsTemp, 1);

	nlsTemp._pchData[0] = (CHAR)wch;
	nlsTemp._pchData[1] = 0;
	nlsTemp._cchLen = sizeof(CHAR); // since it's really in bytes

#else
	STACK_NLS_STR(nlsTemp, 2);

	if (HIBYTE(wch) == 0)
	{
		// Single-byte character
		nlsTemp._pchData[0] = LOBYTE(wch);
		nlsTemp._pchData[1] = '\0';
		nlsTemp._cchLen = sizeof(CHAR);
	}
	else
	{
		// Double-byte character
		nlsTemp._pchData[0] = HIBYTE(wch); // lead byte
		nlsTemp._pchData[1] = LOBYTE(wch);
		nlsTemp._pchData[2] = '\0';
		nlsTemp._cchLen = 2*sizeof(CHAR);
	}

#endif

    strcat(nlsTemp);
    return *this;
}


/*******************************************************************

	NAME:		NLS_STR::realloc

	SYNOPSIS:	Reallocate an NLS_STR to the passed count of bytes, copying
				the current contents to the reallocated string.

	ENTRY:		cb - number of bytes desired in string storage

	EXIT:
		Returns TRUE if successful:

			_pchData points to allocated storage of "cb" bytes.
			_cbData set to cb.
			Old storage is copied

		Returns FALSE upon allocation failure, the string is preserved

	NOTES:
		A string will never be downsized (i.e., realloc can only be used
		to increase the size of a string).  If a request comes in to make
		the string smaller, it will be ignored, and TRUE will be returned.

		DO NOT CALL REALLOC ON AN OWNERALLOCED STRING!!  You will cause
		an assertion error if you do.

	HISTORY:
		johnl	11/11/90	Created
		beng	04/26/91	Changed USHORT parm to INT

********************************************************************/

BOOL NLS_STR::realloc( INT cb )
{
	UIASSERT( !IsOwnerAlloc() );
	UIASSERT( cb != 0 );

	if ( cb <= QueryAllocSize() )
		return TRUE;

	CHAR * pchNewMem = new CHAR[cb];

	if (pchNewMem == NULL)
		return FALSE;

	::memcpyf( pchNewMem, _pchData, min( cb-1, QueryAllocSize() ) );
	delete _pchData;
	_pchData = pchNewMem;
	_cbData = cb;
	*( _pchData + cb - 1 ) = '\0';

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strchr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strchr.cxx
	NLS/DBCS-aware string class: strchr method

	This file contains the implementation of the strchr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strchr

	SYNOPSIS:	Puts the index of the first occurrence of ch in *this
				into istrPos.


	ENTRY:		pistrPos - points to ISTR in which to leave pos
				ch		 - character sought
				istrStart- staring point in string.  If omitted, start
							at beginning

	EXIT:		pistrPos

	RETURNS:	TRUE if character found; otherwise FALSE

	NOTES:		This routine only works for CHAR - not WCHAR.
				Hence it's useless for double-byte characters
				under MBCS.

	HISTORY:
		johnl	11/26/90	Written
		beng	07/22/91	Allow on erroneous strings; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strchr( ISTR * pistrPos, const CHAR ch ) const
{
	if ( QueryError() )
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strchrf( QueryPch(), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((DWORD)(pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::strchr( ISTR * pistrPos, const CHAR ch,
					  const ISTR & istrStart ) const
{
	if ( QueryError() )
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strchrf( QueryPch(istrStart), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((DWORD)(pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\stratoi.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stratoi.cxx
	NLS/DBCS-aware string class: atoi method

	This file contains the implementation of the atoi method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this member function need not link to it.

	FILE HISTORY:
		markbl	06/04/91	Created

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
	#include <stdlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::atoi

	SYNOPSIS:	Returns *this in its integer numeric equivalent

	ENTRY:		With no arguments, parses from beginning of string.
				Given an ISTR, starts at that point within the string.

	EXIT:

	NOTES:		Uses C-Runtime atoi function

	HISTORY:
		markbl	06/04/91	Written
		beng	07/22/91	Callable on erroneous string; simplified CheckIstr

********************************************************************/

INT NLS_STR::atoi() const
{
	if (QueryError())
		return 0;

	return ::atoi( _pchData );
}


INT NLS_STR::atoi( const ISTR & istrStart ) const
{
	if (QueryError())
		return 0;

	CheckIstr( istrStart );

	return ::atoi( QueryPch(istrStart) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strcspn.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strcspn.cxx
	NLS/DBCS-aware string class: strcspn method

	This file contains the implementation of the strcspn method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strcspn

	SYNOPSIS:	Set membership.  Finds the first matching character
				in the passed string

	ENTRY:		pistrPos - destination for results
				nls	 - set of sought characters

	EXIT:		*pistrPos contains offset within "this" of element
				found (assuming it was successful); otherwise it
				is moved to the end of the string.

	RETURNS:	TRUE if any character found; FALSE otherwise

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous strings; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strcspn( ISTR* pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	pistrPos->SetIB( ::strcspnf( QueryPch(), nls.QueryPch() ) );
	return *QueryPch( *pistrPos ) != '\0';
}


BOOL NLS_STR::strcspn( ISTR * pistrPos, const NLS_STR & nls,
						const ISTR& istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );
	CheckIstr( istrStart );

	pistrPos->SetIB( ::strcspnf( QueryPch(istrStart), nls.QueryPch() )
								 + istrStart.QueryIB()  );
	return *QueryPch( *pistrPos ) != '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\stratol.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stratol.cxx
	NLS/DBCS-aware string class: atol method

	This file contains the implementation of the atol method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this member function need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
	#include <stdlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::atol

	SYNOPSIS:	Returns *this in its long numeric equivalent

	ENTRY:		With no arguments, parses from beginning of string.
				Given an ISTR, starts at that point within the string.

	EXIT:

	NOTES:		Uses C-Runtime atol function

	HISTORY:
		johnl	11/26/90	Written
		beng	07/22/91	Callable on erroneous string; simplified CheckIstr

********************************************************************/

LONG NLS_STR::atol() const
{
	if (QueryError())
		return 0;

	return ::atol( _pchData );
}


LONG NLS_STR::atol( const ISTR & istrStart ) const
{
	if (QueryError())
		return 0;

	CheckIstr( istrStart );

	return ::atol( QueryPch(istrStart) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strdss.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strdss.cxx
	NLS/DBCS-aware string class: DelSubStr method

	This file contains the implementation of the DelSubStr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::DelSubStr

	SYNOPSIS:	Collapse the string by removing the characters from
				istrStart to:
				  istrStart  to the end of string
				  istrStart + istrEnd
				The string is not reallocated

	ENTRY:

	EXIT:		Modifies istrStart

	NOTES:		The method DelSubStr( ISTR&, CB) is private and does
				the work.

	HISTORY:
		johnl	11/26/90	Created
		beng	04/26/91	Replaced CB with INT
		beng	07/23/91	Allow on erroneous strings; simplified CheckIstr

********************************************************************/

VOID NLS_STR::DelSubStr( ISTR & istrStart, INT cbLen )
{
	if (QueryError())
		return;

	CheckIstr( istrStart );

	// cbLen == -1 means delete to end of string
	if ( cbLen == -1 )
		*(_pchData + istrStart.QueryIB() ) = '\0';
	else
	{
		INT cbNewEOS = 1 + ::strlenf( QueryPch(istrStart) + cbLen );

		::memmovef( (CHAR *)QueryPch(istrStart),
					(CHAR *)QueryPch(istrStart) + cbLen,
					cbNewEOS );
	}

	_cchLen = ::strlenf( QueryPch() );

	IncVers();
	UpdateIstr( &istrStart );
}


VOID NLS_STR::DelSubStr( ISTR & istrStart )
{
	if (QueryError())
		return;

	DelSubStr( istrStart, -1 );
}


VOID NLS_STR::DelSubStr( ISTR & istrStart, const ISTR & istrEnd  )
{
	if (QueryError())
		return;

	CheckIstr( istrEnd );
	UIASSERT( istrEnd.QueryIB() >= istrStart.QueryIB() );

	DelSubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\stricmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stricmp.cxx
	NLS/DBCS-aware string class: stricmp method

	This file contains the implementation of the stricmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::stricmp

	SYNOPSIS:	Case insensitive string compare w/ optional indices

	ENTRY:		nls					  - string against which to compare
				istrStart1 (optional) - index into "this"
				istrStart2 (optional) - index into "nls"

	RETURNS:	As the C runtime "strcmp".

	NOTES:		If either string is erroneous, return "match."
				This runs contrary to the eqop.

				Glock doesn't allow default parameters which require
				construction; hence this member is overloaded multiply.

	HISTORY:
		johnl	11/15/90	Written
		beng	07/23/91	Allow on erroneous strings;
							simplified CheckIstr

********************************************************************/

INT NLS_STR::stricmp( const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return 0;

	return ::stricmpf( QueryPch(), nls.QueryPch() );
}


INT NLS_STR::stricmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );

	return ::stricmpf( QueryPch(istrStart1), nls.QueryPch() );
}


INT NLS_STR::stricmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::stricmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strcmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strcmp.cxx
	NLS/DBCS-aware string class: strcmp method and equality operator

	This file contains the implementation of the strcmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::operator==

	SYNOPSIS:	Case-sensitive test for equality

	RETURNS:	TRUE if the two operands are equal (case sensitive);
				else FALSE

	NOTES:		An erroneous string matches nothing.

	HISTORY:
		johnl	11/11/90	Written
		beng	07/23/91	Allow on erroneous strings

********************************************************************/

BOOL NLS_STR::operator==( const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	return !::strcmpf( QueryPch(), nls.QueryPch() );
}


/*******************************************************************

	NAME:		NLS_STR::operator!=

	SYNOPSIS:	Case-sensitive test for inequality

	RETURNS:	TRUE if the two operands are unequal (case sensitive);
				else FALSE

	NOTES:		An erroneous string matches nothing.

	HISTORY:
		beng	07/23/91	Header added

********************************************************************/

BOOL NLS_STR::operator!=( const NLS_STR & nls ) const
{
	return ! operator==( nls );
}


/*******************************************************************

	NAME:		NLS_STR::strcmp

	SYNOPSIS:	Standard string compare with optional character indexes

	ENTRY:		nls					  - string against which to compare
				istrStart1 (optional) - index into "this"
				istrStart2 (optional) - index into "nls"

	RETURNS:	As the C runtime "strcmp".

	NOTES:		If either string is erroneous, return "match."
				This runs contrary to the eqop.

				Glock doesn't allow default parameters which require
				construction; hence this member is overloaded multiply.

	HISTORY:
		johnl	11/15/90	Written
		johnl	11/19/90	Changed to use ISTR, overloaded for
							different number of ISTRs
		beng	07/23/91	Allow on erroneous strings;
							simplified CheckIstr

********************************************************************/

int NLS_STR::strcmp( const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return 0;

	return ::strcmpf( QueryPch(), nls.QueryPch() );
}

int NLS_STR::strcmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );

	return ::strcmpf( QueryPch(istrStart1) , nls.QueryPch() );
}

int NLS_STR::strcmp(
	const NLS_STR & nls,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::strcmpf( QueryPch(istrStart1), nls.QueryPch(istrStart2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strinsrt.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strinsrt.cxx
	NLS/DBCS-aware string class: InsertParams method

	This file contains the implementation of the InsertParams method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		Johnl	01/31/91	Created
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


#define MAX_INSERT_PARAMS	9

/*******************************************************************

	NAME:		NLS_STR::InsertParams

	SYNOPSIS:	Fill in a message string from the resource file replacing
				the number parameters with the real text.

	ENTRY:		pchMessage is a pointer to the message text
				apnlsParamStrings is an array of pointers to NLS_STRs

				Example:

				*this = "Error %1 occurred, do %2, or %1 will happen again"
				apnlsParamStrings[0] = "696969"
				apnlsParamStrings[1] = "Something else"

				Return string = "Error 696969 occurred, do Something else or
				696969 will happen again"

	EXIT:		0 if successful, error code otherwise, one of:
					WN_OUT_OF_MEMORY

	NOTES:		The minimum parameter is 1, the maximum parameter is 9.
				The array of param strings must have a NULL to mark
				the end of the array.

	HISTORY:
		JohnL	01/30/91	Created
		beng	04/26/91	Uses WCHAR
		beng	07/23/91	Allow on erroneous string

********************************************************************/

#define PARAM_ESC  '%'

USHORT NLS_STR::InsertParams( const NLS_STR * apnlsParamStrings[] )
{
	if (QueryError())
		return (USHORT) QueryError();

	INT iNumParams = 0;	// Number of param strings in the array
						// Max string length of expanded message (include \0)
	INT iMaxMessLen = strlen() + 1;

	/* How many parameters were we passed?
	*/
	for ( ; apnlsParamStrings[iNumParams] != NULL ; iNumParams++ )
		;

	UIASSERT(iNumParams <= MAX_INSERT_PARAMS);
	if ( iNumParams > MAX_INSERT_PARAMS )
		return WN_OUT_OF_MEMORY;

	/* Determine total string length required for the expanded string
	 * and get out if we can't fulfill the request
	 */

	ISTR istrCurPos( *this );
	while ( 1 )
	{
		if ( !strchr( &istrCurPos, PARAM_ESC, istrCurPos ) )
			break;

		WCHAR wchParam = QueryChar( ++istrCurPos );

		if ( wchParam >= '1' && wchParam <= '9' )
		{
			INT iParamIndex = wchParam - '1';
			if ( iNumParams < iParamIndex )
				return WN_OUT_OF_MEMORY;

			iMaxMessLen += apnlsParamStrings[iParamIndex]->strlen() - 2;
		}
	}

	if ( iMaxMessLen > QueryAllocSize() )
	{
		if ( IsOwnerAlloc() )
			return WN_OUT_OF_MEMORY;
		else
			if ( !realloc( iMaxMessLen ) )
				return WN_OUT_OF_MEMORY;
	}

	/* Now do the parameter substitution
	 */

	istrCurPos.Reset();
	for (;;)
	{
		if ( !strchr( &istrCurPos, PARAM_ESC, istrCurPos ) )
			break;

		ISTR istrParamEsc( istrCurPos );
		WCHAR wchParam = QueryChar( ++istrCurPos );

		if ( wchParam >= '1' && wchParam <= '9' )
		{
			INT iParamIndex = wchParam - '1';

			if (iParamIndex < iNumParams) {
				ReplSubStr( *apnlsParamStrings[iParamIndex],
							istrParamEsc,
							++istrCurPos ) ;   // Replace #
				// Skip past entire substituted string
				istrCurPos.SetIB(istrParamEsc.QueryIB() +
								 apnlsParamStrings[iParamIndex]->strlen());
			}
			// else istrCurPos has been advanced past the out-of-range digit
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\string.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	string.cxx
	NLS/DBCS-aware string class: essential core methods

	This file contains those routines which every client of
	the string classes will always need.

	Most of the implementation has been exploded into other files,
	so that an app linking to string doesn't end up dragging the
	entire string runtime library along with it.

	FILE HISTORY:
		beng	10/23/90	Created
		johnl	12/11/90	Remodeled beyond all recognizable form
		beng	01/18/91	Most methods relocated into other files
		beng	02/07/91	Uses lmui.hxx
		beng	07/26/91	Replaced min with local inline
		gregj	03/30/93	Removed ISTR to separate module
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::NLS_STR

	SYNOPSIS:	Constructor for NLS_STR

	ENTRY:		NLS_STR takes many (too many) ctor forms.

	EXIT:		String constructed

	NOTES:
		The default constructor creates an empty string.

	HISTORY:
		beng	10/23/90	Created
		beng	04/26/91	Replaced 'CB' and USHORT with INT
		beng	07/22/91	Uses member-init ctor forms

********************************************************************/

NLS_STR::NLS_STR()
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if ( !Alloc(1) )
		return;

	*_pchData = '\0';
	InitializeVers();
}


NLS_STR::NLS_STR( INT cchInitLen )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if (!Alloc(cchInitLen+1))
		return;

	::memsetf( _pchData, '\0', cchInitLen );

	_cchLen = 0;

	InitializeVers();
}


NLS_STR::NLS_STR( const CHAR * pchInit )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if (pchInit == NULL)
	{
		if (!Alloc(1))
			ReportError( WN_OUT_OF_MEMORY );
		else
		{
			*_pchData = '\0';
		}
		return;
	}

	INT iSourceLen = ::strlenf( pchInit );

	if ( !Alloc( iSourceLen + 1 ) )
		return;

	::strcpyf( _pchData, pchInit );

	_cchLen = iSourceLen;

	InitializeVers();
}


NLS_STR::NLS_STR( const NLS_STR & nlsInit )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	UIASSERT( !nlsInit.QueryError() );

	if (!Alloc( nlsInit.strlen()+1 ) )
		return;

	::memcpyf( _pchData, nlsInit.QueryPch(), nlsInit.strlen()+1 );

	_cchLen = nlsInit.strlen();

	InitializeVers();
}


#ifdef EXTENDED_STRINGS
NLS_STR::NLS_STR( const CHAR * pchInit, INT iTotalLen )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(0)
{
	if (pchInit == NULL)
	{
		if (!Alloc( 1 + iTotalLen ))
			return;
		*_pchData = '\0';
	}
	else
	{
		_cchLen = ::strlenf( pchInit );
		if ( _cchLen > iTotalLen )
		{
			_cchLen = 0;
			ReportError( WN_OUT_OF_MEMORY );
			return;
		}

		if ( !Alloc( iTotalLen ) )
		{
			_cchLen = 0;
			return;
		}

		::memcpyf( _pchData, pchInit, _cchLen+1 );
	}

	InitializeVers();
}
#endif	// EXTENDED_STRINGS


NLS_STR::NLS_STR( unsigned stralloc, CHAR *pchInit, INT cbSize )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(SF_OWNERALLOC)
{
	UIASSERT( stralloc == STR_OWNERALLOC || stralloc == STR_OWNERALLOC_CLEAR);
	UIASSERT( pchInit != NULL );

	if ( stralloc == STR_OWNERALLOC_CLEAR )
	{
		UIASSERT( cbSize > 0 );
		*(_pchData = pchInit ) = '\0';
		_cchLen = 0;
	}
	else
	{
		_pchData = pchInit;
		_cchLen = ::strlenf( pchInit );
	}

	if ( cbSize == -1 )
		_cbData = _cchLen + 1;
	else
		_cbData = cbSize;

	InitializeVers();
}


#ifdef EXTENDED_STRINGS
NLS_STR::NLS_STR( unsigned stralloc, CHAR *pchBuff, INT cbSize,
				  const CHAR *pchInit )
	: _pchData(0),
	  _cbData(0),
	  _cchLen(0),
	  _fsFlags(SF_OWNERALLOC)
{
	UIASSERT( stralloc == STR_OWNERALLOC );
	UIASSERT( stralloc != STR_OWNERALLOC_CLEAR );
	UIASSERT( pchBuff != NULL || pchInit != NULL );
	UIASSERT( cbSize > 0 && ::strlenf( pchInit ) <= cbSize );

	UNREFERENCED( stralloc );

	_pchData = pchBuff;

	INT cbToCopy = min( ::strlenf( pchInit ), cbSize - 1 );
	::memcpyf( _pchData, pchInit, cbToCopy );
	*(_pchData + cbToCopy) = '\0';

	_cchLen = cbToCopy;
	_cbData = cbSize;

	InitializeVers();
}
#endif


/*******************************************************************

	NAME:		NLS_STR::~NLS_STR

	SYNOPSIS:	Destructor for NLS_STR

	ENTRY:

	EXIT:		Storage deallocated, if not owner-alloc

	HISTORY:
		beng	10/23/90	Created
		beng	07/22/91	Zeroes only in debug version

********************************************************************/

NLS_STR::~NLS_STR()
{
	if ( !IsOwnerAlloc() )
		delete _pchData;

#if defined(DEBUG)
	_pchData = NULL;
	_cchLen  = 0;
	_cbData = 0;
#endif
}


/*******************************************************************

	NAME:		NLS_STR::Alloc

	SYNOPSIS:	Common code for constructors.

	ENTRY:
		cb - number of bytes desired in string storage

	EXIT:
		Returns TRUE if successful:

			_pchData points to allocated storage of "cb" bytes.
			_cbData set to cb.
			Allocated storage set to 0xF2 in debug version

		Returns FALSE upon allocation failure.

	NOTES:

	HISTORY:
		beng	10/23/90	Created
		johnl	12/11/90	Updated as per code review
		beng	04/26/91	Changed USHORT parm to INT

********************************************************************/

BOOL NLS_STR::Alloc( INT cb )
{
	UIASSERT( cb != 0 );

	_pchData = new CHAR[cb];
	if (_pchData == NULL)
	{
		// For now, assume not enough memory.
		//
		ReportError(WN_OUT_OF_MEMORY);
		return FALSE;
	}

#ifdef DEBUG
	::memsetf(_pchData, 0xf2, cb);
#endif
	_cbData = cb;

	return TRUE;
}


/*******************************************************************

	NAME:		NLS_STR::Reset

	SYNOPSIS:	Attempts to clear the error state of the string

	ENTRY:		String is in error state

	EXIT:		If recoverable, string is correct again

	RETURNS:	TRUE if successful; FALSE otherwise

	NOTES:
		An operation on a string may fail, if this occurs, the error
		flag is set and you can't use the string until the flag
		is cleared.  By calling Reset, you can clear the flag,
		thus allowing you to get access to the string again.  The
		string will be in a consistent state.  Reset will return
		FALSE if the string couldn't be restored (for example, after
		construction failure).

    HISTORY:
		Johnl	12/12/90	Created

********************************************************************/

BOOL NLS_STR::Reset()
{
	UIASSERT( QueryError() ) ;	// Make sure an error exists

	if ( QueryError() == WN_OUT_OF_MEMORY && _pchData != NULL )
	{
		ReportError( WN_SUCCESS );
		return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\stristr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stristr.cxx
	NLS/DBCS-aware string class: stristr method

	This file contains the implementation of the stristr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	11/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:	NLS_STR::stristr

	SYNOPSIS:	Same as strstr on case insensitive

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::stristr( ISTR * pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::stristrf( QueryPch(), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::stristr( ISTR *    pistrPos,
					   const NLS_STR & nls,
					   const ISTR    & istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::stristrf(QueryPch(istrStart), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strnchar.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strnchar.cxx
	NLS/DBCS-aware string class:QueryNumChar method

	This file contains the implementation of the QueryNumChar method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		terryk	04/04/91	Creation

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


#ifdef EXTENDED_STRINGS
/*******************************************************************

	NAME:		NLS_STR::QueryNumChar

	SYNOPSIS:	return the total number of character within the string   

	RETURNS:	The number of logical character within the string

	NOTES:
		Treats erroneous string as having length 0

	HISTORY:
		terryk	04/04/91	Written
		beng	07/23/91	Allow on erroneous string

********************************************************************/

INT NLS_STR::QueryNumChar() const
{
	if (QueryError())
		return 0;

	ISTR  istrCurPos( *this );
	INT   cchCounter = 0;

	for ( ;
		this->QueryChar( istrCurPos ) != '\0';
		istrCurPos++, cchCounter ++ )
		;

	return cchCounter;
}


/*******************************************************************

	NAME:		NLS_STR::QueryTextLength

	SYNOPSIS:	Calculate length of text in CHARS, sans terminator

	RETURNS:	Count of CHARs

	NOTES:
		Compare QueryNumChar, which returns a number of glyphs.
		In a DBCS environment, this member will return 2 CHARS for
		each double-byte character, since a CHAR is there only 8 bits.

	HISTORY:
		beng	07/23/91	Created

********************************************************************/

INT NLS_STR::QueryTextLength() const
{
	return _cchLen / sizeof(CHAR);
}


/*******************************************************************

	NAME:		NLS_STR::QueryTextSize

	SYNOPSIS:	Calculate length of text in BYTES, including terminator

	RETURNS:	Count of BYTES

	NOTES:
		QueryTextSize returns the number of bytes needed to duplicate
		the string into a byte vector.

    HISTORY:
		beng	07/23/91	Created

********************************************************************/

INT NLS_STR::QueryTextSize() const
{
	return _cchLen+sizeof(CHAR);
}
#endif	// EXTENDED_STRINGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\stris.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	stris.cxx
	NLS/DBCS-aware string class: InsertStr method

	This file contains the implementation of the InsertStr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::InsertStr

	SYNOPSIS:	Insert passed string into *this at istrStart

	ENTRY:

	EXIT:		If this function returns FALSE, ReportError has been
				called to report the error that occurred.

	RETURN:		TRUE on success, FALSE otherwise.

	NOTES:		If *this is not STR_OWNERALLOCed and the inserted string
				won't fit in the allocated space for *this, then *this
				will be reallocated.

	HISTORY:
		johnl	11/28/90	Created
		rustanl 04/14/91	Fixed new length calculation.  Report
							error if owner alloc'd and not enough
							space.
		beng	04/26/91	Replaced CB with INT
		beng	07/23/91	Allow on erroneous string;
							simplified CheckIstr

********************************************************************/

BOOL NLS_STR::InsertStr( const NLS_STR & nlsIns, ISTR & istrStart )
{
	if (QueryError() || !nlsIns)
		return FALSE;

	CheckIstr( istrStart );

	INT cbNewSize = strlen() + nlsIns.strlen() + 1 ; // include new null char

	if ( QueryAllocSize() < cbNewSize )
	{
		if ( IsOwnerAlloc())
		{
			// Big trouble!  Report error, and return failure.
			//
			UIASSERT( !"Owner alloc'd string not big enough" );
			ReportError( WN_OUT_OF_MEMORY );
			return FALSE;
		}

		// Attempt to allocate more memory
		//
		if ( !realloc( cbNewSize ) )
		{
			ReportError( WN_OUT_OF_MEMORY );
			return FALSE;
		}
	}

	::memmovef( (CHAR *)QueryPch(istrStart) + nlsIns.strlen(),
				(CHAR *)QueryPch(istrStart),
				::strlenf(QueryPch(istrStart) ) + 1 );
	::memmovef( (CHAR *)QueryPch(istrStart),
				(CHAR *)nlsIns.QueryPch(),
				nlsIns.strlen() );

	UIASSERT( cbNewSize >= 1 ); // should have been assigned something +1 above
	_cchLen = cbNewSize - 1;	// don't count null character here

	IncVers();
	UpdateIstr( &istrStart );		// This ISTR does not become invalid
									// after the string update
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strmisc.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	strmisc.cxx
	Miscellaneous members of the string classes

	The NLS_STR and ISTR classes have many inline member functions
	which bloat clients, especially in debug versions.	This file
	gives those unhappy functions a new home.

	FILE HISTORY:
		beng	04/26/91	Created (relocated from string.hxx)
		gregj	05/22/92	Added ToOEM, ToAnsi methods

*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


#ifdef DEBUG
/*******************************************************************

	NAME:		NLS_STR::CheckIstr

	SYNOPSIS:	Checks association between ISTR and NLS_STR instances

	ENTRY:		istr - ISTR to check against this NLS_STR

	NOTES:
		Does nothing in retail build.

	HISTORY:
		beng		07/23/91	Header added; removed redundant "nls" parameter.

********************************************************************/

VOID NLS_STR::CheckIstr( const ISTR& istr ) const
{
	UIASSERT( (istr).QueryPNLS() == this );
	UIASSERT( (istr).QueryVersion() == QueryVersion() );
}


VOID NLS_STR::IncVers()
{
	_usVersion++;
}


VOID NLS_STR::InitializeVers()
{
	_usVersion = 0;
}


VOID NLS_STR::UpdateIstr( ISTR *pistr ) const
{
	pistr->SetVersion( QueryVersion() );
}


USHORT NLS_STR::QueryVersion() const
{
	return _usVersion;
}


const CHAR * NLS_STR::QueryPch() const
{
	if (QueryError()) {
		UIASSERT(FALSE);
		return NULL;
	}

	return _pchData;
}


const CHAR * NLS_STR::QueryPch( const ISTR& istr ) const
{
	if (QueryError())
		return NULL;

	CheckIstr( istr );
	return _pchData+istr.QueryIB();
}


WCHAR NLS_STR::QueryChar( const ISTR& istr ) const
{
	if (QueryError())
		return 0;

	CheckIstr( istr );
	return *(_pchData+istr.QueryIB());
}
#endif	// DEBUG


/*******************************************************************

	NAME:		NLS_STR::ToOEM

	SYNOPSIS:	Convert string to OEM character set

	ENTRY:		No parameters

	EXIT:		String is in OEM character set

	RETURNS:

	NOTES:		If the string is already OEM, nothing happens.
				A string may be constructed as OEM by constructing
				as usual, then calling SetOEM().  Casemap conversion
				does NOT work on OEM strings!

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::ToOEM()
{
	if (IsOEM())
		return;			// string is already OEM

	SetOEM();

#ifdef WIN31
	::AnsiToOem( _pchData, _pchData );
#endif
}


/*******************************************************************

	NAME:		NLS_STR::ToAnsi

	SYNOPSIS:	Convert string to ANSI character set

	ENTRY:		No parameters

	EXIT:		String is in ANSI character set

	RETURNS:

	NOTES:		If the string is already ANSI (the default), nothing
				happens.

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::ToAnsi()
{
	if (!IsOEM())
		return;			// string is already ANSI

	SetAnsi();

#ifdef WIN31
	::OemToAnsi( _pchData, _pchData );
#endif
}


/*******************************************************************

	NAME:		NLS_STR::SetOEM

	SYNOPSIS:	Declares string to be in OEM character set

	ENTRY:		No parameters

	EXIT:		OEM flag set

	RETURNS:

	NOTES:		Use this method if you construct a string which is
				known to be in the OEM character set (e.g., it came
				back from a Net API).

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::SetOEM()
{
	_fsFlags |= SF_OEM;
}


/*******************************************************************

	NAME:		NLS_STR::SetAnsi

	SYNOPSIS:	Declares string to be in ANSI character set

	ENTRY:		No parameters

	EXIT:		OEM flag set

	RETURNS:

	NOTES:		This method is used primarily by NLS_STR itself,
				when an ANSI string is assigned to a previously
				OEM one.

	HISTORY:
		gregj	05/22/92	Created

********************************************************************/

VOID NLS_STR::SetAnsi()
{
	_fsFlags &= ~SF_OEM;
}


/*******************************************************************

	NAME:		NLS_STR::IsDBCSLeadByte

	SYNOPSIS:	Returns whether a character is a lead byte or not

	ENTRY:		ch - byte to check

	EXIT:		TRUE if "ch" is a lead byte

	RETURNS:

	NOTES:		This method works whether the string is OEM or ANSI.
				In a non-DBCS build, this function is inline and
				always returns FALSE.

	HISTORY:
		gregj	04/02/93	Created

********************************************************************/

BOOL NLS_STR::IsDBCSLeadByte( CHAR ch ) const
{
	return IS_LEAD_BYTE(ch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strload.cpp ===
/*****************************************************************/ 
/**                  Microsoft Windows for Workgroups                **/
/**              Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/ 

/*
    strload.cxx
    NLS/DBCS-aware string class:  LoadString methods

    This file contains the implementation of the LoadString methods
    for the NLS_STR class.  It is separate so that clients of NLS_STR who
    do not use this operator need not link to it.

    FILE HISTORY:
        rustanl    01/31/91    Created
        beng    02/07/91    Uses lmui.hxx
        gregj    03/10/92    Added caching to speed up PM ext
        gregj    04/22/93    #ifdef'd out caching to save space
*/

#include "npcommon.h"

extern "C"
{
    #include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>
#include <shlwapi.h>

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

// we define this before we include mluisupp.h so we get code
// instead of just prototypes
#define MLUI_INIT
#include <mluisupp.h>

#ifdef RESOURCE_STRING_CACHING

/*************************************************************************

    NAME:        RESOURCE_CACHE

    SYNOPSIS:    Caches a loaded resource string

    INTERFACE:    RESOURCE_CACHE()
                    Construct from an existing NLS_STR.  Automatically
                    links itself into its list.

                FindResourceCache()    [friend function]
                    Finds an ID in the list.  If not found, returns NULL,
                    else automatically promotes itself to the head of the
                    list.

                AddResourceCache()    [friend function]

                Set()
                    Sets the cached message ID and string.

                all NLS_STR methods

    PARENT:        NLS_STR

    USES:

    CAVEATS:

    NOTES:

    HISTORY:
        gregj    03/10/92    Created

**************************************************************************/

class RESOURCE_CACHE : public NLS_STR
{
friend const RESOURCE_CACHE *FindResourceCache( USHORT idMsg, RESOURCE_CACHE **ppLast,
                                                RESOURCE_CACHE **ppTrail );
friend void AddResourceCache( USHORT idMsg, const NLS_STR *nls, RESOURCE_CACHE *pLast,
                              RESOURCE_CACHE *pTrail );
protected:
    USHORT _idMsg;
    RESOURCE_CACHE *_pFwd;
    static RESOURCE_CACHE *_pList;
    static INT _cItems;
    void Promote();

public:
    RESOURCE_CACHE( USHORT idMsg, const NLS_STR &nls );
    ~RESOURCE_CACHE();
    RESOURCE_CACHE & operator=( const NLS_STR & nlsSource )
    { return (RESOURCE_CACHE&) NLS_STR::operator=( nlsSource ); }

    void Set( USHORT idMsg, const NLS_STR &nls );
};

RESOURCE_CACHE *RESOURCE_CACHE::_pList = NULL;
INT RESOURCE_CACHE::_cItems = 0;

#define RESCACHE_MAX    8    /* max number of strings to cache */

RESOURCE_CACHE::RESOURCE_CACHE( USHORT idMsg, const NLS_STR &nls )
        : NLS_STR( MAX_RES_STR_LEN + 1 ),
          _idMsg( idMsg ),
          _pFwd( NULL )
{
    if (QueryError() != WN_SUCCESS)
        return;

    *this = nls;            /* copy contents */

    _pFwd = _pList;
    _pList = this;            /* make this the new list head */

    _cItems++;                /* and count this one */
}

RESOURCE_CACHE::~RESOURCE_CACHE()
{
    RESOURCE_CACHE *pThis, *pTrail;

    for (pThis = _pList, pTrail = NULL;
         pThis != this && pThis != NULL;
         pTrail = pThis, pThis = pThis->_pFwd)
        ;

    if (pThis == NULL)
        return;

    if (pTrail == NULL)
        _pList = _pFwd;
    else
        pTrail->_pFwd = _pFwd;

    _cItems--;
}


void RESOURCE_CACHE::Promote()
{
    RESOURCE_CACHE *pThis, *pTrail;

    for (pThis = _pList, pTrail = NULL;
         pThis != this && pThis != NULL;
         pTrail = pThis, pThis = pThis->_pFwd)
        ;

    if (pThis == NULL)            /* item not found??? */
        _cItems++;                /* try to keep count accurate */
    else if (pTrail == NULL)
        return;                    /* already at list head, no change */
    else
        pTrail->_pFwd = _pFwd;    /* remove item from list */

    _pFwd = _pList;
    _pList = this;                /* make this the new list head */
}


const RESOURCE_CACHE *FindResourceCache( USHORT idMsg, RESOURCE_CACHE **ppLast,
                                         RESOURCE_CACHE **ppTrail )
{
    RESOURCE_CACHE *pThis, *pTrail;

    if (RESOURCE_CACHE::_pList == NULL) {    /* empty list? */
        *ppLast = NULL;
        *ppTrail = NULL;
        return NULL;
    }

    for (pThis = RESOURCE_CACHE::_pList;
         pThis->_pFwd != NULL && pThis->_idMsg != idMsg;
         pTrail = pThis, pThis = pThis->_pFwd)
        ;

    if (pThis->_idMsg != idMsg) {    /* item not found? */
        *ppLast = pThis;            /* return ptr to last item */
        *ppTrail = pTrail;            /* and to its predecessor */
        return NULL;
    }

    pThis->Promote();                /* item found, promote it */
    return pThis;                    /* and return it */
}


void AddResourceCache( USHORT idMsg, const NLS_STR *nls, RESOURCE_CACHE *pLast,
                        RESOURCE_CACHE *pTrail )
{
    if (RESOURCE_CACHE::_cItems < RESCACHE_MAX) {    /* cache not full, make a new entry */
        RESOURCE_CACHE *pNew = new RESOURCE_CACHE( idMsg, *nls );
                            /* automatically adds itself to the list */
    }
    else {
        if (pTrail != NULL) {        /* if not already first item */
            pTrail->_pFwd = pLast->_pFwd;    /* unlink from list */
            pLast->_pFwd = RESOURCE_CACHE::_pList;    /* and move to front */
            RESOURCE_CACHE::_pList = pLast;
        }

        pLast->Set( idMsg, *nls );    /* set new contents */
    }
}


void RESOURCE_CACHE::Set( USHORT idMsg, const NLS_STR &nls )
{
    *this = nls;
    _idMsg = idMsg;
}

#endif    /* RESOURCE_STRING_CACHING */


/*******************************************************************

    NAME:        NLS_STR::LoadString

    SYNOPSIS:    Loads a string from a resource file.

    ENTRY:

    EXIT:        Returns an error value, which is WN_SUCCESS on success.

    NOTES:        Requires that owner alloc strings must have an allocated
                size enough to fit strings of length MAX_RES_STR_LEN.
                This is requires even if the programmer thinks the string
                to be loaded is very small.  The reason is that after the
                string has been localized, the string length bound is not
                known.    Hence, the programmer always needs to allocate
                MAX_RES_STR_LEN + 1 bytes, which is guaranteed to be
                enough.

    HISTORY:
        rustanl    01/31/91    Created
        beng    07/23/91    Allow on erroneous string
        gregj    04/22/93    #ifdef'd out caching to save space

********************************************************************/

USHORT NLS_STR::LoadString( USHORT usMsgID )
{
    if (QueryError())
        return (USHORT) QueryError();

    //    Impose requirement on owner alloc'd strings (see function header).
    UIASSERT( !IsOwnerAlloc() ||
              ( QueryAllocSize() >= MAX_RES_STR_LEN + 1 ));

    if ( ! IsOwnerAlloc())
    {
        //  Resize the buffer to be big enough to hold any message.
        //  If the buffer is already this big, realloc will do nothing.
        if ( ! realloc( MAX_RES_STR_LEN + 1 ))
        {
            return WN_OUT_OF_MEMORY;
        }
    }

    //    At this point, we have a buffer which is big enough.
    UIASSERT( QueryAllocSize() >= MAX_RES_STR_LEN );

#ifdef RESOURCE_STRING_CACHING
    RESOURCE_CACHE *pLast, *pTrail;
    const RESOURCE_CACHE *prc = FindResourceCache( usMsgID, &pLast, &pTrail );
    if (prc != NULL) {
        *this = *prc;        /* copy contents */
        return WN_SUCCESS;    /* all done */
    }
#endif    /* RESOURCE_STRING_CACHING */

    int cbCopied = MLLoadStringA(usMsgID, (LPSTR)QueryPch(),
                                 QueryAllocSize());
    if ( cbCopied == 0 )
    {
        return WN_BAD_VALUE;
    }

    _cchLen = cbCopied;
    IncVers();

#ifdef RESOURCE_STRING_CACHING
    AddResourceCache( usMsgID, this, pLast, pTrail );
#endif    /* RESOURCE_STRING_CACHING */

    return WN_SUCCESS;
}


/*******************************************************************

    NAME:        NLS_STR::LoadString

    SYNOPSIS:    Loads a string from a resource file, and then inserts
                some parameters into it.

    ENTRY:

    EXIT:        Returns an error value, which is WN_SUCCESS on success.

    NOTES:        This method is provides a simple way to call the above
                LoadString and InsertParams consecutively.

    HISTORY:
        rustanl    01/31/91    Created

********************************************************************/

USHORT NLS_STR::LoadString( USHORT usMsgID,
                            const NLS_STR * apnlsParamStrings[] )
{
    USHORT usErr = LoadString( usMsgID );

    if ( usErr == WN_SUCCESS )
    {
        usErr = InsertParams( apnlsParamStrings );
    }

    return usErr;
}


#ifdef EXTENDED_STRINGS
/*******************************************************************

    NAME:        RESOURCE_STR::RESOURCE_STR

    SYNOPSIS:    Constructs a nls-string from a resource ID.

    ENTRY:        idResource

    EXIT:        Successful construct, or else ReportError

    NOTES:        This string may not be owner-alloc!  For owner-alloc,
                cons up a new one and copy this into it.

    HISTORY:
        beng    07/23/91    Created

********************************************************************/

RESOURCE_STR::RESOURCE_STR( UINT idResource )
    : NLS_STR()
{
    UIASSERT(!IsOwnerAlloc());

    USHORT usErr = LoadString(idResource);
    if (usErr)
        ReportError(usErr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strparty.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strparty.cxx
	NLS/DBCS-aware string class: party support

	This file contains the implementation of the Party() and
	DonePartying() methods of NLS_STR, used for string operations
	outside the set supported by NLS_STR itself.

	FILE HISTORY:
		gregj	03/25/93	Created
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::Party

	SYNOPSIS:	Obtains read-write access to the string buffer, and
				disables standard member function access to the string.

	ENTRY:		No parameters

	EXIT:		Returns a pointer to the string, NULL if in an error state

	NOTES:		Use Party() with care.  Check your partying code to
				make sure it's DBCS-safe, doesn't overflow the string
				buffer, etc.

				Each Party() must be matched with a DonePartying() call.
				They cannot be nested.  It's probably not a good idea
				to leave a string in the Party()ing state for long.

	HISTORY:
		gregj	03/25/93	Created

********************************************************************/

CHAR *NLS_STR::Party()
{
	if (QueryError())
		return NULL;

	ReportError( WN_ACCESS_DENIED );	// keep other folks out
	return _pchData;					// OK, go party
}


/*******************************************************************

	NAME:		NLS_STR::DonePartying

	SYNOPSIS:	Releases read-write access to the string buffer, and
				re-enables standard member access.

	ENTRY:		cchNew - new string length (may be omitted, in which
						 case it's determined by strlenf())

	EXIT:		No return value

	NOTES:

	HISTORY:
		gregj	03/25/93	Created
        lens    03/16/94    Don't let Party/DonePartying pairs lose hard allocation errors.

********************************************************************/

VOID NLS_STR::DonePartying( INT cchNew )
{
	_cchLen = cchNew;			// store new length
	if (QueryError() == WN_ACCESS_DENIED ) {
    	ReportError( WN_SUCCESS );	// standard members can access now
    }
	IncVers();					// all ISTRs are invalid now
}


VOID NLS_STR::DonePartying( VOID )
{
	DonePartying( ::strlenf( _pchData ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strncpy.cpp ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	strncpy.c
	NLS/DBCS-aware string class: strncpy method

	This file contains the implementation of the strncpy method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		gregj	04/08/93	Created
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strncpy

	SYNOPSIS:	Copy non-null-terminated string

	ENTRY:		pchSource - string to copy
				cbSource - number of bytes to copy

	EXIT:		If successful, contents of string overwritten.
				If failed, the original contents of the string remain.

	RETURNS:	Reference to self.

	HISTORY:
		gregj	04/08/93	Created

********************************************************************/

NLS_STR& NLS_STR::strncpy( const CHAR *pchSource, UINT cbSource )
{
	if ( cbSource == 0)
		pchSource = NULL;

	if ( pchSource == NULL )
	{
		if ( !IsOwnerAlloc() && !QueryAllocSize() )
		{
			if ( !Alloc(1) )
				ReportError( WN_OUT_OF_MEMORY );
			return *this;
		}

		UIASSERT( QueryAllocSize() > 0 );

		*_pchData = '\0';
		_cchLen = 0;
	}
	else
	{
		if ( !IsOwnerAlloc() )
		{
			if ( (UINT)QueryAllocSize() < cbSource + 1 )
			{
				CHAR * pchNew = new CHAR[cbSource + 1];

				if ( pchNew == NULL )
				{
					ReportError( WN_OUT_OF_MEMORY );
					return *this;
				}

				delete _pchData;
				_pchData = pchNew;
				_cbData = cbSource + 1;
			}
		}
		else
		{
			if ((UINT)QueryAllocSize() < cbSource + 1)
				cbSource = QueryAllocSize() - 1;
		}

		::strncpyf( _pchData, pchSource, cbSource );

		/*
		 * Get the new length of the string.  It may not necessarily be
		 * cbSource because if the string is getting truncated, cbSource
		 * might be halfway through a double-byte character.
		 */

		 _pchData[cbSource] = '\0';

		_cchLen = ::strlenf( _pchData );
		
	}

	IncVers();

	/* Reset the error state, since the string is now valid.
	 */	
	ReportError( WN_SUCCESS );
	return *this;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strncmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strncmp.cxx
	NLS/DBCS-aware string class: strncmp method

	This file contains the implementation of the strncmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strncmp

	SYNOPSIS:	Case sensitve string compare up to index position istrLen

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/15/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

INT NLS_STR::strncmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrEnd );

	return ::strncmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIB() );
}


INT NLS_STR::strncmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB() );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );

	return ::strncmpf( QueryPch(istrStart1),
					   nls.QueryPch(),
					   istrEnd - istrStart1 );
}


INT NLS_STR::strncmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB() );
	UIASSERT( istrEnd.QueryIB() >= istrStart2.QueryIB() );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::strncmpf( QueryPch(istrStart1),
					   nls.QueryPch(istrStart2),
					   istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strnicmp.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strnicmp.cxx
	NLS/DBCS-aware string class: strnicmp method

	This file contains the implementation of the strnicmp method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strnicmp

	SYNOPSIS:	Case insensitve string compare up to index position istrEnd

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/15/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

int NLS_STR::strnicmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd ) const
{
	if (QueryError() || !nls)
		return 0;

	CheckIstr( istrEnd );

	return ::strnicmpf( QueryPch(), nls.QueryPch(), istrEnd.QueryIB() );
}


int NLS_STR::strnicmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB() );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );

	return ::strnicmpf( QueryPch(istrStart1),
						nls.QueryPch(),
						istrEnd - istrStart1 );
}


int NLS_STR::strnicmp(
	const NLS_STR & nls,
	const ISTR	  & istrEnd,
	const ISTR	  & istrStart1,
	const ISTR	  & istrStart2 ) const
{
	if (QueryError() || !nls)
		return 0;

	UIASSERT( istrEnd.QueryIB() >= istrStart1.QueryIB()  );
	UIASSERT( istrEnd.QueryIB() >= istrStart2.QueryIB()  );
	CheckIstr( istrEnd );
	CheckIstr( istrStart1 );
	nls.CheckIstr( istrStart2 );

	return ::strnicmpf( QueryPch(istrStart1),
						nls.QueryPch(istrStart2),
						istrEnd - istrStart1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strprof.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strprof.c
	NLS/DBCS-aware string class:  GetPrivateProfileString method

	This file contains the implementation of the GetPrivateProfileString method
	for the NLS_STR class.  It is separate so that clients of NLS_STR who
	do not use this operator need not link to it.

	FILE HISTORY:
		04/08/93	gregj	Created
*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::GetPrivateProfileString

	SYNOPSIS:	Loads a string from an INI file.

	ENTRY:		pszFile - name of INI file to read.
				pszSection - name of section (excluding square brackets).
				pszKey - key name to retrieve.
				pszDefault - default value if key not found.

	EXIT:		String contains the value associated with the key.

	NOTES:		The string is truncated if it's being loaded into an
				owner-alloc string and doesn't entirely fit.

				No character-set assumptions are made about the string.
				If the character set of the string being loaded is
				different from the ambient set of the NLS_STR, use
				SetOEM() or SetAnsi() to make the NLS_STR correct.

	HISTORY:
		gregj	04/08/93	Created

********************************************************************/

VOID NLS_STR::GetPrivateProfileString( const CHAR *pszFile,
									   const CHAR *pszSection,
									   const CHAR *pszKey,
									   const CHAR *pszDefault /* = NULL */ )
{
	static CHAR szNull[] = "";

	if (QueryError())
		return;

	if (pszDefault == NULL)
		pszDefault = szNull;

	if (!IsOwnerAlloc() && !QueryAllocSize()) {
		if (!realloc( MAX_RES_STR_LEN )) {
			ReportError( WN_OUT_OF_MEMORY );
			return;
		}
	}

	INT cbCopied;

	for (;;) {						/* really just tries twice */
		cbCopied = ::GetPrivateProfileString( pszSection, pszKey,
							pszDefault, _pchData, _cbData, pszFile );

		if (IsOwnerAlloc() || cbCopied < QueryAllocSize() - 1 ||
			(QueryAllocSize() >= MAX_RES_STR_LEN))
			break;					/* string fit, or can't grow */

		if (!realloc( MAX_RES_STR_LEN ))
			break;					/* tried to grow, but couldn't */
	}

	_cchLen = cbCopied;
	IncVers();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strrchr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strrchr.cxx
	NLS/DBCS-aware string class: strrchr method

	This file contains the implementation of the strrchr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strrchr

	SYNOPSIS:	Puts the index of the last occurrence of ch in *this into
				istrPos.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/26/90	Written
		beng	07/23/91	Allow on erroneous string; update CheckIstr

********************************************************************/

BOOL NLS_STR::strrchr( ISTR * pistrPos, const CHAR ch ) const
{
	if (QueryError())
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strrchrf( QueryPch(), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::strrchr(
	ISTR *pistrPos,
	const CHAR ch,
	const ISTR& istrStart ) const
{
	if (QueryError())
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strrchrf(QueryPch(istrStart), ch );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strqss.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strqss.cxx
	NLS/DBCS-aware string class: QuerySubStr method

	This file contains the implementation of the QuerySubStr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


// Magic value used below
//
#define CB_ENTIRE_STRING (-1)


/*******************************************************************

	NAME:		NLS_STR::QuerySubStr

	SYNOPSIS:	Return a pointer to a new NLS_STR that contains the contents
				of *this from istrStart to:
				  istrStart end of string or
				  istrStart + istrEnd

	ENTRY:

	EXIT:

	RETURNS:	Pointer to newly alloc'd NLS_STR, or NULL if error

	NOTES:		The private method QuerySubStr(ISTR&, CB) is the worker
				method, the other two just check the parameters and
				pass the data. It is private since we can't allow the
				user to access the string on a byte basis

	CAVEAT:		Note that this method creates an NLS_STR that the client is
				responsible for deleting.

	HISTORY:
		johnl	11/26/90	Created
		beng	04/26/91	Replaced CB wth INT; broke out CB_ENTIRE_STRING
							magic value
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart, INT cbLen ) const
{
	if (QueryError())
		return NULL;

	CheckIstr( istrStart );

	INT cchStrLen = ::strlenf(QueryPch(istrStart) );
	INT cbCopyLen = ( cbLen == CB_ENTIRE_STRING || cbLen >= cchStrLen )
					? cchStrLen
					: cbLen;

	NLS_STR *pnlsNew = new NLS_STR( cbCopyLen + 1 );
	if ( pnlsNew == NULL )
		return NULL;

	if ( pnlsNew->QueryError() )
	{
		delete pnlsNew;
		return NULL;
	}

	::memcpyf( pnlsNew->_pchData, QueryPch(istrStart), cbCopyLen );
	*(pnlsNew->_pchData + cbCopyLen) = '\0';

	pnlsNew->_cchLen = cbCopyLen;

	return pnlsNew;
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR & istrStart ) const
{
	return QuerySubStr( istrStart, CB_ENTIRE_STRING );
}


NLS_STR * NLS_STR::QuerySubStr( const ISTR  & istrStart,
								const ISTR  & istrEnd  ) const
{
	CheckIstr( istrEnd );
	UIASSERT( istrEnd.QueryIB() >= istrStart.QueryIB() );

	return QuerySubStr( istrStart, istrEnd - istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strupr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strupr.cxx
	NLS/DBCS-aware string class: strupr method

	This file contains the implementation of the strupr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strupr

	SYNOPSIS:	Convert *this lower case letters to upper case

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/26/90	Written
		beng	07/23/91	Allow on erroneous string

********************************************************************/

NLS_STR& NLS_STR::strupr()
{
	if (!QueryError())
		::struprf( _pchData );

	return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strspn.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strspn.cxx
	NLS/DBCS-aware string class: strspn method

	This file contains the implementation of the strspn method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strspn

	SYNOPSIS:	Find first char in *this that is not a char in arg. and puts
				the position in pistrPos.
				Returns FALSE when no characters do not match

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strspn( ISTR * pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	pistrPos->SetIB( ::strspnf( QueryPch(), nls.QueryPch() ) );
	return *QueryPch( *pistrPos ) != '\0';
}


BOOL NLS_STR::strspn( ISTR *	      pistrPos,
					  const NLS_STR & nls,
					  const ISTR    & istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( istrStart );

	pistrPos->SetIB( ::strspnf(QueryPch( istrStart ), nls.QueryPch() ) +
					 istrStart.QueryIB()  );
	return *QueryPch( *pistrPos ) != '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strrss.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strrss.cxx
	NLS/DBCS-aware string class: strrss method

	This file contains the implementation of the strrss method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::ReplSubStr

	SYNOPSIS:	Replace the substring starting at istrStart with the
				passed nlsRepl string.

				If both a start and end is passed, then the operation is
				equivalent to a DelSubStr( start, end ) and an
				InsertSubStr( start ).

				If just a start is passed in, then the operation is
				equivalent to DelSubStr( start ), concat new string to end.

				The ReplSubStr( NLS_STR&, istrStart&, INT cbDel) method is
				private.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/29/90	Created
		beng	04/26/91	Replaced CB with INT
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

VOID NLS_STR::ReplSubStr( const NLS_STR & nlsRepl, ISTR& istrStart )
{
	if (QueryError() || !nlsRepl)
		return;

	CheckIstr( istrStart );

	DelSubStr( istrStart );
	strcat( nlsRepl );
}


VOID NLS_STR::ReplSubStr( const NLS_STR& nlsRepl,
						  ISTR& istrStart,
						  const ISTR& istrEnd )
{
	CheckIstr( istrEnd );
	UIASSERT( istrEnd.QueryIB() >= istrStart.QueryIB() );

	ReplSubStr( nlsRepl, istrStart, istrEnd - istrStart );
}


VOID NLS_STR::ReplSubStr( const NLS_STR& nlsRepl,
						  ISTR& istrStart,
						  INT cbToBeDeleted )
{
	if (QueryError() || !nlsRepl)
		return;

	CheckIstr( istrStart );

	INT cbRequired = strlen() - cbToBeDeleted + nlsRepl.strlen() + 1;
	if ( !IsOwnerAlloc() && QueryAllocSize() < cbRequired )
	{
		if ( !realloc( cbRequired ) )
		{
			ReportError( WN_OUT_OF_MEMORY );
			return;
		}
	}
	else
		UIASSERT( QueryAllocSize() >= cbRequired );

	CHAR * pchStart = (CHAR *)QueryPch(istrStart) + cbToBeDeleted;
	::memmovef( pchStart + nlsRepl.strlen()-cbToBeDeleted,
				pchStart,
				::strlenf( pchStart ) + 1 );
	::memmovef( (CHAR *)QueryPch(istrStart),
				nlsRepl._pchData,
				nlsRepl.strlen() );

	_cchLen = strlen() + nlsRepl.strlen() - cbToBeDeleted;

	IncVers();
	UpdateIstr( &istrStart );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strstr.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strstr.cxx
	NLS/DBCS-aware string class: strstr method

	This file contains the implementation of the strstr method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strstr

	SYNOPSIS:	Returns TRUE if the passed string is found, false otherwise.
				pistrPos contains start of the specified string if TRUE
				is returned.

	ENTRY:

	EXIT:

	NOTES:

	HISTORY:
		johnl	11/16/90	Written
		beng	07/23/91	Allow on erroneous string; simplified CheckIstr

********************************************************************/

BOOL NLS_STR::strstr( ISTR * pistrPos, const NLS_STR & nls ) const
{
	if (QueryError() || !nls)
		return FALSE;

	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strstrf( QueryPch(), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchStrRes - QueryPch()));
	return TRUE;
}


BOOL NLS_STR::strstr( ISTR    * pistrPos,
					  const NLS_STR & nls,
					  const ISTR    & istrStart ) const
{
	if (QueryError() || !nls)
		return FALSE;

	CheckIstr( istrStart );
	UpdateIstr( pistrPos );
	CheckIstr( *pistrPos );

	const CHAR * pchStrRes = ::strstrf(QueryPch(istrStart), nls.QueryPch() );

	if ( pchStrRes == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int)(pchStrRes - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\strtok.cpp ===
/*****************************************************************/ 
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
	strtok.cxx
	NLS/DBCS-aware string class: strtok method

	This file contains the implementation of the strtok method
	for the STRING class.  It is separate so that clients of STRING which
	do not use this operator need not link to it.

	FILE HISTORY:
		beng	01/18/91	Separated from original monolithic .cxx
		beng	02/07/91	Uses lmui.hxx

*/

#include "npcommon.h"

extern "C"
{
	#include <netlib.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <npassert.h>

#include <npstring.h>


/*******************************************************************

	NAME:		NLS_STR::strtok

	SYNOPSIS:	Basic strtok functionality.  Returns FALSE after the
				string has been traversed.

	ENTRY:

	EXIT:

	NOTES:		We don't update the version on the string since the
				::strtokf shouldn't cause DBCS problems.  It would also
				be painful on the programmer if on each call to strtok
				they had to update all of the ISTR associated with this
				string

				fFirst is required to be TRUE on the first call to
				strtok, it is FALSE afterwards (is defaulted to FALSE)

	CAVEAT:		Under windows, all calls to strtok must be done while
				processing a single message.  Otherwise another process
				my confuse it.

	HISTORY:
		johnl	11/26/90	Created
		beng	07/23/91	Allow on erroneous string

********************************************************************/

BOOL NLS_STR::strtok( 
	ISTR *pistrPos,
	const NLS_STR& nlsBreak,
	BOOL fFirst )
{
	if (QueryError())
		return FALSE;

	const CHAR * pchToken = ::strtokf( fFirst ? _pchData : NULL, (CHAR *)nlsBreak.QueryPch());

	if ( pchToken == NULL )
	{
		pistrPos->SetIB( strlen() );
		return FALSE;
	}

	pistrPos->SetIB((int) (pchToken - QueryPch()));
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\upr.cpp ===
#include "npcommon.h"

/* In a DBCS build, the Win32 CharUpper API will uppercase double-byte
 * Romanji characters, but many low-level network components such as
 * IFSMGR (and NetWare servers!) do not uppercase any double-byte
 * characters.  So we have to have our own function which avoids them.
 *
 * This could be implemented by just calling CharUpper on each character,
 * but the NLS APIs have a fair amount of overhead to them, so calling
 * into the NLS subsystem as few times as possible is desirable.
 */
LPSTR WINAPI struprf(LPSTR lpString)
{
    if (!::fDBCSEnabled)
        return CharUpper(lpString);

	LPSTR pchStart = lpString;

	while (*pchStart != '\0') {
		// Skip any double-byte characters that may be here.
		// Don't need to check for end of string in the loop because
		// the null terminator is not a DBCS lead byte.
		while (IsDBCSLeadByte(*pchStart))
			pchStart += 2;	/* skip double-byte chars */

		if (*pchStart == '\0')
			break;			/* no more SBCs to uppercase */

		// Find the end of this range of single-byte characters, and
		// uppercase them.
		LPSTR pchEnd = pchStart + 1;
		while (*pchEnd && !IsDBCSLeadByte(*pchEnd))
			pchEnd++;		/* count single-byte chars */

		CharUpperBuff(pchStart, (int)(pchEnd-pchStart));
		pchStart = pchEnd;
	}

	return lpString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\common\timedata.cpp ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/
/* :ts=4 */

/***	timedata.cpp - table of days in each month for time conversion
 */

#include "npcommon.h"
#include <convtime.h>

WORD MonTotal[] = { 0,					// dummy entry for month 0
	0,									// days before Jan 1
	31,									// days before Feb 1
	31+28,								// days before Mar 1
	31+28+31,							// days before Apr 1
	31+28+31+30,						// days before May 1
	31+28+31+30+31,						// days before Jun 1
	31+28+31+30+31+30,					// days before Jul 1
	31+28+31+30+31+30+31,				// days before Aug 1
	31+28+31+30+31+30+31+31, 			// days before Sep 1
	31+28+31+30+31+30+31+31+30,			// days before Oct 1
	31+28+31+30+31+30+31+31+30+31,		// days before Nov 1
	31+28+31+30+31+30+31+31+30+31+30,	// days before Dec 1
	31+28+31+30+31+30+31+31+30+31+30+31	// days before end of year
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\convtime.h ===
/*****************************************************************/
/**		      	Copyright (C) Microsoft Corp., 1996				**/
/*****************************************************************/ 

/* CONVTIME.H -- Header file for time conversion subroutines.
 *
 * History:
 *	gregj	04/22/96	Created for subroutines snarfed from vredir.
 */


#ifndef _INC_CONVTIME
#define _INC_CONVTIME

#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif


#define _70_to_80_bias	0x012CEA600L
#define SECS_IN_DAY (60L*60L*24L)
#define SEC2S_IN_DAY (30L*60L*24L)
#define FOURYEARS	(3*365+366)

extern WORD MonTotal[];


typedef struct tagdos_time {
	WORD dt_date;
	WORD dt_time;
} dos_time;

void
NetToDosDate(
DWORD time,
dos_time *pinfo);

DWORD
DosToNetDate(dos_time dt);

void
NetToSystemDate(
DWORD time,
LPSYSTEMTIME pinfo);

DWORD
SystemToNetDate(LPSYSTEMTIME pinfo);

DWORD
GetCurrentNetDate(void);

DWORD
GetLocalNetDate(void);


#ifdef __cplusplus
};	/* extern "C" */
#endif

#endif	/* RC_INVOKED */

#endif	/* _INC_CONVTIME */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\base.h ===
/*****************************************************************/ 
/**				Microsoft Windows for Workgroups				**/
/**			Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/*
    base.h
    Universal base class for error cascading and debugging information

    FILE HISTORY
	beng	    09-Jul-1990     created
	beng	    17-Jul-1990     added standard comment header to BASE
	beng	    31-Jul-1991     added FORWARDING_BASE
	rustanl     11-Sep-1991     Added DECLARE_OUTLINE_NEWBASE,
				    DECLARE_MI_NEWBASE, DEFINE_MI2_NEWBASE,
				    DEFINE_MI3_NEWBASE, and DEFINE_MI4_NEWBASE
	gregj		22-Mar-1993		Ported to Chicago environment
*/


#ifndef _BASE_HXX_
#define _BASE_HXX_

/*************************************************************************

    NAME:	BASE (base)

    SYNOPSIS:	Universal base object, root of every class.
		It contains universal error status and debugging
		support.

    INTERFACE:	ReportError()	- report an error on the object from
				  within the object.

		QueryError()	- return the current error state,
				  or 0 if no error outstanding.

		operator!()	- return TRUE if an error is outstanding.
				  Typically means that construction failed.

    CAVEATS:	This sort of error reporting is safe enough in a single-
		threaded system, but loses robustness when multiple threads
		access shared objects.	Use it for constructor-time error
		handling primarily.

    NOTES:	A class which inherits BASE through a private class should
		use the NEWBASE macro (q.v.) in its definition; otherwise
		its clients will lose the use of ! and QueryError.

    HISTORY:
	rustanl     07-Jun-1990     Created as part of LMOD
	beng	    09-Jul-1990     Gutted, removing LMOD methods
	beng	    17-Jul-1990     Added USHORT error methods
	beng	    19-Oct-1990     Finally, removed BOOL error methods
	johnl	    14-Nov-1990     Changed QueryError to be a const method
	beng	    25-Jan-1991     Added the ! Boolean operator and NEWBASE
	beng	    31-Jul-1991     Made FORWARDING_BASE a friend
	gregj		22-Mar-1993		Ported to Chicago (removed excess baggage)

*************************************************************************/

class BASE
{
private:
    UINT _err;

protected:
    BASE() { _err = 0; }
    VOID    ReportError( WORD err ) { _err = err; }

public:
    UINT	QueryError() const { return _err; }
    BOOL    operator!() const  { return (_err != 0); }
};

#endif // _BASE_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\buffer.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* BUFFER.H -- Definition of BUFFER class.
 *
 * History:
 *	03/22/93	gregj	Created
 *	03/24/93	gregj	Created base class, GLOBAL_BUFFER
 *	10/06/93	gregj	Removed LOCAL_BUFFER and GLOBAL_BUFFER because
 *						they're incompatible with Win32.
 */

#ifndef _INC_BUFFER
#define _INC_BUFFER

/*************************************************************************

    NAME:		BUFFER_BASE

    SYNOPSIS:	Base class for transient buffer classes

    INTERFACE:	BUFFER_BASE()
					Construct with optional size of buffer to allocate.

				Resize()
					Resize buffer to specified size.  Returns TRUE if
					successful.

				QuerySize()
					Return the current size of the buffer in bytes.

				QueryPtr()
					Return a pointer to the buffer.

    PARENT:		None

    USES:		None

    CAVEATS:	This is an abstract class, which unifies the interface
				of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:		In standard OOP fashion, the buffer is deallocated in
				the destructor.

    HISTORY:
		03/24/93	gregj	Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
	UINT _cb;

	virtual BOOL Alloc( UINT cbBuffer ) = 0;
	virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
	BUFFER_BASE()
		{ _cb = 0; }	// buffer not allocated yet
	~BUFFER_BASE()
		{ _cb = 0; }	// buffer size no longer valid
	BOOL Resize( UINT cbNew );
	UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER	BUFFER

/*************************************************************************

    NAME:		BUFFER

    SYNOPSIS:	Wrapper class for new and delete

    INTERFACE:	BUFFER()
					Construct with optional size of buffer to allocate.

				Resize()
					Resize buffer to specified size.  Only works if the
					buffer hasn't been allocated yet.

				QuerySize()
					Return the current size of the buffer in bytes.

				QueryPtr()
					Return a pointer to the buffer.

    PARENT:		BUFFER_BASE

    CAVEATS:

    NOTES:		In standard OOP fashion, the buffer is deallocated in
				the destructor.

    HISTORY:
		03/24/93	gregj	Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
	CHAR *_lpBuffer;

	virtual BOOL Alloc( UINT cbBuffer );
	virtual BOOL Realloc( UINT cbBuffer );

public:
	BUFFER( UINT cbInitial=0 );
	~BUFFER();
	LPVOID QueryPtr() const { return (LPVOID)_lpBuffer; }
	operator void*() const { return (void *)_lpBuffer; }
};

#define LOCAL_BUFFER	BUFFER

#endif	/* _INC_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\contxids.h ===
/*
   Definitions of Help IDs
*/
#define IDH_IGNORE                                              (-1)

/* Options - Appearance Page */
#define IDH_APPEARANCE_SHOW_PICTURES                            0x1000  
#define IDH_APPEARANCE_USE_CUSTOM_COLORS                        0x1001  
#define IDH_APPEARANCE_COLORS_TEXT                              0x1002  
#define IDH_APPEARANCE_COLORS_BACKGROUND                        0x1003  
#define IDH_APPEARANCE_COLORS_VIEWED                            0x1004  
#define IDH_APPEARANCE_COLORS_NOT_VIEWED                        0x1005  
#define IDH_APPEARANCE_UNDERLINE_SHORTCUTS                      0x1006  
#define IDH_APPEARANCE_SHOW_URL_IN_SB                           0x1007
#define IDH_APPEARANCE_SHOW_SIMPLE_URL                          0x1008  
#define IDH_APPEARANCE_SHOW_FULL_URL                            0x1009 

/* Options - Home Base */
#define IDH_HOME_BASE_USE_CURRENT                               0x100a
#define IDH_HOME_BASE_USE_DEFAULT                               0x100b

/* Options - Advanced Page */
#define IDH_ADVANCED_HST_NUM_PLACES                             0x100c
#define IDH_ADVANCED_HST_EMPTY                                  0x100d
#define IDH_ADVANCED_HST_LOCATION                               0x100e  
#define IDH_ADVANCED_HST_BROWSE                                 0x100f
#define IDH_ADVANCED_CACHE_PERCENT                              0x1010
#define IDH_ADVANCED_CACHE_EMPTY                                0x1011
#define IDH_ADVANCED_CACHE_LOCATION                             0x1012  
#define IDH_ADVANCED_CACHE_BROWSE                               0x1013

/* Goto Dialog Box */
#define IDH_GOTOURL_COMBO                                       0x1014
#define IDH_GOTOURL_NEWWINDOW                                   0x1015
#define IDH_GOTOURL_OPENFILE                                    0x1016

/* Find Dialog Box */
#define IDH_FIND_TEXTTOFIND                                     0x1017
#define IDH_FIND_STARTFROMTOP                                   0x1018
#define IDH_FIND_MATCHCASE                                      0x1019
#define IDH_FIND_FINDNEXT                                       0x101a

/* Page Setup Dialog Box */
#define IDH_PAGESETUP_MARGIN_LEFT                               0x101b
#define IDH_PAGESETUP_MARGIN_TOP                                0x101c
#define IDH_PAGESETUP_MARGIN_RIGHT                              0x101d
#define IDH_PAGESETUP_MARGIN_BOTTOM                             0x101e
#define IDH_PAGESETUP_HEADER_LEFT                               0x101f
#define IDH_PAGESETUP_HEADER_RIGHT                              0x1020
#define IDH_PAGESETUP_FOOTER_LEFT                               0x1021
#define IDH_PAGESETUP_FOOTER_RIGHT                              0x1022

/* More Options - Advanced Page */
#define IDH_ADVANCED_CACHE_ONCEPERSESS                          0x1023
#define IDH_ADVANCED_CACHE_NEVER                                0x1024

/* File Type */
#define IDH_FILETYPE_CONTENT_TYPE                               0x1025
#define IDH_FILETYPE_OPENS_WITH                                 0x1026
#define IDH_NEW_FILETYPE_CONTENT_TYPE                           0x1027
#define IDH_NEWFILETYPE_DEFAULT_EXT                             0x1028
#define IDH_FILETYPE_EXTENSION                                  0x1029

/* New Help IDs for Internet Explorer 1.x below */
/* More Options - Appearance */
#define IDH_APPEARANCE_PLAY_SOUNDS                              0x102a
#define IDH_APPEARANCE_PROPORTIONAL_FONT                        0x102b
#define IDH_APPEARANCE_FIXED_FONT                               0x102c
#define IDH_APPEARANCE_SHOW_URL                                 0x102d

/* Options - News */
#define IDH_NEWS_SERVER                                         0x102e
#define IDH_NEWS_ENABLE_AUTH                                    0x102f
#define IDH_NEWS_USERNAME                                       0x1030
#define IDH_NEWS_PASSWORD                                       0x1031
#define IDH_NEWS_ON_OFF                                         0x104a  /* note order! */

/* Options - Start and Search Pages */
#define IDH_PAGES_LISTBOX                                       0x1032
#define IDH_PAGES_START_URL                                     0x1033
#define IDH_PAGES_START_USE_CURRENT                             0x1034
#define IDH_PAGES_START_USE_DEFAULT                             0x1035
#define IDH_PAGES_SEARCH_URL                                    0x1036
#define IDH_PAGES_SEARCH_USE_CURRENT                            0x1037
#define IDH_PAGES_SEARCH_USE_DEFAULT                            0x1038

/* Options - Security */
#define IDH_SECURITY_TELL_ME                                    0x1039
#define IDH_SECURITY_SEND_HIGH                                  0x103a
#define IDH_SECURITY_SEND_MED                                   0x103b
#define IDH_SECURITY_SEND_LOW                                   0x103c
#define IDH_SECURITY_VIEW_HIGH                                  0x103d
#define IDH_SECURITY_VIEW_LOW                                   0x103e




/* Properties - General */
#define IDH_PROPG_ICON                                          0x103f
#define IDH_PROPG_TITLE                                         0x1040
#define IDH_PROPG_PROTOCOL                                      0x1041
#define IDH_PROPG_TYPE                                          0x1042
#define IDH_PROPG_URL                                           0x1043
#define IDH_PROPG_SIZE                                          0x1044
#define IDH_PROPG_CREATED                                       0x1045
#define IDH_PROPG_MODIFIED                                      0x1046
#define IDH_PROPG_UPDATED                                       0x1047

/* Properties - Security */
#define IDH_PROPS_DESC                                          0x1048
#define IDH_PROPS_CERT                                          0x1049
/* used above: #define IDH_NEWS_ON_OFF                          0x104a  */

/* File Type (continued from above) */
#define IDH_FILETYPE_CONFIRM_OPEN                               0X104b
#define IDH_APPEARANCE_SHOW_VIDEO                               0x104c


#define IDH_COMMON_GROUPBOX                                     0x104d

#define IDH_ADVANCED_ASSOC_CHECK                                0x104e 

#ifndef IDH_GROUPBOX
/* Common group box help ID */
#define IDH_GROUPBOX                                            0x2000
#endif

/* help topic that the user gets when he clicks on 
 "tell me about Internet Security" Button */
#define HELP_TOPIC_SECURITY                                     0x104f

#define IDH_SECURITY_BAD_CN_SEND                                0x1050
#define IDH_SECURITY_BAD_CN_RECV                                0x1051


/* help topic that the user gets when he clicks on 
  Help Button in Proxy settings page*/
#define HELP_TOPIC_PROXY_SUPPORT                   HELP_TOPIC_SECURITY


/* Help button at bottom of Print/headers & footers dialog */
#define IDH_PAGESETUP_OVERVIEW                                  0x1052

/* new fields on news tab */
#define IDH_NEWS_EMAIL_ADDRESS                                  0x1053
#define IDH_NEWS_POSTING_NAME                                   0x1054

/* ratings control panel */
#define IDH_RATINGS_SET_RATINGS_BUTTON                          0x1055
#define IDH_RATINGS_TURNON_BUTTON                               0x1056
#define IDH_RATINGS_CATEGORY_LABEL                              0x1057
#define IDH_RATINGS_CATEGORY_LIST                               0x1058
#define IDH_RATINGS_RATING_LABEL                                0x1059
#define IDH_RATINGS_RATING_TEXT                                 0x105a
#define IDH_RATINGS_DESCRIPTION_LABEL                           0x105b
#define IDH_RATINGS_DESCRIPTION_TEXT                            0x105c
#define IDH_RATINGS_UNRATED_CHECKBOX                            0x105d
#define IDH_RATINGS_RATING_SYSTEM_BUTTON                        0x105e
#define IDH_RATINGS_RATING_SYSTEM_TEXT                          0x105f
#define IDH_RATINGS_CHANGE_PASSWORD_BUTTON                      0x1060
#define IDH_RATINGS_CHANGE_PASSWORD_TEXT                        0x1061
#define IDH_RATINGS_OVERRIDE_CHECKBOX                           0x1062
#define IDH_RATINGS_SUPERVISOR_PASSWORD                         0x1063
#define IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD                  0x1064       
#define IDH_RATINGS_CHANGE_PASSWORD_CONFIRM                     0x1065
#define IDH_RATINGS_BUREAU                                      0x1066
#define IDH_RATINGS_VIEW_PROVIDER_PAGE                          0x1067
#define IDH_RATINGS_SYSTEM_RATSYS_LIST                          0x1068
#define IDH_RATINGS_SYSTEM_RATSYS_ADD                           0x1069
#define IDH_RATINGS_SYSTEM_RATSYS_REMOVE                        0x106a
#define IDH_RATINGS_CHANGE_PASSWORD_OLD                         0x106b
#define IDH_RATINGS_CHANGE_PASSWORD_NEW                         0x106c
#define IDH_PICSRULES_OPEN                                      0x1070
#define IDH_PICSRULES_EDIT                                      0x1071
#define IDH_PICSRULES_APPROVEDNEVER                             0x1072
#define IDH_PICSRULES_APPROVEDALWAYS                            0x1073
#define IDH_PICSRULES_APPROVEDREMOVE                            0x1074
#define IDH_PICSRULES_APPROVEDLIST                              0x1075
#define IDH_PICSRULES_APPROVEDEDIT                              0x1076
#define IDH_FIND_RATING_SYSTEM_BUTTON                           0x1077
#define IDH_ADVANCED_TAB_DOWN_ARROW_BUTTON                      0x1078
#define IDH_ADVANCED_TAB_UP_ARROW_BUTTON                        0x1079
#define IDH_PICS_RULES_LIST                                     0x1080
#define IDH_RATINGS_VIEW_RESTRICTED                             0x1081
#define IDH_RATINGS_ENTER_PW_HINT                               0x1085
#define IDH_RATINGS_DISPLAY_PW_HINT                             0x1086
#define IDH_RATINGS_DESCRIBE_RESTRICTED                         0x108f

// Safety: Protecting you from the net
#define IDH_SAFETY_YOUWEREPROTECTED                             0x106d


// reserve range       0x3000 -- 0x4000 for shell
#define IDH_FOR_SHDOCVW_BEGIN                                   0x3000
#define IDH_FOR_SHDOCVW_END                                     0x4000

//  Contents:   Helpids for User project

#define IDH_USERS_LIST                                          81000
#define IDH_NEW_USER                                            81001
#define IDH_REMOVE_USER                                         81002
#define IDH_COPY_USER                                           81003
#define IDH_SET_PASSWORD                                        81004
#define IDH_OLD_PASSWORD                                        81005
#define IDH_NEW_PASSWORD                                        81006
#define IDH_CONFIRM_PASSWORD                                    81007
#define IDH_CHANGE_DESKTOP                                      81008
#define IDH_DESKTOP_NETHOOD                                     81009
#define IDH_START_MENU                                          81010
#define IDH_FAVORITES                                           81011
#define IDH_TEMP_FILES                                          81012
#define IDH_MY_DOCS                                             81013
#define IDH_EMPTY_FOLDERS                                       81014
#define IDH_EXISTING_FILES                                      81015
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\iconlbox.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1993                         **/
/***************************************************************************/

/****************************************************************************

    ICONLBOX.H

    Header file for IconListBox class (hard tabs at 4)

    May 93,         JimH (combobox support added by VladS)

    IconListBox is constructed by specifying the application's hInst and
    the ID of the listbox control.  All the properties of the listbox (font,
    single or muliple selection, etc.) are defined in the .RC file.  It must
    include the LBS_OWNERDRAWFIXED style.

    Icons are really bitmaps or parts of bitmaps.  They must all be the same
    size.  If they are not 16 by 16 this size must be specified in the
    constructor.  By default, bright green (RGB(0,255,0)) is the transparent
    color but this can be overridden for each individual icon.

    Construction of the IconListBox object should occur when the dialog is
    created.  You cannot wait until WM_INITDIALOG time because you need to
    handle the WM_MEASUREITEM message which comes first by passing to the
    constructed IconListBox.  Similarly, the IconListBox cannot be destructed
    during OK or Cancel handling because you will have to handle subsequent
    WM_DRAWITEM messages.

    Follow these steps to use IconListBox (assumes 16 by 16 icons)

    1.  Construct IconListBox(hInst, IDC_MYLISTBOX);

    2.  Handle WM_MEASUREITEM by calling

        mylistbox->SetHeight(hwndDlg, (MEASUREITESTRUCT FAR *)lParam);

        You MUST do this step even if you are using the default height of 16
        pixels.

    3.  During WM_INITDIALOG processing, register each possible icon by
        specifying your internal identifier for this icon, a bitmap id, and
        if necessary, the x and y offset in the bitmap of this icon.
        Don't load the bitmap yourself.  Just pass the .RC file id.

        mylistbox->RegisterIcon(typeFission, IDB_MushroomCloud);

        Note that you can register several icons from the same .RC file
        bitmap.  These may or may not have different x and y offsets but
        they must all have the same transparent color.  There is no
        extra overhead associated with reusing bitmaps or parts of bitmaps.

    4   Also during WM_INITDIALOG, add the listbox entries.

        mylistbox->AddString(typeColdFusion, "Pons & Fleishman");

    5.  Handle the WM_DRAWITEM message by calling

        if (wParam == IDC_MYLISTBOX)
            mylistbox->DrawItem((DRAWITEMSTRUCT FAR *)lParam);

    6.  When handling OK, do whatever listbox stuff you have to do.

        n = mylistbox->GetCurrentSelection();
        mylistbox->GetString(n, pbuffer);

    7.  Destruct IconListBox

    Inline wrappers for common listbox functions are at the end of this file.

****************************************************************************/

#ifndef _ICONLBOX_H_
#define _ICONLBOX_H_

struct IconList {
    int             nID;                // ID icon was registered with
    int             nResID;             // .RC file resource ID
    int             x, y;               // offset within specified icon
    HBITMAP         hbmSelected;
    HBITMAP         hbmUnselected;
};

const int MAXICONS      = 10;   // max number that can be registered
const int MAXTABS       = 10;   // max number of tabs in string
const int MAXSTRINGLEN  = MAX_PATH;  // AddString and InsertString limit
const int ICONSPACE     = 3;    // whitespace around Icons in listbox

class IconListBox {

    public:
        IconListBox(HINSTANCE hInst, int nID,
        int iconWidth = 16, int iconHeight = 16);
        ~IconListBox();

        int  AddString(int nIcon, const char far *string);
        void Clear();
        void DeleteString(int nIndex);
        virtual void DrawItem(LPDRAWITEMSTRUCT lpd);
        int  FindString(const char far *string, int nIndexStart = -1) const;
        int  FindStringExact(const char far *string, int nIndexStart = -1) const;
        int  GetCount();
        int  GetCurrentSelection(void) const;
        int  GetIconID(int nIndex) const;
        BOOL GetSel(int nIndex);
        int  GetSelCount() const;
        int  GetSelItems(int cItems, int FAR *lpItems) const;
        int  GetString(int nIndex, char far *string) const;
        int  InsertString(int nIcon, const char far *string, int nIndex);
        void RegisterIcon(int nIconID, int nResID, int x=0, int y=0,
                            COLORREF colTransparent = RGB(0, 255, 0));
        int  SelectString(int nIndex, const char far *string);
        int  SetCurrentSelection(int nIndex = -1) const;
        void SetHeight(HWND hwndDlg, LPMEASUREITEMSTRUCT lpm, int height=16);
        void SetRedraw(BOOL bRedraw = TRUE) const;
        void SetSel(int nIndex, BOOL bSelected = TRUE) const;
        void SetTabStops(int cTabs, const int *pTabs);

    protected:
        int         SetItemData(int nIndex, int nIconID) const;
		int			UpdateHorizontalExtent(int	nIconID,const char *string);

        int         _cIcons;                    // number of icons registered
        IconList    _aIcons[MAXICONS];          // registered icons
        int         _cTabs;                     // number of tabs registered
        int         _aTabs[MAXTABS];            // registered tabs
        int         _iconWidth, _iconHeight;    // size of icons
		int			_iCurrentMaxHorzExt;		// Currently maximum horizontal extent

        COLORREF    _colSel, _colSelText, _colUnsel, _colUnselText;

        HINSTANCE   _hInst;                     // application's hInst
        int         _nCtlID;                    // id of listbox control
        int         _nTextOffset;               // vertical DrawText offset

        BOOL        _fCombo;                    // Dropdown combo box ?

        HWND        _hwndDialog;
        HWND        _hwndListBox;

        HBRUSH      _hbrSelected;               // background colours
        HBRUSH      _hbrUnselected;
};


// AddString - returns index of new string, or LB_ERR or LB_ERRSPACE

inline int IconListBox::AddString(int nIcon, const char far *string)
{
    int nIndex =  (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                            _fCombo ? CB_ADDSTRING : LB_ADDSTRING,
                             0, (LPARAM) ((LPSTR) string));
    SetItemData(nIndex, nIcon);
	UpdateHorizontalExtent(nIcon,string);

    return nIndex;
}


// Clear - clears contents of listbox

inline void IconListBox::Clear()
{
    ::SendMessage(_hwndListBox,
                  _fCombo ? CB_RESETCONTENT : LB_RESETCONTENT, 0, 0);

    _iCurrentMaxHorzExt = 0;
}


// DeleteString - removes a string specified by the index

inline void IconListBox::DeleteString(int nIndex)
{
    ::SendMessage(_hwndListBox,
                  _fCombo ? CB_DELETESTRING : LB_DELETESTRING, nIndex, 0);

	// May be horizontal extent changed - recalculate again
	UpdateHorizontalExtent(0,NULL);

}

// FindString & FindStringExact
//
// These functions find a listbox entry that begins with the characters
// specifed in string (FindString) or exactly matches string (FindStringExact)
// They return LB_ERR if the string is not found.  Otherwise, you can call
// GetString on the returned index.
//
// nIndexStart defaults to -1 which means search from the beginning of the
// listbox or combobox.

inline int IconListBox::FindString(const char far *string, int nIndexStart) const
{
    return (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                _fCombo ? CB_FINDSTRING : LB_FINDSTRING, nIndexStart, (LPARAM)string);
}
inline int IconListBox::FindStringExact(const char far *string, int nIndexStart) const
{
    return (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                        _fCombo ? CB_FINDSTRINGEXACT : LB_FINDSTRINGEXACT,
                        nIndexStart, (LPARAM)string);
}

// GetCount - returns the current number of listbox entries

inline int IconListBox::GetCount()
{
    return (int) ::SendMessage(_hwndListBox,
                              _fCombo ? CB_GETCOUNT : LB_GETCOUNT, 0, 0);
}


// GetCurrentSelection - returns index or LB_ERR if no selection.
// This function is not useful for multi-select listboxen.

inline int IconListBox::GetCurrentSelection() const
{
    return (int) ::SendMessage(_hwndListBox,
                               _fCombo ? CB_GETCURSEL : LB_GETCURSEL, 0, 0);
}


// GetItemData - retrieve ICON id

inline int IconListBox::GetIconID(int nIndex) const
{
    return (int) ::SendMessage(_hwndListBox,
                     _fCombo ? CB_GETITEMDATA : LB_GETITEMDATA, nIndex, 0);
}


// GetSel - returns nonzero if nIndex is selected

inline BOOL IconListBox::GetSel(int nIndex)
{
    return (BOOL) ::SendMessage(_hwndListBox, LB_GETSEL, nIndex, 0);
}


// GetSelCount - returns number of selected entries in multi-select listbox

inline int IconListBox::GetSelCount() const
{
    return (int) ::SendMessage(_hwndListBox, LB_GETSELCOUNT, 0, 0);
}


// GetSelItems - places index of each selected item in array.  Returns
// LB_ERR if not multi-select listbox, otherwise number of items in array.

inline int IconListBox::GetSelItems(int cItems, int FAR *lpItems) const
{
    return (int)
        ::SendMessage(_hwndListBox, LB_GETSELITEMS, cItems, (LPARAM) lpItems);
}


// GetString - returns length of string returned or LB_ERR if nIndex invalid

inline int IconListBox::GetString(int nIndex, char far *string) const
{
    return (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                        _fCombo ? CB_GETLBTEXT : LB_GETTEXT, nIndex,
                        (LPARAM) ((LPSTR) string));
}


// InsertString - same returns as AddString

inline int IconListBox::InsertString(int nIcon, const char far *string, int nIndex)
{
    int nNewIndex =  (int) ::SendDlgItemMessage(_hwndDialog, _nCtlID,
                 _fCombo ? CB_INSERTSTRING : LB_INSERTSTRING,
                 (WPARAM) nIndex, (LPARAM) ((LPSTR) string));

    SetItemData(nNewIndex, nIcon);
	UpdateHorizontalExtent(nIcon,string);

    return(nNewIndex);
}


// SelectString
// nIndex specifies where to start searching (-1 means from top).
// string specifies the initial characters of the string to match.
// Function returns index or LB_ERR if string not found

inline int IconListBox::SelectString(int nIndex, const char far *string)
{
    return (int) ::SendMessage(_hwndListBox,
                              _fCombo ? CB_SELECTSTRING : LB_SELECTSTRING,
                               nIndex,(LRESULT)string);
}


// SetCurrentSelection -
// This function sets the current selection in a single-select style
// listbox.  It returns LB_ERR if an error occurs, or if nIndex is -1
// (the default) meaning no current selection.

inline int IconListBox::SetCurrentSelection(int nIndex) const
{
    return (int) ::SendMessage(_hwndListBox,
                        _fCombo ? CB_SETCURSEL : LB_SETCURSEL, nIndex, 0);
}


// SetItemData - used to store icon id, returns LB_ERR if error occurs
// Use GetIconID to retrieve this id later.

inline int IconListBox::SetItemData(int nIndex, int nData) const
{
    return (int) ::SendMessage(_hwndListBox,
                              _fCombo ? CB_SETITEMDATA : LB_SETITEMDATA,
                               nIndex, nData);
}


// SetRedraw - turn on (TRUE) or off (FALSE) visual updates

inline void IconListBox::SetRedraw(BOOL bRedraw) const
{
    ::SendMessage(_hwndListBox, WM_SETREDRAW, bRedraw, 0);
}


// SetSel - used in multiselect listboxen.  TRUE selects, FALSE deselects.
// bSelected defaults to TRUE.  nIndex == -1 means select all.

inline void IconListBox::SetSel(int nIndex, BOOL bSelected) const
{
    ::SendMessage(_hwndListBox, LB_SETSEL, bSelected, nIndex);
}


#endif  // _ICONLBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\netlib.h ===
// placeholder

#ifdef __cplusplus
extern "C" {
#endif

void * WINAPI MemAlloc(long cb);
void * WINAPI MemReAlloc(void * pb, long cb);
BOOL WINAPI MemFree(void * pb);

#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memcpyf(d,s,l)  memcpy((d),(s),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define strcatf(d,s)    lstrcat((d),(s))
#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define strcpyf(d,s)    lstrcpy((d),(s))
#define stricmpf(s1,s2) lstrcmpi(s1,s2)
#define strlenf(s)      lstrlen((s))

LPSTR WINAPI strncpyf(LPSTR, LPCSTR, UINT);
LPSTR WINAPI strrchrf(LPCSTR, UINT);
UINT  WINAPI strspnf(LPCSTR, LPCSTR);
LPSTR WINAPI strchrf(LPCSTR, UINT);
int   WINAPI strnicmpf(LPCSTR, LPCSTR, UINT);
UINT  WINAPI strcspnf(LPCSTR, LPCSTR);
LPSTR WINAPI strtokf(LPSTR, LPSTR);
LPSTR WINAPI strstrf(LPCSTR, LPCSTR);
LPSTR WINAPI stristrf(LPCSTR, LPCSTR);
int   WINAPI strncmpf(LPCSTR, LPCSTR, UINT);

LPSTR WINAPI struprf(LPSTR s);

extern BOOL fDBCSEnabled;

#ifdef __cplusplus
#define IS_LEAD_BYTE(c)     (fDBCSEnabled ? ::IsDBCSLeadByte(c) : 0)
#else
#define IS_LEAD_BYTE(c)     (fDBCSEnabled ? IsDBCSLeadByte(c) : 0)
#endif

void WINAPI InitStringLibrary(void);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\nowindep.h ===
#define	NOGDI
#define	NONLS
#define NORESOURCE
#define NOSCROLL
#define NOSHOWWINDOW
#define NOVIRTUALKEYCODES
#define NOWH
#define NODESKTOP
#define NOWINDOWSTATION
#define NOSECURITY
#define NOMSG
#define NOWINOFFSETS
#define NONCMESSAGES
#define NOKEYSTATES
#define NOCLIPBOARD
#define NODEFERWINDOWPOS
#define NOSYSMETRICS
#define NOMENUS
#define NODRAWTEXT
#define NOMB
#define NOCOLOR
#define NOSYSCOMMANDS
#define NOICONS
#define NOWINMESSAGES
#define NOMDI
#define NOHELP
#define NOSYSPARAMSINFO
#define NOSERVICE
#define _INC_MMSYSTEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\netmpr.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    netmpr.h

Abstract:

    DDK WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:


Revision History:

    20-Mar-1995     LenS
        Created.

--*/

#ifndef _INC_NETMPR_
#define _INC_NETMPR_


//
//  Authentication and Logon/Logoff.
//

#define LOGON_DONE              0x00000001
#define LOGON_PRIMARY           0x00000002
#define LOGON_MUST_VALIDATE     0x00000004

#define LOGOFF_PENDING  1
#define LOGOFF_COMMIT   2
#define LOGOFF_CANCEL   3


//
//  Password Cache.
//

#ifndef PCE_STRUCT_DEFINED
#define PCE_STRUCT_DEFINED

struct PASSWORD_CACHE_ENTRY {
    WORD cbEntry;               /* size of this entry in bytes, incl. pad */
    WORD cbResource;            /* size of resource name in bytes */
    WORD cbPassword;            /* size of password in bytes */
    BYTE iEntry;                /* index number of this entry, for MRU */
    BYTE nType;                 /* type of entry (see below) */
    char abResource[1];         /* resource name (may not be ASCIIZ at all) */
};

#define PCE_MEMORYONLY          0x01    /* for flags field when adding */

/*
    Typedef for the callback routine passed to the enumeration functions.
    It will be called once for each entry that matches the criteria
    requested.  It returns TRUE if it wants the enumeration to
    continue, FALSE to stop.
*/
typedef BOOL (FAR PASCAL *CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData );

#endif  /* PCE_STRUCT_DEFINED */

DWORD APIENTRY
WNetCachePassword(
    LPSTR pbResource,
    WORD  cbResource,
    LPSTR pbPassword,
    WORD  cbPassword,
    BYTE  nType,
    UINT  fnFlags
    );

DWORD APIENTRY
WNetGetCachedPassword(
    LPSTR  pbResource,
    WORD   cbResource,
    LPSTR  pbPassword,
    LPWORD pcbPassword,
    BYTE   nType
    );

DWORD APIENTRY
WNetRemoveCachedPassword(
    LPSTR pbResource,
    WORD  cbResource,
    BYTE  nType
    );

DWORD APIENTRY
WNetEnumCachedPasswords(
    LPSTR pbPrefix,
    WORD  cbPrefix,
    BYTE  nType,
    CACHECALLBACK pfnCallback,
    DWORD dwRefData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npdefs.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NPCOMMON.H -- Internal standard header for network provider common library.
 *
 * ATTENTION: This file is used by 16bit components and should be
 *			  maintained as such.
 *
 * History:
 *  03/22/93    gregj   Created
 *  04/02/93    lens    Added _INC_NPDEFS define and _INC_WINDOWS test.
 *
 */
#ifndef _INC_NPDEFS
#define _INC_NPDEFS

#ifndef RC_INVOKED
#pragma warning(disable:4147)       // warning about ignoring __loadds on function
                                    // ptr decls, of which there are 5 in windows.h
#pragma warning(disable:4118)       // warning about not accepting the intrinsic function pragma
                                    // during a fast compile

// Macro to quiet compiler for an unused formal parameter.
#define UNUSED(x) ((void)(x))
#endif

#ifndef _INC_WINDOWS
#include <windows.h>
#endif

#ifdef IS_32
#ifndef _INC_NETSPI
#include <netspi.h>
#endif

#ifndef _STRING_HXX_
#include <npstring.h>
#endif
#endif  /* IS_32 */

// Fixup for when RESOURCETYPE_ANY was not compatible with NT.
// Codework: remove from system.
#define RESOURCETYPE_ANY1 RESOURCETYPE_RESERVED

#define CHAR char
#define INT int

typedef unsigned short WCHAR;
typedef unsigned short USHORT;
typedef WORD HANDLE16;

#ifndef APIENTRY
#define APIENTRY    FAR PASCAL
#endif

#define FAR_NETLIB              /* our netlib is in netapi.dll, and always far */

#ifndef IS_32
#ifndef LOADDS
#define LOADDS __loadds
#endif
#else
#define LOADDS
#endif

#ifndef HNRES
typedef HANDLE HNRES;
#endif


// That is common return type used in both common and mnr projects
#ifndef MNRSTATUS
#ifdef IS_32
#define MNRSTATUS UINT
#else
#define MNRSTATUS WORD
#endif
#endif

#define MNRENTRY DWORD APIENTRY

// Find size of structure upto and including a field that may be the last field in the structure.
#define SIZE_TO_FIELD(s,f) (sizeof(((s *)NULL)->f) + (LPBYTE)&(((s *)NULL)->f) - (LPBYTE)NULL)

// Null strings are quite often taken to be either a NULL pointer or a zero
#define IS_EMPTY_STRING(pch) ( !pch || !*(pch) )

/*******************************************************************

Macro Description:

    This macro is used to test that a LoadLibrary call succeeded.

Arguments:

    hModule          - the handle returned from the LoadLibrary call.

Notes:

    Win31 documentation says that errors are less than HINSTANCE_ERROR
    and that success is greater than 32. Since HINSTANCE_ERROR is 32,
    this leaves the value of 32 as being undefined!

*******************************************************************/

#ifdef IS_32
#define MNRVALIDDLLHANDLE(hdll) (hdll != NULL)
#else
#define MNRVALIDDLLHANDLE(hdll) (hdll > HINSTANCE_ERROR)
#endif

/*******************************************************************

Macro Description:

    This macro is used to determine if a buffer passed in has valid 
    addresses and writeable memory.

Arguments:

    lpBuffer	- the address of the buffer.

    lpcbBuffer	- the address of a DWORD containing the size of the
				  buffer that is filled in on return with the 
				  required size of the buffer if the buffer
				  is not large enough.

Evalutes to:

	An expression that returns TRUE or FALSE.

Notes:

	Only valid for Win32 applications to call.
    The macro does weak validation as it is used generically in many APIs.
	In particular, this means that the macro succeeds a NULL lpcbBuffer, 
    and zero *lpcbBuffer. In neither of these cases does it validate
	that lpBuffer is a valid address (and relies upon the behavior of 
    IsBadWritePtr when *lpcbBuffer is zero).

*******************************************************************/

#define IS_BAD_WRITE_BUFFER(lpBuffer,lpcbBuffer) \
((lpcbBuffer != NULL) && \
 (IsBadWritePtr(lpcbBuffer, sizeof(DWORD)) || \
  IsBadWritePtr(lpBuffer, *lpcbBuffer))) 

#ifdef IS_32
extern "C" { /* Know we're using C++ internally */

NLS_STR FAR * NPSERVICE NPSGetStatusText(DWORD dwError, 
										 LPBOOL pbStatic);

DWORD NPSERVICE NPSCopyNLS(NLS_STR FAR *pnlsSourceString, 
						   LPVOID lpDestBuffer, 
						   LPDWORD lpBufferSize);

}
#endif  /* IS_32 */

#endif  /* !_INC_NPDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npmsg.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* NPMSG.H -- Definition of MsgBox subroutine.
 *
 * History:
 *	05/06/93	gregj	Created
 *	10/07/93	gregj	Added DisplayGenericError.
 */

#ifndef _INC_NPMSG
#define _INC_NPMSG

class NLS_STR;			/* forward declaration */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#define	IDS_MSGTITLE	1024

extern int MsgBox( HWND hwndDlg, UINT idMsg, UINT wFlags, const NLS_STR **apnls = NULL );
extern UINT DisplayGenericError(HWND hwnd, UINT msg, UINT err, LPCSTR psz1, LPCSTR psz2, WORD wFlags, UINT nMsgBase);


#ifndef RC_INVOKED
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */


#endif	/* _INC_NPMSG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npalloc.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/ 

/* npalloc.h -- Definitions for new/delete functions.
 *
 * History:
 *	10/06/93	gregj	Created
 *	11/29/93	gregj	Added debug instrumentation
 */

#ifndef _INC_NPALLOC
#define _INC_NPALLOC

inline BOOL InitHeap(void)
{
	return TRUE;
}

#ifdef DEBUG

#ifndef _INC_NETLIB
#include <netlib.h>
#endif

class MEMWATCH
{
private:
	LPCSTR _lpszLabel;
	MemAllocInfo _info;

protected:
    BOOL   fStats;

public:
	MEMWATCH(LPCSTR lpszLabel);
	~MEMWATCH();
};

class MemLeak : MEMWATCH
{
public:
	MemLeak(LPCSTR lpszLabel);
	~MemLeak() {}
};

class MemOff 
{
private:
    LPVOID  pvContext;
public:
    MemOff();
    ~MemOff();
};
#endif

#ifdef DEBUG
#define MEMLEAK(d,t) MemLeak d ( t )
#define MEMOFF(d) MemOff d
#else
#define MEMLEAK(d,t)
#define MEMOFF(d)
#endif    

#endif	/* _INC_NPALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npassert.h ===
/*****************************************************************/
/**             Microsoft Windows for Workgroups                **/
/**         Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/

/*
    npassert.h
    NP environment independent assertion/logging routines

    Usage:

        ASSERT(exp)     Evaluates its argument.  If "exp" evals to
                        FALSE, then the app will terminate, naming
                        the file name and line number of the assertion
                        in the source.

        UIASSERT(exp)   Synonym for ASSERT.

        ASSERTSZ(exp,sz) As ASSERT, except will also print the message
                        "sz" with the assertion message should it fail.

        REQUIRE(exp)    As ASSERT, except that its expression is still
                        evaluated in retail versions.  (Other versions
                        of ASSERT disappear completely in retail builds.)

        ANSI_ASSERTABLE(sz) Declares "sz" to be a string buffer which
                        can be used with the ASSERT_ANSI and ASSERT_OEM
                        macros (effectively declares a debug-only BOOL
                        associated with the string).

        ASSERT_ANSI(sz) Asserts that sz is in the ANSI character set.

        ASSERT_OEM(sz)  Asserts that sz is in the OEM character set.

        IS_ANSI(sz)     Declares that sz is in the ANSI character set
                        (e.g., if it's just come back from a GetWindowText).

        IS_OEM(sz)      Declares that sz is in the OEM character set.

        TO_ANSI(sz)     Does OemToAnsi in place.

        TO_OEM(sz)      Does AnsiToOem in place.

        COPY_TO_ANSI(src,dest)  Does OemToAnsi, not in place.

        COPY_TO_OEM(src,dest)   Does AnsiToOem, not in place.

        NOTE: the latter two, just like the APIs themselves, have the
        source first and destination second, opposite from strcpy().

    The ASSERT macros expect a symbol _FILENAME_DEFINED_ONCE, and will
    use the value of that symbol as the filename if found; otherwise,
    they will emit a new copy of the filename, using the ANSI C __FILE__
    macro.  A client sourcefile may therefore define __FILENAME_DEFINED_ONCE
    in order to minimize the DGROUP footprint of a number of ASSERTs.

    FILE HISTORY:
        Johnl   11/15/90    Converted from CAssert to general purpose
        Johnl   12/06/90    Changed _FAR_ to _far in _assert prototype
        beng    04/30/91    Made C-includable
        beng    08/05/91    Made assertions occupy less dgroup; withdrew
                            explicit heapchecking (which was crt
                            dependent anyway)
        beng    09/17/91    Removed additional consistency checks;
                            rewrote to minimize dgroup footprint,
                            check expression in-line
        beng    09/19/91    Fixed my own over-cleverness
        beng    09/25/91    Fixed bug in retail REQUIRE
        gregj   03/23/93    Ported to Chicago environment
        gregj   05/11/93    Added ANSI/OEM asserting routines
        gregj   05/25/93    Added COPY_TO_ANSI and COPY_TO_OEM
*/


#ifndef _NPASSERT_H_
#define _NPASSERT_H_

#if defined(__cplusplus)
extern "C"
{
#else
extern
#endif

VOID UIAssertHelper( const CHAR* pszFileName, UINT nLine );
VOID UIAssertSzHelper( const CHAR* pszMessage, const CHAR* pszFileName, UINT nLine );
extern const CHAR szShouldBeAnsi[];
extern const CHAR szShouldBeOEM[];

#if defined(__cplusplus)
}
#endif

#if defined(DEBUG)

# if defined(_FILENAME_DEFINED_ONCE)

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(_FILENAME_DEFINED_ONCE, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), _FILENAME_DEFINED_ONCE, __LINE__); }

# else

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), __FILE__, __LINE__); }

# endif

# define UIASSERT(exp)  ASSERT(exp)
# define REQUIRE(exp)   ASSERT(exp)

#define EXTERN_ANSI_ASSERTABLE(sz)  extern BOOL fAnsiIs##sz;
#define ANSI_ASSERTABLE(sz) BOOL fAnsiIs##sz=FALSE;
#define ASSERT_ANSI(sz)     ASSERTSZ(fAnsiIs##sz,szShouldBeAnsi)
#define ASSERT_OEM(sz)      ASSERTSZ(!fAnsiIs##sz,szShouldBeOEM)
#define IS_ANSI(sz)         fAnsiIs##sz = TRUE;
#define IS_OEM(sz)          fAnsiIs##sz = FALSE;
#define TO_ANSI(sz)         { ASSERT_OEM(sz); ::OemToAnsi(sz,sz); IS_ANSI(sz); }
#define TO_OEM(sz)          { ASSERT_ANSI(sz); ::AnsiToOem(sz,sz); IS_OEM(sz); }
#define COPY_TO_ANSI(s,d)   { ASSERT_OEM(s); ::OemToAnsi(s,d); IS_ANSI(d); }
#define COPY_TO_OEM(s,d)    { ASSERT_ANSI(s); ::AnsiToOem(s,d); IS_OEM(d); }

#else // !DEBUG

# define ASSERT(exp)        ;
# define UIASSERT(exp)      ;
# define ASSERTSZ(exp, sz)  ;
# define REQUIRE(exp)       { (exp); }

#define EXTERN_ANSI_ASSERTABLE(sz)  ;
#define ANSI_ASSERTABLE(sz) ;
#define ASSERT_ANSI(sz)     ;
#define ASSERT_OEM(sz)      ;
#define IS_ANSI(sz)         ;
#define IS_OEM(sz)          ;
#define TO_ANSI(sz)         ::OemToAnsi(sz,sz)
#define TO_OEM(sz)          ::AnsiToOem(sz,sz)
#define COPY_TO_ANSI(s,d)   ::OemToAnsi(s,d)
#define COPY_TO_OEM(s,d)    ::AnsiToOem(s,d)

#endif // DEBUG


// Debug mask APIs

// NOTE: You can #define your own DM_* values using bits in the HI BYTE

#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions

#define	DM_LOG_FILE 0x0100
#define	DM_PREFIX 	0x0200


#if !defined(NetDebugMsg)

//
// DebugMsg(mask, msg, args...) - Generate wsprintf-formatted msg using
//                          specified debug mask.  System debug mask
//                          governs whether message is output.
//

#if defined(__cplusplus)
extern "C"
{
#else
extern
#endif

#define REGVAL_STR_DEBUGMASK	"DebugMask"

void __cdecl NetDebugMsg(UINT mask, LPCSTR psz, ...);

UINT WINAPI  NetSetDebugParameters(PSTR pszName,PSTR pszLogFile);
UINT WINAPI  NetSetDebugMask(UINT mask);
UINT WINAPI  NetGetDebugMask(void);

#if defined(__cplusplus)
}
#endif

#endif

#ifdef	DEBUG

#define Break() 		{_asm _emit 0xcc}
//#define	Trap()			{_asm {_emit 0xcc}}
//#define	TrapC(c)		{if(c) {Trap()}}

#define DPRINTF  NetDebugMsg

#else

#define Break()
#define	Trap()
#define	TrapC(c)

// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
#define DPRINTF 	1?(void)0 : (void)

#endif

#endif // _NPASSERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\netspi.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

/* NETSPI.H -- Network service provider interface definitions.
 */

#ifndef _INC_NETSPI
#define _INC_NETSPI

#ifndef _WINNETWK_
#include <winnetwk.h>
#endif

#ifndef _INC_NETMPR_
#include <netmpr.h>
#endif

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Capability masks and values.
//

#define WNNC_SPEC_VERSION   0x01
#define     WNNC_SPEC_VERSION51 0x00050001

#define WNNC_NET_TYPE       0x02
// Net types defined in Winnetwk.h

#define WNNC_DRIVER_VERSION 0x03

#define WNNC_USER           0x04
#define     WNNC_USR_GETUSER    0x01

#define WNNC_CONNECTION     0x06
#define     WNNC_CON_ADDCONNECTION      0x01
#define     WNNC_CON_CANCELCONNECTION   0x02
#define     WNNC_CON_GETCONNECTIONS     0x04
#define     WNNC_CON_GETPERFORMANCE     0x08
#define     WNNC_CON_GETUNIVERSALNAME   0x10
#define     WNNC_CON_FORMATCONNECTION   0x20

#define WNNC_DIALOG         0x08
#define     WNNC_DLG_FORMATNETWORKNAME  0x080
#define     WNNC_DLG_GETRESOURCEPARENT  0x100
#define     WNNC_DLG_GETRESOURCEINFORMATION  0x800

#define WNNC_ERROR          0x0A
#define  WNNC_ERR_GETERROR              0x01
#define  WNNC_ERR_GETERRORTEXT          0x02

#define WNNC_ENUMERATION    0x0B
#define     WNNC_ENUM_GLOBAL    0x01
#define     WNNC_ENUM_LOCAL     0x02
#define     WNNC_ENUM_CONTEXT   0x04

#define WNNC_START          0x0C
#define     WNNC_START_WONT     0x00
#define     WNNC_START_UNKNOWN  0xFFFFFFFF
#define     WNNC_START_DONE     0x01
#define     WNNC_START_INACTIVE 0xFFFFFFFE

#define WNNC_RESOURCE       0x0D
#define     WNNC_RES_VALIDLOCALDEVICE   0x80

#define WNNC_AUTHENTICATION 0x0E
#define     WNNC_AUTH_LOGON             0x02
#define     WNNC_AUTH_LOGOFF            0x04
#define		WNNC_AUTH_GETHOMEDIRECTORY	0x10
#define		WNNC_AUTH_GETPOLICYPATH		0x20

#define WNNC_MAXCAPNO WNNC_AUTHENTICATION

//
// Profile strings.
//
#define NPProvider      "NPProvider"
#define NPName          "NPName"
#define NPDescription   "NPDescription"
#define NPID            "NPID"

//
// Various defines.
//
//Spec version
#define WNNC_DRIVER_MAJOR1  1  
#define WNNC_DRIVER_MINOR1  1
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)

//
// NP SPI Definitions.
//

#define SPIENTRY DWORD WINAPI

typedef SPIENTRY F_NPGetCaps(
    DWORD nIndex
    );

F_NPGetCaps NPGetCaps;
typedef F_NPGetCaps FAR *PF_NPGetCaps;

typedef SPIENTRY F_NPGetUniversalName(
	LPTSTR  lpLocalPath,
	DWORD   dwInfoLevel,
	LPVOID  lpBuffer,
	LPDWORD lpBufferSize
    );

F_NPGetUniversalName NPGetUniversalName;
typedef F_NPGetUniversalName FAR *PF_NPGetUniversalName;

typedef SPIENTRY F_NPGetUser(
    LPTSTR  lpName,
    LPTSTR  lpAuthenticationID,
    LPDWORD lpBufferSize
    );

F_NPGetUser NPGetUser;
typedef F_NPGetUser FAR *PF_NPGetUser;

typedef SPIENTRY F_NPValidLocalDevice(
    DWORD dwType,
    DWORD dwNumber
    );

F_NPValidLocalDevice NPValidLocalDevice;
typedef F_NPValidLocalDevice FAR *PF_NPValidLocalDevice;

typedef SPIENTRY F_NPAddConnection(
    HWND hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword,
    LPTSTR lpUserID,
    DWORD dwFlags,
	LPTSTR lpAccessName,
	LPDWORD lpBufferSize,
	LPDWORD lpResult
    );

F_NPAddConnection NPAddConnection;
typedef F_NPAddConnection FAR *PF_NPAddConnection;

typedef SPIENTRY F_NPCancelConnection(
    LPTSTR lpName,
    BOOL fForce,
 	DWORD dwFlags
    );

F_NPCancelConnection NPCancelConnection;
typedef F_NPCancelConnection FAR *PF_NPCancelConnection;

typedef SPIENTRY F_NPGetConnection(
    LPTSTR lpLocalName,
    LPTSTR lpRemoteName,
    LPDWORD lpBufferSize
    );

F_NPGetConnection NPGetConnection;
typedef F_NPGetConnection FAR *PF_NPGetConnection;

typedef SPIENTRY F_NPGetConnectionPerformance(
    LPTSTR lpRemoteName, 
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );

F_NPGetConnectionPerformance NPGetConnectionPerformance;
typedef F_NPGetConnectionPerformance FAR *PF_NPGetConnectionPerformance;

typedef SPIENTRY F_NPFormatNetworkName(
    LPTSTR lpRemoteName,
    LPTSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    );

F_NPFormatNetworkName NPFormatNetworkName;
typedef F_NPFormatNetworkName FAR *PF_NPFormatNetworkName;

typedef DWORD (FAR PASCAL *NPDISPLAYCALLBACK)(
    LPVOID  lpUserData,
    DWORD   dwDisplayType,
    LPTSTR  lpszHeaders
    );

typedef SPIENTRY F_NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCE lpNetResource,
    LPHANDLE lphEnum
    );

F_NPOpenEnum NPOpenEnum;
typedef F_NPOpenEnum FAR *PF_NPOpenEnum;

typedef SPIENTRY F_NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbFree
    );

F_NPEnumResource NPEnumResource;
typedef F_NPEnumResource FAR *PF_NPEnumResource;

typedef SPIENTRY F_NPCloseEnum(
    HANDLE hEnum
    );

F_NPCloseEnum NPCloseEnum;
typedef F_NPCloseEnum FAR *PF_NPCloseEnum;

typedef SPIENTRY F_NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    );

F_NPGetResourceParent NPGetResourceParent;
typedef F_NPGetResourceParent FAR *PF_NPGetResourceParent;

typedef SPIENTRY F_NPGetResourceInformation(
	LPNETRESOURCE lpNetResource,
	LPVOID lpBuffer,
	LPDWORD cbBuffer,
	LPSTR *lplpSystem
    );

F_NPGetResourceInformation NPGetResourceInformation;
typedef F_NPGetResourceInformation FAR *PF_NPGetResourceInformation;

typedef struct _LOGONINFO {
    LPTSTR lpUsername;
    LPTSTR lpPassword;
	DWORD cbUsername;
	DWORD cbPassword;
} LOGONINFO, FAR *LPLOGONINFO;

typedef SPIENTRY F_NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    );

F_NPLogon NPLogon;
typedef F_NPLogon FAR *PF_NPLogon;

typedef SPIENTRY F_NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    );

F_NPLogoff NPLogoff;
typedef F_NPLogoff FAR *PF_NPLogoff;

typedef SPIENTRY F_NPChangePassword(
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
	DWORD		dwAction
	);

F_NPChangePassword NPChangePassword;
typedef F_NPChangePassword FAR *PF_NPChangePassword;

typedef SPIENTRY F_NPChangePasswordHwnd(
	HWND hwndOwner
	);

F_NPChangePasswordHwnd NPChangePasswordHwnd;
typedef F_NPChangePasswordHwnd FAR *PF_NPChangePasswordHwnd;


typedef SPIENTRY F_NPGetPasswordStatus(
	DWORD		nIndex
	);

F_NPGetPasswordStatus NPGetPasswordStatus;
typedef F_NPGetPasswordStatus FAR *PF_NPGetPasswordStatus;


typedef SPIENTRY F_NPGetHomeDirectory(
    LPTSTR lpDirectory,
    LPDWORD lpBufferSize
    );

F_NPGetHomeDirectory NPGetHomeDirectory;
typedef F_NPGetHomeDirectory FAR *PF_NPGetHomeDirectory;

typedef SPIENTRY F_NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
	DWORD dwFlags
    );

// flags for NPGetPolicyPath
#define GPP_LOADBALANCE	0x0001

F_NPGetPolicyPath NPGetPolicyPath;
typedef F_NPGetPolicyPath FAR *PF_NPGetPolicyPath;

//
// MPR Services.
//

#define NPSGetProviderHandle NPSGetProviderHandleA
#define NPSGetProviderName NPSGetProviderNameA
#define NPSGetSectionName NPSGetSectionNameA
#define NPSSetExtendedError NPSSetExtendedErrorA
#define NPSSetCustomText NPSSetCustomTextA
#define NPSCopyString NPSCopyStringA
#define NPSDeviceGetNumber NPSDeviceGetNumberA
#define NPSDeviceGetString NPSDeviceGetStringA
#define NPSNotifyRegister NPSNotifyRegisterA
#define NPSNotifyGetContext NPSNotifyGetContextA
#define NPSAuthenticationDialog NPSAuthenticationDialogA

#define NPSERVICE	WINAPI
#define HPROVIDER   LPVOID
typedef HPROVIDER FAR * PHPROVIDER;

typedef struct {
    DWORD  cbStructure;       /* size of this structure in bytes */
    HWND   hwndOwner;         /* owner window for the authentication dialog */
    LPCSTR lpResource;        /* remote name of resource being accessed */
    LPSTR  lpUsername;        /* default username to show, NULL to hide field */
    DWORD  cbUsername;        /* size of lpUsername buffer, set to length copied on exit */
    LPSTR  lpPassword;        /* default password to show */
    DWORD  cbPassword;        /* size of lpPassword buffer, set to length copied on exit */
    LPSTR  lpOrgUnit;         /* default org unit to show, NULL to hide field */
    DWORD  cbOrgUnit;         /* size of lpOrgUnit buffer, set to length copied on exit */
    LPCSTR lpOUTitle;         /* title of org unit field, NULL for default title */
    LPCSTR lpExplainText;     /* explanatory text at top, NULL for default text */
    LPCSTR lpDefaultUserName; /* explanatory text at top, NULL for default text */
    DWORD  dwFlags;           /* flags (see below) */
} AUTHDLGSTRUCTA, FAR *LPAUTHDLGSTRUCTA;
#define AUTHDLGSTRUCT AUTHDLGSTRUCTA
#define LPAUTHDLGSTRUCT LPAUTHDLGSTRUCTA

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

DWORD
NPSERVICE
NPSAuthenticationDialog(
    LPAUTHDLGSTRUCT lpAuthDlgStruct
    );

DWORD
NPSERVICE
NPSGetProviderHandle( 
	PHPROVIDER phProvider
	);

DWORD
NPSERVICE
NPSGetProviderName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszProviderName
	);

DWORD
NPSERVICE
NPSGetSectionName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszSectionName
	);

DWORD
NPSERVICE NPSSetExtendedError (
	DWORD NetSpecificError,
	LPSTR lpExtendedErrorText 
    );

VOID
NPSERVICE NPSSetCustomText (
	LPSTR lpCustomErrorText 
    );

DWORD
NPSERVICE
NPSCopyString (
    LPCTSTR lpString,
    LPVOID  lpBuffer,
    LPDWORD lpdwBufferSize
    );

DWORD
NPSERVICE
NPSDeviceGetNumber (
    LPTSTR  lpLocalName,
    LPDWORD lpdwNumber,
    LPDWORD lpdwType
    );

DWORD
NPSERVICE
NPSDeviceGetString (
    DWORD   dwNumber,
    DWORD   dwType,
    LPTSTR  lpLocalName,
    LPDWORD lpdwBufferSize
    );

// Notification Service.

enum NOTIFYTYPE { NotifyAddConnection, 
                  NotifyCancelConnection, 
                  NotifyGetConnectionPerformance };

#define NOTIFY_PRE              0x00
#define NOTIFY_POST             0x01

typedef struct _NOTIFYINFO {
    DWORD cbStructure;          /* size of NOTIFYINFO */
    DWORD  dwNotifyStatus;      /* Pre/post notification status */
    DWORD  dwOperationStatus;   /* Status of operation */
    LPVOID lpNPContext;         /* NP context */
} NOTIFYINFO, FAR *LPNOTIFYINFO;

typedef struct _NOTIFYADD {
    DWORD cbStructure;          /* size of NOTIFYADD */
    HWND hwndOwner;             /* hWnd for UI */
    NETRESOURCE NetResource;    /* Resource to add */
    DWORD dwAddFlags;           /* Add flags */
    LPTSTR lpAccessName;        /* System name for connection */
    LPDWORD lpBufferSize;       /* Size of AccessName buffer */
    DWORD dwResult;             /* Info about connection */
    DWORD dwAddContext;         /* Context of add connection */
} NOTIFYADD, FAR *LPNOTIFYADD;

#define CONNECT_CTXT_RESTORE        0x00000001
#define CONNECT_CTXT_GLOBAL         0x00000002
#define CONNECT_CTXT_PROVIDER       0x00000004
#define CONNECT_CTXT_SINGLE         0x00000008

typedef struct _NOTIFYCANCEL {
    DWORD cbStructure;          /* size of NOTIFYCANCEL */
    LPTSTR lpName;              /* Local device name or remote name of resource */
    LPTSTR lpProvider;          /* Provider name of resource cancelled */
    DWORD dwFlags;              /* Cancel flags */
    BOOL fForce;                /* Cancel force */
} NOTIFYCANCEL, FAR *LPNOTIFYCANCEL;

typedef struct _NOTIFYPERFORMANCE {
	DWORD cbStructure;          /* size of NOTIFYPERFORMANCE */
	LPTSTR lpRemoteName;        /* network resource name */
	LPTSTR lpProviderName;      /* provider to try/provider that responded */
	LPNETCONNECTINFOSTRUCT lpNetConnectInfo; /* performance information requested/returned */
} NOTIFYPERFORMANCE, FAR *LPNOTIFYPERFORMANCE;

typedef DWORD (FAR PASCAL *NOTIFYCALLBACK)( LPNOTIFYINFO lpNotifyInfo, LPVOID lpOperationInfo );

DWORD
NPSERVICE
NPSNotifyRegister(
    enum NOTIFYTYPE NotifyType,
    NOTIFYCALLBACK P_FNotifyCallBack
    );

LPVOID
NPSERVICE
NPSNotifyGetContext (
    NOTIFYCALLBACK P_FNotifyCallBack
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_NETSPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npcrit.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/* NPCRIT.H -- Definition of CRITSEC classes.
 *
 * History:
 *	gregj	11/01/93	Created
 *  lens    02/25/94    Modified to use CRITICAL_SECTIONs Reinitialize().
 *                      Took out spin-loop interlock.
 */

#ifndef _INC_CRITSEC
#define _INC_CRITSEC

#ifndef RC_INVOKED
#pragma pack(1)
#endif

extern "C"
{

/* extern DECLSPEC_IMPORT
VOID
WINAPI
ReinitializeCriticalSection(LPCRITICAL_SECTION lpcs); - in windefs.h */

extern DECLSPEC_IMPORT
VOID
WINAPI
UninitializeCriticalSection(LPCRITICAL_SECTION lpcs);

// codework: remove following and make MEMWATCH use critical sections.
#ifdef DEBUG
void WaitForInterlock(volatile BYTE *pByte);
void ReleaseInterlock(volatile BYTE *pByte);
#endif	/* DEBUG */

}

/*************************************************************************

    NAME:		CRITSEC

    SYNOPSIS:	Class wrapper for global critical section

    INTERFACE:	Init(pszName)
					Initializes the critical section.

				Term()
					Cleans up the critical section.

	PRIVATE:	Enter()
					Enter the critical section, waiting for others
					to leave if necessary.

				Leave()
					Leave the critical section, unblocking other waiters.

    PARENT:		None

    USES:		None

    CAVEATS:	This class is not initialized with its constructor because
				it should be instantiated at global scope, which introduces
				constructor-linker problems.  Instead, its fields should be
				initialized to all zeroes, and Init() should be called at
				process attach time.  Term() should be called at process
				detach.

    NOTES:		The class's initialization takes care of synchronizing
				itself to protect against multiple simultaneous inits.

    HISTORY:
		11/01/93	gregj	Created
        02/25/94    lens    Modified to use CRITICAL_SECTION directly.

**************************************************************************/

class CRITSEC
{
friend class TAKE_CRITSEC;

private:
	CRITICAL_SECTION _critsec;

public:
	void Enter() { ::EnterCriticalSection(&_critsec); }
	void Leave() { ::LeaveCriticalSection(&_critsec); }
#ifndef WINNT
	void Init() { ::ReinitializeCriticalSection(&_critsec); }
	void Term() { /* codework: add ::UninitializeCriticalSection(&_critsec); */}
#endif /* WINNT */
};


/*************************************************************************

    NAME:		TAKE_CRITSEC

    SYNOPSIS:	Class wrapper to take a critical section.

    INTERFACE:	TAKE_CRITSEC(critsec)
					Construct with the global CRITICAL_SECTION object to take.

				~TAKE_CRITSEC()
					Destructor automatically releases the critical section.

				Release()
					Releases the critical section manually.

				Take()
					Takes the critical section manually.

    PARENT:		None

    USES:		None

    CAVEATS:	None

    NOTES:		Instantiate one of these classes in a block of code
				when you want that block of code to be protected
				against re-entrancy.
                The Take() and Release() functions should rarely be necessary,
                and must be used in matched pairs with Release() called first.

    HISTORY:
		11/01/93	gregj	Created

**************************************************************************/

class TAKE_CRITSEC
{
private:
	CRITSEC & const _critsec;

public:
	void Take(void) { _critsec.Enter(); }
	void Release(void) { _critsec.Leave(); }
	TAKE_CRITSEC(CRITSEC& critsec) : _critsec(critsec) { Take(); }
	~TAKE_CRITSEC() { Release(); }
};


/*************************************************************************

    NAME:		TAKE_MUTEX

    SYNOPSIS:	Class wrapper to take a mutex.

    INTERFACE:	TAKE_MUTEX(hMutex)
					Construct with the mutex handle to take.

				~TAKE_MUTEX()
					Destructor automatically releases the mutex.

				Release()
					Releases the mutex manually.

				Take()
					Takes the mutex manually.

    PARENT:		None

    USES:		None

    CAVEATS:	None

    NOTES:		Instantiate one of these classes in a block of code
				when you want that block of code to be protected
				against re-entrancy.
                The Take() and Release() functions should rarely be necessary,
                and must be used in matched pairs with Release() called first.

    HISTORY:
		09/27/94	lens	Created

**************************************************************************/

class TAKE_MUTEX
{
private:
	HANDLE const _hMutex;

public:
	void Take(void) { WaitForSingleObject(_hMutex, INFINITE); }
	void Release(void) { ReleaseMutex(_hMutex); }
	TAKE_MUTEX(HANDLE hMutex) : _hMutex(hMutex) { Take(); }
	~TAKE_MUTEX() { Release(); }
};

#ifndef RC_INVOKED
#pragma pack()
#endif

#endif	/* _INC_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npstubx.h ===
#define szNPSTUBClassName "WndClass_NPSTUBMonitor"
#define WM_NPSTUB_LOADDLL (WM_USER)
#define WM_NPSTUB_UNLOADDLL (WM_USER + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\npstring.h ===
/*****************************************************************/ 
/**                  Microsoft Windows for Workgroups                **/
/**              Copyright (C) Microsoft Corp., 1991-1992            **/
/*****************************************************************/ 

/*
    npstring.h
    String classes: definition

    This file contains the basic string classes for the Thor UI.
    Its requirements are:

        - provide a modestly object-oriented interface to string
          manipulation, the better to work with the rest of our code;

        - encapsulate NLS and DBCS support as much as possible;

        - ensure that apps get correct form of library support,
          particularly with possible interference from intrinsics;

    The current solution consists of two classes: NLS_STR, and ISTR.

    class NLS_STR:      use wherever NLS/DBCS support is needed.
                      Most strings (in the UI, anyway) should be
                      of this class.

    class ISTR:      Indexes an NLS_STR in a DBCS safe manner.  All
                  positioning within an NLS_STR is done with ISTRs

    The class hierarchy looks like:

        BASE
            NLS_STR
                RESOURCE_STR
        ISTR

    This file also contains the STACK_NLS_STR macro and the
    strcpy( CHAR *, const NLS_STR& ) prototype.

    FILE HISTORY:
        beng        10/21/90        Created from email memo of last week
        johnl        11/13/90        Removed references to EB_STRING
        johnl        11/28/90        Release fully functional version
        johnl        12/07/90        Numerous revisions after code review
                                    (Removed SZ_STR, ISTR must associate
                                    w/a string upon decl etc.)
        beng        02/05/91        Replaced PCH with CHAR * for
                                    const-placement
        beng        04/26/91        Expunged of CB, IB types; relocated
                                    inline functions to string/strmisc.cxx
        beng        07/23/91        Added more *_STR types
        gregj        03/22/93        Ported to Chicago environment.
        gregj        03/25/93        Added Party(), DonePartying()
        gregj        03/30/93        Allow assigning NLS_STR to ISTR
        gregj        04/02/93        Added NLS_STR::IsDBCSLeadByte()
        gregj        04/02/93        Added ISTR::operator int
        gregj        04/08/93        Added NLS_STR::strncpy()
        gregj        04/08/93        Added NLS_STR::GetPrivateProfileString()
*/

#define WIN31    /* for certain string and NETLIB stuff */

#ifndef _BASE_HXX_
#include "base.h"
#endif

#ifndef _STRING_HXX_
#define _STRING_HXX_

extern HINSTANCE hInstance;        // for NLS_STR::LoadString

// String class doesn't allocate or deallocate memory
// for STR_OWNERALLOC strings
//
#define STR_OWNERALLOC         0x8000

// Same as owner alloc only the string is initialized with the null string.
//
#define STR_OWNERALLOC_CLEAR 0x8001

// Maximum resource string size, owner alloced strings must be at least
// MAX_RES_STR_LEN, otherwise an error will occur.
//
#define MAX_RES_STR_LEN    255


// The maximum number of insert parameters the InsertParams method can
// handle
//
#define MAX_INSERT_PARAMS    9


/*************************************************************************

    NAME:    ISTR

    SYNOPSIS:    String index object, used in conjunction with NLS_STR

    INTERFACE:
        ISTR()    - this ISTR gets associated with
                  the passed string and can only be used
                  on this string (NOTE:  on non-debug
                  versions this turns into a nop, can still
                  be useful for decl. clarity however).

        ISTR()    - Initialize to passed ISTR;
                  this ISTR will be associated with
                  the same string that the passed ISTR
                  is associated with.

        operator=()   - Copy passed ISTR (see prev.)

        operator=()   - Associate ISTR with a new NLS_STR.

        operator-()   - Returns CB diff. between *this & Param.
                        (must both belong to the same string)

        operator++()  - Advance the ISTR to the next logical
                        character (use only where absolutely
                        necessary).  Stops at end of string

        operator+=()  - Advance the ISTR to the ith logical
                        character (call operator++ i times)
                        Stops at end of string.

        operator==()  - Returns TRUE if the two ISTRs point to
                        the same position in the string (causes
                        an assertion failure if the two ISTRs
                        don't point to the same string).

        operator>()   - Returns true of *this is greater then
                        the passed ISTR (i.e., further along
                        in the string).

        operator<()   - Same as operator>, only less then.

        Reset()       - Resets ISTR to beginning of string and
                        updates the ISTR version number with the
                        string's current version number

    private:
        QueryIB()     - Returns the index in bytes
        QueryPNLS()   - Returns the pointer to the NLS_STR this ISTR
                        references
        SetPNLS()     - Sets the pointer to point to the NLS_STR
                        this ISTR references

    DEBUG ONLY:
        QueryVersion()     - Gets the version number of
                           the string this ISTR is associated with
        SetVersion()     - Sets the version number of this ISTR.

    USES:

    CAVEATS:    Each NLS_STR has a version number associated with it.  When
                an operation is performed that modifies the string, the
                version number is updated.  It is invalid to use an ISTR
                after its associated NLS_STR has been modified (can use
                Reset to resync it with the NLS_STR, the index gets reset
                to zero).

                You must associate an NLS_STR with an ISTR at the
                declaration of the ISTR.

    NOTES:        The version checking and string association checking goes
                away in the non-debug version.

    HISTORY:
        johnl        11/16/90        Created
        johnl        12/07/90        Modified after code review
        gregj        03/30/93        Allow assigning NLS_STR to ISTR

**************************************************************************/

class ISTR
{
friend class NLS_STR;

public:
    ISTR( const ISTR& istr );
    ISTR( const NLS_STR& nls );
    ISTR& operator=( const ISTR& istr );
    ISTR& operator=( const NLS_STR& nls );

    INT operator-( const ISTR& istr ) const;

    ISTR& operator++();
    VOID operator+=( INT iChars );

    BOOL operator==( const ISTR& istr ) const;
    BOOL operator>( const ISTR& istr )  const;
    BOOL operator<( const ISTR& istr )  const;

    operator INT() const { return QueryIB(); }

    VOID Reset();

private:
    INT _ibString;        // Index (in bytes) into an NLS_STR
    NLS_STR *_pnls;        // Pointer to "owner" NLS

    INT QueryIB() const
        { return _ibString; }
    VOID SetIB( INT ib )
        { _ibString = ib; }

    const NLS_STR* QueryPNLS() const
        { return _pnls; }
    VOID SetPNLS( const NLS_STR * pnls )
        { _pnls = (NLS_STR*)pnls; }

#ifdef DEBUG
    // Version number of NLS_STR this ISTR is associated with
    //
    USHORT _usVersion;

    USHORT QueryVersion() const { return _usVersion; }
    VOID SetVersion( USHORT usVers ) { _usVersion = usVers; }
#endif
};


/*************************************************************************

    NAME:        NLS_STR (nls)

    SYNOPSIS:    Provide a better string abstraction than the standard ASCIIZ
                representation offered by C (and C++).  The abstraction is
                better mainly because it handles double-byte characters
                (DBCS) in the string and makes intelligent use of operator
                overloading.

    INTERFACE:    NLS_STR()        Construct a NLS_STR (initialized to a CHAR *,
                                NLS_STR or NULL).  Reports errors via BASE.

                ~NLS_STR()        Destructor

                operator=()        Assign one NLS_STR (or CHAR *) value
                                to another (old string is deleted, new
                                string is allocated and copies source)

                operator+=()    Concatenate with assignment (equivalent to
                                strcat - see strcat).

                operator==()    Compare two NLS_STRs for equality

                operator!=()    Compare two NLS_STRs for inequality

                QueryPch()        Access operator, returning a "char *"
                                aliased to the string.  DO NOT MODIFY
                                THE STRING USING THIS METHOD (or pass
                                it to procedures that might modify it).
                                Synonym: operator const CHAR *().

                operator[]()    Same as QueryPch, except the string
                                is offset by ISTR characters

                IsDBCSLeadByte()    Returns whether a byte is a lead byte,
                                according to the ANSI- or OEM-ness of the
                                string.

        C-runtime-style methods.

                strlen()        Return the length of the string in bytes,
                                less terminator.  Provided only for crt
                                compatibility; please use a Query method
                                if possible.

                strcat()        Append an NLS_STR.  Will cause *this to be
                                reallocated if the appended string is larger
                                then this->QueryCb() and this is not an
                                STR_OWNERALLOC string

                strncpy()        Copy a non-null-terminated string into an
                                NLS_STR.  DBCS-safe.  For similar functionality
                                with an NLS_STR as the source, use the sub-
                                string members.

                strcmp()        Compare two NLS_STRs
                stricmp()        "
                strncmp()        Compare a portion of two NLS_STRs
                strnicmp()        "

                strcspn()        Find first char in *this that is
                                a char in arg
                strspn()        Find first char in *this that is
                                not a char in arg

                strtok()        Returns a token from the string

                strstr()        Search for a NLS_STR.

                strchr()        Search for a CHAR from beginning.
                                Returns offset.
                strrchr()        Search for a CHAR from end.
                strupr()        Convert NLS_STR to upper case.
                atoi()            Returns integer numeric value
                atol()            Returns long value

                realloc()        Resize string preserving its contents

        Other methods.

                QueryAllocSize()    Returns total # of bytes allocated (i.e.,
                                    number new was called with, or size of
                                    memory block if STR_OWNERALLOC
                IsOwnerAlloc()        Returns TRUE if this string is an owner
                                    allocated string
                QuerySubStr()        Return a substring
                InsertStr()            Insert a NLS_STR at given index.
                DelSubStr()            Delete a substring
                ReplSubStr()        Replace a substring (given start and
                                    NLS_STR)

                InsertParams()        Replace %1-%9 params in *this with the
                                    corresponding NLS_STRs contained in the
                                    array of pointers

                LoadString()        Load the string associated with the passed
                                    resource into *this (OWNER_ALLOC strings must
                                    be at least MAX_RES_STR_LEN).  Optionally
                                    calls InsertParams with a passed array of
                                    nls pointers.

                GetPrivateProfileString()    Loads a string from an INI file.

                Reset()                After an operation fails (due to memory
                                    failure), it is invalid to use the string
                                    until Reset has been called.  If the object
                                    wasn't successfully constructed, Reset will
                                    fail.

                QueryTextLength()    Returns the number of CHARS, less
                                    terminator.

                QueryTextSize()        Returns the number of bytes, including
                                    terminator.  Denotes amount of storage
                                    needed to dup string into a bytevector.

                QueryNumChar()        Returns total number of logical characters
                                    within the string.  Rarely needed.

                Append()            Appends a string to the current string,
                                    like strcat.
                AppendChar()        Appends a single character.

                Compare()            As strcmp().

                CopyFrom()            As operator=(), but returns an APIERR.

                ToOEM()                Convert string to OEM character set.

                ToAnsi()            Convert string to ANSI character set.

                Party()                Obtain read-write access to the buffer.
                DonePartying()        Release read-write access.

    PARENT:    BASE

    USES:    ISTR

    CAVEATS:    A NLS_STR object can enter an error state for various
                reasons - typically a memory allocation failure.  Using
                an object in such a state is theoretically an error.
                Since string operations frequently occur in groups,
                we define operations on an erroneous string as no-op,
                so that the check for an error may be postponed until
                the end of the complex operation.  Most member functions
                which calculate a value will treat an erroneous string
                as having zero length; however, clients should not depend
                on this.

                Attempting to use an ISTR that is registered with another
                string will cause an assertion failure.

                Each NLS_STR has a version/modification flag that is also
                stored in the the ISTR.  An attempt to use an ISTR on an
                NLS_STR that has been modified (by calling one of the methods
                listed below) will cause an assertion failure.    To use the
                ISTR after a modifying method, you must first call ISTR::Reset
                which will update the version in the ISTR.  See the
                method definition for more detail.

                List of modifying methods:
                    All NLS::operator= methods
                    NLS::DelSubStr
                    NLS::ReplSubStr
                    NLS::InsertSubStr

                NOTE: The ISTR used as a starting index on the
                Substring methods remains valid after the call.

                Party() and DonePartying() can be used when you need to
                do something that the standard NLS_STR methods don't
                cover.  For example, you might want to tweak the first
                couple of characters in a pathname;  if you know they're
                definitely not double-byte characters, this is safe to
                do with ordinary character assignments.
                
                Calling Party() returns a pointer to the string buffer,
                and places the NLS_STR in an error state to prevent the
                standard methods from operating on it (and thereby getting
                confused by the possibly incorrect cached length).  You
                can still call QueryAllocSize() to find out the maximum
                size of the buffer.  When you've finished, call DonePartying()
                to switch the NLS_STR back to "normal" mode.  There are two
                overloaded forms of DonePartying().  If you know what the
                length of the string is, you can pass it in, and NLS_STR
                will just use that.  Otherwise, it will use strlenf() to
                find out what the new length is.  If you don't plan to
                change the length, call strlen() on the string before you
                Party(), save that length, and pass it to DonePartying().
                The initial strlen() is fast because it's cached.

                If you find yourself constantly Party()ing in order to
                accomplish a particular function, that function should
                be formally added to the NLS_STR definition.

    NOTES:        The lack of a strlwr() method comes from a shortcoming
                in the casemap tables.    Sorry.

                STR_OWNERALLOC strings are a special type of NLS_STR
                You mark a string as STR_OWNERALLOC on
                construction by passing the flag STR_OWNERALLOC and a pointer
                to your memory space where you want the string to reside
                plus the size of the memory block.
                THE POINTER MUST POINT TO A VALID NULL TERMINATED STRING.
                You are guaranteed this pointer will never be
                resized or deleted.  Note that no checking is performed for
                writing beyond the end of the string.  Valid uses include
                static strings, severe optimization, owner controlled
                memory allocation or stack controlled memory allocation.

                CODEWORK: Owner-alloc strings should be a distinct
                class from these normal strings.

                CODEWORK: Should add a fReadOnly flag.

                CODEWORK: Should clean up this mess, and make the
                owner-alloc constructor protected.

                I wish I could clean up this mess...

    HISTORY:
        johnl        11/28/90        First fully functioning version
        johnl        12/07/90        Incorporated code review changes
        terryk        04/05/91        add QueryNumChar method
        beng        07/22/91        Added more methods; separated fOwnerAlloc
                                    from cbData
        gregj        05/22/92        Added ToOEM, ToAnsi methods
        gregj        03/22/93        Ported to Chicago environment
        gregj        04/02/93        Added IsDBCSLeadByte()
        gregj        04/08/93        Added strncpy()

**************************************************************************/

class NLS_STR : public BASE
{
friend class ISTR; // Allow access to CheckIstr

public:
    // Default constructor, creating an empty string.
    //
    NLS_STR();

    // Initialize to "cchInitLen" characters, each "chInit",
    // plus trailing NUL.
    //
    NLS_STR( INT cchInitLen );

    // Initialize from a NUL-terminated character vector.
    //
    NLS_STR( const CHAR *pchInit );

    // Initialize an NLS_STR to memory position passed in achInit
    // No memory allocation of any type will be performed on this string
    // cbSize should be the total memory size of the buffer, if cbSize == -1
    // then the size of the buffer will assumed to be strlen(achInit)+1
    //
    NLS_STR( unsigned stralloc, CHAR *pchInit, INT cbSize = -1 );

    // Initialize from an existing x_STRING.
    //
    NLS_STR( const NLS_STR& nlsInit );

    ~NLS_STR();

    // Number of bytes the string uses (not including terminator)
    // Cf. QueryTextLength and QueryTextSize.
    //
    inline INT strlen() const;

    // Return a read-only CHAR vector, for the APIs.
    //
    const CHAR *QueryPch() const
#ifdef DEBUG
        ;
#else
        { return _pchData; }
#endif

    const CHAR *QueryPch( const ISTR& istr ) const
#ifdef DEBUG
        ;
#else
        { return _pchData + istr.QueryIB(); }
#endif

    WCHAR QueryChar( const ISTR& istr ) const
#ifdef DEBUG
        ;
#else
        { return *(_pchData+istr.QueryIB()); }
#endif

    operator const CHAR *() const
        { return QueryPch(); }

    const CHAR *operator[]( const ISTR& istr ) const
        { return QueryPch(istr); }

    BOOL IsDBCSLeadByte( CHAR ch ) const;

    // Total allocated storage
    //
    inline INT QueryAllocSize() const;

    inline BOOL IsOwnerAlloc() const;

    // Increase the size of a string preserving its contents.
    // Returns TRUE if successful, false otherwise (illegal to
    // call for an owner alloced string).  If you ask for a string smaller
    // then the currently allocated one, the request will be ignored and TRUE
    // will be returned.
    //
    BOOL realloc( INT cbNew );

    // Returns TRUE if error was successfully cleared (string is now in valid
    // state), FALSE otherwise.
    //
    BOOL Reset();

    NLS_STR& operator=( const NLS_STR& nlsSource );
    NLS_STR& operator=( const CHAR *achSource );

    NLS_STR& operator+=( WCHAR wch );        // NEW, replaces AppendChar
    NLS_STR& operator+=( const NLS_STR& nls ) { return strcat(nls); }
    NLS_STR& operator+=( LPCSTR psz ) { return strcat(psz); }

    NLS_STR& strncpy( const CHAR *pchSource, UINT cbSource );

    NLS_STR& strcat( const NLS_STR& nls );
    NLS_STR& strcat( LPCSTR psz );

    BOOL operator== ( const NLS_STR& nls ) const;
    BOOL operator!= ( const NLS_STR& nls ) const;

    INT strcmp( const NLS_STR& nls ) const;
    INT strcmp( const NLS_STR& nls, const ISTR& istrThis ) const;
    INT strcmp( const NLS_STR& nls, const ISTR& istrThis,
                const ISTR& istrStart2 ) const;

    INT stricmp( const NLS_STR& nls ) const;
    INT stricmp( const NLS_STR& nls, const ISTR& istrThis ) const;
    INT stricmp( const NLS_STR& nls, const ISTR& istrThis,
                 const ISTR& istrStart2 ) const;

    INT strncmp( const NLS_STR& nls, const ISTR& istrLen ) const;
    INT strncmp( const NLS_STR& nls, const ISTR& istrLen,
                 const ISTR& istrThis ) const;
    INT strncmp( const NLS_STR& nls, const ISTR& istrLen,
                 const ISTR& istrThis, const ISTR& istrStart2 ) const;

    INT strnicmp( const NLS_STR& nls, const ISTR& istrLen ) const;
    INT strnicmp( const NLS_STR& nls, const ISTR& istrLen,
                  const ISTR& istrThis ) const;
    INT strnicmp( const NLS_STR& nls, const ISTR& istrLen,
                  const ISTR& istrThis, const ISTR& istrStart2 ) const;

    // The following str* functions return TRUE if successful (istrPos has
    // meaningful data), false otherwise.
    //
    BOOL strcspn( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL strcspn( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;
    BOOL strspn( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL strspn( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;

    BOOL strstr( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL strstr( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;

    BOOL stristr( ISTR *istrPos, const NLS_STR& nls ) const;
    BOOL stristr( ISTR *istrPos, const NLS_STR& nls, const ISTR& istrStart ) const;

    BOOL strchr( ISTR *istrPos, const CHAR ch ) const;
    BOOL strchr( ISTR *istrPos, const CHAR ch, const ISTR& istrStart ) const;

    BOOL strrchr( ISTR *istrPos, const CHAR ch ) const;
    BOOL strrchr( ISTR *istrPos, const CHAR ch, const ISTR& istrStart ) const;

    BOOL strtok( ISTR *istrPos, const NLS_STR& nlsBreak, BOOL fFirst = FALSE );

    LONG atol() const;
    LONG atol( const ISTR& istrStart ) const;

    INT atoi() const;
    INT atoi( const ISTR& istrStart ) const;

    NLS_STR& strupr();

    // Return a pointer to a new NLS_STR that contains the contents
    // of *this from istrStart to:
    //        End of string if no istrEnd is passed
    //        istrStart + istrEnd
    //
    NLS_STR *QuerySubStr( const ISTR& istrStart ) const;
    NLS_STR *QuerySubStr( const ISTR& istrStart, const ISTR& istrEnd ) const;

    // Collapse the string by removing the characters from istrStart to:
    //        End of string
    //        istrStart + istrEnd
    // The string is not reallocated
    //
    VOID DelSubStr( ISTR& istrStart );
    VOID DelSubStr( ISTR& istrStart, const ISTR& istrEnd );

    BOOL InsertStr( const NLS_STR& nlsIns, ISTR& istrStart );

    // Replace till End of string of either *this or replacement string
    // (or istrEnd in the 2nd form) starting at istrStart
    //
    VOID ReplSubStr( const NLS_STR& nlsRepl, ISTR& istrStart );
    VOID ReplSubStr( const NLS_STR& nlsRepl, ISTR& istrStart,
                     const ISTR& istrEnd );

    // Replace %1-%9 in *this with corresponding index from apnlsParamStrings
    // Ex. if *this="Error %1" and apnlsParamStrings[0]="Foo" the resultant
    //       string would be "Error Foo"
    //
    USHORT InsertParams( const NLS_STR *apnlsParamStrings[] );

    // Load a message from a resource file into *this (if string is an
    // OWNER_ALLOC string, then must be at least MAX_RES_STR_LEN.  Heap
    // NLS_STRs will be reallocated if necessary
    //
    USHORT LoadString( USHORT usMsgID );

    // Combines functionality of InsertParams & LoadString.  *this gets loaded
    // with the string from the resource file corresponding to usMsgID.
    //
    USHORT LoadString( USHORT usMsgID, const NLS_STR *apnlsParamStrings[] );

    VOID GetPrivateProfileString( const CHAR *pszFile, const CHAR *pszSection,
                                  const CHAR *pszKey, const CHAR *pszDefault = NULL );

    VOID ToOEM();            // convert ANSI to OEM

    VOID ToAnsi();            // convert OEM to ANSI

    VOID SetOEM();            // declare that string was constructed as OEM
    VOID SetAnsi();            // declare that string was constructed as ANSI

    inline BOOL IsOEM() const;

    CHAR *Party();            // get read-write access
    VOID DonePartying( VOID );            // if you don't have the length handy
    VOID DonePartying( INT cchNew );    // if you do

#ifdef EXTENDED_STRINGS
    // Initialize from a NUL-terminated character vector
    // and allocate a minimum of: cbTotalLen+1 bytes or strlen(achInit)+1
    //
    NLS_STR( const CHAR *pchInit, INT iTotalLen );

    // Similar to prev. except the string pointed at by pchInit is copied
    // to pchBuff.  The address of pchBuff is used as the string storage.
    // cbSize is required.  stralloc can only be STR_OWNERALLOC (it makes
    // no sense to use STR_OWNERALLOC_CLEAR).
    //
    NLS_STR( unsigned stralloc, CHAR *pchBuff, INT cbSize,
             const CHAR *pchInit );

    // return the number of logical characters within the string
    //
    INT QueryNumChar() const;

    // Return the number of printing CHARs in the string.
    // This number does not include the termination character.
    //
    // Cf. QueryNumChar, which returns a count of glyphs.
    //
    INT QueryTextLength() const;

    // Return the number of BYTES occupied by the string's representation.
    // Cf. QueryAllocSize, which returns the total amount alloc'd.
    //
    INT QueryTextSize() const;

    APIERR Append( const NLS_STR& nls );

    APIERR AppendChar( WCHAR wch );

    APIERR CopyFrom( const NLS_STR& nlsSource );
    APIERR CopyFrom( const CHAR *achSource );

    INT Compare( const NLS_STR *nls ) const { return strcmp(*nls); }

#endif

private:
    UINT _fsFlags;        // owner-alloc, character set flags
#define SF_OWNERALLOC    0x1
#define SF_OEM            0x2

    INT _cchLen;        // Number of bytes string uses (strlen)
    INT _cbData;        // Total storage allocated
    CHAR *_pchData;        // Pointer to Storage

#ifdef DEBUG
    USHORT _usVersion;    // Version count (inc. after each change)
#endif

    // The following substring functions are used internally (can't be
    // exposed since they take an INT cbLen parameter for an index).
    //
    VOID DelSubStr( ISTR&istrStart, INT cbLen );

    NLS_STR *QuerySubStr( const ISTR& istrStart, INT cbLen ) const;

    VOID ReplSubStr( const NLS_STR& nlsRepl, ISTR& istrStart, INT cbLen );

    BOOL Alloc( INT cchLen );      // Allocate memory for a string

#ifdef DEBUG        // DEBUG is new for these
    // CheckIstr checks whether istr is associated with this, asserts out
    // if it is not.  Also checks version numbers in debug version.
    //
    VOID CheckIstr( const ISTR& istr ) const;

    // UpdateIstr syncs the version number between *this and the passed
    // ISTR.  This is for operations that cause an update to the string
    // but the ISTR that was passed in is still valid (see InsertSubSt).
    //
    VOID UpdateIstr( ISTR *pistr ) const;

    // IncVers adds one to this strings version number because the previous
    // operation caused the contents to change thus possibly rendering
    // ISTRs on this string as invalid.
    //
    VOID IncVers();

    // InitializeVers sets the version number to 0
    //
    VOID InitializeVers();

    // QueryVersion returns the current version number of this string
    //
    USHORT QueryVersion() const;
#else    // DEBUG
    VOID CheckIstr( const ISTR& istr ) const { }
    VOID UpdateIstr( ISTR *pistr ) const { }
    VOID IncVers() { }
    VOID InitializeVers() { }
    USHORT QueryVersion() const { return 0; }
#endif
};


/***********************************************************************/

/***********************************************************************
 *
 *  Macro STACK_NLS_STR(name, len )
 *
 *    Define an NLS string on the stack with the name of "name" and the
 *    length of "len".    The strlen will be 0 and the first character will
 *    be '\0'.    One byte is added for the NULL terminator.  Usage:
 *        STACK_NLS_STR( UncPath, UNCLEN );
 *
 *  Macro ISTACK_NLS_STR(name, len, pchInitString )
 *
 *    Same as STACK_NLS_STR except ISTACK_NLS_STR takes an initializer.
 **********************************************************************/

#define STACK_NLS_STR( name, len )                \
    CHAR _tmp##name[ len+1 ] ;                    \
    *_tmp##name = '\0' ;                    \
    NLS_STR name( STR_OWNERALLOC, _tmp##name, len+1 );

#define ISTACK_NLS_STR( name, len, pchInitString )        \
    STACK_NLS_STR( name, len ) ;                \
    name = pchInitString;

/***********************************************************************/

BOOL NLS_STR::IsOwnerAlloc() const
{
    return _fsFlags & SF_OWNERALLOC;
}

BOOL NLS_STR::IsOEM() const
{
    return _fsFlags & SF_OEM;
}

INT NLS_STR::strlen() const
{
    return _cchLen;
}

INT NLS_STR::QueryAllocSize()  const
{
    return _cbData;
}

#endif // _STRING_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\sched.h ===
/*****************************************************************/
/**				 MPR Client/Server DLL Header File				**/
/**		      	Copyright (C) Microsoft Corp., 1994				**/
/*****************************************************************/ 

/* SCHED.H -- Header file for miscellaneous common scheduling primitives.
 *
 * History:
 *	gregj	10/17/94	created
 */


#ifndef _INC_SCHED
#define _INC_SCHED

#ifndef RC_INVOKED
#ifdef __cplusplus
extern "C" {
#endif

/* WaitAndYield processes all input messages.  WaitAndProcessSends only
 * processes SendMessages.
 *
 * WaitAndYield takes an optional parameter which is the ID of another
 * thread concerned with the waiting.  If it's not NULL, WM_QUIT messages
 * will be posted to that thread's queue when they are seen in the message
 * loop.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread = NULL);
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout);

#ifdef __cplusplus
};	/* extern "C" */
#endif

#endif	/* RC_INVOKED */

#endif	/* _INC_SCHED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\mslocusr.cpp ===
#include "mslocusr.h"
#include <netspi.h>
#define DECL_CRTFREE
#include <crtfree.h>

/* the following defs will make msluglob.h actually define globals */
#define EXTERN
#define ASSIGN(value) = value
#include "msluglob.h"

HANDLE g_hmtxShell = 0;              // Note: Handle is per-instance.

#ifdef DEBUG
BOOL g_fCritical=FALSE;
#endif

HINSTANCE hInstance = NULL;

const char szMutexName[] = "MSLocUsrMutex";
UINT g_cRefThisDll = 0;		// Reference count of this DLL.
UINT g_cLocks = 0;			// Number of locks on this server.


void LockThisDLL(BOOL fLock)
{
	ENTERCRITICAL
	{
		if (fLock)
			g_cLocks++;
		else
			g_cLocks--;
	}
	LEAVECRITICAL
}


void RefThisDLL(BOOL fRef)
{
	ENTERCRITICAL
	{
		if (fRef)
			g_cRefThisDll++;
		else
			g_cRefThisDll--;
	}
	LEAVECRITICAL
}


void Netlib_EnterCriticalSection(void)
{
    WaitForSingleObject(g_hmtxShell, INFINITE);
#ifdef DEBUG
    g_fCritical=TRUE;
#endif
}

void Netlib_LeaveCriticalSection(void)
{
#ifdef DEBUG
    g_fCritical=FALSE;
#endif
    ReleaseMutex(g_hmtxShell);
}

void _ProcessAttach()
{
    //
    // All the per-instance initialization code should come here.
    //
    // We should not pass TRUE as fInitialOwner, read the CreateMutex
    // section of Win32 API help file for detail.
    //
	::DisableThreadLibraryCalls(::hInstance);
    
    g_hmtxShell = CreateMutex(NULL, FALSE, ::szMutexName);  // per-instance

    ::InitStringLibrary();
}

void _ProcessDetach()
{
    UnloadShellEntrypoint();
    CloseHandle(g_hmtxShell);
}

STDAPI_(BOOL) DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        hInstance = hInstDll;
	_ProcessAttach();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
	_ProcessDetach();
    }


    return TRUE;
}


UINT
NPSCopyNLS ( 
    NLS_STR FAR *   pnlsSourceString, 
    LPVOID          lpDestBuffer, 
    LPDWORD         lpBufferSize )
{
    if ((!lpBufferSize) || (!lpDestBuffer && (*lpBufferSize != 0))) {
        return ERROR_INVALID_PARAMETER;
    }
    if (pnlsSourceString != NULL) {

        DWORD   dwDestLen = 0;  // bytes copied to dest buffer, including NULL
        DWORD   dwSourceLen = pnlsSourceString->strlen() + 1; // bytes in source buffer, including NULL

        if ((lpDestBuffer) && (*lpBufferSize != 0)) {
            NLS_STR nlsDestination( STR_OWNERALLOC_CLEAR, (LPSTR)lpDestBuffer, (UINT) *lpBufferSize );        
            nlsDestination = *pnlsSourceString;      /* copy source string to caller's buffer */
            dwDestLen = nlsDestination.strlen() + 1;
        }
        if (dwSourceLen != dwDestLen) {
            // Only update buffersize parameter if there is more data,
            // and store source string size, counting NULL.
            *lpBufferSize = dwSourceLen;
            return ERROR_MORE_DATA;
        }
        else {
            return NOERROR;
        }
    }
    else {
        if (*lpBufferSize == 0) {
            *lpBufferSize = 1;
            return ERROR_MORE_DATA;
        }
        else {
            *(LPSTR)lpDestBuffer = NULL; // validated to not be NULL above
            return NOERROR;
        }
    }            
}

DWORD
NPSCopyString (
    LPCTSTR lpSourceString,
    LPVOID  lpDestBuffer,
    LPDWORD lpBufferSize )
{
    if (lpSourceString != NULL) {    
        NLS_STR nlsSource( STR_OWNERALLOC, (LPTSTR)lpSourceString );
        return NPSCopyNLS ( &nlsSource,
                            lpDestBuffer,
                            lpBufferSize );
    }
    else {
        return NPSCopyNLS ( NULL,
                            lpDestBuffer,
                            lpBufferSize );    
    }                               
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\dllload.c ===
#include <windows.h>
#include "netmpr.h"
#include "pwlapi.h"
#include <pcerr.h>

/* Avoid inconsistent-DLL-linkage warnings on shell32 and comctl32 APIs. */
#undef DECLSPEC_IMPORT
#define DECLSPEC_IMPORT
#include <prsht.h>
#include <shellapi.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 

// These macros produce code that looks like
#if 0

BOOL GetOpenFileNameA(LPOPENFILENAME pof)
{
    static BOOL (*pfnGetOpenFileNameA)(LPOPENFILENAME pof);
    _GetProcFromDLL(&g_hinstCOMDLG32, "COMDLG32.DLL",  "GetOpenFileNameA", &pfnGetoptnFileNameA);
    if (pfnGetOpenFileNameA)
        return pfnGetOpenFileNameA(pof);
    return -1;
}
#endif

/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    // If it's already loaded, return.
    if (*ppfn) {
        return;
    }

    if (*phinst == NULL) {
        *phinst = LoadLibrary(pszDLL);
        if (*phinst == NULL) {
            return;
        }
    }

    *ppfn = GetProcAddress(*phinst, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
        
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}


/**********************************************************************/
/**********************************************************************/



// --------- MSPWL32.DLL ---------------

HINSTANCE g_hinstMSPWL32 = NULL;

#define DELAY_LOAD_PWL(_fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(g_hinstMSPWL32, mspwl32.dll, APIERR, _fn, _ord, _args, _nargs, IERR_CachingDisabled)

DELAY_LOAD_PWL(OpenPasswordCache, 10,
			   (LPHPWL lphCache,const CHAR *pszUsername,const CHAR *pszPassword,BOOL fWritable),
			   (lphCache, pszUsername, pszPassword, fWritable));
DELAY_LOAD_PWL(ClosePasswordCache, 11,
			   (HPWL hCache, BOOL fDiscardMemory), (hCache, fDiscardMemory));
DELAY_LOAD_PWL(CreatePasswordCache, 12,
			   (LPHPWL lphCache,const CHAR *pszUsername,const CHAR *pszPassword),
			   (lphCache, pszUsername, pszPassword));
DELAY_LOAD_PWL(DeletePasswordCache, 22,
			   (const CHAR *pszUsername), (pszUsername));
DELAY_LOAD_PWL(FindCacheResource, 16,
			   (HPWL hCache,const CHAR *pbResource,WORD cbResource,CHAR *pbBuffer,WORD cbBuffer,UCHAR nType),
			   (hCache, pbResource, cbResource, pbBuffer, cbBuffer, nType));
DELAY_LOAD_PWL(DeleteCacheResource, 17,
			   (HPWL hCache,const CHAR *pbResource,WORD cbResource,UCHAR nType),
			   (hCache, pbResource, cbResource, nType));
DELAY_LOAD_PWL(AddCacheResource, 18,
			   (HPWL hCache,const CHAR *pbResource,WORD cbResource,const CHAR *pbPassword,WORD cbPassword,UCHAR nType,UINT fnFlags),
			   (hCache, pbResource, cbResource, pbPassword, cbPassword, nType, fnFlags));
DELAY_LOAD_PWL(SetCachePassword, 21,
			   (HPWL hCache, const CHAR *pszNewPassword),
			   (hCache, pszNewPassword));


// --------- MPR.DLL ---------------

HINSTANCE g_hinstMPR = NULL;

DELAY_LOAD_ERR(g_hinstMPR, mpr.dll, DWORD, WNetCachePassword,
               (LPSTR pbResource, WORD cbResource, LPSTR pbPassword, WORD cbPassword, BYTE nType, UINT fnFlags),
               (pbResource, cbResource, pbPassword, cbPassword, nType, fnFlags),
               WN_CANCEL);
DELAY_LOAD_ERR(g_hinstMPR, mpr.dll, DWORD, WNetGetCachedPassword,
               (LPSTR pbResource, WORD cbResource, LPSTR pbPassword, LPWORD pcbPassword, BYTE nType),
               (pbResource, cbResource, pbPassword, pcbPassword, nType),
               WN_CANCEL);
DELAY_LOAD_ERR(g_hinstMPR, mpr.dll, DWORD, WNetRemoveCachedPassword,
               (LPSTR pbResource, WORD cbResource, BYTE nType),
               (pbResource, cbResource, nType),
               WN_CANCEL);

// --------- COMCTL32.DLL ---------------

HINSTANCE g_hinstCOMCTL32 = NULL;

DELAY_LOAD(g_hinstCOMCTL32, comctl32.dll, HPROPSHEETPAGE, CreatePropertySheetPageA,
           (LPCPROPSHEETPAGEA lpPage), (lpPage));
DELAY_LOAD(g_hinstCOMCTL32, comctl32.dll, INT_PTR, PropertySheetA,
           (LPCPROPSHEETHEADERA lpHdr), (lpHdr));

// --------- SHELL32.DLL ----------------

HINSTANCE g_hinstSHELL32 = NULL;

#ifdef UNICODE
DELAY_LOAD(g_hinstSHELL32, SHELL32.DLL, BOOL, ShellExecuteExW,
	(LPSHELLEXECUTEINFOW lpExecInfo), (lpExecInfo));
#else
DELAY_LOAD(g_hinstSHELL32, SHELL32.DLL, BOOL, ShellExecuteExA,
	(LPSHELLEXECUTEINFOA lpExecInfo), (lpExecInfo));
#endif
DELAY_LOAD_ORD_VOID(g_hinstSHELL32, SHELL32.DLL, SHFlushSFCache, 526, (), ());

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\mslucpl.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"

#include "profiles.h"
#include <npmsg.h>
#include <shellapi.h>

#include "contxids.h"


HRESULT GetLBItemText(HWND hDlg, UINT idCtrl, int iItem, NLS_STR *pnls)
{
    HWND hCtrl = GetDlgItem(hDlg, idCtrl);
    UINT cch = (UINT)SendMessage(hCtrl, LB_GETTEXTLEN, iItem, 0);
    if (pnls->realloc(cch + 1)) {
        SendMessage(hCtrl, LB_GETTEXT, iItem, (LPARAM)(LPSTR)pnls->Party());
        pnls->DonePartying();
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


void SetErrorFocus(HWND hDlg, UINT idCtrl, BOOL fClear /* = TRUE */)
{
    HWND hCtrl = ::GetDlgItem(hDlg, idCtrl);
    ::SetFocus(hCtrl);
    if (fClear)
        ::SetWindowText(hCtrl, "");
    else
        ::SendMessage(hCtrl, EM_SETSEL, 0, -1);
}


INT_PTR CALLBACK PasswordDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_STATIC1,    IDH_RATINGS_SUPERVISOR_PASSWORD,
        IDC_STATIC2,    IDH_RATINGS_SUPERVISOR_PASSWORD,
        IDC_PASSWORD,   IDH_RATINGS_SUPERVISOR_PASSWORD,
        0,0
    };

    CHAR pszPassword[MAX_PATH];
    HRESULT hRet;

    switch (uMsg) {
        case WM_INITDIALOG:
            {
                HWND hwndCheckbox = GetDlgItem(hDlg, IDC_CACHE_PASSWORD);

                IUserDatabase *pDB = (IUserDatabase *)lParam;
                SetWindowLongPtr(hDlg, DWLP_USER, lParam);
                IUser *pCurrentUser;
                HRESULT hres;
                hres = pDB->GetCurrentUser(&pCurrentUser);
                if (SUCCEEDED(hres)) {
                    DWORD cbBuffer = sizeof(pszPassword);
                    hres = pCurrentUser->GetName(pszPassword, &cbBuffer);
                    if (SUCCEEDED(hres)) {
                        NLS_STR nlsName(STR_OWNERALLOC, pszPassword);
                        NLS_STR nlsTemp(MAX_RES_STR_LEN);
                        const NLS_STR *apnls[] = { &nlsName, NULL };
                        hres = HRESULT_FROM_WIN32(nlsTemp.LoadString(IDS_CACHE_PASSWORD, apnls));
                        if (SUCCEEDED(hres))
                            SetWindowText(hwndCheckbox, nlsTemp.QueryPch());
                    }
                    pCurrentUser->Release();
                }
                if (FAILED(hres)) {
                    ShowWindow(hwndCheckbox, SW_HIDE);
                    EnableWindow(hwndCheckbox, FALSE);
                }
                CheckDlgButton(hDlg, IDC_CACHE_PASSWORD, 0);
            }
            return TRUE;        /* we did not set the focus */

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                break;

            case IDOK:
                GetDlgItemText(hDlg, IDC_PASSWORD, pszPassword, sizeof(pszPassword));
                hRet = VerifySupervisorPassword(pszPassword);

                if (hRet == (NOERROR)) {
                    IUserDatabase *pDB = (IUserDatabase *)GetWindowLongPtr(hDlg, DWLP_USER);
                    IUser *pCurrentUser;
                    if (SUCCEEDED(pDB->GetCurrentUser(&pCurrentUser))) {
                        if (IsDlgButtonChecked(hDlg, IDC_CACHE_PASSWORD)) {
                            pCurrentUser->SetSupervisorPrivilege(TRUE, pszPassword);
                        }
                        else {
                            pCurrentUser->MakeTempSupervisor(TRUE, pszPassword);
                        }
                        pCurrentUser->Release();
                    }

                    EndDialog(hDlg, TRUE);
                }
                else
                {
                    MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                    SetErrorFocus(hDlg, IDC_PASSWORD);
                }
                break;

            default:
                return FALSE;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szRatingsHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, ::szRatingsHelpFile, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)aIds);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

INT_PTR CALLBACK ChangePasswordDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_STATIC1,            IDH_OLD_PASSWORD,
        IDC_OLD_PASSWORD,       IDH_OLD_PASSWORD,
        IDC_STATIC2,            IDH_NEW_PASSWORD,
        IDC_PASSWORD,           IDH_NEW_PASSWORD,
        IDC_STATIC3,            IDH_CONFIRM_PASSWORD,
        IDC_CONFIRM_PASSWORD,   IDH_CONFIRM_PASSWORD,
        0,0
    };

    CHAR pszPassword[MAX_PATH];
    CHAR pszTempPassword[MAX_PATH];
    CHAR *p = NULL;
    HRESULT hRet;
    HWND hwndPassword;

    switch (uMsg) {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            return TRUE;    /* we didn't set the focus */

        case WM_COMMAND:
            switch (LOWORD(wParam))  {
            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                break;

            case IDOK:
                {
                    IUser *pUser = (IUser *)GetWindowLongPtr(hDlg, DWLP_USER);

                    hwndPassword = ::GetDlgItem(hDlg, IDC_PASSWORD);
                    GetWindowText(hwndPassword, pszPassword, sizeof(pszPassword));
                    GetDlgItemText(hDlg, IDC_CONFIRM_PASSWORD, pszTempPassword, sizeof(pszTempPassword));

                    /* if they've typed just the first password but not the
                     * second, let Enter take them to the second field
                     */
                    if (*pszPassword && !*pszTempPassword && GetFocus() == hwndPassword) {
                        SetErrorFocus(hDlg, IDC_CONFIRM_PASSWORD);
                        break;
                    }

                    if (strcmpf(pszPassword, pszTempPassword))
                    {
                        MsgBox(hDlg, IDS_NO_MATCH, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_CONFIRM_PASSWORD);
                        break;
                    }

                    GetDlgItemText(hDlg, IDC_OLD_PASSWORD, pszTempPassword, sizeof(pszTempPassword));
                    
                    hRet = pUser->ChangePassword(pszTempPassword, pszPassword);
                    
                    if (SUCCEEDED(hRet))
                        EndDialog(hDlg, TRUE);
                    else
                    {
                        MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_OLD_PASSWORD);
                    }
                    
                    break;
                }

            default:
                return FALSE;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)aIds);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


BOOL DoPasswordConfirm(HWND hwndParent, IUserDatabase *pDB)
{
    return (BOOL)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PASSWORD), hwndParent, PasswordDialogProc, (LPARAM)pDB);
}


const UINT MAX_PAGES = 1;

class CCPLData
{
public:
    IUserDatabase *m_pDB;
    LPCSTR m_pszNameToDelete;
};


void CPLUserSelected(HWND hwndLB, int iItem)
{
    HWND hDlg = GetParent(hwndLB);
    BOOL fEnableButtons = (iItem != LB_ERR);

    EnableWindow(GetDlgItem(hDlg, IDC_Delete), fEnableButtons);
    EnableWindow(GetDlgItem(hDlg, IDC_Clone), fEnableButtons);
    EnableWindow(GetDlgItem(hDlg, IDC_SetPassword), fEnableButtons);
    EnableWindow(GetDlgItem(hDlg, IDC_OpenProfileFolder), fEnableButtons);

    NLS_STR nlsTemp(MAX_RES_STR_LEN);

    if (fEnableButtons) {
        NLS_STR nlsName;
        if (SUCCEEDED(GetLBItemText(hDlg, IDC_USERNAME, iItem, &nlsName))) {
            const NLS_STR *apnls[] = { &nlsName, NULL };
            if (nlsTemp.LoadString(IDS_SETTINGS_FOR, apnls) != ERROR_SUCCESS)
                nlsTemp = szNULL;
        }
    }
    else {
        if (nlsTemp.LoadString(IDS_SELECTED_USER) != ERROR_SUCCESS)
            nlsTemp = szNULL;
    }
    if (nlsTemp.strlen())
        SetDlgItemText(hDlg, IDC_MAIN_CAPTION, nlsTemp.QueryPch());
}


void ReInitUserList(HWND hDlg, CCPLData *pcpld)
{
    HWND hwndLB = GetDlgItem(hDlg, IDC_USERNAME);

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0);
    DestroyUserList(hwndLB);
    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0);
    FillUserList(hwndLB, pcpld->m_pDB, NULL, FALSE, CPLUserSelected);
    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0);
    InvalidateRect(hwndLB, NULL, TRUE);
}


void DoCloneUser(HWND hDlg, CCPLData *pcpld, IUser *pUserToClone)
{
    DoAddUserWizard(hDlg, pcpld->m_pDB, FALSE, pUserToClone);

    ReInitUserList(hDlg, pcpld);
}


HRESULT DeleteProgressFunc(LPARAM lParam)
{
    CCPLData *pcpld = (CCPLData *)lParam;

    return pcpld->m_pDB->DeleteUser(pcpld->m_pszNameToDelete);
}


void DoDeleteUser(HWND hDlg, CCPLData *pcpld, int iItem)
{
    NLS_STR nlsName;
    if (FAILED(GetLBItemText(hDlg, IDC_USERNAME, iItem, &nlsName)))
        return;

    const NLS_STR *apnls[] = { &nlsName, NULL };
    if (MsgBox(hDlg, IDS_CONFIRM_DELETE_USER,
               MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
               apnls) == IDNO)
        return;

    pcpld->m_pszNameToDelete = nlsName.QueryPch();
    HRESULT hres = CallWithinProgressDialog(hDlg, IDD_DeleteProgress,
                                            DeleteProgressFunc, (LPARAM)pcpld);

    if (SUCCEEDED(hres)) {
        ReInitUserList(hDlg, pcpld);
    }
    else {
        ReportUserError(hDlg, hres);
    }
}


void DoSetPassword(HWND hDlg, CCPLData *pcpld, int iItem)
{
    /* Note, getting pUser this way does not automatically AddRef it */
    IUser *pUser = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);

    if (pUser != NULL) {
        pUser->AddRef();        /* extra AddRef for life of dialog */
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_CHANGE_PASSWORD), hDlg, ChangePasswordDialogProc, (LPARAM)pUser))
            MsgBox(hDlg, IDS_PASSWORD_CHANGED, MB_OK | MB_ICONINFORMATION);
        pUser->Release();       /* undo above AddRef */
    }
}


INT_PTR CALLBACK FoldersDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_CHECK_DESKTOP,      IDH_DESKTOP_NETHOOD,
        IDC_CHECK_STARTMENU,    IDH_START_MENU,
        IDC_CHECK_FAVORITES,    IDH_FAVORITES,
        IDC_CHECK_CACHE,        IDH_TEMP_FILES,
        IDC_CHECK_MYDOCS,       IDH_MY_DOCS,
        IDC_RADIO_EMPTY,        IDH_EMPTY_FOLDERS,
        IDC_RADIO_COPY,         IDH_EXISTING_FILES,
        0,0
    };

    switch(message)
    {
    case WM_COMMAND:
        switch (LOWORD(wParam))  {
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case IDOK:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

                pwd->m_fdwCloneFromDefault = IsDlgButtonChecked(hDlg, IDC_RADIO_EMPTY) ? 0 : 0xffffffff;
                pwd->m_fdwNewPerUserFolders = 0;
                if (IsDlgButtonChecked(hDlg, IDC_CHECK_DESKTOP))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_STARTMENU))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_FAVORITES))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_FAVORITES;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_FAVORITES);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_CACHE))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_CACHE;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_CACHE);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_MYDOCS))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_MYDOCS;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_MYDOCS);

                FinishChooseFolders(hDlg, pwd);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            InitFolderCheckboxes(hDlg, pwd);
            CheckRadioButton(hDlg, IDC_RADIO_COPY, IDC_RADIO_EMPTY, IDC_RADIO_COPY);
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)aIds);
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void DoOpenProfileFolder(HWND hDlg, CCPLData *pcpld, int iItem)
{
    /* Note, getting pUser this way does not automatically AddRef it */
    IUser *pUser = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);

#if 0   /* old code to launch Explorer on the user's profile dir */
    if (pUser != NULL) {
        CHAR szHomeDir[MAX_PATH];
        DWORD cbBuffer = sizeof(szHomeDir);

        if (SUCCEEDED(pUser->GetProfileDirectory(szHomeDir, &cbBuffer)) &&
            cbBuffer > 0) {
            TCHAR szArgs[MAX_PATH+4];
            lstrcpy(szArgs, "/e,");
            lstrcat(szArgs, szHomeDir);

            SHELLEXECUTEINFO ei;

            ei.lpFile          = "explorer.exe";
            ei.cbSize          = sizeof(SHELLEXECUTEINFO);
            ei.hwnd            = NULL;
            ei.lpVerb          = NULL;
            ei.lpParameters    = szArgs;
            ei.lpDirectory     = szHomeDir;
            ei.nShow           = SW_SHOWNORMAL;
            ei.fMask           = SEE_MASK_NOCLOSEPROCESS;

            if (ShellExecuteEx(&ei))
            {
                CloseHandle(ei.hProcess);
            }
        }
    }
#else

    if (pUser != NULL) {
        CWizData wd;
        wd.m_pDB = pcpld->m_pDB;
        wd.m_pUserToClone = pUser;
        pUser->AddRef();

        DialogBoxParam(::hInstance, MAKEINTRESOURCE(IDD_ChooseFolders), hDlg, 
                       FoldersDlgProc, (LPARAM)&wd);
    }

#endif
}


INT_PTR CALLBACK UserCPLDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static DWORD aIds[] = {
        IDC_USERNAME,           IDH_USERS_LIST,
        IDC_Add,                IDH_NEW_USER,
        IDC_Delete,             IDH_REMOVE_USER,
        IDC_Clone,              IDH_COPY_USER,
        IDC_SetPassword,        IDH_SET_PASSWORD,
        IDC_OpenProfileFolder,  IDH_CHANGE_DESKTOP,
        0,0
    };

    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                CPLUserSelected((HWND)lParam, iItem);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            PropSheet_CancelToClose(GetParent(hDlg));
            InitWizDataPtr(hDlg, lParam);
            CCPLData *pcpld = (CCPLData *)(((LPPROPSHEETPAGE)lParam)->lParam);
            FillUserList(GetDlgItem(hDlg, IDC_USERNAME), pcpld->m_pDB, NULL,
                         FALSE, CPLUserSelected);
        }
        break;

    case WM_DESTROY:
        DestroyUserList(GetDlgItem(hDlg, IDC_USERNAME));
        break;

    case WM_COMMAND:
        {
            CCPLData *pcpld = (CCPLData *)GetWindowLongPtr(hDlg, DWLP_USER);
            int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);

            switch (LOWORD(wParam)) {
            case IDC_USERNAME:
                if (HIWORD(wParam) == LBN_SELCHANGE) {
                    CPLUserSelected((HWND)lParam, iItem);
                }
                break;

            case IDC_Add:
                DoCloneUser(hDlg, pcpld, NULL);
                break;

            case IDC_Clone:
                {
                    if (iItem != LB_ERR) {
                        IUser *pUser = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);
                        DoCloneUser(hDlg, pcpld, pUser);
                    }
                }
                break;

            case IDC_Delete:
                DoDeleteUser(hDlg, pcpld, iItem);
                break;

            case IDC_SetPassword:
                DoSetPassword(hDlg, pcpld, iItem);
                break;

            case IDC_OpenProfileFolder:
                DoOpenProfileFolder(hDlg, pcpld, iItem);
                break;

            default:
                return FALSE;
            }   /* switch */
        }
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)aIds);
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


STDMETHODIMP CLUDatabase::UserCPL(HWND hwndParent)
{
    if (ProfileUIRestricted()) {
        ReportRestrictionError(hwndParent);
        return E_ACCESSDENIED;
    }

    CCPLData cpld;
    cpld.m_pDB = this;

    if (!UseUserProfiles() || FAILED(VerifySupervisorPassword(szNULL))) {
        return InstallWizard(hwndParent);
    }
    else {
        BOOL fContinue = TRUE;

        if (IsCurrentUserSupervisor(this) != S_OK) {
            fContinue = DoPasswordConfirm(hwndParent, this);
        }

        if (fContinue) {
            LPPROPSHEETHEADER ppsh;

            // Allocate the property sheet header
            //
            if ((ppsh = (LPPROPSHEETHEADER)LocalAlloc(LMEM_FIXED, sizeof(PROPSHEETHEADER)+
                        (MAX_PAGES * sizeof(HPROPSHEETPAGE)))) != NULL)
            {
                ppsh->dwSize     = sizeof(*ppsh);
                ppsh->dwFlags    = PSH_NOAPPLYNOW;
                ppsh->hwndParent = hwndParent;
                ppsh->hInstance  = ::hInstance;
                ppsh->pszCaption = (LPSTR)IDS_MSGTITLE;
                ppsh->nPages     = 0;
                ppsh->nStartPage = 0;
                ppsh->phpage     = (HPROPSHEETPAGE *)(ppsh+1);

                AddPage(ppsh, IDD_Users, UserCPLDlgProc, &cpld);

                PropertySheet(ppsh);

                LocalFree((HLOCAL)ppsh);
            }
        }
    }

    return NOERROR;
}


void DoUserCPL(HWND hwndParent)
{
    IUserDatabase *pDB = NULL;
    if (FAILED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB)))
        return;

    pDB->UserCPL(hwndParent);

    pDB->Release();
}


extern "C" void UserCPL(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow)
{
    DoUserCPL(hwndParent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\inc\regentry.h ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1991-1994                    **/
/***************************************************************************/


/****************************************************************************

regentry.h

Mar. 94		JimH
Mar. 94     LenS    Added NLS_STR form of GetStringValue
Mar. 94     LenS    Added MoveToSubKey
Mar. 94     LenS    Added RegEnumValues class
Mar. 94     LenS    Added NPMachineEntries class

hard tabs at 4

Wrapper for registry access


Construct a RegEntry object by specifying the subkey (under
HKEY_CURRENT_USER by default, but can be overridden.)

All member functions are inline so there is minimal overhead.

All member functions (except the destructor) set an internal
error state which can be retrieved with GetError().
Zero indicates no error.

RegEntry works only with strings and DWORDS which are both set
using the overloaded function SetValue()

	SetValue("valuename", "string");
	SetValue("valuename", 42);
	
Values are retrieved with GetString() and GetNumber().  GetNumber()
allows you to specificy a default if the valuename doesn't exist.

DeleteValue() removes the valuename and value pair.

****************************************************************************/

#ifndef	REGENTRY_INC
#define	REGENTRY_INC

#ifndef STRICT
#define STRICT
#endif

#include <windows.h>
#include <npstring.h>


class RegEntry
{
	public:
		RegEntry(const char *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
		~RegEntry();
		
		long	GetError()	{ return _error; }
		long	SetValue(const char *pszValue, const char *string);
		long	SetValue(const char *pszValue, unsigned long dwNumber);
		char *	GetString(const char *pszValue, char *string, unsigned long length);
		VOID    GetValue(const char *pszValueName, NLS_STR *pnlsString);
		long	GetNumber(const char *pszValue, long dwDefault = 0);
		long	DeleteValue(const char *pszValue);
		long	FlushKey();
        VOID    MoveToSubKey(const char *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

	private:
		HKEY	_hkey;
		long	_error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
	public:
		RegEnumValues(RegEntry *pRegEntry);
		~RegEnumValues();
		long	Next();
		char *	GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}

	private:
        RegEntry * pRegEntry;
		DWORD   iEnum;
        DWORD   cEntries;
		CHAR *  pchName;
		LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

class NPMachineEntries : public RegEntry
{
    public:
		NPMachineEntries(const char *pszSectionName);
        const char * GetSectionName() { return pszSectionName; }

    private:
        const char * pszSectionName; // Warning: data not copied into object.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\mslocusr.h ===
//#define DBCS

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <regstr.h>
#define WIN31
#include "pwlapi.h"

#include <string.h>
#include <netlib.h>

#ifdef DEBUG
#define SAVE_DEBUG
#undef DEBUG
#endif

#include <npstring.h>
#include <npdefs.h>
#define _COMCTL32_                      // We delay-load Comctl32
#include <prsht.h>

#ifdef SAVE_DEBUG
#define DEBUG
#endif

#include <ole2.h>
#include "msluguid.h"

#include "msluapi.h"

void Netlib_EnterCriticalSection(void);
void Netlib_LeaveCriticalSection(void);
#ifdef DEBUG
extern BOOL g_fCritical;
#endif
#define ENTERCRITICAL   Netlib_EnterCriticalSection();
#define LEAVECRITICAL   Netlib_LeaveCriticalSection();
#define ASSERTCRITICAL  ASSERT(g_fCritical);

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))

extern "C" {
HRESULT VerifySupervisorPassword(LPCSTR pszPassword);
HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword);
};

const UINT cchMaxUsername = 128;

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern void LockThisDLL(BOOL fLock);
extern void RefThisDLL(BOOL fRef);

extern void UnloadShellEntrypoint(void);
extern void CleanupWinINet(void);

UINT NPSCopyNLS (NLS_STR FAR *pnlsSourceString, LPVOID lpDestBuffer, LPDWORD lpBufferSize);

extern APIERR MakeSupervisor(HPWL hPWL, LPCSTR pszSupervisorPassword);

HRESULT GetSystemCurrentUser(NLS_STR *pnlsCurrentUser);
HRESULT GetUserPasswordCache(LPCSTR pszUsername, LPCSTR pszPassword, LPHANDLE phOut, BOOL fCreate);

typedef void (*PFNSELNOTIFY)(HWND hwndLB, int iSel);
HRESULT FillUserList(HWND hwndLB, IUserDatabase *pDB, LPCSTR pszDefaultSelection,
                     BOOL fIncludeGuest, PFNSELNOTIFY pfnSelNotify);
void DestroyUserList(HWND hwndLB);
void AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn, LPVOID pwd);
void InitWizDataPtr(HWND hDlg, LPARAM lParam);
void InsertControlText(HWND hDlg, UINT idCtrl, const NLS_STR *pnlsInsert);
HRESULT GetControlText(HWND hDlg, UINT idCtrl, NLS_STR *pnls);
HRESULT DoAddUserWizard(HWND hwndParent, IUserDatabase *pDB,
                        BOOL fPickUserPage, IUser *pUserToClone);
BOOL InstallLogonDialog(void);
void DeinstallLogonDialog(void);

HRESULT DoUserDialog(HWND hwndOwner, DWORD dwFlags, IUser **ppOut);
void CacheLogonCredentials(LPCSTR pszUsername, LPCSTR pszPassword);

void ReportUserError(HWND hwndOwner, HRESULT hres);
void SetErrorFocus(HWND hDlg, UINT idCtrl, BOOL fClear = TRUE);

class CLUClassFactory : public IClassFactory
{
public:
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
	STDMETHODIMP LockServer( 
            /* [in] */ BOOL fLock);
};


HRESULT CreateUserDatabase(REFIID riid, void **ppOut);

class CLUUser;
class BUFFER;

class CLUDatabase : public IUserDatabase
{
//friend class CLUClassFactory;
friend HRESULT CreateUserDatabase(REFIID riid, void **ppOut);

private:
	ULONG m_cRef;
	CLUUser *m_CurrentUser;

	CLUDatabase();
	~CLUDatabase();

	STDMETHODIMP CreateUser(LPCSTR pszName, IUser *pCloneFrom,
	                        BOOL fFixInstallStubs, IUserProfileInit *pInit);

public:
	// *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP Install(LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
						 LPCSTR pszRatingsPassword, IUserProfileInit *pInit);

	STDMETHODIMP AddUser(LPCSTR pszName, IUser *pSourceUser,
	                     IUserProfileInit *pInit, IUser **ppOut);
	STDMETHODIMP GetUser(LPCSTR pszName, IUser **ppOut);
	STDMETHODIMP GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut);
	STDMETHODIMP GetCurrentUser(IUser **ppOut);
	STDMETHODIMP SetCurrentUser(IUser *pUser);
	STDMETHODIMP DeleteUser(LPCSTR pszName);
	STDMETHODIMP RenameUser(LPCSTR pszOldName, LPCSTR pszNewName);
	STDMETHODIMP EnumUsers(IEnumUnknown **ppOut);

	STDMETHODIMP Authenticate(HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut);

	STDMETHODIMP InstallComponent(REFCLSID clsidComponent, LPCSTR pszName,
								 DWORD dwFlags);
	STDMETHODIMP RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName);
    STDMETHODIMP InstallWizard(HWND hwndParent);
    STDMETHODIMP AddUserWizard(HWND hwndParent);
    STDMETHODIMP UserCPL(HWND hwndParent);
};


class CLUUser : public IUser
{
friend class CLUDatabase;
friend class CLUEnum;

private:
	NLS_STR m_nlsUsername;
	NLS_STR m_nlsDir;
	NLS_STR m_nlsPassword;
	BOOL m_fAuthenticated;
    BOOL m_fTempSupervisor;
	HKEY m_hkeyDB;
	HKEY m_hkeyUser;
	BOOL m_fUserExists;
	BOOL m_fAppearsSupervisor;
    BOOL m_fLoadedProfile;
	ULONG m_cRef;

	CLUDatabase *m_pDB;

	CLUUser(CLUDatabase *m_pDB);
	~CLUUser();
	HRESULT Init(LPCSTR pszUsername);

	BOOL Exists() { return m_fUserExists; }
	HRESULT GetSupervisorPassword(BUFFER *pbufPCE);
    BOOL IsSystemCurrentUser(void);

public: 
	// *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP GetName(LPSTR pbBuffer, LPDWORD pcbBuffer);
	STDMETHODIMP GetProfileDirectory(LPSTR pbBuffer, LPDWORD pcbBuffer);

	STDMETHODIMP IsSupervisor(void);
	STDMETHODIMP SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword);
	STDMETHODIMP MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword);
	STDMETHODIMP AppearsSupervisor(void);

	STDMETHODIMP Authenticate(LPCSTR pszPassword);
	STDMETHODIMP ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword);
	STDMETHODIMP GetPasswordCache(LPCSTR pszPassword, LPHANDLE phOut);

    STDMETHODIMP LoadProfile(HKEY *phkeyUser);
    STDMETHODIMP UnloadProfile(HKEY hkeyUser);

	STDMETHODIMP GetComponentSettings(REFCLSID clsidComponent,
									  LPCSTR pszName, IUnknown **ppOut,
									  DWORD fdwAccess);
	STDMETHODIMP EnumerateComponentSettings(IEnumUnknown **ppOut,
										    DWORD fdwAccess);
};


class CLUEnum : public IEnumUnknown
{
friend class CLUDatabase;

private:
	ULONG m_cRef;
	HKEY m_hkeyDB;
	LPSTR *m_papszNames;
	UINT m_cNames;
	UINT m_cAlloc;
	UINT m_iCurrent;

	CLUDatabase *m_pDB;

	CLUEnum(CLUDatabase *m_pDB);
	~CLUEnum();
	HRESULT Init(void);
	void Cleanup(void);

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP Next(ULONG celt, IUnknown __RPC_FAR *__RPC_FAR *rgelt,
					  ULONG __RPC_FAR *pceltFetched);
	STDMETHODIMP Skip(ULONG celt);
	STDMETHODIMP Reset(void);
	STDMETHODIMP Clone(IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);
};


#ifdef USER_SETTINGS_IMPLEMENTED

class CUserSettings : public IUserSettings
{
private:
	ULONG m_cRef;
	CLSID m_clsid;
	NLS_STR m_nlsName;
	HKEY m_hkey;

	CUserSettings();
	~CUserSettings();

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	STDMETHODIMP GetCLSID(CLSID *pclsidOut);
	STDMETHODIMP GetName(LPSTR pbBuffer, LPDWORD pcbBuffer);
	STDMETHODIMP GetDisplayName(LPSTR pbBuffer, LPDWORD pcbBuffer);

	STDMETHODIMP QueryKey(HKEY *phkeyOut);
};

#endif

class CWizData : public IUserProfileInit
{
public:
    HRESULT m_hresRatings;          /* result of VerifySupervisorPassword("") */
    BOOL m_fGoMultiWizard;          /* TRUE if this is the big go-multiuser wizard */
    NLS_STR m_nlsSupervisorPassword;
    NLS_STR m_nlsUsername;
    NLS_STR m_nlsUserPassword;
    IUserDatabase *m_pDB;
    IUser *m_pUserToClone;
    int m_idPrevPage;               /* ID of page before Finish */
    UINT m_cRef;
    DWORD m_fdwOriginalPerUserFolders;
    DWORD m_fdwNewPerUserFolders;
    DWORD m_fdwCloneFromDefault;
    BOOL m_fCreatingProfile;
    IUser *m_pNewUser;
    BOOL m_fChannelHack;

    CWizData();
    ~CWizData();

	// *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
    STDMETHODIMP PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
};

void InitFolderCheckboxes(HWND hDlg, CWizData *pwd);
void FinishChooseFolders(HWND hDlg, CWizData *pwd);

BOOL ProfileUIRestricted(void);
void ReportRestrictionError(HWND hwndOwner);

typedef HRESULT (*PFNPROGRESS)(LPARAM lParam);
HRESULT CallWithinProgressDialog(HWND hwndOwner, UINT idResource, PFNPROGRESS pfn,
                                 LPARAM lParam);


HRESULT IsCurrentUserSupervisor(IUserDatabase *pDB);


/* NOTE: Keep the following flags in the same order as the corresponding
 * entries in the folder descriptor table in msluwiz.cpp.
 */
const DWORD FOLDER_DESKTOP   = 0x00000001;
const DWORD FOLDER_NETHOOD   = 0x00000002;
const DWORD FOLDER_RECENT    = 0x00000004;
const DWORD FOLDER_STARTMENU = 0x00000008;
const DWORD FOLDER_PROGRAMS  = 0x00000010;
const DWORD FOLDER_STARTUP   = 0x00000020;
const DWORD FOLDER_FAVORITES = 0x00000040;
const DWORD FOLDER_CACHE     = 0x00000080;
const DWORD FOLDER_MYDOCS    = 0x00000100;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msludb.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include "profiles.h"

#include <regentry.h>

#include <ole2.h>

CLUDatabase::CLUDatabase(void)
	: m_cRef(0),
	  m_CurrentUser(NULL)
{
    RefThisDLL(TRUE);
}


CLUDatabase::~CLUDatabase(void)
{
	if (m_CurrentUser != NULL) {
		m_CurrentUser->Release();
		m_CurrentUser = NULL;
	}
    RefThisDLL(FALSE);
}


STDMETHODIMP CLUDatabase::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IUserDatabase)) {
        *ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CLUDatabase::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CLUDatabase::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}
	/* Handle circular refcount because of cached current user object. */
	else if (1L == m_cRef && m_CurrentUser != NULL) {
		IUser *pCurrentUser = m_CurrentUser;
		m_CurrentUser = NULL;
		pCurrentUser->Release();
	}

	return cRef;
}


STDMETHODIMP CLUDatabase::Install(LPCSTR pszSupervisorName,
								  LPCSTR pszSupervisorPassword,
								  LPCSTR pszRatingsPassword,
								  IUserProfileInit *pInit)
{
	/* If the system already has a supervisor password, make sure the caller's
	 * password matches.  If there isn't already a password, the caller's
	 * (account) password is it.  We use the account password because the
	 * caller (the setup program) probably didn't pass us a ratings password
	 * in that case -- he also checks to see if there's an old ratings
	 * password and knows to prompt for one only if it's already there.
	 */
	HRESULT hres = ::VerifySupervisorPassword(pszRatingsPassword);
	
	if (FAILED(hres)) {
        if (pszRatingsPassword == NULL)
    		pszRatingsPassword = pszSupervisorPassword;
		::ChangeSupervisorPassword(::szNULL, pszRatingsPassword);
	}
	else if (hres == S_FALSE)
		return E_ACCESSDENIED;


	/* User profiles and password caching have to be enabled for us to work.
	 * We also have to be able to open or create the supervisor's PWL using
	 * the given password.  Thus we validate the password at the same time.
	 */

	{
		RegEntry re(::szLogonKey, HKEY_LOCAL_MACHINE);
		if (re.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(re.GetError());
		if (!re.GetNumber(::szUserProfiles))
			re.SetValue(::szUserProfiles, 1);
		if (re.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(re.GetError());
	}

    /* Make copies of the username and password for passing to the PWL APIs.
     * They need to be in OEM (PWL is accessible from DOS), and must be upper
     * case since the Windows logon dialog uppercases all PWL passwords.
     */
    NLS_STR nlsPWLName(pszSupervisorName);
    NLS_STR nlsPWLPassword(pszSupervisorPassword);
    if (nlsPWLName.QueryError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(nlsPWLName.QueryError());
    if (nlsPWLPassword.QueryError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(nlsPWLPassword.QueryError());
    nlsPWLName.strupr();
    nlsPWLName.ToOEM();
    nlsPWLPassword.strupr();
    nlsPWLPassword.ToOEM();

	HPWL hPWL = NULL;
	APIERR err = ::OpenPasswordCache(&hPWL, nlsPWLName.QueryPch(),
									 nlsPWLPassword.QueryPch(), TRUE);

	if (err != ERROR_SUCCESS) {
        if (err != IERR_IncorrectUsername)
    		err = ::CreatePasswordCache(&hPWL, nlsPWLName.QueryPch(), nlsPWLPassword.QueryPch());
		if (err != ERROR_SUCCESS)	
			return HRESULT_FROM_WIN32(err);
	}


	/* Now that the system has a supervisor password, call a worker function
	 * to clone the supervisor account from the default profile.  The worker
	 * function assumes that the caller has validated that the current user is
	 * a supervisor.
	 */

	err = ::MakeSupervisor(hPWL, pszRatingsPassword);
	::ClosePasswordCache(hPWL, TRUE);
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	IUser *pSupervisor = NULL;
    hres = GetUser(pszSupervisorName, &pSupervisor);
	if (FAILED(hres)) {
		hres = CreateUser(pszSupervisorName, NULL, TRUE, pInit);
		if (pSupervisor != NULL) {
			pSupervisor->Release();
			pSupervisor = NULL;
		}
		if (SUCCEEDED(hres))
			hres = GetUser(pszSupervisorName, &pSupervisor);	/* reinitialize with created profile */
	}

	if (pSupervisor != NULL) {
		if (SUCCEEDED(hres))
			hres = pSupervisor->Authenticate(pszSupervisorPassword);
		if (SUCCEEDED(hres))
			hres = SetCurrentUser(pSupervisor);
        if (SUCCEEDED(hres))
            pSupervisor->SetSupervisorPrivilege(TRUE, pszRatingsPassword);  /* set appears-supervisor flag */

		pSupervisor->Release();
		pSupervisor = NULL;
	}

	return hres;
}


/* Some install stubs are "clone-user" install stubs, that get re-run if a
 * profile is cloned to become a new user's profile.  For example, if you
 * clone Fred to make Barney, Outlook Express doesn't want Barney to inherit
 * Fred's mailbox.
 *
 * When you run the go-multiuser wizard, we assume that the first user being
 * created is the one who's been using the machine all along, so that one
 * copy should be exempt from this.  So we go through all the install stub
 * keys for the newly created profile and, for any that are marked with a
 * username (even a blank one indicates that it's a clone-user install stub),
 * we mark it with the new username so it won't get re-run.
 */
void FixInstallStubs(LPCSTR pszName, HKEY hkeyProfile)
{
    HKEY hkeyList;
    LONG err = RegOpenKeyEx(hkeyProfile, "Software\\Microsoft\\Active Setup\\Installed Components", 0,
                            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hkeyList);

    if (err == ERROR_SUCCESS) {
        DWORD cbKeyName, iKey;
        TCHAR szKeyName[80];

        /* Enumerate components that are installed for the profile. */
        for (iKey = 0; ; iKey++)
        {
            LONG lEnum;

            cbKeyName = ARRAYSIZE(szKeyName);

            if ((lEnum = RegEnumKey(hkeyList, iKey, szKeyName, cbKeyName)) == ERROR_MORE_DATA)
            {
                // ERROR_MORE_DATA means the value name or data was too large
                // skip to the next item
                continue;
            }
            else if( lEnum != ERROR_SUCCESS )
            {
                // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
                // we can't recover from any other registry problem, anyway
                break;
            }

            HKEY hkeyComponent;
            if (RegOpenKeyEx(hkeyList, szKeyName, 0,
                             KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyComponent) == ERROR_SUCCESS) {
                cbKeyName = sizeof(szKeyName);
                err = RegQueryValueEx(hkeyComponent, "Username", NULL, NULL,
                                      (LPBYTE)szKeyName, &cbKeyName);
                if (err == ERROR_SUCCESS || err == ERROR_MORE_DATA) {
                    RegSetValueEx(hkeyComponent, "Username",
                                  0, REG_SZ,
                                  (LPBYTE)pszName,
                                  lstrlen(pszName)+1);
                }
                RegCloseKey(hkeyComponent);
            }
        }
        RegCloseKey(hkeyList);
    }
}


STDMETHODIMP CLUDatabase::CreateUser(LPCSTR pszName, IUser *pCloneFrom,
                                     BOOL fFixInstallStubs, IUserProfileInit *pInit)
{
    if (::strlenf(pszName) > cchMaxUsername)
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);

	RegEntry reRoot(::szProfileList, HKEY_LOCAL_MACHINE);
	if (reRoot.GetError() != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(reRoot.GetError());

	/* See if the user's subkey exists.  If it doesn't, create it. */
	reRoot.MoveToSubKey(pszName);
	if (reRoot.GetError() != ERROR_SUCCESS) {
		RegEntry reUser(pszName, reRoot.GetKey());
		if (reUser.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(reUser.GetError());

		reRoot.MoveToSubKey(pszName);
		if (reRoot.GetError() != ERROR_SUCCESS)
			return HRESULT_FROM_WIN32(reRoot.GetError());
	}

	NLS_STR nlsProfilePath(MAX_PATH);
	if (nlsProfilePath.QueryError() != ERROR_SUCCESS)
		return E_OUTOFMEMORY;

	reRoot.GetValue(::szProfileImagePath, &nlsProfilePath);

	/* If the profile path is already recorded for the user, see if the
	 * profile itself exists.  If it does, then CreateUser is an error.
	 */
	BOOL fComputePath = FALSE;

	if (reRoot.GetError() == ERROR_SUCCESS) {
		if (!DirExists(nlsProfilePath.QueryPch())) {
			if (!::CreateDirectory(nlsProfilePath.QueryPch(), NULL)) {
				fComputePath = TRUE;
			}
		}
	}
	else {
		fComputePath = TRUE;
	}

	if (fComputePath) {
		ComputeLocalProfileName(pszName, &nlsProfilePath);
		reRoot.SetValue(::szProfileImagePath, nlsProfilePath.QueryPch());
	}

	AddBackslash(nlsProfilePath);
	nlsProfilePath.strcat(::szStdNormalProfile);
	if (FileExists(nlsProfilePath.QueryPch()))
		return HRESULT_FROM_WIN32(ERROR_USER_EXISTS);

	/* The user's profile directory now exists, and its path is recorded
	 * in the registry.  nlsProfilePath is now the full pathname for the
	 * user's profile file, which does not exist yet.
	 */

	NLS_STR nlsOtherProfilePath(MAX_PATH);
	if (nlsOtherProfilePath.QueryError() != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(nlsOtherProfilePath.QueryError());

	HRESULT hres;
	DWORD cbPath = nlsOtherProfilePath.QueryAllocSize();
	if (pCloneFrom == NULL ||
		FAILED(pCloneFrom->GetProfileDirectory(nlsOtherProfilePath.Party(), &cbPath)))
	{
		/* Cloning default profile. */

		hres = GiveUserDefaultProfile(nlsProfilePath.QueryPch());
        nlsOtherProfilePath.DonePartying();
        nlsOtherProfilePath = "";
	}
	else {
		/* Cloning other user's profile. */
        nlsOtherProfilePath.DonePartying();
		AddBackslash(nlsOtherProfilePath);
		nlsOtherProfilePath.strcat(::szStdNormalProfile);
		hres = CopyProfile(nlsOtherProfilePath.QueryPch(), nlsProfilePath.QueryPch());
	}

	if (FAILED(hres))
		return hres;

	/* Now the user has a profile.  Load it and perform directory
	 * reconciliation.
	 */

	LONG err = ::MyRegLoadKey(HKEY_USERS, pszName, nlsProfilePath.QueryPch());
	if (err == ERROR_SUCCESS) {
		HKEY hkeyNewProfile;
		err = ::RegOpenKey(HKEY_USERS, pszName, &hkeyNewProfile);
		if (err == ERROR_SUCCESS) {

            /* Build just the profile directory, no "user.dat" on the end. */
        	ISTR istrBackslash(nlsProfilePath);
	        if (nlsProfilePath.strrchr(&istrBackslash, '\\')) {
                ++istrBackslash;
		        nlsProfilePath.DelSubStr(istrBackslash);
            }

            if (pInit != NULL) {
                hres = pInit->PreInitProfile(hkeyNewProfile, nlsProfilePath.QueryPch());
                if (hres == E_NOTIMPL)
                    hres = S_OK;
            }
            else
                hres = S_OK;

            if (SUCCEEDED(hres)) {
    			err = ReconcileFiles(hkeyNewProfile, nlsProfilePath, nlsOtherProfilePath);	/* modifies nlsProfilePath */
                hres = HRESULT_FROM_WIN32(err);

                if (fFixInstallStubs) {
                    ::FixInstallStubs(pszName, hkeyNewProfile);
                }

                if (pInit != NULL) {
                    hres = pInit->PostInitProfile(hkeyNewProfile, nlsProfilePath.QueryPch());
                    if (hres == E_NOTIMPL)
                        hres = S_OK;
                }
            }
			::RegFlushKey(hkeyNewProfile);
			::RegCloseKey(hkeyNewProfile);
		}
		::RegUnLoadKey(HKEY_USERS, pszName);
	}

	return hres;
}


STDMETHODIMP CLUDatabase::AddUser(LPCSTR pszName, IUser *pSourceUser,
                                  IUserProfileInit *pInit, IUser **ppOut)
{
	if (ppOut != NULL)
		*ppOut = NULL;

    if (IsCurrentUserSupervisor(this) != S_OK)
		return E_ACCESSDENIED;

	HRESULT hres = CreateUser(pszName, pSourceUser, FALSE, pInit);
	if (FAILED(hres))
		return hres;

	if (ppOut != NULL)
		hres = GetUser(pszName, ppOut);

	return hres;
}


STDMETHODIMP CLUDatabase::GetUser(LPCSTR pszName, IUser **ppOut)
{
	*ppOut = NULL;

	CLUUser *pUser = new CLUUser(this);

	if (pUser == NULL) {
		return ResultFromScode(E_OUTOFMEMORY);
	}

	HRESULT err = pUser->Init(pszName);
	if (SUCCEEDED(err) && !pUser->Exists()) {
		err = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
	}

	if (FAILED(err) || !pUser->Exists()) {
		pUser->Release();
		return err;
	}

	*ppOut = pUser;

	return NOERROR;
}


STDMETHODIMP CLUDatabase::GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut)
{
	switch (nSpecialUserCode) {
	case GSU_CURRENT:
		return GetCurrentUser(ppOut);
		break;

	case GSU_DEFAULT:
		return GetUser(szDefaultUserName, ppOut);
		break;

	default:
		return ResultFromScode(E_INVALIDARG);
	};

	return NOERROR;
}


HRESULT GetSystemCurrentUser(NLS_STR *pnlsCurrentUser)
{
	DWORD cbBuffer = pnlsCurrentUser->QueryAllocSize();
	UINT err;
	if (!::GetUserName(pnlsCurrentUser->Party(), &cbBuffer))
		err = ::GetLastError();
	else
		err = NOERROR;
	pnlsCurrentUser->DonePartying();

	return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CLUDatabase::GetCurrentUser(IUser **ppOut)
{
	if (m_CurrentUser == NULL) {
		NLS_STR nlsCurrentUser(cchMaxUsername+1);
		UINT err = nlsCurrentUser.QueryError();
		if (err)
			return HRESULT_FROM_WIN32(err);

		HRESULT hres = GetSystemCurrentUser(&nlsCurrentUser);
		if (FAILED(hres))
			return hres;

		hres = GetUser(nlsCurrentUser.QueryPch(), (IUser **)&m_CurrentUser);
		if (FAILED(hres))
			return hres;
	}

	*ppOut = m_CurrentUser;
	m_CurrentUser->AddRef();

	return NOERROR;
}


STDMETHODIMP CLUDatabase::SetCurrentUser(IUser *pUser)
{
	CLUUser *pCLUUser = (CLUUser *)pUser;
	HPWL hpwlUser;
	if (!pCLUUser->m_fAuthenticated ||
		FAILED(pCLUUser->GetPasswordCache(pCLUUser->m_nlsPassword.QueryPch(), &hpwlUser)))
	{
		return HRESULT_FROM_WIN32(ERROR_NOT_AUTHENTICATED);
	}
	::ClosePasswordCache(hpwlUser, TRUE);

	CLUUser *pClone;

	HRESULT hres = GetUser(pCLUUser->m_nlsUsername.QueryPch(), (IUser **)&pClone);
	if (FAILED(hres))
		return hres;

	/* Make sure the clone object is authenticated properly. */
	hres = pClone->Authenticate(pCLUUser->m_nlsPassword.QueryPch());
	if (FAILED(hres)) {
		return HRESULT_FROM_WIN32(ERROR_NOT_AUTHENTICATED);
	}

	if (m_CurrentUser != NULL) {
		m_CurrentUser->Release();
	}

	m_CurrentUser = pClone;
	return NOERROR;
}


STDMETHODIMP CLUDatabase::DeleteUser(LPCSTR pszName)
{
	NLS_STR nlsName(MAX_PATH);
	if (nlsName.QueryError() != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(nlsName.QueryError());

    /* Check supervisor privilege up front, this'll handle the not-logged-on
     * case later if we re-enable supervisor stuff.
     */
    if (IsCurrentUserSupervisor(this) != S_OK)
        return E_ACCESSDENIED;

	IUser *pCurrentUser;

    HRESULT hres = GetCurrentUser(&pCurrentUser);
    if (SUCCEEDED(hres)) {

    	/* Check current user's name and make sure we're not deleting him.
    	 * Note that because the current user must be an authenticated supervisor,
    	 * and you can't delete the current user, you can never delete the last
    	 * supervisor using this function.
    	 */
    	DWORD cb = nlsName.QueryAllocSize();
    	hres = pCurrentUser->GetName(nlsName.Party(), &cb);
    	nlsName.DonePartying();
    	if (SUCCEEDED(hres) && !::stricmpf(pszName, nlsName.QueryPch()))
            hres = HRESULT_FROM_WIN32(ERROR_BUSY);

    	if (FAILED(hres))
            return hres;
    }

    /* Check system's idea of current user as well. */

    hres = GetSystemCurrentUser(&nlsName);
    if (SUCCEEDED(hres)) {
        if (!::stricmpf(pszName, nlsName.QueryPch()))
            return HRESULT_FROM_WIN32(ERROR_BUSY);
    }

    return DeleteProfile(pszName);
}


STDMETHODIMP CLUDatabase::RenameUser(LPCSTR pszOldName, LPCSTR pszNewName)
{
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CLUDatabase::EnumUsers(IEnumUnknown **ppOut)
{
	*ppOut = NULL;

	CLUEnum *pEnum = new CLUEnum(this);

	if (pEnum == NULL) {
		return ResultFromScode(E_OUTOFMEMORY);
	}

	HRESULT err = pEnum->Init();
	if (FAILED(err)) {
		pEnum->Release();
		return err;
	}

	*ppOut = pEnum;

	return NOERROR;
}



STDMETHODIMP CLUDatabase::Authenticate(HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut)
{
	if (dwFlags & LUA_DIALOG) {
        if (!UseUserProfiles() || FAILED(VerifySupervisorPassword(szNULL))) {
            return InstallWizard(hwndOwner);
        }
        return ::DoUserDialog(hwndOwner, dwFlags, ppOut);
	}

	/* Null out return pointer for error cases. */
	if (ppOut != NULL)
		*ppOut = NULL;

	IUser *pUser;
	BOOL fReleaseMe = TRUE;

	HRESULT hres = GetUser(pszName, &pUser);
	if (SUCCEEDED(hres)) {
		hres = pUser->Authenticate(pszPassword);
		if (SUCCEEDED(hres)) {
			if ((dwFlags & LUA_SUPERVISORONLY) && (pUser->IsSupervisor() != S_OK)) {
				hres = E_ACCESSDENIED;
			}
			else if (ppOut != NULL) {
				*ppOut = pUser;
				fReleaseMe = FALSE;
			}
		}
		if (fReleaseMe)
			pUser->Release();
	}
	return hres;
}


STDMETHODIMP CLUDatabase::InstallComponent(REFCLSID clsidComponent,
										   LPCSTR pszName, DWORD dwFlags)
{
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CLUDatabase::RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName)
{
	return ResultFromScode(E_NOTIMPL);
}


#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD

HRESULT IsCurrentUserSupervisor(IUserDatabase *pDB)
{
    IUser *pCurrentUser = NULL;

    HRESULT hres = pDB->GetCurrentUser(&pCurrentUser);
    if (SUCCEEDED(hres)) {
        hres = pCurrentUser->IsSupervisor();
    }
    if (pCurrentUser != NULL) {
        pCurrentUser->Release();
    }
    return hres;
}
#else
HRESULT IsCurrentUserSupervisor(IUserDatabase *pDB) { return S_OK; }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msluenum.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include <ole2.h>

CLUEnum::CLUEnum(CLUDatabase *pDB)
	: m_cRef(1),
	  m_hkeyDB(NULL),
	  m_papszNames(NULL),
	  m_cNames(0),
	  m_cAlloc(0),
	  m_iCurrent(0),
	  m_pDB(pDB)
{
	m_pDB->AddRef();
    RefThisDLL(TRUE);
}


CLUEnum::~CLUEnum(void)
{
	Cleanup();
	if (m_pDB != NULL)
		m_pDB->Release();
    RefThisDLL(FALSE);
}


#define cpPerAlloc 16		/* allocate 16 pointers at a go */
HRESULT CLUEnum::Init(void)
{
	UINT err = (UINT)RegOpenKey(HKEY_LOCAL_MACHINE, ::szProfileList, &m_hkeyDB);
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	m_papszNames = (LPSTR *)::MemAlloc(cpPerAlloc * sizeof(LPCSTR));	/* not "new", so we can realloc */
	if (m_papszNames == NULL)
		return ResultFromScode(E_OUTOFMEMORY);
	m_cAlloc = cpPerAlloc;

	NLS_STR nlsTempName(cchMaxUsername+1);

	err = nlsTempName.QueryError();
	if (err)
		return HRESULT_FROM_WIN32(err);

	for (DWORD iSubkey=0; err == ERROR_SUCCESS; iSubkey++) {
		DWORD cbBuffer = nlsTempName.QueryAllocSize();
		err = (UINT)RegEnumKey(m_hkeyDB, iSubkey, nlsTempName.Party(), cbBuffer);
		nlsTempName.DonePartying();		
		if (err == ERROR_SUCCESS) {
			if (m_cNames == m_cAlloc) {
				LPSTR *pNew = (LPSTR *)::MemReAlloc(m_papszNames, (m_cAlloc + cpPerAlloc) * sizeof(LPCSTR));
				if (pNew == NULL) {
					err = ERROR_NOT_ENOUGH_MEMORY;
					break;
				}
				m_cAlloc += cpPerAlloc;
				m_papszNames = pNew;
			}
			LPSTR pszNewName = new char[nlsTempName.strlen()+1];
			if (pszNewName == NULL) {
				err = ERROR_NOT_ENOUGH_MEMORY;
				break;
			}
			::strcpyf(pszNewName, nlsTempName.QueryPch());
			m_papszNames[m_cNames++] = pszNewName;
		}
	}

	return NOERROR;
}


void CLUEnum::Cleanup(void)
{
	if (m_hkeyDB != NULL) {
		RegCloseKey(m_hkeyDB);
		m_hkeyDB = NULL;
	}

	if (m_papszNames != NULL) {
		for (UINT i=0; i<m_cNames; i++) {
			delete m_papszNames[i];
		}
		::MemFree(m_papszNames);
		m_papszNames = NULL;
		m_cNames = 0;
	}
}


STDMETHODIMP CLUEnum::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IEnumUnknown)) {
        *ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CLUEnum::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CLUEnum::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}

	return cRef;
}


STDMETHODIMP CLUEnum::Next(ULONG celt, IUnknown __RPC_FAR *__RPC_FAR *rgelt,
						   ULONG __RPC_FAR *pceltFetched)
{
	ULONG celtFetched = 0;
	HRESULT hres = ResultFromScode(S_OK);

	while (celt) {
		if (m_iCurrent == m_cNames) {
			hres = ResultFromScode(S_FALSE);
			break;
		}

		CLUUser *pUser = new CLUUser(m_pDB);
		if (pUser == NULL) {
			hres = ResultFromScode(E_OUTOFMEMORY);
		}
		else {
			hres = pUser->Init(m_papszNames[m_iCurrent]);
		}
		if (FAILED(hres)) {
			for (ULONG i=0; i<celtFetched; i++) {
				rgelt[i]->Release();
			}
			celtFetched = 0;
			if (pUser != NULL)
				pUser->Release();
			break;
		}

		m_iCurrent++;

        /* If this is a name without a real profile attached, don't return
         * it, just go on to the next one.  Advancing m_iCurrent (the index
         * into the name array) above ensures that we won't infinite-loop.
         */
        if (!pUser->Exists()) {
            pUser->Release();
            continue;
        }

		rgelt[celtFetched++] = pUser;
		celt--;
	}

	if (pceltFetched != NULL)
		*pceltFetched = celtFetched;

	return hres;
}


STDMETHODIMP CLUEnum::Skip(ULONG celt)
{
	SCODE sc;

	if (m_iCurrent + celt > m_cNames) {
		m_iCurrent = m_cNames;
		sc = S_FALSE;
	}
	else {
		m_iCurrent += celt;
		sc = S_OK;
	}

	return ResultFromScode(sc);
}


STDMETHODIMP CLUEnum::Reset(void)
{
	Cleanup();
	m_iCurrent = 0;
	return Init();
}


STDMETHODIMP CLUEnum::Clone(IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum)
{
	CLUEnum *pNewEnum = new CLUEnum(m_pDB);

	if (pNewEnum == NULL)
		return ResultFromScode(E_OUTOFMEMORY);

	HRESULT hres = pNewEnum->Init();
	if (FAILED(hres)) {
		pNewEnum->Release();
		return hres;
	}

	if (m_iCurrent == m_cNames) {			/* if at end, new one is at end */
		pNewEnum->m_iCurrent = pNewEnum->m_cNames;
	}
	else {
		LPCSTR pszCurrentName = m_papszNames[m_iCurrent];
		for (UINT i=0; i<pNewEnum->m_cNames; i++) {
			if (!::strcmpf(pszCurrentName, pNewEnum->m_papszNames[i])) {
				pNewEnum->m_iCurrent = i;	/* names match, start here */
				break;
			}
		}
		if (i == pNewEnum->m_cNames)
			pNewEnum->m_iCurrent = 0;		/* current name not found, start at beginning */
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\netmpr.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    netmpr.h

Abstract:

    DDK WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:


Revision History:

    20-Mar-1995     LenS
        Created.

--*/

#ifndef _INC_NETMPR_
#define _INC_NETMPR_


//
//  Authentication and Logon/Logoff.
//

#define LOGON_DONE              0x00000001
#define LOGON_PRIMARY           0x00000002
#define LOGON_MUST_VALIDATE     0x00000004

#define LOGOFF_PENDING  1
#define LOGOFF_COMMIT   2
#define LOGOFF_CANCEL   3


//
//  Password Cache.
//

#ifndef PCE_STRUCT_DEFINED
#define PCE_STRUCT_DEFINED

struct PASSWORD_CACHE_ENTRY {
    WORD cbEntry;               /* size of this entry in bytes, incl. pad */
    WORD cbResource;            /* size of resource name in bytes */
    WORD cbPassword;            /* size of password in bytes */
    BYTE iEntry;                /* index number of this entry, for MRU */
    BYTE nType;                 /* type of entry (see below) */
    char abResource[1];         /* resource name (may not be ASCIIZ at all) */
};

#define PCE_MEMORYONLY          0x01    /* for flags field when adding */

/*
    Typedef for the callback routine passed to the enumeration functions.
    It will be called once for each entry that matches the criteria
    requested.  It returns TRUE if it wants the enumeration to
    continue, FALSE to stop.
*/
typedef BOOL (FAR PASCAL *CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY FAR *pce, DWORD dwRefData );

#endif  /* PCE_STRUCT_DEFINED */

DWORD APIENTRY
WNetCachePassword(
    LPSTR pbResource,
    WORD  cbResource,
    LPSTR pbPassword,
    WORD  cbPassword,
    BYTE  nType,
    UINT  fnFlags
    );

DWORD APIENTRY
WNetGetCachedPassword(
    LPSTR  pbResource,
    WORD   cbResource,
    LPSTR  pbPassword,
    LPWORD pcbPassword,
    BYTE   nType
    );

DWORD APIENTRY
WNetRemoveCachedPassword(
    LPSTR pbResource,
    WORD  cbResource,
    BYTE  nType
    );

DWORD APIENTRY
WNetEnumCachedPasswords(
    LPSTR pbPrefix,
    WORD  cbPrefix,
    BYTE  nType,
    CACHECALLBACK pfnCallback,
    DWORD dwRefData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\mslunp.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"
#include <winnetwk.h>
#include <netspi.h>

#pragma data_seg(".shared")
char szDefaultLogonUsername[MAX_PATH] = "";
char szDefaultLogonPassword[MAX_PATH] = "";
BOOL fDoDefaultLogon = FALSE;
#pragma data_seg()


struct LogonData
{
    LPLOGONINFO lpAuthentInfo;
    DWORD dwFlags;
    IUser **ppOut;
    HBITMAP hbmTransparent;
};


void ObfuscateString(LPSTR pszBuffer)
{
    DWORD dwMask = 0xa95e633b;      /* nice random collection of bits */

    unsigned char ch;
    do {
        ch = *pszBuffer;

        *(pszBuffer++) = ch ^ (unsigned char)(dwMask & 0xff);
        dwMask = (dwMask >> 8) | (dwMask << 24);
    } while (ch);
}


void DeObfuscateString(LPSTR pszBuffer)
{
    DWORD dwMask = 0xa95e633b;      /* nice random collection of bits */

    unsigned char ch;
    do {
        ch = *pszBuffer ^ (unsigned char)(dwMask & 0xff);

        *(pszBuffer++) = ch;
        dwMask = (dwMask >> 8) | (dwMask << 24);
    } while (ch);
}


void CacheLogonCredentials(LPCSTR pszUsername, LPCSTR pszPassword)
{
    lstrcpy(szDefaultLogonUsername, pszUsername);
    lstrcpy(szDefaultLogonPassword, pszPassword);
    fDoDefaultLogon = TRUE;

    ObfuscateString(szDefaultLogonUsername);
    ObfuscateString(szDefaultLogonPassword);
}


SPIENTRY NPGetCaps(
    DWORD nIndex
    )
{
    switch (nIndex) {
    case WNNC_SPEC_VERSION:
        return 0x00040001;          /* spec version 4.1 */

    case WNNC_NET_TYPE:
        return WNNC_NET_MSNET;

    case WNNC_DRIVER_VERSION:
        return 0x00010000;          /* driver version 1.0 */

    case WNNC_USER:
        return
//          WNNC_USR_GETUSER |
            0;

    case WNNC_CONNECTION:
        return
            0;

    case WNNC_DIALOG:
        return
            0;

    case WNNC_ENUMERATION:
        return
            0;

    case WNNC_START:
        return 0x1;                 /* started */

    case WNNC_RESOURCE:
        return
            0;

    case WNNC_AUTHENTICATION:
        return
            WNNC_AUTH_LOGON |
            WNNC_AUTH_LOGOFF |
//          WNNC_AUTH_GETHOMEDIRECTORY |
//          WNNC_AUTH_GETPOLICYPATH |
            0;
    }

    return 0;
}

// FEATURE not multimonitor friendly

VOID PlaceDialog(HWND hDlg, BOOL fTopThird)
{
    RECT rc;
    int dyScreen = GetSystemMetrics(SM_CYSCREEN);
    int yDialog;

    GetWindowRect(hDlg,&rc);

    if (fTopThird)
        yDialog = (dyScreen / 3) - ((rc.bottom-rc.top) / 2);
    else
        yDialog = (dyScreen - (rc.bottom - rc.top)) / 2;

    SetWindowPos(hDlg,NULL,
               (GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2,
               yDialog, 0, 0, SWP_NOSIZE);
}


void UserSelected(HWND hwndLB, int iItem)
{
    BOOL fNeedPassword;
    BOOL fEnableOK;

    if (iItem == LB_ERR) {
        fNeedPassword = FALSE;
        fEnableOK = FALSE;
    }
    else {
        IUser *pUser = (IUser *)::SendMessage(hwndLB, LB_GETITEMDATA, iItem, 0);
        fNeedPassword = FAILED(pUser->Authenticate(""));
        fEnableOK = TRUE;
    }
    HWND hDlg = GetParent(hwndLB);
    EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD_LABEL), fNeedPassword);
    EnableWindow(GetDlgItem(hDlg, IDC_PASSWORD), fNeedPassword);
    EnableWindow(GetDlgItem(hDlg, IDOK), fEnableOK);
}


HRESULT FillUserList(HWND hwndLB, IUserDatabase *pDB, LPCSTR pszDefaultSelection,
                     BOOL fIncludeGuest, PFNSELNOTIFY pfnSelNotify)
{
    IEnumUnknown *pEnum;
    BOOL fSelectionSet = FALSE;

    if (fIncludeGuest) {
        NLS_STR nlsTemp(MAX_RES_STR_LEN);
        if (nlsTemp.LoadString(IDS_GUEST_USERNAME) == ERROR_SUCCESS) {
            UINT iItem = (UINT)::SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)nlsTemp.QueryPch());
            if (iItem != LB_ERR && iItem != LB_ERRSPACE) {
                ::SendMessage(hwndLB, LB_SETITEMDATA, iItem, 0);
            }
        }
    }

    HRESULT hres = pDB->EnumUsers(&pEnum);
    if (SUCCEEDED(hres)) {
        IUnknown *pUnk;
        while (pEnum->Next(1, &pUnk, NULL) == S_OK) {
            IUser *pUser;
            if (SUCCEEDED(pUnk->QueryInterface(IID_IUser, (void **)&pUser))) {
                char szBuf[cchMaxUsername+1];
                DWORD cbBuffer = sizeof(szBuf);

                if (SUCCEEDED(pUser->GetName(szBuf, &cbBuffer))) {
                    UINT iItem = (UINT)::SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)szBuf);
                    if (iItem != LB_ERR && iItem != LB_ERRSPACE) {
                        if (::SendMessage(hwndLB, LB_SETITEMDATA, iItem, (LPARAM)pUser) == LB_ERR)
                            ::SendMessage(hwndLB, LB_SETITEMDATA, iItem, 0);
                        if (!fSelectionSet) {
                            if (pszDefaultSelection != NULL && !::stricmpf(szBuf, pszDefaultSelection)) {
                                fSelectionSet = TRUE;
                                ::SendMessage(hwndLB, LB_SETCURSEL, iItem, 0);
                                if (pfnSelNotify != NULL)
                                    (*pfnSelNotify)(hwndLB, iItem);
                            }
                        }
                    }
                }
                /* Note that pUser is not Release()d here, since the
                 * listbox has a pointer to it.
                 */
            }
            pUnk->Release();
        }

        if (!fSelectionSet) {
            if (pfnSelNotify)
                (*pfnSelNotify)(hwndLB, LB_ERR);
        }
        else {
            /* If we select the default item above, then insert more names
             * above it, the focus rect and the selection will be different,
             * which is confusing if the user tabs to the listbox.  Work
             * around this by setting the caret index manually.
             */
            LRESULT iItem = ::SendMessage(hwndLB, LB_GETCURSEL, 0, 0);
            if (iItem != LB_ERR)
                ::SendMessage(hwndLB, LB_SETCURSEL, iItem, 0);
        }

        pEnum->Release();
    }

    if (FAILED(hres))
        return hres;

    return fSelectionSet ? NOERROR : S_FALSE;
}


BOOL IsMemphis(void)
{
    OSVERSIONINFOA osvi;

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    return (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId &&
            (osvi.dwMajorVersion > 4 || 
             (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion >= 10)));
}


DWORD InitLogonDialog(HWND hwndDialog, LogonData *pld)
{
    DWORD err = WN_NO_NETWORK;
    BOOL fSelectionSet = FALSE;

    ::SetWindowLongPtr(hwndDialog, DWLP_USER, (LONG_PTR)pld);

    PlaceDialog(hwndDialog, FALSE);

    int idBitmap;
    DWORD dwFlags;

    if (IsMemphis())
        idBitmap = IDB_IMAGE_WIN98_LOGON;
    else
        idBitmap = IDB_IMAGE_LOGON;

    /* The bitmap we show at the top of the logon dialog has black text on a
     * transparent background.  If the dialog background is very dark, the
     * text will be unreadable.  In that case we use a static bitmap with
     * a white background.  For more common background colors, though, we use
     * LoadImage to load a transparent image and replace the bitmap in the
     * dialog.
     *
     * CODEWORK: Could try a variant of COLORISLIGHT macro from shell32,
     * defview.cpp;  it seems pretty aggressive about declaring blues in
     * particular as "dark".  Maybe we could have the alternate bitmap be
     * 3D-mapped as well, but have white text and maybe a white box around
     * the Windows flag, then we could always be transparent and just choose
     * one or the other at an arbitrary cutoff point.
     */
    DWORD clrBtnFace = GetSysColor(COLOR_3DFACE);
    if ((LOBYTE(clrBtnFace) >= 128) ||
        (LOBYTE(clrBtnFace >> 8) >= 128) ||
        (LOBYTE(clrBtnFace >> 16) >= 128)) {

        dwFlags = LR_LOADMAP3DCOLORS;       /* we'll use a transparent bitmap */
    }
    else {
        idBitmap++;             /* advance to static bitmap ID */
        dwFlags = LR_DEFAULTCOLOR;
    }

    pld->hbmTransparent = (HBITMAP)LoadImage(::hInstance,
                                        MAKEINTRESOURCE(idBitmap),
                                        IMAGE_BITMAP, 0, 0,
                                        dwFlags);
    if (pld->hbmTransparent != NULL) {
        HBITMAP hbmOld = (HBITMAP)SendDlgItemMessage(hwndDialog,
                                                     IDC_MAIN_CAPTION,
                                                     STM_SETIMAGE,
                                                     (WPARAM)IMAGE_BITMAP,
                                                     (LPARAM)pld->hbmTransparent);
        /* If we set the new bitmap into the control, we got the old one
         * back.  Delete the old one.  We will also have to delete the
         * new one when the dialog is dismissed.
         */
        if (hbmOld != NULL)
            DeleteObject(hbmOld);
    }

    IUserDatabase *pDB;

    if (SUCCEEDED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        HRESULT hres = FillUserList(GetDlgItem(hwndDialog, IDC_USERNAME),
                                    pDB, pld->lpAuthentInfo ? pld->lpAuthentInfo->lpUsername : NULL,
                                    FALSE, UserSelected);

        if (SUCCEEDED(hres)) {
            err = ERROR_SUCCESS;

            ::SetFocus(::GetDlgItem(hwndDialog, hres == NOERROR ? IDC_PASSWORD : IDC_USERNAME));
        }
        pDB->Release();
    }

    return err;
}


BOOL ValidateLogonDialog(HWND hwndDialog)
{
    LRESULT iItem = ::SendDlgItemMessage(hwndDialog, IDC_USERNAME, LB_GETCURSEL, 0, 0);
    if (iItem == LB_ERR)
        return FALSE;

    IUser *pUser = (IUser *)::SendDlgItemMessage(hwndDialog, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);

    if (pUser != NULL) {
        NLS_STR nlsUsername(cchMaxUsername+1);
        if (nlsUsername.QueryError())
            return FALSE;

        DWORD cbBuffer = nlsUsername.QueryAllocSize();
        pUser->GetName(nlsUsername.Party(), &cbBuffer);
        nlsUsername.DonePartying();

        HWND hwndPassword = ::GetDlgItem(hwndDialog, IDC_PASSWORD);
        NLS_STR nlsPassword(::GetWindowTextLength(hwndPassword)+2);
        if (nlsPassword.QueryError())
            return FALSE;

        ::GetWindowText(hwndPassword, nlsPassword.Party(), nlsPassword.QueryAllocSize()-1);
        nlsPassword.DonePartying();

        if (SUCCEEDED(pUser->Authenticate(nlsPassword.QueryPch()))) {
            LogonData *pld = (LogonData *)::GetWindowLongPtr(hwndDialog, DWLP_USER);
            if (pld->lpAuthentInfo) {
                DWORD cbUsername = pld->lpAuthentInfo->cbUsername;
                DWORD cbPassword = pld->lpAuthentInfo->cbPassword;
                NPSCopyNLS(&nlsUsername, pld->lpAuthentInfo->lpUsername, &cbUsername);
                NPSCopyNLS(&nlsPassword, pld->lpAuthentInfo->lpPassword, &cbPassword);
            }

            if (pld->ppOut) {
                *pld->ppOut = pUser;
                pUser->AddRef();
            }

            if (pld->dwFlags & LUA_FORNEXTLOGON) {
                CacheLogonCredentials(nlsUsername.QueryPch(), nlsPassword.QueryPch());
            }

            return TRUE;
        }

        NLS_STR nlsTitle(MAX_RES_STR_LEN);
        NLS_STR nlsMessage(MAX_RES_STR_LEN);
        if (!nlsTitle.QueryError() && !nlsMessage.QueryError()) {
            nlsTitle.LoadString(IDS_LOGONTITLE);
            nlsMessage.LoadString(IDS_BADPASSWORD);
            ::MessageBox(hwndDialog, nlsMessage.QueryPch(), nlsTitle.QueryPch(), MB_ICONSTOP | MB_OK);
        }
        ::SetFocus(hwndPassword);
        ::SendMessage(hwndPassword, EM_SETSEL, (WPARAM)(INT)0, (WPARAM)(INT)-1);
    }
    return FALSE;
}


void DestroyUserList(HWND hwndLB)
{
    LRESULT cItems = ::SendMessage(hwndLB, LB_GETCOUNT, 0, 0);

    for (LRESULT iItem = 0; iItem < cItems; iItem++) {
        IUser *pUser = (IUser *)::SendMessage(hwndLB, LB_GETITEMDATA, iItem, 0);
        if (pUser != NULL) {
            pUser->Release();
        }
    }
}


void ExitLogonDialog(HWND hwndDialog, DWORD err)
{
    DestroyUserList(GetDlgItem(hwndDialog, IDC_USERNAME));

    LogonData *pld = (LogonData *)::GetWindowLongPtr(hwndDialog, DWLP_USER);
    if (pld->hbmTransparent != NULL)
        DeleteObject(pld->hbmTransparent);

    ::EndDialog(hwndDialog, err);
}


extern "C" {

INT_PTR LogonDlgProc(
    HWND hwndDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
#if 0   /*** no help for now ***/
    // Help text array
    static DWORD aIds[] = {
        IDC_DUMMY1, IDH_NET_LOG_USERNAME,
        IDD_LOG_USERNAME, IDH_NET_LOG_USERNAME,
        IDC_DUMMY2, IDH_NET_LOG_PASSWORD,
        IDD_LOG_PASSWORD, IDH_NET_LOG_PASSWORD,
        IDC_LOGOFRAME, NO_HELP,
        IDC_DUMMY3, NO_HELP,
        0,0
    };
#endif

    switch (msg) {
    case WM_INITDIALOG:
        {
            DWORD err = ::InitLogonDialog(hwndDlg, (LogonData *)lParam);
            if (err != ERROR_SUCCESS) {
                ::ExitLogonDialog(hwndDlg, err);
            }
        }
        return FALSE;           /* we set the focus */

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            ::ExitLogonDialog(hwndDlg, WN_CANCEL);
            return TRUE;        /* we processed a message */

        case IDOK:
            if (::ValidateLogonDialog(hwndDlg))
                ::ExitLogonDialog(hwndDlg, WN_SUCCESS);
            return TRUE;        /* we processed a message */

        case IDC_USERNAME:
            if (HIWORD(wParam) == LBN_SELCHANGE) {
                int iItem = (int)::SendDlgItemMessage(hwndDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                UserSelected((HWND)lParam, iItem);
            }
        }
        break;

#if 0   /*** no help for now ***/
    case WM_HELP:
        WinHelp( ((LPHELPINFO)lParam)->hItemHandle, szHelpFile,
                HELP_WM_HELP, (DWORD)(LPVOID)aIds );
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp( (HWND)wParam, szHelpFile, HELP_CONTEXTMENU,
                (DWORD)(LPVOID)aIds );
        return TRUE;
#endif
    }

    return FALSE;               /* we didn't process the message */
}

};  /* extern "C" */


DWORD DoLogonDialog(HWND hwndOwner, LPLOGONINFO lpAuthentInfo)
{
    LogonData ld;

    ld.lpAuthentInfo = lpAuthentInfo;
    ld.dwFlags = 0;
    ld.ppOut = NULL;
    ld.hbmTransparent = NULL;

    INT_PTR nRet = ::DialogBoxParam(::hInstance, MAKEINTRESOURCE(IDD_LOGON),
                                    hwndOwner, LogonDlgProc, (LPARAM)&ld);

    if (nRet == -1)
        return WN_OUT_OF_MEMORY;
    else
        return (DWORD)nRet;
}


HRESULT DoUserDialog(HWND hwndOwner, DWORD dwFlags, IUser **ppOut)
{
    LogonData ld;

    ld.lpAuthentInfo = NULL;
    ld.dwFlags = dwFlags;
    ld.ppOut = ppOut;
    if (ppOut != NULL)
        *ppOut = NULL;

    INT_PTR nRet = ::DialogBoxParam(::hInstance, MAKEINTRESOURCE(IDD_LOGON),
                                    hwndOwner, LogonDlgProc, (LPARAM)&ld);

    if (nRet == -1)
        return E_OUTOFMEMORY;
    else
        return (nRet == WN_SUCCESS) ? S_OK : E_ABORT;
}


DWORD TryDefaultLogon(LPCSTR pszUsername, LPCSTR pszPassword, LPLOGONINFO lpAuthentInfo)
{
    IUserDatabase *pDB = NULL;
    if (FAILED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        return WN_OUT_OF_MEMORY;
    }

    DWORD err;
    IUser *pUser;
    if (SUCCEEDED(pDB->GetUser(pszUsername, &pUser))) {
        if (SUCCEEDED(pUser->Authenticate(pszPassword)))
            err = WN_SUCCESS;
        else
            err = WN_BAD_PASSWORD;

        pUser->Release();
    }
    else {
        err = WN_BAD_USER;
    }

    pDB->Release();

    if (err == WN_SUCCESS) {
        DWORD cbUsername = lpAuthentInfo->cbUsername;
        DWORD cbPassword = lpAuthentInfo->cbPassword;
        NPSCopyString(pszUsername, lpAuthentInfo->lpUsername, &cbUsername);
        NPSCopyString(pszPassword, lpAuthentInfo->lpPassword, &cbPassword);
    }

    return err;
}


SPIENTRY NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    )
{
    /* ignore logon done notification, we only act on logon starting */
    if (dwFlags & LOGON_DONE) {
        return WN_SUCCESS;
    }

    /* we have nothing to do if we're not the primary logon provider */
    if (!(dwFlags & LOGON_PRIMARY)) {
        return WN_SUCCESS;
    }

    /* make sure profiles are enabled, fall back to windows logon if not */
    HKEY hkeyLogon;
    DWORD err;
    DWORD fProfilesEnabled = FALSE;
    DWORD cbData = sizeof(fProfilesEnabled);
    err = ::RegOpenKey(HKEY_LOCAL_MACHINE, ::szLogonKey, &hkeyLogon);
    if (err != ERROR_SUCCESS)
        return WN_NO_NETWORK;
    err = ::RegQueryValueEx(hkeyLogon, ::szUserProfiles, NULL, NULL,
                            (LPBYTE)&fProfilesEnabled, &cbData);
    ::RegCloseKey(hkeyLogon);
    if (err != ERROR_SUCCESS || !fProfilesEnabled)
        return WN_NO_NETWORK;

    /* If we have cached logon credentials, attempt to use them. */

    if (fDoDefaultLogon) {
        DeObfuscateString(szDefaultLogonUsername);
        DeObfuscateString(szDefaultLogonPassword);

        DWORD err = TryDefaultLogon(szDefaultLogonUsername, szDefaultLogonPassword, lpAuthentInfo);

        ::memsetf(szDefaultLogonUsername, '\0', sizeof(szDefaultLogonUsername));
        ::memsetf(szDefaultLogonPassword, '\0', sizeof(szDefaultLogonPassword));
        fDoDefaultLogon = FALSE;

        if (err == WN_SUCCESS)
            return WN_SUCCESS;
    }

    return DoLogonDialog(hwndOwner, lpAuthentInfo);
}


SPIENTRY NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    )
{
    return WN_SUCCESS;
}


SPIENTRY NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
    DWORD dwFlags
    )
{
    return WN_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msluobj.cpp ===
#include "mslocusr.h"
#include "msluglob.h"


STDMETHODIMP CLUClassFactory::QueryInterface(
	/* [in] */ REFIID riid,
	/* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
	*ppvObject = NULL;

	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IClassFactory)) {
		*ppvObject = (LPVOID)this;
		AddRef();
		return NOERROR;
	}
	return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CLUClassFactory::AddRef(void)
{
	RefThisDLL(TRUE);

	return 1;
}


STDMETHODIMP_(ULONG) CLUClassFactory::Release(void)
{
	RefThisDLL(FALSE);

	return 1;
}


HRESULT CreateUserDatabase(REFIID riid, void **ppOut)
{
	CLUDatabase *pObj = new CLUDatabase;

	if (NULL == pObj)
		return ResultFromScode(E_OUTOFMEMORY);

	HRESULT hr = pObj->QueryInterface(riid, ppOut);

	if (FAILED(hr)) {
		delete pObj;
	}
	else {
		pObj->AddRef();
	}

	return NOERROR;
}


STDMETHODIMP CLUClassFactory::CreateInstance(
	/* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
	/* [in] */ REFIID riid,
	/* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
	if (NULL != pUnkOuter)
		return ResultFromScode(CLASS_E_NOAGGREGATION);

	return CreateUserDatabase(riid, ppvObject);
}

        
STDMETHODIMP CLUClassFactory::LockServer( 
	/* [in] */ BOOL fLock)
{
	LockThisDLL(fLock);

	return NOERROR;
}


/* This function signals our stub NP DLL in MPREXE's context to load or
 * unload MSLOCUSR as a net provider DLL.  This way, when we uninstall,
 * DllUnregisterServer can get MSLOCUSR unloaded from MPREXE's process
 * space, so it can be deleted and upgraded.  Then, DllRegisterServer
 * w