                     RESHEADER ResHeader,
                      ACCELTABLEENTRY * pAccelTable,
                      WORD wcTableEntries)
{
    TOKEN tok;
    WORD  i, l;
    char  szBuf[10];

    tok.wType   = ResHeader.wTypeID;
    tok.wName   = ResHeader.wNameID;
    tok.wFlag   = 0;
    tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

    lstrcpy( tok.szName,  ResHeader.pszName);

    for (i = 0; i < wcTableEntries ; i ++) {
        tok.wFlag = (WORD) pAccelTable[i].fFlags;
        tok.wID = i;

        // The order of wID and wAscii is reverse to the
        // oder in the accelerator structure and the .rc file

        sprintf( szBuf, "%hu %hu", pAccelTable[i].wID, pAccelTable[i].wAscii);

        l = lstrlenA( szBuf) + 1;
        tok.szText = (TCHAR *)FALLOC( MEMSIZE( l));
#ifdef RLRES32
        _MBSTOWCS( (TCHAR *)tok.szText, szBuf, l, l);
#else
        lstrcpyA(tok.szText, szBuf);
#endif
        PutToken(TokFile, &tok);
        RLFREE( tok.szText);
    }
}


/**
  *
  *
  *  Function: TokDialog.
  *     Travers through linked list of the Dialog defintion, and writes any info
  *     which requires localization to the token file.
  *
  *
  *  Arguments:
  *     TokFile, file pointer of token file.
  *     ResHeader, Resource header info of dialog resource. This info is needed
  *     to generate the token id.
  *     pDialogHdr, linked list of dialog info. Each dialog control is a node
  *     in the linked list.
  *
  *
  *  Returns:
  *     The info requiring localization written to the tok file.
  *
  *  Errors Codes:
  *     None.
  *
  *  History:
  *     7/91. Implemented.                          TerryRu.
  *     7/91. Now tokenize all control cordiantes, so they are
  *     maintained during updates.                  TerryRu.
  *     8/91. Supported signed coordinates.         TerryRu.
  *     1/93. Now tokenize dlg font names.          TerryRu
  *     01/93 Add support for var length token text MHotchin
  **/

void TokDialog( FILE * TokFile, RESHEADER ResHeader, DIALOGHEADER  *pDialogHdr)
{
    WORD wcDup = 0;
    WORD *pwIdBuf;
    WORD i, j = 0, k = 0, l = 0;
    static CHAR  szTmpBuf[256];
    static TCHAR szBuf[256];
    static TOKEN tok;


    *szTmpBuf = '\0';
    *szBuf    = TEXT('\0');

    // tok the dialog caption
    tok.wType   = ResHeader.wTypeID;
    tok.wName   = ResHeader.wNameID;
    tok.wID     = 0;
    tok.wFlag   = ISCAP;
    tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

    lstrcpy ((TCHAR *)tok.szName , (TCHAR *)ResHeader.pszName);

    tok.szText = BinToText( pDialogHdr->pszCaption,
                            lstrlen( pDialogHdr->pszCaption));
    PutToken(TokFile, &tok);
    RLFREE( tok.szText);

    // tok the dialog cordinates
    // bug fix, cordinates can be signed.
    tok.wFlag = (ISCAP) | (ISCOR);

#ifdef RLRES32
    sprintf( szTmpBuf, "%4hd %4hd %4hd %4hd",
             pDialogHdr->x,
             pDialogHdr->y,
             pDialogHdr->cx,
             pDialogHdr->cy);

    if ( gfShowClass ) {
        sprintf( &szTmpBuf[ strlen( szTmpBuf)], " : TDB");
    }
    _MBSTOWCS( szBuf,
               szTmpBuf,
               WCHARSIN( sizeof( szBuf)),
               ACHARSIN( lstrlenA( szTmpBuf ) + 1 ));
#else
    sprintf( szBuf, "%4hd %4hd %4hd %4hd",
             pDialogHdr->x,
             pDialogHdr->y,
             pDialogHdr->cx,
             pDialogHdr->cy);
#endif

    tok.szText = BinToText( szBuf, lstrlen( szBuf));

    PutToken(TokFile, &tok);
    RLFREE( tok.szText);

    if (gfExtendedTok) {
        // toknize dialog fontname, and size

        if ( pDialogHdr->lStyle & DS_SETFONT ) {
            tok.wFlag = ISDLGFONTSIZE;
            sprintf(szTmpBuf, "%hu", pDialogHdr->wPointSize);
            l = lstrlenA( szTmpBuf) + 1;
            tok.szText = (TCHAR *)FALLOC( MEMSIZE( l));
#ifdef RLRES32
            _MBSTOWCS( (TCHAR*) tok.szText, szTmpBuf, l, l);
#else
            strcpy(tok.szText, szTmpBuf);
#endif

            PutToken(TokFile, &tok);
            RLFREE( tok.szText);

            tok.wFlag = ISDLGFONTNAME;
            tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( pDialogHdr->pszFontName) + 1));
            lstrcpy( tok.szText, pDialogHdr->pszFontName);

            PutToken( TokFile, &tok);
            RLFREE( tok.szText);
            tok.szText = NULL;
        }
    }

    // allocate buffer for for duplicate check
    pwIdBuf = (WORD *) FALLOC((DWORD) pDialogHdr->wNumberOfItems * sizeof(WORD));


    for (i = 0; i < (WORD) pDialogHdr->wNumberOfItems; i ++) {
        if (isdup ((WORD)pDialogHdr->pCntlData[i].dwID, pwIdBuf, (WORD)j)) {
            tok.wID = (USHORT)wcDup++;
            tok.wFlag = ISDUP;
        } else {
            // wid is unique so store in buffer for dup check
            pwIdBuf[j++] = (USHORT)pDialogHdr->pCntlData[i].dwID;

            tok.wID = (USHORT)pDialogHdr->pCntlData[i].dwID;
            tok.wFlag = 0;
        }

        if (pDialogHdr->pCntlData[i].pszDlgText[0]) {
            tok.szText = BinToText( pDialogHdr->pCntlData[i].pszDlgText,
                                    lstrlen( (TCHAR *)pDialogHdr->pCntlData[i].pszDlgText));

            PutToken(TokFile, &tok);
            RLFREE( tok.szText);
        }

        // now do the dialog corrdinates,
        // bug fix, cordinates can be signed.

#ifdef RLRES32
        sprintf( szTmpBuf,
                 "%4hd %4hd %4hd %4hd",
                 pDialogHdr->pCntlData[i].x,
                 pDialogHdr->pCntlData[i].y,
                 pDialogHdr->pCntlData[i].cx,
                 pDialogHdr->pCntlData[i].cy);

        _MBSTOWCS( szBuf,
                   szTmpBuf,
                   WCHARSIN( sizeof ( szBuf)),
                   ACHARSIN( lstrlenA( szTmpBuf ) + 1));

        if (gfExtendedTok)
            if ( (pDialogHdr->pCntlData[i].bClass_Flag == IDFLAG)
                 && ((pDialogHdr->pCntlData[i].bClass == STATIC)
                     || (pDialogHdr->pCntlData[i].bClass == EDIT) ) ) {
                TCHAR *pszCtrl[3] =
                {
                    TEXT("LEFT"),
                    TEXT("CENTER"),
                    TEXT("RIGHT")
                };
                TCHAR *pszAlign = NULL;
                DWORD dwStyle   = pDialogHdr->pCntlData[i].lStyle;

                if ( pDialogHdr->pCntlData[i].bClass == STATIC ) {
                    // STATIC class alignment values are constants
                    // not flags, so we handle them differently
                    // than we do for the EDIT class below.

                    dwStyle &= (SS_LEFT|SS_CENTER|SS_RIGHT);

                    if ( dwStyle == SS_RIGHT ) {
                        pszAlign = pszCtrl[2];
                    } else if ( dwStyle == SS_CENTER ) {
                        pszAlign = pszCtrl[1];
                    } else if ( dwStyle == SS_LEFT ) {
                        pszAlign = pszCtrl[0];
                    }
                } else {                // Dealing with an EDIT class
                    if ( dwStyle & ES_RIGHT ) {
                        pszAlign = pszCtrl[2];
                    } else if ( dwStyle & ES_CENTER ) {
                        pszAlign = pszCtrl[1];
                    } else if ( dwStyle & ES_LEFT ) {
                        pszAlign = pszCtrl[0];
                    }
                }

                if ( pszAlign ) {
                    _stprintf( &szBuf[ _tcslen( szBuf)], TEXT(" ( %s ) "), pszAlign);
                }
            }

        if ( gfShowClass ) {
            if ( pDialogHdr->pCntlData[i].bClass_Flag == IDFLAG ) {
                TCHAR *pszCtrl = TEXT("???");    //... DLG box control class

                switch ( pDialogHdr->pCntlData[i].bClass ) {
                    case BUTTON:
                        {
                            WORD  wTmp;

                            wTmp = (WORD)(pDialogHdr->pCntlData[i].lStyle & 0xffL);

                            switch ( wTmp ) {

                                case BS_PUSHBUTTON:
                                case BS_DEFPUSHBUTTON:

                                    pszCtrl = TEXT("BUT");
                                    break;

                                case BS_CHECKBOX:
                                case BS_AUTOCHECKBOX:
                                case BS_3STATE:
                                case BS_AUTO3STATE:

                                    pszCtrl = TEXT("CHX");
                                    break;

                                case BS_RADIOBUTTON:
                                case BS_AUTORADIOBUTTON:

                                    pszCtrl = TEXT("OPT");
                                    break;

                                case BS_GROUPBOX:
                                case BS_USERBUTTON:
                                case BS_OWNERDRAW:
                                case BS_LEFTTEXT:
                                default:

                                    pszCtrl = TEXT("DIA");
                                    break;

                            }   //... END switch( wTmp )
                            break;
                        }
                    case STATIC:

    #ifdef DBCS
//Special hack
//I will remove this code later.
//This code is for fix code between 1.84 and 1.85(STATIC alignment problem)

                        {
                            WORD  wTmp;

                            wTmp = (WORD)(pDialogHdr->pCntlData[i].lStyle & (SS_LEFT|SS_CENTER|SS_RIGHT));
                            if ( (wTmp==SS_CENTER)
                                 || (wTmp==SS_LEFT) || (wTmp==SS_RIGHT) ) {
                                pszCtrl = TEXT("TXB");
                            } else {
                                pszCtrl = TEXT("ICO");
                            }
                            break;
                        }
    #else // not DBCS
                        pszCtrl = TEXT("TXB");
                        break;
    #endif // DBCS
                    default:

                        pszCtrl = TEXT("DIA");
                        break;

                }   //... END switch ( pDialogHdr->pCntlData[i].bClass )

                wsprintf( &szBuf[ lstrlen( szBuf)], TEXT(" : %s"), pszCtrl);
            } else {
                wsprintf( &szBuf[ lstrlen( szBuf)],
                          TEXT(" : \"%s\""),
                          pDialogHdr->pCntlData[i].pszClass);
            }
        }

#else
        sprintf(szBuf, "%4hd %4hd %4hd %4hd",
                pDialogHdr->pCntlData[i].x,
                pDialogHdr->pCntlData[i].y,
                pDialogHdr->pCntlData[i].cx,
                pDialogHdr->pCntlData[i].cy);
#endif

        tok.wFlag |= ISCOR;

        tok.szText = BinToText( szBuf, lstrlen( (TCHAR *)szBuf));
        PutToken(TokFile, &tok);
        RLFREE( tok.szText);
        tok.szText = NULL;
    }
    RLFREE( pwIdBuf);
    pwIdBuf = NULL;
}


/**
  *
  *
  * Function: TokMenu,
  * Travers the linked list of the Menu definition, and writes any info
  * requiring localization to the token file.
  *
  *
  *  Arguments:
  * TokFile, file pointer of token file.
  * ResHeader, Resource header  of Menu info. Need to generate token ids.
  * pMenuHdr, Header of the menu used to access the linked list of token info.
  *
  *  Returns:
  * TokenFile contain all info requiring localization.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void TokMenu(FILE *TokFile ,   RESHEADER ResHeader, MENUHEADER *pMenuHdr)
{
    TOKEN tok;
    static WORD  wcPopUp = 0;
    MENUITEM *pMenuItem;

    pMenuItem = pMenuHdr->pMenuItem;

    tok.wReserved = (gbMaster? ST_NEW : ST_NEW | ST_TRANSLATED);

    while (pMenuItem) {
        // if Menu Item is a seperator skip it
        if (*pMenuItem->szItemText) {
            tok.wType = ResHeader.wTypeID;
            tok.wName = ResHeader.wNameID;

            // check for the popup menu items
            if ((pMenuItem->fItemFlags & MFR_POPUP) && pMenuHdr->fMenuEx) {
                tok.wID = (pMenuItem->dwMenuID == 0 ||
                           pMenuItem->dwMenuID == 0x0000ffff) ?
                          (USHORT)pMenuItem->dwMenuID : 0x8000 + wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else if (pMenuItem->fItemFlags & POPUP) {
                tok.wID = wcPopUp++;
                tok.wFlag = ISPOPUP;
            } else {
                tok.wID = (USHORT)pMenuItem->dwMenuID;
                tok.wFlag = 0;
            }
            lstrcpy ((TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);

            tok.szText = BinToText( pMenuItem->szItemText,
                                    lstrlen( (TCHAR *)pMenuItem->szItemText));
            PutToken (TokFile, &tok);
            RLFREE( tok.szText);
        }
        pMenuItem = pMenuItem->pNextItem;
    }
}



/**
  *
  *
  *  Function: TokString
  * Write the 16 strings contained in the  string block.
  *
  *
  *  Arguments:
  * TokFile, file pointer of Token File.
  * ResHeader, Resource header info of String block.
  * pStrHdr, Array of 16 strings making up portion of the string table.
  *
  *  Returns:
  * Strings written to the Token File.
  *
  *  Errors Codes:
  * None.
  *
  *  History:
  * 7/91, Implemented.              TerryRu.
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void TokString( FILE * TokFile, RESHEADER ResHeader, STRINGHEADER * pStrHdr)
{
//    int   nLen;
    TOKEN tok;
    BYTE  i;



    for ( i = 0; i < 16; i++ ) {
        tok.wType   = ResHeader.wTypeID;
        tok.wName   = ResHeader.wNameID;
        tok.wID     = i;
        tok.wFlag   = 0;
        tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);

        lstrcpy( (TCHAR *)tok.szName, (TCHAR *)ResHeader.pszName);

//        nLen = lstrlen( (TCHAR *)pStrHdr->pszStrings[i]);        //DHW_TOOLONG

        tok.szText = BinToText( (TCHAR *)pStrHdr->pszStrings[i], pStrHdr->wChars[i]);

        PutToken( TokFile, &tok);
        RLFREE( tok.szText);
    }
}


#ifdef RLRES32

//................................................................
//...
//... Move to start of value field in version resource blocks
//... and adjust remaining-data-sizes accordingly.

PVERBLOCK MoveAlongVer(

                      PVERBLOCK pVerData, //... Start of current version block
                      WORD     *pw1,      //... First word to decrement
                      WORD     *pw2,      //... Second word to decrement
                      WORD     *pw3)      //... Third word to decrement
{
    WORD  wLen;
    PBYTE pData = (PBYTE)pVerData;


    wLen = DWORDUP( pVerData->wLength);

    pData += DWORDUP( wLen);

    DECWORDBY( pw1, wLen);
    DECWORDBY( pw2, wLen);
    DECWORDBY( pw3, wLen);

    return ( (PVERBLOCK)pData);
}

//....................................................................



TCHAR *GetVerValue( PVERBLOCK pVerData)
{
    WORD  wLen = sizeof( VERBLOCK);

    //... sizeof(VERBLOCK) already includes
    //... the size of a WCHAR so we do not
    //... need to add 1 to length of the key.

    wLen += (WORD) (BYTESINSTRING( pVerData->szKey));
    wLen = DWORDUP( wLen);      //... Possible DWORD padding

    return ( (TCHAR *)((PBYTE)pVerData + wLen));
}

//....................................................................

#endif  //... RLRES32


/**
  *
  *
  *  Function: TokResVer
  * Reads through the Version Info blocks, and writes any info requiring
  * localization to the token file.
  *
  *
  *  Arguments:
  * TokeFile, file pointer of token file.
  * ResHeader, Resource Header info for version stamping. Need to generate
  * the token IDs.
  *
  *  Returns:
  *
  *  Errors Codes:
  * 1, info written to token file.
  *
  *  History:
  * 11/91. Implemented.             TerryRu.
  * 10/92.  Added RLRES32 version     DaveWi
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

#ifdef RLRES32

int TokResVer(

             FILE     *fpTokFile,      //... Output token file
             RESHEADER ResHeader,      //... Resource header of version resource
             VERBLOCK *pVerData,       //... Data to tokenize
             WORD      wDataLen)       //... # bytes in pVerData
{
    TOKEN  Tok;
    BOOL   fInStringInfo = FALSE;   //... TRUE if reading StringFileInfo
    WORD   wTokNum   = 0;           //... Put into Tok.wID field
    WORD   wTokContinueNum = 0;     //... Put into Tok.wFlag field


    if (wDataLen == 0 || wDataLen == (WORD)-1) {
        return (-1);             //... No data to tokenize
    }
    //... Fill in static part of TOKEN struct

    Tok.wType   = ResHeader.wTypeID;
    Tok.wName   = IDFLAG;
    Tok.szName[0] = TEXT('\0');
    Tok.szType[0] = TEXT('\0');
    Tok.wReserved = (gbMaster? ST_NEW : ST_NEW | ST_TRANSLATED);


    //... Make a token for each string found

    while (wDataLen > 0) {
        WORD wRC;

        //... Start of a StringFileInfo block?

        wRC =(WORD)_tcsncmp((TCHAR *)pVerData->szKey,
                            (TCHAR *)STRINGFILEINFO,
                            min(wDataLen, (WORD)STRINGFILEINFOLEN));

        if (wRC == SAME) {
            WORD  wStringInfoLen = 0;   //... # of bytes in StringFileInfo
            WORD  wLen = 0;

            //... Get # of bytes in this StringFileInfo
            //... (Length of value is always 0 here)

            wStringInfoLen = pVerData->wLength;

            //... Move to start of first StringTable blk.

            wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                           - sizeof(WCHAR)
                           + MEMSIZE( STRINGFILEINFOLEN)));

            pVerData = (PVERBLOCK)((PBYTE)pVerData + wLen);
            DECWORDBY(&wDataLen, wLen);
            DECWORDBY(&wStringInfoLen, wLen);

            while (wStringInfoLen > 0) {
                WORD  wStringTableLen = 0;

                //... Get # of bytes in this StringTable
                //... (Length of value is always 0 here)

                wStringTableLen = pVerData->wLength;

                //... Copy Language BLOCK Info key
                //... into Token name

                lstrcpy((TCHAR *)Tok.szName, (TCHAR *)LANGUAGEINFO);

                //... Copy lang string into token

                Tok.szText = (TCHAR *) FALLOC(MEMSIZE(LANGSTRINGLEN+1));
                CopyMemory( Tok.szText,
                            pVerData->szKey,
                            LANGSTRINGLEN * sizeof ( TCHAR));

                Tok.szText[ LANGSTRINGLEN] = TEXT('\0');

                Tok.wID = wTokNum++;
                Tok.wFlag = 0;

                PutToken(fpTokFile, &Tok);
                RLFREE( Tok.szText);

                //... Move to start of first String.

                wLen = DWORDUP(sizeof(VERBLOCK)
                               - sizeof(WCHAR)
                               + MEMSIZE( LANGSTRINGLEN));

                pVerData = (PVERBLOCK)((PBYTE)pVerData + wLen);

                DECWORDBY(&wDataLen, wLen);
                DECWORDBY(&wStringInfoLen, wLen);
                DECWORDBY(&wStringTableLen, wLen);

                while (wStringTableLen > 0) {
                    //... Is value a string?

                    if (pVerData->wType == VERTYPESTRING) {
                        Tok.wID = wTokNum++;

                        lstrcpy( (TCHAR *)Tok.szName, (TCHAR *)pVerData->szKey);
                        Tok.szText = BinToText( GetVerValue( pVerData),
                                                lstrlen( GetVerValue( pVerData)));

                        PutToken(fpTokFile, &Tok);
                        RLFREE( Tok.szText);
                    }
                    //... Move to start of next String.

                    pVerData = MoveAlongVer(pVerData,
                                            &wDataLen,
                                            &wStringInfoLen,
                                            &wStringTableLen);

                }               //... END while (wStringTableLen)

            }                   //... END while (wStringInfoLen)
        } else {
            if (_tcsncmp((TCHAR *)pVerData->szKey,
                         (TCHAR *)VARFILEINFO,
                         min(wDataLen, (WORD)VARFILEINFOLEN)) == SAME) {
                WORD  wVarInfoLen = 0;  //... # of bytes in VarFileInfo
                WORD  wLen = 0;

                //... Get # of bytes in this VarFileInfo
                //... (Length of value is always 0 here)

                wVarInfoLen = pVerData->wLength;

                //... Move to start of first Var.

                wLen = (WORD)(DWORDUP(sizeof(VERBLOCK)
                               - sizeof(WCHAR)
                               + MEMSIZE( VARFILEINFOLEN)));
                pVerData = (PVERBLOCK)((PBYTE)pVerData + wLen);

                DECWORDBY(&wDataLen, wLen);
                DECWORDBY(&wVarInfoLen, wLen);

                while (wVarInfoLen > 0) {
                    if (_tcsncmp(pVerData->szKey,
                                 TRANSLATION,
                                 min( wDataLen, (WORD)TRANSLATIONLEN)) == SAME) {
                        PBYTE  pValue = NULL;
                        WORD   wTransLen = 0;
                        USHORT uByte1 = 0;
                        USHORT uByte2 = 0;
                        UINT   uLen   = 0;

                        wTokContinueNum = 0;

                        //... How many bytes are we to tokenize?

                        wTransLen = pVerData->wValueLength;

                        //... Where are those bytes?

                        pValue = (PBYTE)GetVerValue(pVerData);

                        //... Copy VarFileInfo into Token

                        lstrcpy((TCHAR *)Tok.szName, (TCHAR *)pVerData->szKey);

                        //... Allocate a buffer for a space-separated
                        //... list of the lang ID's in this vresion res.

                        *szDHW = '\0';

                        while ( wTransLen >= TRANSDATALEN ) {
                            //... Write translation language id by
                            //... reversing byte pairs so the id looks
                            //... like the language id string.  This will
                            //... have to be undone in PutResVer().

                            uByte1 = *pValue;
                            uByte2 = *(pValue + 1);

                            sprintf( &szDHW[ lstrlenA( szDHW)],
                                     "%02hx%02hx",
                                     uByte2,    //... Reverses byte order to
                                     uByte1);   //... be like transltn str.

                            //... Move to next possible translation value

                            wTransLen -= TRANSDATALEN;

                            if ( wTransLen >= TRANSDATALEN ) {
                                pValue += TRANSDATALEN;
                                strcat( szDHW, " ");   //... white-space sep
                            }
                        }       //... END while ( wTransLen ...

                        uLen = lstrlenA( szDHW) + 1;
                        Tok.szText = (TCHAR *)FALLOC( MEMSIZE( uLen));
                        _MBSTOWCS( (TCHAR *)Tok.szText, szDHW, uLen, (UINT)-1);

                        Tok.wID   = wTokNum;
                        Tok.wFlag = wTokContinueNum++;

                        PutToken( fpTokFile, &Tok);

                        RLFREE( Tok.szText);
                    }           //... END if (_tcsncmp( ...

                    //... Move to start of next Var info block.

                    pVerData = MoveAlongVer(pVerData,
                                            &wDataLen,
                                            &wVarInfoLen,
                                            NULL);

                }               //... END while (wVarInfoLen)
            } else {
                QuitT( IDS_ENGERR_14, (LPTSTR)IDS_INVVERBLK, NULL);
            }
        }
    }                           //... END while (wDataLen)
    return (0);
}

#else //... RLRES32

int TokResVer(FILE * TokFile, RESHEADER ResHeader, VERBLOCK *pVerBlk)
{
    TCHAR szLangIdBuf[20];
    TCHAR szCodePageIdBuf[20];
    #ifdef RLRES32
    CHAR  szTmpBuf[20];
    #endif
    WORD wcLang = 0, wcBlock = 0;
    TOKEN tok;
    VERBLOCK  *pCurBlk;
    TCHAR *pszStr;
    DWORD *pdwVal;
    int    wTotLen, nHeadLen, wBlkLen;


    // the count fields are int because count may go negative
    // because the last DWORD alignment is not counted in the
    // byte count.

    // Fill in static part of TOKEN struct
    tok.wType   = ResHeader.wTypeID;
    tok.wName   = IDFLAG;
    tok.wReserved =  (gbMaster? ST_NEW : ST_NEW |  ST_TRANSLATED);


    wTotLen = DWORDUP(pVerBlk->nTotLen);

    tok.wID = wcBlock;
    pszStr = pVerBlk->szKey;
    nHeadLen = 4 + DWORDUP(pVerBlk->nValLen) + DWORDUP(lstrlen((TCHAR *)pszStr) + 1);

    wTotLen -= nHeadLen;
    pCurBlk = (VERBLOCK *) ((TCHAR *) pVerBlk + nHeadLen);

    while (wTotLen > 0) {
        // For string file tables we localize the key field
        tok.wFlag = ISKEY;
        wBlkLen = DWORDUP(pCurBlk->nTotLen);
        pszStr = pCurBlk->szKey;

        tok.szText = BinToText( pszStr, lstrlen((TCHAR *)pszStr));

        lstrcpy((TCHAR *)tok.szName, TEXT("Language Info"));
        tok.wID = wcBlock;

        PutToken(TokFile, &tok);
        RLFREE(tok.szText);

        // Get offset to next block;
        nHeadLen = 4 +
                   DWORDUP(pVerBlk->nValLen) +
                   DWORDUP(lstrlen((TCHAR *)pszStr) + 1);

        // Update counter vars

        wTotLen -= wBlkLen;
        wBlkLen -= nHeadLen;

        // set pointer to next ver block
        pCurBlk = (VERBLOCK*) ((TCHAR *) pCurBlk + nHeadLen);

        // For string blocks we localize the value field.
        tok.wFlag = ISVAL;

        // Now output the tokens in String Block
        while (wBlkLen>0) {
            pszStr = pCurBlk->szKey;
            lstrcpy((TCHAR *)tok.szName, (TCHAR *)pszStr);
            pszStr = (TCHAR *) pCurBlk+4+DWORDUP(lstrlen((TCHAR *)pszStr)+1);

            tok.szText = BinToText( pszStr, lstrlen((TCHAR *)pszStr));
            PutToken(TokFile, &tok);
            RLFREE(tok.szText);

            wBlkLen -= DWORDUP(pCurBlk->nTotLen);
            pCurBlk = (VERBLOCK *) ((TCHAR *) pCurBlk + DWORDUP(pCurBlk->nTotLen));
        }
        wcBlock++;
    }

    // Skip past Head of VarInfoBlock

    wTotLen = DWORDUP(pCurBlk->nTotLen);

    pszStr = pCurBlk->szKey;
    nHeadLen = 4 + DWORDUP(pVerBlk->nValLen) + DWORDUP(lstrlen((TCHAR *)pszStr) + 1);
    wTotLen -= nHeadLen;
    pCurBlk = (VERBLOCK *)((TCHAR *) pCurBlk + nHeadLen);

    wcLang = 0;

    // In Var File blocks we localize the value fields.

    tok.wFlag = ISVAL;

    while (wTotLen > 0) {
        TCHAR szTemp[256];

        pszStr = pCurBlk->szKey;
        tok.wID = wcLang;
        lstrcpy((TCHAR *)tok.szName, TEXT("Translation"));
        pdwVal = (DWORD *)((TCHAR *) pCurBlk + 4 + DWORDUP(lstrlen((TCHAR *)pszStr) + 1));
    #ifdef RLRES32
        _itoa(HIWORD(*pdwVal) , szTmpBuf, 16);
        _MBSTOWCS( szLangIdBuf,
                   szTmpBuf,
                   WCHARSIN( sizeof( szLangIdBuf)),
                   ACHARSIN( strlen( szTmpBuf ) + 1));
    #else

        _itoa(HIWORD(*pdwVal) , szLangIdBuf, 16);
    #endif

    #ifdef RLRES32
        _itoa(LOWORD(*pdwVal), szTmpBuf, 16);
        _MBSTOWCS( szCodePageIdBuf,
                   szTmpBuf,
                   WCHARSIN( sizeof( szCodePageIdBuf)),
                   ACHARSIN( strlen( szTmpBuf ) + 1));
    #else
        _itoa(LOWORD(*pdwVal), szCodePageIdBuf, 16);
    #endif


        // Construct Token Text
        // Note leading zeros gets lost in itoa translation
        lstrcpy((TCHAR *)szTemp, TEXT("0"));
        _tcscat((TCHAR *)szTemp, _tcsupr((TCHAR *)szCodePageIdBuf));
        _tcscat((TCHAR *)szTemp, TEXT("0"));
        _tcscat((TCHAR *)szTemp, _tcsupr((TCHAR *)szLangIdBuf));

        tok.szText = BinToText( szTemp, lstrlen((TCHAR *)szTemp));
        PutToken(TokFile, &tok);
        RLFREE(tok.szText);
        wcLang ++;
        wTotLen -= DWORDUP(pCurBlk->nTotLen);
        pCurBlk = (VERBLOCK *) ((BYTE *) pCurBlk + DWORDUP(pCurBlk->nTotLen));
    }
    return (1);
}

#endif //... RLRES32


/**
  *
  *
  *  Function: UpdateResSize
  * Preforms the Resource Header size fixup, once the size of
  * the localized resource block is determined.
  *
  *
  *  Arguments:
  * OutResFile, File pointer of localized resource file.
  * pResSizePos, file location of size file, of the resoure header.
  * lSize, size of the localized resource.
  *
  *  Returns:
  * The size field fixed up to the value specfied in the lsize.
  *
  *  Errors Codes:
  * TRUE, fixup sucessfull.
  * Result of fsetpos, and fgetpos call.
  *
  *  History:
  *
  *
  **/

WORD    UpdateResSize (FILE * OutResFile, fpos_t *pResSizePos, DWORD lSize)
{
    WORD rc;
    fpos_t tResSizePos;

    if ((rc = (WORD) fgetpos (OutResFile, &tResSizePos)) != 0) {
        return (rc);
    }

    if ((rc = (WORD) fsetpos (OutResFile, pResSizePos)) != 0) {
        return (rc);
    }

    PutdWord(OutResFile, lSize, NULL);

    if ((rc = (WORD) fsetpos (OutResFile, &tResSizePos)) != 0) {
        return (rc);
    }

    return (TRUE) ;
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  * 01/93 Added support for var length token text strings.  MHotchin
  *
  **/

void PutAccelTable(FILE    *OutResFile,
                   FILE    *TokFile,
                   RESHEADER       ResHeader,
                   ACCELTABLEENTRY *pAccelTable,
                   WORD    wcAccelEntries)

{
    fpos_t ResSizePos = 0;
    TOKEN  tok;
    WORD   wcCount = 0;
    DWORD  lSize = 0L;
    TCHAR  pErrBuf[MAXINPUTBUFFER];
#ifdef RLRES32
    CHAR   szTmpBuf[30];
#endif
    TCHAR  *cpAscii, *cpID;

    if ( PutResHeader (OutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, (LPTSTR)IDS_ACCELKEY, NULL);
    }

    lSize = 0L;

    // Prep for find token call
    tok.wType   = ResHeader.wTypeID;
    tok.wName   = ResHeader.wNameID;
    tok.wID     = 0;
    tok.wFlag   = 0;
    tok.wReserved = ST_TRANSLATED;

    lstrcpy( tok.szName, ResHeader.pszName);

    for (wcCount = 0; wcCount < wcAccelEntries; wcCount++) {
        tok.wID     = wcCount;
        tok.wFlag   = (WORD) pAccelTable[wcCount].fFlags;
        tok.szText  = NULL;

        if (!FindToken(TokFile, &tok, ST_TRANSLATED)) {

            ParseTokToBuf(pErrBuf, &tok);
            QuitT( IDS_ENGERR_05, pErrBuf, NULL);
        }

        tok.wReserved = ST_TRANSLATED;

        cpID = (TCHAR *)tok.szText;
        cpAscii = _tcschr((TCHAR *)tok.szText, TEXT(' '));
        (*cpAscii) = '\0';
        cpAscii++;

#ifdef  RLRES16

    #ifndef PDK2

        PutByte (OutResFile, (BYTE) pAccelTable[wcCount].fFlags, &lSize);

    #else   // PDK2

        PutWord (OutResFile, (WORD) pAccelTable[wcCount].fFlags, &lSize);

    #endif  // PDK2

#else   // RLRES16

        PutWord (OutResFile, (WORD) pAccelTable[wcCount].fFlags, &lSize);

#endif  // RLRES16

#ifdef RLRES32

        _WCSTOMBS( szTmpBuf,
                   cpAscii,
                   ACHARSIN( sizeof( szTmpBuf)),
                   lstrlen( cpAscii ) + 1 );
        PutWord (OutResFile, (WORD) atoi(szTmpBuf), &lSize);

        _WCSTOMBS( szTmpBuf,
                   cpID,
                   ACHARSIN( sizeof( szTmpBuf)),
                   lstrlen( cpID ) + 1 );
        PutWord (OutResFile, (WORD) atoi(szTmpBuf), &lSize);

#else   // RLRES32

        PutWord (OutResFile, (WORD) atoi(cpAscii), &lSize);
        PutWord (OutResFile, (WORD) atoi(cpID), &lSize);

#endif  // RLRES32


#ifdef RLRES32
        PutWord (OutResFile, pAccelTable[wcCount].wPadding, &lSize);
#endif

        RLFREE( tok.szText);

    } // for

    if (!UpdateResSize (OutResFile, &ResSizePos , lSize)) {
        QuitT( IDS_ENGERR_07, (LPTSTR)IDS_ACCELKEY, NULL);
    }
} // PutAccelTable


void  CopyRes(

             FILE      *fpInResFile,
             FILE      *fpOutResFile,
             RESHEADER *pResHeader,
             fpos_t    *pResSizePos)
{
    DWORD dwTmp = 0L;


    PutResHeader( fpOutResFile, *pResHeader, pResSizePos, &dwTmp);

    ReadInRes( fpInResFile, fpOutResFile, (DWORD *)&(pResHeader->lSize));

#ifdef RLRES32

    DWordUpFilePointer( fpInResFile,  MYREAD,  ftell( fpInResFile),  NULL);

    DWordUpFilePointer( fpOutResFile, MYWRITE, ftell( fpOutResFile), NULL);

#endif

}

/////////////////////////////
// GetDlgInit
//
// VC++ uses a new resource type, DLGINIT (#240) when storing the
// initial contents of a list box. The data for this resource type
// is unaligned and containg non-Unicode strings. This function will
// read the resource data from the resource file pfInRes into a linked
// list of structures and will return a pointer to the head of that list.
// The parameter pdwSize contains the size of the resource as read from
// the resources associated resource header prior to this function
// being called.
// NOTE: The first entry in the list is aligned so it is treated
// slightly differently than are the remaining entries.

PDLGINITDATA GetDlgInit( FILE * pfInRes, DWORD *pdwSize)
{
    PDLGINITDATA pList = NULL;
    PDLGINITDATA pListEntry = NULL;
    WORD wTmp = 0;

    while ( *pdwSize > sizeof( DWORD) + 2 * sizeof( WORD) ) {
        if ( pList ) {                   // allocate the next entry in the list
            pListEntry->pNext = (PDLGINITDATA)FALLOC( sizeof( DLGINITDATA));
            pListEntry = pListEntry->pNext;
        } else {                   // allocate the head of the list
            pList = (PDLGINITDATA)FALLOC( sizeof( DLGINITDATA));
            pListEntry = pList;
        }
        // save the first two WORD fields of the data
        pListEntry->wControlID     = GetWord( pfInRes, pdwSize);
        pListEntry->wMessageNumber = GetWord( pfInRes, pdwSize);
        // get the string's length (incl nul terminator)
        pListEntry->dwStringLen = GetdWord( pfInRes, pdwSize);
        // get the string
        pListEntry->pszString = FALLOC( pListEntry->dwStringLen);

        for ( wTmp = 0; (pListEntry->pszString[ wTmp] = GetByte( pfInRes, pdwSize)); ++wTmp )
            ;   // empty loop
    }
    // Skip the trailing zero-value WORD
    SkipBytes( pfInRes, pdwSize);
#ifdef RLRES32
    DWordUpFilePointer( pfInRes, MYREAD, ftell( pfInRes),  NULL);
#endif
    return ( pList);
}

//////////////////////////////
// TokDlgInit
//
// Make tokens in pTokFile out of the data in the pDlgInit linked list.

void TokDlgInit( FILE *pfTokFile, RESHEADER ResHeader, PDLGINITDATA pDlgInit)
{
    int    nLen   = 0;
    WORD   wCount = 0;
    static TOKEN Tok;
#ifdef UNICODE
    static TCHAR szTmpBuf[ 256];
#else
    PCHAR szTmpBuf = NULL;
#endif

    ZeroMemory( &Tok, sizeof( Tok));

    Tok.wType   = ResHeader.wTypeID;
    Tok.wName   = ResHeader.wNameID;
    Tok.wReserved = (gbMaster ? ST_NEW : ST_NEW | ST_TRANSLATED);
    lstrcpy( Tok.szName, ResHeader.pszName);

    while ( pDlgInit ) {
        Tok.wID   = wCount++;
        Tok.wFlag = 0;
#ifdef UNICODE
        nLen = _MBSTOWCS( szTmpBuf,
                          pDlgInit->pszString,
                          WCHARSIN( sizeof( szTmpBuf)),
                          (UINT)-1);
#else
        nLen     = strlen( pDlgInit->pszString);
        szTmpBuf = pDlgInit->pszString;
#endif
        Tok.szText = BinToTextW( szTmpBuf, nLen);

        PutToken( pfTokFile, &Tok);
        RLFREE( Tok.szText);
        pDlgInit = pDlgInit->pNext;
    }
}

////////////////////////////
// PutDlgInit
//
// Create a new resource in pfOutRes using the data stored in pDlgInit
// and the token text in the pfTokFile.

void PutDlgInit( FILE *pOutResFile, FILE *pTokFile, RESHEADER ResHeader, PDLGINITDATA pDlgInit)
{
    fpos_t ResSizePos = 0;
    TOKEN  Tok;
    DWORD  lSize   = 0L;
    PCHAR  pszTmp  = NULL;

    if ( PutResHeader( pOutResFile, ResHeader , &ResSizePos, &lSize)) {
        QuitT( IDS_ENGERR_06, TEXT("DLGINIT"), NULL);
    }
    lSize = 0L;

    // Prep for find token call
    Tok.wType   = ResHeader.wTypeID;
    Tok.wName   = ResHeader.wNameID;
    Tok.wID     = 0;
    Tok.wFlag   = 0;
    Tok.wReserved = ST_TRANSLATED;

    lstrcpy( Tok.szName, ResHeader.pszName);

    while ( pDlgInit ) {
        Tok.szText = NULL;

        if ( ! FindToken( pTokFile, &Tok, ST_TRANSLATED)) {
            ParseTokToBuf( (LPTSTR)szDHW, &Tok);
            QuitT( IDS_ENGERR_05, (LPTSTR)szDHW, NULL);
        }
        Tok.wReserved = ST_TRANSLATED;
        Tok.wID++;
        // Write out the two unchanged WORD fields
        PutWord( pOutResFile, pDlgInit->wControlID, &lSize);
        PutWord( pOutResFile, pDlgInit->wMessageNumber, &lSize);
        // write the length of the new string (incl nul)
        _WCSTOMBS( szDHW, Tok.szText, DHWSIZE, (UINT)-1);
        PutdWord( pOutResFile, strlen( szDHW) + 1, &lSize);
        // write the new string (incl nul)
        for ( pszTmp = szDHW; *pszTmp; ++pszTmp ) {
            PutByte( pOutResFile, *pszTmp, &lSize);
        }
        PutByte( pOutResFile, '\0', &lSize);

        pDlgInit = pDlgInit->pNext;
    }
    // write the trailing zero-value WORD
    PutWord( pOutResFile, 0, &lSize);

    if ( ! UpdateResSize( pOutResFile, &ResSizePos, lSize) ) {
        QuitT( IDS_ENGERR_07, TEXT("DLGINIT"), NULL);
    }
#ifdef RLRES32
    DWordUpFilePointer( pOutResFile, MYWRITE, ftell( pOutResFile), NULL);
#endif
}

//////////////////////////////
// ClearDlgInitData
//
// Free the memory allocated for the DlgInitData linked list in GetDlgInit().

void ClearDlgInitData( PDLGINITDATA pDlgInit)
{
    while ( pDlgInit ) {
        PDLGINITDATA pTmp = pDlgInit->pNext;
        RLFREE( pDlgInit->pszString);
        RLFREE( pDlgInit);
        pDlgInit = pTmp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\showerrs.h ===
CHAR *GetErrMsg( UINT uErrID);
void ShowErr( int n, void *p1, void *p2);
void ShowEngineErr( int n, void *p1, void *p2);
int  RLMessageBoxA( LPCSTR pszMsgText);
void Usage( void);

DWORD B_FormatMessage( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId,
    LPSTR lpBuffer, DWORD nSize, va_list *Arguments );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\tokenapi.h ===
#ifndef _TOKENAPI_H_
#define _TOKENAPI_H_


#define MAXINPUTBUFFER 564  // Longest supported line in the token file
#define MAXTOKENBUFFER 1024 // Size for the t_token struct plus the strings
#define MAXFILENAME 256 // maximum length of file pathname
#define MAXCUSTFILTER   40  // maximum size of custom filter buffer
#define CCHNPMAX    65535   // max number of bytes in a notepad file


// Token flag Masks

#define ISPOPUP       0x0001
#define ISCOR         0x0010
#define ISDUP         0x0020
#define ISCAP         0x0040
#define ISDLGFONTNAME 0x0004
#define ISDLGFONTSIZE 0x0008
#define ISALIGN	      0x0080

#define ISKEY    0x0010
#define ISVAL    0x0020

// status bits
#define ST_TRANSLATED  4
#define ST_READONLY    2
#define ST_NEW         1
#define ST_DIRTY       1
#define ST_CHANGED     4
    
#define TOKENSTRINGBUFFER 260
#define MAXTEXTLEN        (4096+TOKENSTRINGBUFFER)

// Increased buffer size of TokeString and TokenText to 260
// I increased to 260 and not 256 to be on the safe side. (PW)
// DHW - For Message Resource Table tokens, the high word of the ulong ID# is
//     now stored as a string in the szName field.  String is result of _itoa().
// MHotchin - Converted to szText field to a pointer, for var length text fields
//      Added a new constant - MAXTEXTLEN is the longest token text we are
//      willing to handle.

#pragma pack(1)

struct t_token {
    WORD wType;         // Type of the token
    WORD wName;         // Name ID of token, 65535 => contains TokenString
    WORD wID;           // Token item ID or duplicated number
    WORD wFlag;         // =0 -> ID is unique
                        // >0 -> ID not unique
    WORD wLangID;       // Locale ID for Win32 resources
    WORD wReserved;     // Not used now
    TCHAR szType[TOKENSTRINGBUFFER];    // Pointer to type string (Not yet used.)
    TCHAR szName[TOKENSTRINGBUFFER];    // Pointer to name string, or msg ID hiword
    TCHAR *szText;                      // Pointer to the text for the token
};

typedef struct t_token TOKEN;

int  GetToken(  FILE * , TOKEN * );
int  PutToken(  FILE * , TOKEN * );
int  FindToken( FILE * , TOKEN * , WORD);
void ParseTokToBuf( TCHAR *, TOKEN * );
void ParseBufToTok( TCHAR *, TOKEN * );
int  TokenToTextSize( TOKEN *);

#pragma pack()

#endif // _TOKENAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\tokenapi.c ===
#include <ctype.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#ifdef RLDOS
    #include "dosdefs.h"
#else
    #include <windows.h>
    #include "windefs.h"
#endif

#include "restok.h"
#include "commbase.h"
#include "resread.h"

extern UCHAR szDHW[];

//
//  The syssetup.dll, that has been contained Windows NT 4.00, has the largest
//  message strings than ever. So, we have to expand buffer size(to 20480).
//
#define MAX_OUT_BUFFER  20480
CHAR gt_szTextBuffer[ MAX_OUT_BUFFER];
TCHAR pt_szOutBuffer[MAX_OUT_BUFFER];

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

/*---------------------------------------------------------
 * Function: GetToken
 * Input: fpInFile       File pointer, points to the token to be read.
 *        tToken         Pointer to a token.
 *
 *
 * Output: fpInFile      File pointer after read operation.
 *                       points to the next token in the file.
 *         tToken        The token read in from the file.  Memory will have been
 *                       allocated for the token text, unless no token was read in.
 *
 * Return code:
 *   0  = Read token, every thing OK
 *   1  = Empty line or line started with # (Comment)
 *  -1  = End of FILE
 *  -2  = Error reading from file.
 *
 * History:
 * 01/93 Re-written to read in long token text strings.  MHotchin
 *
 *----------------------------------------------------------*/


int GetToken(

            FILE *fpInFile,     //... File to get token from.
            TOKEN *pToken)      //... Buffer for token.
{
    int chNextChar = 0;
    int cTextLen   = 0;
    int rc = 0;

    // Read token from file.
    // we will want to use MyGetStr, when
    // tokens are in UNICODE

    // Strip off leading whitespace, and check
    // for blank lines.

    chNextChar = fgetc( fpInFile);

    while ( (chNextChar == ' ') || (chNextChar == '\t') ) {
        chNextChar = fgetc( fpInFile);
    }

    if ( chNextChar == EOF ) {
        return ( -1);
    } else if ( chNextChar == '\n' ) {
        return ( 1);
    }

    // Now we have the first non-white space
    // character.
    // Check for a comment line, and strip out the
    // remainder of the line if it is.

    else if ( chNextChar == '#' ) {
        fscanf( fpInFile, "%*[^\n]");
        chNextChar = fgetc( fpInFile);

        if ( chNextChar == EOF ) {
            return ( -1);
        } else {
            return ( 1);
        }
    }

    // Now we are positioned at the first
    // non-whitespace character. Check it, and
    // read in the numbers...

    else if ( chNextChar != '[' ) {
        // Bad format?
        return ( -2);
    }

    if ( fscanf( fpInFile,
                 "[%hu|%hu|%hu|%hu|%hu",
                 &pToken->wType,
                 &pToken->wName,
                 &pToken->wID,
                 &pToken->wFlag,
                 &pToken->wReserved) != 5 ) {
        QuitA( IDS_ENGERR_12, (LPSTR)IDS_BADTOKID, NULL);
    }

    // Now that we have all the numbers, we can
    // look for the name of the token.

    if ( (pToken->wName == IDFLAG) || (pToken->wType == ID_RT_ERRTABLE) ) {
        static char szName[ TOKENSTRINGBUFFER];
        int nRC = 0;

        nRC = fscanf( fpInFile, "|\"%[^\"]", szName);
        if ( nRC == EOF  ) {
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVTOKNAME, NULL);
        }

#ifndef UNITOK

    #ifdef RLRES32
        if (nRC)
            _MBSTOWCS( (TCHAR *)pToken->szName,
                       szName,
                       TOKENSTRINGBUFFER,
                       lstrlenA( szName) + 1);
        else
            _MBSTOWCS( (TCHAR *)pToken->szName,
                       "",
                       TOKENSTRINGBUFFER,
                       lstrlenA( szName) + 1);
    #else
        if (nRC)
            strcpy( pToken->szName, szName);
        else
            *pToken->szName = '\0';
    #endif

#else
        if (nRC)
            strcpy( pToken->szName, szName);
        else
            *pToken->szName = '\0';
#endif
    } else {
        if ( fscanf( fpInFile, "|\"%*[^\"]") != 0 ) {
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_NOSKIPNAME, NULL);
        }
        pToken->szName[0] = '\0';
    }

    // Now the name has been read, and we are
    // positioned at the last '"' in the text
    // stream.  Allocate memory for the token
    // text, and read it in.

    fgets( gt_szTextBuffer, sizeof(gt_szTextBuffer), fpInFile);

    // Now that the token text is read in,
    // convert it to whatever character type
    // we are expecting.  First strip the newline!

    StripNewLineA( gt_szTextBuffer);
    cTextLen = lstrlenA( gt_szTextBuffer);

    if ( cTextLen < 4 ) {         // Must be more than "\"]]=" in szTextBuffer
        return ( -2);
    }
    pToken->szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen - 3));

#ifndef UNITOK

    #ifdef RLRES32
    _MBSTOWCS( pToken->szText, gt_szTextBuffer+4, cTextLen - 3, cTextLen - 3);
    #else
    strcpy( pToken->szText, gt_szTextBuffer+4);
    #endif  // RLRES32

#else   // UNITOK
    strcpy( pToken->szText, gt_szTextBuffer+4);
#endif  // UNITOK

    return ( 0);
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  * 01/93 Added new character count field.  MHotchin
  *
  **/


int PutToken(

            FILE  *fpOutFile,   //... Token file to write to
            TOKEN *tToken)      //... Token to be writen to the token file
{
    WORD   rc     = 0;
    PCHAR  pszBuf = NULL;


    ParseTokToBuf( pt_szOutBuffer, tToken);
//    RLFREE( tToken->szText);

#ifdef RLRES32

    if ( ! _WCSTOMBS( szDHW, pt_szOutBuffer, DHWSIZE, lstrlen( pt_szOutBuffer) + 1) ) {
        QuitT( IDS_ENGERR_26, pt_szOutBuffer, NULL);
    }
    pszBuf = szDHW;

#else

    pszBuf = pt_szOutBuffer;

#endif


    return fprintf( fpOutFile, "%s\n", pszBuf);
}


/**
  *  Function: FindToken
  * Finds a token whose status bits match only where the mask is set.
  *
  *  Arguments:
  * fpSearchFile -- search file
  * psTok       -- pointer to the token
  * uMask       -- status bit mask
  *
  *  Returns:
  * string and status of found token
  *
  *  Errors Codes:
  * 0 - token not found
  * 1 - token found
  *
  *  History:
  * 01/93 Added support for var length token text strings.  Previous token text
  *     is de-allocated!  MHotchin
  *
  **/

int FindToken( FILE *fpSearchFile, TOKEN *psTok, WORD wMask)
{
    BOOL  fFound     = FALSE;
    BOOL  fStartOver = TRUE;
    int   error;
    int   nTokensRead = 0;
    long  lStartFilePos, lFilePos;
    TOKEN cTok;

    //... Remember where we are starting

    lFilePos = lStartFilePos = ftell(fpSearchFile);

    do {
        long lType11Pos = 0;


        do {
            lType11Pos = ftell( fpSearchFile);

            error = GetToken( fpSearchFile, &cTok);

            if ( error == 0 ) {
                //... Is this the token we are looking for?

                fFound = ((cTok.wType == psTok->wType)
                          && (cTok.wName == psTok->wName)
                          && (cTok.wID   == psTok->wID)
                          && (cTok.wFlag == psTok->wFlag)
                          && ((WORD)(cTok.wReserved & wMask) == psTok->wReserved)
                          && (_tcscmp( (TCHAR *)cTok.szName,
                                       (TCHAR *)psTok->szName) == 0));
            }

            if ( ! fFound ) {
                //... If we were looking for another segment to
                //... an NT Msg Table entry, move back to the
                //... token we just read and quit (speedup).

                if ( psTok->wType == ID_RT_ERRTABLE
                     && psTok->wFlag > 0
                     && error == 0 ) {
                    if ( cTok.wType != psTok->wType
                         || cTok.wName != psTok->wName
                         || cTok.wID   != psTok->wID
                         || cTok.wFlag  > psTok->wFlag ) {
                        fseek( fpSearchFile, lType11Pos, SEEK_SET);
                        RLFREE( cTok.szText);
                        return ( FALSE);
                    }
                } else if ( error >= 0 ) {
                    lFilePos = ftell(fpSearchFile);

                    if (error == 0) {
                        RLFREE(cTok.szText);
                    }
                } else if (error == -2) {
                    return ( FALSE);
                }
            }

        } while ( ! fFound
                  && (error >= 0)
                  && (fStartOver || (lFilePos < lStartFilePos)) );

        if ( ! fFound && (error == -1) && fStartOver ) {
            rewind(fpSearchFile);
            lFilePos = 0L;
            fStartOver = FALSE;
        }

    } while ( ! fFound && (lFilePos < lStartFilePos) );

    //... Did we find the desired token?
    if ( fFound ) {                           //... Yes, we found it
        psTok->wReserved = cTok.wReserved;

        RLFREE( psTok->szText);
        psTok->szText = cTok.szText;
    }
    return ( fFound);
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  * 01/93 Added support for new token text count.  MHotchin
  *
  **/


void ParseBufToTok( TCHAR *szToken, TOKEN *pTok )
{
    TCHAR *pos;
    WORD  bChars;


    if ( _stscanf( szToken,
                   TEXT("[[%hu|%hu|%hu|%hu|%hu"),
                   &pTok->wType,
                   &pTok->wName,
                   &pTok->wID,
                   &pTok->wFlag,
                   &pTok->wReserved) != 5 ) {
        QuitT( IDS_BADTOK, szToken, NULL);
    }

    if ( pTok->wName == IDFLAG || pTok->wType == ID_RT_ERRTABLE ) {
        //... Find Names's first char and get it's len

        if ( pos = _tcschr( (TCHAR *)szToken, TEXT('"')) ) {
            TCHAR *pStart;

            pStart = ++pos;
            bChars = 0;

            while ( *pos && *pos != TEXT('"')
                    && bChars < TOKENSTRINGBUFFER - 1 ) {
                bChars++;
                pos++;
            } // while

            CopyMemory( pTok->szName, pStart, min( TOKENSTRINGBUFFER, bChars) * sizeof( TCHAR));
            pTok->szName[ bChars ] = TEXT('\0');
        } else {
            //... No token ID found
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVTOKNAME, NULL);
        }
    } else {
        // Don't forget the zero termination
        pTok->szName[0] = TEXT('\0');
    }

    // now do the token text

    pos = _tcschr ((TCHAR *)szToken, TEXT(']'));

    if ( pos ) {

        //  This can be written better now that we know the text length.

        bChars = (WORD)lstrlen( pos);

        if ( bChars > 3 ) {
            pos += 3;
            bChars -= 3;
            pTok->szText = (TCHAR *)FALLOC( MEMSIZE( bChars + 1));
            CopyMemory( pTok->szText, pos, MEMSIZE( bChars + 1));
            // Don't forget the zero termination
            pTok->szText[ bChars] = TEXT('\0');
        } else if ( bChars == 3 ) {
            //... Empty token text
            pTok->szText = (TCHAR *) FALLOC( 0);
        } else {
            //... No token ID found
            QuitT( IDS_ENGERR_05, (LPTSTR)IDS_INVTOKID, NULL);
        }
    } else {
        //... No token ID found
        QuitT( IDS_ENGERR_05, (LPTSTR)IDS_NOTOKID, NULL);
    }
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/


void ParseTokToBuf( TCHAR *szToken, TOKEN *pTok )
{
    *szToken = TEXT('\0');

    if ( pTok != NULL) {
        wsprintf( szToken,
                  TEXT("[[%hu|%hu|%hu|%hu|%hu|\"%s\"]]="),
                  pTok->wType,
                  pTok->wName,
                  pTok->wID,
                  pTok->wFlag,
                  pTok->wReserved,
                  pTok->szName);
        if (pTok->szText)
            lstrcat(szToken, pTok->szText);
    }
}


/**
  *
  *
  *  Function: TokenToTextSize
  *             This calculates the number of characters needed to hold
  *             the text representation of a token.
  *
  *  Arguments:
  *     pTok    The token to measure.
  *
  *  Returns:
  *     int     The number of characters needed to hold the token, not
  *             including a null terminator.  [[%hu|%hu|%hu|%hu|%hu|\"%s\"]]=%s
  *
  *  Errors Codes:
  *     None.
  *
  *  History:
  *     01/18/93        MHotchin        Created.
  *
  **/
int TokenToTextSize( TOKEN *pTok)
{
    int cTextLen;

    cTextLen = (14 +         //  Separators and terminator ( + 1 extra)
                30);         //  Space for 5 numeric fields  (65,535 = 6 chars)

    if ( pTok->szText != NULL ) {

        //  Add space for the Token text
        cTextLen += MEMSIZE( lstrlen( pTok->szText) );

    }

    cTextLen += lstrlen( pTok->szName);

    return ( cTextLen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\version.h ===
#define rmj		1
#define rmm		534
#define rup		1
#define szVerName	""
#define szVerUser	"July 1993"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\toklist.c ===
#include <windows.h>

#include <assert.h>
#include <ctype.h>
#include <malloc.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "windefs.h"
#include "toklist.h"
#include "restok.h"
#include "resread.h"

#include "showerrs.h"

#define	MAXLINE	1024

#ifdef WIN32
extern HINSTANCE   hInst;       // Instance of the main window
#else
extern HWND        hInst;       // Instance of the main window
#endif

extern HWND hListWnd;
extern HWND hMainWnd;
extern HCURSOR hHourGlass;
extern int  nUpdateMode;
extern HWND hStatusWnd;
extern UCHAR szDHW[];

/**
  *
  *
  *  Function:
  *
  *  Returns:
  *
  *  History:
  *     01/92, Implemented.     TerryRu.
  *
  *
  **/

int MatchToken(TOKEN tToken,
               TCHAR * szFindType,
               TCHAR *szFindText,
               WORD wStatus,
               WORD    wStatusMask)
{
    TCHAR szResIDStr[20];

    if (tToken.wType <= 16)
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES + tToken.wType,
                    szResIDStr,
                    TCHARSIN( sizeof(szResIDStr)));
    }
    else
    {
#ifndef UNICODE
        _itoa(tToken.wType,szResIDStr, 10);
#else
        CHAR szTemp[32];
        _itoa(tToken.wType, szTemp, 10);
        _MBSTOWCS( szResIDStr,
                   szTemp,
                   WCHARSIN( sizeof( szResIDStr)),
                   ACHARSIN( lstrlenA(szTemp) + 1));
#endif
    }
    // need to both check because checking szFindType[0]
    // when string is null cause exception
    if (szFindType && szFindType[0])
    {
        if (_tcsicmp((TCHAR *)szFindType, (TCHAR *)szResIDStr))
        {
            return FALSE;
        }
    }

// this has case problems.
// how do I work around this and work with extened characters?

    if ( szFindText && szFindText[0] )
    {
        if (!_tcsstr( (TCHAR *)tToken.szText, (TCHAR *)szFindText))
        {
            return FALSE;
        }
    }

    // if we made it to here,
    // all search criteria exept the status bits have matched.

    return (wStatus ==  (WORD) (wStatusMask & tToken.wReserved));
}

/**
  *
  *
  *  Function: DoTokenSearch
  *     BiDirection token search utility to find tokens.
  *     Search is based on, the status field, token type, and token text.
  *
  *  Paramaters:
  *     *szFindType, type of token to search for.
  *     *szFindText, token text to search for.
  * wStatus, status values to search for
  * wStatusMask, status mask to search with
  *     fDirection, direction to search through tokens 0 = down, 1 = up
  *
  *  Returns:
  *     TRUE, token located and selected.
  *     FALSE token not found.
  *
  *  History:
  * 01/92, Implemented.                     TerryRu.
  * 02/92, mask parameter added                 SteveBl
  * 01/93  Added support for var length token text strings.  MHotchin
  *
  **/

int DoTokenSearch (TCHAR *szFindType,
                   TCHAR *szFindText,
                   WORD  wStatus,
                   WORD wStatusMask,
                   BOOL fDirection,
                   BOOL fSkipFirst)
{

    UINT wLbCount;                      // number of tokens in list box
    LPTSTR lpstrToken;
    int wCurSelection;                  // current selected token.
    UINT wSaveSelection;                // location in token list where the search began
    TOKEN tToken;                       // info of current token
    BOOL fWrapped = FALSE;              // flag to indicate whether we wrapped during the search
    TCHAR *szBuffer;

    // get the number of tokens in the list
    wLbCount = (UINT)SendMessage( hListWnd,
                                  LB_GETCOUNT,
                                  (WPARAM)0,
                                  (LPARAM)0);

    // save the current in the token list
    wCurSelection = (UINT)SendMessage( hListWnd,
                                       LB_GETCURSEL,
                                       (WPARAM)0,
                                       (LPARAM)0);
    wSaveSelection = wCurSelection;

    // check for case where there is no current selection.
    if (wCurSelection == (UINT) -1)
    {
        wSaveSelection = wCurSelection = 0;
    }

    while (TRUE)
    {
        // get current token info in the tToken sturcture

        HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wCurSelection,
                                             (LPARAM)0);
        lpstrToken = (LPTSTR)GlobalLock( hMem);

        if ( lpstrToken )
        {
            szBuffer = (TCHAR *) FALLOC( MEMSIZE( lstrlen( lpstrToken)+1));
            lstrcpy( szBuffer, lpstrToken);
            GlobalUnlock( hMem);

            ParseBufToTok(szBuffer, &tToken);
            RLFREE( szBuffer);

                // is it a match?
            if ( MatchToken( tToken,
                             szFindType,
                             szFindText,
                             wStatus,
                             wStatusMask)
                && ! fSkipFirst)
            {
                    // yes, select and return TRUE
                RLFREE( tToken.szText);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wCurSelection,
                             (LPARAM)0);
                return (TRUE);
            }
            RLFREE( tToken.szText);
        }
        fSkipFirst = FALSE;

        // no, continue search
        if (fDirection)
        {
            // going upward during the search
            if (--wCurSelection < 0)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached beginning of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDBEGIN,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = wLbCount-1;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
        else
        {
            // going downward during the search
            if (++wCurSelection >= (int) wLbCount)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached end of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDEND,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = 0;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
    }
    return FALSE;
}

//.......................................................................

int DoTokenSearchForRledit (TCHAR *szFindType,
                            TCHAR *szFindText,
                            WORD  wStatus,
                            WORD wStatusMask,
                            BOOL fDirection,
                            BOOL fSkipFirst)
{

    UINT      wLbCount;                     // number of tokens in list box
    LPTSTR    lpstrToken;
    int       wCurSelection;                // current selected token.
    UINT      wSaveSelection;               // location in token list where the search began
    TOKEN     tToken;                       // info of current token
    BOOL      fWrapped = FALSE;             // flag to indicate whether we wrapped during the search
    TCHAR     *szBuffer;

    LPTOKDATA lpTokData;

    // get the number of tokens in the list
    wLbCount = (UINT)SendMessage( hListWnd,
                                  LB_GETCOUNT,
                                  (WPARAM)0,
                                  (LPARAM)0);

    // save the current in the token list
    wCurSelection = (UINT)SendMessage( hListWnd,
                                       LB_GETCURSEL,
                                       (WPARAM)0,
                                       (LPARAM)0);
    wSaveSelection = wCurSelection;

    // check for case where there is no current selection.
    if (wCurSelection == (UINT) -1)
    {
        wSaveSelection = wCurSelection = 0;
    }

    while (TRUE)
    {
        // get current token info in the tToken sturcture

        HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wCurSelection,
                                             (LPARAM)0);
	//RLedit has different format data.
        lpTokData = (LPTOKDATA)GlobalLock( hMem );
        lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

        if ( lpstrToken )
        {
            szBuffer = (TCHAR *) FALLOC( MEMSIZE( lstrlen( lpstrToken)+1));
            lstrcpy( szBuffer, lpstrToken);

            GlobalUnlock( lpTokData->hToken );
            GlobalUnlock( hMem);

            ParseBufToTok(szBuffer, &tToken);
            RLFREE( szBuffer);

                // is it a match?
            if ( MatchToken( tToken,
                             szFindType,
                             szFindText,
                             wStatus,
                             wStatusMask)
                && ! fSkipFirst)
            {
                    // yes, select and return TRUE
                RLFREE( tToken.szText);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wCurSelection,
                             (LPARAM)0);
                return (TRUE);
            }
            RLFREE( tToken.szText);
        }
        fSkipFirst = FALSE;

        // no, continue search
        if (fDirection)
        {
            // going upward during the search
            if (--wCurSelection < 0)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached beginning of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDBEGIN,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = wLbCount-1;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
        else
        {
            // going downward during the search
            if (++wCurSelection >= (int) wLbCount)
            {
                LPSTR pszFind  = NULL;
                DWORD dwMsgLen = 0;

                // reached end of the tokens, do we want to wrap

                dwMsgLen = B_FormatMessage((FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                                          | FORMAT_MESSAGE_IGNORE_INSERTS
                                          | FORMAT_MESSAGE_FROM_HMODULE,
                                            NULL,
                                            IDS_REACHEDEND,
                                            szDHW,
                                            DHWSIZE,
                                            NULL);
                pszFind = szDHW + dwMsgLen + 2;

                B_FormatMessage( (FORMAT_MESSAGE_MAX_WIDTH_MASK & 78)
                               | FORMAT_MESSAGE_IGNORE_INSERTS
                               | FORMAT_MESSAGE_FROM_HMODULE,
                                 NULL,
                                 IDS_FINDTOKENS,
                                 pszFind,
                                 DHWSIZE - dwMsgLen - 2,
                                 NULL);
                if ( nUpdateMode == 0
                  && wSaveSelection != wLbCount
                  && !fWrapped
                  && (MessageBoxA( hMainWnd,
                                   szDHW,
                                   pszFind,
                                   MB_ICONQUESTION | MB_YESNO) == IDYES) )
                {
                    // yes, so wrap and reset counters
                    fWrapped = TRUE;
                    wCurSelection = 0;
                    wLbCount = wSaveSelection;
                }
                // no, so return FALSE
                else
                {
                    break;
                }
            }
        }
    }
    return FALSE;
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

#ifdef NO
void FindAllDirtyTokens(void)
{
    int wSaveSelection;
    extern int wIndex;
    LONG lListParam = 0L;

    // set listbox selection to begining of the token list
    wSaveSelection = SendMessage( hListWnd, LB_GETCURSEL, 0 , 0L);

    wIndex = 0;
    SendMessage(hListWnd, LB_SETCURSEL, wIndex, 0L);

    while (DoTokenSearch (NULL, NULL, ST_TRANSLATED | ST_DIRTY , NULL))
    {
        // go into edit mode
        wIndex = (UINT) SendMessage(hListWnd, LB_GETCURSEL, 0 , 0L);

        lListParam  = MAKELONG(NULL, LBN_DBLCLK);
        SendMessage(hMainWnd, WM_COMMAND, IDC_LIST, lListParam);

        // move selection to next token
        wIndex++;
        SendMessage(hListWnd, LB_SETCURSEL, wIndex, 0L);
    }
    wIndex = wSaveSelection;
    SendMessage(hListWnd, LB_SETCURSEL, wIndex, 0L);
}


#endif

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/
TCHAR FAR *FindDeltaToken(TOKEN tToken,
                          TOKENDELTAINFO FAR *pTokenDeltaInfo,
                          UINT wStatus)
{
    TOKENDELTAINFO FAR *ptTokenDeltaInfo;
    int found;
    ptTokenDeltaInfo = pTokenDeltaInfo;

    while (ptTokenDeltaInfo)
    {
        found = ((tToken.wType == ptTokenDeltaInfo->DeltaToken.wType)
              && (tToken.wName == ptTokenDeltaInfo->DeltaToken.wName)
              && (tToken.wID == ptTokenDeltaInfo->DeltaToken.wID)
              && (tToken.wFlag == ptTokenDeltaInfo->DeltaToken.wFlag)
              && (wStatus  == (UINT)ptTokenDeltaInfo->DeltaToken.wReserved)
#ifdef UNICODE
              && !_tcscmp((TCHAR FAR *)tToken.szName,
                          (TCHAR *)ptTokenDeltaInfo->DeltaToken.szName)
#else
//                 !lstrcmp((TCHAR FAR *)tToken.szName,
//                          (TCHAR *)ptTokenDeltaInfo->DeltaToken.szName)
              && CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                 SORT_STRINGSORT,
                                 tToken.szName,
                                 -1,
                                 ptTokenDeltaInfo->DeltaToken.szName,
                                 -1) == 2
#endif

                 );

        if (found)
        {
            return ((TCHAR FAR *)ptTokenDeltaInfo->DeltaToken.szText);
        }
        ptTokenDeltaInfo = ptTokenDeltaInfo->pNextTokenDelta;
    }

    // token not found in token delta info
    return NULL;
}

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/
TOKENDELTAINFO  FAR *UpdateTokenDeltaInfo(TOKEN *pDeltaToken)
{
    TOKENDELTAINFO FAR *pTokenDeltaInfo = NULL;
    int cTextLen;

    if ( pDeltaToken )
    {
        pTokenDeltaInfo = (TOKENDELTAINFO FAR *)FALLOC( sizeof( TOKENDELTAINFO));

        if ( pTokenDeltaInfo )
        {
            memcpy( (void *)&(pTokenDeltaInfo->DeltaToken),
                    (void *)pDeltaToken,
                    sizeof( TOKEN));

            cTextLen = lstrlen( pDeltaToken->szText) + 1;
            pTokenDeltaInfo->DeltaToken.szText =
                                    (TCHAR *)FALLOC( MEMSIZE( cTextLen));
            memcpy( (void *)pTokenDeltaInfo->DeltaToken.szText,
                    (void *)pDeltaToken->szText,
                    MEMSIZE( cTextLen));
            pTokenDeltaInfo->pNextTokenDelta = NULL;
        }
    }
    return(pTokenDeltaInfo);
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *    02/93 - changed to use GetToken, rather that reading directly
  *             from the file.  This provides support for long token
  *             text.  MHotchin.
  *
  **/

TOKENDELTAINFO  FAR *InsertTokMtkList(FILE * fpTokFile, FILE *fpMtkFile )
{
    int rcFileCode;
    TOKENDELTAINFO FAR * ptTokenDeltaInfo, FAR * pTokenDeltaInfo = NULL;
    TOKEN tToken;
    UINT wcChars = 0;
    HANDLE         hTokData;
    LPTSTR         lpstrToken;
    LPSTR        lpstrDmy=0;
    LPTOKDATA    lpstrTokData=0;

    rewind(fpTokFile);

    rewind( fpMtkFile );

//only make Dmy buffer
    lpstrDmy = (LPSTR)FALLOC( MEMSIZE(MAXLINE) );


    while ((rcFileCode = GetToken(fpTokFile, &tToken)) >= 0)
    {
        if (rcFileCode == 0)
        {

//For fast moving, save Mtk position
//Create Data
            hTokData = GlobalAlloc( GMEM_MOVEABLE, sizeof(TOKDATA) );
            if( !hTokData ){
                RLFREE(tToken.szText);
                RLFREE( lpstrDmy );
                QuitA( IDS_ENGERR_16, (LPSTR)IDS_ENGERR_11, NULL);
            }
            lpstrTokData = (LPTOKDATA)GlobalLock( hTokData );

//MtkFilePointer get
            if( (lpstrTokData->lMtkPointer=ftell(fpMtkFile)) >= 0 ){
                TOKEN    cToken, ccToken;
                BOOL    fFound;
                if( !GetToken(fpMtkFile,&cToken) )
                {
                    RLFREE(cToken.szText);

                    if( cToken.wReserved & ST_CHANGED ){
                        if( !GetToken(fpMtkFile,&ccToken) )
                        {
                            RLFREE(ccToken.szText);
                            fFound = ((cToken.wType ==ccToken.wType)
                                   && (cToken.wName == ccToken.wName)
                                   && (cToken.wID   == ccToken.wID)
                                   && (cToken.wFlag == ccToken.wFlag)
                                   && (_tcscmp((TCHAR *)cToken.szName,
                                       (TCHAR *)ccToken.szName) == 0));
                            fseek( fpMtkFile,
                                lpstrTokData->lMtkPointer, SEEK_SET);
                            fgets( lpstrDmy, MAXLINE, fpMtkFile );
                            if( fFound )
                                fgets( lpstrDmy, MAXLINE, fpMtkFile );
                        }
                    }
                }
            }

            if(tToken.wReserved & ST_TRANSLATED)
            {
                TCHAR *szTokBuf;

                szTokBuf = (TCHAR *) FALLOC(MEMSIZE(TokenToTextSize(&tToken)));
                ParseTokToBuf(szTokBuf, &tToken);

                // only add tokens with the translated status bit set to the token list
                lpstrTokData->hToken = GlobalAlloc(GMEM_MOVEABLE,
                    MEMSIZE(lstrlen((TCHAR *)szTokBuf)+1));

                if (!lpstrTokData->hToken){
                    RLFREE(tToken.szText);                    // MHotchin
                    RLFREE(szTokBuf);
                    RLFREE( lpstrDmy );
                    QuitA(IDS_ENGERR_16, (LPSTR)IDS_ENGERR_11, NULL);
                }

                lpstrToken = (LPTSTR) GlobalLock( lpstrTokData->hToken );
                lstrcpy (lpstrToken, szTokBuf);
                GlobalUnlock( lpstrTokData->hToken );
                GlobalUnlock( hTokData );
                RLFREE(szTokBuf);

                if( SendMessage(hListWnd,LB_ADDSTRING,0,(LONG_PTR)hTokData) < 0){
                    RLFREE(tToken.szText);                    // MHotchin
                    RLFREE( lpstrDmy );
                    QuitA (IDS_ENGERR_16, (LPSTR)IDS_ENGERR_11, NULL);
                }
            }
            else
            {
                // the current token is delta info so save in delta list.
                if (!pTokenDeltaInfo){
                    ptTokenDeltaInfo = pTokenDeltaInfo =
                        UpdateTokenDeltaInfo(&tToken);
                }
                else{
                    ptTokenDeltaInfo->pNextTokenDelta =
                        UpdateTokenDeltaInfo(&tToken);
                    ptTokenDeltaInfo = ptTokenDeltaInfo->pNextTokenDelta;
                }
//don't use TokData
                GlobalUnlock( hTokData );
                GlobalFree( hTokData );
            }

            RLFREE(tToken.szText);                    // MHotchin
        }
    }

    RLFREE( lpstrDmy );
    return(pTokenDeltaInfo);

}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/
void GenStatusLine( TOKEN *pTok)
{
    TCHAR szName[32];
    TCHAR szStatus[20];
#ifdef UNICODE
    CHAR  szTmpBuf[32];
#endif //UNICODE
    TCHAR szResIDStr[20];
    static BOOL fFirstCall = TRUE;

    if (fFirstCall)
    {
        SendMessage( hStatusWnd,
                     WM_FMTSTATLINE,
                     (WPARAM)0,
                     (LPARAM)TEXT("15s7s4i5s4i"));
        fFirstCall = FALSE;
    }

    if (pTok->szName[0])
    {
        lstrcpy( szName, pTok->szName);
    }
    else
    {
#ifdef UNICODE
        _itoa(pTok->wName, szTmpBuf, 10);
        _MBSTOWCS( szName,
                   szTmpBuf,
                   WCHARSIN( sizeof( szTmpBuf)),
                   ACHARSIN( lstrlenA( szTmpBuf) + 1));
#else
        _itoa(pTok->wName, szName, 10);
#endif
    }

    if (pTok->wReserved & ST_READONLY)
    {
        LoadString( hInst, IDS_READONLY, szStatus, TCHARSIN( sizeof( szStatus)));
    }
    else if (pTok->wReserved & ST_DIRTY)
    {
        LoadString( hInst, IDS_DIRTY, szStatus, TCHARSIN( sizeof( szStatus)));
    }
    else
    {
        LoadString( hInst, IDS_CLEAN, szStatus, TCHARSIN( sizeof( szStatus)));
    }

    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)3, (LPARAM)szStatus);

    if (pTok->wType <= 16)
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES+pTok->wType,
                    szResIDStr,
                    TCHARSIN( sizeof( szResIDStr)));
    }
    else
    {

#ifdef UNICODE
        _itoa(pTok->wType, szTmpBuf, 10);
        _MBSTOWCS( szResIDStr,
                   szTmpBuf,
                   WCHARSIN( sizeof( szTmpBuf)),
                   ACHARSIN( lstrlenA( szTmpBuf) + 1));
#else
        _itoa(pTok->wType, szResIDStr, 10);
#endif
    }
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)0,
                 (LPARAM)szName);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)1,
                 (LPARAM)szResIDStr);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)2,
                 (LPARAM)pTok->wID);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)4,
                 (LPARAM)lstrlen( pTok->szText));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\update.h ===
#ifndef _UPDATE_H_
#define _UPDATE_H_


////int PrepareUpdate(CHAR *szResourceFile,CHAR *szMasterTokenFile);
    int Update(CHAR *szMasterTokenFile, CHAR *szLanguageTokenFile);
////int Switch(TCHAR *szValue, CHAR *szTokenFile);


#endif // _UPDATE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\update.c ===
/** Update.c
  *
  * Resource update tool.
  *
  * Written by SteveBl
  *
  * Exported Functions:
  * int PrepareUpdate(TCHAR *szResourcePath,TCHAR *szMasterTokenFile);
  *
  * int Update(TCHAR *szMasterTokenFile, TCHAR *szLanguageTokenFile);
  *
  * History:
  * Initial version written January 31, 1992.  -- SteveBl
  **/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <io.h>
#include <string.h>
#include <tchar.h>

#include "windefs.h"
#include "restok.h"
#include "custres.h"
#include "update.h"
#include "resread.h"

extern char *gszTmpPrefix;
extern UCHAR szDHW[];


/** Function: Update
  * Updates a language token file from a master token file.
  * This step should be executed after a Prepare Update.
  *
  * Arguments:
  * szMasterTokenFile, token file created by PrepareUpdate.
  * szLanguageTokenFile, token file to be updated with new tokens.
  *
  * Returns:
  * updated token file
  *
  * Error Codes:
  * 0  - successfull execution
  * !0 - error
  *
  * History:
  * 1/92 - initial implementation -- SteveBl
  **/

int Update(

CHAR *szMasterTokenFile,    //... Master token file to update from.
CHAR *szLanguageTokenFile)  //... Token file to update or create.
{
    FILE *pfMTK = NULL;
    FILE *pfTOK = NULL;
    FILE *pfTmpTOK = NULL;
    int rc = 0;
    static TOKEN MstrTok;
    static TOKEN LangTok;
    static CHAR szTempTok[ MAX_PATH+1];
    

    MstrTok.szText = NULL;
    LangTok.szText = NULL;

    rc = MyGetTempFileName( 0, "", 0, szTempTok);
    
    pfMTK = FOPEN( szMasterTokenFile, "rt");

    if ( pfMTK == NULL )
    {
        QuitA( IDS_ENGERR_01, "Master token", szMasterTokenFile);
    }

    rc = _access( szLanguageTokenFile, 0);

    if ( rc != 0 )
    {
                                // Token file does not exist CREAT IT
        
        if ( (pfTOK = FOPEN( szLanguageTokenFile, "wt")) == NULL )
        {
            FCLOSE( pfMTK);
            QuitA( IDS_ENGERR_02, szLanguageTokenFile, NULL);
        }
        
        do
        {
            rc = GetToken( pfMTK, &MstrTok);
            
                                // If rc > 0, empty line or comment found
                                // and will not be copied to token file.

            if ( rc == 0 )
            {
                if ( *(MstrTok.szText) == TEXT('\0') ) // Empty token  (PW)
                {
                                // Do not mark empty token as DIRTY
                    
                    MstrTok.wReserved = ST_TRANSLATED;
                }
                else
                {
                    if (MstrTok.wReserved == ST_READONLY)
                    {
                        MstrTok.wReserved = ST_TRANSLATED | ST_READONLY;
                    }
                    else
                    {
                        MstrTok.wReserved = ST_TRANSLATED | ST_DIRTY;
                    }
                }                
                PutToken( pfTOK, &MstrTok);
                RLFREE( MstrTok.szText);
            }

        } while ( rc >= 0 );
        
        FCLOSE( pfMTK);
        FCLOSE( pfTOK);
        
        if ( rc == -2 )
        {
            QuitT( IDS_ENGERR_11, (LPTSTR)IDS_UPDMODE, NULL);
        }
    }
    else
    {                           // file exists -- UPDATE IT
        
        pfTOK = FOPEN(szLanguageTokenFile, "rt");

        if ( pfTOK == NULL)
        {
            FCLOSE( pfMTK);
            QuitA( IDS_ENGERR_01, "Language token", szLanguageTokenFile);
        }
        
        pfTmpTOK = FOPEN(szTempTok, "wt");

        if ( pfTmpTOK == NULL)
        {
            FCLOSE( pfMTK);
            FCLOSE( pfTOK);
            QuitA( IDS_ENGERR_02, szTempTok, NULL);
        }
        
        do
        {
            rc = GetToken( pfTOK, &LangTok);
            
                                // If rc > 0, empty line or comment found
                                // and will not be copied to token file.

            if ( rc == 0 )
            {
                if ( LangTok.wReserved & ST_TRANSLATED )
                {
                    PutToken( pfTmpTOK, &LangTok);
                }
                RLFREE( LangTok.szText);
            }

        } while ( rc >= 0 );
        
        FCLOSE( pfTOK);
        FCLOSE( pfTmpTOK);
        
        if( rc == -2 )
        {
            QuitT( IDS_ENGERR_11, (LPTSTR)IDS_UPDMODE, NULL);
        }
        
        pfTmpTOK = FOPEN(szTempTok, "rt");

        if ( pfTmpTOK == NULL )
        {
            FCLOSE( pfMTK);
            QuitA( IDS_ENGERR_01, "temporary token", szTempTok);
        }
        
        pfTOK = FOPEN(szLanguageTokenFile, "wt");

        if ( pfTOK == NULL )
        {
            FCLOSE( pfMTK);
            FCLOSE( pfTOK);
            QuitA( IDS_ENGERR_02, szLanguageTokenFile, NULL);
        }
        
        do
        {
            rc = GetToken( pfMTK, &MstrTok);
            
                                // If rc > 0, empty line or comment found
                                // and will not be copied to token file.

            if ( rc == 0 )
            {
                int fTokenFound = 0;
                
                LangTok.wType     = MstrTok.wType;
                LangTok.wName     = MstrTok.wName;
                LangTok.wID       = MstrTok.wID;
                LangTok.wFlag     = MstrTok.wFlag;
                LangTok.wLangID   = MstrTok.wLangID;
                LangTok.wReserved = ST_TRANSLATED;
				LangTok.szText    = NULL;

                lstrcpy( LangTok.szType, MstrTok.szType);
                lstrcpy( LangTok.szName, MstrTok.szName);
                
                if ( MstrTok.wReserved & ST_READONLY )
                {
                    fTokenFound = 1;
                    LangTok.szText = (TCHAR *)FALLOC( 0);
                }
                else if ( MstrTok.wReserved != ST_CHANGED )
                {
                    fTokenFound = FindToken( pfTmpTOK, &LangTok, ST_TRANSLATED);
                }
                
                if ( fTokenFound )
                {
                    if ( MstrTok.wReserved & ST_READONLY )
                    {
                                // token marked read only in token file and
                                // this token is not an old token
                        
                        MstrTok.wReserved = ST_READONLY | ST_TRANSLATED;
                        
                        PutToken( pfTOK, &MstrTok);
                    }
                    else if ( MstrTok.wReserved & ST_NEW )
                    {
                                // flagged as new but previous token existed
                        
                        if ( LangTok.szText[0] == TEXT('\0') )
                        {
                                // Put new text in token, easier for
                                // the localizers to see.

                            RLFREE( LangTok.szText);
                            LangTok.szText =
                                (TCHAR *) FALLOC(
                                         MEMSIZE( lstrlen( MstrTok.szText)+1));
                            lstrcpy( LangTok.szText, MstrTok.szText);                            
                        }
                        LangTok.wReserved = ST_TRANSLATED|ST_DIRTY;
                        
                        PutToken( pfTOK, &LangTok);
                        
                                // write out as a new untranslated token
                        
                        MstrTok.wReserved = ST_NEW;
                        
                        PutToken( pfTOK, &MstrTok);
                    }
                    else if ( MstrTok.wReserved & ST_CHANGED )
                    {
                                // Language token is empty, but new
                                // token contains text.
                        
                        if ( MstrTok.wReserved == (ST_CHANGED | ST_NEW) )
                        {
                            
                            if ( LangTok.szText[0] == TEXT('\0') )
                            {
                                RLFREE( LangTok.szText);
                                LangTok.szText = (TCHAR *)
                                    FALLOC(
                                        MEMSIZE( lstrlen( MstrTok.szText)+1));
                                
                                lstrcpy( LangTok.szText, MstrTok.szText);
                            }
                            LangTok.wReserved = ST_DIRTY|ST_TRANSLATED;
                            
                            PutToken( pfTOK, &LangTok);
                        }
                                // only write old token once
                        
                        MstrTok.wReserved &= ST_NEW;
                        
                        PutToken( pfTOK, &MstrTok);
                    }
                    else
                    {
                                // token did not change at all
                        
								//If align info was added into Mtk, add it to Tok also.
                        int l1, r1, t1, b1, l2, r2, t2, b2;
                        TCHAR   a1[20], a2[20], *ap;

                                                   //Cordinates token?
                        if ( (LangTok.wType == ID_RT_DIALOG)
						    && (LangTok.wFlag&ISCOR)
                                                   //Not including align info?
                            && _stscanf( LangTok.szText, TEXT("%d %d %d %d %s"),
						        		&l1,&r1,&t1,&b1,a1) == 4
                                                   //Including align info?
                            && _stscanf( MstrTok.szText, TEXT("%d %d %d %d %s"),
                                		&l2,&r2,&t2,&b2,a2) == 5 
                            && (ap = _tcschr( MstrTok.szText,TEXT('('))) )
                        {
                            RLFREE( LangTok.szText );
                            LangTok.szText = (TCHAR *)FALLOC(
                                        MEMSIZE( _tcslen( MstrTok.szText)+1));
                            _stprintf( LangTok.szText,
                                TEXT("%4hd %4hd %4hd %4hd %s"), l1, r1, t1, b1, ap );
                        }
								//If LangToken is Version stamp and szTexts is "Translation",
								//it is 1.0 version format. So Translate it.
                        if ( LangTok.wType == ID_RT_VERSION
                            && ! _tcscmp( LangTok.szText, TEXT("Translation")) )
                        {
                            
                            _stprintf( LangTok.szText, 
                            		  TEXT("%04x 04b0"), 
                            		  GetUserDefaultLangID());
                        }
                        PutToken( pfTOK, &LangTok);
                    }
                    RLFREE( LangTok.szText);
                }
                else
                {
                                // BRAND NEW TOKEN
                    
                                // write out any token but a changed mstr token.
                    
                    if ( MstrTok.wReserved != ST_CHANGED )
                    {
                                // do not write out old changed tokens if
                                // there is no token in target
                        
                        if ( MstrTok.wReserved == ST_READONLY )
                        {
                            MstrTok.wReserved = ST_TRANSLATED | ST_READONLY;
                        }
                        else
                        {
								//If MstrTok is Version stamp and there are 1.0 format Version stamp,
								//insert 1.0 version stamp by 1.7 format but flag should be TRANSLATED. 
                            if ( MstrTok.wType == ID_RT_VERSION )
                            {
                                LangTok.szText = NULL;
                                LangTok.wFlag = 1;
                                _tcscpy( LangTok.szName, TEXT("VALUE") );
																
                                if ( FindToken( pfTmpTOK, &LangTok, ST_TRANSLATED))
                                {
                                    MstrTok.wReserved = ST_TRANSLATED;
                                    RLFREE( MstrTok.szText );
                                    MstrTok.szText = LangTok.szText;
                                }
								else
								    MstrTok.wReserved = ST_TRANSLATED|ST_DIRTY;
                             }
                             else
                                MstrTok.wReserved = ST_TRANSLATED|ST_DIRTY;
                        }
                        
                        if ( MstrTok.szText[0] == 0 )
                        {
                            MstrTok.wReserved = ST_TRANSLATED;
                        }
                        PutToken( pfTOK, &MstrTok);
                    }
                }
                RLFREE( MstrTok.szText);
            }

        } while ( rc >= 0 );
        
        FCLOSE( pfMTK);
        FCLOSE( pfTmpTOK);
        FCLOSE( pfTOK);
        
        
        if ( rc == -2 )
        {
            QuitT( IDS_ENGERR_11, (LPTSTR)IDS_UPDMODE, NULL);
        }
        remove( szTempTok);
    }
    return( 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\toklist.h ===
#ifndef _TOKLIST_H_
#define _TOKLIST_H_

#include "tokenapi.h"

typedef struct _TOKENDELTAINFO
{
    TOKEN       DeltaToken;
    struct _TOKENDELTAINFO  FAR *  pNextTokenDelta;
} TOKENDELTAINFO;

typedef struct _TRANSLIST
{
    TCHAR * sz;
    struct _TRANSLIST * pPrev;
    struct _TRANSLIST * pNext;
} TRANSLIST;

typedef struct _TOKDATA
    {
    long	lMtkPointer;
    HANDLE	hToken;
}TOKDATA, *PTOKDATA, NEAR *NPTOKDATA, FAR *LPTOKDATA;

int MatchToken(TOKEN tToken,
               TCHAR * szFindType,
               TCHAR *szFindText,
               WORD wStatus,
               WORD    wStatusMask);
int DoTokenSearch (TCHAR *szFindType,
                   TCHAR *szFindText,
                   WORD  wStatus,
                   WORD wStatusMask,
                   BOOL fDirection,
                   BOOL fSkipFirst);

int DoTokenSearchForRledit (TCHAR *szFindType,
                            TCHAR *szFindText,
                            WORD  wStatus,
                            WORD wStatusMask,
                            BOOL fDirection,
                            BOOL fSkipFirst);

TCHAR FAR *FindDeltaToken(TOKEN tToken,
                          TOKENDELTAINFO FAR *pTokenDeltaInfo,
                          UINT wStatus);
TOKENDELTAINFO  FAR *UpdateTokenDeltaInfo(TOKEN *pDeltaToken);

TOKENDELTAINFO  FAR *InsertTokMtkList(FILE * fpTokFile, FILE *fpMtkFile);

void GenStatusLine(TOKEN *pTok);

#endif // _TOKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\toktrans.c ===
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <tchar.h>

#ifdef RLDOS
#include "dosdefs.h"
#else
#include "windefs.h"
#endif

#include "restok.h"
#include "resread.h"
#include "toklist.h"
#include "commbase.h"


#define MAXLINE     1024
#define MAXTERM     512


extern UCHAR szDHW[];
extern PROJDATA gProj;
extern MSTRDATA gMstr;

#ifdef WIN32
extern HINSTANCE   hInst;       // Instance of the main window
#else
extern HWND        hInst;       // Instance of the main window
#endif

static fUnicodeGlossary = FALSE;


static long   GetGlossaryIndex( FILE *,  TCHAR, long []);
static void   ParseGlossEntry( TCHAR *, TCHAR *, TCHAR[], TCHAR *, TCHAR[]);
static void   ParseTextHotKeyToBuf( TCHAR *, TCHAR, TCHAR *);
static void   ParseBufToTextHotKey( TCHAR *, TCHAR[], TCHAR *);
static WORD   NormalizeIndex( TCHAR);
static int    MyPutGlossStr( TCHAR *, FILE *);
static TCHAR *MyGetGlossStr( TCHAR *, int, FILE *);
static void   BuildGlossEntry( TCHAR *, TCHAR *, TCHAR, TCHAR *, TCHAR);
static BOOL   NotAMember( TRANSLIST *, TCHAR *);




FILE * OpenGlossary( CHAR *szGlossFile, CHAR chAccessType)
{
    CHAR * szRW[4] = {"rb", "rt", "wb", "wt"};
    int nRW = 0;            // assume access type is 'r' (read)
    FILE *fpRC = NULL;

    if ( chAccessType == 'w' )          // is access type 'w' (write)?
    {
        nRW = fUnicodeGlossary ? 2 : 3; // yes (Unicode file or not?)
    }
    fpRC = fopen( szGlossFile, szRW[ nRW]);

    if ( fpRC && chAccessType == 'r' )
    {
        USHORT usMark = GetWord( fpRC, NULL);

        if ( usMark == 0xfeff )
        {
            fUnicodeGlossary = TRUE;            // it's a Unicode text file
        }
        else if ( usMark == 0xfffe )
        {
            QuitA( IDS_WRONGENDIAN, szGlossFile, NULL);
        }
        else
        {
            fclose( fpRC);
            fpRC = fopen( szGlossFile, szRW[ ++nRW]); // it's an ANSI text file
        }
    }
    return( fpRC);
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

int MakeGlossIndex( LONG * lFilePointer)
{
    TCHAR szGlossEntry[MAXLINE] = TEXT("");
    WORD  iCurrent  =  0;
    LONG  lFPointer = -1;
    FILE *pFile  = NULL;


    pFile = OpenGlossary( gProj.szGlo, 'r');

    if ( pFile == NULL )
    {
        return( 1);
    }

    // Glossaries some times have this bogus header at the begining.
    // which we want to skip if it exists


    if ( ! MyGetGlossStr( szGlossEntry, MAXLINE, pFile) )
    {
        // Error during first read from the glossary.
        fclose( pFile);
        return( 1);
    }
    lFPointer = ftell( pFile);

    // check for glossary header

    if ( lstrlen( szGlossEntry) >= 7 )
    {
//        lstrcpy( (TCHAR *)szDHW, szGlossEntry);
//        szDHW[ MEMSIZE( 7)] = szDHW[ MEMSIZE( 7) + 1] = '\0';
//        CharLower( (TCHAR *)szDHW);
//
//        if ( lstrcmp( (TCHAR *)szDHW, TEXT("english")) == 0 )
        if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                             SORT_STRINGSORT | NORM_IGNORECASE,
                             szGlossEntry,
                             7,
                             TEXT("ENGLISH"),
                             7) == 2 )
       {
            lFPointer = ftell (pFile);

            if (  ! MyGetGlossStr( szGlossEntry, MAXLINE, pFile) )
            {
                fclose( pFile);
                return (1);
            }
        }
    }

    // now assume we are at the correct location in glossary
    // file to begin generating the index, we want to save
    // this location

    lFilePointer[0] = lFPointer;

    // glossary file is sorted so,  any non letter items
    // in the glossary would be first. Index into this location
    // using the 1st position

    // 1st lets make sure we have non letters items in
    // the glossary

    // now skip ( if any ) the non letter entries in the glossary


    while( (WORD) szGlossEntry[0] < (WORD) TEXT('A' ) )
    {
        if ( ! MyGetGlossStr( szGlossEntry, MAXLINE, pFile) )
        {
            fclose( pFile);
            return( 1);
        }
    }

    // now position at alpha characters

    iCurrent = NormalizeIndex( szGlossEntry[0] );

    // now we read through the remaining glossary entries
    // and save the offsets for each index as we go

    do
    {
        if ( NormalizeIndex( szGlossEntry[0] ) > iCurrent )
        {
            // we passed the region for our current index
            // so save the location, and move to the next index.
            // note we may be skiping indexs,

            lFilePointer[ iCurrent] = lFPointer;
            iCurrent = NormalizeIndex( szGlossEntry[0] );
        }

        lFPointer = ftell( pFile );
        // otherwise the current index is valied for this
        // section of the glossary indexes, so just continue

    } while ( MyGetGlossStr( szGlossEntry, MAXLINE, pFile) );

    fclose( pFile);
    return( 0);
}


 /**
  *
  *
  *  Function: TransString
  * Builds a circular linked list containing all translations of a string.
  * The first entry in the list is the untranslated string.
  *
  *  Arguments:
  * fpGlossFile, handle to open glossary file
  * szKeyText, string with the text to build translation table
  * szCurrentText, text currently in the box.
  * ppTransList, pointer to a pointer to a node in a circular linked list
  * lFilePointer, pointer to index table for glossary file
  *
  *  Returns:
  * number of nodes in list
  *
  *  Errors Codes:
  *
  *  History:
  * Recoded by SteveBl, 3/92
  *
  **/

/* Translate the string, if possible. */

int TransString(

TCHAR      *szKeyText,
TCHAR      *szCurrentText,
TRANSLIST **ppTransList,
LONG       *lFilePointer)
{
    int  n = 0;
    long lFileIndex;
    TRANSLIST **ppCurrentPointer;
    static TCHAR  szGlossEntry[MAXLINE];
    static TCHAR  szEngText[260];
    static TCHAR  szIntlText[260];
    TCHAR *szCurText = NULL;
    TCHAR  cEngHotKey  = TEXT('\0');
    TCHAR  cIntlHotKey = TEXT('\0');
    TCHAR  cCurHotKey  = TEXT('\0');
    FILE  *fpGlossFile = NULL;

                                // *Is* there a glossary file?

    if ( (fpGlossFile = OpenGlossary( gProj.szGlo, 'r')) == NULL )
    {
        return( 0);
    }

    // FIRST let's erase the list
    if ( *ppTransList )
    {
        (*ppTransList)->pPrev->pNext = NULL; // so we can find the end of the list
    }

    while ( *ppTransList )
    {
        TRANSLIST *pTemp;

        pTemp = *ppTransList;
        *ppTransList = pTemp->pNext;
        RLFREE( pTemp->sz);
        RLFREE( pTemp);
    }
    ppCurrentPointer = ppTransList;

    // DONE removing the list
    // Now make the first node (which is the untranslated string)
    {
        TCHAR * psz;
        psz = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szCurrentText) + 1));


        lstrcpy( psz,szCurrentText);
        *ppTransList = ( TRANSLIST *)FALLOC( sizeof( TRANSLIST));
        (*ppTransList)->pPrev = (*ppTransList)->pNext = *ppTransList;
        (*ppTransList)->sz = psz;
        ppCurrentPointer = ppTransList;
        n++;
    }
    szCurText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( szKeyText) + 1) );

    ParseBufToTextHotKey(  szCurText, &cCurHotKey, szKeyText);

    lFileIndex = GetGlossaryIndex( fpGlossFile, szCurText[0], lFilePointer);

    fseek (fpGlossFile, lFileIndex, SEEK_SET);

    while ( TRUE)
    {
        if ( ! MyGetGlossStr( szGlossEntry, MAXLINE, fpGlossFile) )
        {
            // Reached end of glossary file
            RLFREE( szCurText);
            fclose( fpGlossFile);
            return n;
        }
        ParseGlossEntry( szGlossEntry,
                         szEngText,
                         &cEngHotKey,
                         szIntlText,
                         &cIntlHotKey);

        // make comparision, using text, and hot keys

//        if ( ( ! lstrcmp( szCurText, szEngText )) && cCurHotKey == cEngHotKey )
        if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                         SORT_STRINGSORT,
                                         szCurText,
                                         -1,
                                         szEngText,
                                         -1) == 2
          && cCurHotKey == cEngHotKey )
        {
            TCHAR * psz;
            static TCHAR szTemp[ MAXINPUTBUFFER];

            // we have a match, put translated text into token
            if ( cIntlHotKey )
            {
                ParseTextHotKeyToBuf( szIntlText, cIntlHotKey, szTemp);
            }
            else
            {
                lstrcpy( szTemp, szIntlText);
            }

            if ( NotAMember( *ppTransList, szTemp) )
            {
                // add matched glossary text to circular list of matches

                psz = (TCHAR *) FALLOC( MEMSIZE( lstrlen( szTemp) + 1));

                lstrcpy( psz,szTemp);

                (*ppCurrentPointer)->pNext = (TRANSLIST *)
                                                FALLOC( sizeof( TRANSLIST));

                ((*ppCurrentPointer)->pNext)->pPrev = *ppCurrentPointer;
                ppCurrentPointer = (TRANSLIST **)&((*ppCurrentPointer)->pNext);
                (*ppCurrentPointer)->pPrev->pNext = *ppCurrentPointer;
                (*ppCurrentPointer)->pNext = *ppTransList;
                (*ppTransList)->pPrev = *ppCurrentPointer;
                (*ppCurrentPointer)->sz = psz;
                ++n;
            }
        }
        else
        {
            // can we terminate search?
//            if(  lstrcmpi( szEngText, szCurText ) > 0 )
            if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                             SORT_STRINGSORT,
                                             szEngText,
                                             -1,
                                             szCurText,
                                             -1) == 3 )
            {
                // went past index section
                RLFREE( szCurText);
                fclose( fpGlossFile);
                return( n);
            }
        }
    }
    RLFREE( szCurText);
    fclose( fpGlossFile);

    return( n);
}               // TransString


/**
  *
  *
  *  Function: NormalizeIndex
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/


static WORD NormalizeIndex( TCHAR chIndex )
{
    TCHAR chTmp = chIndex;

    CharLowerBuff( &chTmp, 1);

    return( (chTmp != TEXT('"') && chTmp >= TEXT('a') && chTmp <= TEXT('z'))
            ? chTmp - TEXT('a') + 1
            : 0);
}



/*
 * Function:NotAMember
 *
 * Arguments:
 *  pList, pointer to a TRANSLIST node
 *  sz, string to find
 *
 * Returns:
 *  TRUE if not found in the list else FALSE
 *
 * History:
 *  3/92, implemented       SteveBl
 **/

static BOOL NotAMember( TRANSLIST *pList, TCHAR *sz)
{
    TRANSLIST *pCurrent = pList;

    if ( ! pList )
    {
        return( TRUE);  // empty list
    }

    do
    {
//        if ( lstrcmp( sz, pCurrent->sz) == 0 )
        if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                             SORT_STRINGSORT,
                             sz,
                             -1,
                             pCurrent->sz,
                             -1) == 2 )
        {
            return( FALSE); // found in list
        }
        pCurrent = pCurrent->pNext;

    }while ( pList != pCurrent );

    return( TRUE); // not found
}

/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

static void ParseGlossEntry(

TCHAR szGlossEntry[],
TCHAR szEngText[],
TCHAR cEngHotKey[1],
TCHAR szIntlText[],
TCHAR cIntlHotKey[1])
{

    WORD wIndex, wIndex2;

    // format is:
    // <eng text><tab><eng hot key><tab><loc text><tab><loc hot key>
    // Any field could be null and if there aren't the right amount of
    // tabs we'll just assume that the remaining fields are empty.

    wIndex=wIndex2=0;

    // first get the english text
    while ( szGlossEntry[wIndex2] != TEXT('\t')
         && szGlossEntry[wIndex2] != TEXT('\0') )
    {
        szEngText[ wIndex++] = szGlossEntry[ wIndex2++];
    }
    szEngText[wIndex]=TEXT('\0');

    if ( szGlossEntry[ wIndex2] == TEXT('\t') )
    {
        ++wIndex2; // skip the tab
    }
    // now get the eng hot key
    if ( szGlossEntry[wIndex2] != TEXT('\t')
      && szGlossEntry[wIndex2] != TEXT('\0') )
    {
        *cEngHotKey = szGlossEntry[wIndex2++];
    }
    else
    {
        *cEngHotKey = TEXT('\0');
    }

    while ( szGlossEntry[ wIndex2] != TEXT('\t')
         && szGlossEntry[ wIndex2] != TEXT('\0') )
    {
        ++wIndex2; // make sure the hot key field doesn't hold more than one char
    }

    if ( szGlossEntry[ wIndex2] == TEXT('\t') )
    {
        ++wIndex2; // skip the tab
    }
    wIndex = 0;

    // now get the intl text
    while ( szGlossEntry[ wIndex2] != TEXT('\t')
         && szGlossEntry[ wIndex2] != TEXT('\0') )
    {
        szIntlText[wIndex++]=szGlossEntry[wIndex2++];
    }
    szIntlText[wIndex]='\0';

    if ( szGlossEntry[ wIndex2] == TEXT('\t') )
    {
        ++wIndex2; // skip the tab
    }

    // now get the intl hot key
    if ( szGlossEntry[ wIndex2] != TEXT('\t')
      && szGlossEntry[ wIndex2] != TEXT('\0') )
    {
        *cIntlHotKey = szGlossEntry[ wIndex2++];
    }
    else
    {
        *cIntlHotKey = TEXT('\0');
    }
}



/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

static void ParseBufToTextHotKey(

TCHAR *szText,
TCHAR cHotKey[1],
TCHAR *szBuf)
{

    WORD wIndexBuf  = 0;
    WORD wIndexText = 0;

    *cHotKey = TEXT('\0');

    while( szBuf[ wIndexBuf] )
    {
        if ( szBuf[ wIndexBuf ] == TEXT('&') )
        {
            *cHotKey = szBuf[ ++wIndexBuf];
        }
        else
        {
            szText[ wIndexText++] = szBuf[ wIndexBuf++];
        }
    }
    szText[ wIndexText] = TEXT('\0');
}


/**
  *
  *
  *  Function:
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

static void ParseTextHotKeyToBuf(

TCHAR *szText,
TCHAR cHotKey,
TCHAR *szBuf )
{
    WORD  wIndexBuf  = 0;
    WORD  wIndexText = 0;
//    TCHAR cTmp;


    while ( szText[ wIndexText] )
    {
//        cTmp = szText[ wIndexText];
//
//        CharUpperBuff( &cTmp, 1);
//
//        if ( cTmp == cHotKey )
        if ( szText[ wIndexText] == cHotKey )
        {
            szBuf[ wIndexBuf++] = TEXT('&');
            szBuf[ wIndexBuf++] = szText[ wIndexText++];
            break;
        }
        else
        {
            szBuf[ wIndexBuf++] = szText[ wIndexText++];
        }
    }

    // copy remaining string

    while( szText[ wIndexText] )
    {
        szBuf[ wIndexBuf++] = szText[ wIndexText++];
    }
    szBuf[ wIndexBuf] = TEXT('\0');
}


static long GetGlossaryIndex(

FILE *fpGlossFile,
TCHAR c,
long  *lGlossaryIndex )
{
    int   i    = 0;
    TCHAR cTmp = c;

    CharLowerBuff( &cTmp, 1);

    if ( cTmp >= TEXT('a')
      && cTmp <= TEXT('z') )
    {
        i = NormalizeIndex( c );
        return( lGlossaryIndex[ i > 0 ? i - 1 : 0]);
    }
    else
    {
        return( 0);
    }
}

/*******************************************************************************
*    PROCEDURE: BuildGlossEntry
*    Builds a glossary entry line.
*
*    Parameters:
*    sz, line buffer
*    sz1, untranslated text
*    c1, untranslated hot key (or 0 if no hot key)
*    sz2, translated text
*    c2, translated hot key (or 0 if no hot key)
*
*    Returns:
*    nothing.  sz contains the line.  (assumes there is room in the buffer)
*
*    History:
*    3/93 - initial implementation - SteveBl
*******************************************************************************/

static void BuildGlossEntry(

TCHAR *sz,
TCHAR *sz1,
TCHAR  c1,
TCHAR *sz2,
TCHAR  c2)
{
    *sz = TEXT('\0');
    wsprintf( sz, TEXT("%s\t%c\t%s\t%c"), sz1, c1, sz2, c2);
}

/******************************************************************************
*    PROCEDURE: AddTranslation
*    Adds a translation to a glossary file.
*
*    PARAMETERS:
*    szGlossFile, path to the glossary
*    szKey, untranslated text
*    szTranslation, translated text
*    lFilePointer, pointer to index hash table for glossary
*
*    RETURNS:
*    nothing.  Key is added to glossary if no errors are encountered else
*    file is left unchanged.
*
*    COMMENTS:
*    rebuilds the global pointer list lFilePointer
*
*    HISTORY:                                    *
*    3/92 - initial implementation - SteveBl
******************************************************************************/

void AddTranslation(

TCHAR *szKey,
TCHAR *szTranslation,
LONG  *lFilePointer)
{

// DBCS begin
    TCHAR szCurText [520];
    TCHAR szTransText   [520];
// DBCS end
    TCHAR cTransHot   = TEXT('\0');
    TCHAR cCurHotKey  = TEXT('\0');
    CHAR szTempFileName [255];
    FILE *fTemp       = NULL;
    FILE *fpGlossFile = NULL;
    TCHAR szTempText [MAXLINE];
// DBCS begin
    TCHAR szNewText [MAXLINE * 2];
// DBCS end
    TCHAR *r    = NULL;
    TCHAR chTmp = TEXT('\0');

    MyGetTempFileName( 0, "", 0, szTempFileName);

    if ( (fTemp = OpenGlossary( szTempFileName, 'w')) != NULL )
    {
        if ( fUnicodeGlossary )
        {
            fprintf( fTemp, "%hu", 0xfeff); // Mark new one as Unicode
        }

        ParseBufToTextHotKey( szCurText, &cCurHotKey, szKey);
        ParseBufToTextHotKey( szTransText, &cTransHot, szTranslation);

        BuildGlossEntry( szNewText,
                         szCurText,
                         cCurHotKey,
                         szTransText,
                         cTransHot);

                                // If the glossary file exists, get its first
                                // line. If it doesn't exist, we'll create it
                                // (via CopyFile) at the end of this function.

        if ( (fpGlossFile = OpenGlossary( gProj.szGlo, 'r')) != NULL )
        {
            if ( (r = MyGetGlossStr( szTempText,
                                     TCHARSIN( sizeof( szTempText)),
                                     fpGlossFile)) )
            {
//                lstrcpy( (TCHAR *)szDHW, szTempText);
//                szDHW[ MEMSIZE( 7)] = szDHW[ MEMSIZE( 7) + 1] = '\0';
//                CharLower( (TCHAR *)szDHW);
//
//                if ( lstrcmpi( (TCHAR *)szDHW, TEXT("ENGLISH")) == 0 )

                if ( CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                     SORT_STRINGSORT | NORM_IGNORECASE,
                                     szTempText,
                                     7,
                                     TEXT("ENGLISH"),
                                     7) == 2 )
                {
                                // skip first line

                    MyPutGlossStr( szTempText, fTemp);
                    r = MyGetGlossStr( szTempText, TCHARSIN( sizeof( szTempText)), fpGlossFile);
                }
            }
        }
        else
        {
            r = NULL;
        }

//        if ( r )
//        {
//            chTmp = szTempText[0];
//            CharLowerBuff( &chTmp, 1);
//        }
//        else
//        {
//            chTmp = szTempText[0] = TEXT('\0');
//        }
//                // Does the new text begin with a letter?
//
//        if ( chTmp >= TEXT('a') )
//        {
//                // begins with a letter, we need to find where to put it
//
//            while ( r && chTmp < TEXT('a') )
            while ( r && CompareStringW( MAKELCID( gMstr.wLanguageID, SORT_DEFAULT),
                                         SORT_STRINGSORT,
                                         szTempText,
                                         -1,
                                         szNewText,
                                         -1) == 1 )
            {
                    // skip the non letter section
                MyPutGlossStr( szTempText, fTemp);

                r = MyGetGlossStr( szTempText,
                                   TCHARSIN( sizeof( szTempText)),
                                   fpGlossFile);
//                if ( (r = MyGetGlossStr( szTempText,
//                                         TCHARSIN( sizeof( szTempText)),
//                                         fpGlossFile)) )
//                {
//                    chTmp = szTempText[0];
//                    CharLowerBuff( &chTmp, 1);
//                }
            }

//            while ( r && _tcsicmp( szTempText, szNewText) < 0 )
//            {
//                    // skip anything smaller than me
//
//                    MyPutGlossStr( szTempText, fTemp);
//                    r = MyGetGlossStr( szTempText, TCHARSIN( sizeof( szTempText)), fpGlossFile);
//            }
//        }
//        else
//        {
//                // doesn't begin with a letter, we need to insert it before
//                // the letter sections begin but it still must be sorted
//
//            while ( r
//                 && chTmp < TEXT('a')
//                 && _tcsicmp( szTempText, szNewText) < 0 )
//            {
//                MyPutGlossStr( szTempText, fTemp);
//
//                if ( (r = MyGetGlossStr( szTempText,
//                                         TCHARSIN( sizeof( szTempText)),
//                                         fpGlossFile)) )
//                {
//                    chTmp = szTempText[0];
//                    CharLowerBuff( &chTmp, 1);
//                }
//            }
//        }
        MyPutGlossStr( szNewText, fTemp);

        while ( r )
        {
            MyPutGlossStr( szTempText,fTemp);
            r = MyGetGlossStr( szTempText, TCHARSIN( sizeof( szTempText)), fpGlossFile);
        }
        fclose( fTemp);

        if ( fpGlossFile )
        {
            fclose( fpGlossFile);
        }
                                // This call will create the glossary file
                                // if it didn't already exist.

        if ( ! CopyFileA( szTempFileName, gProj.szGlo, FALSE) )
        {
            QuitA( IDS_COPYFILE_FAILED, szTempFileName, gProj.szGlo);
        }
        remove( szTempFileName);

        MakeGlossIndex( lFilePointer);
    }
    else
    {
        QuitA( IDS_NO_TMP_GLOSS, szTempFileName, NULL);
    }
}

/**
  *
  *
  *  Function: MyGetGlossStr
  *     Replaces C runtime fgets function.
  *
  *  History:
  *     5/92, Implemented.              TerryRu.
  *
  *
  **/

static TCHAR *MyGetGlossStr( TCHAR * ptszStr, int nCount, FILE * fIn)
{
    int i = 0;

#ifdef RLRES32
                                // It this a Unicode glossary file?
    TCHAR  tCh = TEXT('\0');

    if ( fUnicodeGlossary )
    {
        do                      // Yes
        {
            tCh = ptszStr[ i++] = (TCHAR)GetWord( fIn, NULL);

        } while ( i < nCount && tCh != TEXT('\n') );

        if ( tCh == TEXT('\0') || feof( fIn) )
        {
            return( NULL);
        }
        ptszStr[i] = TEXT('\0');

        StripNewLineW( ptszStr);
    }
    else                        // No, it's an ANSI glossary file
    {
        if ( fgets( szDHW, DHWSIZE, fIn) != NULL )
        {
            StripNewLineA( szDHW);
            _MBSTOWCS( ptszStr, szDHW, nCount, (UINT)-1);
        }
        else
        {
            return( NULL);
        }
    }
    return( ptszStr);

#else  //RLRES32

    if ( fgets( ptszStr, nCount, fIn) )
    {
        StripNewLineA( ptszStr);
    }
    else
    {
        return( NULL);
    }

#endif //RLRES32
}




/**
  *
  *
  *  Function: MyPutGlossStr
  *   Replaces C runtime fputs function.

  *  History:
  *   6/92, Implemented.              TerryRu.
  *
  *
  **/
static int MyPutGlossStr( TCHAR * ptszStr, FILE * fOut)
{

#ifdef RLRES32

    int i = 0;

                                // It this a Unicode glossary file?
    if ( fUnicodeGlossary )
    {
        do                      // Yes
        {
            PutWord( fOut, ptszStr[i], NULL);

        } while ( ptszStr[ i++] );

        PutWord( fOut, TEXT('\r'), NULL);
        PutWord( fOut, TEXT('\n'), NULL);
        i += 2;
    }
    else                        // No, it's an ANSI glossary file
    {
        _WCSTOMBS( szDHW, ptszStr, DHWSIZE, lstrlen( ptszStr) + 1);
        i = fputs( szDHW, fOut);
        fputs( "\n",  fOut);
    }

#else  //RLRES32

    i = fputs( ptszStr,  fOut);
    fputs( "\n",  fOut);

#endif //RLRES32

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\wincomon.h ===
#ifndef _WINCOMON_H_
#define _WINCOMON_H_

extern HWND   hMainWnd;
extern CHAR   szFileName[];
extern CHAR   szAppName[];
extern CHAR   szCustFilterSpec[MAXCUSTFILTER];
extern CHAR   szFileTitle[];

BOOL	      GetFileNameFromBrowse( HWND, PSTR, UINT, PSTR, PSTR, PSTR );
INT_PTR APIENTRY StatusWndProc( HWND, UINT, WPARAM, LPARAM);
void	      cwCenter( HWND, int);
int	      LoadStrIntoAnsiBuf( HINSTANCE, UINT, LPSTR, int);
BOOL	      LoadNewFile(CHAR *);
void          szFilterSpecFromSz1Sz2(char *sz,char *sz1,char *sz2);
void          CatSzFilterSpecs(char *sz,char *sz1,char *sz2);


#endif // _WINCOMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\wincomon.c ===
// Not sure which of these includes are/will be needed - t-gregti

#include <windows.h>
//#include <port1632.h>
#include <commdlg.h>

// CRT includes
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <io.h>
#include <time.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <ctype.h>

// RL TOOLS SET includes
#include "windefs.h"
#include "restok.h"
#include "wincomon.h"


int LoadStrIntoAnsiBuf(

HINSTANCE hinst,
UINT      idResource,
LPSTR     lpszBuffer,
int       cbBuffer )
{
    int rc;
#ifdef RLRES32
    WCHAR tszTmpBuf[256];

    rc = LoadString( hinst, idResource, tszTmpBuf,  TCHARSIN( sizeof( tszTmpBuf)));
    _WCSTOMBS( lpszBuffer,
               tszTmpBuf,
               cbBuffer,
               lstrlen( tszTmpBuf ) + 1 );
#else
    rc = LoadString( hinst, idResource, lpszBuffer, cbBuffer );
#endif
    return( rc);
}

/**
*  Function: GetFileNameFromBrowse.
  * Uses the commdlg.dll GetOpenFileName function to prompt the user
  * file name.
  *
  *  Arguments:
  *     hDlg, Owner for browse dialog.
  *     pszFileName,   // buffer to insert file name
  *     cbFilePath,    // Max length of file path buffer.
  *     szTitle,       // Working directory
  *     szFilter,      // filters string.
  *     szDefExt       // Default extension to file name
  *
  *  Returns:
  * TRUE, pszFileName contains file name.
  * FALSE, GetFileName aborted.
  *
  *  History:
  * 9/91 Copied from NotePad sources.       TerryRu.
  **/
BOOL GetFileNameFromBrowse(HWND hDlg,
       PSTR pszFileName,
       UINT cbFilePath,
       PSTR szTitle,
       PSTR szFilter,
       PSTR szDefExt)
{
    OPENFILENAMEA ofn;       // Structure used to init dialog.
    CHAR szBrowserDir[128]; // Directory to start browsing from.
    szBrowserDir[0] = '\0'; // By default use CWD.


    // initalize ofn to NULLS

    memset( (void *)&ofn, 0, sizeof( OPENFILENAMEA ) );

    /* fill in non-variant fields of OPENFILENAMEA struct. */

    ofn.lStructSize     = sizeof(OPENFILENAMEA);
    ofn.lpstrCustomFilter   = szCustFilterSpec;
    ofn.nMaxCustFilter      = MAXCUSTFILTER;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = pszFileName;
    ofn.nMaxFile            = MAXFILENAME;
    ofn.lpstrFileTitle      = szFileTitle;
    ofn.nMaxFileTitle       = MAXFILENAME;
    ofn.lpTemplateName      = NULL;
    ofn.lpfnHook            = NULL;

    // Setup info for comm dialog.
    ofn.hwndOwner           = hDlg;
    ofn.lpstrInitialDir     = szBrowserDir;
    ofn.Flags               = OFN_HIDEREADONLY;
    ofn.lpstrDefExt         = szDefExt;
    ofn.lpstrFileTitle      = szFileTitle;
    ofn.lpstrTitle          = szTitle;
    ofn.lpstrFilter         = szFilter;

    // Get a filename from the dialog.
    return GetOpenFileNameA(&ofn);
}

#define MAX_STATUS_FIELDS 5
#define MAXBUFFERSIZE     80

/****************************************************************************
*Procedure: StatusWndProc
*
*Inputs:
*
*Returns:
*    depends on message
*
*History:
*    7/92 - created - t-gregti
*
*Comments:
*    More general than strictly neccesary for the RL tools, but
*    it makes adding new fields to the status line really easy.
*    For WM_FMTSTATLINE the lParam should be a string with length/type pairs
*    much like a printf format, e.g. "10s5i10s20i".
*    For WM_UPDSTATLINE the wParam contains the field to change and the lParam
*    contains a pointer to a string or int to display.
*
*****************************************************************************/

INT_PTR APIENTRY StatusWndProc( HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC hDC;
    static HFONT hFontCourier;
        static UINT cFields = 0;
        static UINT aiSize[MAX_STATUS_FIELDS];
        static TCHAR aszStatusStrings[MAX_STATUS_FIELDS][MAXBUFFERSIZE];
        static BOOL abIntegers[MAX_STATUS_FIELDS];

    switch( wMsg )
    {
    case WM_CREATE:
        {
                LOGFONT lf;

        memset( (void *)&lf, 0, sizeof(LOGFONT) );

                // Intialize font info
                lf.lfWeight         = 400; //Normal
                lf.lfCharSet        = ANSI_CHARSET;
                lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
                lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
                lf.lfQuality        = PROOF_QUALITY;
                lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
                lf.lfHeight         = 14;
                lf.lfWidth          = 0;
                lf.lfUnderline      = 0;
        lstrcpy ( lf.lfFaceName, TEXT("Courier"));

                // Get a handle to the courier font
        hFontCourier = CreateFontIndirect( (void *)& lf );

                break;
    }

    case WM_DESTROY:
        DeleteObject((HGDIOBJ)hFontCourier);
                break;

        case WM_FMTSTATLINE:
        {
                TCHAR *psz;

#ifdef RLRES32
                CHAR sz[MAXBUFFERSIZE];
#endif

                cFields = 0;

                for (psz = (LPTSTR)lParam; *psz; psz++)
                {
                    cFields++;

#ifdef RLRES32
                    _WCSTOMBS( sz,
                               psz,
                               ACHARSIN( sizeof( sz)),
                               lstrlen( psz) + 1);
                        aiSize[cFields-1] = atoi(sz);
#else
                        aiSize[cFields-1] = atoi(psz);
#endif

                        while(_istdigit(*psz))
                        {
                                psz++;
                        }

                        switch(*psz)
                        {
                        case 'i':
                                abIntegers[cFields-1] = TRUE;
                                break;
                        case 's':
                                abIntegers[cFields-1] = FALSE;
                                break;
                        default:
                                cFields = 0;
                                return(FALSE);
                        }
                }
                return(TRUE);
        }


    case WM_UPDSTATLINE:
                // intialize status line info, and force it to be painted
                if (wParam > cFields)
                {
                        return(FALSE);
                }
                if (abIntegers[wParam]) // Is it for an integer field?
                {
#ifdef RLRES32
                        char sz[MAXBUFFERSIZE] = "";

                        _itoa((INT)lParam, sz, 10);
                        _MBSTOWCS( aszStatusStrings[ wParam],
                                   sz,
                                   WCHARSIN( sizeof( sz)),
                                   ACHARSIN( lstrlenA( sz)+1));
#else
                        _itoa(lParam, aszStatusStrings[wParam], 10);
#endif
                }
                else
                {

#ifdef RLWIN32
                        CopyMemory( aszStatusStrings[ wParam],
                                    (LPTSTR)lParam,
                                    min( MAXBUFFERSIZE, MEMSIZE( lstrlen( (LPTSTR)lParam) + 1)));
                        aszStatusStrings[ wParam][ MAXBUFFERSIZE - 1] = TEXT('\0');
#else
                        _fstrncpy(aszStatusStrings[wParam], (LPTSTR)lParam, MAXBUFFERSIZE-1);
#endif
                        aszStatusStrings[wParam][MAXBUFFERSIZE-1] = 0;
                }
                InvalidateRect( hWnd, NULL, TRUE );
                break;

    case WM_PAINT:
    {
                RECT r;
        HFONT hOldFont;
                HBRUSH hbrOld, hbrFace, hbrHilite, hbrShadow;
                TEXTMETRIC tm;
                int iWidth, iHeight;
                UINT i;

                /* Obtain a handle to the device context        */
        memset((void *)&ps, 0x00, sizeof(PAINTSTRUCT));
                hDC = BeginPaint(hWnd, &ps);
                GetTextMetrics(hDC, &tm);

                GetClientRect( hWnd, &r );
                iWidth  = r.right  - r.left;
                iHeight = r.bottom - r.top;

                // Create the brushes for the 3D effect
                hbrFace   = CreateSolidBrush(RGB(0xC0, 0xC0, 0xC0));
                hbrHilite = CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF));
                hbrShadow = CreateSolidBrush(RGB(0x80, 0x80, 0x80));

                // Paint outer 3D effect for raised slab
        hbrOld = (HBRUSH)SelectObject(hDC, (HGDIOBJ)hbrHilite);
                PatBlt(hDC, r.left, r.top, iWidth, 1, PATCOPY);
                PatBlt(hDC, r.left, r.top+1, 1, iHeight-2, PATCOPY);
        SelectObject(hDC, (HGDIOBJ)hbrShadow);
                PatBlt(hDC, r.left, r.bottom-1, iWidth, 1, PATCOPY);
                PatBlt(hDC, r.right-1, r.top+1, 1, iHeight-2, PATCOPY);

                // Paint surface of slab
                r.left   += 1;
                r.top    += 1;
                r.right  -= 1;
                r.bottom -= 1;
                iWidth   -= 2;
                iHeight  -= 2;
        SelectObject(hDC, (HGDIOBJ)hbrFace);
                PatBlt(hDC, r.left, r.top, iWidth, iHeight, PATCOPY);

                // Get Courier font
        hOldFont = (HFONT)SelectObject( hDC, (HGDIOBJ)hFontCourier );
                SetBkColor(hDC, RGB(0xC0, 0xC0, 0xC0));

                // Paint inner 3D effect for tray carved into slab and write text
                r.left   += 9;
                r.right  -= 9;
                r.top    += 3;
                r.bottom -= 3;
                iHeight = r.bottom - r.top;

                for (i = 0; i < cFields; i++)
                {
                        iWidth = tm.tmMaxCharWidth * aiSize[i];
                        r.right = r.left + iWidth - 2;
            SelectObject(hDC, (HGDIOBJ)hbrShadow);
                        PatBlt(hDC, r.left-1, r.top-1, iWidth, 1, PATCOPY);
                        PatBlt(hDC, r.left-1, r.top, 1, iHeight-2, PATCOPY);
            SelectObject(hDC, (HGDIOBJ)hbrHilite);
                        PatBlt(hDC, r.left-1, r.bottom, iWidth, 1, PATCOPY);
                        PatBlt(hDC, r.left + iWidth-1, r.top, 1, iHeight-2, PATCOPY);
                        DrawText(hDC, aszStatusStrings[i],
                                         STRINGSIZE( lstrlen( aszStatusStrings[i])),
                                         &r, DT_SINGLELINE);
                        r.left += iWidth + 8;
                }

                // Put old brush back and delete the rest
        SelectObject(hDC, (HGDIOBJ)hbrOld);
        DeleteObject((HGDIOBJ)hbrFace);
        DeleteObject((HGDIOBJ)hbrHilite);
        DeleteObject((HGDIOBJ)hbrShadow);

        SelectObject(hDC,(HGDIOBJ)hOldFont);
        EndPaint ( hWnd, (CONST PAINTSTRUCT *)&ps );

                break;  /*  End of WM_PAINT */
    }

    }
    return( DefWindowProc( hWnd, wMsg, wParam, lParam ));
}

/**
  *  Function: cwCenter
  *   Centers Dialog boxes in main window.
  *
  **/

void cwCenter( HWND hWnd, int top )
{
    POINT   pt;
    RECT    swp;
    RECT    rParent;
    int     iwidth;
    int     iheight;

    GetWindowRect(hWnd, &swp);
    GetWindowRect(hMainWnd, &rParent);

    /* calculate the height and width for MoveWindow    */
    iwidth = swp.right - swp.left;
    iheight = swp.bottom - swp.top;

    /* find the center point */
    pt.x = (rParent.right - rParent.left) / 2;
    pt.y = (rParent.bottom - rParent.top) / 2;

    /* calculate the new x, y starting point    */
    pt.x = pt.x - (iwidth / 2);
    pt.y = pt.y - (iheight / 2);

    ClientToScreen(hMainWnd,&pt);


    /* top will adjust the window position, up or down  */
    if(top)
        pt.y = pt.y + top;

    if (pt.x < 0)
        pt.x=0;
    else
        if (pt.x + iwidth > GetSystemMetrics(SM_CXSCREEN))
            pt.x = GetSystemMetrics(SM_CXSCREEN)-iwidth;

    /* move the window         */
    MoveWindow(hWnd, pt.x, pt.y, iwidth, iheight, FALSE);
}

/**
  *  Function: szFilterSpecFromSz1Sz2
  *    Returns a filter spec with the format "%s\0%s\0\0" suitable for
  *    use with the Windows 3.1 standard load dialog box.
  *
  *  Arguments:
  *    sz, destination buffer
  *    sz1, first string
  *    sz2, second string
  *
  *  Returns:
  *    result in sz
  *
  *  Error Codes:
  *    none
  *
  *  Comments:
  *    Performs no bounds checking.  sz is assumed to be large enough to
  *    accomidate the filter string.
  *
  *  History:
  *    2/92, Implemented    SteveBl
  */
void szFilterSpecFromSz1Sz2(CHAR *sz,CHAR *sz1, CHAR *sz2)
{
    int i1 = 0;
    int i2 = 0;

    while (sz[i1++] = sz1[i2++]);
    i2 = 0;

    while (sz[i1++] = sz2[i2++]);
    sz[i1]=0;
}

/**
  *  Function: CatSzFilterSpecs
  *    Concatonates two szFilterSpecs (double null terminated strings)
  *    and returns a buffer with the result.
  *
  *  Arguments:
  *    sz, destination buffer
  *    sz1, first Filter Spec
  *    sz2, second Filter Spec
  *
  *  Returns:
  *    result in sz
  *
  *  Error Codes:
  *    none
  *
  *  Comments:
  *    performs no bounds checking
  *
  *  History:
  *    3/92, initial implementation -- SteveBl
  */
void CatSzFilterSpecs(CHAR *sz,CHAR *sz1,CHAR *sz2)
{
    int i1 = 0;
    int i2 = 0;

    while (sz1[i2] || sz1[i2+1]) // looking for double byte
    {
        sz[i1++]=sz1[i2++];
    }
    sz[i1++] = '\0';
    i2 = 0;
    while (sz2[i2] || sz2[i2+1])
    {
        sz[i1++]=sz2[i2++];
    }
    sz[i1++] = '\0';
    sz[i1++] = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\common\windefs.h ===
#ifndef _WINDEFS_H_
#define _WINDEFS_H_

// USER DEFINED MESSAGES

#define WM_TOKEDIT      WM_USER + 2
#define WM_UPDSTATLINE      WM_USER + 2

#define WM_FMTSTATLINE      WM_USER + 3
#define WM_READMPJDATA      WM_USER + 3
#define WM_LOADPROJECT      WM_USER + 3

#define WM_LOADTOKENS       WM_USER + 4
#define WM_SAVEPROJECT      WM_USER + 5
#define WM_EDITER_CLOSED    WM_USER + 6
#define WM_VIEW             WM_USER + 7
#define WM_TRANSLATE        WM_USER + 8
#define WM_SAVETOKENS       WM_USER + 9

#define ID_ICON     1


/* Windows macros */

#pragma message("Using the WIN translation of the common macros.")

#ifdef RLWIN32

#ifdef _DEBUG

FILE  * MyFopen( char *, char *, char *, int);
int     MyClose( FILE **, char *, int);

#define FALLOC(n)        MyAlloc( (size_t)(n), __FILE__, __LINE__)
#define FREALLOC(p,n)    MyReAlloc( (p),(n), __FILE__, __LINE__)
#define FOPEN(f,m) 		 MyFopen( (f), (m), __FILE__, __LINE__)
#define FCLOSE(p) 		 MyClose( &(p), __FILE__, __LINE__)

#else // _DEBUG

FILE  *MyFopen( char *, char *);
int     MyClose( FILE **);

#define FALLOC(n)        MyAlloc( (size_t)(n))
#define FREALLOC(p,n)    MyReAlloc( (p),(n))
#define FOPEN(f,m)  	 fopen( (f),(m))
//#define FOPEN(f,m)  	 MyFopen( (f),(m))
//#define FCLOSE(p)   	 MyClose( &(p))
//#define FCLOSE(p)   	 {if(p){fclose( p);p=NULL;}}
#define FCLOSE(p)   	 fclose( p);

#endif // _DEBUG

//#define RLFREE(p)        if(p){GlobalFree(p);p=NULL;}
#define RLFREE(p)        MyFree(&p)
#define ALLOC(n)         FALLOC(n)
#define REALLOC(p,n)     FREALLOC( (p),(n))
#define FMEMMOVE( szDst, szSrc, uSize)  memmove( (szDst), (szSrc), (uSize))
#define FSTRNCPY( szDst, szSrc, uSize)  strncpy( (szDst), (szSrc), (uSize))
#else // RLWIN32
#define FALLOC(n)        (VOID FAR *)MAKELONG( 0, GlobalAlloc(GPTR, (DWORD)n))
#define FFREE(n)         GlobalFree((HANDLE)HIWORD( (LONG)n))
#define FREALLOC(p,n)    (VOID FAR *)MAKELONG( 0, GlobalReAlloc( (HANDLE)HIWORD( (LONG)n),n,GPTR))
#define ALLOC(n)         (VOID NEAR *)LocalAlloc( LPTR,n)
#define FREE(p)          LocalFree( (LOCALHANDLE) p)
#define REALLOC(p,n)     LocalRealloc( p, n, LMEM_MOVEABLE)
#define FMEMMOVE( szDst, szSrc, uSize)  _fmemmove( szDst, szSrc, uSize )
#define FSTRNCPY( szDst, szSrc, uSize)  _fstrncpy( szDst, szSrc, uSize )
#endif // RLWIN32



#ifndef UNICODE
#define MessageBoxA         MessageBox
#define SetWindowTextA      SetWindowText
#define WinHelpA            WinHelp
#define SetDlgItemTextA     SetDlgItemText
#define GetDlgItemTextA     GetDlgItemText
#define GetOpenFileNameA    GetOpenFileName
#define OPENFILENAMEA       OPENFILENAME
#define DragQueryFileA      DragQueryFile
#endif



#ifndef RLWIN32

#ifndef CONST
#define CONST            const
#endif

#define CHAR char
typedef CHAR *LPSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#define WCHAR wchar_t
typedef WCHAR *PWCHAR;
typedef WCHAR *LPWSTR, *PWSTR;

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR;
typedef LPCSTR LPCTSTR;
#define TEXT(quote) quote
typedef unsigned char UCHAR;
typedef char *PCHAR;
#define UNALIGNED
#endif

#ifdef CAIRO

#define OPENFILENAMEA      OPENFILENAME
#define GetOpenFileNameA   GetOpenFileName
#define HDROP HANDLE

#endif

#ifndef RLWIN32

#define _MBSTOWCS(ds,ss,dc,sc) mbstowcs(ds,ss,sc)
#define _WCSTOMBS(ds,ss,dc,sc) wcstombs(ds,ss,sc)

#else  //RLWIN32

UINT _MBSTOWCS( WCHAR*, CHAR*, UINT, UINT);
UINT _WCSTOMBS( CHAR*, WCHAR*, UINT, UINT);

#endif // RLWIN32

#ifndef MAKEINTRESOURCE

#define MAKEINTRESOURCEA(i) (LPSTR)((DWORD)((WORD)(i)))
#define MAKEINTRESOURCEW(i) (LPWSTR)((DWORD)((WORD)(i)))

#ifdef UNICODE
#define MAKEINTRESOURCE  MAKEINTRESOURCEW
#else
#define MAKEINTRESOURCE  MAKEINTRESOURCEA
#endif // UNICODE

#endif // !MAKEINTRESOURCE

#endif  // _WINDEFS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rladmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RLADMIN.RC
//
#define IDS_SELECTLANG                  3101
#define IDS_NOCPXTABLE                  3102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        7001
#define _APS_NEXT_COMMAND_VALUE         6001
#define _APS_NEXT_CONTROL_VALUE         5002
#define _APS_NEXT_SYMED_VALUE           8001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rladmin\rladmin.c ===
// INCLUSION PREVENTION DEFINITIONS
#define NOMETAFILE
#define NOMINMAX
#define NOSOUND
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOCOMM
#define NOBITMAP
#define NOSCROLL
#define NOWINOFFSETS
#define NOWH
#define NORASTEROPS
#define NOOEMRESOURCE
#define NOGDICAPMASKS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NOATOM
#define NOLOGERROR
#define NOSYSTEMPARAMSINFO

#include <windows.h>

#ifdef RLWIN32
#include <windowsx.h>
#endif

#include <commdlg.h>
#include <shellapi.h>
#include <stdio.h>
#include <stdlib.h>

#include "windefs.h"
#include "toklist.h"
#include "RLADMIN.H"
#include "RESTOK.H"
#include "update.h"
#include "custres.h"
#include "exe2res.h"
#include "commbase.h"
#include "wincomon.h"
#include "projdata.h"
#include "showerrs.h"
#include "resread.h"
#include "langlist.h"
#include "resource.h"

// Global Variables:

extern BOOL     gbMaster;
extern MSTRDATA gMstr;
extern PROJDATA gProj;
extern UCHAR    szDHW[];

extern BOOL     bRLGui;

#ifdef WIN32
    HINSTANCE   hInst;          // Instance of the main window
#else
    HWND        hInst;          // Instance of the main window
#endif

int  nUpdateMode    = 0;
BOOL fCodePageGiven = FALSE;    //... Set to TRUE if -p arg given
CHAR szFileTitle[14] = "";      // holds base name of latest opened file
CHAR szCustFilterSpec[MAXCUSTFILTER]="";    // custom filter buffer
HWND hMainWnd   = NULL;         // handle to main window
HWND hListWnd   = NULL;         // handle to tok list window
HWND hStatusWnd = NULL;         // handle to status windows


static int     iLastBox    = IDD_SOURCERES;
static CHAR  * gszHelpFile = "rltools.hlp";
static TCHAR   szSearchType[80]   = TEXT("");
static TCHAR   szSearchText[4096] = TEXT("");
static WORD    wSearchStatus = 0;
static WORD    wSearchStatusMask = 0;
static BOOL    fSearchDirection;
static BOOL    fSearchStarted = FALSE;
static BOOL    fLanguageGiven = FALSE;
static BOOL    fLangSelected  = FALSE;

static void           DrawLBItem(         LPDRAWITEMSTRUCT lpdis);
static void           MakeStatusLine(     TOKEN *pTok);
static BOOL           SaveMtkList(        HWND hWnd, FILE *fpTokFile);
static TOKENDELTAINFO FAR *InsertMtkList( FILE * fpTokFile);
static void           CleanDeltaList(     void);

static long lFilePointer[30];

// File IO vars

static OPENFILENAMEA ofn;

static CHAR    szFilterSpec    [60] = "";
static CHAR    szExeFilterSpec [60] = "";
static CHAR    szDllFilterSpec [60] = "";
static CHAR    szResFilterSpec [60] = "";
static CHAR    szExeResFilterSpec [180] = "";
static CHAR    szMtkFilterSpec [60] = "";
static CHAR    szMPJFilterSpec [60] = "";
static CHAR    szRdfFilterSpec [60] = "";

static CHAR    szFileName[MAXFILENAME] = "";// holds full name of latest opened file
static TCHAR   tszAppName[100] = TEXT("");
static CHAR    szAppName[100] = "";
static TCHAR   szClassName[]=TEXT("RLAdminClass");
static TCHAR   szStatusClass[]=TEXT("RLAdminStatus");

static BOOL    fMtkChanges = FALSE;        // set to true when toke file is out of date
static BOOL    fMtkFile    = FALSE;
static BOOL    fMpjChanges = FALSE;
static BOOL    fMPJOutOfDate = FALSE;
static BOOL    fPRJOutOfDate = FALSE;

static CHAR    szOpenDlgTitle[80] = ""; // title of File open dialog
static CHAR    szSaveDlgTitle[80] = ""; // title of File saveas dialog
static CHAR    szNewFileName[MAXFILENAME] = "";
static CHAR    szPrompt[80] = "";
static CHAR   *szFSpec = NULL;
static CHAR   *szExt   = NULL;


static TOKENDELTAINFO FAR *pTokenDeltaInfo;       // linked list of token deta info

// Window vars
static HCURSOR    hHourGlass  = NULL;   // handle to hourglass cursor
static HCURSOR    hSaveCursor = NULL;   // current cursor handle
static HACCEL     hAccTable   = NULL;
static RECT       Rect = {0,0,0,0};     // dimension of the client window
static UINT       cyChildHeight = 0;    // height of status windows


// NOTIMPLEMENTED is a macro that displays a "Not implemented" dialog
#define NOTIMPLEMENTED {\
            LoadString(hInst,IDS_NOT_IMPLEMENTED,szDHW, DHWSIZE);\
            MessageBox(hMainWnd,szDHW,tszAppName,MB_ICONEXCLAMATION | MB_OK);}

// Edit Tok Dialog

static FARPROC lpTokEditDlg   = NULL;
static HWND    hTokEditDlgWnd = 0;



/**
  *
  *
  *  Function: InitApplication
  *   Regsiters the main window, which is a list box composed of tokens
  *   read from the token file. Also register the status window.
  *
  *
  *  Arguments:
  *   hInstance, instance handle of program in memory.
  *
  *  Returns:
  *
  *  Errors Codes:
  *   TRUE, windows registered correctly.
  *   FALSE, error during register of one of the windows.
  *
  *  History:
  *   9/91, Implemented.                TerryRu
  *
  *
  **/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    CHAR sz[60] = "";
    CHAR sztFilterSpec[180] = "";

    gbMaster=TRUE;

    LoadStrIntoAnsiBuf(hInstance,IDS_RESSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szResFilterSpec,sz,"*.RES");

    LoadStrIntoAnsiBuf(hInstance,IDS_EXESPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szExeFilterSpec,sz,"*.EXE");

    LoadStrIntoAnsiBuf(hInstance,IDS_DLLSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szDllFilterSpec,sz,"*.DLL");
    CatSzFilterSpecs(sztFilterSpec,szExeFilterSpec,szDllFilterSpec);
    CatSzFilterSpecs(szExeResFilterSpec,sztFilterSpec,szResFilterSpec);

    LoadStrIntoAnsiBuf(hInstance,IDS_MTKSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szMtkFilterSpec,sz,"*.MTK");

    LoadStrIntoAnsiBuf(hInstance,IDS_RDFSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szRdfFilterSpec,sz,"*.RDF");

    LoadStrIntoAnsiBuf(hInstance,IDS_MPJSPEC,sz,sizeof(sz));
    szFilterSpecFromSz1Sz2(szMPJFilterSpec,sz,"*.MPJ");
    szFilterSpecFromSz1Sz2(szFilterSpec,sz,"*.MPJ");

    LoadStrIntoAnsiBuf(hInstance,
                       IDS_OPENTITLE,
                       szOpenDlgTitle,
                       sizeof(szOpenDlgTitle));
    LoadStrIntoAnsiBuf(hInstance,
                       IDS_SAVETITLE,
                       szSaveDlgTitle,
                       sizeof(szSaveDlgTitle));

    wc.style            = 0;
    wc.lpfnWndProc      = StatusWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon((HINSTANCE) NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = szStatusClass;

    if (! RegisterClass( (CONST WNDCLASS *)&wc))
    {
        return (FALSE);
    }

    wc.style            = 0;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hInstance,TEXT("RLAdminIcon"));
    wc.hCursor          = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName     = TEXT("RLAdmin");
    wc.lpszClassName    = szClassName;

    return( RegisterClass( (CONST WNDCLASS *)&wc) ? TRUE : FALSE);
}



/**
  *
  *
  *  Function: InitInstance
  *   Creates the main, and status windows for the program.
  *   The status window is sized according to the main window
  *   size.  InitInstance also loads the acclerator table, and prepares
  *   the global openfilename structure for later use.
  *
  *
  *  Errors Codes:
  *   TRUE, windows created correctly.
  *   FALSE, error on create windows calls.
  *
  *  History:
  *   9/11, Implemented         TerryRu
  *
  *
  **/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT    Rect;

    hAccTable = LoadAccelerators(hInst, TEXT("RLAdmin"));

    hMainWnd = CreateWindow( szClassName,
                             tszAppName,
                             WS_OVERLAPPEDWINDOW,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             CW_USEDEFAULT,
                             (HWND) NULL,
                             (HMENU) NULL,
                             (HINSTANCE)hInstance,
                             (LPVOID) NULL);

    if ( ! hMainWnd )
    {
        return( FALSE);
    }

    DragAcceptFiles(hMainWnd, TRUE);

    GetClientRect(hMainWnd, (LPRECT) &Rect);

    // Create a child list box window

    hListWnd = CreateWindow( TEXT("LISTBOX"),
                             NULL,
                             WS_CHILD |
                             LBS_WANTKEYBOARDINPUT |
                             LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED |
                             WS_VSCROLL | WS_HSCROLL | WS_BORDER ,
                             0,
                             0,
                             (Rect.right-Rect.left),
                             (Rect.bottom-Rect.top),
                             hMainWnd,
                             (HMENU)IDC_LIST, // Child control i.d.
                             hInstance,
                             NULL);

    if ( ! hListWnd )
    {
        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    // Creat a child status window

    hStatusWnd = CreateWindow( szStatusClass,
                               NULL,
                               WS_CHILD | WS_BORDER | WS_VISIBLE,
                               0, 0, 0, 0,
                               hMainWnd,
                               NULL,
                               hInst,
                               NULL);

    if ( ! hStatusWnd )
    {                           // clean up after errors.
        DeleteObject((HGDIOBJ)hListWnd);
        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    hHourGlass = LoadCursor( (HINSTANCE) NULL, IDC_WAIT);

    // Fill in non-variant fields of OPENFILENAMEA struct.
    ofn.lStructSize         = sizeof( OPENFILENAMEA);
    ofn.hwndOwner           = hMainWnd;
    ofn.lpstrFilter         = szFilterSpec;
    ofn.lpstrCustomFilter   = szCustFilterSpec;
    ofn.nMaxCustFilter      = MAXCUSTFILTER;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFileName;
    ofn.nMaxFile            = MAXFILENAME;
    ofn.lpstrInitialDir     = NULL;
    ofn.lpstrFileTitle      = szFileTitle;
    ofn.nMaxFileTitle       = MAXFILENAME;
    ofn.lpstrTitle          = NULL;
    ofn.lpstrDefExt         = "MPJ";
    ofn.Flags               = 0;

    GetLangList();

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);

    return TRUE;
}

/**
  *
  *
  *  Function: WinMain
  *   Calls the intialization functions, to register, and create the
  *   application windows. Once the windows are created, the program
  *   enters the GetMessage loop.
  *
  *
  *  Arguements:
  *   hInstace, handle for this instance
  *   hPrevInstanc, handle for possible previous instances
  *   lpszCmdLine, long pointer to exec command line.
  *   nCmdShow,  code for main window display.
  *
  *
  *  Errors Codes:
  *   IDS_ERR_REGISTER_CLASS, error on windows register
  *   IDS_ERR_CREATE_WINDOW, error on create windows
  *   otherwise, status of last command.
  *
  *  History:
  *
  *
  **/


INT WINAPI WinMain(

HINSTANCE hInstance,
HINSTANCE hPrevInstance,
LPSTR     lpszCmdLine,
int       nCmdShow)
{
    MSG   msg;
    HWND  FirstWnd      = NULL;
    HWND  FirstChildWnd = NULL;
    static TCHAR szString[256] = TEXT("");


    hInst  = hInstance;
    bRLGui = TRUE;

    if ( FirstWnd = FindWindow( szClassName,NULL) )
    {
        // checking for previous instance
        FirstChildWnd = GetLastActivePopup( FirstWnd);
        BringWindowToTop( FirstWnd);
        ShowWindow( FirstWnd, SW_SHOWNORMAL);

        if ( FirstWnd != FirstChildWnd )
        {
            BringWindowToTop( FirstChildWnd);
        }
        return( FALSE);
    }

    GetModuleFileNameA( hInst, szDHW, DHWSIZE);
    GetInternalName( szDHW, szAppName, ACHARSIN( sizeof( szAppName)));
    szFileName[0] = '\0';
    lFilePointer[0] = (LONG)-1;

#ifdef UNICODE
    _MBSTOWCS( tszAppName,
               szAppName,
               WCHARSIN( sizeof( tszAppName)),
               ACHARSIN( strlen( szAppName) + 1));
#else
    strcpy( tszAppName, szAppName);
#endif

    // register window classes if first instance of application
    if ( ! hPrevInstance )
    {
        if ( ! InitApplication( hInstance) )
        {
            /* Registering one of the windows failed      */
            LoadString( hInst,
                        IDS_ERR_REGISTER_CLASS,
                        szString,
                        TCHARSIN( sizeof( szString)));
            MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
            return( IDS_ERR_REGISTER_CLASS);
        }
    }

    // Create windows for this instance of application
    if ( ! InitInstance( hInstance, nCmdShow) )
    {
        LoadString( hInst,
                    IDS_ERR_CREATE_WINDOW,
                    szString,
                    TCHARSIN( sizeof( szString)));
        MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
        return( IDS_ERR_CREATE_WINDOW);
    }

    // Main Message Loop

    while ( GetMessage( &msg, (HWND)NULL, 0, 0) )
    {
        if ( hTokEditDlgWnd )
        {
            if ( IsDialogMessage( hTokEditDlgWnd, &msg) )
            {
                continue;
            }
        }

        if ( TranslateAccelerator( hMainWnd, hAccTable, &msg) )
        {
            continue;
        }

        TranslateMessage( (CONST MSG *)&msg);
        DispatchMessage( (CONST MSG *)&msg);
    }
    return( (INT)msg.wParam);
}

/**
  *
  *
  *  Function: MainWndProc
  *   Process the windows messages for the main window of the application.
  *   All user inputs go through this window procedure.
  *   See cases in the switch table for a description of each message type.
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/

INT_PTR APIENTRY MainWndProc(

HWND   hWnd,
UINT   wMsg,
WPARAM wParam,
LPARAM lParam)
{
    DoListBoxCommand (hWnd, wMsg, wParam, lParam);

    switch (wMsg)
    {
    case WM_DROPFILES:
        {
#ifndef CAIRO
            DragQueryFileA((HDROP)wParam, 0, szDHW, MAXFILENAME);
#else
            DragQueryFile((HDROP)wParam, 0, szDHW, MAXFILENAME);
#endif
            MessageBoxA( hWnd, szDHW, szAppName, MB_OK);

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                if ( GetMasterProjectData( gProj.szMpj,
                                           NULL,
                                           NULL,
                                           FALSE) == SUCCESS )
                {
                    sprintf( szDHW, "%s - %s", szAppName, gProj.szMpj);
                    SetWindowTextA( hMainWnd, szDHW);
                    SendMessage( hMainWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                }
            }
            DragFinish((HDROP)wParam);
            return( TRUE);
        }

    case WM_COMMAND:

        if ( DoMenuCommand( hWnd, wMsg, wParam, lParam) )
        {
            return( TRUE);
        }
        break;

    case WM_CLOSE:

        SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
        DestroyWindow( hMainWnd);
        DestroyWindow( hListWnd);
        DestroyWindow( hStatusWnd);
        _fcloseall();
        FreeLangList();

#ifdef _DEBUG
        {
            FILE *pLeakList = fopen( "C:\\LEAKLIST.TXT", "wt");
            FreeMemList( pLeakList);
            fclose( pLeakList);
        }
#endif // _DEBUG

        break;

    case WM_CREATE:
        {
            HDC hdc;
            int cyBorder;
            TEXTMETRIC tm;

            hdc  = GetDC (hWnd);
            GetTextMetrics(hdc, &tm);
            ReleaseDC(hWnd, hdc);

            cyBorder = GetSystemMetrics(SM_CYBORDER);

            cyChildHeight = tm.tmHeight + 6 + cyBorder * 2;
            break;
        }


    case WM_DESTROY:

        WinHelpA( hWnd, gszHelpFile, HELP_QUIT, 0L);
        DragAcceptFiles( hMainWnd, FALSE);
        PostQuitMessage( 0);
        break;

    case WM_INITMENU:
        // Enable or Disable the Paste menu item
        // based on available Clipboard Text data
        if ( wParam == (WPARAM)GetMenu( hMainWnd) )
        {
            if ( OpenClipboard( hWnd))
            {
#if defined(UNICODE)
                if ((IsClipboardFormatAvailable(CF_UNICODETEXT) ||
                     IsClipboardFormatAvailable(CF_OEMTEXT)) &&
                    fMtkFile)
#else // not UNICODE
                if ((IsClipboardFormatAvailable(CF_TEXT) ||
                     IsClipboardFormatAvailable(CF_OEMTEXT)) &&
                    fMtkFile)
#endif // UNICODE
                {
                    EnableMenuItem((HMENU) wParam, IDM_E_PASTE, MF_ENABLED);
                }
                else
                {
                    EnableMenuItem((HMENU) wParam, IDM_E_PASTE, MF_GRAYED);
                }

                CloseClipboard();
                return (TRUE);
            }
        }
        break;

    case WM_QUERYENDSESSION:
        /* message: to end the session? */
        if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    case WM_SETFOCUS:
        SetFocus (hListWnd);
        break;

    case WM_DRAWITEM:
        DrawLBItem((LPDRAWITEMSTRUCT) lParam);
        break;

    case WM_DELETEITEM:
        GlobalFree((HGLOBAL) ((LPDELETEITEMSTRUCT) lParam)->itemData);
        break;

    case WM_SIZE:
        {
            int cxWidth;
            int cyHeight;
            int xChild;
            int yChild;

            cxWidth  = LOWORD(lParam);
            cyHeight = HIWORD(lParam);

            xChild = 0;
            yChild = cyHeight - cyChildHeight + 1;

            MoveWindow(hListWnd, 0, 0, cxWidth, yChild , TRUE);
            MoveWindow(hStatusWnd, xChild, yChild, cxWidth, cyChildHeight, TRUE);
            break;
        }

    case WM_LOADTOKENS:
        {
            HMENU hMenu = NULL;
            FILE *f = NULL;
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

            // Remove the current token list
            SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            CleanDeltaList();

            // Hide token list, while we add new tokens
            ShowWindow(hListWnd, SW_HIDE);

            if ( OpenFile( gMstr.szMtk, &Of, OF_EXIST) == HFILE_ERROR )
            {
                // file doesn't exist, create it
                BOOL bUpdate;
                HCURSOR hOldCursor;

                hOldCursor = SetCursor(hHourGlass);
                LoadCustResDescriptions(gMstr.szRdfs);

                GenerateTokFile(gMstr.szMtk,
                                gMstr.szSrc,
                                &bUpdate, 0);
                SetCursor(hOldCursor);
                ClearResourceDescriptions();
                SzDateFromFileName( gMstr.szSrcDate,           gMstr.szSrc);
                SzDateFromFileName( gMstr.szMpjLastRealUpdate, gMstr.szMtk);
                fMpjChanges   = TRUE;
                fMPJOutOfDate = FALSE;
            }

            SzDateFromFileName( szDHW, gMstr.szSrc);

            if ( lstrcmpA( szDHW, gMstr.szSrcDate) )
            {
                HCURSOR hOldCursor;
                BOOL bUpdate;

                // MPJ is not up to date
                fMPJOutOfDate = TRUE;
                hOldCursor = SetCursor( hHourGlass);
                LoadCustResDescriptions( gMstr.szRdfs);
                GenerateTokFile( gMstr.szMtk,
                                 gMstr.szSrc,
                                 &bUpdate, 0);
                if ( bUpdate )
                {
                    SzDateFromFileName( gMstr.szMpjLastRealUpdate,
                                        gMstr.szMtk);
                }

                ClearResourceDescriptions();
                SzDateFromFileName(gMstr.szSrcDate,
                                   gMstr.szSrc);
                fMpjChanges   = TRUE;
                fMPJOutOfDate = FALSE;
                SetCursor(hOldCursor);
            }
            else
            {
                fMPJOutOfDate = FALSE;
            }

            if ( f = fopen(gMstr.szMtk,"rt") )
            {
                HCURSOR hOldCursor;

                hOldCursor = SetCursor(hHourGlass);

                // Insert tokens from token file into the list box
                pTokenDeltaInfo = InsertMtkList(f);
                FCLOSE(f);

                // Make list box visible
                ShowWindow(hListWnd, SW_SHOW);

                hMenu=GetMenu(hWnd);
                EnableMenuItem(hMenu, IDM_P_CLOSE,     MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_P_VIEW,      MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FIND,      MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDUP,    MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDDOWN,  MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_REVIEW,    MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_COPY,      MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_COPYTOKEN, MF_ENABLED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_PASTE,     MF_ENABLED|MF_BYCOMMAND);
                fMtkFile = TRUE;
                fMtkChanges = FALSE;

                SetCursor(hOldCursor);
            }
            break;
        }

    case WM_SAVEPROJECT:
        {
            fMtkFile = FALSE;

            if ( fMtkChanges )
            {
                FILE *f = NULL;

                if ( (f = fopen( gMstr.szMtk, "wt")) )
                {
                    SaveMtkList( hWnd,f);
                    FCLOSE(f);
                    SzDateFromFileName( gMstr.szMpjLastRealUpdate,
                                        gMstr.szMtk);
                    fMtkChanges = FALSE;
                    fMpjChanges = TRUE;
                }
                else
                {
                    LoadStrIntoAnsiBuf(hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                    MessageBoxA( hWnd,
                                 szDHW,
                                 gMstr.szMtk,
                                 MB_ICONHAND | MB_OK);
                    return FALSE;
                }
            }

            if ( fMpjChanges )
            {
                if ( PutMasterProjectData( gProj.szMpj) != SUCCESS )
                {
                    LoadStrIntoAnsiBuf(hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                    MessageBoxA(hWnd, szDHW,gProj.szMpj, MB_ICONHAND | MB_OK);
                    return FALSE;
                }
                fMpjChanges = FALSE;
            }
            return TRUE; // everything saved ok
        }
    default:
        break;
    }
    return (DefWindowProc(hWnd, wMsg, wParam, lParam));
}

/**
  *
  *
  *  Function: DoListBoxCommand
  *   Processes the messages sent to the list box. If the message is
  *   not reconized as a list box message, it is ignored and not processed.
  *   As the user scrolls through the tokens WM_UPDSTATLINE messages are
  *   sent to the status window to indicate the current selected token.
  *   The list box goes into Edit Mode by  pressing the enter key, or
  *   by double clicking on the list box.  After the edit is done, a WM_TOKEDIT
  *   message is sent back to the list box to update the token. The
  *   list box uses control ID IDC_LIST.
  *
  *
  *
  *  Arguments:
  *   wMsg    List Box message ID
  *   wParam  Either IDC_LIST, or VK_RETURN depending on wMsg
  *   lParam  LPTSTR to selected token during WM_TOKEDIT message.
  *
  *  Returns:
  *
  *
  *  Errors Codes:
  *   TRUE.  Message processed.
  *   FALSE. Message not processed.
  *
  *  History:
  *   01/92 Implemented.            TerryRu.
  *   01/92 Fixed problem with DblClick, and Enter processing.  TerryRu.
  *
  *
  **/

INT_PTR DoListBoxCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TOKEN  tok;                     // struct for token read from token list
    TCHAR  szName[32] = TEXT("");   // buffer to hold token name

    CHAR   szTmpBuf[64] = "";
    TCHAR  szID[14]     = TEXT(""); // buffer to hold token id
    TCHAR  sz[512]      = TEXT(""); // buffer to hold messages
    static UINT wIndex= 0;
    LONG   lListParam = 0L;
    HWND   hCtl       = NULL;
    LPTSTR lpstrToken = NULL;
    HGLOBAL hMem = NULL;

    // this is the WM_COMMAND

    switch (wMsg)
    {
    case WM_TOKEDIT:
        {
            WORD wReservedOld;
            TCHAR *szBuffer;

            // Message sent by TokEditDlgProc to
            // indicate change in the token text.
            // Response to the message by inserting
            // new token text into list box

            // Insert the selected token into token struct

            hMem = (HGLOBAL)SendMessage( hListWnd,
                                         LB_GETITEMDATA,
                                         (WPARAM)wIndex,
                                         (LPARAM)0);
            lpstrToken = (LPTSTR)GlobalLock( hMem);
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
            lstrcpy( szBuffer, lpstrToken);
            GlobalUnlock( hMem);
            ParseBufToTok(szBuffer, &tok);
            RLFREE( szBuffer);

            wReservedOld = tok.wReserved;

            switch (LOWORD(wParam))
            {
            case 0:
                tok.wReserved = 0;
                break;

            case 1:
                tok.wReserved = ST_CHANGED|ST_NEW;
                break;

            case 2:
                tok.wReserved = ST_NEW;
                break;

            case 3:
                tok.wReserved = ST_READONLY;
                break;
            }

            if (wReservedOld != tok.wReserved)
            {
                fMtkChanges = TRUE;
            }
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok)));
            ParseTokToBuf( szBuffer, &tok);
            RLFREE( tok.szText);

            SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)FALSE, (LPARAM)0);

            // Now remove old token
            SendMessage( hListWnd, LB_DELETESTRING, (WPARAM)wIndex, (LPARAM)0);

            // Replacing with the new token
            hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( lstrlen( szBuffer) + 1));
            lpstrToken = (LPTSTR)GlobalLock( hMem);
            lstrcpy( lpstrToken, szBuffer);
            GlobalUnlock( hMem);
            SendMessage( hListWnd,
                         LB_INSERTSTRING,
                         (WPARAM)wIndex,
                         (LPARAM)hMem);
            RLFREE( szBuffer);

            // Now put focus back on the current string
            SendMessage( hListWnd, LB_SETCURSEL, (WPARAM)wIndex, (LPARAM)0);
            SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)TRUE, (LPARAM)0);
            InvalidateRect( hListWnd, NULL, TRUE);

            return TRUE;
        }
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        {
#ifdef RLWIN16
            LONG lListParam = 0;
#endif
            UINT wListParam = 0;

            // Messages sent to list box when  keys are depressed.
            // Check for Return key pressed.
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case VK_RETURN:
#ifdef RLWIN16
                lListParam = (LONG) MAKELONG(NULL,  LBN_DBLCLK);
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             (WPARAM)IDC_LIST,
                             (LPARAM)lListParam);
#else
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                             (LPARAM)0);
#endif

            default:
                break;
            }
            break;
        }
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_LIST:
            /*
             *
             * This is where we process the list box messages.
             * The TokEditDlgProc is used to
             * edit the token selected in LBS_DBLCLK message
             *
             */
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case (UINT) LBN_ERRSPACE:
                LoadString( hInst,
                            IDS_ERR_NO_MEMORY,
                            sz,
                            TCHARSIN( sizeof( sz)));
                MessageBox ( hWnd,
                             sz,
                             tszAppName,
                             MB_ICONHAND | MB_OK);
                return TRUE;

            case LBN_DBLCLK:
                {
                    TCHAR szResIDStr[20] = TEXT("");
                    LPTSTR lpstrToken;
                    TCHAR *szBuffer;

                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);
                    if (wIndex == (UINT) -1)
                    {
                        return TRUE;
                    }

                    // double click, or Return entered, go into token edit mode.

                    if (!hTokEditDlgWnd)
                    {
                        // set up modaless dialog box to edit token
#ifdef RLWIN32
                        hTokEditDlgWnd = CreateDialog(hInst,
                                                      TEXT("RLAdmin"),
                                                      hWnd,
                                                      TokEditDlgProc);
#else
                        lpTokEditDlg = (FARPROC) MakeProcInstance(TokEditDlgProc,
                                                                  hInst);
                        hTokEditDlgWnd = CreateDialog(hInst,
                                                      TEXT("RLAdmin"),
                                                      hWnd,
                                                      lpTokEditDlg);
#endif
                    }

                    // Get token info from listbox, and place in token struct
                    hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)wIndex,
                                                 (LPARAM)0);
                    lpstrToken = (LPTSTR)GlobalLock( hMem);
                    szBuffer = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                    lstrcpy( szBuffer, lpstrToken);
                    GlobalUnlock( hMem);
                    ParseBufToTok(szBuffer, &tok);
                    RLFREE( szBuffer);

                    // Now get the token name
                    // Its either a string, or ordinal number

                    if (tok.szName[0])
                    {
                        lstrcpy(szName, tok.szName);
                    }
                    else
                    {
#ifdef UNICODE
                        _itoa( tok.wName, szTmpBuf, 10);
                        _MBSTOWCS( szName,
                                   szTmpBuf,
                                   WCHARSIN( sizeof( szName)),
                                   ACHARSIN( strlen( szTmpBuf) + 1));
#else

                        _itoa(tok.wName, szName, 10);
#endif
                    }
                    // Now get the token id
#ifdef UNICODE
                    _itoa( tok.wID, szTmpBuf, 10);
                    _MBSTOWCS( szID,
                               szTmpBuf,
                               WCHARSIN( sizeof( szID)),
                               ACHARSIN( strlen( szTmpBuf) + 1));
#else
                    _itoa( tok.wID, szID, 10);
#endif
                    if ( tok.wType <= 16 || tok.wType == ID_RT_DLGINIT )
                    {
                        LoadString( hInst,
                                    IDS_RESOURCENAMES+tok.wType,
                                    szResIDStr,
                                    TCHARSIN( sizeof( szResIDStr)));
                    }
                    else
                    {
#ifdef UNICODE
                        _itoa( tok.wType, szTmpBuf, 10);
                        _MBSTOWCS( szResIDStr,
                                   szTmpBuf,
                                   WCHARSIN( sizeof( szResIDStr)),
                                   ACHARSIN( strlen( szTmpBuf) + 1));
#else
                        _itoa( tok.wType, szResIDStr, 10);
#endif
                    }

                    // Now insert token info  in TokEdit Dialog Box
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKTYPE,
                                   (LPTSTR) szResIDStr);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKNAME,
                                   (LPTSTR) szName);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKID,
                                   (LPTSTR) szID);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKCURTEXT,
                                   (LPTSTR) tok.szText);
                    SetDlgItemText(hTokEditDlgWnd,
                                   IDD_TOKPREVTEXT,
                                   (LPTSTR) FindDeltaToken(tok,
                                                           pTokenDeltaInfo,
                                                           ST_CHANGED));

                    hCtl = GetDlgItem(hTokEditDlgWnd,IDD_STATUS);
                    {
                        int i;

                        if (tok.wReserved & ST_READONLY)
                        {
                            i = 3;
                        }
                        else if (tok.wReserved == ST_NEW)
                        {
                            i = 2;
                        }
                        else if (tok.wReserved & ST_CHANGED)
                        {
                            i = 1;
                        }
                        else
                        {
                            i = 0;
                        }
                        SendMessage( hCtl, CB_SETCURSEL, (WPARAM)i, (LPARAM)0);
                    }

                    SetActiveWindow(hTokEditDlgWnd);
                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);
                    RLFREE( tok.szText);

                    return TRUE;
                }

                // let these messages fall through,
            default:
                break;
            }
        default:
            return FALSE;
        }

        break; // WM_COMMAND Case

    } // Main List Box Switch

    return FALSE;
}

/**
  *
  *
  *  Function: DoMenuCommand.
  *   Processes the Menu Command messages.
  *
  *  Errors Codes:
  *   TRUE. Message processed.
  *   FALSE. Message not processed.
  *
  *  History:
  *   01/92. Implemented.       TerryRu.
  *
  *
  **/

INT_PTR DoMenuCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fListBox = FALSE;
    CHAR        sz[256]="";
    TCHAR       tsz[256] = TEXT("");
#ifndef RLWIN32
    FARPROC     lpNewDlg,lpViewDlg;
#endif

    // Commands entered from the application menu, or child windows.
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {

    case IDM_P_NEW:

        if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
        {
            CHAR szOldFile[MAXFILENAME] = "";


            strcpy( szOldFile, szFileName);

            if ( ! GetFileNameFromBrowse( hWnd,
                                          szFileName,
                                          MAXFILENAME,
                                          szSaveDlgTitle,
                                          szFilterSpec,
                                          "MPJ"))
            {
                break;
            }
            strcpy( gProj.szMpj, szFileName);

#ifdef RLWIN32
            if (DialogBox(hInst, TEXT("PROJECT"), hWnd, NewDlgProc))
#else
            lpNewDlg = MakeProcInstance( NewDlgProc, hInst);

            if (DialogBox(hInst, TEXT("PROJECT"), hWnd, lpNewDlg))
#endif
            {
                sprintf( szDHW, "%s - %s", szAppName, gProj.szMpj);
                SetWindowTextA( hWnd,szDHW);
                gMstr.szSrcDate[0] = 0;
                gMstr.szMpjLastRealUpdate[0] = 0;
                SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            }
            else
            {
                strcpy( gProj.szMpj, szOldFile);
            }
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
        }
        break;

    case IDM_P_OPEN:

        if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
        {
            if ( GetFileNameFromBrowse( hWnd,
                                        gProj.szMpj,
                                        MAXFILENAME,
                                        szOpenDlgTitle,
                                        szFilterSpec,
                                        "MPJ"))
            {
                if ( GetMasterProjectData( gProj.szMpj, NULL, NULL, FALSE) == SUCCESS )
                {

                    sprintf( szDHW, "%s - %s", szAppName, gProj.szMpj);
                    SetWindowTextA( hMainWnd, szDHW);
                    SendMessage( hMainWnd,
                                 WM_LOADTOKENS,
                                 (WPARAM)0,
                                 (LPARAM)0);
                }
            }
        }
        break;

    case IDM_P_VIEW:

#ifdef RLWIN32
        DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, ViewDlgProc);
#else
        lpViewDlg = MakeProcInstance(ViewDlgProc, hInst);
        DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, lpViewDlg);
#endif
        break;

    case IDM_P_CLOSE:
        {
            HMENU hMenu;

            hMenu = GetMenu(hWnd);
            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                // Remove file name from window title
                SetWindowTextA(hMainWnd, szAppName);

                // Hide token list since it's empty
                ShowWindow(hListWnd, SW_HIDE);

                // Remove the current token list
                SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
                CleanDeltaList();

                // Force Repaint of status Window
                InvalidateRect(hStatusWnd, NULL, TRUE);

                EnableMenuItem(hMenu,IDM_P_CLOSE,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_P_VIEW,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_FIND,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_FINDUP,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_FINDDOWN,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_REVIEW,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_COPY,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_COPYTOKEN,MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu,IDM_E_PASTE,MF_GRAYED|MF_BYCOMMAND);
            }
            break;
        }

    case IDM_P_EXIT:
        // send wm_close message to main window
        PostMessage(hMainWnd, WM_CLOSE, (WPARAM)0, (LPARAM)0);
        break;

    case IDM_E_COPYTOKEN:
        {
            HGLOBAL hStringMem = NULL;
            LPTSTR  lpString   = NULL;
            int     nIndex  = 0;
            int     nLength = 0;
            LPTSTR  lpstrToken = NULL;

            // Is anything selected in the listbox
            if ( (nIndex = (int)SendMessage( hListWnd,
                                             LB_GETCURSEL,
                                             (WPARAM)0,
                                             (LPARAM)0)) != LB_ERR )
            {
                HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                     LB_GETITEMDATA,
                                                     (WPARAM)nIndex,
                                                     (LPARAM)0);
                lpstrToken = (LPTSTR)GlobalLock( hMem);
                nLength = lstrlen( lpstrToken);

                // Allocate memory for the string
                if ( (hStringMem =
                      GlobalAlloc(GHND, (DWORD) MEMSIZE(nLength+1))) != NULL )
                {
                    if ( (lpString = (LPTSTR)GlobalLock( hStringMem)) != NULL )
                    {
                        // Get the selected text
                        lstrcpy( lpString, lpstrToken);
                        GlobalUnlock( hMem);
                        // Unlock the block
                        GlobalUnlock( hStringMem);

                        // Open the Clipboard and clear its contents
                        OpenClipboard( hWnd);
                        EmptyClipboard();

                        // Give the Clipboard the text data

#if defined(UNICODE)
                        SetClipboardData(CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                        SetClipboardData( CF_TEXT, hStringMem);
#endif // UNICODE

                        CloseClipboard();

                        hStringMem = NULL;
                    }
                    else
                    {
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    tsz,
                                    TCHARSIN( sizeof( tsz)));
                        MessageBox( hWnd,
                                    tsz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                }
                else
                {
                    LoadString( hInst,
                                IDS_ERR_NO_MEMORY,
                                tsz,
                                TCHARSIN( sizeof(tsz)));
                    MessageBox( hWnd,
                                tsz,
                                tszAppName,
                                MB_ICONHAND | MB_OK);
                }
            }
            break;
        }

    case IDM_E_COPY:
        {
            HGLOBAL hStringMem  = NULL;
            HGLOBAL hMem = NULL;
            LPTSTR  lpString = NULL;
            TCHAR  *pszString = NULL;
            int     nIndex  = 0;
            int     nLength = 0;
            int     nActual = 0;
            TOKEN   tok;
            LPTSTR  lpstrToken   = NULL;

            // Is anything selected in the listbox
            if ( (nIndex = (int)SendMessage( hListWnd,
                                             LB_GETCURSEL,
                                             (WPARAM)0,
                                             (LPARAM)0)) != LB_ERR )
            {
                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)nIndex,
                                             (LPARAM)0);
                lpstrToken = (LPTSTR)
                pszString = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1 ));
                lstrcpy( pszString, lpstrToken);
                GlobalUnlock( hMem);
                ParseBufToTok( pszString, &tok);
                RLFREE( pszString);

                nLength = lstrlen(tok.szText);

                // Allocate memory for the string
                if ((hStringMem =
                     GlobalAlloc(GHND, (DWORD)MEMSIZE( nLength + 1))) != NULL)
                {
                    if ( (lpString = (LPTSTR)GlobalLock( hStringMem)) != NULL)
                    {
                        // Get the selected text
                        lstrcpy( lpString, tok.szText);

                        // Unlock the block
                        GlobalUnlock( hStringMem);

                        // Open the Clipboard and clear its contents
                        OpenClipboard(hWnd);
                        EmptyClipboard();

                        // Give the Clipboard the text data

#if defined(UNICODE)
                        SetClipboardData(CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                        SetClipboardData(CF_TEXT, hStringMem);
#endif // UNICODE

                        CloseClipboard();

                        hStringMem = NULL;
                    }
                    else
                    {
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    tsz,
                                    TCHARSIN( sizeof(tsz)));
                        MessageBox( hWnd,
                                    tsz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                }
                else
                {
                    LoadString( hInst,
                                IDS_ERR_NO_MEMORY,
                                tsz,
                                TCHARSIN( sizeof( tsz)));
                    MessageBox( hWnd,
                                tsz,
                                tszAppName,
                                MB_ICONHAND | MB_OK);
                }
                RLFREE( tok.szText);
            }
            break;
        }

    case IDM_E_PASTE:
        {
            HGLOBAL hClipMem  = NULL;
            HGLOBAL hMem = NULL;
            LPTSTR  lpClipMem = NULL;
            TCHAR   *pszPasteString = NULL;
            int     nIndex    = 0;
            TOKEN   tok;
            LPTSTR  lpstrToken = NULL;

            if (OpenClipboard(hWnd))
            {

#if defined(UNICODE)
                if(IsClipboardFormatAvailable(CF_UNICODETEXT) ||
                    IsClipboardFormatAvailable(CF_OEMTEXT))
#else // not UNICODE
                if(IsClipboardFormatAvailable(CF_TEXT) ||
                    IsClipboardFormatAvailable(CF_OEMTEXT))
#endif // UNICODE

                {
                    // Check for current position and change that token's text
                    nIndex = (int) SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);

                    if (nIndex == LB_ERR)
                    {
#if defined(UNICODE)	// if no select, just ignore it.
                        break;
#else // not UNICODE
			nIndex = -1;
#endif // UNICODE
                    }

#if defined(UNICODE)	//enabled Paste command
                    hClipMem = GetClipboardData(CF_UNICODETEXT);
#else // not UNICODE
                    hClipMem = GetClipboardData(CF_TEXT);
#endif // UNICODE

                    lpClipMem = (LPTSTR)GlobalLock( hClipMem);
                    hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)nIndex,
                                                 (LPARAM)0);
                    lpstrToken = (LPTSTR)GlobalLock( hMem);
                    pszPasteString = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                    lstrcpy( pszPasteString, lpstrToken);
                    GlobalUnlock( hMem);
                        // copy the string to the token
                    ParseBufToTok( pszPasteString, &tok);
                    RLFREE( pszPasteString);
                    RLFREE( tok.szText);

                    tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpClipMem) + 1));
                    lstrcpy( tok.szText, lpClipMem);

                    GlobalUnlock(hClipMem);
                    pszPasteString = (LPTSTR)FALLOC( MEMSIZE( TokenToTextSize( &tok) + 1));
                    ParseTokToBuf( pszPasteString, &tok);
                    RLFREE( tok.szText);

                        // Paste the text
                    SendMessage( hListWnd,
                                 WM_SETREDRAW,
                                 (WPARAM)FALSE,
                                 (LPARAM)0);

                    SendMessage( hListWnd,
                                 LB_DELETESTRING,
                                 (WPARAM)nIndex,
                                 (LPARAM)0);

                    hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( lstrlen( pszPasteString)+1));
                    lpstrToken = (LPTSTR)GlobalLock( hMem);
                    lstrcpy( lpstrToken, pszPasteString);
                    GlobalUnlock( hMem);
                    SendMessage( hListWnd,
                                 LB_INSERTSTRING,
                                 (WPARAM)nIndex,
                                 (LPARAM)hMem);
                    SendMessage( hListWnd,
                                 LB_SETCURSEL,
                                 (WPARAM)nIndex,
                                 (LPARAM)0);
                    SendMessage( hListWnd,
                                 WM_SETREDRAW,
                                 (WPARAM)TRUE,
                                 (LPARAM)0);
                    InvalidateRect(hListWnd,NULL,TRUE);
                    fMtkChanges = TRUE; // Set Dirty Flag
                    RLFREE( pszPasteString);

                    // Close the Clipboard
                    CloseClipboard();

                    SetFocus(hListWnd);
                }
            }
            CloseClipboard();
            break;
        }

    case IDM_E_FINDDOWN:

        if (fSearchStarted)
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  0,
                                  TRUE) )
            {
                TCHAR sz1[80], sz2[80];

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd, sz2, sz1, MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FINDUP:

        if (fSearchStarted)
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  1,
                                  TRUE) )
            {
                TCHAR sz1[80], sz2[80];
                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd, sz2, sz1, MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FIND:
        {
#ifndef RLWIN32
            FARPROC lpfnTOKFINDMsgProc;

            lpfnTOKFINDMsgProc = MakeProcInstance((FARPROC)TOKFINDMsgProc,
                                                  hInst);

            if (!DialogBox( hInst, TEXT("TOKFIND"), hWnd, lpfnTOKFINDMsgProc))
#else
            if (!DialogBox(hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc))
#endif
	    {
#ifndef DBCS
// 'Token Not Found' is strange because user selected cancel #3042
                TCHAR sz1[80] = TEXT("");
                TCHAR sz2[80] = TEXT("");

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd, sz2, sz1, MB_ICONINFORMATION | MB_OK);
#endif	//DBCS
	    }
#ifndef RLWIN32
            FreeProcInstance( lpfnTOKFINDMsgProc);
#endif
            return TRUE;
        }

    case IDM_E_REVIEW:
        {
            LRESULT lrSaveSelection = 0;

            nUpdateMode = 1;

            // set listbox selection to begining of the token list
            lrSaveSelection = SendMessage( hListWnd,
                                           LB_GETCURSEL,
                                           (WPARAM)0,
                                           (LPARAM)0);

            SendMessage( hListWnd, LB_SETCURSEL, (WPARAM)0, (LPARAM)0);

            if ( DoTokenSearch( NULL, NULL, ST_NEW, ST_NEW, FALSE, FALSE) )
            {
#ifdef RLWIN32
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                             (LPARAM)0);
#else
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             IDC_LIST,
                             MAKELONG( 0, LBN_DBLCLK));
#endif
            }
        }
        break;


    case IDM_H_CONTENTS:
    {
        OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

        if ( OpenFile( gszHelpFile, &Of, OF_EXIST) == HFILE_ERROR)
        {
            LoadString( hInst,
                        IDS_ERR_NO_HELP ,
                        tsz,
                        TCHARSIN( sizeof( tsz)));
            MessageBox( hWnd, tsz, NULL, MB_OK);
        }
        else
        {
            WinHelpA( hWnd, gszHelpFile, HELP_KEY,(DWORD_PTR)((LPSTR)"RLAdmin"));
        }
        break;
    }

    case IDM_H_ABOUT:
        {
#ifndef RLWIN32

            WNDPROC lpProcAbout;

            lpProcAbout = MakeProcInstance(About, hInst);
            DialogBox(hInst, TEXT("ABOUT"), hWnd, lpProcAbout);
            FreeProcInstance(lpProcAbout);
#else
            DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#endif
        }
        break;

    default:
        break;
    }  // WM_COMMAND switch
    return FALSE;
}

/**
  *
  *
  *  Function:  TokEditDlgProc
  *   Procedure for the edit mode dialog window. Loads the selected token
  *   info into the window, and allows the user to change the token text.
  *   Once the edit is complete, the procedure sends a message to the
  *   list box windows to update the current token info.
  *
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  *   TRUE, carry out edit, and update token list box.
  *   FALSE, cancel edit.
  *
  *  History:
  *
  *
  **/

INT_PTR TokEditDlgProc(

HWND   hDlg,
UINT   wMsg,
WPARAM wParam,
LPARAM lParam)
{
    HWND    hCtl;
    HWND    hParentWnd;
    UINT    static wcTokens = 0;
    UINT    wIndex;
    static BOOL fChanged = FALSE;

    switch(wMsg)
    {
    case WM_INITDIALOG:
        cwCenter(hDlg, 0);
        wcTokens = (UINT)SendMessage( hListWnd,
                                      LB_GETCOUNT,
                                      (WPARAM)0,
                                      (LPARAM)0);
        wcTokens--;
        hCtl = GetDlgItem(hDlg,IDD_STATUS);
        {
            TCHAR sz[80];

            LoadString( hInst, IDS_UNCHANGED, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);

            LoadString( hInst, IDS_CHANGED, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);

            LoadString( hInst, IDS_NEW, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);

            LoadString( hInst, IDS_READONLY, sz, TCHARSIN( sizeof( sz)));
            SendMessage( hCtl, CB_ADDSTRING, (WPARAM)0, (LPARAM)sz);
        }

        if( ! nUpdateMode )
        {

            if (hCtl = GetDlgItem(hDlg, IDD_SKIP))
            {
                EnableWindow(hCtl, FALSE);
            }
        }
        else
        {
            if (hCtl = GetDlgItem(hDlg, IDD_SKIP))
            {
                EnableWindow(hCtl, TRUE);
            }
        }
        fChanged = FALSE;
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_SKIP:
            wIndex = (UINT)SendMessage( hListWnd,
                                        LB_GETCURSEL,
                                        (WPARAM)0,
                                        (LPARAM)0);

            if ( nUpdateMode &&  wIndex < wcTokens )
            {
                wIndex ++;
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wIndex,
                             (LPARAM)0);

                if ( DoTokenSearch( NULL, NULL, ST_NEW, ST_NEW, FALSE, FALSE) )
                {
                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (WPARAM)0,
                                                (LPARAM)0);
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                 (LPARAM)0);
                    return TRUE;
                }
            }
            nUpdateMode = 0;
            DestroyWindow(hDlg);
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
            hTokEditDlgWnd = 0;
            break;

        case IDD_STATUS:
            fChanged = TRUE;
            break;

        case IDOK:
            wIndex = (UINT)SendMessage( hListWnd,
                                        LB_GETCURSEL,
                                        (WPARAM)0,
                                        (LPARAM)0);
            if (fChanged)
            {
                int i;
                fChanged = FALSE;

                hCtl = GetDlgItem(hDlg, IDD_STATUS);
                i = (int)SendMessage( hCtl,
                                      CB_GETCURSEL,
                                      (WPARAM)0,
                                      (LPARAM)0);
                hParentWnd = GetParent(hDlg);
                SendMessage( hParentWnd, WM_TOKEDIT, (WPARAM)i, (LPARAM)0);
            }
            // Exit, or goto to next changed token if in update mode

            if ( nUpdateMode && wIndex < wcTokens )
            {
                wIndex++;
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wIndex,
                             (LPARAM)0);

                if ( DoTokenSearch( NULL, NULL, ST_NEW, ST_NEW, FALSE, FALSE) )
                {
                    // go into edit mode
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                 (LPARAM)0);

                    return TRUE;
                }
            }
            // fall through to IDCANCEL

        case IDCANCEL:
            nUpdateMode = 0;
            // remove edit dialog box
            DestroyWindow(hDlg);
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
            hTokEditDlgWnd = 0;
            break;

        } // WM_COMMAND
        return TRUE;

    default:
        if (hCtl = GetDlgItem(hDlg, IDOK))
        {
            EnableWindow(hCtl, TRUE);
        }
        return FALSE;
    } // Main Switch
}

/**
  *
  *
  *  Function: TOKFINDMsgProc
  *
  *  Arguments:
  *
  *  Returns:
  *   NA.
  *
  *  Errors Codes:
  *
  *  History:
  *
  *
  **/


INT_PTR TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hCtl;
    int rgiTokenTypes[]=
    {
        ID_RT_MENU,
        ID_RT_DIALOG,
        ID_RT_STRING,
        ID_RT_ACCELERATORS,
        ID_RT_RCDATA,
        ID_RT_ERRTABLE,
        ID_RT_NAMETABLE,
        ID_RT_VERSION,
        ID_RT_DLGINIT
    };

    TCHAR szTokenType[40] = TEXT("");
    UINT i;

    switch(wMsg)
    {
    case WM_INITDIALOG:

        CheckDlgButton(hWndDlg, IDD_READONLY, 2);
        CheckDlgButton(hWndDlg, IDD_CHANGED, 2);
        CheckDlgButton(hWndDlg, IDD_FINDDOWN, 1);
        hCtl = GetDlgItem(hWndDlg, IDD_TYPELST);

        for ( i = 0; i < sizeof( rgiTokenTypes) / 2; i++)
        {
            LoadString( hInst,
                        IDS_RESOURCENAMES + rgiTokenTypes[i],
                        szTokenType,
                        TCHARSIN( sizeof( szTokenType)));
            SendMessage( hCtl,
                         CB_ADDSTRING,
                         (WPARAM)0,
                         (LPARAM)szTokenType);
        }
        return TRUE;
        break;

    case WM_COMMAND:

        switch(wParam)
        {
        case IDOK: /* Button text: "Okay"                        */
            fSearchStarted = TRUE;
            GetDlgItemText( hWndDlg,
                            IDD_TYPELST,
                            szSearchType,
                            TCHARSIN( sizeof( szSearchType)));
            GetDlgItemText( hWndDlg,
                            IDD_FINDTOK,
                            szSearchText,
                            TCHARSIN( sizeof( szSearchText)));

            wSearchStatus = wSearchStatusMask = 0;

            switch (IsDlgButtonChecked(hWndDlg, IDD_READONLY))
            {
            case 1:
                wSearchStatus |= ST_READONLY;

            case 0:
                wSearchStatusMask |= ST_READONLY;
            }

            switch (IsDlgButtonChecked(hWndDlg, IDD_CHANGED))
            {
            case 1:
                wSearchStatus |= ST_CHANGED;

            case 0:
                wSearchStatusMask |= ST_CHANGED;
            }

            fSearchDirection = IsDlgButtonChecked(hWndDlg, IDD_FINDUP);

            if( DoTokenSearch(szSearchType,
                              szSearchText,
                              wSearchStatus,
                              wSearchStatusMask,
                              fSearchDirection,
                              FALSE) )
            {
                EndDialog( hWndDlg, TRUE );
            }
            else
            {
                TCHAR sz1[80], sz2[80];

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWndDlg, sz2, sz1, MB_ICONINFORMATION | MB_OK);
                EndDialog( hWndDlg, FALSE );
            }

        case IDCANCEL:

            EndDialog( hWndDlg, FALSE);
            return TRUE;
        }
        break;      /* End of WM_COMMAND     */

    default:
        return FALSE;
    }
    return FALSE;
}

/**
  *  Function:  NewDlgProc
  *   Procedure for the new project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  *   TRUE, carry out edit, and update token list box.
  *   FALSE, cancel edit.
  *
  *  History:
  **/

INT_PTR APIENTRY NewDlgProc(

HWND   hDlg,
UINT   wMsg,
WPARAM wParam,
LPARAM lParam)
{
    CHAR pszDrive[ _MAX_DRIVE] = "";
    CHAR pszDir[   _MAX_DIR]   = "";
    CHAR pszName[  _MAX_FNAME] = "";
    CHAR pszExt[   _MAX_EXT]   = "";


    switch ( wMsg )
    {
    case WM_INITDIALOG:
    {
        LPTSTR pszLangName = NULL;
        OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};
        int nSel = 0;


        iLastBox       = IDD_SOURCERES;
        fLangSelected  = FALSE;
        _splitpath( gProj.szMpj, pszDrive, pszDir, pszName, pszExt);

        sprintf( szDHW, "%s%s%s.%s", pszDrive, pszDir, pszName, "EXE");
        SetDlgItemTextA( hDlg, IDD_SOURCERES, szDHW);

        sprintf( szDHW, "%s%s%s.%s", pszDrive, pszDir, pszName, "MTK");
        SetDlgItemTextA( hDlg, IDD_MTK, szDHW);

        sprintf( szDHW, "%s%s%s.%s", pszDrive, pszDir, pszName, "RDF");

        if ( OpenFile( szDHW, &Of, OF_EXIST) != HFILE_ERROR )
            SetDlgItemTextA( hDlg, IDD_RDFS, szDHW);
        else
            SetDlgItemText( hDlg, IDD_RDFS, TEXT(""));

        if ( gMstr.uCodePage == CP_ACP )
            gMstr.uCodePage = GetACP();
        else if ( gMstr.uCodePage == CP_OEMCP )
            gMstr.uCodePage = GetOEMCP();

        if ( ! IsValidCodePage( gMstr.uCodePage) )
        {
            static TCHAR szMsg[ 256];
            CHAR *pszCP[1];

            pszCP[0] = UlongToPtr(gMstr.uCodePage);

            LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
            FormatMessage( FORMAT_MESSAGE_FROM_STRING
                         | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           szMsg,
                           0,
                           0,
                           (LPTSTR)szDHW,
                           DHWSIZE/sizeof(TCHAR),
                           (va_list *)pszCP);
            MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
            SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
            return( TRUE);
        }
        SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
        PostMessage( hDlg, WM_COMMAND, IDD_BROWSE, 0);
        return TRUE;
    }

    case WM_COMMAND:

        switch ( GET_WM_COMMAND_ID( wParam, lParam) )
        {
        case IDD_SOURCERES:
        case IDD_MTK:
        case IDD_RDFS:
            iLastBox = GET_WM_COMMAND_ID(wParam, lParam);
            break;

        case IDD_BROWSE:
            switch ( iLastBox )
            {
            case IDD_SOURCERES:
                szFSpec = szExeResFilterSpec;
                szExt = "EXE";
                LoadStrIntoAnsiBuf( hInst,
                                    IDS_RES_SRC,
                                    szPrompt,
                                    ACHARSIN( sizeof( szPrompt)));
                fLangSelected = FALSE;
                break;

            case IDD_RDFS:
                szFSpec = szRdfFilterSpec;
                szExt = "RDF";
                LoadStrIntoAnsiBuf( hInst,
                                    IDS_RDF,
                                    szPrompt,
                                    ACHARSIN( sizeof( szPrompt)));
                break;

            case IDD_MTK:
                szFSpec = szMtkFilterSpec;
                szExt = "MTK";
                LoadStrIntoAnsiBuf( hInst,
                                    IDS_MTK,
                                    szPrompt,
                                    ACHARSIN( sizeof(szPrompt)));
                break;
            }

            GetDlgItemTextA(hDlg, iLastBox, szNewFileName, MAXFILENAME);

            if ( GetFileNameFromBrowse( hDlg,
                                        szNewFileName,
                                        MAXFILENAME,
                                        szPrompt,
                                        szFSpec,
                                        szExt) )
            {
                SetDlgItemTextA( hDlg, iLastBox, szNewFileName);

                if ( iLastBox == IDD_SOURCERES )
                {                       // fill in suggested name for the MTK box
                    CHAR pszDrive[_MAX_DRIVE] = "";
                    CHAR pszDir[  _MAX_DIR]   = "";
                    CHAR pszName[ _MAX_FNAME] = "";
                    CHAR pszExt[  _MAX_EXT]   = "";


                    lstrcpyA( gMstr.szSrc, szNewFileName);

                    FillListAndSetLang( hDlg,
                                        IDD_MSTR_LANG_NAME,
                                        &gMstr.wLanguageID,
                                        &fLangSelected);

                    _splitpath( szNewFileName, pszDrive, pszDir, pszName, pszExt);
                    GetDlgItemTextA(hDlg, IDD_MTK, szNewFileName, MAXFILENAME);

                    if ( ! szNewFileName[0] )
                    {
                        sprintf( szNewFileName,
                                 "%s%s%s.%s",
                                 pszDrive,
                                 pszDir,
                                 pszName,
                                 "MTK");
                        SetDlgItemTextA( hDlg, IDD_MTK, szNewFileName);
                    }
                }
            }
            break;

        case IDD_MSTR_LANG_NAME:

            if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK )
            {
                fLangSelected = TRUE;
            }
            break;

        case IDOK:

            if ( fLangSelected )
            {
                MSTRDATA stProject =
                { "", "", "", "", "",
                  MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
                  CP_ACP
                };
                BOOL fTranslated = FALSE;
                UINT uCP = GetDlgItemInt( hDlg,
                                          IDD_TOK_CP,
                                          &fTranslated,
                                          FALSE);

                                //... Get the selected language name
                                //... then set the appropriate lang id vals

                INT_PTR nSel = SendDlgItemMessage( hDlg,
                                               IDD_MSTR_LANG_NAME,
                                               CB_GETCURSEL,
                                               (WPARAM)0,
                                               (LPARAM)0);

                if ( nSel != CB_ERR
                  && SendDlgItemMessage( hDlg,
                                         IDD_MSTR_LANG_NAME,
                                         CB_GETLBTEXT,
                                         (WPARAM)nSel,
                                         (LPARAM)(LPTSTR)szDHW) != CB_ERR )
                {
                    WORD wPri = 0;
                    WORD wSub = 0;

                    if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
                    {
                        gMstr.wLanguageID = MAKELANGID( wPri, wSub);
                    }
                    else
                    {
                        fLangSelected = FALSE;
                        return( TRUE);
                    }
                }

                if ( uCP == CP_ACP )
                    uCP = GetACP();
                else if ( uCP == CP_OEMCP )
                    uCP = GetOEMCP();

                if ( IsValidCodePage( uCP) )
                {
                    gMstr.uCodePage = uCP;
                }
                else
                {
                    static TCHAR szMsg[ 256];
                    CHAR *pszCP[1];

                    pszCP[0] = UlongToPtr(uCP);

                    LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
                    FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                 | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   szMsg,
                                   0,
                                   0,
                                   (LPTSTR)szDHW,
                                   DHWSIZE/sizeof(TCHAR),
                                   (va_list *)pszCP);
                    MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
                    SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
                    return( TRUE);
                }

                GetDlgItemTextA( hDlg,
                                 IDD_SOURCERES,
                                 stProject.szSrc,
                                 MAXFILENAME);

                GetDlgItemTextA( hDlg,
                                 IDD_RDFS,
                                 stProject.szRdfs,
                                 MAXFILENAME);

                GetDlgItemTextA( hDlg,
                                 IDD_MTK,
                                 stProject.szMtk,
                                 MAXFILENAME);

                if ( stProject.szSrc[0] && stProject.szMtk[0] )
                {
                    _fullpath( gMstr.szSrc,
                               stProject.szSrc,
                               ACHARSIN( sizeof( gMstr.szSrc)));

                    _fullpath( gMstr.szMtk,
                               stProject.szMtk,
                               ACHARSIN( sizeof( gMstr.szMtk)));

                    if ( stProject.szRdfs[0] )
                    {
                        _fullpath( gMstr.szRdfs,
                                   stProject.szRdfs,
                                   ACHARSIN( sizeof( gMstr.szRdfs)));
                    }
                    else
                    {
                        gMstr.szRdfs[0] = '\0';
                    }
                    gProj.fSourceEXE = IsExe( gMstr.szSrc);

                    EndDialog( hDlg, TRUE);
                    return( TRUE);
                }
                else
                {
                    break;
                }
            }
            else
            {
                LoadString( hInst, IDS_SELECTLANG, (LPTSTR)szDHW, TCHARSIN( DHWSIZE));
                MessageBox( hDlg, (LPTSTR)szDHW, tszAppName, MB_ICONHAND | MB_OK);
                break;
            }

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return( TRUE);
        }
        break;
    }
    return( FALSE);
}

/**
  *
  *
  *  Function:  ViewDlgProc
  *   Procedure for the View project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  *   TRUE, carry out edit, and update token list box.
  *   FALSE, cancel edit.
  *
  *  History:
  *
  *
  **/

INT_PTR ViewDlgProc(

HWND hDlg,
UINT wMsg,
WPARAM wParam,
LPARAM lParam)
{
    static int iLastBox = IDD_SOURCERES;

    switch(wMsg)
    {
    case WM_INITDIALOG:
    {
        WORD wPri = PRIMARYLANGID( gMstr.wLanguageID);
        WORD wSub = SUBLANGID( gMstr.wLanguageID);
        LPTSTR pszName = GetLangName( wPri, wSub);

        SetDlgItemTextA( hDlg, IDD_VIEW_SOURCERES, gMstr.szSrc);
        SetDlgItemTextA( hDlg, IDD_VIEW_MTK,       gMstr.szMtk);
        SetDlgItemTextA( hDlg, IDD_VIEW_RDFS,      gMstr.szRdfs);
        SetDlgItemText(  hDlg, IDD_MSTR_LANG_NAME, pszName);
        SetDlgItemInt( hDlg, IDD_TOK_CP, gMstr.uCodePage, FALSE);
        return TRUE;
    }

    case WM_COMMAND:

        switch ( wParam )
        {
        case IDOK:
            EndDialog( hDlg, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}


void DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    LPRECT  lprc    = (LPRECT) &(lpdis->rcItem);
    DWORD   rgbOldText  = 0;
    DWORD   rgbOldBack  = 0;
    HBRUSH  hBrush;
    static DWORD    rgbHighlightText;
    static DWORD    rgbHighlightBack;
    static HBRUSH   hBrushHilite = NULL;
    static HBRUSH   hBrushNormal = NULL;
    static DWORD    rgbChangedText;
    static DWORD    rgbBackColor;
    static DWORD    rgbUnchangedText;
    static DWORD    rgbReadOnlyText;
    static DWORD    rgbNewText;
    TCHAR   *szToken = NULL;
    TOKEN   tok;
    LPTSTR lpstrToken = NULL;

    if (lpdis->itemAction & ODA_FOCUS)
    {
        DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
    }
    else
    {
        HANDLE hMem = (HANDLE)SendMessage( lpdis->hwndItem,
                                           LB_GETITEMDATA,
                                           (WPARAM)lpdis->itemID,
                                           (LPARAM)0);
        lpstrToken = (LPTSTR)GlobalLock( hMem);
        szToken = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
        lstrcpy( szToken, lpstrToken);
        GlobalUnlock( hMem);
        ParseBufToTok(szToken, &tok);
        RLFREE( szToken);

        if (lpdis->itemState & ODS_SELECTED)
        {
            if (!hBrushHilite)
            {
                rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                rgbHighlightBack = GetSysColor(COLOR_HIGHLIGHT);
                hBrushHilite = CreateSolidBrush(rgbHighlightBack);
            }
            MakeStatusLine(&tok);

            rgbOldText = SetTextColor(lpdis->hDC, rgbHighlightText);
            rgbOldBack = SetBkColor(lpdis->hDC, rgbHighlightBack);

            hBrush = hBrushHilite;
        }
        else
        {
            if (!hBrushNormal)
            {
                rgbChangedText = RGB(255, 0, 0);
                rgbBackColor = RGB(192, 192, 192);
                rgbUnchangedText = RGB(0, 0, 0);
                rgbReadOnlyText = RGB(127, 127, 127);
                rgbNewText = RGB(0, 0, 255);
                hBrushNormal = CreateSolidBrush(rgbBackColor);
            }
            if (tok.wReserved & ST_READONLY)
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbReadOnlyText);
            }
            else if (tok.wReserved & ST_CHANGED)
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbChangedText);
            }
            else if (tok.wReserved & ST_NEW)
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbNewText);
            }
            else
            {
                rgbOldText = SetTextColor(lpdis->hDC, rgbUnchangedText);
            }
            rgbOldBack = SetBkColor(lpdis->hDC, rgbBackColor);
            hBrush = hBrushNormal;
        }
        FillRect(lpdis->hDC, (CONST RECT *)lprc, hBrush);

        DrawText(lpdis->hDC,
                 tok.szText,
                 STRINGSIZE(lstrlen(tok.szText)),
                 lprc,
                 DT_LEFT|DT_NOPREFIX);
        RLFREE( tok.szText);

        if (rgbOldText)
        {
            SetTextColor(lpdis->hDC, rgbOldText);
        }

        if (rgbOldBack)
        {
            SetBkColor(lpdis->hDC, rgbOldBack);
        }

        if (lpdis->itemState & ODS_FOCUS)
        {
            DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
        }
    }
}

/*
 * Function:  Make Status Line
 *   Builds status line string from a token
 *
 * Inputs:
 *    pszStatusLine, buffer to hold string
 *    pTok, pointer to token structure
 *
 * History:
 *   2/92, implemented      SteveBl
 *   7/92, changed to talk to new StatusWndProc  t-GregTi
 */
static void MakeStatusLine(TOKEN *pTok)
{
    static BOOL fFirstCall = TRUE;
    TCHAR szName[32] = TEXT("");
    TCHAR szStatus[20] = TEXT("");
    TCHAR szResIDStr[20] = TEXT("");

    CHAR  szTmpBuf[32] = "";

    // now build status line

    if (pTok->szName[0])
    {
        lstrcpy(szName, pTok->szName);
    }
    else
    {
#ifdef UNICODE
        _itoa(pTok->wName, szTmpBuf, 10);
        _MBSTOWCS( szName,
                   szTmpBuf,
                   WCHARSIN( sizeof( szName)),
                   ACHARSIN( strlen( szTmpBuf) + 1));
#else
        _itoa(pTok->wName, szName, 10);
#endif
    }

    if ( pTok->wReserved & ST_READONLY )
    {
        LoadString( hInst,
                    IDS_READONLY,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }
    else if (pTok->wReserved == ST_NEW)
    {
        LoadString( hInst,
                    IDS_NEW,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }
    else if (pTok->wReserved & ST_CHANGED)
    {
        LoadString( hInst,
                    IDS_CHANGED,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }
    else
    {
        LoadString( hInst,
                    IDS_UNCHANGED,
                    szStatus,
                    TCHARSIN( sizeof( szStatus)));
    }

    if ( pTok->wType <= 16 || pTok->wType == ID_RT_DLGINIT )
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES+pTok->wType,
                    szResIDStr,
                    TCHARSIN( sizeof( szResIDStr)));
    }
    else
    {
#ifdef UNICODE
        _itoa( pTok->wType, szTmpBuf, 10);
        _MBSTOWCS( szResIDStr,
                   szTmpBuf,
                   WCHARSIN( sizeof( szResIDStr)),
                   ACHARSIN( strlen( szTmpBuf) + 1));
#else
        _itoa(pTok->wType, szResIDStr, 10);
#endif
    }

    if (fFirstCall)
    {
        SendMessage( hStatusWnd,
                     WM_FMTSTATLINE,
                     (WPARAM)0,
                     (LPARAM)TEXT("10s10s5i8s4i"));
        fFirstCall = FALSE;
    }
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)0, (LPARAM)szResIDStr);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)1, (LPARAM)szName);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)2, (LPARAM)pTok->wID);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)3, (LPARAM)szStatus);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)4,
                 (LPARAM)lstrlen( pTok->szText));
}


/**********************************************************************
*FUNCTION: SaveMtkList(HWND)                                          *
*                                                                     *
*PURPOSE: Save current Token List                                     *
*                                                                     *
*COMMENTS:                                                            *
*                                                                     *
*This saves the current contents of the Token List                    *
**********************************************************************/

static BOOL SaveMtkList(HWND hWnd, FILE *fpTokFile)
{
    BOOL   bSuccess = TRUE;
    int    IOStatus;      // result of a file write
    UINT   cTokens;
    UINT   cCurrentTok = 0;
    TCHAR  *szTmpBuf;
    CHAR  *szTokBuf;
    TCHAR  str[255] = TEXT("");
    TOKENDELTAINFO FAR *pTokNode;
    LPTSTR lpstrToken;

    // Set the cursor to an hourglass during the file transfer

    hSaveCursor = SetCursor(hHourGlass);

    // Find number of tokens in the list

    cTokens = (UINT) SendMessage( hListWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

    if (cTokens != LB_ERR)
    {
        for (cCurrentTok = 0; bSuccess && (cCurrentTok < cTokens); cCurrentTok++)
        {
#ifdef UNICODE
            int nLenW = 0;
            int nLenA = 0;
#endif
            // Get each token from list
            HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)cCurrentTok,
                                                 (LPARAM)0);
            lpstrToken = (LPTSTR)GlobalLock( hMem);

#ifdef UNICODE
            nLenW = lstrlen( lpstrToken) + 1;
            szTmpBuf = (TCHAR *)FALLOC( (nLenA = MEMSIZE( nLenW)));
            lstrcpy( szTmpBuf, lpstrToken);
            GlobalUnlock( hMem);
            szTokBuf = (CHAR *)FALLOC( nLenA);
            _WCSTOMBS( szTokBuf, szTmpBuf, nLenA, nLenW);
            RLFREE( szTmpBuf);
#else
            szTokBuf = (CHAR *)FALLOC( strlen( lpstrToken) + 1);
            lstrcpy( szTokBuf, lpstrToken);
#endif
            IOStatus = fprintf(fpTokFile, "%s\n", szTokBuf);

            if ( IOStatus != (int) strlen(szTokBuf) + 1 )
            {
                LoadString( hInst,
                            IDS_FILESAVEERR,
                            str,
                            TCHARSIN( sizeof( str)));
                MessageBox( hWnd, str, NULL, MB_OK | MB_ICONHAND);
                bSuccess = FALSE;
            }
            RLFREE( szTokBuf);
        }
    }

    pTokNode = pTokenDeltaInfo;

    while (pTokNode)
    {
        TOKEN *pTok;
        int nLenW = 0;
        int nLenA = 0;

        pTok = &(pTokNode->DeltaToken);

#ifdef UNICODE
        nLenW = TokenToTextSize( pTok);
        szTmpBuf = (TCHAR *)FALLOC( (nLenA = MEMSIZE( nLenW)));
        ParseTokToBuf( szTmpBuf, pTok);
        szTokBuf = (CHAR *)FALLOC( nLenA);
        _WCSTOMBS( szTokBuf, szTmpBuf, nLenA, nLenW);
        RLFREE( szTmpBuf);
#else
        szTokBuf = (CHAR *)FALLOC( TokenToTextSize( pTok));
        ParseTokToBuf( szTokBuf, pTok);
#endif

        IOStatus = fprintf(fpTokFile, "%s\n", szTokBuf);

        if ( IOStatus != (int) strlen(szTokBuf) + 1 )
        {
            LoadString( hInst,
                        IDS_FILESAVEERR,
                        str,
                        TCHARSIN( sizeof(str)));
            MessageBox( hWnd, str, NULL, MB_OK | MB_ICONHAND);
            bSuccess = FALSE;
        }
        pTokNode = pTokNode->pNextTokenDelta;
    }

    // restore cursor

    SetCursor(hSaveCursor);

    return (bSuccess);
}

/**
  * Function: CleanDeltaList
  *   frees the pTokenDeltaInfo list
  */
static void CleanDeltaList(void)
{
    TOKENDELTAINFO FAR *pTokNode;

    while (pTokNode = pTokenDeltaInfo)
    {
        pTokenDeltaInfo = pTokNode->pNextTokenDelta;
        RLFREE( pTokNode->DeltaToken.szText);
        RLFREE( pTokNode);
    }
}


static TOKENDELTAINFO FAR *InsertMtkList(FILE * fpTokFile)
{
    TOKENDELTAINFO FAR * ptTokenDeltaInfo, FAR * pTokenDeltaInfo = NULL;
    int scTokStat;
    TOKEN tToken;
    UINT wcChars = 0;
    LPTSTR lpstrToken;

    rewind(fpTokFile);

    while ( (scTokStat = GetToken( fpTokFile, &tToken)) >= 0 )
    {
        if ( scTokStat == 0 )
        {
            if ( tToken.wReserved != ST_CHANGED )
            {
                HGLOBAL hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( TokenToTextSize( &tToken)));
                lpstrToken = (LPTSTR)GlobalLock( hMem);
                ParseTokToBuf( lpstrToken, &tToken);
                GlobalUnlock( hMem);
                    // only add tokens that aren't changed && old
                if ( SendMessage( hListWnd,
                                  LB_ADDSTRING,
                                  (WPARAM)0,
                                  (LPARAM)hMem) < 0 )
                {
                    QuitA( IDS_ENGERR_11, NULL, NULL);
                }
            }
            else
            {
                // the current token is delta info so save in delta list.
                if (!pTokenDeltaInfo)
                {
                    ptTokenDeltaInfo = pTokenDeltaInfo =
                        UpdateTokenDeltaInfo(&tToken);
                }
                else
                {
                    ptTokenDeltaInfo->pNextTokenDelta =
                        UpdateTokenDeltaInfo(&tToken);
                    ptTokenDeltaInfo = ptTokenDeltaInfo->pNextTokenDelta;
                }
            }
            RLFREE( tToken.szText);
        }
    }

    return(pTokenDeltaInfo);
}

/*
 * About -- message processor for about box
 *
 */
//#ifdef RLWIN32

INT_PTR CALLBACK About(

HWND   hDlg,
UINT   message,
WPARAM wParam,
LPARAM lParam)
{
    switch( message )
    {
        case WM_INITDIALOG:
            {
                WORD wRC = SUCCESS;
                CHAR szModName[ MAXFILENAME];

                GetModuleFileNameA( hInst, szModName, sizeof( szModName));

                if ( (wRC = GetCopyright( szModName,
                                          szDHW,
                                          DHWSIZE)) == SUCCESS )
                {
                    SetDlgItemTextA( hDlg, IDC_COPYRIGHT, szDHW);
                }
                else
                {
                    ShowErr( wRC, NULL, NULL);
                }
            }
            break;

        case WM_COMMAND:

            if ((wParam == IDOK) || (wParam == IDCANCEL))
            {
                EndDialog(hDlg, TRUE);
            }
            break;

        default:

            return( FALSE);
    }
    return( TRUE);
}


//...................................................................

int  RLMessageBoxA(

LPCSTR pszMsgText)
{
    return( MessageBoxA( hMainWnd, pszMsgText, szAppName, MB_ICONHAND|MB_OK));
}


//...................................................................

void Usage()
{
    return;
}


//...................................................................

void DoExit( int nErrCode)
{
    ExitProcess( (UINT)nErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rladmin\rladmin.h ===
#ifndef _RLADMIN_H_
#define _RLADMIN_H_

#include "rlstrngs.h"
#include "resourc2.h"

void cwCenter(HWND, int);

INT_PTR FAR PASCAL MainWndProc(HWND, UINT,  WPARAM, LPARAM);
INT_PTR FAR PASCAL GENERATEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL EXECUTEDLGEDITMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL EXECUTERCWMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL TOKENIZEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL TOKFINDMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR FAR PASCAL TRANSLATEMsgProc( HWND, UINT, WPARAM, LPARAM );

#define MAXFILENAME     256         /* maximum length of file pathname      */
#define MAXCUSTFILTER   40          /* maximum size of custom filter buffer */
#define CCHNPMAX        65535       /* max number of bytes in a notepad file */


void        CwUnRegisterClasses(void);
INT_PTR     DoMenuCommand    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR     DoListBoxCommand ( HWND, UINT, WPARAM, LPARAM );
TCHAR        FAR *FindDeltaToken( TOKEN , TOKENDELTAINFO FAR * , UINT );
BOOL        GetFileNameFromBrowse( HWND, PSTR, UINT, PSTR, PSTR, PSTR );
BOOL        InitApplication(HINSTANCE);
BOOL        InitInstance(HINSTANCE, int);
TOKENDELTAINFO FAR *InsertTokList( FILE * );
void        FindAllDirtyTokens( void );
void        MakeNewExt ( TCHAR *, TCHAR *, TCHAR * );
int         nCwRegisterClasses(void);
void        SetNewBuffer(HWND, HANDLE, PSTR);

#ifdef RLWIN32
INT_PTR     CALLBACK TokEditDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR     CALLBACK NewDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR     CALLBACK ViewDlgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR     CALLBACK About( HWND, UINT, WPARAM, LPARAM );
#else
BOOL        APIENTRY TokEditDlgProc( HWND, UINT, UINT, LONG );
BOOL        APIENTRY NewDlgProc( HWND, UINT, UINT, LONG );
BOOL        APIENTRY ViewDlgProc( HWND, UINT, UINT, LONG );
BOOL        APIENTRY About( HWND, UINT, UINT, LONG );
#endif // RLWIN32

#endif // _RLADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rledit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rledit.rc
//
#define IDC_APPENDREPLACE               1007
#define IDS_NOCPXTABLE                  3101
#define IDS_WILLREPLACE                 3102
#define IDS_WILLAPPEND                  3103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rledit\rledit.c ===
// INCLUSION PREVENTION DEFINITIONS
#define NOMETAFILE
#define NOMINMAX
#define NOSOUND
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NODRIVERS
#define NOCOMM
#define NOBITMAP
#define NOSCROLL
#define NOWINOFFSETS
#define NOWH
#define NORASTEROPS
#define NOOEMRESOURCE
#define NOGDICAPMASKS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NOATOM
#define NOLOGERROR
#define NOSYSTEMPARAMSINFO

// WINDOWS includes
#include <windows.h>
#include <windowsx.h>

#ifdef RLWIN16
//#include <toolhelp.h>
#endif

#include <shellapi.h>
#include <commdlg.h>

// CRT includes
#include <stdio.h>
#include <stdlib.h>

// RL TOOLS SET includes
#include "windefs.h"
#include "toklist.h"
#include "RESTOK.H"
#include "RLEDIT.H"
#include "update.h"
#include "custres.h"
#include "exe2res.h"
#include "exeNTres.h"
#include "commbase.h"
#include "wincomon.h"
#include "resread.h"
#include "projdata.h"
#include "showerrs.h"
#include "resource.h"

// Global Variables:
static CHAR * gszHelpFile = "rltools.hlp";
extern MSTRDATA gMstr;
extern PROJDATA gProj;

extern BOOL     bRLGui;

#ifdef RLWIN32
HINSTANCE   hInst;      /* Instance of the main window  */
#else
HWND        hInst;          /* Instance of the main window  */
#endif

int  nUpdateMode    = 0;
BOOL fCodePageGiven = FALSE;    //... Set to TRUE if -p arg given
HWND hMainWnd;                  // handle to main window
HWND hListWnd;                  // handle to tok list window
HWND hStatusWnd;                // handle to status windows
CHAR szFileTitle[MAXFILENAME] = ""; // holds base name of latest opened file
CHAR szCustFilterSpec[MAXCUSTFILTER] = "";

extern CHAR szDHW[];     //... used in debug strings
extern BOOL fInThirdPartyEditer;
extern BOOL gfReplace;

static TCHAR   szSearchType[80]   = TEXT("");
static TCHAR   szSearchText[4096] = TEXT("");
static WORD    wSearchStatus      = 0;
static WORD    wSearchStatusMask  = 0;
static BOOL    fSearchDirection;
static BOOL    fSearchStarted     = FALSE;

#ifndef UNICODE
BOOL PASCAL _loadds WatchTask(WORD wID, DWORD dwData);
#endif

#ifdef RLWIN16
static FARPROC lpfnWatchTask = NULL;
#endif

static void CleanDeltaList(void);
static int  ExecResEditor(HWND, CHAR *, CHAR *, CHAR *);
static void DrawLBItem(LPDRAWITEMSTRUCT lpdis);
static void SetNames( HWND hDlg, int iLastBox, LPSTR szNewFile);

// File IO vars

static OPENFILENAMEA ofn;

static CHAR     szFilterSpec    [60] = "";
static CHAR     szPRJFilterSpec [60] = "";
static CHAR     szResFilterSpec [60] = "";
static CHAR     szExeFilterSpec [60] = "";
static CHAR     szDllFilterSpec [60] = "";
static CHAR     szExeResFilterSpec [180] = "";
static CHAR     szTokFilterSpec [60] = "";
static CHAR     szMPJFilterSpec [60] = "";
static CHAR     szGlossFilterSpec[60] = "";
static CHAR     szTempFileName[MAXFILENAME] = "";
static CHAR     szFileName[MAXFILENAME] = "";  // holds full name of latest opened file
static TCHAR    szString[256] = TEXT("");      // variable to load resource strings
static TCHAR    tszAppName[100] = TEXT("");
static CHAR     szAppName[100] = "";
static TCHAR    szClassName[]=TEXT("RLEditClass");
static TCHAR    szStatusClass[]=TEXT("RLEditStatus");

static BOOL    gbNewProject  = FALSE;      // indicates to prompt for auto translate
static BOOL    fTokChanges   = FALSE;      // set to true when toke file is out of date
static BOOL    fTokFile      = FALSE;
static BOOL    fEditing      = FALSE;
static BOOL    fPrjChanges   = FALSE;
static BOOL    fMPJOutOfDate = FALSE;
static BOOL    fPRJOutOfDate = FALSE;

static CHAR     szOpenDlgTitle[80] = ""; // title of File open dialog
static CHAR     szSaveDlgTitle[80] = ""; // title of File saveas dialog

// linked list of token deta info
static TOKENDELTAINFO FAR *pTokenDeltaInfo = NULL;
static LONG    lFilePointer[30]= {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

// circular doubly linked list of translations
static TRANSLIST *pTransList = NULL;

// Window vars
static BOOL        fWatchEditor;
static CHAR        szTempRes[MAXFILENAME] = "";     // temp file for resource editor
// set true if a resource editer has been launched

static HCURSOR    hHourGlass;     /* handle to hourglass cursor     */
static HCURSOR    hSaveCursor;    /* current cursor handle      */
static HACCEL     hAccTable;
static RECT        Rect;   /* dimension of the client window   */
static int cyChildHeight;  /* height of status windows   */


// NOTIMPLEMENTED is a macro that displays a "Not implemented" dialog
#define NOTIMPLEMENTED {TCHAR sz[80];\
                        LoadString( hInst, \
                                    IDS_NOT_IMPLEMENTED, \
                                    sz, TCHARSIN( sizeof(sz)));\
                        MessageBox(hMainWnd, sz, tszAppName, \
                                   MB_ICONEXCLAMATION | MB_OK);}

// Edit Tok Dialog
#ifndef RLWIN32
static DLGPROC lpTokEditDlg;
#endif
static HWND    hTokEditDlgWnd = 0;


/**
  *
  *
  *  Function: InitApplication
  * Regsiters the main window, which is a list box composed of tokens
  * read from the token file. Also register the status window.
  *
  *
  *  Arguments:
  * hInstance, instance handle of program in memory.
  *
  *  Returns:
  *
  *  Errors Codes:
  * TRUE, windows registered correctly.
  * FALSE, error during register of one of the windows.
  *
  *  History:
  * 9/91, Implemented.      TerryRu
  *
  *
  **/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    CHAR sz[60] = "";
    CHAR sztFilterSpec[120] = "";


    LoadStrIntoAnsiBuf(hInstance, IDS_PRJSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szFilterSpec, sz, "*.PRJ");
    szFilterSpecFromSz1Sz2(szPRJFilterSpec, sz, "*.PRJ");

    LoadStrIntoAnsiBuf(hInstance, IDS_RESSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szResFilterSpec, sz, "*.RES");

    LoadStrIntoAnsiBuf(hInstance, IDS_EXESPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szExeFilterSpec, sz, "*.EXE");

    LoadStrIntoAnsiBuf(hInstance, IDS_DLLSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szDllFilterSpec, sz, "*.DLL");
    CatSzFilterSpecs(sztFilterSpec, szExeFilterSpec, szDllFilterSpec);
    CatSzFilterSpecs(szExeResFilterSpec, sztFilterSpec, szResFilterSpec);

    LoadStrIntoAnsiBuf(hInstance, IDS_TOKSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szTokFilterSpec, sz, "*.TOK");

    LoadStrIntoAnsiBuf(hInstance, IDS_MPJSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szMPJFilterSpec, sz, "*.MPJ");

    LoadStrIntoAnsiBuf(hInstance, IDS_GLOSSSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szGlossFilterSpec, sz, "*.TXT");

    LoadStrIntoAnsiBuf(hInstance,
                       IDS_OPENTITLE,
                       szOpenDlgTitle,
                       sizeof(szOpenDlgTitle));
    LoadStrIntoAnsiBuf(hInstance,
                       IDS_SAVETITLE,
                       szSaveDlgTitle,
                       sizeof(szSaveDlgTitle));

    wc.style        = 0;
    wc.lpfnWndProc  = StatusWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = 0;
    wc.hInstance    = hInstance;
    wc.hIcon        = LoadIcon((HINSTANCE) NULL, IDI_APPLICATION);
    wc.hCursor      = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName    = szStatusClass;

    if (! RegisterClass((CONST WNDCLASS *)&wc)) {
        return (FALSE);
    }

    wc.style        = 0;
    wc.lpfnWndProc  = MainWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = 0;
    wc.hInstance    = hInstance;
    wc.hIcon        = LoadIcon(hInstance, TEXT("RLEditIcon"));
    wc.hCursor      = LoadCursor((HINSTANCE) NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = TEXT("RLEdit");
    wc.lpszClassName    = szClassName;

    if (!RegisterClass((CONST WNDCLASS *)&wc)) {
        return (FALSE);
    }

    // Windows register return sucessfully
    return (TRUE);
}



/**
  *
  *
  *  Function: InitInstance
  * Creates the main, and status windows for the program.
  * The status window is sized according to the main window
  * size.  InitInstance also loads the acclerator table, and prepares
  * the global openfilename structure for later use.
  *
  *
  *  Errors Codes:
  * TRUE, windows created correctly.
  * FALSE, error on create windows calls.
  *
  *  History:
  * 9/11, Implemented       TerryRu
  *
  *
  **/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT    Rect = { 0,0,0,0};

    hAccTable = LoadAccelerators(hInst, TEXT("RLEdit"));

    hMainWnd = CreateWindow(szClassName,
                            tszAppName,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);

    if (!hMainWnd) {                           // clean up after errors.
        return ( FALSE);
    }
    DragAcceptFiles(hMainWnd, TRUE);

    GetClientRect(hMainWnd, (LPRECT) &Rect);

    // Create a child list box window

    hListWnd = CreateWindow(TEXT("LISTBOX"),
                            NULL,
                            WS_CHILD |
                            LBS_WANTKEYBOARDINPUT |
                            LBS_NOTIFY | LBS_NOINTEGRALHEIGHT |
                            LBS_OWNERDRAWFIXED | WS_VSCROLL |
                            WS_HSCROLL | WS_BORDER,
                            0,
                            0,
                            (Rect.right-Rect.left),
                            (Rect.bottom-Rect.top),
                            hMainWnd,
                            (HMENU)IDC_LIST,       // Child control i.d.
                            hInstance,
                            NULL);

    if (!hListWnd) {                           // clean up after errors.
        DeleteObject((HGDIOBJ)hMainWnd);
        return ( FALSE);
    }
    // Creat a child status window

    hStatusWnd = CreateWindow(szStatusClass,
                              NULL,
                              WS_CHILD | WS_BORDER | WS_VISIBLE,
                              0, 0, 0, 0,
                              hMainWnd,
                              NULL,
                              hInstance,
                              NULL);

    if (! hStatusWnd) {                           // clean up after errors.
        DeleteObject((HGDIOBJ)hListWnd);
        DeleteObject((HGDIOBJ)hMainWnd);
        return ( FALSE);
    }
    hHourGlass = LoadCursor((HINSTANCE) NULL, IDC_WAIT);

    // Fill in non-variant fields of OPENFILENAMEA struct.
    ofn.lStructSize       = sizeof( OPENFILENAMEA);
    ofn.hwndOwner         = hMainWnd;
    ofn.lpstrFilter       = szFilterSpec;
    ofn.lpstrCustomFilter = szCustFilterSpec;
    ofn.nMaxCustFilter    = MAXCUSTFILTER;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = sizeof( szFileName);
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = szFileTitle;
    ofn.nMaxFileTitle     = sizeof( szFileTitle);
    ofn.lpstrTitle        = NULL;
    ofn.lpstrDefExt       = "PRJ";
    ofn.Flags             = 0;

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);
    return ( TRUE);
}

/**
  *
  *
  *  Function: WinMain
  * Calls the intialization functions, to register, and create the
  * application windows. Once the windows are created, the program
  * enters the GetMessage loop.
  *
  *
  *  Arguements:
  * hInstace, handle for this instance
  * hPrevInstanc, handle for possible previous instances
  * lpszCmdLine, LONG pointer to exec command line.
  * nCmdShow,  code for main window display.
  *
  *
  *  Errors Codes:
  * IDS_ERR_REGISTER_CLASS, error on windows register
  * IDS_ERR_CREATE_WINDOW, error on create windows
  * otherwise, status of last command.
  *
  *  History:
  *
  *
  **/

INT WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpszCmdLine,
                   int       nCmdShow)
{
    MSG  msg;
    HWND FirstWnd      = NULL;
    HWND FirstChildWnd = NULL;
    WORD wRC           = SUCCESS;


    bRLGui = TRUE;            //... used in rlcommon.lib

    if (FirstWnd = FindWindow(szClassName, NULL)) {  // checking for previous instance
        FirstChildWnd = GetLastActivePopup(FirstWnd);
        BringWindowToTop(FirstWnd);
        ShowWindow(FirstWnd, SW_SHOWNORMAL);

        if (FirstWnd != FirstChildWnd) {
            BringWindowToTop(FirstChildWnd);
        }
        return (FALSE);
    }

    hInst = hInstance;

    GetModuleFileNameA( hInst, szDHW, DHWSIZE);
    GetInternalName( szDHW, szAppName, sizeof( szAppName));
    szFileName[0] = '\0';
    lFilePointer[0] = (LONG)-1;

#ifdef UNICODE
    _MBSTOWCS( tszAppName,
               szAppName,
               WCHARSIN( sizeof( tszAppName)),
               ACHARSIN( strlen( szAppName) + 1));
#else
    strcpy( tszAppName, szAppName);
#endif

    // register window classes if first instance of application

    if ( ! hPrevInstance ) {
        if ( ! InitApplication( hInstance) ) {
            /* Registering one of the windows failed    */
            LoadString( hInst,
                        IDS_ERR_REGISTER_CLASS,
                        szString,
                        TCHARSIN( sizeof( szString)));
            MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
            return IDS_ERR_REGISTER_CLASS;
        }
    }

    // Create windows for this instance of application

    if ( ! InitInstance(hInstance, nCmdShow) ) {
        LoadString( hInst,
                    IDS_ERR_CREATE_WINDOW,
                    szString,
                    TCHARSIN( sizeof(szString)));
        MessageBox( NULL, szString, NULL, MB_ICONEXCLAMATION);
        return IDS_ERR_CREATE_WINDOW;
    }

    // Main Message Loop

    while ( GetMessage( &msg, NULL, 0, 0) ) {
        if ( hTokEditDlgWnd ) {
            if ( IsDialogMessage( hTokEditDlgWnd, &msg)) {
                continue;
            }
        }

        if ( TranslateAccelerator( hMainWnd, hAccTable, &msg) ) {
            continue;
        }

        TranslateMessage( (CONST MSG *)&msg);
        DispatchMessage( (CONST MSG *)&msg);
    }
    return (INT)msg.wParam;
}

/**
  *  Function: MainWndProc
  * Process the windows messages for the main window of the application.
  * All user inputs go through this window procedure.
  * See cases in the switch table for a description of each message type.
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/

INT_PTR APIENTRY MainWndProc( HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    // if it's a list box message process it in  DoListBoxCommand

    if ( fInThirdPartyEditer ) {  //... only process messages sent by the editor
        switch (wMsg) {
            case WM_EDITER_CLOSED:
                {
                    CHAR    szDlgToks[MAXFILENAME] = "";
                    static WORD wSavedIndex;
#ifdef RLWIN16
                    NotifyUnRegister( NULL);
                    FreeProcInstance( lpfnWatchTask);
#endif
                    ShowWindow(hWnd, SW_SHOW);

                    {
                        TCHAR tsz[80] = TEXT("");
                        LoadString( hInst,
                                    IDS_REBUILD_TOKENS,
                                    tsz,
                                    TCHARSIN( sizeof(tsz)));

                        if ( MessageBox( hWnd,
                                         tsz,
                                         tszAppName,
                                         MB_ICONQUESTION | MB_YESNO) == IDYES) {
                            HCURSOR hOldCursor;
                            BOOL bUpdated = FALSE;

                            hOldCursor = SetCursor(hHourGlass);

                            LoadCustResDescriptions(gMstr.szRdfs);

                            // szTempRes returned from resource editor
                            MyGetTempFileName(0, "TOK", 0, szDlgToks);
                            GenerateTokFile(szDlgToks, szTempRes, &bUpdated, 0);

                            InsDlgToks(gProj.szTok,
                                       szDlgToks,
                                       ID_RT_DIALOG);
                            remove(szDlgToks);
                            ClearResourceDescriptions();

                            // gProj.szTok, now contains the latest tokens
                            SetCursor(hOldCursor);

                            //Rledit doesn't save when changed tokens by Dialog Editor.
                            fTokChanges = TRUE;
                        }
                    }
                    fInThirdPartyEditer = FALSE;

                    remove(szTempRes);
                    // UNDONE - delete all temp files with the same root in case
                    // the editor created additional files like DLGs and RCs.
                    // (DLGEDIT does this.)
                    // For now I'm just going to tack a .DLG
                    // at the end of the file name
                    // and delete it.
                    {
                        int i;
                        for (i = strlen(szTempRes);
                            i > 0 && szTempRes[i]!='.'; i--) {
                        }

                        if (szTempRes[i] == '.') {
                            szTempRes[++i]='D';
                            szTempRes[++i]='L';
                            szTempRes[++i]='G';
                            szTempRes[++i]='\0';
                            remove(szTempRes);
                        }
                    }

                    wSavedIndex = (UINT)SendMessage( hListWnd,
                                                     LB_GETCURSEL,
                                                     (WPARAM)0,
                                                     (LPARAM)0);
                    SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                    SendMessage( hListWnd,
                                 LB_SETCURSEL,
                                 (WPARAM)wSavedIndex,
                                 (LPARAM)0);
                }
                return ( DefWindowProc( hWnd, wMsg, wParam, lParam));
        }
    }


    // Not a third party edit command.

    DoListBoxCommand (hWnd, wMsg, wParam, lParam);

    switch (wMsg) {

        case WM_DROPFILES:
            {
                CHAR sz[MAXFILENAME] = "";

                DragQueryFileA( (HDROP) wParam, 0, sz, MAXFILENAME);

                if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0)) {
                    GetProjectData( sz, NULL, NULL, FALSE, FALSE);
                }
                DragFinish( (HDROP) wParam);
                return ( TRUE);
            }

        case WM_COMMAND:
            if (DoMenuCommand(hWnd, wMsg, wParam, lParam)) {
                return TRUE;
            }
            break;

        case WM_CLOSE:
            SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
            DestroyWindow(hMainWnd);
            DestroyWindow(hListWnd);
            DestroyWindow(hStatusWnd);
            _fcloseall();

            FreeLangList();

#ifdef _DEBUG
            {
                FILE *pLeakList = fopen( "C:\\LEAKLIST.TXT", "wt");
                FreeMemList( pLeakList);
                fclose( pLeakList);
            }
#endif // _DEBUG

            break;

        case WM_CREATE:
            {
                HDC hdc;
                int cyBorder;
                TEXTMETRIC tm;

                hdc  = GetDC (hWnd);
                GetTextMetrics(hdc, &tm);
                ReleaseDC(hWnd, hdc);


                cyBorder = GetSystemMetrics(SM_CYBORDER);

                cyChildHeight = tm.tmHeight + 6 + cyBorder * 2;
                break;
            }

        case WM_DESTROY:
            WinHelpA(hWnd, gszHelpFile, HELP_QUIT, (DWORD)0);
            // remove translation list
            if (pTransList) {
                // so we can find the end of the list
                pTransList->pPrev->pNext = NULL;
            }

            while (pTransList) {
                TRANSLIST *pTemp;

                pTemp = pTransList;
                pTransList = pTemp->pNext;
                RLFREE( pTemp->sz);
                RLFREE( pTemp);
            }
            PostQuitMessage(0);
            break;

        case WM_INITMENU:
            // Enable or Disable the Paste menu item
            // based on available Clipboard Text data
            if (wParam == (WPARAM) GetMenu(hMainWnd)) {
                if (OpenClipboard(hWnd)) {

#if defined(UNICODE)
                    if ((IsClipboardFormatAvailable(CF_UNICODETEXT)
                         || IsClipboardFormatAvailable(CF_OEMTEXT)) && fTokFile)
#else // not UNICODE
                    if ((IsClipboardFormatAvailable(CF_TEXT)
                         || IsClipboardFormatAvailable(CF_OEMTEXT)) && fTokFile)
#endif // UNICODE
                    {
                        EnableMenuItem((HMENU) wParam, IDM_E_PASTE, MF_ENABLED);
                    } else {
                        EnableMenuItem((HMENU)wParam, IDM_E_PASTE, MF_GRAYED);
                    }

                    CloseClipboard();
                    return (TRUE);
                }
            }
            break;

        case WM_QUERYENDSESSION:
            /* message: to end the session? */
            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                return TRUE;
            } else {
                return FALSE;
            }

        case WM_SETFOCUS:
            SetFocus (hListWnd);
            break;

        case WM_DRAWITEM:
            DrawLBItem((LPDRAWITEMSTRUCT) lParam);
            break;

        case WM_DELETEITEM:
            {
                HGLOBAL   hTokData;
                LPTOKDATA lpTokData;

                hTokData = ((HGLOBAL)((LPDELETEITEMSTRUCT)lParam)->itemData);

                if ( hTokData ) {
                    lpTokData = (LPTOKDATA)GlobalLock( hTokData );
                    GlobalFree( lpTokData->hToken );
                    GlobalUnlock( hTokData );
                    GlobalFree( hTokData );
                }
            }
            break;

        case WM_SIZE:
            {
                int cxWidth;
                int cyHeight;
                int xChild;
                int yChild;

                cxWidth  = LOWORD(lParam);
                cyHeight = HIWORD(lParam);

                xChild = 0;
                yChild = cyHeight - cyChildHeight + 1;

                MoveWindow(hListWnd, 0, 0, cxWidth, yChild, TRUE);
                MoveWindow(hStatusWnd, xChild, yChild, cxWidth, cyChildHeight, TRUE);
                break;
            }

        case WM_READMPJDATA:
            {
                OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

                if ( OpenFile( gProj.szMpj, &Of, OF_EXIST) == HFILE_ERROR ) {
                    // file doesn't exist
                    LoadStrIntoAnsiBuf( hInst, IDS_MPJERR, szDHW, DHWSIZE);
                    MessageBoxA( hWnd,
                                 gProj.szMpj,
                                 szDHW,
                                 MB_ICONSTOP | MB_OK);
                } else if ( GetMasterProjectData( gProj.szMpj,
                                                  NULL,
                                                  NULL,
                                                  FALSE) == SUCCESS ) {
                    OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

                    gProj.fSourceEXE = IsExe( gMstr.szSrc);
                    gProj.fTargetEXE = (!IsRes( gProj.szBld));

                    if ( gProj.fTargetEXE  && !gProj.fSourceEXE ) {
                        int i = lstrlenA( gProj.szBld) - 3;

                        LoadStrIntoAnsiBuf( hInst,
                                            IDS_RLE_CANTSAVEASEXE,
                                            szDHW,
                                            DHWSIZE);

                        lstrcpyA( gProj.szBld+i, "RES");
                        MessageBoxA( hWnd,
                                     szDHW,
                                     gProj.szBld,
                                     MB_ICONHAND|MB_OK);
                        gProj.fTargetEXE = FALSE;
                    }

                    SzDateFromFileName( szDHW, gMstr.szSrc);
                    fMPJOutOfDate = FALSE;

                    if ( OpenFile( gProj.szTok, &Of, OF_EXIST) == HFILE_ERROR ) {

                        // file doesn't exist, create it
                        Update( gMstr.szMtk, gProj.szTok);

                        lstrcpyA( gProj.szTokDate,
                                  gMstr.szMpjLastRealUpdate);
                        fPrjChanges   = TRUE;
                        fPRJOutOfDate = FALSE;
                    } else {
                        if ( lstrcmpA( gMstr.szMpjLastRealUpdate,
                                       gProj.szTokDate) ) {
                            HCURSOR hOldCursor;

                            fPRJOutOfDate = TRUE;
                            hOldCursor    = SetCursor( hHourGlass);
                            Update( gMstr.szMtk, gProj.szTok);
                            SetCursor( hOldCursor);
                            lstrcpyA( gProj.szTokDate,
                                      gMstr.szMpjLastRealUpdate);
                            fPrjChanges   = TRUE;
                            fPRJOutOfDate = FALSE;
                        } else {
                            fPRJOutOfDate = FALSE;
                        }
                    }

                    // New code to do auto-translate

                    SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);

                    if ( gProj.szGlo[0]               // file name given exists?
                         && OpenFile( gProj.szGlo, &Of, OF_EXIST) != HFILE_ERROR ) {                                 // Yes
                        HCURSOR hOldCursor = SetCursor( hHourGlass);

                        MakeGlossIndex( lFilePointer);
                        SetCursor( hOldCursor);
                    }
                }       //... END case WM_READMPJDATA
            }           //... END switch (wMsg)
            break;

        case WM_LOADTOKENS:
            {
                HMENU hMenu = NULL;
                FILE *f     = NULL;

                // Remove the current token list
                SendMessage( hListWnd, LB_RESETCONTENT, (LPARAM)0, (LPARAM)0);
                CleanDeltaList();

                // Hide token list, while we add new tokens
                ShowWindow(hListWnd, SW_HIDE);

                if (f = FOPEN(gProj.szTok, "rt")) {
                    HCURSOR hOldCursor;

                    hOldCursor = SetCursor(hHourGlass);

                    // Insert tokens from token file into the list box
                    {
                        FILE    *fm;

                        if ( !(fm = fopen((CHAR *)gMstr.szMtk,"rt")) )
                            return TRUE;
                        pTokenDeltaInfo = InsertTokMtkList(f, fm );
                        FCLOSE( fm );
                    }
                    FCLOSE(f);

                    // Make list box visible
                    ShowWindow(hListWnd, SW_SHOW);

                    hMenu=GetMenu(hWnd);
                    EnableMenuItem(hMenu, IDM_P_CLOSE,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_VIEW,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_EDIT,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_SAVE,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FIND,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDUP,    MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDDOWN,  MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_REVIEW,    MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_ALLREVIEW, MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPY,      MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPYTOKEN, MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_PASTE,     MF_ENABLED|MF_BYCOMMAND);

                    if ((!fMPJOutOfDate) && (!fPRJOutOfDate)) {
                        int i;
                        EnableMenuItem(hMenu, IDM_O_GENERATE, MF_ENABLED|MF_BYCOMMAND);

                        for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++) {
                            EnableMenuItem(hMenu, i, MF_ENABLED|MF_BYCOMMAND);
                        }
                    }
                    fTokFile = TRUE;
                    fTokChanges = FALSE;

                    SetCursor(hOldCursor);
                }
                return TRUE;
            }
            break;

        case WM_SAVEPROJECT:
            {
                HCURSOR hOldCursor;

                hOldCursor = SetCursor( hHourGlass);

                _fcloseall();

                if ( fPrjChanges ) {
                    // Generate PRJ file

                    if ( PutProjectData( gProj.szPRJ) != SUCCESS ) {
                        SetCursor( hOldCursor);
                        LoadStrIntoAnsiBuf (hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                        MessageBoxA( hWnd,szDHW, gProj.szPRJ, MB_ICONHAND | MB_OK);
                        return FALSE;
                    }
                    fPrjChanges = FALSE;
                }

                fTokFile = FALSE;

                if (fTokChanges) {
                    FILE *f = FOPEN( gProj.szTok, "wt");

                    if ( f ) {
                        SaveTokList(hWnd, f);
                        FCLOSE(f);
                        fTokChanges = FALSE;
                    } else {
                        SetCursor( hOldCursor);
                        LoadStrIntoAnsiBuf(hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                        MessageBoxA( hWnd,
                                     szDHW,
                                     gProj.szTok,
                                     MB_ICONHAND | MB_OK);
                        return FALSE;
                    }
                }
                SetCursor( hOldCursor);
                return TRUE; // everything saved ok
            }

        default:
            break;
    }
    return ( DefWindowProc(hWnd, wMsg, wParam, lParam));
}



static void GetTextFromMTK( HWND hWnd, TOKEN *pTok, long lMtkPointer )
{
    FILE *fp = FOPEN( gMstr.szMtk, "rt");

    if ( fp ) {
        TOKEN   cTok, ccTok;
        BOOL    fFound;

        pTok->wReserved = 0;

        if ( lMtkPointer >= 0 ) {
            fseek( fp, lMtkPointer, SEEK_SET);

            if ( !GetToken(fp,&cTok) ) {
                fFound = ((cTok.wType == pTok->wType)
                          && (cTok.wName == pTok->wName)
                          && (cTok.wID   == pTok->wID)
                          && (cTok.wFlag == pTok->wFlag)
                          && (lstrcmp((TCHAR *)cTok.szName,
                                      (TCHAR *)pTok->szName) == 0));

                if ( fFound ) {
                    // any changed old token
                    SetDlgItemText( hWnd,
                                    IDD_TOKCURTEXT,
                                    (LPTSTR)cTok.szText);

                    if ( ! GetToken( fp,&ccTok) ) {
                        fFound = ((cTok.wType == ccTok.wType)
                                  && (cTok.wName == ccTok.wName)
                                  && (cTok.wID   == ccTok.wID)
                                  && (cTok.wFlag == ccTok.wFlag)
                                  && (lstrcmp((TCHAR *)cTok.szName,
                                              (TCHAR *)ccTok.szName) == 0)
                                  && (cTok.wReserved & ST_CHANGED) );

                        if ( fFound ) {
                            SetDlgItemText( hWnd, IDD_TOKPREVTEXT, (LPTSTR)ccTok.szText);
                        } else {
                            // should this ever happen??
                            SetDlgItemText( hWnd, IDD_TOKPREVTEXT, (LPTSTR)TEXT(""));
                        }
                    } else {
                        // should this ever happen??
                        SetDlgItemText( hWnd, IDD_TOKPREVTEXT, (LPTSTR)TEXT(""));
                    }
                    FCLOSE( fp);
                    return;
                }
            }
        }

        pTok->wReserved = 0;

        if (FindToken(fp, pTok, 0)) {
            // any changed old token
            SetDlgItemText(hWnd, IDD_TOKCURTEXT, (LPTSTR)pTok->szText);
        } else {
            SetDlgItemText(hWnd, IDD_TOKCURTEXT, (LPTSTR)TEXT(""));
        }

        pTok->wReserved = ST_CHANGED;

        if (FindToken(fp, pTok, ST_CHANGED)) { // any old token
            SetDlgItemText(hWnd, IDD_TOKPREVTEXT, (LPTSTR)pTok->szText);
        } else {
            // should this ever happen??
            SetDlgItemText(hWnd, IDD_TOKPREVTEXT, (LPTSTR)TEXT(""));
        }
        FCLOSE(fp);
    }
}






/**
  *  Function: DoListBoxCommand
  * Processes the messages sent to the list box. If the message is
  * not reconized as a list box message, it is ignored and not processed.
  * As the user scrolls through the tokens WM_UPDSTATLINE messages are
  * sent to the status window to indicate the current selected token.
  * The list box goes into Edit Mode by  pressing the enter key, or
  * by double clicking on the list box.  After the edit is done, a WM_TOKEDIT
  * message is sent back to the list box to update the token. The
  * list box uses control ID IDC_LIST.
  *
  *  Arguments:
  * wMsg    List Box message ID
  * wParam  Either IDC_LIST, or VK_RETURN depending on wMsg
  * lParam  LPTSTR to selected token during WM_TOKEDIT message.
  *
  *  Returns:
  *
  *  Errors Codes:
  * TRUE.  Message processed.
  * FALSE. Message not processed.
  *
  *  History:
  * 01/92 Implemented.      TerryRu.
  * 01/92 Fixed problem with DblClick, and Enter processing.    TerryRu.
  *
  **/

INT_PTR DoListBoxCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TOKEN tok;       // structure to hold token read from token list
    TCHAR szName[32] = TEXT("");          // buffer to hold token name
    CHAR  szTmpBuf[32] = "";      // buffer to hold token name
    TCHAR szID[7] = TEXT("");   // buffer to hold token id
    TCHAR sz[256] = TEXT("");   // buffer to hold messages
    static UINT wIndex;
    LONG lListParam = 0L;
    HWND    hCtl = NULL;
    HGLOBAL hMem = NULL;
    LPTSTR  lpstrToken = NULL;
    LPTOKDATA lpTokData;
    LONG      lMtkPointer;

    // this is the WM_COMMAND

    switch (wMsg) {
        case WM_VIEW:
            {
                TCHAR *szBuffer;

                // Message sent by TOkEdigDlgProc to fill IDD_TOKCURTEXT
                // and IDD_TOKPREVTEXT fields in dialog box

                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wIndex,
                                             (LPARAM)0);

                lpTokData = (LPTOKDATA)GlobalLock( hMem );
                lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                lMtkPointer = lpTokData->lMtkPointer;

                szBuffer = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                lstrcpy( szBuffer, lpstrToken);

                GlobalUnlock( lpTokData->hToken );

                GlobalUnlock( hMem);
                ParseBufToTok( szBuffer, &tok);
                RLFREE( szBuffer);
                GetTextFromMTK(hTokEditDlgWnd, &tok, lMtkPointer );

                RLFREE( tok.szText);

                return TRUE;
            }

        case WM_TRANSLATE:
            {
                // Message sent by TokEditDlgProc to build a translation list

                HWND hDlgItem = NULL;
                int cTextLen  = 0;
                TCHAR *szKey  = NULL;
                TCHAR *szText = NULL;


                hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKCURTEXT);
                cTextLen = GetWindowTextLength( hDlgItem);
                szKey = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                szKey[0] = 0;
                GetDlgItemText( hTokEditDlgWnd,
                                IDD_TOKCURTEXT,
                                szKey,
                                cTextLen + 1);

                hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKCURTRANS);
                cTextLen = GetWindowTextLength( hDlgItem);
                szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                *szText = 0;
                GetDlgItemText( hTokEditDlgWnd,
                                IDD_TOKCURTRANS,
                                szText,
                                cTextLen + 1);
                TransString( szKey, szText, &pTransList, lFilePointer);
                RLFREE( szKey);
                RLFREE( szText);

                break;
            }

        case WM_TOKEDIT:
            {
                TCHAR *szBuffer;
                int cTextLen;

                // Message sent by TokEditDlgProc to
                // indicate change in the token text.
                // Response to the message by inserting
                // new token text into list box

                // Insert the selected token into token struct
                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             (WPARAM)wIndex,
                                             (LPARAM)0);

                lpTokData = (LPTOKDATA)GlobalLock( hMem );
                lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

                cTextLen = lstrlen( lpstrToken);
                szBuffer = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                lstrcpy( szBuffer, lpstrToken);

                lMtkPointer = lpTokData->lMtkPointer;
                GlobalUnlock( lpTokData->hToken );

                GlobalUnlock( hMem);
                ParseBufToTok( szBuffer, &tok);
                RLFREE( szBuffer);
                RLFREE( tok.szText);

                // Copy new token text from edit box into the token struct
                cTextLen = lstrlen( (LPTSTR)lParam);
                tok.szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
                lstrcpy( tok.szText, (LPTSTR)lParam);

                // Mark token as clean
#ifdef  RLWIN32
                tok.wReserved = (WORD) ST_TRANSLATED | (WORD) wParam;
#else
                tok.wReserved = ST_TRANSLATED | (WORD) wParam;
#endif

                // should we clean up the delta token information??
                szBuffer = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok)));
                ParseTokToBuf( szBuffer, &tok);
                RLFREE( tok.szText);

                // Now remove old token
                SendMessage( hListWnd, WM_SETREDRAW,    (WPARAM)FALSE,  (LPARAM)0);
                SendMessage( hListWnd, LB_DELETESTRING, (WPARAM)wIndex, (LPARAM)0);

                // Replacing with the new token

                hMem = GlobalAlloc( GMEM_MOVEABLE, sizeof(TOKDATA) );
                lpTokData = (LPTOKDATA)GlobalLock( hMem );
                lpTokData->hToken = GlobalAlloc(GMEM_MOVEABLE,
                                                MEMSIZE(lstrlen((TCHAR *)szBuffer)+1));
                lpstrToken = (LPTSTR) GlobalLock( lpTokData->hToken );
                lstrcpy((TCHAR *)lpstrToken, (TCHAR *)szBuffer);
                GlobalUnlock( lpTokData->hToken );
                lpTokData->lMtkPointer = lMtkPointer;            //MtkPointer

                GlobalUnlock( hMem);
                RLFREE( szBuffer);

                SendMessage( hListWnd,
                             LB_INSERTSTRING,
                             (WPARAM)wIndex,
                             (LPARAM)hMem);

                // Now put focus back on the current string
                SendMessage( hListWnd, LB_SETCURSEL, (WPARAM)wIndex, (LPARAM)0);
                SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)TRUE,   (LPARAM)0);
                InvalidateRect(hListWnd, NULL, TRUE);

                return TRUE;
            }

        case WM_CHARTOITEM:
        case WM_VKEYTOITEM:
            {
#ifdef RLWIN16
                LONG lListParam = 0;
#endif
                // Messages sent to list box when  keys are depressed.
                // Check for Return key pressed.

                switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                    case VK_RETURN:
#ifdef RLWIN16
                        lListParam = (LONG) MAKELONG(NULL,  LBN_DBLCLK);
                        SendMessage(hMainWnd, WM_COMMAND, IDC_LIST, lListParam);
#else
                        SendMessage( hMainWnd,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                     (LPARAM)0);
#endif

                        return TRUE;

                    default:
                        break;
                }
                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDC_LIST:
                    {
                        /*
                         *
                         * This is where we process the list box messages.
                         * The TokEditDlgProc is used to
                         * edit the token selected in LBS_DBLCLK message
                         *
                         */
                        switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                            case (UINT) LBN_ERRSPACE:
                                LoadString( hInst,
                                            IDS_ERR_NO_MEMORY,
                                            sz,
                                            TCHARSIN( sizeof( sz)));
                                MessageBox( hWnd,
                                            sz,
                                            tszAppName,
                                            MB_ICONHAND | MB_OK);
                                return TRUE;

                            case LBN_DBLCLK:
                                {
                                    LPTSTR CurText = NULL;
                                    LPTSTR PreText = NULL;
                                    TCHAR szResIDStr[20] = TEXT("");
                                    TCHAR *szBuffer;

                                    wIndex = (UINT)SendMessage( hListWnd,
                                                                LB_GETCURSEL,
                                                                (WPARAM)0,
                                                                (LPARAM)0);
                                    if (wIndex == (UINT) -1) {
                                        return TRUE;
                                    }

                                    // double click, or Return entered,
                                    // go into token edit mode.
                                    if (!hTokEditDlgWnd) {
                                        // set up modaless dialog box to edit token
#ifdef RLWIN32
                                        hTokEditDlgWnd = CreateDialog(hInst,
                                                                      TEXT("RLEdit"),
                                                                      hWnd,
                                                                      TokEditDlgProc);
#else
                                        lpTokEditDlg =
                                        (DLGPROC) MakeProcInstance(TokEditDlgProc,
                                                                   hInst);
                                        hTokEditDlgWnd = CreateDialog(hInst,
                                                                      TEXT("RLEdit"),
                                                                      hWnd,
                                                                      lpTokEditDlg);
#endif
                                    }

                                    // Get token info from listbox, and place in token struct
                                    hMem = (HGLOBAL)SendMessage( hListWnd,
                                                                 LB_GETITEMDATA,
                                                                 (WPARAM)wIndex,
                                                                 (LPARAM)0);

                                    lpTokData = (LPTOKDATA)GlobalLock( hMem );
                                    lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                                    lMtkPointer = lpTokData->lMtkPointer;

                                    szBuffer = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
                                    lstrcpy( szBuffer, lpstrToken);

                                    GlobalUnlock( lpTokData->hToken );

                                    GlobalUnlock( hMem);
                                    ParseBufToTok(szBuffer, &tok);
                                    RLFREE( szBuffer);

                                    // Now get the token name
                                    // Its either a string, or ordinal number
                                    if (tok.szName[0]) {
                                        lstrcpy( szName, tok.szName);
                                    } else {
#ifdef UNICODE
                                        _itoa(tok.wName, szTmpBuf, 10);
                                        _MBSTOWCS( szName,
                                                   szTmpBuf,
                                                   WCHARSIN( sizeof( szName)),
                                                   ACHARSIN( strlen(szTmpBuf) + 1));
#else

                                        _itoa(tok.wName, szName, 10);
#endif
                                    }
                                    // Now get the token id
#ifdef UNICODE
                                    _itoa(tok.wID, szTmpBuf, 10);
                                    _MBSTOWCS( szID,
                                               szTmpBuf,
                                               WCHARSIN( sizeof( szID)),
                                               ACHARSIN( strlen(szTmpBuf) + 1));
#else
                                    _itoa(tok.wID, szID, 10);
#endif

                                    if ( tok.wType <= 16 || tok.wType == ID_RT_DLGINIT ) {
                                        LoadString(hInst,
                                                   IDS_RESOURCENAMES+tok.wType,
                                                   szResIDStr,
                                                   TCHARSIN( sizeof( szResIDStr)));
                                    } else {
#ifdef UNICODE
                                        _itoa(tok.wType, szTmpBuf, 10);
                                        _MBSTOWCS(szResIDStr,
                                                  szTmpBuf,
                                                  WCHARSIN( sizeof( szResIDStr)),
                                                  ACHARSIN( strlen(szTmpBuf) + 1));
#else
                                        _itoa(tok.wType, szResIDStr, 10);
#endif
                                    }

                                    // Now insert token info  in TokEdit Dialog Box
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKTYPE,
                                                   (LPTSTR) szResIDStr);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKNAME,
                                                   (LPTSTR) szName);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKID,
                                                   (LPTSTR) szID);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKCURTRANS,
                                                   (LPTSTR) tok.szText);
                                    SetDlgItemText(hTokEditDlgWnd,
                                                   IDD_TOKPREVTRANS,
                                                   (LPTSTR) tok.szText);
                                    CheckDlgButton(hTokEditDlgWnd, IDD_DIRTY, 0);

                                    if (tok.wReserved & ST_READONLY) {
                                        CheckDlgButton(hTokEditDlgWnd, IDD_READONLY, 1);
                                        EnableWindow(GetDlgItem(hTokEditDlgWnd,
                                                                IDD_TOKCURTRANS),
                                                     FALSE);
                                        SetFocus(GetDlgItem(hTokEditDlgWnd, IDCANCEL));
                                    } else {
                                        CheckDlgButton(hTokEditDlgWnd, IDD_READONLY, 0);
                                        EnableWindow(GetDlgItem(hTokEditDlgWnd,
                                                                IDD_TOKCURTRANS),
                                                     TRUE);
                                    }

                                    // we did not find anything in the delta info,
                                    // so we need to read it from the master token.

                                    GetTextFromMTK(hTokEditDlgWnd, &tok, lMtkPointer );

                                    RLFREE( tok.szText);

                                    // Disable OK button.
                                    // User must enter text before it is enabled

                                    hCtl = GetDlgItem(hTokEditDlgWnd, IDOK);

                                    SendMessage( hMainWnd,
                                                 WM_TRANSLATE,
                                                 (LPARAM)0,
                                                 (LPARAM)0);
                                    EnableWindow(hCtl, FALSE);
                                    SetActiveWindow(hTokEditDlgWnd);
                                    wIndex = (UINT)SendMessage( hListWnd,
                                                                LB_GETCURSEL,
                                                                (WPARAM)0,
                                                                (LPARAM)0);
                                    return TRUE;
                                }

                                // let these messages fall through,
                            default:
                                break;
                        }
                    }
                default:
                    return FALSE;
            }

            break; // WM_COMMAND Case
    } // Main List Box Switch
    return FALSE;
}

/**
  *  Function: DoMenuCommand.
  * Processes the Menu Command messages.
  *
  *  Errors Codes:
  * TRUE. Message processed.
  * FALSE. Message not processed.
  *
  *  History:
  * 01/92. Implemented.       TerryRu.
  *
  **/

INT_PTR DoMenuCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fListBox = FALSE;
    TCHAR sz[256]=TEXT("");
#ifndef RLWIN32
    WNDPROC lpNewDlg, lpViewDlg;
#endif
    int rc;
    LPTOKDATA    lpTokData;
    long         lMtkPointer;

    // Commands entered from the application menu, or child windows.
    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDM_P_NEW:

            fEditing = FALSE;       //... We are *not* editing an existing .PRJ

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                CHAR szFile[MAXFILENAME] = "";


                if ( GetFileNameFromBrowse( hWnd,
                                            gProj.szPRJ,
                                            MAXFILENAME,
                                            szSaveDlgTitle,
                                            szFilterSpec,
                                            "PRJ")) {
                    strcpy( szFile, gProj.szPRJ);
                } else {
                    break; // user cancelled
                }
#ifdef RLWIN32
                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, NewDlgProc) == IDOK )
#else
                lpNewDlg = MakeProcInstance(NewDlgProc, hInst);

                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, lpNewDlg) == IDOK )
#endif
                {
                    sprintf( szDHW, "%s - %s", szAppName, szFile);
                    SetWindowTextA( hWnd, szDHW);
                    gbNewProject = TRUE;
                    gProj.szTokDate[0] = 0;
                    strcpy( gProj.szPRJ, szFile);
                    fPrjChanges = TRUE;
                    SendMessage( hWnd, WM_READMPJDATA, (WPARAM)0, (LPARAM)0);
                }

                gbNewProject = FALSE;
#ifndef RLWIN32
                FreeProcInstance(lpNewDlg);
#endif
                break;
            }

        case IDM_P_EDIT:

            fEditing = TRUE;        //... We *are* editing an existing .PRJ

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                CHAR szOldMpj[ MAXFILENAME];

                // Save old Master Project name
                lstrcpyA( szOldMpj, gProj.szMpj);

#ifdef RLWIN32
                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, NewDlgProc) == IDOK )
#else
                lpNewDlg = MakeProcInstance(NewDlgProc, hInst);

                if ( DialogBox( hInst, TEXT("PROJECT"), hWnd, lpNewDlg) == IDOK )
#endif
                {
                    fPrjChanges = TRUE;

                    // Still same Master Project referenced?

                    if ( lstrcmpiA( szOldMpj, gProj.szMpj) != 0 ) {
                        gbNewProject = TRUE;        // No
                        gProj.szTokDate[0] = 0;
                        SendMessage( hWnd, WM_READMPJDATA, (WPARAM)0, (LPARAM)0);
                    }
                }
                gbNewProject = FALSE;

#ifndef RLWIN32
                FreeProcInstance(lpNewDlg);
#endif
                break;
            }

        case IDM_P_OPEN:

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                szTempFileName[0] = 0;

                if ( GetFileNameFromBrowse( hWnd,
                                            szTempFileName,
                                            MAXFILENAME,
                                            szOpenDlgTitle,
                                            szFilterSpec,
                                            "PRJ") ) {
                    if ( GetProjectData( szTempFileName,
                                         NULL,
                                         NULL,
                                         FALSE,
                                         FALSE) == SUCCESS ) {
                        SendMessage( hWnd, WM_READMPJDATA, (WPARAM)0, (LPARAM)0);
                        sprintf( szDHW, "%s - %s", szAppName, szTempFileName);
                        SetWindowTextA( hMainWnd, szDHW);
                        strcpy( gProj.szPRJ, szTempFileName);

                        SendMessage( hMainWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                    }
                }
            }
            break;

        case IDM_P_VIEW:

#ifdef RLWIN32
            DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, ViewDlgProc);
#else
            lpViewDlg = (WNDPROC) MakeProcInstance((WNDPROC)ViewDlgProc, hInst);
            DialogBox(hInst, TEXT("VIEWPROJECT"), hWnd, lpViewDlg);
#endif
            break;

        case IDM_P_CLOSE:
            {
                HMENU hMenu;

                hMenu=GetMenu(hWnd);
                if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                    int i;

                    // Remove file name from window title
                    SetWindowTextA(hMainWnd, szAppName);

                    // Hide token list since it's going to be empty
                    ShowWindow(hListWnd, SW_HIDE);

                    // Remove the current token list
                    SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);

                    CleanDeltaList();

                    // Force Repaint of status Window
                    InvalidateRect(hStatusWnd, NULL, TRUE);

                    EnableMenuItem(hMenu, IDM_P_CLOSE,     MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_VIEW,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_EDIT,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_SAVE,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FIND,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDUP,    MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDDOWN,  MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_REVIEW,    MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_ALLREVIEW, MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPY,      MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPYTOKEN, MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_PASTE,     MF_GRAYED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_O_GENERATE,  MF_GRAYED|MF_BYCOMMAND);

                    for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++) {
                        EnableMenuItem(hMenu, i, MF_GRAYED|MF_BYCOMMAND);
                    }
                }
                break;
            }


        case IDM_P_SAVE:

            if (fTokChanges || fPrjChanges) {
                CHAR szPrjName[MAXFILENAME];

                strcpy(szPrjName, gProj.szPRJ);

                if ( SendMessage(hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                    GetProjectData( szPrjName, NULL, NULL, FALSE, FALSE);
                }
            } else {
                LoadString( hInst,
                            IDS_NOCHANGESYET,
                            sz,
                            TCHARSIN( sizeof( sz)));
                MessageBox( hWnd,
                            sz,
                            tszAppName,
                            MB_ICONHAND | MB_OK);
            }
            break;


        case IDM_P_EXIT:
            SendMessage( hWnd,     WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
            PostMessage( hMainWnd, WM_CLOSE,       (WPARAM)0, (LPARAM)0);
            break;

        case IDM_E_COPYTOKEN:
            {
                HANDLE  hStringMem;
                LPTSTR  lpString;
                int     nIndex = 0;
                int     nLength = 0;
                LPTSTR  lpstrToken;

                // Is anything selected in the listbox
                if ( (nIndex = (int)SendMessage( hListWnd,
                                                 LB_GETCURSEL,
                                                 (WPARAM)0,
                                                 (LPARAM)0)) != LB_ERR ) {
                    HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                         LB_GETITEMDATA,
                                                         (WPARAM)nIndex,
                                                         (LPARAM)0);

                    lpTokData = (LPTOKDATA)GlobalLock( hMem );
                    lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                    nLength = lstrlen(lpstrToken);
                    // Allocate memory for the string
                    if ( (hStringMem = GlobalAlloc(GHND,
                                                   (DWORD) MEMSIZE(nLength + 1))) != NULL ) {
                        if ( (lpString = (LPTSTR)GlobalLock(hStringMem)) != NULL ) {
                            // Get the selected text
                            lstrcpy( lpString, lpstrToken);

                            GlobalUnlock( lpTokData->hToken );

                            GlobalUnlock( hMem);
                            // Unlock the block
                            GlobalUnlock( hStringMem);

                            // Open the Clipboard and clear its contents
                            OpenClipboard( hWnd);
                            EmptyClipboard();

                            // Give the Clipboard the text data

#if defined(UNICODE)
                            SetClipboardData( CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                            SetClipboardData( CF_TEXT, hStringMem);
#endif // UNICODE
                            CloseClipboard();

                            hStringMem = NULL;
                        } else {
                            GlobalUnlock( lpTokData->hToken );
                            GlobalUnlock( hMem);
                            LoadString( hInst,
                                        IDS_ERR_NO_MEMORY,
                                        sz,
                                        TCHARSIN( sizeof( sz)));
                            MessageBox( hWnd,
                                        sz,
                                        tszAppName,
                                        MB_ICONHAND | MB_OK);
                        }
                    } else {
                        GlobalUnlock( lpTokData->hToken );
                        GlobalUnlock( hMem);
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    sz,
                                    TCHARSIN( sizeof(sz)));
                        MessageBox( hWnd,
                                    sz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                }
                break;
            }

        case IDM_E_COPY:
            {
                HANDLE  hStringMem;
                LPTSTR  lpString;
                int     nIndex = 0;
                int     nLength = 0;
                int     nActual = 0;
                TOKEN   tok;
                LPTSTR  lpstrToken;

                // Is anything selected in the listbox
                if ( (nIndex = (int)SendMessage( hListWnd,
                                                 LB_GETCURSEL,
                                                 (WPARAM)0,
                                                 (LPARAM)0)) != LB_ERR ) {
                    HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                         LB_GETITEMDATA,
                                                         (WPARAM)nIndex,
                                                         (LPARAM)0);

                    lpTokData = (LPTOKDATA)GlobalLock( hMem );
                    lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );
                    lstrcpy( szString, lpstrToken);

                    GlobalUnlock( lpTokData->hToken );
                    GlobalUnlock( hMem);
                    ParseBufToTok( szString, &tok);
                    nLength = lstrlen( tok.szText);

                    // Allocate memory for the string
                    if ( (hStringMem =
                          GlobalAlloc( GHND, (DWORD)MEMSIZE( nLength + 1))) != NULL ) {
                        if ( (lpString =
                              (LPTSTR)GlobalLock( hStringMem)) != NULL) {
                            // Get the selected text
#ifdef RLWIN32
                            lstrcpy( lpString, tok.szText);
#else
                            _fstrcpy( lpString, tok.szText);
#endif

                            // Unlock the block
                            GlobalUnlock(hStringMem);

                            // Open the Clipboard and clear its contents
                            OpenClipboard( hWnd);
                            EmptyClipboard();

                            // Give the Clipboard the text data

#if defined(UNICODE)
                            SetClipboardData(CF_UNICODETEXT, hStringMem);
#else // not UNICODE
                            SetClipboardData( CF_TEXT, hStringMem);
#endif // UNICODE
                            CloseClipboard();

                            hStringMem = NULL;
                        } else {
                            LoadString( hInst,
                                        IDS_ERR_NO_MEMORY,
                                        sz,
                                        TCHARSIN( sizeof( sz)));
                            MessageBox( hWnd,
                                        sz,
                                        tszAppName,
                                        MB_ICONHAND | MB_OK);
                        }
                    } else {
                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    sz,
                                    TCHARSIN( sizeof( sz)));
                        MessageBox( hWnd,
                                    sz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                    }
                    RLFREE( tok.szText);
                }
                break;
            }

        case IDM_E_PASTE:
            {
                HANDLE  hClipMem = NULL;
                LPTSTR  lpClipMem = NULL;
                HGLOBAL hMem = NULL;
                TCHAR *szString;
                int nIndex = 0;
                TOKEN   tok;
                LPTSTR lpstrToken;

                if ( OpenClipboard( hWnd) ) {

#if defined(UNICODE)
                    if (IsClipboardFormatAvailable(CF_UNICODETEXT)
                        || IsClipboardFormatAvailable(CF_OEMTEXT))
#else // not UNICODE
                    if ( IsClipboardFormatAvailable( CF_TEXT)
                         || IsClipboardFormatAvailable( CF_OEMTEXT))
#endif // UNICODE
                    {
                        // Check for current position and change that token's text
                        nIndex = (int)SendMessage( hListWnd,
                                                   LB_GETCURSEL,
                                                   (WPARAM)0,
                                                   (LPARAM)0);

                        if (nIndex == LB_ERR) {

#if defined(UNICODE)
                            //if no select, just ignore
                            break;
#else // not UNICODE
                            nIndex = -1;
#endif // UNICODE

                        }


#if defined(UNICODE)
                        hClipMem = GetClipboardData(CF_UNICODETEXT);
#else // not UNICODE
                        hClipMem = GetClipboardData( CF_TEXT);
#endif // UNICODE

                        lpClipMem = (LPTSTR)GlobalLock( hClipMem);
                        hMem = (HGLOBAL)SendMessage( hListWnd,
                                                     LB_GETITEMDATA,
                                                     (WPARAM)nIndex,
                                                     (LPARAM)0);

                        lpTokData = (LPTOKDATA)GlobalLock( hMem );
                        lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

                        if ( lpstrToken ) {

#if defined(UNICODE)
                            szString = (TCHAR *)FALLOC(
                                                      MEMSIZE(lstrlen(lpstrToken)+1) );
#else // not UNICODE
                            szString = (TCHAR *)
                                       FALLOC( lstrlen( lpstrToken) + 1);
#endif // UNICODE

                            lstrcpy( szString, lpstrToken);

                            GlobalUnlock( lpTokData->hToken );
                            lMtkPointer = lpTokData->lMtkPointer;    //Save

                            GlobalUnlock( hMem);
                            // copy the string to the token
                            ParseBufToTok(szString, &tok);
                            RLFREE( szString);
                            RLFREE( tok.szText);

                            tok.szText = (TCHAR *)
                                         FALLOC( MEMSIZE( lstrlen( lpClipMem) + 1));
#ifdef RLWIN32
                            lstrcpy( tok.szText, lpClipMem);
#else
                            _fstrcpy(tok.szText, lpClipMem);
#endif

                            GlobalUnlock(hClipMem);
                            szString = (TCHAR *)
                                       FALLOC( MEMSIZE( TokenToTextSize( &tok)));
                            ParseTokToBuf(szString, &tok);
                            RLFREE( tok.szText);

                            // Paste the text
                            SendMessage( hListWnd,
                                         WM_SETREDRAW,
                                         (WPARAM)FALSE,
                                         (LPARAM)0);
                            SendMessage( hListWnd,
                                         LB_DELETESTRING,
                                         (WPARAM)nIndex,
                                         (LPARAM)0);

                            hMem = GlobalAlloc( GMEM_MOVEABLE, sizeof(TOKDATA) );
                            lpTokData = (LPTOKDATA)GlobalLock( hMem );
                            lpTokData->hToken = GlobalAlloc
                                                ( GMEM_MOVEABLE, MEMSIZE(lstrlen(szString)+1) );
                            lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

                            lstrcpy( lpstrToken, szString);
                            RLFREE( szString);

                            GlobalUnlock( lpTokData->hToken );
                            lpTokData->lMtkPointer = lMtkPointer;

                            GlobalUnlock( hMem);
                            SendMessage( hListWnd,
                                         LB_INSERTSTRING,
                                         (WPARAM)nIndex,
                                         (LPARAM)hMem);
                            SendMessage( hListWnd,
                                         LB_SETCURSEL,
                                         (WPARAM)nIndex,
                                         (LPARAM)0);
                            fTokChanges = TRUE; // Set Dirty Flag
                        }
                        SendMessage( hListWnd,
                                     WM_SETREDRAW,
                                     (WPARAM)TRUE,
                                     (LPARAM)0);
                        InvalidateRect(hListWnd, FALSE, TRUE);

                        // Close the Clipboard
                        CloseClipboard();

                        SetFocus(hListWnd);
                    }
                }
                CloseClipboard();
                break;
            }

        case IDM_E_FINDDOWN:

            if (fSearchStarted) {
                if (!DoTokenSearchForRledit(szSearchType,
                                            szSearchText,
                                            wSearchStatus,
                                            wSearchStatusMask,
                                            0,
                                            TRUE)) {
                    TCHAR sz1[80], sz2[80];
                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
                }
                break;
            }
        case IDM_E_FINDUP:
            if (fSearchStarted) {
                if (!DoTokenSearchForRledit(szSearchType,
                                            szSearchText,
                                            wSearchStatus,
                                            wSearchStatusMask,
                                            1,
                                            TRUE)) {
                    TCHAR sz1[80], sz2[80];
                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
                }
                break;
            }

        case IDM_E_FIND:
            {
#ifndef RLWIN32
                WNDPROC lpfnTOKFINDMsgProc;

                lpfnTOKFINDMsgProc = MakeProcInstance( (WNDPROC)TOKFINDMsgProc,
                                                       hInst);

                if ( DialogBox( hInst, TEXT("TOKFIND"), hWnd, lpfnTOKFINDMsgProc) == -1)
#else
                if ( DialogBox( hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc) == -1)
#endif
                {

#ifndef DBCS
// 'Token Not Found' is strange because user selected cancel
                    TCHAR sz1[80], sz2[80];

                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
#endif    //DBCS

                }
#ifndef RLWIN32
                FreeProcInstance( lpfnTOKFINDMsgProc);
#endif
                return TRUE;
            }

        case IDM_E_REVIEW:
            {
                int wSaveSelection;
                nUpdateMode = 1;

                // set listbox selection to begining of the token list
                wSaveSelection = (UINT)SendMessage( hListWnd,
                                                    LB_GETCURSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)0);

                // Selection for REVIEW starts with the user-selected line, (PW)
                // not at the top of the token list.                            (PW)
                // SendMessage(hListWnd, LB_SETCURSEL, 0, 0L);          (PW)

                if ( DoTokenSearchForRledit( NULL,
                                             NULL,
                                             ST_TRANSLATED | ST_DIRTY,
                                             ST_TRANSLATED | ST_DIRTY,
                                             FALSE,
                                             FALSE) ) {
#ifdef RLWIN16
                    LONG lListParam;

                    lListParam      = MAKELONG(NULL, LBN_DBLCLK);
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 (WPARAM)IDC_LIST,
                                 (LPARAM)lListParam);
#else
                    SendMessage( hMainWnd,
                                 WM_COMMAND,
                                 MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                 (LPARAM)0);
#endif

                }
                break;
            }

        case IDM_E_ALLREVIEW:
            {
                UINT    wListParam;
                UINT    wIndex, wcTokens;

                wIndex   = (UINT)SendMessage( hListWnd, LB_GETCURSEL, 0, 0L);
                wcTokens = (UINT)SendMessage( hListWnd, LB_GETCOUNT, 0, 0L );

                if ( wcTokens == wIndex )
                    break;

                nUpdateMode = 2;
                SendMessage( hListWnd, LB_SETCURSEL, wIndex, 0L);
                wListParam  = (UINT) MAKELONG(IDC_LIST, LBN_DBLCLK);
                SendMessage(hMainWnd, WM_COMMAND, wListParam, (LPARAM)0);
                break;
            }


        case IDM_O_GENERATE:
            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                HCURSOR hOldCursor;

                hOldCursor = SetCursor( hHourGlass);
                rc = GenerateImageFile( gProj.szBld,
                                        gMstr.szSrc,
                                        gProj.szTok,
                                        gMstr.szRdfs,
                                        0);
                SetCursor( hOldCursor);
            }
            break;

        case IDM_H_CONTENTS:
            {
                OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

                if ( OpenFile( gszHelpFile, &Of, OF_EXIST) == HFILE_ERROR ) {
                    LoadString( hInst, IDS_ERR_NO_HELP, sz, TCHARSIN( sizeof( sz)));
                    MessageBox( hWnd, sz, NULL, MB_OK);
                } else {
                    WinHelpA( hWnd, gszHelpFile, HELP_KEY, (DWORD_PTR)(LPSTR)"RLEdit");
                }
                break;
            }

        case IDM_H_ABOUT:
            {

#ifndef RLWIN32

                WNDPROC lpProcAbout;

                lpProcAbout = MakeProcInstance(About, hInst);
                DialogBox(hInst, TEXT("ABOUT"), hWnd, lpProcAbout);
                FreeProcInstance(lpProcAbout);
#else
                DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#endif
                break;
            }
            break;

        default:
            if (wParam <= IDM_LAST_EDIT && wParam >= IDM_FIRST_EDIT) {
                // USER IS INVOKING AN EDITOR
                CHAR szEditor[MAXFILENAME] = "";

                if ( LoadStrIntoAnsiBuf(hInst, (UINT)wParam, szEditor, sizeof(szEditor))) {
                    if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) ) {
                        HCURSOR hOldCursor;

                        hOldCursor = SetCursor(hHourGlass);
                        MyGetTempFileName(0, "RES", 0, szTempRes);
                        fInThirdPartyEditer = TRUE;

                        if (gProj.fSourceEXE) {
                            // we need to first extract the .RES from the .EXE
                            CHAR sz[MAXFILENAME] = "";
                            MyGetTempFileName(0, "RES", 0, sz);
                            ExtractResFromExe32A( gMstr. szSrc, sz, 0);
                            GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                             sz,
                                                             gProj.szTok,
                                                             gMstr.szRdfs,
                                                             ID_RT_DIALOG);
                            remove(sz);
                        } else {
                            GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                             gMstr.szSrc,
                                                             gProj.szTok,
                                                             gMstr.szRdfs,
                                                             ID_RT_DIALOG);
                        }
                        SetCursor( hOldCursor);
                        ExecResEditor( hWnd, szEditor, szTempRes,  "");
                    }
                }
            }
            break;  // default
    }
    return FALSE;
}



#ifdef RLWIN16
static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    CHAR szExecCmd[256];
    int  RetCode;

    // generate command line
    lstrcpy( szExecCmd, szEditor);
    lstrcat( szExecCmd, " ");
    lstrcat( szExecCmd, szArgs);
    lstrcat( szExecCmd, " ");
    lstrcat( szExecCmd, szFile);

    lpfnWatchTask = MakeProcInstance(WatchTask, hInst);
    NotifyRegister(NULL, (LPFNNOTIFYCALLBACK)lpfnWatchTask, NF_NORMAL);
    fWatchEditor = TRUE;

    // exec resource editor
    RetCode = WinExec(szExecCmd, SW_SHOWNORMAL);

    if (RetCode > 31) {
        // successful execution
        ShowWindow(hWnd, SW_HIDE);
    } else {
        // unsuccessful execution
        CHAR sz[80];

        NotifyUnRegister(NULL);
        FreeProcInstance(lpfnWatchTask);
        remove(szFile);
        fInThirdPartyEditer = FALSE;
        SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
        LoadString( hInst, IDS_GENERALFAILURE, sz, TCHARSIN( sizeof( sz)));
        MessageBox( hWnd, sz, tszAppName, MB_OK);
    }
    return RetCode;
}

#endif

#ifdef RLWIN32

static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    TCHAR  wszExecCmd[256];
    CHAR   szExecCmd[256];
    DWORD  dwRetCode  = 0;
    DWORD  dwExitCode = 0;
    BOOL   fSuccess = FALSE;
    BOOL   fExit    = FALSE;

    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO     StartupInfo;

    StartupInfo.cb          = sizeof(STARTUPINFO);
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop   = NULL;
    StartupInfo.lpTitle     = TEXT("Resize Dialogs");
    StartupInfo.dwX         = 0L;
    StartupInfo.dwY         = 0L;
    StartupInfo.dwXSize     = 0L;
    StartupInfo.dwYSize     = 0L;
    StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.cbReserved2 = 0;

    //  generate command line
    strcpy(szExecCmd, szEditor);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szArgs);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szFile);


    #ifdef UNICODE
    _MBSTOWCS( wszExecCmd,
               szExecCmd,
               WCHARSIN( sizeof( wszExecCmd)),
               ACHARSIN( strlen(szExecCmd) + 1));
    #else
    strcpy(wszExecCmd, szExecCmd);
    #endif


    fSuccess = CreateProcess( (LPTSTR) NULL,
                              wszExecCmd,
                              NULL,
                              NULL,
                              FALSE,
                              NORMAL_PRIORITY_CLASS,
                              NULL,
                              NULL,
                              &StartupInfo,
                              &ProcessInfo); /* try to create a process */

    if ( fSuccess ) {
        //  wait for the editor to complete */
        dwRetCode = WaitForSingleObject( ProcessInfo.hProcess, 0xFFFFFFFF) ;

        if ( ! dwRetCode ) {
            // editor terminated, check exit code
            fExit = GetExitCodeProcess( ProcessInfo.hProcess, &dwExitCode) ;
        } else {
            fExit = FALSE;
        }
        // close the editor object  handles

        CloseHandle( ProcessInfo.hThread) ;
        CloseHandle( ProcessInfo.hProcess) ;

        if ( fExit ) {
            // successful execution
            ShowWindow(hWnd, SW_HIDE);
            SendMessage(hMainWnd, WM_EDITER_CLOSED, 0, 0);
        } else {
            // unsuccessful execution
            remove( szFile);
            fInThirdPartyEditer = FALSE;
            SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            LoadStrIntoAnsiBuf( hInst, IDS_GENERALFAILURE, szDHW, DHWSIZE);
            MessageBoxA( hWnd, szDHW, szEditor, MB_ICONSTOP|MB_OK);
        }
    } else {
        CHAR  szText[ 80] = "";
        LPSTR pszMsg = szText;


        dwRetCode = GetLastError();

        if ( dwRetCode == ERROR_PATH_NOT_FOUND ) {
            pszMsg = ", Path not found.";
        } else if ( dwRetCode == ERROR_FILE_NOT_FOUND ) {
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

            sprintf( szText,
                     ", File \"%s\" not found.",
                     OpenFile( szFile, &Of, OF_EXIST) != HFILE_ERROR
                     ? szEditor
                     : szFile);
        }
        sprintf( szDHW,
                 "Command  \"%s\"  failed.\nSystem error code = %d%s",
                 szExecCmd,
                 dwRetCode,
                 pszMsg);
        MessageBoxA( hWnd, szDHW, szAppName, MB_ICONEXCLAMATION|MB_OK);
        fExit = FALSE;
    }

    return ( fExit);
}

#endif

/**
  *  Function: WatchTask
  *    A callback function installed by a NotifyRegister function.
  *    This function is installed by the dialog editer command and is used
  *    to tell RLEDIT when the dialog editer has been closed by the user.
  *
  *    To use this function, set fWatchEditor to TRUE and install this
  *    callback function by using NotifyRegister.  The next task initiated
  *    (in our case via a WinExec call) will be watched for termination.
  *
  *    When WatchTask sees that the task being watched has terminated it
  *    posts a WM_EDITER_CLOSED message to RLEDITs main window.
  *
  *  History:
  *    2/92, implemented    SteveBl
  */
#ifdef RLWIN16
BOOL PASCAL _loadds  WatchTask(WORD wID, DWORD dwData)
{
    static HTASK htWatchedTask;
    static BOOL fWatching = FALSE;

    switch (wID) {
        case NFY_STARTTASK:
            if (fWatchEditor) {
                htWatchedTask = GetCurrentTask();
                fWatching = TRUE;
                fWatchEditor = FALSE;
            }
            break;

        case NFY_EXITTASK:
            if (fWatching) {
                if (GetCurrentTask() == htWatchedTask) {
                    PostMessage(hMainWnd, WM_EDITER_CLOSED, 0, 0);
                    fWatching = FALSE;
                }
            }
            break;
    }
    return FALSE;
}

#endif

/**
  *
  *
  *  Function:  TokEditDlgProc
  * Procedure for the edit mode dialog window. Loads the selected token
  * info into the window, and allows the user to change the token text.
  * Once the edit is complete, the procedure sends a message to the
  * list box windows to update the current token info.
  *
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  * TRUE, carry out edit, and update token list box.
  * FALSE, cancel edit.
  *
  *  History:
  *
  *
  **/

INT_PTR CALLBACK TokEditDlgProc(

                               HWND   hDlg,
                               UINT   wMsg,
                               WPARAM wParam,
                               LPARAM lParam)
{
    HWND    hCtl         = NULL;
    HWND    hParentWnd   = NULL;
    UINT static wcTokens = 0;
    UINT    wNotifyCode  = 0;
    UINT    wIndex       = 0;
#ifdef RLWIN16
    LONG    lListParam   = 0;
#endif

    switch ( wMsg ) {
        case WM_INITDIALOG:

            cwCenter( hDlg, 0);
            wcTokens = (UINT)SendMessage( hListWnd,
                                          LB_GETCOUNT,
                                          (WPARAM)0,
                                          (LPARAM)0);
            wcTokens--;

            // only allow skip button if in update mode
            if ( ! nUpdateMode ) {
                if ( (hCtl = GetDlgItem( hDlg, IDD_SKIP)) ) {
                    EnableWindow( hCtl, FALSE);
                }
            } else {
                if ( (hCtl = GetDlgItem( hDlg, IDD_SKIP)) ) {
                    EnableWindow( hCtl, TRUE);
                }
            }

            // disallow auto translate if we don't have a glossary file

            if ( *gProj.szGlo == '\0' ) {
                hCtl = GetDlgItem( hDlg, IDD_TRANSLATE);
                EnableWindow( hCtl, FALSE);
                hCtl = GetDlgItem( hDlg, IDD_ADD);
                EnableWindow( hCtl, FALSE);
            }
            return ( TRUE);

        case WM_COMMAND:

            switch ( GET_WM_COMMAND_ID( wParam, lParam) ) {
                case IDD_TOKCURTRANS:

                    wNotifyCode = GET_WM_COMMAND_CMD( wParam, lParam);
                    hCtl = GET_WM_COMMAND_HWND( wParam, lParam);

                    if ( wNotifyCode == EN_CHANGE ) {
                        if ( hCtl = GetDlgItem( hDlg, IDOK) ) {
                            EnableWindow( hCtl, TRUE);
                        }
                    }
                    break;

                case IDD_ADD:
                    {
                        TCHAR *szUntranslated = NULL;
                        TCHAR *szTranslated   = NULL;
                        TCHAR *sz             = NULL;
                        TCHAR szMask[80]      = TEXT("");
                        HWND hDlgItem         = NULL;
                        int  cCurTextLen      = 0;
                        int  cTotalTextLen    = 80;


                        hDlgItem       = GetDlgItem( hDlg, IDD_TOKCURTEXT);
                        cCurTextLen    = GetWindowTextLength( hDlgItem);
                        cTotalTextLen += cCurTextLen;
                        szUntranslated = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));

                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTEXT,
                                        szUntranslated,
                                        cCurTextLen + 1);

                        hDlgItem       = GetDlgItem( hDlg, IDD_TOKCURTRANS);
                        cCurTextLen    = GetWindowTextLength( hDlgItem);
                        cTotalTextLen += cCurTextLen;
                        szTranslated   = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));
                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTRANS,
                                        szTranslated,
                                        cCurTextLen + 1);

                        LoadString( hInst,
                                    IDS_ADDGLOSS,
                                    szMask,
                                    TCHARSIN( sizeof(szMask)));

                        sz = (TCHAR *)FALLOC( MEMSIZE( cTotalTextLen + 1));
                        wsprintf( sz, szMask, szTranslated, szUntranslated);

                        if ( MessageBox( hDlg,
                                         sz,
                                         tszAppName,
                                         MB_ICONQUESTION | MB_YESNO) == IDYES) {
                            HCURSOR hOldCursor = SetCursor( hHourGlass);

                            AddTranslation( szUntranslated,
                                            szTranslated,
                                            lFilePointer);

                            TransString( szUntranslated,
                                         szTranslated,
                                         &pTransList,
                                         lFilePointer);
                            SetCursor( hOldCursor);
                        }
                        RLFREE( sz);
                        RLFREE( szUntranslated);
                        RLFREE( szTranslated);
                        break;
                    }

                case IDD_UNTRANSLATE:
                    {
                        int cTextLen  = 0;
                        TCHAR *sz     = NULL;
                        HWND hDlgItem = NULL;

                        hDlgItem = GetDlgItem( hDlg, IDD_TOKCURTEXT);
                        cTextLen = GetWindowTextLength( hDlgItem);
                        sz = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));

                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTEXT,
                                        sz,
                                        cTextLen + 1);

                        SetDlgItemText( hDlg, IDD_TOKCURTRANS, sz);
                        RLFREE( sz);
                        break;
                    }

                case IDD_TRANSLATE:
                    // Get next thing in the translation list
                    if ( pTransList ) {
                        pTransList = pTransList->pNext;
                        SetDlgItemText( hDlg, IDD_TOKCURTRANS, pTransList->sz);
                    }
                    break;

                case IDD_SKIP:

                    wIndex = (UINT)SendMessage( hListWnd,
                                                LB_GETCURSEL,
                                                (LPARAM)0,
                                                (LPARAM)0);

                    if ( nUpdateMode == 2 && wIndex < wcTokens ) {
                        wIndex++;
                        SendMessage( hListWnd, LB_SETCURSEL, wIndex, 0L );
                        SendMessage( hMainWnd,
                                     WM_COMMAND,
                                     MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                     (LPARAM)0);
                        return ( TRUE );
                    } else if ( nUpdateMode == 1 && (wIndex < wcTokens) ) {
                        wIndex++;
                        SendMessage( hListWnd,
                                     LB_SETCURSEL,
                                     (WPARAM)wIndex,
                                     (LPARAM)0);

                        if ( DoTokenSearchForRledit( NULL,
                                                     NULL,
                                                     ST_TRANSLATED | ST_DIRTY,
                                                     ST_TRANSLATED | ST_DIRTY,
                                                     FALSE,
                                                     FALSE) ) {
                            // go into edit mode
                            wIndex = (UINT)SendMessage( hListWnd,
                                                        LB_GETCURSEL,
                                                        (WPARAM)0,
                                                        (LPARAM)0);
#ifdef RLWIN16
                            SendMessage( hMainWnd,
                                         WM_COMMAND,
                                         IDC_LIST,
                                         MAKELONG( NULL, LBN_DBLCLK));
#else
                            SendMessage( hMainWnd,
                                         WM_COMMAND,
                                         MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                         (LPARAM)0);
#endif

                            return TRUE;
                        }
                    }
                    nUpdateMode = 0;

                    // remove edit dialog box
                    DestroyWindow( hDlg);
#ifndef RLWIN32
                    FreeProcInstance( (FARPROC)lpTokEditDlg);
#endif
                    hTokEditDlgWnd = 0;
                    break;

                case IDD_READONLY:
                    if ( IsDlgButtonChecked( hDlg, IDD_READONLY) ) {
                        EnableWindow( GetDlgItem( hDlg, IDD_TOKCURTRANS), FALSE);
                    } else {
                        EnableWindow( GetDlgItem( hDlg, IDD_TOKCURTRANS), TRUE);
                    }
                    break;

                case IDOK:
                    {
                        int cTokenTextLen   = 0;
                        TCHAR *szTokTextBuf = NULL;
                        HWND hDlgItem       = NULL;

                        wIndex = (UINT)SendMessage( hListWnd,
                                                    LB_GETCURSEL,
                                                    (WPARAM)0,
                                                    (LPARAM)0);
                        fTokChanges  = TRUE;

                        // set flag to show token list has changed
                        // Extract String from IDD_TOKTEXT edit control

                        hDlgItem = GetDlgItem( hDlg, IDD_TOKCURTRANS);
                        cTokenTextLen = GetWindowTextLength( hDlgItem);
                        szTokTextBuf = (TCHAR *)FALLOC( MEMSIZE( cTokenTextLen + 1));
                        GetDlgItemText( hDlg,
                                        IDD_TOKCURTRANS,
                                        szTokTextBuf,
                                        cTokenTextLen+1);

                        hParentWnd = GetParent( hDlg);
                        SendMessage( hParentWnd,
                                     WM_TOKEDIT,
                                     (WPARAM)((IsDlgButtonChecked( hDlg, IDD_READONLY)
                                               ? ST_READONLY : 0)
                                              | (IsDlgButtonChecked( hDlg, IDD_DIRTY)
                                                 ? ST_DIRTY : 0)),
                                     (LPARAM)szTokTextBuf);

                        RLFREE( szTokTextBuf);

                        // Exit, or goto to next changed token if in update mode

                        if ( nUpdateMode == 2 && wIndex < wcTokens ) {
                            wIndex++;
                            SendMessage( hListWnd, LB_SETCURSEL, wIndex, 0L );
                            SendMessage( hMainWnd,
                                         WM_COMMAND,
                                         MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                                         (LPARAM)0);
                            return ( TRUE );
                        } else if ( nUpdateMode == 1 && (wIndex < wcTokens) ) {
                            wIndex++;
                            SendMessage( hListWnd,
                                         LB_SETCURSEL,
                                         (WPARAM)wIndex,
                                         (LPARAM)0);

                            if ( DoTokenSearchForRledit( NULL,
                                                         NULL,
                                                         ST_TRANSLATED | ST_DIRTY,
                                                         ST_TRANSLATED | ST_DIRTY,
                                                         FALSE,
                                                         FALSE) ) {
                                // go into edit mode
#ifdef RLWIN16
                                lListParam = MAKELONG(NULL, LBN_DBLCLK);
                                SendMessage( hMainWnd,
                                             WM_COMMAND,
                                             IDC_LIST,
                                             lListParam);
#else
                                SendMessage( hMainWnd,
                                             WM_COMMAND,
                                             MAKEWPARAM(IDC_LIST, LBN_DBLCLK),
                                             (LPARAM)0);
#endif

                                return ( TRUE);
                            }
                        }
                    }
                    // fall through to IDCANCEL

                case IDCANCEL:

                    nUpdateMode = 0;

                    // remove edit dialog box
                    DestroyWindow( hDlg);
#ifndef RLWIN32
                    FreeProcInstance( lpTokEditDlg);
#endif
                    hTokEditDlgWnd = 0;
                    break;
            } // GET_WM_COMMAND_ID
            return ( TRUE);

        default:

            if ( (hCtl = GetDlgItem(hDlg, IDOK)) ) {
                EnableWindow( hCtl, TRUE);
            }
            return ( FALSE);
    } // Main Switch
}


/**
  *
  *  Function: TOKFINDMsgProc
  *
  *  Arguments:
  *
  *  Returns:
  * NA.
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/

//#ifdef RLWIN32
//BOOL CALLBACK TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, UINT wParam, LONG lParam)
//#else
INT_PTR CALLBACK TOKFINDMsgProc(

                               HWND   hWndDlg,
                               UINT   wMsg,
                               WPARAM wParam,
                               LPARAM lParam)
//#endif
{
    HWND hCtl;
    int rgiTokenTypes[]=
    {
        ID_RT_MENU,
        ID_RT_DIALOG,
        ID_RT_STRING,
        ID_RT_ACCELERATORS,
        ID_RT_RCDATA,
        ID_RT_ERRTABLE,
        ID_RT_NAMETABLE,
        ID_RT_VERSION,
        ID_RT_DLGINIT
    };
    TCHAR szTokenType[20] = TEXT("");
    WORD i;
    DWORD rc;

    switch (wMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hWndDlg, IDD_READONLY, 2);
            CheckDlgButton(hWndDlg, IDD_DIRTY, 2);
            CheckDlgButton(hWndDlg, IDD_FINDDOWN, 1);
            hCtl = GetDlgItem(hWndDlg, IDD_TYPELST);

            for (i = 0; i < sizeof(rgiTokenTypes)/sizeof(int); i ++) {
                LoadString( hInst,
                            IDS_RESOURCENAMES + rgiTokenTypes[i],
                            szTokenType,
                            TCHARSIN( sizeof( szTokenType)));
                SendMessage( hCtl,
                             CB_ADDSTRING,
                             (WPARAM)0,
                             (LPARAM)szTokenType);
            }
            return TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK: /* Button text: "Okay"                        */
                    GetDlgItemText(hWndDlg, IDD_TYPELST, szSearchType, 40);
                    GetDlgItemText(hWndDlg, IDD_FINDTOK, szSearchText, 256);
                    wSearchStatus = ST_TRANSLATED;
                    wSearchStatusMask = ST_TRANSLATED ;
                    switch (IsDlgButtonChecked(hWndDlg, IDD_READONLY)) {
                        case 1:
                            wSearchStatus |= ST_READONLY;

                        case 0:
                            wSearchStatusMask |= ST_READONLY;
                    }

                    switch (IsDlgButtonChecked(hWndDlg, IDD_DIRTY)) {
                        case 1:
                            wSearchStatus |= ST_DIRTY;

                        case 0:
                            wSearchStatusMask |= ST_DIRTY;
                    }
                    fSearchStarted = TRUE;
                    fSearchDirection = IsDlgButtonChecked(hWndDlg, IDD_FINDUP);
                    EndDialog( hWndDlg,
                               DoTokenSearchForRledit( szSearchType,
                                                       szSearchText,
                                                       wSearchStatus,
                                                       wSearchStatusMask,
                                                       fSearchDirection,
                                                       FALSE));
                    return TRUE;

                case IDCANCEL:
                    /* and dismiss the dialog window returning FALSE       */
                    EndDialog( hWndDlg, -1);
                    return TRUE;
            }
            break;    /* End of WM_COMMAND     */

        default:
            return FALSE;
    }
    return FALSE;
}

/**
  *  Function:  NewDlgProc
  * Procedure for the new project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  * TRUE, carry out edit, and update token list box.
  * FALSE, cancel edit.
  *
  *  History:
  **/
static CHAR szPrompt[80] = "";
static CHAR *szFSpec  = NULL;
static CHAR *szExt    = NULL;
static int   iLastBox = IDD_MPJ;

INT_PTR CALLBACK NewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static PROJDATA OldProj;
    static CHAR     szNewFileName[ MAXFILENAME] = "";


    switch ( wMsg ) {
        case WM_INITDIALOG:
            {
                int    nSel = 0;
                LPTSTR pszLangName = NULL;

                // Save the old .PRJ

                CopyMemory( &OldProj, &gProj, sizeof( PROJDATA));

                if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( gMstr.wLanguageID)),
                                                 (WORD)(SUBLANGID( gMstr.wLanguageID)))) == NULL ) {
                    SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, TEXT("UNKNOWN"));
                } else {
                    SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, pszLangName);
                }

                FillListAndSetLang( hDlg,
                                    IDD_PROJ_LANG_NAME,
                                    &gProj.wLanguageID,
                                    NULL);

                if ( gProj.uCodePage == CP_ACP )
                    gProj.uCodePage = GetACP();
                else if ( gProj.uCodePage == CP_OEMCP )
                    gProj.uCodePage = GetOEMCP();

                if ( ! IsValidCodePage( gProj.uCodePage) ) {
                    static TCHAR szMsg[ 256];
                    CHAR *pszCP[1];

                    pszCP[0] = UlongToPtr(gProj.uCodePage);

                    LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
                    FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   szMsg,
                                   0,
                                   0,
                                   (LPTSTR)szDHW,
                                   DHWSIZE/sizeof(TCHAR),
                                   (va_list *)pszCP);
                    MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
                }
                SetDlgItemInt( hDlg, IDD_PROJ_TOK_CP, gProj.uCodePage, FALSE);

                if ( fEditing ) {
                    SetDlgItemTextA( hDlg, IDD_MPJ,      gProj.szMpj);
                    SetDlgItemTextA( hDlg, IDD_TOK,      gProj.szTok);
                    SetDlgItemTextA( hDlg, IDD_BUILTRES, gProj.szBld);
                    SetDlgItemTextA( hDlg, IDD_GLOSS,    gProj.szGlo);
                } else {
                    // fill in suggested name for the token file
                    SetDlgItemTextA( hDlg, IDD_TOK,      ".TOK");
                    SetDlgItemTextA( hDlg, IDD_BUILTRES, ".EXE");
                    SetDlgItemTextA( hDlg, IDD_GLOSS,    ".TXT");
                    iLastBox = IDD_MPJ;
                    PostMessage( hDlg, WM_COMMAND, IDD_BROWSE, 0);
                }
                CheckRadioButton( hDlg,
                                  IDC_REPLACE,
                                  IDC_APPEND,
                                  gfReplace ? IDC_REPLACE : IDC_APPEND);
                return TRUE;
            }

        case WM_COMMAND:

            switch ( GET_WM_COMMAND_ID( wParam, lParam) ) {
                case IDD_MPJ:
                case IDD_TOK:
                case IDD_BUILTRES:
                case IDD_GLOSS:

                    iLastBox = GET_WM_COMMAND_ID( wParam, lParam);
                    break;

                case IDD_BROWSE:
                    {
                        switch ( iLastBox ) {
                            case IDD_MPJ:

                                szFSpec = szMPJFilterSpec;
                                szExt   = "MPJ";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_MPJ,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;

                            case IDD_BUILTRES:

                                szFSpec = szExeResFilterSpec;
                                szExt   = "EXE";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_RES_BLD,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;

                            case IDD_TOK:

                                szFSpec = szTokFilterSpec;
                                szExt   = "TOK";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_TOK,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;

                            case IDD_GLOSS:

                                szFSpec = szGlossFilterSpec;
                                szExt   ="TXT";
                                LoadStrIntoAnsiBuf( hInst,
                                                    IDS_GLOSS,
                                                    szPrompt,
                                                    sizeof( szPrompt));
                                break;
                        } // END switch ( iLastBox )

                        if ( GetFileNameFromBrowse( hDlg,
                                                    szNewFileName,
                                                    MAXFILENAME,
                                                    szPrompt,
                                                    szFSpec,
                                                    szExt) ) {
                            SetDlgItemTextA( hDlg, iLastBox, szNewFileName);
                            SetNames( hDlg, iLastBox, szNewFileName);
                        }
                        break;
                    } // END case IDD_BROWSE:

                case IDC_REPLACE:
                case IDC_APPEND:

                    CheckRadioButton( hDlg,
                                      IDC_REPLACE,
                                      IDC_APPEND,
                                      GET_WM_COMMAND_ID( wParam, lParam));
                    break;

                case IDD_PROJ_LANG_NAME:

                    if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK ) {
                        //... Get the selected language name
                        //... then set the appropriate lang id vals

                        INT_PTR nSel = SendDlgItemMessage( hDlg,
                                                           IDD_PROJ_LANG_NAME,
                                                           CB_GETCURSEL,
                                                           (WPARAM)0,
                                                           (LPARAM)0);

                        if ( nSel != CB_ERR
                             && SendDlgItemMessage( hDlg,
                                                    IDD_PROJ_LANG_NAME,
                                                    CB_GETLBTEXT,
                                                    (WPARAM)nSel,
                                                    (LPARAM)(LPTSTR)szDHW) != CB_ERR ) {
                            WORD wPri = 0;
                            WORD wSub = 0;

                            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) ) {
                                gProj.wLanguageID = MAKELANGID( wPri, wSub);
                            }
                        }
                    }
                    break;

                case IDOK:
                    {
                        PROJDATA stProject =
                        { "", "", "", "", "", "",
                            CP_ACP,
                            MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US),
                            FALSE,
                            FALSE
                        };
                        BOOL fTranslated = FALSE;
                        UINT uCP = GetDlgItemInt( hDlg,
                                                  IDD_TOK_CP,
                                                  &fTranslated,
                                                  FALSE);

                        if ( uCP == CP_ACP )
                            uCP = GetACP();
                        else if ( uCP == CP_OEMCP )
                            uCP = GetOEMCP();

                        if ( IsValidCodePage( uCP) ) {
                            gProj.uCodePage = uCP;
                        } else {
                            static TCHAR szMsg[ 256];
                            CHAR *pszCP[1];

                            pszCP[0] = UlongToPtr(uCP);

                            LoadString( hInst, IDS_NOCPXTABLE, szMsg, 256);
                            FormatMessage( FORMAT_MESSAGE_FROM_STRING
                                           | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                           szMsg,
                                           0,
                                           0,
                                           (LPTSTR)szDHW,
                                           DHWSIZE/sizeof(TCHAR),
                                           (va_list *)pszCP);
                            MessageBox( hDlg, (LPCTSTR)szDHW, tszAppName, MB_ICONHAND|MB_OK);
                            SetDlgItemInt( hDlg, IDD_TOK_CP, gProj.uCodePage, FALSE);
                            return ( TRUE);
                        }

                        GetDlgItemTextA( hDlg, IDD_MPJ,      stProject.szMpj, MAXFILENAME);
                        GetDlgItemTextA( hDlg, IDD_BUILTRES, stProject.szBld, MAXFILENAME);
                        GetDlgItemTextA( hDlg, IDD_TOK,      stProject.szTok, MAXFILENAME);
                        GetDlgItemTextA( hDlg, IDD_GLOSS,    stProject.szGlo, MAXFILENAME);

                        //Why don't allow the partial path?
                        if ( stProject.szMpj[0]
                             && stProject.szBld[0]
                             && stProject.szTok[0]  ) {
                            _fullpath( gProj.szMpj,
                                       stProject.szMpj,
                                       sizeof( gProj.szMpj));
                            _fullpath( gProj.szBld,
                                       stProject.szBld,
                                       sizeof( gProj.szBld));
                            _fullpath( gProj.szTok,
                                       stProject.szTok,
                                       sizeof( gProj.szTok));

                            if ( stProject.szGlo[0] != '\0' ) {
                                _fullpath( gProj.szGlo,
                                           stProject.szGlo,
                                           sizeof( gProj.szGlo));
                            }
                            gfReplace = IsDlgButtonChecked( hDlg, IDC_REPLACE);
                            EndDialog( hDlg, TRUE);

                            return ( TRUE);
                        } else {
                            break;
                        }
                    } // END case ID_OK:

                case IDCANCEL:

                    CopyMemory( &gProj, &OldProj, sizeof( PROJDATA));
                    EndDialog( hDlg, FALSE);
                    return ( TRUE);
            } // END switch ( GET_WM_COMMAND_ID( wParam, lParam) )
            break;
    } // END switch ( wMsg )
    return ( FALSE);
}

/**
  *  Function:  ViewDlgProc
  * Procedure for the View project dialog window.
  *
  *  Arguments:
  *
  *  Returns:  NA.
  *
  *  Errors Codes:
  * TRUE, carry out edit, and update token list box.
  * FALSE, cancel edit.
  *
  *  History:
  **/

INT_PTR CALLBACK ViewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static int iLastBox = IDD_MPJ;

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                LPTSTR pszLangName = NULL;


                if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( gMstr.wLanguageID)),
                                                 (WORD)(SUBLANGID( gMstr.wLanguageID)))) == NULL ) {
                    sprintf( szDHW, "Unknown LANGID %#06hx", gMstr.wLanguageID);
                    SetDlgItemTextA( hDlg, IDD_MSTR_LANG_NAME, szDHW);
                } else {
                    SetDlgItemText( hDlg, IDD_MSTR_LANG_NAME, pszLangName);
                }

                if ( (pszLangName = GetLangName( (WORD)(PRIMARYLANGID( gProj.wLanguageID)),
                                                 (WORD)(SUBLANGID( gProj.wLanguageID)))) == NULL ) {
                    sprintf( szDHW, "Unknown LANGID %#06hx", gProj.wLanguageID);
                    SetDlgItemTextA( hDlg, IDD_PROJ_LANG_NAME, szDHW);
                } else {
                    SetDlgItemText( hDlg, IDD_PROJ_LANG_NAME, pszLangName);
                }

                SetDlgItemTextA( hDlg, IDD_VIEW_SOURCERES,  gMstr.szSrc);
                SetDlgItemTextA( hDlg, IDD_VIEW_MTK,        gMstr.szMtk);
                SetDlgItemTextA( hDlg, IDD_VIEW_RDFS,       gMstr.szRdfs);
                SetDlgItemTextA( hDlg, IDD_VIEW_MPJ,        gProj.szMpj);
                SetDlgItemTextA( hDlg, IDD_VIEW_TOK,        gProj.szTok);
                SetDlgItemTextA( hDlg, IDD_VIEW_TARGETRES,  gProj.szBld);
                SetDlgItemTextA( hDlg, IDD_VIEW_GLOSSTRANS, gProj.szGlo);

                if ( gProj.uCodePage == CP_ACP )
                    gProj.uCodePage = GetACP();
                else if ( gProj.uCodePage == CP_OEMCP )
                    gProj.uCodePage = GetOEMCP();

                SetDlgItemInt( hDlg, IDD_PROJ_TOK_CP, gProj.uCodePage, FALSE);

                LoadString( hInst,
                            gfReplace ? IDS_WILLREPLACE : IDS_WILLAPPEND,
                            (LPTSTR)szDHW,
                            TCHARSIN( DHWSIZE));
                SetDlgItemText( hDlg, IDC_APPENDREPLACE, (LPTSTR)szDHW);

                return TRUE;
            }
        case WM_COMMAND:

            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:

                    EndDialog(hDlg, TRUE);
                    return TRUE;
            }
    }
    return FALSE;
}

/**
  *  Function:
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  **/
static void DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    LPRECT  lprc        = (LPRECT) &(lpdis->rcItem);
    DWORD   rgbOldText  = 0;
    DWORD   rgbOldBack  = 0;
    HBRUSH  hBrush;
    static DWORD    rgbHighlightText;
    static DWORD    rgbHighlightBack;
    static HBRUSH   hBrushHilite = NULL;
    static HBRUSH   hBrushNormal = NULL;
    static DWORD    rgbDirtyText;
    static DWORD    rgbBackColor;
    static DWORD    rgbCleanText;
    static DWORD    rgbReadOnlyText;
    TCHAR           *szToken;
    TOKEN           tok;
    LPTSTR          lpstrToken;
    LPTOKDATA        lpTokData;


    if (lpdis->itemAction & ODA_FOCUS) {
        DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
    } else {
        HANDLE hMem = (HANDLE)SendMessage( lpdis->hwndItem,
                                           LB_GETITEMDATA,
                                           (WPARAM)lpdis->itemID,
                                           (LPARAM)0);

        lpTokData = (LPTOKDATA)GlobalLock( hMem );
        lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken );

        szToken = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
        lstrcpy( szToken, lpstrToken);

        GlobalUnlock( lpTokData->hToken );
        GlobalUnlock( hMem);
        ParseBufToTok(szToken, &tok);
        RLFREE( szToken);

        if (lpdis->itemState & ODS_SELECTED) {
            if (!hBrushHilite) {
                rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                rgbHighlightBack = GetSysColor(COLOR_HIGHLIGHT);
                hBrushHilite = CreateSolidBrush(rgbHighlightBack);
            }
            GenStatusLine(&tok);

            rgbOldText = SetTextColor(lpdis->hDC, rgbHighlightText);
            rgbOldBack = SetBkColor(lpdis->hDC, rgbHighlightBack);

            hBrush = hBrushHilite;
        } else {
            if (!hBrushNormal) {
                rgbDirtyText = RGB(255, 0, 0);
                rgbBackColor = RGB(192, 192, 192);
                rgbCleanText = RGB(0, 0, 0);
                rgbReadOnlyText = RGB(127, 127, 127);
                hBrushNormal = CreateSolidBrush(rgbBackColor);
            }
            if (tok.wReserved & ST_READONLY) {
                rgbOldText = SetTextColor(lpdis->hDC, rgbReadOnlyText);
            } else {
                if (tok.wReserved & ST_DIRTY) {
                    rgbOldText = SetTextColor(lpdis->hDC, rgbDirtyText);
                } else {
                    rgbOldText = SetTextColor(lpdis->hDC, rgbCleanText);
                }
            }
            rgbOldBack = SetBkColor(lpdis->hDC, rgbBackColor);
            hBrush = hBrushNormal;
        }
        FillRect(lpdis->hDC, (CONST RECT *)lprc, hBrush);
        DrawText(lpdis->hDC,
                 tok.szText,
                 STRINGSIZE(lstrlen(tok.szText)),
                 lprc,
                 DT_LEFT|DT_NOPREFIX);
        RLFREE( tok.szText);

        if (rgbOldText) {
            SetTextColor(lpdis->hDC, rgbOldText);
        }
        if (rgbOldBack) {
            SetBkColor(lpdis->hDC, rgbOldBack);
        }

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
        }
    }
}

/**********************************************************************
*FUNCTION: SaveTokList(HWND, FILE *fpTokFile)                         *
*                                                                     *
*PURPOSE: Save current Token List                                     *
*                                                                     *
*COMMENTS:                                                            *
*                                                                     *
*This saves the current contents of the Token List, and changes       *
*fTokChanges to indicate that the list has not been changed since the *
*last save.                                                           *
**********************************************************************/

static BOOL SaveTokList(HWND hWnd, FILE *fpTokFile)
{
    HCURSOR hSaveCursor;
    BOOL bSuccess = TRUE;
    int IOStatus;
    UINT cTokens;
    UINT cCurrentTok = 0;
    CHAR   *szTokBuf = NULL;
    LPTSTR lpstrToken = NULL;
    HGLOBAL hMem = NULL;
    LPTOKDATA    lpTokData;


    // Set the cursor to an hourglass during the file transfer

    hSaveCursor = SetCursor(hHourGlass);

    // Find number of tokens in the list

    cTokens = (UINT)SendMessage( hListWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

    if ( cTokens != LB_ERR ) {
        for (cCurrentTok = 0; bSuccess && (cCurrentTok < cTokens); cCurrentTok++) {
            int nLen1 = 0;
            int nLen2 = 0;

            // Get each token from list
            hMem = (HGLOBAL)SendMessage( hListWnd,
                                         LB_GETITEMDATA,
                                         (WPARAM)cCurrentTok,
                                         (LPARAM)0);

            if ( ! (lpTokData = (LPTOKDATA)GlobalLock(hMem)) ) {
                continue;
            }

            if ( (lpstrToken = (LPTSTR)GlobalLock( lpTokData->hToken)) ) {
                szTokBuf = (CHAR *)FALLOC( (nLen2 = MEMSIZE( (nLen1 = lstrlen(lpstrToken)+1))));
#ifdef UNICODE
                _WCSTOMBS( szTokBuf, lpstrToken, nLen2, nLen1);
#else
                lstrcpy(szTokBuf, lpstrToken);
#endif

                GlobalUnlock( lpTokData->hToken );
                GlobalUnlock( hMem);
                IOStatus = fprintf(fpTokFile, "%s\n", szTokBuf);

                if ( IOStatus != (int) strlen(szTokBuf) + 1 ) {
                    TCHAR szTmpBuf[256];

                    LoadString( hInst,
                                IDS_FILESAVEERR,
                                szTmpBuf,
                                TCHARSIN( sizeof(szTmpBuf)));
                    MessageBox( hWnd,
                                szTmpBuf,
                                tszAppName,
                                MB_OK | MB_ICONHAND);
                    bSuccess = FALSE;
                }
                RLFREE( szTokBuf);
            }
        }
    }
    // restore cursor
    SetCursor(hSaveCursor);
    return (bSuccess);
}




/**
  * Function: CleanDeltaList
  *   frees the pTokenDeltaInfo list
  */
static void CleanDeltaList(void)
{
    TOKENDELTAINFO FAR *pTokNode;

    while (pTokNode = pTokenDeltaInfo) {
        pTokenDeltaInfo = pTokNode->pNextTokenDelta;
        RLFREE( pTokNode->DeltaToken.szText);
        RLFREE( pTokNode);
    }
}

/*
 * About -- message processor for about box
 *
 */
//#ifdef RLWIN32
//
//BOOL CALLBACK About(
//
//HWND   hDlg,
//UINT   message,
//WPARAM wParam,
//LPARAM lParam)
//
//#else
//
INT_PTR CALLBACK About(

                      HWND   hDlg,
                      UINT   message,
                      WPARAM wParam,
                      LPARAM lParam)
//
//#endif
{
    switch ( message ) {
        case WM_INITDIALOG:
            {
                WORD wRC = SUCCESS;
                CHAR szModName[ MAXFILENAME];

                GetModuleFileNameA( hInst, szModName, sizeof( szModName));

                if ( (wRC = GetCopyright( szModName,
                                          szDHW,
                                          DHWSIZE)) == SUCCESS ) {
                    SetDlgItemTextA( hDlg, IDC_COPYRIGHT, szDHW);
                } else {
                    ShowErr( wRC, NULL, NULL);
                }
            }
            break;

        case WM_COMMAND:

            if ((wParam == IDOK) || (wParam == IDCANCEL)) {
                EndDialog(hDlg, TRUE);
            }
            break;

        default:

            return ( FALSE);
    }
    return ( TRUE);
}


//...................................................................

int  RLMessageBoxA(

                  LPCSTR pszMsgText)
{
    return ( MessageBoxA( NULL, pszMsgText, szAppName, MB_ICONHAND|MB_OK));
}


//...................................................................

void Usage()
{
    return;
}


//...................................................................

void DoExit( int nErrCode)
{
    ExitProcess( (UINT)nErrCode);
}


//...................................................................

static void SetNames( HWND hDlg, int iLastBox, LPSTR szNewFile)
{
    static CHAR szDrive[ _MAX_DRIVE] = "";
    static CHAR szDir[   _MAX_DIR]   = "";
    static CHAR szName[  _MAX_FNAME] = "";
    static CHAR szExt[   _MAX_EXT]   = "";
    static CHAR szOldFileName[ MAXFILENAME];


    if ( iLastBox == IDD_MPJ ) {
        lstrcpyA( gProj.szMpj, szNewFile);

        if ( ! fEditing && GetMasterProjectData( gProj.szMpj,
                                                 NULL,
                                                 NULL,
                                                 FALSE) == SUCCESS ) {
            // Suggest a name for the target file

            GetDlgItemTextA( hDlg, IDD_BUILTRES, szOldFileName, MAXFILENAME);

            if ( szOldFileName[0] == '\0' || szOldFileName[0] == '.' ) {
                _splitpath( gProj.szPRJ, szDrive, szDir, szName, szExt);

                sprintf( gProj.szBld, "%s%s", szDrive, szDir);

                _splitpath( gMstr.szSrc, szDrive, szDir, szName, szExt);

                sprintf( &gProj.szBld[ lstrlenA( gProj.szBld)],
                         "%s%s",
                         szName,
                         szExt);

                SetDlgItemTextA( hDlg, IDD_BUILTRES, gProj.szBld);
            }
        } else {
            return;
        }
    }

    if ( iLastBox == IDD_BUILTRES ) {
        lstrcpyA( gProj.szBld, szNewFile);
    }

    if ( ! fEditing && (iLastBox == IDD_MPJ || iLastBox == IDD_BUILTRES) ) {
        // Suggest a name for the project token file

        GetDlgItemTextA( hDlg, IDD_TOK, szOldFileName, MAXFILENAME);

        if ( szOldFileName[0] == '\0' || szOldFileName[0] == '.' ) {
            _splitpath( gProj.szPRJ, szDrive, szDir, szName, szExt);
            sprintf( gProj.szTok, "%s%s%s.%s", szDrive, szDir, szName, "TOK");
            SetDlgItemTextA( hDlg, IDD_TOK, gProj.szTok);
        }

        // Suggest a name for the glossary file

        GetDlgItemTextA( hDlg, IDD_GLOSS, szOldFileName, MAXFILENAME);

        if ( szOldFileName[0] == '\0' || szOldFileName[0] == '.' ) {
            _splitpath( gProj.szPRJ, szDrive, szDir, szName, szExt);
            sprintf( gProj.szGlo, "%s%s%s.%s", szDrive, szDir, szName, "TXT");
            SetDlgItemTextA( hDlg, IDD_GLOSS, gProj.szGlo);
        }
    }

    if ( iLastBox == IDD_TOK ) {
        lstrcpyA( gProj.szTok, szNewFile);
    }

    if ( iLastBox == IDD_GLOSS ) {
        lstrcpyA( gProj.szGlo, szNewFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rledit\rledit.h ===
#ifndef _RLEDIT_H_
#define _RLEDIT_H_

#include "rlstrngs.h"
#include "resourc2.h"

void cwCenter(HWND, int);

INT_PTR     APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY GENERATEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY EXECUTEDLGEDITMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR FAR PASCAL StatusWndProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY EXECUTERCWMsgProc( HWND, UINT, WPARAM, LPARAM );
INT_PTR APIENTRY TOKENIZEMsgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY TRANSLATEMsgProc( HWND, UINT, WPARAM, LPARAM );

#define MAXFILENAME     256         /* maximum length of file pathname      */
#define MAXCUSTFILTER   40          /* maximum size of custom filter buffer */
#define CCHNPMAX        65535       /* max number of bytes in a notepad file */

void        cwCenter(HWND, int);
void        CwUnRegisterClasses(void);
INT_PTR     DoMenuCommand    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR     DoListBoxCommand ( HWND, UINT, WPARAM, LPARAM );
TCHAR  FAR *FindDeltaToken( TOKEN , TOKENDELTAINFO FAR * , UINT );
LONG        GetGlossaryIndex( FILE *, TCHAR, long [30] );
BOOL        InitApplication(HINSTANCE);
BOOL        InitInstance(HINSTANCE, int);
void        FindAllDirtyTokens( void );
int         nCwRegisterClasses(void);
BOOL        SaveTokList( HWND, FILE * );
void        SetNewBuffer(HWND, HANDLE, PSTR);
FILE       *UpdateFile( HWND, FILE *, FILE *, BOOL, TCHAR *, TCHAR *, TCHAR *, TCHAR * );
int         MyGetTempFileName( BYTE   hDriveLetter,
                               LPSTR  lpszPrefixString,
                               WORD   wUnique,
                               LPSTR  lpszTempFileName);

#ifdef RLWIN32
INT_PTR CALLBACK TokEditDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ViewDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#else
BOOL APIENTRY TokEditDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam );
BOOL APIENTRY TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, UINT wParam, LONG lParam);
BOOL APIENTRY NewDlgProc( HWND hDlg, UINT wMsg, UINT wParam, LONG lParam );
BOOL APIENTRY ViewDlgProc( HWND hDlg, UINT wMsg, UINT wParam, LONG lParam );
BOOL APIENTRY About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
#endif // RLWIN32

#endif // _RLEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlman\help.h ===
//...........................................................
//...
//... Header file for command-line RLMAN's help file
//...........................................................


#define IDM_HELPUSAGE       901
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlman\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by RLMAN.RC
//
#define IDS_SELECTMSTRLANG              3101
#define IDS_SELECTPROJLANG              3102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlquiked\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by rlquiked.rc
//
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlman\rlman.h ===
//... RLMAN.H

#define SUCCESS 0

#define IDM_HELPUSAGE 901

//... MSG ID #'s for usage message lines

#define IDS_USG_00  256
#define IDS_USG_01  IDS_USG_00 + 1
#define IDS_USG_02  IDS_USG_00 + 2
#define IDS_USG_03  IDS_USG_00 + 3
#define IDS_USG_04  IDS_USG_00 + 4
#define IDS_USG_05  IDS_USG_00 + 5
#define IDS_USG_06  IDS_USG_00 + 6
#define IDS_USG_07  IDS_USG_00 + 7
#define IDS_USG_08  IDS_USG_00 + 8
#define IDS_USG_09  IDS_USG_00 + 9
#define IDS_USG_10  IDS_USG_00 + 10
#define IDS_USG_11  IDS_USG_00 + 11
#define IDS_USG_12  IDS_USG_00 + 12
#define IDS_USG_13  IDS_USG_00 + 13
#define IDS_USG_14  IDS_USG_00 + 14
#define IDS_USG_15  IDS_USG_00 + 15
#define IDS_USG_16  IDS_USG_00 + 16
#define IDS_USG_17  IDS_USG_00 + 17
#define IDS_USG_18  IDS_USG_00 + 18
#define IDS_USG_19  IDS_USG_00 + 19
#define IDS_USG_20  IDS_USG_00 + 20
#define IDS_USG_21  IDS_USG_00 + 21
#define IDS_USG_22  IDS_USG_00 + 22
#define IDS_USG_23  IDS_USG_00 + 23
#define IDS_USG_24  IDS_USG_00 + 24
#define IDS_USG_25  IDS_USG_00 + 25
#define IDS_USG_26  IDS_USG_00 + 26
#define IDS_USG_27  IDS_USG_00 + 27
#define IDS_USG_END IDS_USG_27 + 1 //... Must be 1 greater than last IDS_USG_nn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlquiked\rlquiked.c ===
#include <windows.h>

#ifdef RLWIN16
//#include <toolhelp.h>
#endif
#ifdef RLWIN32
#include <windowsx.h>
#endif

#include <shellapi.h>
#include <commdlg.h>

// CRT includes
#include <stdio.h>
#include <stdlib.h>

// RL TOOLS SET includes
#include "windefs.h"
#include "toklist.h"
#include "RESTOK.H"
#include "RLQuikEd.H"
#include "custres.h"
#include "exe2res.h"
#include "exeNTres.h"
#include "commbase.h"
#include "wincomon.h"
#include "resread.h"
#include "projdata.h"
#include "showerrs.h"
#include "rlmsgtbl.h"

#ifdef WIN32
    HINSTANCE   hInst;      /* Instance of the main window  */
#else
    HWND        hInst;          /* Instance of the main window  */
#endif

HWND hMainWnd = NULL;        // handle to main window
HWND hListWnd = NULL;        // handle to tok list window
HWND hStatusWnd = NULL;      // handle to status windows
int  nUpdateMode    = 0;     // needed in rlcommon.lib
BOOL fCodePageGiven = FALSE; //... Set to TRUE if -p arg given
CHAR szAppName[50] = "";
CHAR szFileTitle[14] = "";   // holds base name of latest opened file
CHAR szCustFilterSpec[MAXCUSTFILTER]="";    // custom filter buffer

extern UCHAR szDHW[];     //... used in debug strings



#ifndef RLWIN32
static BOOL PASCAL _loadds  WatchTask( WORD wID,DWORD dwData);
static FARPROC lpfnWatchTask = NULL;
#endif

static int     ExecResEditor( HWND , CHAR *, CHAR *, CHAR *);
static void    DrawLBItem( LPDRAWITEMSTRUCT lpdis);
static void    CleanDeltaList( void);
static void    MakeStatusLine( TOKEN *pTok);
static TOKENDELTAINFO FAR *
               InsertQuikTokList( FILE * fpTokFile);

// File IO vars

static CHAR    szFilterSpec        [180] = "";
static CHAR    szResFilterSpec     [60] = "";
static CHAR    szExeFilterSpec     [60] = "";
static CHAR    szDllFilterSpec     [60] = "";
static CHAR    szCplFilterSpec     [60] = "";
static CHAR    szGlossFilterSpec   [60] = "";
static CHAR    szFileName[MAXFILENAME] = "";    // holds full name of latest opened file

static TCHAR   szString[256] = TEXT("");        // variable to load resource strings
static TCHAR   tszAppName[100] = TEXT("");
static CHAR    szEditor[MAXFILENAME] = "";

static BOOL    gbNewProject  = FALSE;      // indicates whether to prompt for auto translate
static BOOL    fTokChanges   = FALSE;      // set to true when toke file is out of date
static BOOL    fTokFile      = FALSE;
static BOOL    fPrjChanges   = FALSE;
static BOOL    fMPJOutOfDate = FALSE;
static BOOL    fPRJOutOfDate = FALSE;

static CHAR    szOpenDlgTitle[80] = "";    // title of File open dialog
static CHAR    szSaveDlgTitle[80] = "";    // title of File saveas dialog
static TCHAR   *szClassName   = TEXT("RLQuikEdClass");
static TCHAR   *szStatusClass = TEXT("RLQuikEdStatus");

static TOKENDELTAINFO FAR *
               pTokenDeltaInfo;        // linked list of token deta info
static LONG    lFilePointer[30]= { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
                            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
static TRANSLIST *pTransList =(TRANSLIST *) NULL;      // circular doubly linked list of translations

// Window vars
static BOOL    fWatchEditor;
static CHAR    szTempRes[MAXFILENAME] = "";    // the temporary file created by the resource editor
static CHAR    szTRes[MAXFILENAME] = "";

    // set true if a resource editer has been launched

static HCURSOR hHourGlass;    /* handle to hourglass cursor     */
static HCURSOR hSaveCursor;    /* current cursor handle        */
static HACCEL  hAccTable;
static RECT    Rect;           /* dimension of the client window    */
static int     cyChildHeight;  /* height of status windows */

static TCHAR   szSearchType[80] = TEXT("");
static TCHAR   szSearchText[512] = TEXT("");
static WORD    wSearchStatus = 0;
static WORD    wSearchStatusMask = 0;
static BOOL    fSearchDirection;
static BOOL    fSearchStarted = FALSE;


// NOTIMPLEMENTED is a macro that displays a "Not implemented" dialog
#define NOTIMPLEMENTED {TCHAR sz[80];\
            LoadString(hInst,IDS_NOT_IMPLEMENTED,sz,TCHARSIN(sizeof(sz)));\
            MessageBox(hMainWnd,sz,tszAppName,MB_ICONEXCLAMATION|MB_OK);}

// Edit Tok Dialog

#ifndef RLWIN32
  static FARPROC lpTokEditDlg;
#endif

static HWND hTokEditDlgWnd = NULL;

extern MSTRDATA gMstr;          //... Data from Master Project file (MPJ)
extern PROJDATA gProj;          //... Data from Project file (PRJ)

extern BOOL  gfReplace;         //... FALSE if appending new language to existing resources
extern BOOL  fInQuikEd;         //... Are we in the rlquiked?
extern BOOL  fInThirdPartyEditer;//.. Are we in a 3rd-party resource editor?
extern BOOL		bRLGui;

// Global Variables:
static CHAR * gszHelpFile = "RLTools.hlp";


/**
  *
  *
  *  Function: InitApplication
  *    Regsiters the main window, which is a list box composed of tokens
  *    read from the token file. Also register the status window.
  *
  *
  *  Arguments:
  *    hInstance, instance handle of program in memory.
  *
  *  Returns:
  *
  *  Errors Codes:
  *    TRUE, windows registered correctly.
  *    FALSE, error during register of one of the windows.
  *
  *  History:
  *    9/91, Implemented.      TerryRu
  *
  *
  **/

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    CHAR sz[60] = "";
    CHAR sztFilterSpec[120] = "";

    LoadStrIntoAnsiBuf(hInstance, IDS_RESSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szResFilterSpec, sz, "*.RES");

    LoadStrIntoAnsiBuf(hInstance, IDS_EXESPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szExeFilterSpec, sz, "*.EXE");

    LoadStrIntoAnsiBuf(hInstance, IDS_DLLSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szDllFilterSpec, sz, "*.DLL");

    LoadStrIntoAnsiBuf(hInstance, IDS_CPLSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szCplFilterSpec, sz, "*.CPL");

    CatSzFilterSpecs(szFilterSpec,  szExeFilterSpec, szDllFilterSpec);
    CatSzFilterSpecs(sztFilterSpec, szFilterSpec,    szCplFilterSpec);
    CatSzFilterSpecs(szFilterSpec,  sztFilterSpec,   szResFilterSpec);

    LoadStrIntoAnsiBuf(hInstance, IDS_GLOSSSPEC, sz, sizeof(sz));
    szFilterSpecFromSz1Sz2(szGlossFilterSpec, sz, "*.TXT");

    LoadStrIntoAnsiBuf(hInstance,
                       IDS_OPENTITLE,
                       szOpenDlgTitle,
                       sizeof(szOpenDlgTitle));
    LoadStrIntoAnsiBuf(hInstance,
                       IDS_SAVETITLE,
                       szSaveDlgTitle,
                       sizeof(szSaveDlgTitle));

    wc.style            = 0;
    wc.lpfnWndProc      = StatusWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = szStatusClass;

    if (! RegisterClass((CONST WNDCLASS *)&wc))
    {
        return (FALSE);
    }

    wc.style            = 0;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = hInstance;
    wc.hIcon            = LoadIcon(hInstance,TEXT("RLQuikEdIcon"));
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName     = TEXT("RLQuikEd");
    wc.lpszClassName    = szClassName;

    if (!RegisterClass((CONST WNDCLASS *)&wc))
    {
        return (FALSE);
    }

    // Windows register return sucessfully
    return (TRUE);
}



/**
  *
  *
  *  Function: InitInstance
  *   Creates the main, and status windows for the program.
  *   The status window is sized according to the main window
  *   size.  InitInstance also loads the acclerator table, and prepares
  *   the global openfilename structure for later use.
  *
  *
  *  Errors Codes:
  *   TRUE, windows created correctly.
  *   FALSE, error on create windows calls.
  *
  *  History:
  *   9/11, Implemented       TerryRu
  *
  *
  **/

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    RECT    Rect;

    hAccTable = LoadAccelerators(hInst, TEXT("RLQuikEd"));

    hMainWnd = CreateWindow(szClassName,
                            tszAppName,
                            WS_OVERLAPPEDWINDOW,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            (HWND) NULL,
                            (HMENU) NULL,
                            hInstance,
                            (LPVOID) NULL);

    if (!hMainWnd)
    {
        return( FALSE);
    }

    DragAcceptFiles(hMainWnd, TRUE);

    GetClientRect(hMainWnd, (LPRECT) &Rect);

    // Create a child list box window

    hListWnd = CreateWindow(TEXT("LISTBOX"),
                            NULL,
                            WS_CHILD |
                            LBS_WANTKEYBOARDINPUT |
                            LBS_NOTIFY | LBS_NOINTEGRALHEIGHT |
                            LBS_OWNERDRAWFIXED |
                            WS_VSCROLL | WS_HSCROLL | WS_BORDER ,
                            0,
                            0,
                            (Rect.right-Rect.left),
                            (Rect.bottom-Rect.top),
                            (HWND) hMainWnd,
                            (HMENU)IDC_LIST, // Child control i.d.
                            hInstance,
                            (LPVOID)NULL);

    if ( ! hListWnd )
    {
                                // clean up after error.

        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    // Creat a child status window

    hStatusWnd = CreateWindow(szStatusClass,
                              NULL,
                              WS_CHILD | WS_BORDER | WS_VISIBLE,
                              0,
                              0,
                              0,
                              0,
                              hMainWnd,
                              NULL,
                              hInstance,
                              (LPVOID)NULL);

    if ( ! hStatusWnd )
    {
                                // clean up after error.

        DeleteObject((HGDIOBJ)hListWnd);
        DeleteObject((HGDIOBJ)hMainWnd);
        return( FALSE);
    }

    hHourGlass = LoadCursor(NULL, IDC_WAIT);

    ShowWindow(hMainWnd, nCmdShow);
    UpdateWindow(hMainWnd);
    return( TRUE);
}

/**
  *
  *
  *  Function: WinMain
  *     Calls the intialization functions, to register, and create the
  *     application windows. Once the windows are created, the program
  *     enters the GetMessage loop.
  *
  *
  *  Arguements:
  *     hInstace, handle for this instance
  *     hPrevInstanc, handle for possible previous instances
  *     lpszCmdLine, LONG pointer to exec command line.
  *     nCmdShow,  code for main window display.
  *
  *
  *  Errors Codes:
  *     IDS_ERR_REGISTER_CLASS, error on windows register
  *     IDS_ERR_CREATE_WINDOW, error on create windows
  *         otherwise, status of last command.
  *
  *  History:
  *
  *
  **/

#ifdef RLWIN32

INT WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpszCmdLine,
                   int       nCmdShow)

#else

int PASCAL WinMain(HANDLE hInstance,
                   HANDLE hPrevInstance,
                   LPSTR  lpszCmdLine,
                   int    nCmdShow)

#endif
{
    MSG     msg;
    HWND    FirstWnd, FirstChildWnd;


	bRLGui = TRUE;

    if (FirstWnd = FindWindow(szClassName,NULL))
    {
        // checking for previous instance
        FirstChildWnd = GetLastActivePopup(FirstWnd);
        BringWindowToTop(FirstWnd);
        ShowWindow(FirstWnd,SW_SHOWNORMAL);

        if (FirstWnd != FirstChildWnd)
        {
            BringWindowToTop(FirstChildWnd);
        }

        return(FALSE);
    }
    fInQuikEd = TRUE;
    hInst = hInstance;

    gProj.wLanguageID = LANGIDFROMLCID( GetThreadLocale());

    GetModuleFileNameA( hInst, szDHW, DHWSIZE);
    GetInternalName( szDHW, szAppName, sizeof( szAppName));
    szFileName[0] = '\0';
    lFilePointer[0] = (LONG)-1;

#ifdef UNICODE
    _MBSTOWCS( tszAppName,
               szAppName,
               WCHARSIN( sizeof( tszAppName)),
               ACHARSIN( strlen( szAppName) + 1));
#else
    strcpy( tszAppName, szAppName);
#endif

    // register window classes if first instance of application
    if ( ! hPrevInstance )
    {
        if ( ! InitApplication( hInstance) )
        {
            /* Registering one of the windows failed      */
            LoadString( hInst,
                        IDS_ERR_REGISTER_CLASS,
                        szString,
                        TCHARSIN( sizeof( szString)));
            MessageBox(NULL, szString, tszAppName, MB_ICONEXCLAMATION);
            return( IDS_ERR_REGISTER_CLASS);
        }
    }

    // Create windows for this instance of application
    if ( ! InitInstance( hInstance, nCmdShow) )
    {
        LoadString( hInst,
                    IDS_ERR_CREATE_WINDOW,
                    szString,
                    TCHARSIN( sizeof( szString)));
        MessageBox( NULL, szString, tszAppName, MB_ICONEXCLAMATION);
        return( IDS_ERR_CREATE_WINDOW);
    }

    // Main Message Loop

    while ( GetMessage( &msg, NULL, 0, 0) )
    {
        if ( hTokEditDlgWnd )
        {
            if ( IsDialogMessage( hTokEditDlgWnd, &msg) )
            {
                continue;
            }
        }

        if( TranslateAccelerator( hMainWnd, hAccTable, &msg) )
        {
            continue;
        }
        TranslateMessage( &msg);
        DispatchMessage ( &msg);
    }
    return( (INT)msg.wParam);
}

/**
  *  Function: MainWndProc
  *     Process the windows messages for the main window of the application.
  *     All user inputs go through this window procedure.
  *     See cases in the switch table for a description of each message type.
  *
  *
  *  Arguments:
  *
  *  Returns:
  *
  *  Errors Codes:
  *
  *  History:
  *
  **/

INT_PTR APIENTRY MainWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    FILE *f = NULL;
    WORD rc = 0;

    // if its a list box message process it in  DoListBoxCommand

    if ( fInThirdPartyEditer )  //... only process messages sent by the editor
    {
        switch (wMsg)
        {
        case WM_EDITER_CLOSED:
            {
                CHAR   szDlgToks[ MAXFILENAME] = "";
                static WORD wSavedIndex;
#ifdef RLWIN16
                NotifyUnRegister( NULL);
                FreeProcInstance( lpfnWatchTask);
#endif
                ShowWindow( hWnd, SW_SHOW);
                {
                    TCHAR tsz[80] = TEXT("");
                    LoadString( hInst,
                                IDS_REBUILD_TOKENS,
                                tsz,
                                TCHARSIN( sizeof( tsz)));

                    if ( MessageBox( hWnd,
                                     tsz,
                                     tszAppName,
                                     MB_ICONQUESTION | MB_YESNO) == IDYES)
                    {
                        HCURSOR hOldCursor;
                        BOOL bChanged;

                        hOldCursor = SetCursor( hHourGlass);

                        // szTempRes returned from resource editor, contains only dialogs
                        // need to merge it back into the main token file

                        MyGetTempFileName( 0, "TOK", 0, szDlgToks);
                        rc = (WORD)GenerateTokFile( szDlgToks,
                                              szTempRes,
                                              &bChanged,
                                              0);
                        InsDlgToks( gProj.szTok,
                                    szDlgToks,
                                    ID_RT_DIALOG);
                        remove( szDlgToks);

                        if ( rc )
                        {
                            QuitT( IDS_TOKGENERR, (LPTSTR)rc, NULL);
                            return FALSE;
                        }


                        // gProj.szTok, now contains the latest tokens
                        SetCursor( hOldCursor);

			//Rlqked10 doesn't save when changed tokens by DialogEditor.
			fTokChanges = TRUE;
                    }
                }
                fInThirdPartyEditer = FALSE;

                remove( szTempRes);
                // delete all temp files with the same root in case
                // the editor created additional files like DLGs and RCs.
                // \(DLGEDIT does this.\)
                // For now I'm just going to tack a .DLG at the end of the file name
                // and delete it.
                {
                    int i;
                    for (i = strlen(szTempRes);i > 0 && szTempRes[i]!='.';i--);

                    if (szTempRes[i] == '.')
                    {
                        szTempRes[++i]='D';
                        szTempRes[++i]='L';
                        szTempRes[++i]='G';
                        szTempRes[++i]=0;
                        remove(szTempRes);
                    }
                }
                wSavedIndex = (UINT)SendMessage( hListWnd,
                                                 LB_GETCURSEL,
                                                 (WPARAM)0,
                                                 (LPARAM)0);
                SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             (WPARAM)wSavedIndex,
                             (LPARAM)0);
            }
            return (DefWindowProc(hWnd, wMsg, wParam, lParam));
        }
    }


    // Not a thrid party edit command.


    // is it a list dox command ??
    DoListBoxCommand (hWnd, wMsg, wParam, lParam);


    switch (wMsg)
    {
    case WM_COMMAND:

        if (DoMenuCommand(hWnd, wMsg, wParam, lParam))
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }

        break;

    case WM_CLOSE:
        {
            char sz[128] = "";
            int rc ;

            LoadStrIntoAnsiBuf( hInst, IDS_SAVECHANGES, sz, sizeof( sz));

            if ( fPrjChanges || fTokChanges )
            {
                rc = MessageBoxA( hWnd,
                                  sz,
                                  szAppName,
                                  MB_ICONQUESTION | MB_YESNOCANCEL);
            }
            else
            {
                rc = IDNO;
            }

            if ( rc == IDYES )
            {
                if ( ! SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0))
                {
                    return FALSE;
                }
            }

            if (rc == IDCANCEL)
            {
                return(FALSE);
            }

            if (gProj.szTok[0])
            {
                remove(gProj.szTok);
                gProj.szTok[0] = 0;
            }

            if (hMainWnd)
            {
                DestroyWindow(hMainWnd);
            }

            if (hListWnd)
            {
                DestroyWindow(hListWnd);
            }

            if (hStatusWnd)
            {
                DestroyWindow(hStatusWnd);
            }
            _fcloseall();
            FreeLangList();

#ifdef _DEBUG
            {
                FILE *pLeakList = fopen( "C:\\LEAKLIST.TXT", "wt");
                FreeMemList( pLeakList);
                fclose( pLeakList);
            }
#endif // _DEBUG

            return FALSE;
            break;
        }

    case WM_CREATE:
        {
            HDC hdc;
            int cyBorder;
            TEXTMETRIC tm;

            hdc  = GetDC(hWnd);
            GetTextMetrics(hdc, &tm);
            ReleaseDC(hWnd, hdc);

            cyBorder = GetSystemMetrics(SM_CYBORDER);

            cyChildHeight = tm.tmHeight + 6 + cyBorder * 2;

            break;
        }

    case WM_DESTROY:
        WinHelpA(hWnd, gszHelpFile, HELP_QUIT, 0L);
        // remove translation list
        if (pTransList)
        {
            pTransList->pPrev->pNext = NULL; // so we can find the end of the list
        }

        while (pTransList)
        {
            TRANSLIST *pTemp;
            pTemp = pTransList;
            pTransList = pTemp->pNext;
            RLFREE( pTemp->sz);
            RLFREE( pTemp);
        }

        DragAcceptFiles(hMainWnd, FALSE);
        PostQuitMessage(0);
        break;

    case WM_INITMENU:
        // Enable or Disable the Paste menu item
        // based on available Clipboard Text data
        if (wParam == (WPARAM) GetMenu(hMainWnd))
        {
            if (OpenClipboard(hWnd))
            {

#if defined(UNICODE)
                if ((IsClipboardFormatAvailable(CF_UNICODETEXT) ||
                     IsClipboardFormatAvailable(CF_OEMTEXT)) && fTokFile)
#else // not UNICODE
                if ( (IsClipboardFormatAvailable(CF_TEXT)
                   || IsClipboardFormatAvailable(CF_OEMTEXT))
                  && fTokFile )
#endif // UNICODE

                {
                    EnableMenuItem( (HMENU)wParam, IDM_E_PASTE, MF_ENABLED);
                }
                else
                {
                    EnableMenuItem( (HMENU)wParam, IDM_E_PASTE, MF_GRAYED);
                }
                CloseClipboard();
                return (TRUE);
            }
        }
        break;

    case WM_SETFOCUS:
        SetFocus (hListWnd);
        break;

    case WM_DRAWITEM:
        DrawLBItem((LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_DELETEITEM:
        {
            GlobalFree( (HGLOBAL)((LPDELETEITEMSTRUCT)lParam)->itemData);
            break;
        }

    case WM_SIZE:
        {
            int cxWidth;
            int cyHeight;
            int xChild;
            int yChild;

            cxWidth  = LOWORD(lParam);
            cyHeight = HIWORD(lParam);

            xChild = 0;
            yChild = cyHeight - cyChildHeight + 1;

            MoveWindow(hListWnd, 0, 0, cxWidth, yChild , TRUE);
            MoveWindow(hStatusWnd, xChild, yChild, cxWidth, cyChildHeight, TRUE);
            break;
        }

    case WM_LOADPROJECT:
        {
            HCURSOR hOldCursor = NULL;
            BOOL    bChanged   = FALSE;
            BOOL    fRC        = TRUE;

            hOldCursor = SetCursor( hHourGlass);

            if ( gProj.szTok[0] )
            {
                remove( gProj.szTok);
            }

#ifdef RLRES32
                                //... Get project lanuages

            fRC = DialogBox( hInst,
                             MAKEINTRESOURCE( IDD_LANGUAGES),
                             hMainWnd,
                             GetLangIDsProc) ? TRUE : FALSE;
#endif

            if ( fRC )
            {
                strcpy( gProj.szBld, gMstr.szSrc);

                rc = (WORD)GenerateTokFile( gProj.szTok,
                                      gMstr.szSrc,
                                      &fTokChanges,
                                      0);
                SetCursor( hOldCursor);

                if (rc)
                {
                    QuitT( IDS_TOKGENERR, (LPTSTR)rc, NULL);
                }

                if ( ( ! fTokChanges) && (gProj.wLanguageID != gMstr.wLanguageID) )
                {
                    fTokChanges = TRUE;
                }
                fPrjChanges   = FALSE;
                fPRJOutOfDate = FALSE;

                SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            }
            else
            {
                SetWindowText( hMainWnd, tszAppName);
                SetCursor( hOldCursor);
            }
            break;
        }

    case WM_LOADTOKENS:
        {
            HMENU hMenu;

            // Remove the current token list
            SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
            CleanDeltaList();

            // Hide token list, while we add new tokens
            ShowWindow(hListWnd, SW_HIDE);

            if (f = FOPEN(gProj.szTok, "rt"))
            {
                int i;
                HCURSOR hOldCursor;

                hOldCursor = SetCursor(hHourGlass);

                // Insert tokens from token file into the list box
                pTokenDeltaInfo = InsertQuikTokList(f);
                FCLOSE( f);

                // Make list box visible
                ShowWindow( hListWnd, SW_SHOW);

                if ( SendMessage( hListWnd,
                                  LB_GETCOUNT,
                                  (WPARAM)0,
                                  (LPARAM)0) > 0 )
                {
                    hMenu = GetMenu(hWnd);
                    EnableMenuItem(hMenu, IDM_P_SAVE,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_SAVEAS,   MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_P_CLOSE,    MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FIND,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDUP,   MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_FINDDOWN, MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_COPY,     MF_ENABLED|MF_BYCOMMAND);
                    EnableMenuItem(hMenu, IDM_E_PASTE,    MF_ENABLED|MF_BYCOMMAND);

                    for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++)
                    {
                        EnableMenuItem(hMenu,i,MF_ENABLED|MF_BYCOMMAND);
                    }

                    fTokFile    = TRUE;
                    fTokChanges = (gProj.wLanguageID != gMstr.wLanguageID);

                    SetCursor(hOldCursor);
                }
                else
                {
                    SetCursor(hOldCursor);
                    fTokChanges = FALSE;
                    MessageBox( hListWnd,
                                TEXT("No tokens matching given criteria found"),
                                tszAppName,
                                MB_ICONINFORMATION|MB_OK);
                }
            }
        }
        break;

    case WM_SAVEPROJECT:
        {
            _fcloseall();

            if ( SendMessage( hWnd, WM_SAVETOKENS, (WPARAM)0, (LPARAM)0) )
            {
                if (fPrjChanges)
                {
                    HCURSOR hOldCursor = NULL;
                    CHAR  sz[100] = "";
                    WORD  rc;

                    if ( gProj.szBld[0] == '\0' )
                    {
                        if(gProj.fSourceEXE)
                        {
                            rc = (WORD)GetFileNameFromBrowse( hWnd,
                                                        szFileName,
                                                        MAXFILENAME,
                                                        szSaveDlgTitle,
                                                        szFilterSpec,
                                                        "EXE");
                        }
                        else
                        {
                            rc = (WORD)GetFileNameFromBrowse( hWnd,
                                                        szFileName,
                                                        MAXFILENAME,
                                                        szSaveDlgTitle,
                                                        szResFilterSpec,
                                                        "RES");
                        }

                        if (rc)
                        {
                            strcpy( gProj.szBld, szFileName);
                        }
                        else
                        {
                            return( FALSE); // user cancelled
                        }
                    }

                    hOldCursor = SetCursor(hHourGlass);

                    rc = (WORD)GenerateImageFile(gProj.szBld,
                                           gMstr.szSrc,
                                           gProj.szTok,
                                           gMstr.szRdfs,
                                           0);

                    SetCursor(hOldCursor);

                    switch(rc)
                    {
                    case 1:
                        gProj.fTargetEXE = IsExe( gProj.szBld);
                        gProj.fSourceEXE = IsExe( gMstr.szSrc);
                        fPrjChanges = FALSE;
                        sprintf( sz, "%s - %s", szAppName, gProj.szBld);
                        SetWindowTextA(hWnd,sz);
                        break;

                    case (WORD)-1:
                        lstrcpyA( gProj.szBld, gMstr.szSrc);
                        LoadStrIntoAnsiBuf(hInst, IDS_RLQ_CANTSAVEASRES, sz, sizeof(sz));
                        MessageBoxA( NULL, sz, gProj.szBld, MB_ICONHAND|MB_OK);
                        break;

                    case (WORD)-2:
                        lstrcpyA( gProj.szBld, gMstr.szSrc);
                        LoadStrIntoAnsiBuf(hInst, IDS_RLQ_CANTSAVEASEXE, sz, sizeof(sz));
                        MessageBoxA( NULL, sz, gProj.szBld,MB_ICONHAND|MB_OK);
                        break;
                    }
                    return(TRUE);
                }
                // no project changes to save
            }
            return TRUE;
        }
        break;

    case WM_SAVETOKENS:

        if ( fTokChanges )
        {
            if (f = FOPEN(gProj.szTok, "wt"))
            {
                SaveTokList(hWnd, f);
                FCLOSE(f);
                fTokChanges = FALSE;
                fPrjChanges = TRUE;
            }
            else
            {
                LoadStrIntoAnsiBuf( hInst, IDS_FILESAVEERR, szDHW, DHWSIZE);
                MessageBoxA( hWnd,
                             szDHW,
                             gProj.szTok,
                             MB_ICONHAND | MB_OK);
                return FALSE;
            }
        }
        return TRUE;                    // everything saved ok

    case WM_DROPFILES:
        {
            CHAR sz[MAXFILENAME] = "";

#ifndef CAIRO
            DragQueryFileA((HDROP) wParam, 0, sz, MAXFILENAME);
#else
            DragQueryFile((HDROP) wParam, 0, sz, MAXFILENAME);
#endif
            LoadNewFile(sz);
            DragFinish((HDROP) wParam);
            return(TRUE);
        }

    default:
        break;
    }

    return (DefWindowProc(hWnd, wMsg, wParam, lParam));
}

/**
  *  Function: DoListBoxCommand
  *     Processes the messages sent to the list box. If the message is
  *     not reconized as a list box message, it is ignored and not processed.
  *     As the user scrolls through the tokens WM_UPDSTATLINE messages are
  *     sent to the status window to indicate the current selected token.
  *     The list box goes into Edit Mode by  pressing the enter key, or
  *     by double clicking on the list box.  After the edit is done, a WM_TOKEDIT
  *     message is sent back to the list box to update the token. The
  *     list box uses control ID IDC_LIST.
  *
  *  Arguments:
  *     wMsg    List Box message ID
  *     wParam  Either IDC_LIST, or VK_RETURN depending on wMsg
  *     lParam  LPTSTR to selected token during WM_TOKEDIT message.
  *
  *  Returns:
  *
  *  Errors Codes:
  *     TRUE.  Message processed.
  *     FALSE. Message not processed.
  *
  *  History:
  *     01/92 Implemented.      TerryRu.
  *     01/92 Fixed problem with DblClick, and Enter processing.    TerryRu.
  *
  **/

INT_PTR DoListBoxCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TOKEN   tok;                        // structure to hold token read from token list
    LPTSTR  lpstrBuffer;
    CHAR    szTmpBuf[32] = "";
    TCHAR   szName[32] = TEXT("");      // buffer to hold token name
    TCHAR   szID[7] = TEXT("");         // buffer to hold token id
    TCHAR   sz[256] = TEXT("");         // buffer to hold messages
    static  UINT wIndex;
    LONG    lListParam = 0L;

    // this is the WM_COMMAND

    switch (wMsg)
    {
    case WM_TRANSLATE:
        {
            // Message sent by TokEditDlgProc to build a translation list
            HWND hDlgItem = NULL;
            int cTextLen  = 0;
            TCHAR *szKey  = NULL;
            TCHAR *szText = NULL;

            hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKPREVTRANS);
            cTextLen = GetWindowTextLength( hDlgItem);
            szKey    = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
            szKey[0] = TEXT('\0');
            GetDlgItemText( hTokEditDlgWnd,
                            IDD_TOKPREVTRANS,
                            szKey,
                            cTextLen+1);

            hDlgItem = GetDlgItem( hTokEditDlgWnd, IDD_TOKCURTRANS);
            cTextLen = GetWindowTextLength( hDlgItem);
            szText = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
            szText[0] = TEXT('\0');
            GetDlgItemText( hTokEditDlgWnd,
                            IDD_TOKCURTRANS,
                            szText,
                            cTextLen + 1);

            TransString( szKey, szText, &pTransList, lFilePointer);
            RLFREE( szKey);
            RLFREE( szText);
            return TRUE;
        }

    case WM_TOKEDIT:
        {
            TCHAR *szBuffer = NULL;
            int    cTextLen = 0;
            // Message sent by TokEditDlgProc to
            // indicate change in the token text.
            // Response to the message by inserting
            // new token text into list box

            // Insert the selected token into token struct

            HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)wIndex,
                                                 (LPARAM)0);
            lpstrBuffer = (LPTSTR)GlobalLock( hMem);

            if ( ! lpstrBuffer )
            {
                QuitA( IDS_ENGERR_11, NULL, NULL);
            }

            cTextLen = lstrlen( lpstrBuffer);
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( cTextLen + 1));
            lstrcpy( szBuffer, lpstrBuffer);
            GlobalUnlock( hMem);
            ParseBufToTok( szBuffer, &tok);
            RLFREE( szBuffer);
            RLFREE( tok.szText);

            // Copy new token text from edit box into the token struct
            cTextLen = lstrlen( (LPTSTR)lParam);
            tok.szText = (LPTSTR)FALLOC( MEMSIZE( cTextLen + 1));
            lstrcpy( tok.szText, (LPTSTR)lParam);
            RLFREE( (void *)lParam);

            // Mark token as clean

#ifdef  RLWIN32
            tok.wReserved = (WORD) ST_TRANSLATED;
#else
            tok.wReserved = ST_TRANSLATED;
#endif
            szBuffer = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok) + 1));
            ParseTokToBuf( szBuffer, &tok);
            RLFREE( tok.szText);

            // Now remove old token
            SendMessage( hListWnd, WM_SETREDRAW,    (WPARAM)FALSE,  (LPARAM)0);
            SendMessage( hListWnd, LB_DELETESTRING, (WPARAM)wIndex, (LPARAM)0);

            // Replacing with the new token
            hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( lstrlen( szBuffer) + 1));
            lpstrBuffer = (LPTSTR)GlobalLock( hMem);
            lstrcpy( lpstrBuffer, szBuffer);
            GlobalUnlock( hMem);
            RLFREE( szBuffer);

            SendMessage( hListWnd,
                         LB_INSERTSTRING,
                         (WPARAM)wIndex,
                         (LPARAM)hMem);

            // Now put focus back on the current string
            SendMessage( hListWnd, LB_SETCURSEL, (LPARAM)wIndex, (LPARAM)0);
            SendMessage( hListWnd, WM_SETREDRAW, (WPARAM)TRUE,   (LPARAM)0);
            InvalidateRect( hListWnd, NULL, TRUE);

            return TRUE;

        }

    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        {
#ifdef RLWIN16
            LPARAM lListParam = 0;
#endif
            // Messages sent to list box when   keys are depressed.
            // Check for Return key pressed.

            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
            case VK_RETURN:
#ifdef RLWIN16
                lListParam = (LPARAM) MAKELONG( 0, LBN_DBLCLK);
                SendMessage( hMainWnd, WM_COMMAND, (WPARAM)IDC_LIST, lListParam);
#else
                SendMessage( hMainWnd,
                             WM_COMMAND,
                             MAKEWPARAM( IDC_LIST, LBN_DBLCLK),
                             (LPARAM)0);
#endif
                return TRUE;

            default:
                break;
            }
            break;
        }

    case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_LIST:
                {
                    /*
                     *
                     * This is where we process the list box messages.
                     * The TokEditDlgProc is used to
                     * edit the token selected in LBS_DBLCLK message
                     *
                     */
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                    case (UINT) LBN_ERRSPACE:

                        LoadString( hInst,
                                    IDS_ERR_NO_MEMORY,
                                    sz,
                                    TCHARSIN( sizeof( sz)));
                        MessageBox( hWnd,
                                    sz,
                                    tszAppName,
                                    MB_ICONHAND | MB_OK);
                        return TRUE;

                    case LBN_DBLCLK:
                        {
                            LPTSTR CurText = NULL;
                            LPTSTR PreText = NULL;
                            TCHAR szResIDStr[20] = TEXT("");
                            TCHAR *szBuffer;
                            HGLOBAL hMem = NULL;

                            wIndex = (UINT)SendMessage( hListWnd,
                                                        LB_GETCURSEL,
                                                        (WPARAM)0,
                                                        (LPARAM)0);
                            if (wIndex == (UINT) -1)
                            {
                                return TRUE;
                            }

                            // double click, or Return entered, go into token edit mode.
                            if (!hTokEditDlgWnd)
                            {
                                // set up modaless dialog box to edit token
#ifdef RLWIN32
                                hTokEditDlgWnd = CreateDialog (hInst,
                                                               TEXT("RLQuikEd"),
                                                               hWnd,
                                                               TokEditDlgProc);
#else
                                lpTokEditDlg =
                                    (FARPROC) MakeProcInstance(TokEditDlgProc,
                                                               hInst);

                                hTokEditDlgWnd = CreateDialog(hInst,
                                                              TEXT("RLQuikEd"),
                                                              hWnd,
                                                              lpTokEditDlg);
#endif

                            }

                            // Get token info from listbox, and place in token struct
                            hMem = (HGLOBAL)SendMessage( hListWnd,
                                                         LB_GETITEMDATA,
                                                         (WPARAM)wIndex,
                                                         (LPARAM)0);
                            lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                            szBuffer = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrBuffer) +1));
                            lstrcpy(szBuffer, lpstrBuffer);
                            GlobalUnlock( hMem);
                            ParseBufToTok(szBuffer, &tok);
                            RLFREE( szBuffer);

                            // Now get the token name
                            // Its either a string, or ordinal number

                            if ( tok.szName[0] )
                            {
                                lstrcpy( szName, tok.szName);
                            }
                            else
                            {
#ifdef UNICODE
                                _itoa(tok.wName, szTmpBuf, 10);
                                _MBSTOWCS( szName,
                                           szTmpBuf,
                                           WCHARSIN( sizeof( szName)),
                                           ACHARSIN( strlen( szTmpBuf) + 1));
#else
                                _itoa( tok.wName, szName, 10);
#endif
                            }


                            // Now do the ID string
#ifdef UNICODE

                            _itoa( tok.wID, szTmpBuf, 10);
                            _MBSTOWCS( szID,
                                       szTmpBuf,
                                       WCHARSIN( sizeof( szID)),
                                       ACHARSIN( strlen( szTmpBuf) + 1));
#else
                            _itoa( tok.wID, szID, 10);
#endif

                            if ( tok.wType <= 16 || tok.wType == ID_RT_DLGINIT )
                            {
                                LoadString( hInst,
                                            IDS_RESOURCENAMES+tok.wType,
                                            szResIDStr,
                                            TCHARSIN( sizeof( szResIDStr)));
                            }
                            else
                            {
#ifdef UNICODE
                                _itoa(tok.wType, szTmpBuf, 10);
                                _MBSTOWCS( szResIDStr,
                                           szTmpBuf,
                                           WCHARSIN( sizeof( szResIDStr)),
                                           ACHARSIN( strlen( szTmpBuf) + 1));
#else
                                _itoa( tok.wType, szResIDStr, 10);
#endif
                            }
                            // Now insert token info  in TokEdit Dialog Box
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKTYPE,
                                            (LPTSTR) szResIDStr);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKNAME,
                                            (LPTSTR) szName);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKID,
                                            (LPTSTR) szID);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKCURTRANS,
                                            (LPTSTR) tok.szText);
                            SetDlgItemText( hTokEditDlgWnd,
                                            IDD_TOKPREVTRANS,
                                            (LPTSTR) tok.szText);
                            RLFREE( tok.szText);

                            SendMessage( hMainWnd,
                                         WM_TRANSLATE,
                                         (WPARAM)0,
                                         (LPARAM)0);
                            SetActiveWindow(hTokEditDlgWnd);
                            wIndex = (UINT)SendMessage( hListWnd,
                                                        LB_GETCURSEL,
                                                        (WPARAM)0,
                                                        (LPARAM)0);
                            return TRUE;
                        }

                    default:
                        // let these messages fall through,
                        break;
                    }
                }

            default:
                return FALSE;
            }

        }

        break;              // WM_COMMAND Case
    }
    return FALSE;

}

/**
 *  Function: DoMenuCommand.
 *   Processes the Menu Command messages.
 *
 *  Errors Codes:
 *   TRUE. Message processed.
 *   FALSE. Message not processed.
 *
 *  History:
 *   01/92. Implemented.       TerryRu.
 *
 **/

INT_PTR DoMenuCommand(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL fListBox = FALSE;
    CHAR sz[256] = "";
    BOOL    fRC  = TRUE;


    sz[0] = 0;
    // Commands entered from the application menu, or child windows.
    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
    case IDM_P_OPEN:

        if ( GetFileNameFromBrowse( hWnd,
                                    sz,
                                    MAXFILENAME,
                                    szOpenDlgTitle,
                                    szFilterSpec,
                                    ".EXE") )
        {
            LoadNewFile( sz);
            strcpy( gProj.szBld, gMstr.szSrc);
        }

        break;

    case IDM_P_SAVE:

        SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0);
        break;

    case IDM_P_SAVEAS:
        {
            CHAR szOldName[MAXFILENAME] = "";

            strcpy( szOldName, gProj.szBld);
            gProj.szBld [0] = 0;    // force user to enter a name
            fPrjChanges = TRUE;     // force project to be saved

            if ( ! SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                // restore the name
                strcpy( gProj.szBld, szOldName);
            }
            break;
        }

    case IDM_P_CLOSE:
        {
            HMENU hMenu;
            hMenu=GetMenu(hWnd);

            if ( SendMessage( hWnd, WM_SAVEPROJECT, (WPARAM)0, (LPARAM)0) )
            {
                int i;
                // Remove file name from window title
                SetWindowText(hMainWnd, tszAppName);

                // Remove the current token list
                SendMessage( hListWnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
                CleanDeltaList();

                // Hide token list since it\'s empty
                ShowWindow(hListWnd, SW_HIDE);

                // Force Repaint of status Window
                InvalidateRect(hStatusWnd, NULL, TRUE);

                EnableMenuItem(hMenu, IDM_P_CLOSE,    MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_P_SAVE,     MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_P_SAVEAS,   MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FIND,     MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDUP,   MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_FINDDOWN, MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_COPY,     MF_GRAYED|MF_BYCOMMAND);
                EnableMenuItem(hMenu, IDM_E_PASTE,    MF_GRAYED|MF_BYCOMMAND);

                for (i = IDM_FIRST_EDIT; i <= IDM_LAST_EDIT;i++)
                {
                    EnableMenuItem(hMenu, i, MF_GRAYED|MF_BYCOMMAND);
                }
            }
            break;
        }

    case IDM_P_EXIT:
        // send wm_close message to main window
        if (hMainWnd)
        {
            PostMessage(hMainWnd, WM_CLOSE, (WPARAM)0, (LPARAM)0); //bugbug??
        }
        return FALSE;
        break;

    case IDM_E_COPY:
        {
            HGLOBAL hStringMem  = NULL;
            LPTSTR  lpstrBuffer = NULL;
            LPTSTR  lpString    = NULL;
            TCHAR  *szString    = NULL;
            int nIndex  = 0;
            int nLength = 0;
            int nActual = 0;
            TOKEN   tok;

            // Is anything selected in the listbox
            if ( (nIndex = (int)SendMessage( hListWnd,
                                             LB_GETCURSEL,
                                             (WPARAM)0,
                                             (LPARAM)0)) != LB_ERR )
            {
                HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                     LB_GETITEMDATA,
                                                     (WPARAM)nIndex,
                                                     (LPARAM)0);
                lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                szString = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrBuffer )+ 1));
                lstrcpy( szString, lpstrBuffer);
                GlobalUnlock( hMem);
                ParseBufToTok( szString, &tok);
                RLFREE( szString);

                nLength = lstrlen( tok.szText) + 1;

                // Allocate memory for the string
                hStringMem = GlobalAlloc( GHND, (DWORD)MEMSIZE( nLength));

                if ( hStringMem != NULL )
                {
                    if ( (lpString = GlobalLock( hStringMem)) != NULL )
                    {
#ifdef UNICODE
                        UINT uTextType = CF_UNICODETEXT;
#else
                        UINT uTextType = CF_TEXT;
#endif
                        // Get the selected text
                        lstrcpy( lpString, tok.szText);

                        // Unlock the block
                        GlobalUnlock( hStringMem);

                        // Open the Clipboard and clear its contents
                        OpenClipboard( hWnd);
                        EmptyClipboard();

                        // Give the Clipboard the text data

                        SetClipboardData( uTextType, hStringMem);

                        CloseClipboard();

                        hStringMem = NULL;
                    }
                    else
                    {
                        LoadStringA( hInst, IDS_ERR_NO_MEMORY, szDHW, DHWSIZE);
                        MessageBoxA( hWnd,
                                     szDHW,
                                     szAppName,
                                     MB_ICONHAND | MB_OK);
                    }
                }
                else
                {
                    LoadStringA( hInst, IDS_ERR_NO_MEMORY, szDHW, DHWSIZE);
                    MessageBoxA( hWnd,
                                 szDHW,
                                 szAppName,
                                 MB_ICONHAND | MB_OK);
                }
                RLFREE( tok.szText);
            }
            break;
        }

    case IDM_G_GLOSS:

        if ( GetFileNameFromBrowse( hWnd,
                                    gProj.szGlo,
                                    MAXFILENAME,
                                    szOpenDlgTitle,
                                    szGlossFilterSpec,
                                    NULL) )
        {
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};
                                                 // file exists?
            if ( OpenFile( gProj.szGlo, &Of, OF_EXIST) != HFILE_ERROR )
            {                                    // Yes
                HCURSOR hOldCursor = SetCursor( hHourGlass);

                MakeGlossIndex( lFilePointer);
                SetCursor( hOldCursor);
            }
            else
            {
                gProj.szGlo[0] = 0;
            }
        }
        break;

    case IDM_E_PASTE:

        if ( fTokFile && OpenClipboard( hWnd) )
        {
            UINT    puFormat[]  = { CF_TEXT, CF_OEMTEXT, CF_UNICODETEXT };
            int     nType   = GetPriorityClipboardFormat( puFormat, 3);


                    // Check for current position and change that token's text

            if ( nType != 0 && nType != -1 )
            {
                HGLOBAL hClipMem    = NULL;
                HGLOBAL hMem        = NULL;
                LPTSTR  lpstrBuffer = NULL;
                LPTSTR  lpClipMem   = NULL;
                TCHAR   *szString   = NULL;
                TOKEN   tok;
#ifdef UNICODE
                UINT    uWantType = CF_UNICODETEXT;
#else
                UINT    uWantType = CF_TEXT;
#endif
                int     nLength = 0;
                WPARAM  wIndex  = (WPARAM)SendMessage( hListWnd,
                                                       LB_GETCURSEL,
                                                       (WPARAM)0,
                                                       (LPARAM)0);

                if ( wIndex == LB_ERR )
                {
#if defined(UNICODE)
                     break;
#else // not UNICODE
		    wIndex = (WPARAM)-1;
#endif // UNICODE
                }
                hClipMem  = GetClipboardData( uWantType);
                lpClipMem = (LPTSTR)GlobalLock( hClipMem);

                hMem = (HGLOBAL)SendMessage( hListWnd,
                                             LB_GETITEMDATA,
                                             wIndex,
                                             (LPARAM)0);
                lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                szString = (LPTSTR)FALLOC( MEMSIZE( lstrlen( lpstrBuffer) + 1));
                lstrcpy( szString, lpstrBuffer);
                GlobalUnlock( hMem);
                    // copy the string to the token
                ParseBufToTok( szString, &tok);
                RLFREE( szString);
                RLFREE( tok.szText);
                tok.szText = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpClipMem) + 1));
                lstrcpy( tok.szText, lpClipMem);
                GlobalUnlock( hClipMem);

                szString = (TCHAR *)FALLOC( MEMSIZE( TokenToTextSize( &tok)+ 1));
                ParseTokToBuf( szString, &tok);
                RLFREE( tok.szText);

                    // Paste the text
                SendMessage( hListWnd,
                             WM_SETREDRAW,
                             (WPARAM)FALSE,
                             (LPARAM)0);
                SendMessage( hListWnd,
                             LB_DELETESTRING,
                             wIndex,
                             (LPARAM)0);

                hMem = GlobalAlloc( GMEM_ZEROINIT,
                                    MEMSIZE( lstrlen( szString) + 1));
                lpstrBuffer = (LPTSTR)GlobalLock( hMem);
                lstrcpy( lpstrBuffer, szString);
                GlobalUnlock( hMem);
                RLFREE( szString);

                SendMessage( hListWnd,
                             LB_INSERTSTRING,
                             wIndex,
                             (LPARAM)hMem);
                SendMessage( hListWnd,
                             LB_SETCURSEL,
                             wIndex,
                             (LPARAM)0);
                SendMessage( hListWnd,
                             WM_SETREDRAW,
                             (WPARAM)TRUE,
                             (LPARAM)0);
                InvalidateRect( hListWnd, NULL, TRUE);
                fTokChanges = TRUE; // Set Dirty Flag

                                // Close the Clipboard
                CloseClipboard();

                SetFocus( hListWnd);
            }
        }
        CloseClipboard();
        break;

    case IDM_E_FINDDOWN:

        if ( fSearchStarted )
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  0,
                                  TRUE) )
            {
                TCHAR sz1[80] = TEXT("");
                TCHAR sz2[80] = TEXT("");

                LoadString( hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd,
                            sz2,
                            sz1,
                            MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FINDUP:

        if ( fSearchStarted )
        {
            if ( ! DoTokenSearch( szSearchType,
                                  szSearchText,
                                  wSearchStatus,
                                  wSearchStatusMask,
                                  1,
                                  TRUE) )
            {
                TCHAR sz1[80] = TEXT("");
                TCHAR sz2[80] = TEXT("");

                LoadString (hInst,
                            IDS_FIND_TOKEN,
                            sz1,
                            TCHARSIN( sizeof( sz1)));
                LoadString( hInst,
                            IDS_TOKEN_NOT_FOUND,
                            sz2,
                            TCHARSIN( sizeof( sz2)));
                MessageBox( hWnd,
                            sz2,
                            sz1,
                            MB_ICONINFORMATION | MB_OK);
            }
            break;
        }               //... ELSE fall thru

    case IDM_E_FIND:
        {
#ifndef RLWIN32
            WNDPROC lpfnTOKFINDMsgProc;

            lpfnTOKFINDMsgProc = MakeProcInstance((WNDPROC)TOKFINDMsgProc, hInst);

            if (!DialogBox(hInst, TEXT("TOKFIND"), hWnd, lpfnTOKFINDMsgProc))
#else
            if (!DialogBox(hInst, TEXT("TOKFIND"), hWnd, TOKFINDMsgProc))
#endif
                {

#ifndef DBCS
// 'Token Not Found' is strange because user selected cancel
                    TCHAR sz1[80] = TEXT("");
		    TCHAR sz2[80] = TEXT("");

                    LoadString( hInst,
                                IDS_TOKEN_NOT_FOUND,
                                sz2,
                                TCHARSIN( sizeof( sz2)));
                    LoadString( hInst,
                                IDS_FIND_TOKEN,
                                sz1,
                                TCHARSIN( sizeof( sz1)));
                    MessageBox( hWnd,
                                sz2,
                                sz1,
                                MB_ICONINFORMATION | MB_OK);
#endif    //DBCS

                }
#ifndef RLWIN32
            FreeProcInstance( lpfnTOKFINDMsgProc);
#endif
            return TRUE;
        }

    case IDM_H_CONTENTS:
    {
        OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

        if ( OpenFile( gszHelpFile, &Of, OF_EXIST) == HFILE_ERROR )
        {
            LoadStringA( hInst, IDS_ERR_NO_HELP , szDHW, DHWSIZE);
            MessageBoxA( hWnd, szDHW, gszHelpFile, MB_OK);
        }
        else
        {
            WinHelpA( hWnd, gszHelpFile, HELP_KEY, (LPARAM)(LPSTR)"RLQuikEd");
        }
        break;
    }

    case IDM_H_ABOUT:
        {

#ifndef RLWIN32

            WNDPROC lpProcAbout;

            lpProcAbout = MakeProcInstance(About, hInst);
            DialogBox(hInst, TEXT("ABOUT"), hWnd, lpProcAbout);
            FreeProcInstance(lpProcAbout);
#else
            DialogBox(hInst, TEXT("ABOUT"), hWnd, About);
#endif
            break;
        }
        break;

    default:

        if (wParam <= IDM_LAST_EDIT && wParam >= IDM_FIRST_EDIT)
        {
            // USER IS INVOKING AN EDITOR
            if ( LoadStrIntoAnsiBuf(hInst, (UINT)wParam, szEditor, sizeof(szEditor)) )
            {
                if ( SendMessage( hWnd, WM_SAVETOKENS, (WPARAM)0, (LPARAM)0) )
                {
                    HCURSOR hOldCursor;

                    hOldCursor = SetCursor(hHourGlass);
                    MyGetTempFileName(0, "RES", 0, szTempRes);
			        fInThirdPartyEditer = TRUE;

                    if (gProj.fSourceEXE)
                    {
                        // we need to first extract the .RES from the .EXE
                        CHAR sz[MAXFILENAME] = "";
                        MyGetTempFileName(0, "RES", 0, sz);
                        ExtractResFromExe32A( gMstr.szSrc, sz, 0);
                        GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                         sz,
                                                         gProj.szTok,
                                                         gMstr.szRdfs,
                                                         ID_RT_DIALOG);
                        remove(sz);
                    }
                    else
                    {
                        GenerateRESfromRESandTOKandRDFs( szTempRes,
                                                         gMstr.szSrc,
                                                         gProj.szTok,
                                                         gMstr.szRdfs,
                                                         ID_RT_DIALOG);
                    }
                    SetCursor( hOldCursor);
                    ExecResEditor( hWnd, szEditor, szTempRes,  "");
                }
            }
        }
        break;                          // default
    }
    return( FALSE);
}


#ifdef RLWIN16
static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    CHAR szExecCmd[256] = "";
    int  RetCode;

    // generate command line
    strcpy(szExecCmd, szEditor);
    lstrcat(szExecCmd, " ");
    lstrcat(szExecCmd, szArgs);
    lstrcat(szExecCmd, " ");
    lstrcat(szExecCmd, szFile);

    lpfnWatchTask = MakeProcInstance(WatchTask, hInst);
    NotifyRegister(NULL, lpfnWatchTask, NF_NORMAL);
    fWatchEditor = TRUE;

    // exec resource editor
    RetCode = WinExec(szExecCmd, SW_SHOWNORMAL);

    if (RetCode > 31)
    {
        // successful execution
        ShowWindow(hWnd,SW_HIDE);
    }
    else
    {
        // unsuccessful execution
        TCHAR sz[80] = TEXT("");
        NotifyUnRegister(NULL);
        FreeProcInstance(lpfnWatchTask);
        remove(szFile);
        fInThirdPartyEditer = FALSE;
        SendMessage(hWnd, WM_LOADTOKENS, 0, 0);
        LoadString(hInst, IDS_GENERALFAILURE, sz, CHARSIZE( sz));
    }
    return RetCode;
}
#endif

#ifdef RLWIN32
static int ExecResEditor(HWND hWnd, CHAR *szEditor, CHAR *szFile, CHAR *szArgs)
{
    TCHAR  wszExecCmd[256] = TEXT("");
    CHAR   szExecCmd[256] = "";
    DWORD  dwRetCode;
    DWORD  dwExitCode;
    BOOL   fSuccess;
    BOOL   fExit = FALSE;

    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO     StartupInfo;

    StartupInfo.cb          = sizeof( STARTUPINFO);
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop   = NULL;
    StartupInfo.lpTitle     = TEXT("Resize Dialogs");
    StartupInfo.dwX         = 0L;
    StartupInfo.dwY         = 0L;
    StartupInfo.dwXSize     = 0L;
    StartupInfo.dwYSize     = 0L;
    StartupInfo.dwFlags     = STARTF_USESHOWWINDOW;
    StartupInfo.wShowWindow = SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = NULL;
    StartupInfo.cbReserved2 = 0;

    //  generate command line
    strcpy(szExecCmd, szEditor);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szArgs);
    strcat(szExecCmd, " ");
    strcat(szExecCmd, szFile);


#ifdef UNICODE
    _MBSTOWCS( wszExecCmd,
               szExecCmd,
               WCHARSIN( sizeof( wszExecCmd)),
               ACHARSIN( strlen( szExecCmd) + 1));
#else
    strcpy(wszExecCmd, szExecCmd);
#endif

    fSuccess = CreateProcess( NULL,
                              wszExecCmd,
                              NULL,
                              NULL,
                              FALSE,
                              NORMAL_PRIORITY_CLASS,
                              NULL,
                              NULL,
                              &StartupInfo,
                              &ProcessInfo);
    /* try to create a process */

    if ( fSuccess )
    {
        //  wait for the editor to complete */

        dwRetCode = WaitForSingleObject(ProcessInfo.hProcess, 0xFFFFFFFF) ;

        if (!dwRetCode)
        {
            // editor terminated, check exit code
            fExit = GetExitCodeProcess(ProcessInfo.hProcess, &dwExitCode) ;
        }
        else
        {
            fExit = FALSE;
        }

        if (fExit)
        {

            // successful execution
            ShowWindow(hWnd,SW_HIDE);
            PostMessage(hMainWnd,WM_EDITER_CLOSED,0,0);
        }
        else
        {
            // unsuccessful execution
            remove(szFile);
	        fInThirdPartyEditer = FALSE;
            SendMessage( hWnd, WM_LOADTOKENS, (WPARAM)0, (LPARAM)0);
            LoadStrIntoAnsiBuf( hInst, IDS_GENERALFAILURE, szDHW, DHWSIZE);
            MessageBoxA( hWnd, szDHW, szEditor, MB_ICONSTOP|MB_OK);
        }

        // close the editor object  handles

        CloseHandle(ProcessInfo.hThread) ;
        CloseHandle(ProcessInfo.hProcess) ;
    }
	else
	{
		dwRetCode = GetLastError();		// not used - debugging only (so far)
        fExit = FALSE;
	}

    return fExit;
}
#endif

/**
 *  Function: WatchTask
 *    A callback function installed by a NotifyRegister function.
 *    This function is installed by the dialog editer command and is used
 *    to tell RLQuikEd when the dialog editer has been closed by the user.
 *
 *    To use this function, set fWatchEditor to TRUE and install this
 *    callback function by using NotifyRegister.  The next task initiated
 *    \(in our case via a WinExec call\) will be watched for termination.
 *
 *    When WatchTask sees that the task being watched has terminated it
 *    posts a WM_EDITER_CLOSED message to RLQuikEds main window.
 *
 *  History:
 *    2/92, implemented    SteveBl
 */
#ifdef RLWIN16
static BOOL PASCAL _loadds  WatchTask(WORD wID,DWORD dwData)
{
    static HTASK htWatchedTask;
    static BOOL fWatching = FALSE;

    switch (wID)
    {
    case NFY_STARTTASK:
        if (fWatchEditor)
        {
            htWatchedTask = GetCurrentTask();
            fWatching = TRUE;
            fWatchEditor = FALSE;
        }
        break;
    case NFY_EXITTASK:
        if (fWatching)
        {
            if (GetCurrentTask() == htWatchedTask)
            {
                PostMessage(hMainWnd,WM_EDITER_CLOSED,0,0);
                fWatching = FALSE;
            }
        }
        break;
    }
    return FALSE;
}

#endif

/**
 *
 *
 *  Function:  TokEditDlgProc
 *     Procedure for the edit mode dialog window. Loads the selected token
 *     info into the window, and allows the user to change the token text.
 *     Once the edit is complete, the procedure sends a message to the
 *     list box windows to update the current token info.
 *
 *
 *  Arguments:
 *
 *  Returns:  NA.
 *
 *  Errors Codes:
 *     TRUE, carry out edit, and update token list box.
 *     FALSE, cancel edit.
 *
 *  History:
 *
 *
 **/

#ifdef RLWIN32
INT_PTR CALLBACK TokEditDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
#else
static BOOL APIENTRY TokEditDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
#endif
{
    HWND    hCtl;
    HWND    hParentWnd;
//    TCHAR   *szTokTextBuf;
    UINT    static wcTokens = 0;
    UINT    wNotifyCode;
    UINT    wIndex;

    switch(wMsg)
    {
    case WM_INITDIALOG:

        cwCenter(hDlg, 0);
        wcTokens = (UINT)SendMessage( hListWnd,
                                      LB_GETCOUNT,
                                      (WPARAM)0,
                                      (LPARAM)0);
        wcTokens--;

        // only allow skip button if in update mode

        // disallow auto translate if we don\'t have a glossary file
        if (*gProj.szGlo == '\0')
        {
            hCtl = GetDlgItem(hDlg, IDD_TRANSLATE);

            if (hCtl)
            {
                EnableWindow(hCtl, FALSE);
            }
            hCtl = GetDlgItem(hDlg, IDD_ADD);

            if (hCtl)
            {
                EnableWindow(hCtl, FALSE);
            }
        }
        return TRUE;

    case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_TOKCURTRANS:

            wNotifyCode = GET_WM_COMMAND_CMD(wParam, lParam);
            hCtl = GET_WM_COMMAND_HWND(wParam, lParam);

            if (wNotifyCode == EN_CHANGE)
            {
                hCtl = GetDlgItem(hDlg, IDOK);

                if (hCtl)
                {
                    EnableWindow(hCtl, TRUE);
                }
            }
            break;

        case IDD_ADD:
            {
                TCHAR *szUntranslated = NULL;
                TCHAR *szTranslated   = NULL;
                TCHAR *sz = NULL;
                TCHAR szMask[80]  = TEXT("");
                HWND hDlgItem     = NULL;
                int cCurTextLen   = 0;
                int cTotalTextLen = 0;

                cTotalTextLen = 80;
                hDlgItem       = GetDlgItem(hDlg, IDD_TOKPREVTRANS);
                cCurTextLen    = GetWindowTextLength( hDlgItem);
                cTotalTextLen += cCurTextLen;

                szTranslated = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));

                GetDlgItemText( hDlg,
                                IDD_TOKPREVTRANS,
                                (LPTSTR)szUntranslated,
                                cCurTextLen + 1);

                hDlgItem       = GetDlgItem( hDlg, IDD_TOKCURTRANS);
                cCurTextLen    = GetWindowTextLength( hDlgItem);
                cTotalTextLen += cCurTextLen;
                szTranslated = (TCHAR *)FALLOC( MEMSIZE( cCurTextLen + 1));
                GetDlgItemText( hDlg,
                                IDD_TOKCURTRANS,
                                (LPTSTR)szTranslated,
                                cCurTextLen + 1);

                LoadString( hInst,
                            IDS_ADDGLOSS,
                            szMask,
                            TCHARSIN( sizeof( szMask)));

                sz = (TCHAR *)FALLOC( MEMSIZE( cTotalTextLen + 1));

                wsprintf( sz, szMask, szTranslated, szUntranslated);

                if ( MessageBox( hDlg,
                                 sz,
                                 tszAppName,
                                 MB_ICONQUESTION | MB_YESNO) == IDYES)
                {
                    HCURSOR hOldCursor = SetCursor( hHourGlass);

                    AddTranslation( szUntranslated,
                                    szTranslated,
                                    lFilePointer);

                    TransString( szUntranslated,
                                 szTranslated,
                                 &pTransList,
                                 lFilePointer);
                    SetCursor( hOldCursor);
                }
                RLFREE( sz);
                RLFREE( szTranslated);
                RLFREE( szUntranslated);
                break;
            }

        case IDD_TRANSLATE:

            // if \(!pTransList\)
            //    SendMessage\(hMainWnd, WM_TRANSLATE, \(WPARAM\) 0,\(LPARAM\) 0\);

            // Get next thing in the translation list

            if ( pTransList )
            {
                pTransList = pTransList->pNext;
                SetDlgItemText( hDlg, IDD_TOKCURTRANS, (LPTSTR)pTransList->sz);
            }
            break;

        case IDOK:
            {
                int cTokenTextLen;
                HWND hDlgItem;
                TCHAR *szTokenTextBuf;

                wIndex = (UINT)SendMessage( hListWnd,
                                            LB_GETCURSEL,
                                            (WPARAM)0,
                                            (LPARAM)0);
                fTokChanges = TRUE;

                // set flag to show token list has changed
                // Extract String from IDD_TOKTEXT edit control
                hDlgItem = GetDlgItem(hDlg, IDD_TOKCURTRANS);
                cTokenTextLen = GetWindowTextLength(hDlgItem);
                szTokenTextBuf = (TCHAR *)FALLOC( MEMSIZE( cTokenTextLen + 1));
                GetDlgItemText(hDlg,
                               IDD_TOKCURTRANS,
                               szTokenTextBuf,
                               cTokenTextLen+1);

                hParentWnd = GetParent(hDlg);
                SendMessage( hParentWnd,
                             WM_TOKEDIT,
                             (WPARAM)0,
                             (LPARAM)szTokenTextBuf);
                // Exit, or goto to next changed token if in update mode

                // fall through to IDCANCEL
            }

        case IDCANCEL:

            // remove edit dialog box

            if (hDlg)
            {
                DestroyWindow(hDlg);
            }
            hTokEditDlgWnd = 0;
#ifndef RLWIN32
            FreeProcInstance(lpTokEditDlg);
#endif
            break;

        }                               // GET_WM_COMMAND_ID
        return TRUE;

    default:

        hCtl = GetDlgItem(hDlg, IDOK);

        if (hCtl)
        {
            EnableWindow(hCtl, TRUE);
        }
        return FALSE;

    }                                   // Main Switch
}


/**
 *
 *  Function: TOKFINDMsgProc
 *
 *  Arguments:
 *
 *  Returns:
 *     NA.
 *
 *  Errors Codes:
 *
 *  History:
 *
 **/
#ifdef RLWIN32
INT_PTR CALLBACK TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
#else
static BOOL APIENTRY TOKFINDMsgProc(HWND hWndDlg, UINT wMsg, UINT wParam, LONG lParam)
#endif
{
    HWND hCtl;

    int rgiTokenTypes[]=
    {
        ID_RT_MENU,
        ID_RT_DIALOG,
        ID_RT_STRING,
        ID_RT_ACCELERATORS,
        ID_RT_RCDATA,
        ID_RT_ERRTABLE,
        ID_RT_NAMETABLE,
        ID_RT_VERSION,
        ID_RT_DLGINIT
    };

    TCHAR szTokenType[20] = TEXT("");

    WORD  i;
    DWORD rc;

    switch(wMsg)
    {
    case WM_INITDIALOG:

        CheckDlgButton( hWndDlg, IDD_FINDDOWN, 1);
        hCtl = GetDlgItem( hWndDlg, IDD_TYPELST);

        for ( i = 0; i < sizeof( rgiTokenTypes) / sizeof( int); i++ )
        {
            LoadString( hInst,
                        IDS_RESOURCENAMES + rgiTokenTypes[i],
                        szTokenType,
                        TCHARSIN( sizeof( szTokenType)));
            rc = (DWORD)SendMessage( hCtl,
                              CB_ADDSTRING,
                              (WPARAM)0,
                              (LPARAM)szTokenType);
        }
        return TRUE;
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDOK:                      /* Button text: "Okay"                */
            fSearchStarted = TRUE;
            GetDlgItemText(hWndDlg, IDD_TYPELST, szSearchType, 40);
            GetDlgItemText(hWndDlg, IDD_FINDTOK, szSearchText, 256);
            wSearchStatus = ST_TRANSLATED;
            wSearchStatusMask = ST_TRANSLATED ;

            fSearchDirection = IsDlgButtonChecked(hWndDlg, IDD_FINDUP);

            if( DoTokenSearch (szSearchType,
                               szSearchText,
                               wSearchStatus,
                               wSearchStatusMask,
                               fSearchDirection,
                               0) )
			{
				EndDialog( hWndDlg, TRUE );
			}
			else
			{
                TCHAR sz1[80], sz2[80];

                LoadString(hInst, IDS_FIND_TOKEN, sz1, sizeof(sz1));
                LoadString(hInst, IDS_TOKEN_NOT_FOUND, sz2, sizeof(sz2));
                MessageBox(hWndDlg, sz2, sz1, MB_ICONINFORMATION | MB_OK);
				EndDialog( hWndDlg, FALSE );
			}
            return TRUE;

        case IDCANCEL:
            /* and dismiss the dialog window returning FALSE   */
            EndDialog(hWndDlg, FALSE);
            return TRUE;
        }
        break;                          /* End of WM_COMMAND    */

    default:
        return FALSE;
    }
    return FALSE;
}

/**
 *  Function:
 *
 *  Arguments:
 *
 *  Returns:
 *
 *  Errors Codes:
 *
 *  History:
 **/
static void DrawLBItem(LPDRAWITEMSTRUCT lpdis)
{
    LPRECT lprc    = (LPRECT) &(lpdis->rcItem);
    DWORD  rgbOldText   = 0;
    DWORD  rgbOldBack   = 0;
    LPTSTR  lpstrToken;
    HBRUSH hBrush;
    static DWORD    rgbHighlightText;
    static DWORD    rgbHighlightBack;
    static HBRUSH   hBrushHilite = NULL;
    static HBRUSH   hBrushNormal = NULL;
    static DWORD    rgbBackColor;
    static DWORD    rgbCleanText;
    TCHAR  *szToken;
    TOKEN  tok;

    if (lpdis->itemAction & ODA_FOCUS)
    {
        DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
    }
    else
    {
        HANDLE hMem = (HANDLE)SendMessage( lpdis->hwndItem,
                                           LB_GETITEMDATA,
                                           (WPARAM)lpdis->itemID,
                                           (LPARAM)0);
        lpstrToken = (LPTSTR)GlobalLock( hMem);
        szToken = (TCHAR *)FALLOC( MEMSIZE( lstrlen( lpstrToken) + 1));
        lstrcpy( szToken,lpstrToken);
        GlobalUnlock( hMem);
        ParseBufToTok( szToken, &tok);
        RLFREE( szToken);

        if ( lpdis->itemState & ODS_SELECTED )
        {
            if (!hBrushHilite)
            {
                rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                rgbHighlightBack = GetSysColor(COLOR_HIGHLIGHT);
                hBrushHilite = CreateSolidBrush(rgbHighlightBack);
            }

            MakeStatusLine(&tok);

            rgbOldText = SetTextColor(lpdis->hDC, rgbHighlightText);
            rgbOldBack = SetBkColor(lpdis->hDC, rgbHighlightBack);

            hBrush = hBrushHilite;
        }
        else
        {
            if (!hBrushNormal)
            {
                rgbBackColor = RGB(192,192,192);
                rgbCleanText = RGB(0,0,0);
                hBrushNormal = CreateSolidBrush(rgbBackColor);
            }
            rgbOldText = SetTextColor(lpdis->hDC, rgbCleanText);
            rgbOldBack = SetBkColor(lpdis->hDC,rgbBackColor);
            hBrush = hBrushNormal;
        }

        FillRect(lpdis->hDC, (CONST RECT *)lprc, hBrush);
        DrawText(lpdis->hDC,
                 tok.szText,
                 STRINGSIZE(lstrlen(tok.szText)),
                 lprc,
                 DT_LEFT|DT_NOPREFIX);

        RLFREE( tok.szText);

        if (rgbOldText)
        {
            SetTextColor(lpdis->hDC, rgbOldText);
        }
        if (rgbOldBack)
        {
            SetBkColor(lpdis->hDC, rgbOldBack);
        }

        if (lpdis->itemState & ODS_FOCUS)
        {
            DrawFocusRect(lpdis->hDC, (CONST RECT *)lprc);
        }
    }
}

/************************************************************************
 *FUNCTION: SaveTokList(HWND, FILE *fpTokFile)                          *
 *                                                                      *
 *PURPOSE: Save current Token List                                      *
 *                                                                      *
 *COMMENTS:                                                             *
 *                                                                      *
 *This saves the current contents of the Token List                     *
 **********************************************************************/

static BOOL SaveTokList(HWND hWnd, FILE *fpTokFile)
{
    HCURSOR hSaveCursor   = NULL;
    BOOL    bSuccess      = TRUE;
    int     cTokenTextLen = 0;
    int     IOStatus      = 0;
    UINT    cTokens       = 0;
    UINT    cCurrentTok   = 0;
    CHAR   *szTokBuf      = NULL;
    TCHAR  *szTmpBuf      = NULL;
    LPTSTR  lpstrToken    = NULL;

    // Set the cursor to an hourglass during the file transfer

    hSaveCursor = SetCursor(hHourGlass);

    // Find number of tokens in the list

    cTokens = (UINT)SendMessage( hListWnd, LB_GETCOUNT, (WPARAM)0, (LPARAM)0);

    if ( cTokens != LB_ERR )
    {
        for ( cCurrentTok = 0;
              bSuccess && (cCurrentTok < cTokens);
              cCurrentTok++)
        {
            // Get each token from list
            HGLOBAL hMem = (HGLOBAL)SendMessage( hListWnd,
                                                 LB_GETITEMDATA,
                                                 (WPARAM)cCurrentTok,
                                                 (LPARAM)0);
            if ( hMem )
            {
                if ( (lpstrToken = (LPTSTR)GlobalLock( hMem)) != NULL )
                {
#ifdef UNICODE

                    cTokenTextLen = MEMSIZE( lstrlen(lpstrToken) + 1 );
                    szTmpBuf = (TCHAR *)FALLOC( cTokenTextLen );
                    szTokBuf = FALLOC( cTokenTextLen );
                    lstrcpy( szTmpBuf, lpstrToken);

                    _WCSTOMBS( szTokBuf, szTmpBuf, cTokenTextLen, lstrlen(szTmpBuf)+1);
                    cTokenTextLen = lstrlenA( szTokBuf );

                    RLFREE( szTmpBuf);
#else	//UNICODE
                    cTokenTextLen = lstrlen( lpstrToken);
                    szTokBuf =  FALLOC( cTokenTextLen + 1);
                    lstrcpy( szTokBuf, lpstrToken);
#endif
                    GlobalUnlock( hMem);
                    IOStatus = fprintf( fpTokFile, "%s\n", szTokBuf);
                    RLFREE( szTokBuf);

                    if ( IOStatus != (int)cTokenTextLen + 1 )
                    {
                        TCHAR szTmpBuf[256];

                        LoadString( hInst,
                                    IDS_FILESAVEERR,
                                    szTmpBuf,
                                    TCHARSIN( sizeof( szTmpBuf)));
                        MessageBox( hWnd,
                                    szTmpBuf,
                                    NULL,
                                    MB_OK | MB_ICONHAND);
                        bSuccess = FALSE;
                    }
                }
            }
        }
    }
    // restore cursor
    SetCursor(hSaveCursor);
    return( bSuccess);
}



/**
 * Function: CleanDeltaList
 *   frees the pTokenDeltaInfo list
 */
static void CleanDeltaList(void)
{
    TOKENDELTAINFO FAR *pTokNode;

    while (pTokNode = pTokenDeltaInfo)
    {
        pTokenDeltaInfo = pTokNode->pNextTokenDelta;
        RLFREE( pTokNode->DeltaToken.szText);
        RLFREE( pTokNode);

    }
}

/*
 * About -- message processor for about box
 *
 */

#ifdef RLWIN32

INT_PTR CALLBACK About(

HWND     hDlg,
unsigned message,
WPARAM   wParam,
LPARAM   lParam)

#else

static BOOL APIENTRY About(

HWND     hDlg,
unsigned message,
UINT     wParam,
LONG     lParam)

#endif
{
    switch( message )
    {
        case WM_INITDIALOG:
            {
                WORD wRC = SUCCESS;
                CHAR szModName[ MAXFILENAME];

                GetModuleFileNameA( hInst, szModName, sizeof( szModName));

                if ( (wRC = GetCopyright( szModName,
                                          szDHW,
                                          DHWSIZE)) == SUCCESS )
                {
                    SetDlgItemTextA( hDlg, IDC_COPYRIGHT, szDHW);
                }
                else
                {
                    ShowErr( wRC, NULL, NULL);
                }
            }
            break;

        case WM_COMMAND:

            switch ( GET_WM_COMMAND_ID(wParam, lParam) )
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    break;
            }
            break;

        default:

            return( FALSE);
    }
    return( TRUE);
}



#ifdef RLWIN32

/*
 * GetLangIDsProc -- message processor for getting language IDs
 *
 */

INT_PTR CALLBACK GetLangIDsProc(

HWND     hDlg,
unsigned message,
WPARAM   wParam,
LPARAM   lParam)
{
    switch( message )
    {
        case WM_INITDIALOG:
            {
                LPTSTR pszName = NULL;
                int nSel = 0;


                FillListAndSetLang( hDlg,
                                    IDD_MSTR_LANG_NAME,
                                    &gMstr.wLanguageID,
                                    NULL);

                FillListAndSetLang( hDlg,
                                    IDD_PROJ_LANG_NAME,
                                    &gProj.wLanguageID,
                                    NULL);

                CheckRadioButton( hDlg, IDC_REPLACE, IDC_APPEND, IDC_REPLACE);
            }
            break;

        case WM_COMMAND:

            switch( GET_WM_COMMAND_ID( wParam, lParam) )
            {
                case IDC_REPLACE:
                case IDC_APPEND:

                    CheckRadioButton( hDlg,
                                      IDC_REPLACE,
                                      IDC_APPEND,
                                      GET_WM_COMMAND_ID( wParam, lParam));
                    break;

                case IDD_MSTR_LANG_NAME:

                    if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK )
                    {
                                //... Get the selected language name
                                //... then set the appropriate lang id vals

                        INT_PTR nSel = -1;

                        if ( (nSel = SendDlgItemMessage( hDlg,
                                                         IDD_MSTR_LANG_NAME,
                                                         CB_GETCURSEL,
                                                         (WPARAM)0,
                                                         (LPARAM)0)) != CB_ERR
                          && SendDlgItemMessage( hDlg,
                                                 IDD_MSTR_LANG_NAME,
                                                 CB_GETLBTEXT,
                                                 (WPARAM)nSel,
                                                 (LPARAM)(LPTSTR)szDHW) != CB_ERR )
                        {
                            WORD wPri = 0;
                            WORD wSub = 0;

                            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
                            {
                                gMstr.wLanguageID = MAKELANGID( wPri, wSub);
                            }
                        }
                    }
                    else
                    {
                        return( FALSE);
                    }
                    break;

                case IDD_PROJ_LANG_NAME:

                    if ( GET_WM_COMMAND_CMD( wParam, lParam) == CBN_SELENDOK )
                    {
                                //... Get the selected language name
                                //... then set the appropriate lang id vals

                        INT_PTR nSel = SendDlgItemMessage( hDlg,
                                                       IDD_PROJ_LANG_NAME,
                                                       CB_GETCURSEL,
                                                       (WPARAM)0,
                                                       (LPARAM)0);
                        if ( nSel != CB_ERR
                          && SendDlgItemMessage( hDlg,
                                                 IDD_PROJ_LANG_NAME,
                                                 CB_GETLBTEXT,
                                                 (WPARAM)nSel,
                                                 (LPARAM)(LPTSTR)szDHW) != CB_ERR )
                        {
                            WORD wPri = 0;
                            WORD wSub = 0;

                            if ( GetLangIDs( (LPTSTR)szDHW, &wPri, &wSub) )
                            {
                                gProj.wLanguageID = MAKELANGID( wPri, wSub);
                            }
                        }
                    }
                    else
                    {
                        return( FALSE);
                    }
                    break;

                case IDOK:
                {
                    gfReplace = IsDlgButtonChecked( hDlg, IDC_REPLACE);

                    EndDialog( hDlg, TRUE);
                    break;
                }

                case IDCANCEL:

                    EndDialog( hDlg, FALSE);
                    break;

                default:

                    return( FALSE);
            }
            break;

        default:

            return( FALSE);
    }
    return( TRUE);
}

#endif //RLWIN32



/*
 * Function:  Make Status Line
 *   Builds status line string from a token
 *
 * Inputs:
 *    pszStatusLine, buffer to hold string
 *    pTok, pointer to token structure
 *
 * History:
 *   3/92, implemented      SteveBl
 */

static void MakeStatusLine( TOKEN *pTok)
{
    TCHAR szName[32]       = TEXT("");
    TCHAR szResIDStr[20]   = TEXT("");
    static BOOL fFirstCall = TRUE;

    if ( pTok->szName[0] )
    {
        lstrcpy( szName, pTok->szName);
    }
    else
#ifdef UNICODE
    {
        char szTmpBuf[32] = "";

        _itoa(pTok->wName, szTmpBuf, 10);
        _MBSTOWCS( szName,
                   szTmpBuf,
                   WCHARSIN( sizeof( szName)),
                   ACHARSIN( strlen( szTmpBuf) + 1));
    }
#else
    {
        _itoa(pTok->wName, szName, 10);
    }
#endif

    if ( pTok->wType <= 16 || pTok->wType == ID_RT_DLGINIT )
    {
        LoadString( hInst,
                    IDS_RESOURCENAMES+pTok->wType,
                    szResIDStr,
                    TCHARSIN( sizeof( szResIDStr)));
    }
    else
    {
#ifdef UNICODE

        char szTmpBuf[40] = "";


        _WCSTOMBS( szTmpBuf,
                   szResIDStr,
                   ACHARSIN( sizeof( szTmpBuf)),
                   (UINT)-1);
        _itoa( pTok->wType, szTmpBuf, 10);
#else
        _itoa( pTok->wType, szResIDStr, 10);
#endif
    }

    if ( fFirstCall )
    {
        SendMessage( hStatusWnd,
                     WM_FMTSTATLINE,
                     (WPARAM)0,
                     (LPARAM)TEXT("15s10s5i5i"));
        fFirstCall = FALSE;
    }
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)0, (LPARAM)szName);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)1, (LPARAM)szResIDStr);
    SendMessage( hStatusWnd, WM_UPDSTATLINE, (WPARAM)2, (LPARAM)pTok->wID);
    SendMessage( hStatusWnd,
                 WM_UPDSTATLINE,
                 (WPARAM)3,
                 (LPARAM)lstrlen(pTok->szText));
}


/**************************************************************************
 *Procedure: InsertQuikTokList                                          *
 *                                                                      *
 *Inputs:                                                               *
 *    file pointer to the token file                                    *
 *                                                                      *
 *Returns:                                                              *
 *    pointer to token delta list \(always NULL\)                         *
 *                                                                      *
 *History:                                                              *
 *    3/92 - original implementation - SteveBl                          *
 *    2/93 - Rewrote to use get token, since tokens can be arb length   *
 *              MHotchin.                                               *
 *                                                                      *
 *Comments:                                                             *
 *    Since RLQuikEd\'s token files are always temporary files generated *
 *    from res files we know that all tokens are new and unique.  There is *
 *    never any tracking data so we never have to build a token delta info *
 *    list.  For this reason, InsertQuikTokList allways returns NULL.     *
 *    Also, every token must be marked as ST_TRANSLATED                 *
 *                                                                      *
 **************************************************************************/

static TOKENDELTAINFO FAR *InsertQuikTokList( FILE * fpTokFile)
{
    static TOKEN tInputToken;
    int    rcFileCode = 0;
    UINT   uTokCharsW = 0;
    LPTSTR pszTokBuf  = NULL;

    rewind(fpTokFile);

    while ( (rcFileCode = GetToken( fpTokFile, &tInputToken)) >= 0 )
    {
        if ( rcFileCode == 0 )
        {
            HGLOBAL hMem = NULL;
            uTokCharsW = TokenToTextSize( &tInputToken) + 1;
            hMem = GlobalAlloc( GMEM_ZEROINIT, MEMSIZE( uTokCharsW));
            pszTokBuf = (LPTSTR)GlobalLock( hMem);
            ParseTokToBuf( pszTokBuf, &tInputToken);
            GlobalUnlock( hMem);

            if ( SendMessage( hListWnd,
                              LB_ADDSTRING,
                              (WPARAM)0,
                              (LPARAM)hMem) < 0)
            {
                QuitT( IDS_ENGERR_11, NULL, NULL);
            }
        }
    }
    return NULL;
}



/****************************************************************************
 *Procedure: LoadNewFile                                                     *
 *                                                                           *
 *Inputs:                                                                    *
 *       Pointer to path string                                              *
 *                                                                           *
 *Returns:                                                                   *
 *   boolean success or failure                                              *
 *                                                                           *
 *History:                                                                   *
 *       6/92 - created from IDM_P_OPEN case in DoMenuCommand - t-gregti     *
 *                                                                           *
 *Comments:                                                                  *
 *       This is nice to have so code isn't repeated in the file-browse and  *
 *   drag-drop cases.                                                        *
 *****************************************************************************/

static BOOL LoadNewFile( CHAR *szPath)
{                               // Save old project
    OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

    if ( ! SendMessage( hMainWnd, WM_SAVEPROJECT, (LPARAM)0, (LPARAM)0) )
    {
        return( FALSE);
    }
    if ( gProj.szTok[0] )       // get rid of the old temp file
    {
        remove( gProj.szTok);
        gProj.szTok[0] = 0;
    }

    strcpy( szFileName, szPath);

    if ( OpenFile( szFileName, &Of, OF_EXIST) != HFILE_ERROR )
    {
        if ( IsExe( szFileName) )
        {
            gProj.fSourceEXE = TRUE;
            gProj.fTargetEXE = TRUE;
        }
        else
        {
            gProj.fSourceEXE = FALSE;
            gProj.fTargetEXE = FALSE;
        }
        strcpy( gMstr.szSrc, szFileName);
        gMstr.szRdfs[0] = 0;
        gProj.szTok[0]  = 0;
        MyGetTempFileName( 0,"TOK", 0, gProj.szTok);

        sprintf( szDHW, "%s - %s", szAppName, szFileName);
        SetWindowTextA( hMainWnd, szDHW);
        SendMessage( hMainWnd, WM_LOADPROJECT, (LPARAM)0, (LPARAM)0);
    }
    return(TRUE);
}


//...................................................................

int  RLMessageBoxA(

LPCSTR pszMsgText)
{
    return( MessageBoxA( hMainWnd, pszMsgText, szAppName, MB_ICONSTOP|MB_OK));
}


//...................................................................

void Usage()
{
    return;
}


void DoExit( int nErrCode)
{
    ExitProcess( (UINT)nErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlquiked\rlquiked.h ===
#ifndef _RLQUIKED_H_
#define _RLQUIKED_H_

#include "rlstrngs.h"
#include "resourc2.h"



void cwCenter(HWND, int);

INT_PTR APIENTRY   MainWndProc(HWND, UINT,  WPARAM, LPARAM);
INT_PTR     DoMenuCommand    ( HWND, UINT, WPARAM, LPARAM );
INT_PTR     DoListBoxCommand ( HWND, UINT, WPARAM, LPARAM );
BOOL        InitApplication(HINSTANCE);
BOOL        InitInstance(HINSTANCE, int);
BOOL        SaveTokList( HWND, FILE * );


#ifdef RLWIN32
INT_PTR CALLBACK About(          HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK GetLangIDsProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK TOKFINDMsgProc( HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK TokEditDlgProc( HWND, UINT, WPARAM, LPARAM);
#else
static BOOL APIENTRY About( HWND, UINT, UINT, LONG );
static BOOL APIENTRY TOKFINDMsgProc( HWND, UINT, UINT, LONG);
static BOOL APIENTRY TokEditDlgProc( HWND, UINT, UINT, LONG);
#endif // RLWIN32


#endif // _RLQUIKED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\rltools\rlman\rlman.c ===
//........................................................................
//...
//... RLMAN.C
//...
//... Contains 'main' for rlman.exe.
//........................................................................


#include <stdio.h>
#include <stdlib.h>

#ifdef RLDOS
#include "dosdefs.h"
#else
#include <windows.h>
#include "windefs.h"
#endif

//#include <tchar.h>
#include "custres.h"
#include "rlmsgtbl.h"
#include "commbase.h"
#include "rlman.h"
#include "exe2res.h"
#include "exeNTres.h"
#include "rlstrngs.h"
#include "projdata.h"
#include "showerrs.h"
#include "resread.h"

#ifndef RLDOS
int Update( char *, char *);
#endif



extern MSTRDATA gMstr;           //... Data from Master Project file (MPJ)
extern PROJDATA gProj;           //... Data from Project file (PRJ)

HWND hListWnd       = NULL;
HWND hMainWnd       = NULL;
HWND hStatusWnd     = NULL;
int  nUpdateMode    = 0;
BOOL fCodePageGiven = FALSE; //... Set to TRUE if -p arg given
CHAR szCustFilterSpec[MAXCUSTFILTER];
CHAR szFileTitle[256]="";

extern BOOL gfReplace;      //... Set FALSE if -a option is given
extern BOOL gbMaster;       //... TRUE if working in a Master Project
extern BOOL gbShowWarnings; //... Display warnining messages if TRUE
extern BOOL gfShowClass;    //... Set TRUE to put dlg box elemnt class in
                            //... token file
extern BOOL gfExtendedTok;  //... Set TRUE if -x option is given
extern UCHAR szDHW[];       //... Common buffer, many uses

extern int  atoihex( CHAR sz[]);
extern BOOL bRLGui;
CHAR szModule[MAX_PATH];


//............................................................

void Usage( void)
{
    int i;

    for ( i = IDS_USG_00; i < IDS_USG_END; ++i )
    {
        LoadStringA( NULL, i, szDHW, DHWSIZE);
        CharToOemA( szDHW, szDHW);
        fprintf( stderr, "%s\n", szDHW);
    }
}

//............................................................
//...
//... This is a stub for console programs

int RLMessageBoxA(

LPCSTR lpError)
{
    fprintf( stderr, "RLMan (%s): %s\n", szModule, lpError);
    return( IDOK);  // Should return something.
}


#ifndef __cdecl
#define __cdecl __cdecl
#endif

//............................................................

void __cdecl main( int argc, char *argv[])
{
    BOOL    fBuildRes = FALSE;
    BOOL    fBuildTok = FALSE;
    BOOL    fExtRes   = FALSE;
    BOOL    bChanged  = FALSE;
    BOOL    fProject       = FALSE; //... Set to TRUE if -l arg given
    BOOL    fNewLanguageGiven = FALSE; //... Set to TRUE if -n arg given
    BOOL    fOldLanguageGiven = FALSE; //... Set to TRUE if -o arg given
    FILE   *pfCRFile = NULL;
    int     iCount = 0;
    int     iErrorLine = 0;
    UINT    usError = 0;
    WORD    wRC     = 0;
    WORD    wResTypeFilter = 0; //... Pass all resource types by default
    char   *pszMasterFile  = NULL;
    char   *pszProjectFile = NULL;
    int     chOpt = 0;

    bRLGui = FALSE;

    wRC = GetCopyright( argv[0], szDHW, DHWSIZE);

    if ( wRC != SUCCESS )
    {
        ShowErr( wRC, NULL, NULL);
        DoExit( wRC);
    }
    CharToOemA( szDHW, szDHW);
    fprintf( stderr, "\n%s\n\n", szDHW);

                                //... Enough args on command line?
    if ( argc < 2 )
    {
        ShowErr( IDS_ERR_01, NULL, NULL);
        Usage();
        DoExit( IDS_ERR_01);
    }
    gbMaster = FALSE;       //... Build project token file by default.

    iCount = 1;
                                //... Get the switches

    while ( iCount < argc && (*argv[ iCount] == '-' || *argv[ iCount] == '/') )
    {
        switch ( (chOpt = *CharLowerA( &argv[iCount][1])))
        {
            case '?':
            case 'h':

                WinHelp( NULL, TEXT("rlman.hlp"), HELP_CONTEXT, IDM_HELPUSAGE);
                DoExit( SUCCESS);
                break;

            case 'e':

                if ( fBuildTok != FALSE || fBuildRes != FALSE )
                {
                    ShowErr( IDS_ERR_02, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                fExtRes   = TRUE;
                gbMaster  = FALSE;
                fBuildTok = FALSE;
                break;

            case 't':           //... Create token file

                if ( fBuildRes != FALSE || fExtRes != FALSE )
                {
                    ShowErr( IDS_ERR_02, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                gbMaster  = FALSE;
                fProject  = FALSE;
                fBuildTok = TRUE;
                break;

                                //... Update 1.0 token files to fit upper 1.7 version,
                                //... it is same as 'm' + 'l' option.

            case 'u':           //...Update 1.0 token files to fit upper 1.7 version

                if ( argc - iCount < 6 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                gbMaster  = TRUE;
                fProject  = TRUE;
                fBuildTok = TRUE;				
                pszMasterFile  = argv[++iCount];
                pszProjectFile = argv[++iCount];
                break;

           case 'm':           //... Build Master token file

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                gbMaster  = TRUE;
                fProject  = FALSE;
                fBuildTok = TRUE;

                pszMasterFile = argv[ ++iCount];
                break;

            case 'l':           //... Build language project token file

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                fProject  = TRUE;
                fBuildTok = TRUE;
                gbMaster  = FALSE;

                pszProjectFile = argv[ ++iCount];
                break;

            case 'a':
            case 'r':

                if ( fBuildTok != FALSE || fExtRes != FALSE )
                {
                    ShowErr( IDS_ERR_02, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_02);
                }
                fBuildRes = TRUE;
                gfReplace = (chOpt == 'a') ? FALSE : TRUE;
                gbMaster  = FALSE;
                fProject  = FALSE;
                break;

            case 'n':           //... Get ID components of new language

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                else
                {
                    WORD wPri = (WORD)MyAtoi( argv[ ++iCount]);
                    WORD wSub = (WORD)MyAtoi( argv[ ++iCount]);
                    gProj.wLanguageID = MAKELANGID( wPri, wSub);
                    fNewLanguageGiven = TRUE;
                }
                break;

            case 'o':           //... Get old language ID components

                if ( argc - iCount < 2 )
                {
                    ShowErr( IDS_ERR_01, NULL, NULL);
                    Usage();
                    DoExit( IDS_ERR_01);
                }
                else
                {
                    WORD wPri = (WORD)MyAtoi( argv[ ++iCount]);
                    WORD wSub = (WORD)MyAtoi( argv[ ++iCount]);
                    gMstr.wLanguageID = MAKELANGID( wPri, wSub);
                    fOldLanguageGiven = TRUE;
                }
                break;

            case 'p':           //... Get code page number

                gMstr.uCodePage = gProj.uCodePage
                                = (UINT)MyAtoi( argv[ ++iCount]);
                fCodePageGiven = TRUE;
                break;

            case 'c':           //... Get custom resource def file name

                strcpy( gMstr.szRdfs, argv[ ++iCount]);

                pfCRFile = FOPEN( gMstr.szRdfs, "rt");

                if ( pfCRFile == NULL )
                {
                    QuitA( IDS_ENGERR_02, gMstr.szRdfs, NULL);
                }
                wRC = (WORD)ParseResourceDescriptionFile( pfCRFile, &iErrorLine);

                if ( wRC )
                {
                    switch ( (int)wRC )
                    {
                        case -1:

                            ShowErr( IDS_ERR_14, NULL, NULL);
                            break;

                        case -2:

                            ShowErr( IDS_ERR_15, NULL, NULL);
                            break;

                        case -3:

                            ShowErr( IDS_ERR_16, NULL, NULL);
                            break;
                    }       //... END switch ( wRC )
                }
                FCLOSE( pfCRFile);
                break;

            case 'f':           //... Get res type to retrieve

                wResTypeFilter = (WORD)MyAtoi( argv[ ++iCount]);
                break;

            case 'w':

                gbShowWarnings = TRUE;
                break;

            case 'd':

                gfShowClass = TRUE;
                break;

            case 'x':

                gfExtendedTok = TRUE;
                break;

            default:

                ShowErr( IDS_ERR_04, argv[ iCount], NULL);
                Usage();
                DoExit( IDS_ERR_04);
                break;

        }                       //... END switch
        iCount++;
    }                           //... END while

	lstrcpyA(szModule, argv[ iCount]);

    if ( fExtRes )
    {
        if ( argc - iCount < 2 )
        {
            ShowErr( IDS_ERR_01, NULL, NULL);
            Usage();
            DoExit( IDS_ERR_01);
        }
        ExtractResFromExe32A( argv[ iCount], argv[ iCount + 1], wResTypeFilter);
    }
    else if ( fBuildTok )
    {
        if ( ( fProject == FALSE && gbMaster == FALSE) && argc - iCount < 2 )
        {
            ShowErr( IDS_ERR_01, NULL, NULL);
            Usage();
            DoExit( IDS_ERR_01);
        }
                                //... check to see if we are updating a
                                //... Master Token file
        if ( gbMaster )
        {
            OFSTRUCT Of = { 0, 0, 0, 0, 0, ""};

            CHAR	*pExe, *pMtk;

            if ( chOpt == 'u' )			//Update them
            {
                pExe = argv[iCount++];
                pMtk = argv[iCount++];				
            }
            else
            {
               pExe = argc - iCount < 1 ? NULL : argv[ iCount];
               pMtk = argc - iCount < 2 ? NULL : argv[ iCount+1];
            }
		   	wRC = (WORD)GetMasterProjectData( pszMasterFile,
                                        pExe,
                                        pMtk,
                                        fOldLanguageGiven);

            if ( wRC != SUCCESS )
            {
                DoExit( wRC);
            }

            LoadCustResDescriptions( gMstr.szRdfs);

                                //... check for the special case where Master
                                //... Token file does not exists. This is
                                //... possible if the MPJ file was created
                                //... automatically.

            if ( OpenFile( gMstr.szMtk, &Of, OF_EXIST) == HFILE_ERROR )
            {
                                //... Master token file does not exists,
                                //... so go ahead and create it

                wRC = (WORD)GenerateTokFile( gMstr.szMtk,
                                       gMstr.szSrc,
                                       &bChanged,
                                       wResTypeFilter);

                SzDateFromFileName( gMstr.szMpjLastRealUpdate, gMstr.szMtk);
            }
            else
            {
                                //... we are doing an update, so we need to make
                                //... sure we don't do unecessary upates

                SzDateFromFileName( gMstr.szSrcDate, gMstr.szSrc);

                if ( strcmp( gMstr.szMpjLastRealUpdate, gMstr.szSrcDate) )
                {
                    wRC = (WORD)GenerateTokFile( gMstr.szMtk,
                                           gMstr.szSrc,
                                           &bChanged,
                                           wResTypeFilter);

                                //... did we really update anything ??

                    if( bChanged )
                    {
                        SzDateFromFileName( gMstr.szMpjLastRealUpdate, gMstr.szMtk);
                    }
                }
            }
                                //... write out the new mpj data

            PutMasterProjectData( pszMasterFile);
        }

#ifndef RLDOS

        if ( fProject )    //... Are we to update a project?
        {
                                //... Yes
            CHAR	*pMpj, *pTok;

            if ( chOpt == 'u' )	//Update it
            {
                pMpj = pszMasterFile;
                pTok = argv[iCount];
            }
            else
            {
                pMpj = argc - iCount < 1 ? NULL : argv[ iCount];
                pTok = argc - iCount < 2 ? NULL : argv[ iCount+1];
            }

            if ( GetProjectData( pszProjectFile,
                                 pMpj,
                                 pTok,
                                 fCodePageGiven,
                                 fNewLanguageGiven) )
            {
                DoExit( -1);
            }
                                //... Get source and master token file names
                                //... from the master project file.

            wRC = (WORD)GetMasterProjectData( gProj.szMpj,
                                        NULL,
                                        NULL,
                                        fOldLanguageGiven);

            if ( wRC != SUCCESS )
            {
                DoExit( wRC);
            }
                                //... Now we do the actual updating.

            wRC = (WORD)Update( gMstr.szMtk, gProj.szTok);

                                //... If that worked, we update the project file
            if ( wRC == 0 )
            {
                SzDateFromFileName( gProj.szTokDate, (CHAR *)gProj.szTok);
                PutProjectData( pszProjectFile);
            }
            else
            {
                ShowErr( IDS_ERR_18, gProj.szTok, gMstr.szMtk);
                DoExit( IDS_ERR_18);
            }
        }

#endif  // RLDOS

        if ( !gbMaster && !fProject )
        {
            wRC = (WORD)GenerateTokFile( argv[ iCount + 1],
                                   argv[ iCount],
                                   &bChanged,
                                   wResTypeFilter);
        }

        if ( wRC != 0 )
        {

#ifdef RLDOS

            ShowErr( IDS_ERR_08, errno, NULL);
            DoExit( -1);
#else
            usError = GetLastError();
            ShowErr( IDS_ERR_08, UlongToPtr(usError), NULL);

            switch ( usError )
            {
                case ERROR_BAD_FORMAT:

                    ShowErr( IDS_ERR_09, NULL, NULL);
                    DoExit( IDS_ERR_09);
                    break;

                case ERROR_OPEN_FAILED:

                    ShowErr( IDS_ERR_10, NULL, NULL);
                    DoExit( IDS_ERR_10);
                    break;

                case ERROR_EXE_MARKED_INVALID:
                case ERROR_INVALID_EXE_SIGNATURE:

                    ShowErr( IDS_ERR_11, NULL, NULL);
                    DoExit( IDS_ERR_11);
                    break;

                default:

                    if ( usError < ERROR_HANDLE_DISK_FULL )
                    {
                        ShowErr( IDS_ERR_12, _sys_errlist[ usError], NULL);
                        DoExit( IDS_ERR_12);
                    }
                    DoExit( (int)usError);
            }                   //... END switch
#endif

        }
    }
    else if ( fBuildRes )
    {
        if ( argc - iCount < 3 )
        {
            ShowErr( IDS_ERR_01, NULL, NULL);
            Usage();
            DoExit( IDS_ERR_01);
        }

        if ( GenerateImageFile( argv[iCount + 2],
                                argv[iCount],
                                argv[iCount + 1],
                                gMstr.szRdfs,
                                wResTypeFilter) != 1 )
        {
            ShowErr( IDS_ERR_23, argv[iCount + 2], NULL);
            DoExit( IDS_ERR_23);
        }
    }
    else
    {
        Usage();
        DoExit( IDS_ERR_28);
    }
    DoExit( SUCCESS);
}

//...................................................................


void DoExit( int nErrCode)
{

#ifdef _DEBUG

    FreeMemList( NULL);

#endif // _DEBUG

    exit( nErrCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\tct\display.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

#include "display.h"

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*  main() -                                                                 */
/*                                                                           */
/*---------------------------------------------------------------------------*/

VOID __cdecl main(int argc, UCHAR **argv)
{
    int		iStr;
    TCHAR	buf[256];
    HMODULE	hmod;
    HBITMAP	hb;

    printf("System Language is:  %x\n", GetSystemDefaultLangID());
    printf("User Language is:  %x\n\n", GetUserDefaultLangID());

    for (iStr=iStrMin ; iStr<=iStrMax ; iStr++) {
	LoadString(NULL, iStr, buf, 256);
	printf("String %d is:\"%ws\"\n", iStr, buf);
    }

    hmod = GetModuleHandle(NULL);
    if (!hmod)
	printf("No module handle!\n");
    hb = LoadBitmap(hmod, TEXT("ONE"));
    if (!hb)
	printf("ONE not loaded!\n");
    hb = LoadBitmap(hmod, TEXT("TWO"));
    if (!hb)
	printf("TWO not loaded!\n");
    hb = LoadBitmap(hmod, TEXT("THREE"));
    if (!hb)
	printf("THREE not loaded!\n");
    hb = LoadBitmap(hmod, TEXT("FOUR"));
    if (!hb)
	printf("THREE not loaded!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\tct\display.h ===
#define	iStrMin	1
#define	iStrMax	40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\unicode\nlsdata.c ===
/****************************** Module Header ******************************\
* Module Name: nlsdata.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the translation tables used by system character
* translation routines.  These tables are TEMPORARY.  The boot loader
* will be modified to load in the ANSI Code Page (ACP) translation
* tables specified during system installation.  Until then we use these...
*
* History:
* 03-Jan-1992 gregoryw
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>

/*
 * Code Page 1252 (Win 3.1 ANSI) to Unicode translation table.
 * The ANSI code is used as the index into this table to get
 * the corresponding Unicode representation.
 *
 * NOTE: for those ANSI values that are undefined in the Win 3.1
 *       code page (e.g., 0x8d - 0x90 et. al.) the values are
 *       simply zero extended.
 *
 */
WCHAR TmpAnsiToUnicodeTable[256] = {
        0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
        0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
        0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
        0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
        0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
        0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
        0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
        0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
        0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
        0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
        0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
        0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
        0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
        0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
        0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
        0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,
        0x0080, 0x0081, 0x201a, 0x0192, 0x201e, 0x2026, 0x2020, 0x2021,
        0x02c6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008d, 0x008e, 0x008f,
        0x0090, 0x2018, 0x2019, 0x201c, 0x201d, 0x2022, 0x2013, 0x2014,
        0x02dc, 0x2122, 0x0161, 0x203a, 0x0153, 0x009d, 0x009e, 0x0178,
        0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
        0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,
        0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
        0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
        0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
        0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
        0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
        0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
        0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
        0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
        0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
        0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff
};

#ifdef DBCS

USHORT TmpUnicodeToAnsiTable[] = {

    //
    // The first 256 entries are indexed by the high byte of the
    // Unicode character.
    //

 0x100, 0x110, 0x120, 0x130, 0x140, 0x150, 0x160, 0x170,
 0x180, 0x190, 0x1a0, 0x1b0, 0x1c0, 0x1d0, 0x1e0, 0x1f0,
 0x200, 0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x270,
 0x280, 0x290, 0x2a0, 0x2b0, 0x2c0, 0x2d0, 0x2e0, 0x2f0,
 0x300, 0x310, 0x320, 0x330, 0x340, 0x350, 0x360, 0x370,
 0x380, 0x390, 0x3a0, 0x3b0, 0x3c0, 0x3d0, 0x3e0, 0x3f0,
 0x400, 0x410, 0x420, 0x430, 0x440, 0x450, 0x460, 0x470,
 0x480, 0x490, 0x4a0, 0x4b0, 0x4c0, 0x4d0, 0x4e0, 0x4f0,
 0x500, 0x510, 0x520, 0x530, 0x540, 0x550, 0x560, 0x570,
 0x580, 0x590, 0x5a0, 0x5b0, 0x5c0, 0x5d0, 0x5e0, 0x5f0,
 0x600, 0x610, 0x620, 0x630, 0x640, 0x650, 0x660, 0x670,
 0x680, 0x690, 0x6a0, 0x6b0, 0x6c0, 0x6d0, 0x6e0, 0x6f0,
 0x700, 0x710, 0x720, 0x730, 0x740, 0x750, 0x760, 0x770,
 0x780, 0x790, 0x7a0, 0x7b0, 0x7c0, 0x7d0, 0x7e0, 0x7f0,
 0x800, 0x810, 0x820, 0x830, 0x840, 0x850, 0x860, 0x870,
 0x880, 0x890, 0x8a0, 0x8b0, 0x8c0, 0x8d0, 0x8e0, 0x8f0,
 0x900, 0x910, 0x920, 0x930, 0x940, 0x950, 0x960, 0x970,
 0x980, 0x990, 0x9a0, 0x9b0, 0x9c0, 0x9d0, 0x9e0, 0x9f0,
 0xa00, 0xa10, 0xa20, 0xa30, 0xa40, 0xa50, 0xa60, 0xa70,
 0xa80, 0xa90, 0xaa0, 0xab0, 0xac0, 0xad0, 0xae0, 0xaf0,
 0xb00, 0xb10, 0xb20, 0xb30, 0xb40, 0xb50, 0xb60, 0xb70,
 0xb80, 0xb90, 0xba0, 0xbb0, 0xbc0, 0xbd0, 0xbe0, 0xbf0,
 0xc00, 0xc10, 0xc20, 0xc30, 0xc40, 0xc50, 0xc60, 0xc70,
 0xc80, 0xc90, 0xca0, 0xcb0, 0xcc0, 0xcd0, 0xce0, 0xcf0,
 0xd00, 0xd10, 0xd20, 0xd30, 0xd40, 0xd50, 0xd60, 0xd70,
 0xd80, 0xd90, 0xda0, 0xdb0, 0xdc0, 0xdd0, 0xde0, 0xdf0,
 0xe00, 0xe10, 0xe20, 0xe30, 0xe40, 0xe50, 0xe60, 0xe70,
 0xe80, 0xe90, 0xea0, 0xeb0, 0xec0, 0xed0, 0xee0, 0xef0,
 0xf00, 0xf10, 0xf20, 0xf30, 0xf40, 0xf50, 0xf60, 0xf70,
 0xf80, 0xf90, 0xfa0, 0xfb0, 0xfc0, 0xfd0, 0xfe0, 0xff0,
 0x1000, 0x1010, 0x1020, 0x1030, 0x1040, 0x1050, 0x1060, 0x1070,
 0x1080, 0x1090, 0x10a0, 0x10b0, 0x10c0, 0x10d0, 0x10e0, 0x10f0,
    //
    // second level tables begin here.  They are indexed
    // by the high nibble of the low byte (bits 4-7) of
    // the Unicode character.
    //

 0x0, 0x0, 0x1100, 0x1110, 0x1120, 0x1130, 0x1140, 0x1150,
 0x0, 0x0, 0x1160, 0x1170, 0x0, 0x1180, 0x0, 0x1190,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x11a0, 0x11b0, 0x11c0, 0x11d0, 0x0, 0x0, 0x0,
 0x11e0, 0x11f0, 0x1200, 0x1210, 0x1220, 0x1230, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x1240, 0x1250, 0x1260, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x1270, 0x0, 0x0,
 0x1280, 0x0, 0x1290, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x12a0, 0x0, 0x0, 0x0, 0x12b0, 0x0, 0x0,
 0x12c0, 0x12d0, 0x12e0, 0x12f0, 0x0, 0x1300, 0x1310, 0x0,
 0x1320, 0x0, 0x1330, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x1340, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x1350, 0x1360, 0x1370, 0x1380, 0x1390, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x13a0, 0x13b0, 0x13c0, 0x0, 0x0, 0x0,
 0x13d0, 0x0, 0x0, 0x0, 0x13e0, 0x0, 0x13f0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x1400, 0x1410, 0x0, 0x0, 0x1420, 0x1430, 0x1440, 0x1450,
 0x1460, 0x1470, 0x1480, 0x1490, 0x14a0, 0x14b0, 0x14c0, 0x14d0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x14e0, 0x14f0, 0x1500, 0x1510, 0x1520, 0x1530, 0x1540, 0x1550,
 0x1560, 0x1570, 0x1580, 0x1590, 0x15a0, 0x15b0, 0x15c0, 0x15d0,
 0x15e0, 0x15f0, 0x1600, 0x1610, 0x1620, 0x1630, 0x1640, 0x1650,
 0x1660, 0x1670, 0x1680, 0x1690, 0x16a0, 0x16b0, 0x16c0, 0x16d0,
 0x16e0, 0x16f0, 0x1700, 0x1710, 0x1720, 0x1730, 0x1740, 0x1750,
 0x1760, 0x1770, 0x1780, 0x1790, 0x17a0, 0x17b0, 0x17c0, 0x17d0,
 0x17e0, 0x17f0, 0x1800, 0x1810, 0x1820, 0x1830, 0x1840, 0x1850,
 0x1860, 0x1870, 0x1880, 0x1890, 0x18a0, 0x18b0, 0x18c0, 0x18d0,
 0x18e0, 0x18f0, 0x1900, 0x1910, 0x1920, 0x1930, 0x1940, 0x1950,
 0x1960, 0x1970, 0x1980, 0x1990, 0x19a0, 0x19b0, 0x19c0, 0x19d0,
 0x19e0, 0x19f0, 0x1a00, 0x1a10, 0x1a20, 0x1a30, 0x1a40, 0x1a50,
 0x1a60, 0x1a70, 0x1a80, 0x1a90, 0x1aa0, 0x1ab0, 0x1ac0, 0x1ad0,
 0x1ae0, 0x1af0, 0x1b00, 0x1b10, 0x1b20, 0x1b30, 0x1b40, 0x1b50,
 0x1b60, 0x1b70, 0x1b80, 0x1b90, 0x1ba0, 0x1bb0, 0x1bc0, 0x1bd0,
 0x1be0, 0x1bf0, 0x0, 0x1c00, 0x1c10, 0x1c20, 0x1c30, 0x1c40,
 0x1c50, 0x1c60, 0x1c70, 0x1c80, 0x1c90, 0x1ca0, 0x1cb0, 0x1cc0,
 0x1cd0, 0x1ce0, 0x1cf0, 0x1d00, 0x1d10, 0x1d20, 0x1d30, 0x1d40,
 0x1d50, 0x1d60, 0x1d70, 0x1d80, 0x1d90, 0x1da0, 0x1db0, 0x1dc0,
 0x1dd0, 0x1de0, 0x1df0, 0x1e00, 0x1e10, 0x1e20, 0x1e30, 0x1e40,
 0x1e50, 0x1e60, 0x1e70, 0x1e80, 0x1e90, 0x1ea0, 0x1eb0, 0x1ec0,
 0x1ed0, 0x1ee0, 0x1ef0, 0x1f00, 0x1f10, 0x1f20, 0x1f30, 0x1f40,
 0x1f50, 0x1f60, 0x1f70, 0x1f80, 0x1f90, 0x1fa0, 0x1fb0, 0x1fc0,
 0x1fd0, 0x1fe0, 0x1ff0, 0x2000, 0x2010, 0x2020, 0x2030, 0x2040,
 0x2050, 0x2060, 0x2070, 0x2080, 0x2090, 0x20a0, 0x20b0, 0x20c0,
 0x20d0, 0x20e0, 0x20f0, 0x2100, 0x2110, 0x2120, 0x2130, 0x2140,
 0x0, 0x2150, 0x0, 0x2160, 0x2170, 0x2180, 0x2190, 0x21a0,
 0x21b0, 0x21c0, 0x21d0, 0x21e0, 0x21f0, 0x2200, 0x2210, 0x2220,
 0x2230, 0x2240, 0x2250, 0x2260, 0x2270, 0x2280, 0x2290, 0x22a0,
 0x22b0, 0x22c0, 0x22d0, 0x22e0, 0x22f0, 0x2300, 0x2310, 0x2320,
 0x2330, 0x2340, 0x2350, 0x2360, 0x2370, 0x2380, 0x2390, 0x23a0,
 0x23b0, 0x23c0, 0x23d0, 0x0, 0x23e0, 0x23f0, 0x2400, 0x2410,
 0x2420, 0x2430, 0x2440, 0x2450, 0x2460, 0x2470, 0x2480, 0x2490,
 0x24a0, 0x24b0, 0x24c0, 0x24d0, 0x24e0, 0x24f0, 0x2500, 0x2510,
 0x2520, 0x2530, 0x2540, 0x2550, 0x2560, 0x2570, 0x2580, 0x2590,
 0x25a0, 0x25b0, 0x25c0, 0x25d0, 0x25e0, 0x25f0, 0x2600, 0x2610,
 0x2620, 0x2630, 0x2640, 0x2650, 0x2660, 0x2670, 0x2680, 0x2690,
 0x26a0, 0x26b0, 0x26c0, 0x26d0, 0x26e0, 0x26f0, 0x2700, 0x2710,
 0x2720, 0x2730, 0x2740, 0x2750, 0x2760, 0x2770, 0x2780, 0x2790,
 0x27a0, 0x27b0, 0x27c0, 0x27d0, 0x27e0, 0x27f0, 0x2800, 0x2810,
 0x2820, 0x2830, 0x2840, 0x2850, 0x2860, 0x0, 0x2870, 0x2880,
 0x2890, 0x28a0, 0x28b0, 0x28c0, 0x28d0, 0x28e0, 0x28f0, 0x2900,
 0x2910, 0x2920, 0x2930, 0x2940, 0x2950, 0x2960, 0x2970, 0x2980,
 0x2990, 0x29a0, 0x29b0, 0x29c0, 0x29d0, 0x29e0, 0x29f0, 0x2a00,
 0x2a10, 0x2a20, 0x2a30, 0x2a40, 0x2a50, 0x2a60, 0x2a70, 0x2a80,
 0x2a90, 0x2aa0, 0x2ab0, 0x2ac0, 0x2ad0, 0x2ae0, 0x2af0, 0x2b00,
 0x2b10, 0x2b20, 0x2b30, 0x2b40, 0x2b50, 0x2b60, 0x2b70, 0x2b80,
 0x2b90, 0x2ba0, 0x2bb0, 0x2bc0, 0x2bd0, 0x2be0, 0x2bf0, 0x2c00,
 0x2c10, 0x2c20, 0x2c30, 0x2c40, 0x2c50, 0x2c60, 0x2c70, 0x2c80,
 0x2c90, 0x2ca0, 0x2cb0, 0x2cc0, 0x2cd0, 0x2ce0, 0x2cf0, 0x2d00,
 0x2d10, 0x2d20, 0x2d30, 0x2d40, 0x2d50, 0x2d60, 0x2d70, 0x2d80,
 0x2d90, 0x2da0, 0x2db0, 0x2dc0, 0x2dd0, 0x2de0, 0x2df0, 0x2e00,
 0x2e10, 0x2e20, 0x2e30, 0x2e40, 0x2e50, 0x2e60, 0x2e70, 0x2e80,
 0x2e90, 0x2ea0, 0x2eb0, 0x2ec0, 0x2ed0, 0x2ee0, 0x2ef0, 0x2f00,
 0x2f10, 0x2f20, 0x2f30, 0x2f40, 0x2f50, 0x2f60, 0x2f70, 0x2f80,
 0x2f90, 0x2fa0, 0x2fb0, 0x2fc0, 0x2fd0, 0x2fe0, 0x2ff0, 0x3000,
 0x3010, 0x3020, 0x3030, 0x3040, 0x3050, 0x3060, 0x3070, 0x3080,
 0x3090, 0x30a0, 0x30b0, 0x30c0, 0x30d0, 0x30e0, 0x30f0, 0x3100,
 0x3110, 0x3120, 0x3130, 0x3140, 0x3150, 0x3160, 0x3170, 0x3180,
 0x3190, 0x31a0, 0x31b0, 0x31c0, 0x31d0, 0x31e0, 0x31f0, 0x3200,
 0x3210, 0x3220, 0x3230, 0x3240, 0x3250, 0x3260, 0x3270, 0x3280,
 0x3290, 0x32a0, 0x32b0, 0x32c0, 0x32d0, 0x32e0, 0x32f0, 0x3300,
 0x3310, 0x3320, 0x3330, 0x3340, 0x3350, 0x3360, 0x3370, 0x3380,
 0x3390, 0x33a0, 0x33b0, 0x33c0, 0x33d0, 0x33e0, 0x33f0, 0x3400,
 0x3410, 0x3420, 0x3430, 0x3440, 0x3450, 0x3460, 0x3470, 0x3480,
 0x3490, 0x34a0, 0x34b0, 0x34c0, 0x34d0, 0x34e0, 0x34f0, 0x3500,
 0x3510, 0x3520, 0x3530, 0x3540, 0x3550, 0x3560, 0x3570, 0x3580,
 0x3590, 0x35a0, 0x35b0, 0x35c0, 0x35d0, 0x35e0, 0x35f0, 0x3600,
 0x3610, 0x3620, 0x3630, 0x3640, 0x3650, 0x3660, 0x3670, 0x3680,
 0x3690, 0x36a0, 0x36b0, 0x36c0, 0x36d0, 0x36e0, 0x36f0, 0x3700,
 0x3710, 0x3720, 0x3730, 0x3740, 0x3750, 0x3760, 0x0, 0x3770,
 0x3780, 0x3790, 0x37a0, 0x37b0, 0x37c0, 0x37d0, 0x37e0, 0x37f0,
 0x3800, 0x3810, 0x3820, 0x3830, 0x3840, 0x3850, 0x3860, 0x3870,
 0x3880, 0x3890, 0x38a0, 0x38b0, 0x38c0, 0x38d0, 0x38e0, 0x38f0,
 0x3900, 0x3910, 0x3920, 0x3930, 0x3940, 0x3950, 0x3960, 0x3970,
 0x3980, 0x3990, 0x39a0, 0x39b0, 0x39c0, 0x39d0, 0x39e0, 0x39f0,
 0x3a00, 0x3a10, 0x3a20, 0x3a30, 0x3a40, 0x3a50, 0x3a60, 0x3a70,
 0x3a80, 0x0, 0x3a90, 0x3aa0, 0x3ab0, 0x3ac0, 0x3ad0, 0x3ae0,
 0x3af0, 0x3b00, 0x3b10, 0x3b20, 0x3b30, 0x3b40, 0x3b50, 0x3b60,
 0x3b70, 0x3b80, 0x3b90, 0x3ba0, 0x3bb0, 0x3bc0, 0x3bd0, 0x3be0,
 0x3bf0, 0x3c00, 0x3c10, 0x3c20, 0x3c30, 0x3c40, 0x3c50, 0x3c60,
 0x3c70, 0x3c80, 0x3c90, 0x3ca0, 0x3cb0, 0x3cc0, 0x3cd0, 0x3ce0,
 0x3cf0, 0x3d00, 0x3d10, 0x3d20, 0x3d30, 0x3d40, 0x3d50, 0x3d60,
 0x3d70, 0x3d80, 0x3d90, 0x3da0, 0x3db0, 0x3dc0, 0x3dd0, 0x3de0,
 0x3df0, 0x3e00, 0x3e10, 0x3e20, 0x3e30, 0x3e40, 0x3e50, 0x3e60,
 0x3e70, 0x3e80, 0x3e90, 0x3ea0, 0x3eb0, 0x3ec0, 0x3ed0, 0x3ee0,
 0x3ef0, 0x3f00, 0x3f10, 0x3f20, 0x3f30, 0x3f40, 0x3f50, 0x3f60,
 0x3f70, 0x3f80, 0x3f90, 0x3fa0, 0x3fb0, 0x3fc0, 0x3fd0, 0x3fe0,
 0x3ff0, 0x4000, 0x4010, 0x4020, 0x4030, 0x4040, 0x4050, 0x4060,
 0x4070, 0x4080, 0x4090, 0x40a0, 0x40b0, 0x40c0, 0x40d0, 0x40e0,
 0x40f0, 0x4100, 0x4110, 0x4120, 0x4130, 0x4140, 0x4150, 0x4160,
 0x4170, 0x4180, 0x4190, 0x41a0, 0x41b0, 0x41c0, 0x41d0, 0x41e0,
 0x41f0, 0x4200, 0x4210, 0x4220, 0x4230, 0x4240, 0x4250, 0x4260,
 0x4270, 0x4280, 0x4290, 0x42a0, 0x42b0, 0x42c0, 0x42d0, 0x42e0,
 0x42f0, 0x4300, 0x4310, 0x4320, 0x4330, 0x4340, 0x4350, 0x4360,
 0x4370, 0x4380, 0x4390, 0x43a0, 0x43b0, 0x43c0, 0x43d0, 0x43e0,
 0x43f0, 0x4400, 0x4410, 0x4420, 0x4430, 0x4440, 0x4450, 0x4460,
 0x4470, 0x4480, 0x4490, 0x44a0, 0x44b0, 0x44c0, 0x44d0, 0x44e0,
 0x44f0, 0x4500, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x4510, 0x4520, 0x4530, 0x4540, 0x4550,
 0x4560, 0x4570, 0x4580, 0x4590, 0x45a0, 0x45b0, 0x45c0, 0x45d0,
 0x45e0, 0x45f0, 0x4600, 0x4610, 0x4620, 0x4630, 0x4640, 0x4650,
 0x4660, 0x4670, 0x4680, 0x4690, 0x46a0, 0x46b0, 0x46c0, 0x46d0,
 0x46e0, 0x46f0, 0x4700, 0x4710, 0x4720, 0x4730, 0x4740, 0x4750,
 0x4760, 0x4770, 0x4780, 0x4790, 0x47a0, 0x47b0, 0x47c0, 0x47d0,
 0x47e0, 0x47f0, 0x4800, 0x4810, 0x4820, 0x4830, 0x4840, 0x4850,
 0x4860, 0x4870, 0x4880, 0x4890, 0x48a0, 0x48b0, 0x48c0, 0x48d0,
 0x48e0, 0x48f0, 0x4900, 0x4910, 0x4920, 0x4930, 0x0, 0x4940,
 0x4950, 0x4960, 0x4970, 0x4980, 0x4990, 0x49a0, 0x49b0, 0x49c0,
 0x49d0, 0x49e0, 0x49f0, 0x4a00, 0x4a10, 0x4a20, 0x4a30, 0x4a40,
 0x4a50, 0x4a60, 0x4a70, 0x4a80, 0x4a90, 0x4aa0, 0x4ab0, 0x4ac0,
 0x4ad0, 0x4ae0, 0x4af0, 0x4b00, 0x4b10, 0x4b20, 0x4b30, 0x4b40,
 0x4b50, 0x4b60, 0x4b70, 0x4b80, 0x4b90, 0x4ba0, 0x4bb0, 0x4bc0,
 0x4bd0, 0x4be0, 0x4bf0, 0x4c00, 0x4c10, 0x4c20, 0x4c30, 0x4c40,
 0x4c50, 0x4c60, 0x4c70, 0x4c80, 0x4c90, 0x4ca0, 0x4cb0, 0x4cc0,
 0x4cd0, 0x4ce0, 0x4cf0, 0x4d00, 0x4d10, 0x4d20, 0x4d30, 0x4d40,
 0x4d50, 0x4d60, 0x4d70, 0x4d80, 0x4d90, 0x4da0, 0x4db0, 0x4dc0,
 0x4dd0, 0x4de0, 0x4df0, 0x4e00, 0x4e10, 0x4e20, 0x4e30, 0x4e40,
 0x4e50, 0x4e60, 0x4e70, 0x4e80, 0x4e90, 0x4ea0, 0x4eb0, 0x4ec0,
 0x4ed0, 0x4ee0, 0x4ef0, 0x4f00, 0x4f10, 0x4f20, 0x4f30, 0x4f40,
 0x4f50, 0x4f60, 0x4f70, 0x4f80, 0x4f90, 0x4fa0, 0x4fb0, 0x4fc0,
 0x4fd0, 0x4fe0, 0x4ff0, 0x5000, 0x5010, 0x5020, 0x5030, 0x5040,
 0x5050, 0x5060, 0x5070, 0x5080, 0x5090, 0x50a0, 0x50b0, 0x50c0,
 0x50d0, 0x50e0, 0x50f0, 0x5100, 0x5110, 0x5120, 0x5130, 0x5140,
 0x5150, 0x5160, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x5170, 0x5180, 0x5190, 0x51a0, 0x51b0,
 0x51c0, 0x51d0, 0x51e0, 0x51f0, 0x5200, 0x5210, 0x5220, 0x5230,
 0x5240, 0x5250, 0x0, 0x0, 0x0, 0x0, 0x5260, 0x5270,
 0x5280, 0x5290, 0x52a0, 0x52b0, 0x52c0, 0x52d0, 0x52e0, 0x52f0,
 0x5300, 0x5310, 0x5320, 0x5330, 0x5340, 0x5350, 0x5360, 0x5370,
 0x5380, 0x5390, 0x53a0, 0x53b0, 0x53c0, 0x53d0, 0x53e0, 0x53f0,
 0x5400, 0x5410, 0x5420, 0x5430, 0x5440, 0x5450, 0x5460, 0x0,
 0x0, 0x5470, 0x5480, 0x5490, 0x54a0, 0x54b0, 0x54c0, 0x54d0,
 0x54e0, 0x54f0, 0x5500, 0x5510, 0x5520, 0x5530, 0x5540, 0x5550,
 0x5560, 0x5570, 0x5580, 0x5590, 0x55a0, 0x55b0, 0x55c0, 0x55d0,
 0x55e0, 0x55f0, 0x5600, 0x5610, 0x5620, 0x5630, 0x5640, 0x5650,
 0x5660, 0x5670, 0x5680, 0x5690, 0x56a0, 0x56b0, 0x56c0, 0x56d0,
 0x56e0, 0x56f0, 0x5700, 0x5710, 0x5720, 0x5730, 0x5740, 0x5750,
 0x5760, 0x5770, 0x5780, 0x5790, 0x0, 0x57a0, 0x57b0, 0x57c0,
 0x57d0, 0x57e0, 0x57f0, 0x5800, 0x5810, 0x5820, 0x5830, 0x5840,
 0x5850, 0x5860, 0x5870, 0x5880, 0x5890, 0x58a0, 0x58b0, 0x0,
 0x58c0, 0x58d0, 0x58e0, 0x58f0, 0x5900, 0x5910, 0x5920, 0x5930,
 0x5940, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5950,
 0x5960, 0x5970, 0x5980, 0x5990, 0x59a0, 0x59b0, 0x59c0, 0x0,
 0x0, 0x59d0, 0x59e0, 0x59f0, 0x5a00, 0x5a10, 0x5a20, 0x5a30,
 0x5a40, 0x5a50, 0x5a60, 0x5a70, 0x5a80, 0x5a90, 0x5aa0, 0x5ab0,
 0x5ac0, 0x5ad0, 0x5ae0, 0x5af0, 0x5b00, 0x5b10, 0x5b20, 0x5b30,
 0x5b40, 0x5b50, 0x5b60, 0x5b70, 0x5b80, 0x5b90, 0x5ba0, 0x5bb0,
 0x5bc0, 0x5bd0, 0x5be0, 0x5bf0, 0x5c00, 0x5c10, 0x5c20, 0x5c30,
 0x0, 0x0, 0x5c40, 0x5c50, 0x5c60, 0x5c70, 0x5c80, 0x5c90,
 0x5ca0, 0x5cb0, 0x5cc0, 0x5cd0, 0x5ce0, 0x5cf0, 0x0, 0x0,
 0x0, 0x5d00, 0x5d10, 0x5d20, 0x5d30, 0x5d40, 0x5d50, 0x5d60,
 0x5d70, 0x5d80, 0x5d90, 0x5da0, 0x5db0, 0x5dc0, 0x5dd0, 0x0,
 0x0, 0x0, 0x5de0, 0x5df0, 0x5e00, 0x5e10, 0x5e20, 0x5e30,
 0x5e40, 0x5e50, 0x5e60, 0x5e70, 0x5e80, 0x5e90, 0x0, 0x5ea0,
 0x5eb0, 0x5ec0, 0x5ed0, 0x5ee0, 0x5ef0, 0x5f00, 0x5f10, 0x5f20,
 0x5f30, 0x5f40, 0x5f50, 0x5f60, 0x5f70, 0x5f80, 0x5f90, 0x5fa0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5fb0, 0x5fc0,
 0x5fd0, 0x5fe0, 0x5ff0, 0x6000, 0x6010, 0x6020, 0x6030, 0x6040,
 0x6050, 0x6060, 0x6070, 0x6080, 0x6090, 0x60a0, 0x60b0, 0x60c0,
 0x0, 0x60d0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60e0,
 0x60f0, 0x6100, 0x6110, 0x6120, 0x6130, 0x6140, 0x6150, 0x6160,
 0x6170, 0x6180, 0x6190, 0x61a0, 0x61b0, 0x61c0, 0x61d0, 0x61e0,
 0x61f0, 0x6200, 0x6210, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x6220, 0x6230, 0x6240, 0x6250, 0x6260, 0x6270, 0x6280, 0x6290,
 0x62a0, 0x62b0, 0x0, 0x0, 0x0, 0x0, 0x62c0, 0x0,
    //
    // third level tables begin here.  They are indexed
    // by the low nibble of the low byte (bits 0x0-3) of
    // the Unicode character.
    //

 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x0, 0x7f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8198,
 0x814e, 0x0, 0x0, 0x0, 0x0, 0x815d, 0x0, 0x7e,
 0x818b, 0x817d, 0x0, 0x0, 0x814c, 0x0, 0x81f7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x817e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8180,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x839f, 0x83a0, 0x83a1, 0x83a2, 0x83a3, 0x83a4, 0x83a5,
 0x83a6, 0x83a7, 0x83a8, 0x83a9, 0x83aa, 0x83ab, 0x83ac, 0x83ad,
 0x83ae, 0x83af, 0x0, 0x83b0, 0x83b1, 0x83b2, 0x83b3, 0x83b4,
 0x83b5, 0x83b6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x83bf, 0x83c0, 0x83c1, 0x83c2, 0x83c3, 0x83c4, 0x83c5,
 0x83c6, 0x83c7, 0x83c8, 0x83c9, 0x83ca, 0x83cb, 0x83cc, 0x83cd,
 0x83ce, 0x83cf, 0x0, 0x83d0, 0x83d1, 0x83d2, 0x83d3, 0x83d4,
 0x83d5, 0x83d6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8446, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8440, 0x8441, 0x8442, 0x8443, 0x8444, 0x8445, 0x8447, 0x8448,
 0x8449, 0x844a, 0x844b, 0x844c, 0x844d, 0x844e, 0x844f, 0x8450,
 0x8451, 0x8452, 0x8453, 0x8454, 0x8455, 0x8456, 0x8457, 0x8458,
 0x8459, 0x845a, 0x845b, 0x845c, 0x845d, 0x845e, 0x845f, 0x8460,
 0x8470, 0x8471, 0x8472, 0x8473, 0x8474, 0x8475, 0x8477, 0x8478,
 0x8479, 0x847a, 0x847b, 0x847c, 0x847d, 0x847e, 0x8480, 0x8481,
 0x8482, 0x8483, 0x8484, 0x8485, 0x8486, 0x8487, 0x8488, 0x8489,
 0x848a, 0x848b, 0x848c, 0x848d, 0x848e, 0x848f, 0x8490, 0x8491,
 0x0, 0x8476, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x815c, 0x0, 0x0,
 0x8165, 0x8166, 0x0, 0x0, 0x8167, 0x8168, 0x0, 0x0,
 0x81f5, 0x81f6, 0x0, 0x0, 0x0, 0x8164, 0x8163, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x81f1, 0x0, 0x818c, 0x818d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x81a6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x81fc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x818e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x81f0, 0x0, 0x0, 0x0, 0x0,
 0x81a9, 0x81aa, 0x81a8, 0x81ab, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81cb, 0x0, 0x81cc, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x81cd, 0x0, 0x81dd, 0x81ce, 0x0, 0x0, 0x0, 0x81de,
 0x81b8, 0x0, 0x0, 0x81b9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81e3, 0x0, 0x0, 0x81e5, 0x8187, 0x0,
 0x81da, 0x0, 0x0, 0x0, 0x0, 0x8161, 0x0, 0x81c8,
 0x81c9, 0x81bf, 0x81be, 0x81e7, 0x81e8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8188, 0x81e6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x81e4, 0x0, 0x0,
 0x0, 0x0, 0x81e0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8182, 0x81df, 0x0, 0x0, 0x0, 0x0, 0x8185, 0x8186,
 0x0, 0x0, 0x81e1, 0x81e2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81bc, 0x81bd, 0x0, 0x0, 0x81ba, 0x81bb,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x81db, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81dc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x849f, 0x84aa, 0x84a0, 0x84ab, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x84a1, 0x0, 0x0, 0x84ac,
 0x84a2, 0x0, 0x0, 0x84ad, 0x84a4, 0x0, 0x0, 0x84af,
 0x84a3, 0x0, 0x0, 0x84ae, 0x84a5, 0x84ba, 0x0, 0x0,
 0x84b5, 0x0, 0x0, 0x84b0, 0x84a7, 0x84bc, 0x0, 0x0,
 0x84b7, 0x0, 0x0, 0x84b2, 0x84a6, 0x0, 0x0, 0x84b6,
 0x84bb, 0x0, 0x0, 0x84b1, 0x84a8, 0x0, 0x0, 0x84b8,
 0x84bd, 0x0, 0x0, 0x84b3, 0x84a9, 0x0, 0x0, 0x84b9,
 0x0, 0x0, 0x84be, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x84b4, 0x0, 0x0, 0x0, 0x0,
 0x81a1, 0x81a0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81a3, 0x81a2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x81a5, 0x81a4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x819f, 0x819e,
 0x0, 0x0, 0x0, 0x819b, 0x0, 0x0, 0x819d, 0x819c,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x819a, 0x8199, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x818a, 0x0, 0x8189, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x81f4, 0x0, 0x0, 0x81f3, 0x0, 0x81f2,
 0x8140, 0x8141, 0x8142, 0x8156, 0x8157, 0x8158, 0x8159, 0x815a,
 0x8171, 0x8172, 0x8173, 0x8174, 0x8175, 0x8176, 0x8177, 0x8178,
 0x8179, 0x817a, 0x81a7, 0x81ac, 0x816b, 0x816c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x829f, 0x82a0, 0x82a1, 0x82a2, 0x82a3, 0x82a4, 0x82a5,
 0x82a6, 0x82a7, 0x82a8, 0x82a9, 0x82aa, 0x82ab, 0x82ac, 0x82ad,
 0x82ae, 0x82af, 0x82b0, 0x82b1, 0x82b2, 0x82b3, 0x82b4, 0x82b5,
 0x82b6, 0x82b7, 0x82b8, 0x82b9, 0x82ba, 0x82bb, 0x82bc, 0x82bd,
 0x82be, 0x82bf, 0x82c0, 0x82c1, 0x82c2, 0x82c3, 0x82c4, 0x82c5,
 0x82c6, 0x82c7, 0x82c8, 0x82c9, 0x82ca, 0x82cb, 0x82cc, 0x82cd,
 0x82ce, 0x82cf, 0x82d0, 0x82d1, 0x82d2, 0x82d3, 0x82d4, 0x82d5,
 0x82d6, 0x82d7, 0x82d8, 0x82d9, 0x82da, 0x82db, 0x82dc, 0x82dd,
 0x82de, 0x82df, 0x82e0, 0x82e1, 0x82e2, 0x82e3, 0x82e4, 0x82e5,
 0x82e6, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82eb, 0x82ec, 0x82ed,
 0x82ee, 0x82ef, 0x82f0, 0x82f1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x814a, 0x814b, 0x8154, 0x8155, 0x0,
 0x0, 0x8340, 0x8341, 0x8342, 0x8343, 0x8344, 0x8345, 0x8346,
 0x8347, 0x8348, 0x8349, 0x834a, 0x834b, 0x834c, 0x834d, 0x834e,
 0x834f, 0x8350, 0x8351, 0x8352, 0x8353, 0x8354, 0x8355, 0x8356,
 0x8357, 0x8358, 0x8359, 0x835a, 0x835b, 0x835c, 0x835d, 0x835e,
 0x835f, 0x8360, 0x8361, 0x8362, 0x8363, 0x8364, 0x8365, 0x8366,
 0x8367, 0x8368, 0x8369, 0x836a, 0x836b, 0x836c, 0x836d, 0x836e,
 0x836f, 0x8370, 0x8371, 0x8372, 0x8373, 0x8374, 0x8375, 0x8376,
 0x8377, 0x8378, 0x8379, 0x837a, 0x837b, 0x837c, 0x837d, 0x837e,
 0x8380, 0x8381, 0x8382, 0x8383, 0x8384, 0x8385, 0x8386, 0x8387,
 0x8388, 0x8389, 0x838a, 0x838b, 0x838c, 0x838d, 0x838e, 0x838f,
 0x8390, 0x8391, 0x8392, 0x8393, 0x8394, 0x8395, 0x8396, 0x0,
 0x0, 0x0, 0x0, 0x8145, 0x815b, 0x8152, 0x8153, 0x0,
 0x88ea, 0x929a, 0x0, 0x8eb5, 0x0, 0x0, 0x0, 0x969c,
 0x8fe4, 0x8e4f, 0x8fe3, 0x89ba, 0x0, 0x9573, 0x975e, 0x0,
 0x98a0, 0x894e, 0x0, 0x0, 0x8a8e, 0x98a1, 0x90a2, 0x99c0,
 0x8b75, 0x95b8, 0x0, 0x0, 0x0, 0x0, 0x8fe5, 0x0,
 0x0, 0x97bc, 0x0, 0x0, 0x0, 0x0, 0x95c0, 0x0,
 0x0, 0x0, 0x98a2, 0x0, 0x0, 0x9286, 0x0, 0x0,
 0x0, 0x98a3, 0x8bf8, 0x0, 0x0, 0x0, 0x98a4, 0x0,
 0x8adb, 0x924f, 0x0, 0x8ee5, 0x98a5, 0x0, 0x0, 0x98a6,
 0x0, 0x0, 0x98a7, 0x9454, 0x0, 0x8b76, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9456, 0x0, 0x93e1, 0x8cc1, 0x9652,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe568, 0x98a8, 0x8fe6,
 0x98a9, 0x89b3, 0x0, 0x0, 0x0, 0x8be3, 0x8cee, 0x96e7,
 0x0, 0x0, 0x9ba4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9790, 0x0, 0x93fb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8aa3, 0x0,
 0x8b54, 0x0, 0x98aa, 0x0, 0x0, 0x98ab, 0x97b9, 0x0,
 0x975c, 0x9188, 0x98ad, 0x8e96, 0x93f1, 0x0, 0x98b0, 0x0,
 0x0, 0x895d, 0x8cdd, 0x0, 0x8cdc, 0x88e4, 0x0, 0x0,
 0x986a, 0x9869, 0x0, 0x8db1, 0x889f, 0x0, 0x98b1, 0x98b2,
 0x98b3, 0x9653, 0x98b4, 0x0, 0x8cf0, 0x88e5, 0x9692, 0x0,
 0x8b9c, 0x0, 0x0, 0x8b9d, 0x8b9e, 0x92e0, 0x97ba, 0x0,
 0x98b5, 0x0, 0x0, 0x98b6, 0x0, 0x0, 0x98b7, 0x0,
 0x0, 0x0, 0x906c, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8f59, 0x906d, 0x98bc, 0x0, 0x98ba, 0x0, 0x98bb, 0x8b77,
 0x0, 0x0, 0x8da1, 0x89ee, 0x0, 0x98b9, 0x98b8, 0x95a7,
 0x0, 0x0, 0x0, 0x0, 0x8e65, 0x8e64, 0x91bc, 0x98bd,
 0x9574, 0x90e5, 0x0, 0x0, 0x0, 0x0, 0x98be, 0x98c0,
 0x0, 0x0, 0x0, 0x91e3, 0x97df, 0x88c8, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x98bf, 0x89bc, 0x0,
 0x8bc2, 0x0, 0x9287, 0x0, 0x0, 0x0, 0x8c8f, 0x98c1,
 0x0, 0x0, 0x0, 0x9443, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8ae9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x98c2, 0x88c9, 0x0, 0x0, 0x8cde, 0x8aea, 0x959a,
 0x94b0, 0x8b78, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89ef, 0x0, 0x98e5, 0x9360, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x948c,
 0x98c4, 0x0, 0x0, 0x0, 0x94ba, 0x0, 0x97e0, 0x0,
 0x904c, 0x0, 0x8e66, 0x0, 0x8e97, 0x89be, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x92cf, 0x0, 0x0, 0x9241, 0x98c8,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x88ca, 0x92e1, 0x8f5a,
 0x8db2, 0x9743, 0x0, 0x91cc, 0x0, 0x89bd, 0x0, 0x98c7,
 0x0, 0x975d, 0x98c3, 0x98c5, 0x8dec, 0x98c6, 0x9b43, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x98ce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x98d1,
 0x98cf, 0x0, 0x0, 0x89c0, 0x0, 0x95b9, 0x98c9, 0x0,
 0x0, 0x0, 0x0, 0x98cd, 0x8cf1, 0x0, 0x0, 0x8e67,
 0x0, 0x0, 0x0, 0x8aa4, 0x0, 0x0, 0x98d2, 0x0,
 0x98ca, 0x0, 0x0, 0x97e1, 0x0, 0x8e98, 0x0, 0x98cb,
 0x0, 0x98d0, 0x0, 0x0, 0x0, 0x0, 0x98d3, 0x0,
 0x98cc, 0x0, 0x0, 0x8b9f, 0x0, 0x88cb, 0x0, 0x0,
 0x8ba0, 0x89bf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9b44, 0x0, 0x9699, 0x958e, 0x8cf2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x904e, 0x97b5, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95d6,
 0x0, 0x0, 0x8c57, 0x91a3, 0x89e2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8f72, 0x0, 0x0, 0x0, 0x98d7, 0x0,
 0x98dc, 0x98da, 0x0, 0x0, 0x98d5, 0x0, 0x0, 0x91ad,
 0x98d8, 0x0, 0x98db, 0x98d9, 0x0, 0x95db, 0x0, 0x98d6,
 0x0, 0x904d, 0x9693, 0x0, 0x98dd, 0x98de, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f43, 0x98eb,
 0x0, 0x0, 0x0, 0x946f, 0x0, 0x9555, 0x98e6, 0x0,
 0x95ee, 0x0, 0x89b4, 0x0, 0x0, 0x0, 0x98ea, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x98e4, 0x98ed, 0x0,
 0x0, 0x9171, 0x0, 0x8cc2, 0x0, 0x947b, 0x0, 0xe0c5,
 0x0, 0x98ec, 0x937c, 0x0, 0x98e1, 0x0, 0x8cf4, 0x0,
 0x0, 0x8cf3, 0x98df, 0x0, 0x0, 0x0, 0x0, 0x8ed8,
 0x0, 0x98e7, 0x0, 0x95ed, 0x926c, 0x98e3, 0x8c91, 0x0,
 0x98e0, 0x98e8, 0x98e2, 0x97cf, 0x98e9, 0x9860, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8be4, 0x0,
 0x0, 0x8c90, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x98ee, 0x0, 0x0, 0x0, 0x98ef,
 0x98f3, 0x88cc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95ce,
 0x98f2, 0x0, 0x0, 0x0, 0x0, 0x98f1, 0x98f5, 0x0,
 0x0, 0x0, 0x98f4, 0x0, 0x92e2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c92, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x98f6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ec3, 0x0, 0x91a4, 0x92e3, 0x8bf4, 0x0,
 0x98f7, 0x0, 0x0, 0x0, 0x0, 0x8b55, 0x0, 0x0,
 0x98f8, 0x0, 0x0, 0x0, 0x0, 0x98fa, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9654, 0x0, 0x0,
 0x0, 0x8c86, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8e50, 0x94f5, 0x98f9, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8dc3, 0x9762, 0x0, 0x0,
 0x0, 0x0, 0x98fc, 0x9942, 0x98fb, 0x8dc2, 0x0, 0x8f9d,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c58, 0x0,
 0x0, 0x0, 0x9943, 0x0, 0x0, 0x8bcd, 0x0, 0x0,
 0x0, 0x9940, 0x9941, 0x0, 0x0, 0x93ad, 0x0, 0x919c,
 0x0, 0x8ba1, 0x0, 0x0, 0x0, 0x966c, 0x9944, 0x0,
 0x0, 0x0, 0x97bb, 0x0, 0x0, 0x0, 0x9945, 0x0,
 0x0, 0x0, 0x0, 0x9948, 0x0, 0x9946, 0x0, 0x916d,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9947, 0x9949, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x994b, 0x0, 0x0,
 0x0, 0x994a, 0x0, 0x95c6, 0x0, 0x0, 0x0, 0x0,
 0x8b56, 0x994d, 0x994e, 0x0, 0x89ad, 0x0, 0x0, 0x0,
 0x0, 0x994c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ef2, 0x0, 0x9951, 0x9950, 0x994f, 0x0,
 0x98d4, 0x0, 0x9952, 0x0, 0x0, 0x0, 0x0, 0x8f9e,
 0x0, 0x9953, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9744, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x96d7, 0x0, 0x0, 0x0, 0x0, 0x9955,
 0x0, 0x0, 0x9954, 0x9957, 0x9956, 0x0, 0x0, 0x9958,
 0x9959, 0x88f2, 0x0, 0x8cb3, 0x8c5a, 0x8f5b, 0x929b, 0x8ba2,
 0x90e6, 0x8cf5, 0x0, 0x8d8e, 0x995b, 0x96c6, 0x9365, 0x0,
 0x8e99, 0x0, 0x995a, 0x0, 0x995c, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x937d, 0x0, 0x8a95, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x995d, 0x0, 0x0, 0x93fc, 0x0, 0x0,
 0x9153, 0x995f, 0x9960, 0x94aa, 0x8cf6, 0x985a, 0x9961, 0x0,
 0x0, 0x8ba4, 0x0, 0x0, 0x0, 0x95ba, 0x91b4, 0x8bef,
 0x9354, 0x0, 0x0, 0x0, 0x8c93, 0x0, 0x0, 0x0,
 0x9962, 0x0, 0x9963, 0x0, 0x0, 0x93e0, 0x897e, 0x0,
 0x0, 0x9966, 0x8dfb, 0x0, 0x9965, 0x8dc4, 0x0, 0x9967,
 0xe3ec, 0x9968, 0x9660, 0x0, 0x9969, 0x996a, 0x996b, 0x8fe7,
 0x0, 0x8eca, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8aa5, 0x0, 0x996e, 0x0, 0x996c, 0x96bb, 0x996d, 0x0,
 0x9579, 0x996f, 0x9970, 0x9971, 0x937e, 0x0, 0x0, 0x0,
 0x9975, 0x9973, 0x9974, 0x9972, 0x8de1, 0x9976, 0x96e8, 0x97e2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9977, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90a6, 0x9978, 0x8f79, 0x0,
 0x0, 0x9979, 0x0, 0x929c, 0x97bd, 0x9380, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x99c3, 0x0,
 0x0, 0x0, 0x0, 0x997a, 0xeaa3, 0x8bc3, 0x0, 0x0,
 0x997b, 0x967d, 0x0, 0x0, 0x0, 0x0, 0x8f88, 0x91fa,
 0x0, 0x997d, 0x93e2, 0x0, 0x0, 0x997e, 0x0, 0x0,
 0x9980, 0x8a4d, 0x0, 0x0, 0x0, 0x9981, 0x8ba5, 0x0,
 0x93ca, 0x899a, 0x8f6f, 0x0, 0x0, 0x949f, 0x9982, 0x0,
 0x9381, 0x0, 0x0, 0x906e, 0x9983, 0x0, 0x95aa, 0x90d8,
 0x8aa0, 0x0, 0x8aa7, 0x9984, 0x0, 0x0, 0x9986, 0x0,
 0x0, 0x8c59, 0x0, 0x0, 0x9985, 0x0, 0x0, 0x97f1,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f89, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x94bb, 0x95ca, 0x0, 0x9987,
 0x0, 0x9798, 0x9988, 0x0, 0x0, 0x0, 0x9989, 0x0,
 0x939e, 0x0, 0x0, 0x998a, 0x0, 0x0, 0x90a7, 0x8dfc,
 0x8c94, 0x998b, 0x8e68, 0x8d8f, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x92e4, 0x998d, 0x0, 0x0, 0x91a5,
 0x0, 0x0, 0x8ded, 0x998e, 0x998f, 0x914f, 0x0, 0x998c,
 0x0, 0x0, 0x0, 0x0, 0x9991, 0x0, 0x9655, 0x0,
 0x0, 0x0, 0x0, 0x8d84, 0x0, 0x0, 0x9990, 0x0,
 0x0, 0x0, 0x0, 0x8c95, 0x8ddc, 0x948d, 0x0, 0x0,
 0x0, 0x9994, 0x9992, 0x0, 0x0, 0x0, 0x0, 0x959b,
 0x8fe8, 0x999b, 0x8a84, 0x9995, 0x9993, 0x916e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9997, 0x0, 0x9996,
 0x0, 0x0, 0x0, 0x8a63, 0x0, 0x0, 0x0, 0x8c80,
 0x999c, 0x97ab, 0x0, 0x0, 0x0, 0x9998, 0x0, 0x0,
 0x0, 0x999d, 0x999a, 0x0, 0x9999, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x97cd, 0x0, 0x0, 0x0, 0x8cf7,
 0x89c1, 0x0, 0x0, 0x97f2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8f95, 0x9377, 0x8d85, 0x99a0, 0x99a1, 0x0, 0x0,
 0x0, 0x97e3, 0x0, 0x0, 0x984a, 0x99a3, 0x0, 0x0,
 0x0, 0x8cf8, 0x0, 0x0, 0x99a2, 0x0, 0x8a4e, 0x0,
 0x0, 0x99a4, 0x0, 0x9675, 0x0, 0x92ba, 0x0, 0x9745,
 0x0, 0x95d7, 0x0, 0x0, 0x0, 0x99a5, 0x0, 0x0,
 0x0, 0x0, 0xe8d3, 0x0, 0x0, 0x93ae, 0x0, 0x99a6,
 0x8aa8, 0x96b1, 0x0, 0x0, 0x0, 0x8f9f, 0x99a7, 0x95e5,
 0x99ab, 0x0, 0x90a8, 0x99a8, 0x8bce, 0x0, 0x99a9, 0x8aa9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c4d, 0x99ac, 0x0, 0x99ad, 0x0, 0x0,
 0x99ae, 0x99af, 0x8ed9, 0x0, 0x0, 0x0, 0x8cf9, 0x96dc,
 0x0, 0x96e6, 0x93f5, 0x0, 0x0, 0x95ef, 0x99b0, 0x0,
 0x99b1, 0x0, 0x0, 0x0, 0x0, 0x99b3, 0x0, 0x99b5,
 0x99b4, 0x0, 0x0, 0x0, 0x0, 0x99b6, 0x89bb, 0x966b,
 0x0, 0x8dfa, 0x99b7, 0x0, 0x0, 0x9178, 0x0, 0x0,
 0x8fa0, 0x8ba7, 0x0, 0x99b8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x94d9, 0x0, 0x0, 0x0, 0x0, 0x99b9,
 0x0, 0x99ba, 0x0, 0x99bb, 0x0, 0x0, 0x0, 0x0,
 0x99bc, 0x9543, 0x8be6, 0x88e3, 0x0, 0x0, 0x0, 0x93bd,
 0x99bd, 0x8f5c, 0x0, 0x90e7, 0x0, 0x99bf, 0x99be, 0x8fa1,
 0x8cdf, 0x0, 0x99c1, 0x94bc, 0x0, 0x0, 0x99c2, 0x0,
 0x0, 0x0, 0x94da, 0x91b2, 0x91ec, 0x8ba6, 0x0, 0x93ec,
 0x9250, 0x0, 0x948e, 0x0, 0x966d, 0x0, 0x99c4, 0x0,
 0x90e8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c54, 0x0,
 0x0, 0x99c5, 0x0, 0x0, 0x0, 0x0, 0x99c6, 0x894b,
 0x88f3, 0x8aeb, 0x0, 0x91a6, 0x8b70, 0x9791, 0x0, 0x99c9,
 0x89b5, 0x0, 0x0, 0x99c8, 0x0, 0x0, 0x0, 0x8ba8,
 0x0, 0x0, 0x99ca, 0x0, 0x96ef, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x99cb, 0x0,
 0x97d0, 0x0, 0x8cfa, 0x0, 0x0, 0x0, 0x0, 0x8cb4,
 0x99cc, 0x0, 0x0, 0x0, 0x0, 0x99ce, 0x99cd, 0x0,
 0x907e, 0x8958, 0x0, 0x0, 0x0, 0x897d, 0x99cf, 0x0,
 0x99d0, 0x0, 0x0, 0x8cb5, 0x0, 0x0, 0x99d1, 0x0,
 0x0, 0x0, 0x0, 0x8b8e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8e51, 0x99d2, 0x0, 0x0, 0x0, 0x0,
 0x9694, 0x8db3, 0x8b79, 0x9746, 0x916f, 0x94bd, 0x8efb, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8f66, 0x0, 0x8ee6, 0x8ef3,
 0x0, 0x8f96, 0x0, 0x94be, 0x0, 0x0, 0x0, 0x99d5,
 0x0, 0x8962, 0x0, 0x9170, 0x8cfb, 0x8cc3, 0x8be5, 0x0,
 0x0, 0x99d9, 0x9240, 0x91fc, 0x8ba9, 0x8fa2, 0x99da, 0x99d8,
 0x89c2, 0x91e4, 0x8eb6, 0x8e6a, 0x8945, 0x0, 0x0, 0x8a90,
 0x8d86, 0x8e69, 0x0, 0x99db, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x99dc, 0x0, 0x8b68, 0x8a65, 0x0, 0x0,
 0x0, 0x8d87, 0x8b67, 0x92dd, 0x8944, 0x93af, 0x96bc, 0x8d40,
 0x9799, 0x9366, 0x8cfc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8c4e, 0x0, 0x99e5, 0x0,
 0x8be1, 0x9669, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94db,
 0x0, 0x0, 0x99e4, 0x0, 0x8adc, 0x99df, 0x99e0, 0x99e2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x99e3,
 0x0, 0x8b7a, 0x9081, 0x0, 0x95ab, 0x99e1, 0x99dd, 0x8ce1,
 0x0, 0x99de, 0x8d90, 0x0, 0x9843, 0x0, 0x0, 0x0,
 0x95f0, 0x0, 0x92e6, 0x8ce0, 0x0, 0x0, 0x0, 0x99e6,
 0x0, 0x0, 0x93db, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x99ea, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8efc, 0x0, 0x8ef4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x99ed, 0x99eb, 0x0, 0x96a1, 0x0, 0x99e8, 0x99f1,
 0x99ec, 0x0, 0x0, 0x0, 0x99ef, 0x8cc4, 0x96bd, 0x0,
 0x0, 0x99f0, 0x0, 0x0, 0x0, 0x99f2, 0x0, 0x99f4,
 0x0, 0x0, 0x0, 0x0, 0x8dee, 0x8cec, 0x9861, 0x0,
 0x99e9, 0x99e7, 0x99f3, 0x0, 0x99ee, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x99f6, 0x0, 0x9a42, 0x99f8,
 0x0, 0x0, 0x99fc, 0x0, 0x0, 0x9a40, 0x99f9, 0x0,
 0x0, 0x9a5d, 0x0, 0x0, 0x8de7, 0x8a50, 0x0, 0x0,
 0x0, 0x0, 0x99f7, 0x0, 0x0, 0x0, 0x9a44, 0x88f4,
 0x9a43, 0x0, 0x88a3, 0x9569, 0x9a41, 0x0, 0x99fa, 0x0,
 0x0, 0x99f5, 0x99fb, 0x8dc6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9a45, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x88f5, 0x9a4e, 0x0, 0x0, 0x9a46,
 0x9a47, 0x0, 0x8fa3, 0x9689, 0x0, 0x0, 0x0, 0x9a4c,
 0x9a4b, 0x0, 0x0, 0x0, 0x934e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a4d, 0x0, 0x0, 0x9a4a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8953, 0x0,
 0x8db4, 0x904f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9a48, 0x9382, 0x0, 0x0, 0x9a49, 0x0, 0x88a0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a53, 0x9742, 0x0, 0x8fa5, 0x0, 0x9a59, 0x0, 0x0,
 0x0, 0x0, 0x9a58, 0x9a4f, 0x0, 0x0, 0x0, 0x0,
 0x91c1, 0x0, 0x9a50, 0x0, 0x0, 0x0, 0x91ed, 0x9a55,
 0x8fa4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a52, 0x0,
 0x0, 0x96e2, 0x0, 0x0, 0x0, 0x8c5b, 0x0, 0x0,
 0x9a56, 0x9a57, 0x0, 0x0, 0x0, 0x0, 0x9a54, 0x9a5a,
 0x0, 0x0, 0x0, 0x0, 0x9a51, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9a60, 0x9a65, 0x0, 0x9a61, 0x0,
 0x9a5c, 0x0, 0x0, 0x9a66, 0x9150, 0x0, 0x0, 0x9a68,
 0x0, 0x8d41, 0x9a5e, 0x929d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a62, 0x9a5b, 0x8aab, 0x0, 0x8aec, 0x8a85, 0x9a63, 0x9a5f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c96,
 0x9a69, 0x9a67, 0x9172, 0x8b69, 0x8baa, 0x0, 0x9a64, 0x0,
 0x8bf2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8963, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a6d, 0x9a6b, 0x0,
 0x9aa5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a70, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9a6a, 0x0, 0x9a6e, 0x0, 0x0,
 0x9a6c, 0x0, 0x0, 0x0, 0x8e6b, 0x9a6f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a72, 0x0, 0x9a77, 0x0, 0x0, 0x0, 0x9a75, 0x9a74,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9251,
 0x0, 0x0, 0x89c3, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a71, 0x0, 0x9a73,
 0x8fa6, 0x8952, 0x0, 0x0, 0x9a76, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89dc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a82, 0x0, 0x8ffa, 0x9a7d, 0x0, 0x9a7b, 0x0, 0x9a7c,
 0x0, 0x9a7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x895c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9158, 0x0, 0x9a78,
 0x0, 0x9a79, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8a9a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a81, 0x0, 0x0, 0x0,
 0x8aed, 0x0, 0x9a84, 0x9a80, 0x9a83, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95ac, 0x0, 0x0, 0x0,
 0x93d3, 0x0, 0x94b6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a86, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a85, 0x8a64,
 0x0, 0x0, 0x9a87, 0x0, 0x0, 0x0, 0x0, 0x9a8a,
 0x0, 0x0, 0x0, 0x0, 0x9a89, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9a88, 0x0, 0x9458, 0x0, 0x0, 0x9a8b, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a8c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a8e, 0x0, 0x9a8d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9a90, 0x0, 0x0, 0x0,
 0x9a93, 0x9a91, 0x9a8f, 0x9a92, 0x0, 0x0, 0x0, 0x0,
 0x9a94, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a95, 0x0,
 0x0, 0x9a96, 0x0, 0x9a97, 0x0, 0x0, 0x0, 0x9a98,
 0x9964, 0x0, 0x8efa, 0x8e6c, 0x0, 0x0, 0x89f1, 0x0,
 0x88f6, 0x0, 0x0, 0x9263, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a99, 0x0,
 0x8da2, 0x0, 0x88cd, 0x907d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9a9a, 0x8cc5, 0x0, 0x0, 0x8d91, 0x0, 0x9a9c,
 0x9a9b, 0x0, 0x0, 0x95de, 0x9a9d, 0x0, 0x0, 0x0,
 0x9a9f, 0x9a9e, 0x0, 0x9aa0, 0x8c97, 0x0, 0x9aa1, 0x0,
 0x0, 0x0, 0x8980, 0x9aa2, 0x0, 0x0, 0x9aa4, 0x0,
 0x9aa3, 0x0, 0x0, 0x0, 0x9aa6, 0x0, 0x0, 0x9379,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9aa7, 0x88b3,
 0x8ddd, 0x0, 0x0, 0x0, 0x0, 0x8c5c, 0x0, 0x0,
 0x926e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9aa8,
 0x9aa9, 0x0, 0x0, 0x9aab, 0x0, 0x0, 0x0, 0x0,
 0x9aac, 0x0, 0x8de2, 0x0, 0x0, 0x0, 0x0, 0x8bcf,
 0x0, 0x0, 0x9656, 0x0, 0x0, 0x0, 0x9aaa, 0x9aad,
 0x8dbf, 0x8d42, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9ab1, 0x0, 0x0, 0x8da3, 0x0, 0x9252, 0x0,
 0x0, 0x9aae, 0x92d8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ab2,
 0x0, 0x0, 0x9082, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ab0, 0x9ab3, 0x0, 0x8c5e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ab4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ab5, 0x0, 0x8d43, 0x8a5f, 0x9ab7, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ab8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ab9, 0x0, 0x0, 0x9ab6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9aaf, 0x0, 0x0, 0x9aba, 0x0, 0x0, 0x9abb, 0x0,
 0x0, 0x0, 0x0, 0x9684, 0x0, 0x0, 0x8fe9, 0x0,
 0x0, 0x0, 0x9abd, 0x9abe, 0x9abc, 0x0, 0x9ac0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9457, 0x0, 0x0, 0x88e6,
 0x9575, 0x0, 0x0, 0x9ac1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8ffb, 0x0, 0x0, 0x8eb7,
 0x0, 0x947c, 0x8aee, 0x0, 0x8de9, 0x0, 0x0, 0x0,
 0x9678, 0x0, 0x93b0, 0x0, 0x0, 0x8c98, 0x91cd, 0x0,
 0x0, 0x0, 0x9abf, 0x9ac2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x91c2, 0x0, 0x0,
 0x0, 0x9ac3, 0x0, 0x0, 0x0, 0x9ac4, 0x0, 0x0,
 0x0, 0x9ac6, 0x0, 0x0, 0x92e7, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8aac, 0x0, 0x0, 0x0, 0x0, 0xea9f,
 0x8981, 0x95f1, 0x0, 0x0, 0x8fea, 0x9367, 0x0, 0x0,
 0x0, 0x0, 0x8de4, 0x0, 0x0, 0x9acc, 0x0, 0x0,
 0x95bb, 0x97db, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89f2, 0x9ac8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9159, 0x9acb, 0x0, 0x9383, 0x0, 0x0, 0x9368,
 0x9384, 0x94b7, 0x92cb, 0x0, 0x0, 0x0, 0x8dc7, 0x0,
 0x0, 0x0, 0x9ac7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8996, 0x0, 0x9355, 0x0, 0x0, 0x0, 0x0,
 0x9ac9, 0x0, 0x9ac5, 0x0, 0x0, 0x906f, 0x0, 0x0,
 0x0, 0x9acd, 0x0, 0x0, 0x0, 0x0, 0x8f6d, 0x0,
 0x0, 0x0, 0x0, 0x8bab, 0x0, 0x9ace, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x95e6, 0x0, 0x0, 0x0, 0x919d,
 0x0, 0x0, 0x0, 0x0, 0x92c4, 0x0, 0x0, 0x9ad0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x966e, 0x0, 0x0, 0x9ad1, 0x0, 0x0, 0x9ad6, 0x0,
 0x0, 0x0, 0x0, 0x95ad, 0x0, 0x0, 0x0, 0x0,
 0x9ad5, 0x9acf, 0x9ad2, 0x9ad4, 0x0, 0x0, 0x8da4, 0x0,
 0x0, 0x95c7, 0x0, 0x0, 0x0, 0x9ad7, 0x0, 0x9264,
 0x0, 0x0, 0x89f3, 0x0, 0x8feb, 0x0, 0x0, 0x0,
 0x0, 0x9ad9, 0x0, 0x9ad8, 0x0, 0x8d88, 0x0, 0x9ada,
 0x9adc, 0x9adb, 0x0, 0x0, 0x9ade, 0x0, 0x9ad3, 0x9ae0,
 0x0, 0x0, 0x0, 0x9adf, 0x9add, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8e6d, 0x9070, 0x0, 0x9173, 0x9ae1, 0x90ba,
 0x88eb, 0x9484, 0x0, 0x0, 0x0, 0x0, 0x92d9, 0x0,
 0x9ae3, 0x9ae2, 0x9ae4, 0x9ae5, 0x9ae6, 0x0, 0x0, 0x0,
 0x0, 0x9ae7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ae8, 0x0, 0x0, 0x95cf, 0x0, 0x0, 0x89c4, 0x9ae9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x975b, 0x8a4f, 0x0,
 0x99c7, 0x8f67, 0x91bd, 0x9aea, 0x96e9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x96b2, 0x0, 0x0, 0x9aec, 0x0, 0x91e5,
 0x0, 0x9356, 0x91be, 0x9576, 0x9aed, 0x9aee, 0x899b, 0x0,
 0x0, 0x8eb8, 0x9aef, 0x0, 0x0, 0x0, 0x0, 0x88ce,
 0x9af0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9af1, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8982, 0x0, 0x0, 0x8aef,
 0x93de, 0x95f2, 0x0, 0x0, 0x0, 0x0, 0x9af5, 0x9174,
 0x9af4, 0x8c5f, 0x0, 0x0, 0x967a, 0x9af3, 0x0, 0x9385,
 0x9af7, 0x0, 0x9af6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9af9, 0x0, 0x9af8, 0x0, 0x0, 0x899c, 0x0, 0x9afa,
 0x8fa7, 0x9afc, 0x9244, 0x0, 0x9afb, 0x0, 0x95b1, 0x0,
 0x0, 0x0, 0x0, 0x8f97, 0x937a, 0x0, 0x0, 0x0,
 0x9b40, 0x0, 0x0, 0x0, 0x0, 0x8d44, 0x0, 0x0,
 0x0, 0x9b41, 0x9440, 0x94dc, 0x96cf, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9444, 0x0, 0x0, 0x9b4a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8b57, 0x0, 0x0, 0x9764, 0x0,
 0x0, 0x96ad, 0x0, 0x9baa, 0x0, 0x9b42, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9b45, 0x0, 0x91c3, 0x0, 0x0,
 0x9657, 0x0, 0x0, 0x0, 0x9369, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9b46, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9685, 0x0, 0x8dc8, 0x0, 0x0, 0x8fa8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b47, 0x0,
 0x0, 0x8e6f, 0x0, 0x8e6e, 0x0, 0x0, 0x0, 0x0,
 0x88b7, 0x8cc6, 0x0, 0x90a9, 0x88cf, 0x0, 0x0, 0x0,
 0x0, 0x9b4b, 0x9b4c, 0x0, 0x9b49, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8957, 0x8aad, 0x0,
 0x9b48, 0x0, 0x96c3, 0x9550, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88a6, 0x0,
 0x0, 0x0, 0x0, 0x88f7, 0x0, 0x0, 0x0, 0x8e70,
 0x0, 0x88d0, 0x0, 0x88a1, 0x0, 0x0, 0x0, 0x0,
 0x9b51, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9b4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96ba,
 0x0, 0x9b52, 0x0, 0x9b50, 0x0, 0x0, 0x9b4e, 0x9050,
 0x0, 0x0, 0x0, 0x0, 0x9b4d, 0x0, 0x0, 0x0,
 0x95d8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ce2, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b56, 0x9b57, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8fa9, 0x0, 0x0, 0x0,
 0x9b53, 0x984b, 0x0, 0x0, 0x0, 0x0, 0x946b, 0x0,
 0x0, 0x9b55, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8da5, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9b58, 0x0, 0x0, 0x0, 0x9577, 0x0,
 0x0, 0x0, 0x9b59, 0x0, 0x9b54, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96b9, 0x0,
 0x0, 0x947d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9b5a, 0x9551, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9b5b, 0x9b5f, 0x9b5c, 0x0, 0x0,
 0x89c5, 0x9b5e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8eb9, 0x0, 0x9b5d, 0x8c99, 0x0, 0x0, 0x0, 0x9b6b,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b64, 0x9b61, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9284, 0x0, 0x9b60, 0x0, 0x0, 0x9b62, 0x0, 0x0,
 0x9b63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9b65, 0x9b66, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8af0, 0x0, 0x9b68, 0x9b67, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b69, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8fec, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9b6c, 0x0, 0x92da, 0x0, 0x0, 0x0, 0x8964,
 0x0, 0x9b6a, 0x0, 0x0, 0x0, 0x9b6d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b6e, 0x0, 0x9b71,
 0x0, 0x0, 0x9b6f, 0x0, 0x9b70, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e71,
 0x9b72, 0x0, 0x8d45, 0x0, 0x9b73, 0x0, 0x8e9a, 0x91b6,
 0x0, 0x9b74, 0x9b75, 0x8e79, 0x8d46, 0x0, 0x96d0, 0x0,
 0x0, 0x0, 0x8b47, 0x8cc7, 0x9b76, 0x8a77, 0x0, 0x0,
 0x9b77, 0x0, 0x91b7, 0x0, 0x0, 0x0, 0x0, 0x9b78,
 0x9ba1, 0x0, 0x9b79, 0x0, 0x9b7a, 0x0, 0x0, 0x9b7b,
 0x0, 0x9b7d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b7e,
 0x0, 0x0, 0x9b80, 0x0, 0x91ee, 0x0, 0x8946, 0x8ee7,
 0x88c0, 0x0, 0x9176, 0x8aae, 0x8eb3, 0x0, 0x8d47, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9386, 0x0, 0x8f40, 0x8aaf,
 0x9288, 0x92e8, 0x88b6, 0x8b58, 0x95f3, 0x0, 0x8ec0, 0x0,
 0x0, 0x8b71, 0x90e9, 0x8eba, 0x9747, 0x9b81, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b7b, 0x0, 0x8dc9,
 0x0, 0x0, 0x8a51, 0x8983, 0x8faa, 0x89c6, 0x0, 0x9b82,
 0x9765, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f68, 0x0,
 0x0, 0x8ee2, 0x9b83, 0x8af1, 0x93d0, 0x96a7, 0x9b84, 0x0,
 0x9b85, 0x0, 0x0, 0x9578, 0x0, 0x0, 0x0, 0x9b87,
 0x0, 0x8aa6, 0x8bf5, 0x9b86, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ab0, 0x0, 0x9051, 0x9b8b, 0x8e40, 0x0,
 0x89c7, 0x9b8a, 0x0, 0x9b88, 0x9b8c, 0x9b89, 0x944a, 0x9ecb,
 0x9052, 0x0, 0x9b8d, 0x0, 0x0, 0x97be, 0x0, 0x9b8e,
 0x0, 0x0, 0x9b90, 0x0, 0x929e, 0x9b8f, 0x0, 0x90a1,
 0x0, 0x8e9b, 0x0, 0x0, 0x0, 0x91ce, 0x8ef5, 0x0,
 0x9595, 0x8fab, 0x90ea, 0x0, 0x8ecb, 0x9b91, 0x9b92, 0x9b93,
 0x88d1, 0x91b8, 0x9071, 0x0, 0x9b94, 0x93b1, 0x8fac, 0x0,
 0x8fad, 0x0, 0x9b95, 0x0, 0x0, 0x90eb, 0x0, 0x0,
 0x0, 0x8fae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b96,
 0x0, 0x9b97, 0x0, 0x96de, 0x0, 0x0, 0x0, 0x9b98,
 0x0, 0x0, 0x0, 0x0, 0x8bc4, 0x0, 0x0, 0x0,
 0x8f41, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9b99,
 0x9b9a, 0x8eda, 0x904b, 0x93f2, 0x9073, 0x94f6, 0x9441, 0x8bc7,
 0x9b9b, 0x0, 0x0, 0x0, 0x8b8f, 0x9b9c, 0x0, 0x8bfc,
 0x0, 0x93cd, 0x89ae, 0x0, 0x8e72, 0x9b9d, 0x9ba0, 0x9b9f,
 0x8bfb, 0x0, 0x9b9e, 0x0, 0x9357, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x91ae, 0x0, 0x936a,
 0x8ec6, 0x0, 0x0, 0x9177, 0x979a, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ba2, 0x0, 0x9ba3, 0x93d4, 0x0,
 0x8e52, 0x0, 0x0, 0x0, 0x0, 0x9ba5, 0x0, 0x0,
 0x9ba6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ba7, 0x0, 0x0, 0x0, 0x8af2,
 0x9ba8, 0x0, 0x0, 0x9ba9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x89aa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x915a,
 0x8ae2, 0x0, 0x9bab, 0x96a6, 0x0, 0x0, 0x0, 0x0,
 0x91d0, 0x0, 0x8a78, 0x0, 0x0, 0x9bad, 0x9baf, 0x8add,
 0x0, 0x0, 0x9bac, 0x9bae, 0x0, 0x9bb1, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9bb0, 0x0, 0x9bb2, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9bb3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93bb,
 0x8bac, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x89e3,
 0x9bb4, 0x9bb9, 0x0, 0x0, 0x9bb7, 0x0, 0x95f5, 0x95f4,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9387, 0x0, 0x0,
 0x0, 0x9bb6, 0x8f73, 0x0, 0x9bb5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9092, 0x0,
 0x0, 0x0, 0x9bba, 0x0, 0x0, 0x8de8, 0x0, 0x0,
 0x9bc0, 0x0, 0x0, 0x9bc1, 0x9bbb, 0x8a52, 0x9bbc, 0x9bc5,
 0x9bc4, 0x9bc3, 0x9bbf, 0x0, 0x0, 0x0, 0x9bbe, 0x0,
 0x0, 0x9bc2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x95f6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9bc9, 0x9bc6, 0x0, 0x9bc8, 0x0, 0x9792,
 0x0, 0x9bc7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9bbd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9093, 0x0, 0x0, 0x9bca, 0x0, 0x0, 0x8db5, 0x0,
 0x0, 0x0, 0x9bcb, 0x0, 0x0, 0x9bcc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9bcf, 0x0, 0x9bce, 0x0, 0x0, 0x9bcd, 0x0,
 0x0, 0x0, 0x9388, 0x9bb8, 0x0, 0x0, 0x0, 0x9bd5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9bd1, 0x0, 0x0, 0x0,
 0x0, 0x9bd0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9bd2, 0x0, 0x9bd3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9bd6, 0x0,
 0x0, 0x97e4, 0x0, 0x9bd7, 0x9bd4, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9bd8, 0x0, 0x0, 0x8ade, 0x9bd9, 0x0, 0x0, 0x0,
 0x0, 0x9bdb, 0x9bda, 0x0, 0x0, 0x9bdc, 0x0, 0x0,
 0x0, 0x0, 0x9bdd, 0x0, 0x90ec, 0x8f42, 0x0, 0x0,
 0x8f84, 0x0, 0x9183, 0x0, 0x8d48, 0x8db6, 0x8d49, 0x8b90,
 0x0, 0x0, 0x9bde, 0x0, 0x0, 0x8db7, 0x0, 0x0,
 0x8cc8, 0x9bdf, 0x96a4, 0x9462, 0x9be0, 0x0, 0x8d4a, 0x0,
 0x0, 0x0, 0x8aaa, 0x0, 0x9246, 0x8bd0, 0x0, 0x0,
 0x0, 0x8e73, 0x957a, 0x0, 0x0, 0x94bf, 0x0, 0x0,
 0x0, 0x0, 0x9be1, 0x8af3, 0x0, 0x0, 0x0, 0x0,
 0x9be4, 0x0, 0x0, 0x0, 0x0, 0x929f, 0x0, 0x0,
 0x9be3, 0x9be2, 0x9be5, 0x0, 0x92e9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9083, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8e74, 0x0, 0x90c8, 0x0, 0x91d1, 0x8b41,
 0x0, 0x0, 0x92a0, 0x0, 0x0, 0x9be6, 0x9be7, 0x8fed,
 0x0, 0x0, 0x0, 0x0, 0x9658, 0x0, 0x0, 0x9bea,
 0x0, 0x0, 0x9be9, 0x9be8, 0x959d, 0x0, 0x9bf1, 0x0,
 0x0, 0x0, 0x0, 0x9679, 0x0, 0x9beb, 0x0, 0x0,
 0x0, 0x0, 0x9bed, 0x968b, 0x0, 0x9bec, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9bee, 0x0, 0x94a6,
 0x9bef, 0x95bc, 0x9bf0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8ab1, 0x95bd, 0x944e, 0x9bf2, 0x9bf3, 0x0, 0x8d4b, 0x8ab2,
 0x9bf4, 0x8cb6, 0x9763, 0x9748, 0x8af4, 0x9bf6, 0x0, 0x92a1,
 0x0, 0x8d4c, 0x8faf, 0x0, 0x0, 0x94dd, 0x0, 0x0,
 0x8fb0, 0x0, 0x0, 0x0, 0x0, 0x8f98, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x92ea, 0x95f7, 0x9358, 0x0, 0x0,
 0x8d4d, 0x0, 0x957b, 0x0, 0x0, 0x0, 0x9bf7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9378, 0x8dc0, 0x0, 0x0,
 0x0, 0x8cc9, 0x0, 0x92eb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x88c1, 0x8f8e, 0x8d4e, 0x9766, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9bf8,
 0x9bf9, 0x9470, 0x0, 0x0, 0x0, 0x0, 0x9bfa, 0x97f5,
 0x984c, 0x0, 0x0, 0x0, 0x0, 0x9bfc, 0x9bfb, 0x0,
 0x0, 0x8a66, 0x0, 0x0, 0x9c40, 0x0, 0x0, 0x0,
 0x9c43, 0x9c44, 0x0, 0x9c42, 0x0, 0x955f, 0x8fb1, 0x9c46,
 0x9c45, 0x9c41, 0x0, 0x0, 0x0, 0x0, 0x9c47, 0x9c48,
 0x0, 0x0, 0x9c49, 0x0, 0x0, 0x0, 0x9c4c, 0x9c4a,
 0x0, 0x9c4b, 0x9c4d, 0x0, 0x8984, 0x92ec, 0x9c4e, 0x0,
 0x8c9a, 0x89f4, 0x9455, 0x0, 0x9c4f, 0x93f9, 0x0, 0x95d9,
 0x0, 0x9c50, 0x984d, 0x0, 0x0, 0x0, 0x0, 0x9c51,
 0x95be, 0x9c54, 0x989f, 0x98af, 0x0, 0x8eae, 0x93f3, 0x9c55,
 0x0, 0x8b7c, 0x92a2, 0x88f8, 0x9c56, 0x95a4, 0x8d4f, 0x0,
 0x0, 0x926f, 0x0, 0x0, 0x0, 0x92ed, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x96ed, 0x8cb7, 0x8cca, 0x0, 0x9c57,
 0x0, 0x0, 0x0, 0x9c58, 0x0, 0x9c5e, 0x0, 0x8ee3,
 0x0, 0x0, 0x0, 0x92a3, 0x0, 0x8bad, 0x9c59, 0x0,
 0x0, 0x0, 0x954a, 0x0, 0x9265, 0x0, 0x0, 0x9c5a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c5b, 0x0,
 0x8bae, 0x0, 0x9c5c, 0x0, 0x9c5d, 0x0, 0x0, 0x9c5f,
 0x0, 0x9396, 0x0, 0x0, 0x9c60, 0x9c61, 0x0, 0x9c62,
 0x0, 0x0, 0x9c53, 0x9c52, 0x0, 0x0, 0x0, 0x9c63,
 0x8c60, 0x0, 0x0, 0x0, 0x9546, 0x0, 0x0, 0x8dca,
 0x9556, 0x92a4, 0x956a, 0x9c64, 0x0, 0x0, 0x8fb2, 0x8965,
 0x0, 0x9c65, 0x0, 0x0, 0x0, 0x9c66, 0x0, 0x96f0,
 0x0, 0x0, 0x94de, 0x0, 0x0, 0x9c69, 0x899d, 0x90aa,
 0x9c68, 0x9c67, 0x8c61, 0x91d2, 0x0, 0x9c6d, 0x9c6b, 0x0,
 0x9c6a, 0x97a5, 0x8ce3, 0x0, 0x0, 0x0, 0x8f99, 0x9c6c,
 0x936b, 0x8f5d, 0x0, 0x0, 0x0, 0x93be, 0x9c70, 0x9c6f,
 0x0, 0x0, 0x0, 0x0, 0x9c6e, 0x0, 0x9c71, 0x8ce4,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c72, 0x959c,
 0x8f7a, 0x0, 0x0, 0x9c73, 0x94f7, 0x0, 0x0, 0x0,
 0x0, 0x93bf, 0x92a5, 0x0, 0x0, 0x0, 0x0, 0x934f,
 0x0, 0x0, 0x9c74, 0x8b4a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9053, 0x0, 0x954b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8af5, 0x9445, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9c75, 0x8e75, 0x9659, 0x965a,
 0x0, 0x0, 0x899e, 0x9c7a, 0x0, 0x0, 0x9289, 0x0,
 0x0, 0x0, 0x9c77, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89f5, 0x0, 0x0, 0x0, 0x0, 0x9cab, 0x9c79,
 0x0, 0x0, 0x0, 0x944f, 0x0, 0x0, 0x9c78, 0x0,
 0x0, 0x9c76, 0x0, 0x8d9a, 0x0, 0x9c7c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9c83, 0x9c89, 0x9c81, 0x0,
 0x937b, 0x0, 0x0, 0x9c86, 0x957c, 0x0, 0x0, 0x9c80,
 0x0, 0x9c85, 0x97e5, 0x8e76, 0x0, 0x0, 0x91d3, 0x9c7d,
 0x0, 0x0, 0x0, 0x8b7d, 0x9c88, 0x90ab, 0x8985, 0x9c82,
 0x89f6, 0x9c87, 0x0, 0x0, 0x0, 0x8baf, 0x0, 0x9c84,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9c8a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c8c,
 0x9c96, 0x9c94, 0x0, 0x0, 0x9c91, 0x0, 0x0, 0x0,
 0x9c90, 0x97f6, 0x0, 0x9c92, 0x0, 0x0, 0x8bb0, 0x0,
 0x8d50, 0x0, 0x0, 0x8f9a, 0x0, 0x0, 0x0, 0x9c99,
 0x9c8b, 0x0, 0x0, 0x0, 0x0, 0x9c8f, 0x9c7e, 0x0,
 0x89f8, 0x9c93, 0x9c95, 0x9270, 0x0, 0x0, 0x8da6, 0x89b6,
 0x9c8d, 0x9c98, 0x9c97, 0x8bb1, 0x0, 0x91a7, 0x8a86, 0x0,
 0x0, 0x0, 0x0, 0x8c62, 0x0, 0x9c8e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c9a,
 0x0, 0x9c9d, 0x9c9f, 0x0, 0x0, 0x0, 0x0, 0x8ebb,
 0x0, 0x9ca5, 0x92ee, 0x9c9b, 0x0, 0x0, 0x0, 0x0,
 0x9ca3, 0x0, 0x89f7, 0x0, 0x9ca1, 0x9ca2, 0x0, 0x0,
 0x9c9e, 0x9ca0, 0x0, 0x0, 0x0, 0x8ce5, 0x9749, 0x0,
 0x0, 0x8ab3, 0x0, 0x0, 0x8978, 0x9ca4, 0x0, 0x9459,
 0x88ab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x94df, 0x9c7b, 0x9caa, 0x9cae, 0x96e3, 0x0, 0x9ca7, 0x0,
 0x0, 0x0, 0x9389, 0x9cac, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8fee, 0x9cad, 0x93d5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9866,
 0x0, 0x9ca9, 0x0, 0x0, 0x0, 0x0, 0x9caf, 0x0,
 0x8d9b, 0x0, 0x90c9, 0x0, 0x0, 0x88d2, 0x9ca8, 0x9ca6,
 0x0, 0x9179, 0x0, 0x0, 0x0, 0x9c9c, 0x8e53, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x91c4, 0x9cbb,
 0x0, 0x917a, 0x9cb6, 0x0, 0x9cb3, 0x9cb4, 0x0, 0x8ee4,
 0x9cb7, 0x9cba, 0x0, 0x0, 0x0, 0x0, 0x9cb5, 0x8f44,
 0x0, 0x9cb8, 0x0, 0x0, 0x9cb2, 0x0, 0x96fa, 0x96f9,
 0x0, 0x0, 0x0, 0x9cbc, 0x9cbd, 0x88d3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9cb1, 0x0, 0x0, 0x0, 0x0,
 0x8bf0, 0x88a4, 0x0, 0x0, 0x0, 0x8ab4, 0x0, 0x9cb9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9cc1, 0x9cc0, 0x0,
 0x0, 0x0, 0x9cc5, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9cc6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9cc4, 0x9cc7, 0x9cbf, 0x9cc3, 0x0, 0x0,
 0x9cc8, 0x0, 0x9cc9, 0x0, 0x0, 0x9cbe, 0x8e9c, 0x0,
 0x9cc2, 0x91d4, 0x8d51, 0x9cb0, 0x9054, 0x0, 0x0, 0x0,
 0x0, 0x9cd6, 0x0, 0x95e7, 0x0, 0x0, 0x9ccc, 0x9ccd,
 0x9cce, 0x0, 0x0, 0x9cd5, 0x0, 0x9cd4, 0x0, 0x0,
 0x969d, 0x8ab5, 0x0, 0x9cd2, 0x0, 0x8c64, 0x8a53, 0x0,
 0x0, 0x9ccf, 0x0, 0x0, 0x97b6, 0x9cd1, 0x88d4, 0x9cd3,
 0x0, 0x9cca, 0x9cd0, 0x9cd7, 0x8c63, 0x9ccb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x977c, 0x0, 0x0, 0x0,
 0x974a, 0x0, 0x0, 0x0, 0x0, 0x9cda, 0x0, 0x0,
 0x9cde, 0x0, 0x0, 0x0, 0x919e, 0x0, 0x97f7, 0x9cdf,
 0x0, 0x0, 0x9cdc, 0x0, 0x9cd9, 0x0, 0x0, 0x9cd8,
 0x9cdd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x95ae, 0x0, 0x0, 0x93b2, 0x0, 0x8c65,
 0x0, 0x9ce0, 0x9cdb, 0x0, 0x9ce1, 0x0, 0x0, 0x0,
 0x8c9b, 0x0, 0x0, 0x0, 0x89af, 0x0, 0x0, 0x0,
 0x9ce9, 0x0, 0x0, 0x0, 0x8ab6, 0x0, 0x0, 0x0,
 0x0, 0x9ce7, 0x0, 0x0, 0x9ce8, 0x8da7, 0x9ce6, 0x9ce4,
 0x9ce3, 0x9cea, 0x9ce2, 0x9cec, 0x0, 0x0, 0x89f9, 0x0,
 0x0, 0x9cee, 0x0, 0x0, 0x9ced, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x92a6, 0x0, 0x9cf1, 0x0, 0x9cef, 0x9ce5, 0x8c9c, 0x0,
 0x9cf0, 0x0, 0x9cf4, 0x9cf3, 0x9cf5, 0x9cf2, 0x9cf6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9cf7, 0x9cf8,
 0x95e8, 0x0, 0x9cfa, 0x9cf9, 0x8f5e, 0x0, 0x90ac, 0x89e4,
 0x89fa, 0x0, 0x9cfb, 0x0, 0x88bd, 0x0, 0x0, 0x0,
 0x90ca, 0x9cfc, 0x0, 0xe6c1, 0x9d40, 0x8c81, 0x0, 0x9d41,
 0x0, 0x0, 0x0, 0x0, 0x90ed, 0x0, 0x0, 0x0,
 0x9d42, 0x0, 0x0, 0x0, 0x9d43, 0x8b59, 0x9d44, 0x0,
 0x9d45, 0x9d46, 0x91d5, 0x0, 0x0, 0x0, 0x8ccb, 0x0,
 0x0, 0x96df, 0x0, 0x0, 0x0, 0x965b, 0x8f8a, 0x9d47,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x90ee, 0xe7bb, 0x94e0,
 0x0, 0x8ee8, 0x0, 0x8dcb, 0x9d48, 0x0, 0x0, 0x0,
 0x0, 0x91c5, 0x0, 0x95a5, 0x0, 0x0, 0x91ef, 0x0,
 0x0, 0x9d4b, 0x0, 0x0, 0x9d49, 0x0, 0x9d4c, 0x0,
 0x0, 0x9d4a, 0x0, 0x0, 0x0, 0x0, 0x9d4d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95af, 0x0, 0x0, 0x88b5,
 0x0, 0x0, 0x0, 0x0, 0x957d, 0x0, 0x0, 0x94e1,
 0x0, 0x0, 0x9d4e, 0x0, 0x9d51, 0x8fb3, 0x8b5a, 0x0,
 0x9d4f, 0x9d56, 0x8fb4, 0x0, 0x0, 0x0, 0x0, 0x9d50,
 0x9463, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x977d,
 0x9d52, 0x9d53, 0x9d57, 0x938a, 0x9d54, 0x8d52, 0x90dc, 0x0,
 0x0, 0x9d65, 0x94b2, 0x0, 0x91f0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x94e2, 0x9dab, 0x0, 0x0, 0x0, 0x0, 0x95f8,
 0x0, 0x0, 0x0, 0x92ef, 0x0, 0x0, 0x0, 0x9695,
 0x0, 0x9d5a, 0x899f, 0x928a, 0x0, 0x0, 0x0, 0x0,
 0x9d63, 0x0, 0x0, 0x9253, 0x9d5d, 0x9d64, 0x9d5f, 0x9d66,
 0x9d62, 0x0, 0x9d61, 0x948f, 0x0, 0x9d5b, 0x89fb, 0x9d59,
 0x8b91, 0x91f1, 0x9d55, 0x0, 0x0, 0x9d58, 0x8d53, 0x90d9,
 0x0, 0x8fb5, 0x9d60, 0x9471, 0x0, 0x0, 0x8b92, 0x8a67,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8a87, 0x9040, 0x9d68, 0x9d6d, 0x0, 0x9d69,
 0x0, 0x8c9d, 0x0, 0x9d6e, 0x8e41, 0x8d89, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8f45, 0x9d5c, 0x0, 0x8e9d,
 0x9d6b, 0x0, 0x0, 0x0, 0x0, 0x8e77, 0x9d6c, 0x88c2,
 0x0, 0x0, 0x9d67, 0x0, 0x0, 0x0, 0x0, 0x92a7,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b93,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8bb2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d6a, 0x88a5, 0x0,
 0x0, 0x8dc1, 0x0, 0x0, 0x0, 0x9055, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x92f0, 0x0, 0x0, 0x94d2, 0x9d70, 0x917d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x91a8,
 0x0, 0x0, 0x8e4a, 0x9d71, 0x0, 0x9d73, 0x9d6f, 0x0,
 0x0, 0x0, 0x0, 0x95df, 0x0, 0x92bb, 0x0, 0x0,
 0x0, 0x0, 0x917b, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x95f9, 0x8ecc, 0x9d80,
 0x0, 0x9d7e, 0x0, 0x0, 0x9098, 0x0, 0x0, 0x0,
 0x8c9e, 0x0, 0x0, 0x0, 0x9d78, 0x8fb7, 0x0, 0x0,
 0x93e6, 0x9450, 0x0, 0x0, 0x0, 0x0, 0x9d76, 0x0,
 0x0, 0x917c, 0x0, 0x0, 0x0, 0x0, 0x8ef6, 0x9d7b,
 0x0, 0x0, 0x8fb6, 0x0, 0x9d75, 0x9d7a, 0x0, 0x0,
 0x9472, 0x0, 0x0, 0x0, 0x9d74, 0x0, 0x8c40, 0x0,
 0x0, 0x8a7c, 0x0, 0x0, 0x0, 0x9d7c, 0x97a9, 0x8dcc,
 0x9254, 0x9d79, 0x0, 0x90da, 0x0, 0x8d54, 0x9084, 0x8986,
 0x915b, 0x9d77, 0x8b64, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8c66, 0x0, 0x92cd, 0x9d7d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x917e, 0x0, 0x0, 0x9d81, 0x0, 0x9d83, 0x0,
 0x0, 0x91b5, 0x9d89, 0x0, 0x9d84, 0x0, 0x0, 0x9d86,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9560, 0x92f1, 0x0,
 0x9d87, 0x0, 0x0, 0x0, 0x974b, 0x0, 0x0, 0x0,
 0x9767, 0x8ab7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88ac,
 0x0, 0x9d85, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d82,
 0x0, 0x0, 0x0, 0x0, 0x8af6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8987, 0x0, 0x9d88, 0x0, 0x0, 0x0,
 0x9768, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d8c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x91b9, 0x0, 0x9d93, 0x0,
 0x0, 0x0, 0x9d8d, 0x0, 0x0, 0x9d8a, 0x9d91, 0x0,
 0x0, 0x0, 0x0, 0x9d72, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d8e, 0x0, 0x9d92,
 0x0, 0x0, 0x0, 0x94c0, 0x938b, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9d8b, 0x0, 0x9d8f, 0x0, 0x0,
 0x0, 0x8c67, 0x0, 0x0, 0x8def, 0x0, 0x0, 0x0,
 0x90db, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9d97, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9345, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d94, 0x0, 0x9680,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9d95, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9d96, 0x0, 0x96cc, 0x0,
 0x90a0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8c82, 0x0, 0x0, 0x0, 0x0, 0x9d9d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8e54, 0x9d9a, 0x0, 0x9d99, 0x0, 0x0, 0x0, 0x0,
 0x9451, 0x0, 0x0, 0x0, 0x93b3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9350, 0x9d9b, 0x0, 0x0, 0x0, 0x9d9c,
 0x0, 0x958f, 0x0, 0x9464, 0x8e42, 0x0, 0x90ef, 0x0,
 0x966f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a68,
 0x0, 0x9da3, 0x9d9e, 0x0, 0x0, 0x0, 0x0, 0x9769,
 0x9da5, 0x0, 0x0, 0x9da1, 0x0, 0x9da2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9180, 0x0, 0x0, 0x0, 0x0,
 0x9da0, 0x0, 0x9d5e, 0x0, 0x0, 0x0, 0x9da4, 0x0,
 0x9d9f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9da9, 0x9daa,
 0x9346, 0x9dac, 0x0, 0x0, 0x8e43, 0x9da7, 0x0, 0x0,
 0x0, 0x0, 0x8b5b, 0x0, 0x0, 0x9dad, 0x0, 0x9da6,
 0x9db1, 0x0, 0x9db0, 0x0, 0x9daf, 0x0, 0x0, 0x0,
 0x9db2, 0x0, 0x0, 0x9db4, 0x8fef, 0x0, 0x9db3, 0x0,
 0x0, 0x0, 0x0, 0x9db7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9db5, 0x0,
 0x0, 0x0, 0x9db6, 0x9d90, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9db9, 0x9db8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9d98, 0x9dba, 0x9dae, 0x0, 0x0, 0x8e78, 0x0, 0x0,
 0x0, 0x0, 0x9dbb, 0x9dbc, 0x9dbe, 0x9dbd, 0x9dbf, 0x89fc,
 0x0, 0x8d55, 0x0, 0x0, 0x95fa, 0x90ad, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8ccc, 0x0, 0x0, 0x9dc1, 0x0,
 0x0, 0x0, 0x0, 0x9dc4, 0x0, 0x9571, 0x0, 0x8b7e,
 0x0, 0x0, 0x0, 0x9dc3, 0x9dc2, 0x9473, 0x0, 0x9dc5,
 0x8bb3, 0x0, 0x0, 0x0, 0x9dc7, 0x9dc6, 0x0, 0x0,
 0x0, 0x8ab8, 0x8e55, 0x0, 0x0, 0x93d6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c68, 0x0, 0x0, 0x0, 0x9094,
 0x0, 0x9dc8, 0x0, 0x90ae, 0x9347, 0x0, 0x957e, 0x9dc9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9dca, 0x9dcb, 0x0, 0x0, 0x0, 0x0, 0x95b6, 0x9b7c,
 0x90c4, 0x0, 0x0, 0x956b, 0x0, 0x8dd6, 0x0, 0x94e3,
 0x94c1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x936c, 0x0,
 0x97bf, 0x0, 0x9dcd, 0x8ece, 0x0, 0x0, 0x9dce, 0x0,
 0x88b4, 0x0, 0x0, 0x8bd2, 0x90cb, 0x0, 0x9580, 0x0,
 0x0, 0x0, 0x9dcf, 0x8e61, 0x9266, 0x0, 0x8e7a, 0x9056,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9dd0, 0x0,
 0x95fb, 0x0, 0x0, 0x8997, 0x8e7b, 0x0, 0x0, 0x0,
 0x9dd3, 0x0, 0x9dd1, 0x9dd4, 0x97b7, 0x9dd2, 0x0, 0x0,
 0x0, 0x0, 0x90f9, 0x9dd5, 0x0, 0x0, 0x91b0, 0x0,
 0x0, 0x9dd6, 0x0, 0x0, 0x0, 0x0, 0x8af8, 0x0,
 0x9dd8, 0x0, 0x9dd7, 0x0, 0x0, 0x0, 0x0, 0x9dd9,
 0x9dda, 0x8af9, 0x0, 0x0, 0x93fa, 0x9255, 0x8b8c, 0x8e7c,
 0x9181, 0x0, 0x0, 0x8f7b, 0x88ae, 0x0, 0x0, 0x0,
 0x9ddb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89a0, 0x9ddf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8d56, 0x9dde, 0x0, 0x0, 0x8da9, 0x8fb8, 0x0,
 0x0, 0x9ddd, 0x0, 0x8fb9, 0x0, 0x96be, 0x8da8, 0x0,
 0x0, 0x0, 0x88d5, 0x90cc, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9de4, 0x0, 0x0, 0x90af, 0x8966,
 0x0, 0x0, 0x0, 0x0, 0x8f74, 0x0, 0x9686, 0x8df0,
 0x0, 0x0, 0x0, 0x0, 0x8fba, 0x0, 0x90a5, 0x0,
 0x0, 0x0, 0x0, 0x9de3, 0x9de1, 0x9de2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x928b, 0x0, 0x0, 0x9e45, 0x0,
 0x9de8, 0x8e9e, 0x8d57, 0x9de6, 0x0, 0x0, 0x0, 0x0,
 0x9de7, 0x0, 0x9057, 0x0, 0x0, 0x0, 0x9de5, 0x0,
 0x0, 0x8e4e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9dea, 0x9de9, 0x9dee, 0x0,
 0x0, 0x9def, 0x0, 0x9deb, 0x0, 0x8a41, 0x9dec, 0x9ded,
 0x94d3, 0x0, 0x0, 0x0, 0x0, 0x9581, 0x8c69, 0x9df0,
 0x0, 0x0, 0x0, 0x90b0, 0x0, 0x8fbb, 0x0, 0x0,
 0x0, 0x9271, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8bc5, 0x0, 0x9df1, 0x9df5, 0x0, 0x0, 0x89c9, 0x9df2,
 0x9df4, 0x0, 0x0, 0x0, 0x0, 0x9df3, 0x0, 0x0,
 0x8f8b, 0x0, 0x0, 0x0, 0x0, 0x9267, 0x88c3, 0x9df6,
 0x0, 0x0, 0x0, 0x0, 0x9df7, 0x0, 0x0, 0x0,
 0x0, 0x92a8, 0x0, 0x0, 0x0, 0x97ef, 0x0, 0x0,
 0x0, 0x0, 0x8e62, 0x0, 0x0, 0x95e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x965c, 0x0, 0x0, 0x0, 0x9e41,
 0x9df9, 0x0, 0x0, 0x9dfc, 0x0, 0x9dfb, 0x0, 0x0,
 0x9df8, 0x0, 0x0, 0x9e40, 0x0, 0x0, 0x93dc, 0x0,
 0x9dfa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e42, 0x0, 0x0,
 0x8f8c, 0x9e43, 0x0, 0x976a, 0x9498, 0x0, 0x0, 0x9e44,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e46, 0x0, 0x0,
 0x9e47, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e48,
 0x0, 0x8bc8, 0x8967, 0x8d58, 0x9e49, 0x0, 0x9e4a, 0x8f91,
 0x9182, 0x0, 0x0, 0x99d6, 0x915d, 0x915c, 0x91d6, 0x8dc5,
 0x0, 0x0, 0x98f0, 0x0, 0x0, 0x0, 0x0, 0x8c8e,
 0x974c, 0x0, 0x95fc, 0x0, 0x959e, 0x0, 0x9e4b, 0x0,
 0x0, 0x0, 0x0, 0x8df1, 0x92bd, 0x9e4c, 0x984e, 0x0,
 0x0, 0x0, 0x965d, 0x0, 0x92a9, 0x9e4d, 0x8afa, 0x0,
 0x0, 0x0, 0xe452, 0x0, 0x0, 0x0, 0x9e4e, 0x9e4f,
 0x96d8, 0x0, 0x96a2, 0x9696, 0x967b, 0x8e44, 0x9e51, 0x0,
 0x0, 0x8ee9, 0x0, 0x0, 0x9670, 0x0, 0x9e53, 0x9e56,
 0x9e55, 0x0, 0x8af7, 0x0, 0x0, 0x8b80, 0x0, 0x9e52,
 0x0, 0x9e54, 0x0, 0x0, 0x0, 0x0, 0x9e57, 0x0,
 0x0, 0x9099, 0x0, 0x0, 0x0, 0x0, 0x979b, 0x88c7,
 0x8dde, 0x91ba, 0x0, 0x8edb, 0x0, 0x0, 0x8ff1, 0x0,
 0x0, 0x9e5a, 0x0, 0x0, 0x936d, 0x0, 0x9e58, 0x91a9,
 0x9e59, 0x8ff0, 0x96db, 0x9e5b, 0x9e5c, 0x9788, 0x0, 0x0,
 0x0, 0x0, 0x9e61, 0x0, 0x0, 0x8d59, 0x0, 0x9474,
 0x9e5e, 0x938c, 0x9ddc, 0x9de0, 0x0, 0x8b6e, 0x0, 0x9466,
 0x0, 0x0, 0x0, 0x0, 0x9e60, 0x0, 0x8fbc, 0x94c2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e66, 0x0, 0x94f8,
 0x0, 0x9e5d, 0x0, 0x9e63, 0x9e62, 0x0, 0x0, 0x0,
 0x90cd, 0x0, 0x0, 0x0, 0x0, 0x968d, 0x0, 0x97d1,
 0x0, 0x0, 0x9687, 0x0, 0x89ca, 0x8e7d, 0x0, 0x0,
 0x9867, 0x9e65, 0x9095, 0x0, 0x0, 0x0, 0x9e64, 0x0,
 0x0, 0x9e5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ccd,
 0x0, 0x0, 0x0, 0x9e6b, 0x9e69, 0x0, 0x89cb, 0x9e67,
 0x9e6d, 0x9e73, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x91c6, 0x0, 0x0, 0x95bf, 0x0, 0x9e75, 0x0,
 0x0, 0x0, 0x9541, 0x0, 0x0, 0x0, 0x9e74, 0x9490,
 0x965e, 0x8ab9, 0x0, 0x90f5, 0x8f5f, 0x0, 0x0, 0x0,
 0x92d1, 0x0, 0x974d, 0x0, 0x0, 0x9e70, 0x9e6f, 0x0,
 0x0, 0x0, 0x9e71, 0x0, 0x9e6e, 0x0, 0x0, 0x9e76,
 0x0, 0x9e6c, 0x0, 0x0, 0x9e6a, 0x0, 0x9e72, 0x9e68,
 0x0, 0x928c, 0x0, 0x96f6, 0x8ec4, 0x8df2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8db8, 0x0, 0x0, 0x968f, 0x8a60,
 0x0, 0x0, 0x92cc, 0x93c8, 0x8968, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x90f0, 0x0, 0x0, 0x90b2, 0x8c49,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e78, 0x0,
 0x0, 0x8d5a, 0x8a9c, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9e7a, 0x8a94, 0x9e81, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9e7d, 0x0, 0x90f1, 0x0, 0x0, 0x0,
 0x8a6a, 0x8daa, 0x0, 0x0, 0x8a69, 0x8dcd, 0x0, 0x0,
 0x9e7b, 0x8c85, 0x8c6a, 0x938d, 0x0, 0x0, 0x9e79, 0x0,
 0x88c4, 0x0, 0x0, 0x0, 0x0, 0x9e7c, 0x9e7e, 0x0,
 0x8bcb, 0x8c4b, 0x0, 0x8aba, 0x8b6a, 0x0, 0x0, 0x0,
 0x0, 0x9e82, 0x0, 0x0, 0x8df7, 0x9691, 0x0, 0x8e56,
 0x0, 0x0, 0x0, 0x9e83, 0x0, 0x0, 0x0, 0x954f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9e8f, 0x0, 0x89b1, 0x9e84,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e95, 0x9e85,
 0x0, 0x97c0, 0x0, 0x9e8c, 0x0, 0x947e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9e94, 0x0, 0x9e87,
 0x0, 0x0, 0x0, 0x88b2, 0x9e89, 0x0, 0x0, 0x8d5b,
 0x0, 0x0, 0x0, 0x9e8b, 0x0, 0x9e8a, 0x0, 0x9e86,
 0x9e91, 0x0, 0x8fbd, 0x0, 0x0, 0x0, 0x9aeb, 0x8ce6,
 0x979c, 0x0, 0x0, 0x0, 0x0, 0x9e88, 0x0, 0x92f2,
 0x8a42, 0x8dab, 0x0, 0x9e80, 0x0, 0x9e90, 0x8a81, 0x0,
 0x0, 0x9e8e, 0x9e92, 0x0, 0x8a91, 0x938e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8afc, 0x0, 0x9eb0,
 0x0, 0x0, 0x96c7, 0x9e97, 0x8afb, 0x0, 0x9e9e, 0x0,
 0x0, 0x0, 0x0, 0x965f, 0x0, 0x9e9f, 0x9ea1, 0x0,
 0x9ea5, 0x9e99, 0x0, 0x9249, 0x0, 0x0, 0x0, 0x0,
 0x938f, 0x9ea9, 0x9e9c, 0x0, 0x9ea6, 0x0, 0x0, 0x0,
 0x9ea0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9058,
 0x9eaa, 0x0, 0x0, 0x90b1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ea8, 0x8abb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x986f, 0x9e96, 0x0, 0x0, 0x9ea4, 0x88d6, 0x0,
 0x0, 0x9e98, 0x0, 0x0, 0x96b8, 0x9e9d, 0x9041, 0x92c5,
 0x9e93, 0x0, 0x0, 0x9ea3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x909a, 0x9ead, 0x8c9f, 0x0, 0x0, 0x0,
 0x0, 0x9eaf, 0x9e9a, 0x9eae, 0x0, 0x9ea7, 0x9e9b, 0x0,
 0x9eab, 0x0, 0x9eac, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9ebd, 0x0, 0x0, 0x0, 0x93cc, 0x0, 0x9ea2, 0x0,
 0x0, 0x9eb9, 0x0, 0x0, 0x0, 0x9ebb, 0x0, 0x92d6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x976b, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9596, 0x9eb6, 0x91c8, 0x0, 0x0,
 0x0, 0x9ebc, 0x915e, 0x0, 0x9eb3, 0x9ec0, 0x9ebf, 0x0,
 0x93ed, 0x9ebe, 0x93e8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ec2, 0x9eb5, 0x0, 0x8bc6, 0x9eb8, 0x8f7c,
 0x0, 0x0, 0x0, 0x9480, 0x9eba, 0x8bc9, 0x0, 0x9eb2,
 0x9eb4, 0x9eb1, 0x0, 0x0, 0x984f, 0x8a79, 0x9eb7, 0x0,
 0x0, 0x9ec1, 0x8a54, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8de5, 0x0, 0x0, 0x0, 0x897c, 0x0,
 0x0, 0x9ed2, 0x0, 0x0, 0x9850, 0x9ed5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9059, 0x9ed4, 0x0, 0x0, 0x0,
 0x9ed3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ed0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ec4, 0x0,
 0x0, 0x9ee1, 0x9ec3, 0x0, 0x9ed6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ece, 0x0, 0x0, 0x9ec9, 0x9ec6,
 0x0, 0x9ec7, 0x0, 0x9ecf, 0x0, 0x0, 0x0, 0xeaa0,
 0x0, 0x0, 0x9ecc, 0x8d5c, 0x92c6, 0x9184, 0x9eca, 0x0,
 0x9ec5, 0x0, 0x0, 0x9ec8, 0x0, 0x0, 0x0, 0x0,
 0x976c, 0x968a, 0x0, 0x0, 0x0, 0x9ecd, 0x9ed7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9edf,
 0x9ed8, 0x0, 0x0, 0x9ee5, 0x0, 0x9ee3, 0x0, 0x0,
 0x0, 0x0, 0x9ede, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9edd, 0x0, 0x92ce, 0x0, 0x9185, 0x0, 0x9edb,
 0x0, 0x0, 0x9ed9, 0x0, 0x0, 0x9ee0, 0x0, 0x0,
 0x0, 0x0, 0x9ee6, 0x94f3, 0x9eec, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9ee7, 0x9eea, 0x9ee4, 0x0, 0x0, 0x9294,
 0x0, 0x9557, 0x0, 0x9eda, 0x0, 0x0, 0x9ee2, 0x8fbe,
 0x0, 0x96cd, 0x9ef6, 0x9ee9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8ca0, 0x89a1, 0x8a7e, 0x0, 0x0, 0x9ed1, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8fbf, 0x9eee, 0x0,
 0x9ef5, 0x8ef7, 0x8a92, 0x0, 0x0, 0x924d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9eeb, 0x0, 0x0, 0x9ef0,
 0x9ef4, 0x0, 0x0, 0x8bb4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8b6b, 0x9ef2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b40,
 0x0, 0x93c9, 0x9ef1, 0x0, 0x0, 0x0, 0x9ef3, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9eed, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9eef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a80,
 0x9268, 0x0, 0x0, 0x0, 0x9efa, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ef8, 0x8ce7, 0x0,
 0x9ef7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f40,
 0x0, 0x0, 0x0, 0x0, 0x9e77, 0x0, 0x0, 0x0,
 0x9ef9, 0x0, 0x9efb, 0x9efc, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f4b, 0x0, 0x9f47, 0x0, 0x9e8d, 0x0,
 0x0, 0x0, 0x0, 0x9f46, 0x0, 0x0, 0x0, 0x0,
 0x9f45, 0x0, 0x0, 0x9f42, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9ee8, 0x9f44, 0x9f43, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9f49, 0x0, 0x9845, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f4c, 0x8bf9, 0x0, 0x0, 0x9f48, 0x9f4a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x94a5, 0x0, 0x9f4d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f51, 0x9f4e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9793, 0x9f4f, 0x0, 0x0,
 0x0, 0x0, 0x9edc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f52, 0x0, 0x0, 0x0, 0x9f53, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8954, 0x0, 0x9f55,
 0x8c87, 0x8e9f, 0x0, 0x8bd3, 0x0, 0x0, 0x0, 0x89a2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x977e, 0x0, 0x0, 0x0, 0x0, 0x9f57,
 0x9f56, 0x9f59, 0x8b5c, 0x0, 0x0, 0x8bd4, 0x8abc, 0x0,
 0x0, 0x0, 0x0, 0x9f5c, 0x0, 0x0, 0x0, 0x9f5b,
 0x0, 0x9f5d, 0x0, 0x0, 0x89cc, 0x0, 0x9256, 0x0,
 0x9f5e, 0x0, 0x0, 0x8abd, 0x9f60, 0x0, 0x0, 0x0,
 0x0, 0x9f5f, 0x0, 0x9f61, 0x0, 0x0, 0x0, 0x9f62,
 0x0, 0x9f63, 0x8e7e, 0x90b3, 0x8d9f, 0x0, 0x9590, 0x0,
 0x0, 0x95e0, 0x9863, 0x0, 0x0, 0x0, 0x0, 0x8e95,
 0x0, 0x0, 0x0, 0x8dce, 0x97f0, 0x0, 0x0, 0x0,
 0x9f64, 0x9f65, 0x0, 0x8e80, 0x0, 0x0, 0x0, 0x9f66,
 0x9f67, 0x0, 0x0, 0x9f69, 0x9f68, 0x0, 0x9677, 0x0,
 0x0, 0x8f7d, 0x8eea, 0x8e63, 0x0, 0x9f6a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f6c, 0x9042, 0x0,
 0x9f6b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9f6d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9f6e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9f6f, 0x9f70, 0x0, 0x0, 0x0, 0x9f71,
 0x0, 0x9f73, 0x9f72, 0x9f74, 0x89a3, 0x9269, 0x0, 0x9f75,
 0x0, 0x0, 0x8e45, 0x8a6b, 0x9f76, 0x0, 0x0, 0x9361,
 0x9aca, 0x0, 0x0, 0x0, 0x0, 0x8b42, 0x9f77, 0x0,
 0x0, 0x0, 0x0, 0x9f78, 0x0, 0x95ea, 0x9688, 0x0,
 0x0, 0x0, 0x93c5, 0x9f79, 0x94e4, 0x0, 0x0, 0x0,
 0x94f9, 0x0, 0x0, 0x96d1, 0x0, 0x0, 0x0, 0x9f7a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9f7c, 0x9f7b, 0x0, 0x0, 0x9f7e,
 0x0, 0x0, 0x0, 0x9f7d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9f81, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e81,
 0x0, 0x96af, 0x0, 0x9f82, 0x9f83, 0x0, 0x0, 0x8b43,
 0x0, 0x0, 0x0, 0x9f84, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9f86, 0x9f85, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9085, 0x0, 0x0, 0x9558,
 0x8969, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94c3, 0x0,
 0x92f3, 0x8f60, 0x8b81, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94c4, 0x0,
 0x8eac, 0x0, 0x0, 0x0, 0x0, 0x9f88, 0x0, 0x8abe,
 0x0, 0x0, 0x8998, 0x0, 0x0, 0x93f0, 0x9f87, 0x8d5d,
 0x9272, 0x0, 0x9f89, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9f91, 0x0, 0x9f8a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x91bf, 0x0, 0x8b82, 0x9f92, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c88, 0x0, 0x0, 0x8b44, 0x9f90, 0x0,
 0x0, 0x9f8e, 0x9f8b, 0x9780, 0x0, 0x0, 0x0, 0x0,
 0x92be, 0x0, 0x0, 0x0, 0x93d7, 0x9f8c, 0x0, 0x0,
 0x9f94, 0x0, 0x9f93, 0x8c42, 0x0, 0x0, 0x89ab, 0x0,
 0x0, 0x8db9, 0x9f8d, 0x9f8f, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9676, 0x91f2, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9697, 0x0, 0x0, 0x9f9c, 0x0,
 0x0, 0x9f9d, 0x0, 0x89cd, 0x0, 0x0, 0x0, 0x0,
 0x95a6, 0x96fb, 0x9f9f, 0x8ea1, 0x8fc0, 0x9f98, 0x9f9e, 0x8988,
 0x0, 0x8bb5, 0x0, 0x0, 0x9f95, 0x9f9a, 0x0, 0x0,
 0x0, 0x90f2, 0x9491, 0x0, 0x94e5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9f97, 0x0, 0x9640, 0x0, 0x9f99,
 0x0, 0x9fa2, 0x0, 0x9fa0, 0x0, 0x9f9b, 0x0, 0x0,
 0x0, 0x9641, 0x9467, 0x8b83, 0x0, 0x9344, 0x0, 0x0,
 0x928d, 0x0, 0x9fa3, 0x0, 0x0, 0x0, 0x0, 0x9fa1,
 0x91d7, 0x9f96, 0x0, 0x896a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x976d, 0x9fae, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9fad, 0x0, 0x0, 0x0, 0x0, 0x90f4, 0x0,
 0x9faa, 0x0, 0x978c, 0x0, 0x0, 0x93b4, 0x9fa4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x92c3, 0x0, 0x0, 0x0,
 0x896b, 0x8d5e, 0x9fa7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8f46, 0x9fac, 0x0, 0x9fab, 0x9fa6, 0x0, 0x9fa9,
 0x0, 0x0, 0x8a88, 0x0, 0x9fa8, 0x9468, 0x0, 0x0,
 0x97ac, 0x0, 0x0, 0x8ff2, 0x90f3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9fb4, 0x9fb2, 0x0, 0x956c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9faf, 0x9fb1, 0x0, 0x8959, 0x0, 0x0,
 0x8d5f, 0x9851, 0x0, 0x8a5c, 0x0, 0x9582, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9781, 0x0, 0x0, 0x8a43, 0x905a,
 0x9fb3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9fb8, 0x0, 0x0, 0x8fc1,
 0x0, 0x0, 0x0, 0x974f, 0x0, 0x9fb5, 0x0, 0x0,
 0x0, 0x0, 0x9fb0, 0x0, 0x9fb6, 0x0, 0x0, 0x0,
 0x97dc, 0x0, 0x9393, 0x93c0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a55, 0x0,
 0x0, 0x8974, 0x0, 0x0, 0x9fbc, 0x0, 0x0, 0x9fbf,
 0x0, 0x0, 0x0, 0x97c1, 0x0, 0x0, 0x0, 0x9784,
 0x0, 0x0, 0x0, 0x0, 0x9fc6, 0x9fc0, 0x9fbd, 0x0,
 0x0, 0x0, 0x97d2, 0x9fc3, 0x0, 0x0, 0x0, 0x0,
 0x8f69, 0x9fc5, 0x0, 0x0, 0x9fca, 0x0, 0x0, 0x9391,
 0x9fc8, 0x0, 0x0, 0x0, 0x0, 0x9fc2, 0x0, 0x0,
 0x9257, 0x0, 0x0, 0x9fc9, 0x0, 0x9fbe, 0x0, 0x9fc4,
 0x0, 0x9fcb, 0x88fa, 0x9fc1, 0x0, 0x9fcc, 0x0, 0x0,
 0x905b, 0x0, 0x8f7e, 0x0, 0x95a3, 0x0, 0x8dac, 0x0,
 0x9fb9, 0x9fc7, 0x9359, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90b4, 0x0, 0x8a89, 0x8dcf,
 0x8fc2, 0x9fbb, 0x8f61, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c6b, 0x0, 0x9fba, 0x0, 0x0, 0x0,
 0x9fd0, 0x8f8d, 0x8cb8, 0x0, 0x9fdf, 0x0, 0x9fd9, 0x8b94,
 0x936e, 0x0, 0x9fd4, 0x9fdd, 0x88ad, 0x8951, 0x0, 0x0,
 0x89b7, 0x0, 0x9fd6, 0x91aa, 0x9fcd, 0x9fcf, 0x8d60, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9fe0,
 0x0, 0x9fdb, 0x0, 0x0, 0x0, 0x9fd3, 0x0, 0x0,
 0x0, 0x0, 0x9fda, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x96a9, 0x0, 0x0, 0x9fd8, 0x9fdc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8cce, 0x0, 0x8fc3,
 0x0, 0x0, 0x9258, 0x0, 0x0, 0x0, 0x9fd2, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x974e, 0x0,
 0x0, 0x0, 0x9fd5, 0x0, 0x0, 0x9fce, 0x9392, 0x0,
 0x0, 0x9fd1, 0x0, 0x0, 0x0, 0x9fd7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9870, 0x8ebc, 0x969e,
 0x0, 0x9fe1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x94ac, 0x0, 0x0, 0x9fed, 0x8cb9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f80, 0x0, 0x9fe3,
 0x0, 0x0, 0x0, 0x97ad, 0x8d61, 0x0, 0x9ff0, 0x0,
 0x0, 0x88ec, 0x0, 0x0, 0x9fee, 0x0, 0x0, 0x0,
 0x0, 0x9fe2, 0x0, 0x0, 0x0, 0x0, 0x9fe8, 0x0,
 0x0, 0x9fea, 0x0, 0x0, 0x0, 0x976e, 0x9fe5, 0x0,
 0x0, 0x934d, 0x0, 0x0, 0x9fe7, 0x0, 0x0, 0x0,
 0x0, 0x9fef, 0x0, 0x9fe9, 0x96c5, 0x0, 0x0, 0x0,
 0x9fe4, 0x0, 0x8ea0, 0x9ffc, 0x0, 0x0, 0x0, 0x0,
 0x8a8a, 0x0, 0x9fe6, 0x9feb, 0x9fec, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x91ea, 0x91d8, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ff4, 0x0, 0x0, 0x9ffa, 0x0,
 0x0, 0x9ff8, 0x0, 0x9348, 0x0, 0x0, 0xe042, 0x9ff5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9ff6, 0x9fde, 0x0,
 0x8b99, 0x9559, 0x0, 0x0, 0x0, 0x8ebd, 0x0, 0x0,
 0x8d97, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9852, 0x0,
 0x9ff2, 0x0, 0xe041, 0x8989, 0x9186, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9499,
 0x0, 0x8abf, 0x97f8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x969f, 0x92d0, 0x0, 0x0, 0x0, 0x0,
 0x9ff9, 0x9ffb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9151,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe040, 0x9ff7, 0x0,
 0x9ff1, 0x0, 0x0, 0x0, 0x8ac1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c89, 0x0, 0x0, 0x0, 0xe04e,
 0x0, 0x0, 0xe049, 0x90f6, 0x0, 0x0, 0x8a83, 0x0,
 0x0, 0x0, 0x0, 0x8f81, 0x0, 0xe052, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe04b, 0x92aa, 0xe048, 0x92d7,
 0x0, 0x0, 0x0, 0xe06b, 0x0, 0x0, 0x0, 0xe045,
 0x0, 0xe044, 0x0, 0xe04d, 0x0, 0x0, 0x0, 0xe047,
 0xe046, 0xe04c, 0x0, 0x909f, 0x0, 0xe043, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe04f, 0x0, 0x0,
 0xe050, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ac0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe055, 0x0, 0xe054, 0xe056, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe059, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9362, 0x0, 0xe053, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe057, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c83,
 0x91f7, 0xe051, 0x945a, 0x0, 0x0, 0xe058, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe05d, 0xe05b, 0x0, 0x0, 0xe05e,
 0x0, 0x0, 0xe061, 0x0, 0x0, 0x0, 0xe05a, 0x8d8a,
 0x9447, 0x0, 0x0, 0x9fb7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9794, 0xe05c, 0x0, 0xe060, 0x91f3, 0x0,
 0xe05f, 0x0, 0xe04a, 0x0, 0x0, 0xe889, 0x0, 0x0,
 0x0, 0xe064, 0x0, 0x0, 0x0, 0xe068, 0x0, 0x0,
 0xe066, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe062, 0x0, 0xe063, 0x0, 0x0, 0x0, 0xe067, 0x0,
 0xe065, 0x0, 0x0, 0x0, 0x956d, 0x0, 0x0, 0xe06d,
 0x0, 0xe06a, 0xe069, 0x0, 0xe06c, 0x93d2, 0xe06e, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9295, 0x91eb, 0x0,
 0x0, 0x0, 0x0, 0x90a3, 0x0, 0x0, 0x0, 0xe06f,
 0x0, 0xe071, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe070, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9ff3, 0x0, 0x0, 0x0, 0x0,
 0xe072, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93e5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe073, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x89ce, 0x0, 0x0, 0x0, 0x9394, 0x8a44,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b84,
 0x0, 0x0, 0x0, 0x8edc, 0x8dd0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9846, 0x9086, 0x0, 0x0, 0x0, 0x898a, 0x0, 0x0,
 0x0, 0xe075, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe074, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe078, 0x9259, 0xe07b, 0xe076, 0x0,
 0x0, 0x0, 0xe07a, 0x0, 0x0, 0x0, 0x0, 0xe079,
 0x935f, 0x88d7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x97f3,
 0x0, 0x0, 0xe07d, 0x0, 0x0, 0x0, 0x8947, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe080, 0x0, 0x0, 0x0, 0xe07e, 0x0, 0xe07c, 0x0,
 0xe077, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9642, 0x0, 0x0, 0x0, 0xe082, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe081, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x898b, 0x0, 0x0, 0x0, 0x0,
 0xe084, 0x95b0, 0x0, 0xe083, 0x0, 0x0, 0x0, 0x0,
 0x96b3, 0x0, 0x0, 0x0, 0x0, 0x8fc5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9152, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8fc4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x97f9, 0x0, 0x0, 0xe08a, 0x0, 0x90f7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe086, 0xe08b, 0x0, 0x0,
 0x898c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe089, 0x0, 0x9481, 0xe085, 0xe088, 0x8fc6, 0x0,
 0x94cf, 0x0, 0x0, 0xe08c, 0x0, 0x8ecf, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90f8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe08f, 0x0, 0x0, 0x0, 0xe087,
 0x0, 0x8c46, 0x0, 0x0, 0x0, 0x0, 0xe08d, 0x0,
 0x0, 0x0, 0x0, 0x976f, 0xe090, 0x0, 0x0, 0x0,
 0xeaa4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f6e, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe091,
 0x0, 0x0, 0x0, 0xe092, 0x0, 0x0, 0x0, 0x0,
 0x944d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe094, 0x0, 0x0, 0x0, 0x0, 0xe095, 0x0, 0x0,
 0x0, 0x0, 0x9452, 0x0, 0x0, 0x0, 0x0, 0x9395,
 0xe097, 0x0, 0x0, 0x0, 0x0, 0xe099, 0x0, 0x97d3,
 0x0, 0xe096, 0x0, 0xe098, 0x898d, 0x0, 0xe093, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a7a, 0xe09a,
 0x0, 0x0, 0x0, 0x0, 0x9187, 0x8e57, 0xe09c, 0x0,
 0x0, 0x0, 0x0, 0xe09b, 0x9043, 0x99d7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe09d, 0x0, 0x0, 0x0,
 0xe09f, 0x0, 0xe08e, 0xe09e, 0x0, 0x0, 0xe0a0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x949a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe0a1, 0x0, 0x0, 0xe0a2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0a3, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0a4,
 0x0, 0x92dc, 0x0, 0xe0a6, 0xe0a5, 0x0, 0x0, 0xe0a7,
 0x0, 0xe0a8, 0x0, 0x0, 0x0, 0x8edd, 0x9583, 0x0,
 0x0, 0x0, 0x96ea, 0xe0a9, 0xe0aa, 0x9175, 0x8ea2, 0xe0ab,
 0xe0ac, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0ad, 0x95d0,
 0x94c5, 0x0, 0x0, 0xe0ae, 0x9476, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x92ab, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0af, 0x89e5, 0x0, 0x8b8d, 0x0, 0x96c4, 0x0, 0x96b4,
 0x0, 0x89b2, 0x9853, 0x0, 0x0, 0x0, 0x0, 0x9671,
 0x0, 0x95a8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x90b5, 0x0, 0xe0b0, 0x0, 0x0, 0x0,
 0x0, 0x93c1, 0x0, 0x0, 0x0, 0x8ca1, 0xe0b1, 0x0,
 0x8dd2, 0xe0b3, 0xe0b2, 0x0, 0x0, 0x0, 0x0, 0xe0b4,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0b5, 0x0, 0x0, 0x0, 0xe0b6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8b5d, 0x0, 0xe0b7, 0x0, 0x0, 0x0, 0x0, 0xe0b8,
 0x0, 0x0, 0x0, 0x0, 0x8ca2, 0x0, 0x0, 0x94c6,
 0x0, 0x0, 0xe0ba, 0x0, 0x0, 0x0, 0x8ff3, 0x0,
 0x0, 0xe0b9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8bb6, 0xe0bb, 0xe0bd, 0x0, 0xe0bc, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0be, 0x0,
 0x8ccf, 0x0, 0xe0bf, 0x0, 0x0, 0x0, 0x0, 0x8be7,
 0x0, 0x915f, 0x0, 0x8d9d, 0x0, 0x0, 0x0, 0x0,
 0xe0c1, 0xe0c2, 0xe0c0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8eeb, 0x0, 0x0, 0x93c6, 0x8bb7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0c4,
 0x924b, 0xe0c3, 0x0, 0x0, 0x9854, 0x9482, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0c7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0c9, 0xe0c6,
 0x0, 0x0, 0x0, 0x96d2, 0xe0c8, 0xe0ca, 0x0, 0x97c2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0ce, 0x0, 0x0,
 0x0, 0xe0cd, 0x9296, 0x944c, 0x0, 0x0, 0x8ca3, 0xe0cc,
 0x0, 0x0, 0x0, 0x0, 0xe0cb, 0x0, 0x9750, 0x9751,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0cf, 0x898e,
 0x0, 0x0, 0x0, 0x0, 0x8d96, 0x8e82, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0d0, 0xe0d1,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0d3,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8f62, 0x0, 0x0, 0x0, 0x0,
 0xe0d5, 0x0, 0xe0d4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0d6, 0x0, 0x8a6c, 0x0, 0x0, 0xe0d8, 0x0, 0x0,
 0xe0d7, 0x0, 0xe0da, 0xe0d9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8cba, 0x0, 0x0, 0x97a6,
 0x0, 0x8bca, 0x0, 0x89a4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8be8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8adf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97e6, 0xe0dc, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe0de, 0x0, 0x0, 0x0, 0x0,
 0xe0df, 0x0, 0x89cf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0db, 0x0, 0x8e58, 0x0, 0x0, 0x92bf, 0xe0dd, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0e2, 0x0,
 0x8eec, 0x0, 0x0, 0x0, 0x0, 0xe0e0, 0x0, 0x0,
 0x0, 0x0, 0x8c5d, 0x0, 0x0, 0x94c7, 0xe0e1, 0x0,
 0x0, 0xe0fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe0e7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8cbb, 0x0,
 0x0, 0x0, 0x0, 0x8b85, 0x0, 0xe0e4, 0x979d, 0x0,
 0x0, 0x97ae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x91f4, 0x0, 0x0, 0xe0e6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0e8, 0x97d4, 0x8bd5, 0x94fa, 0x9469, 0x0,
 0x0, 0x0, 0xe0e9, 0x0, 0x0, 0x0, 0x0, 0xe0eb,
 0x0, 0xe0ee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0ea, 0x0, 0x0,
 0x0, 0xe0ed, 0x8ce8, 0x896c, 0xe0ef, 0x0, 0x9090, 0xe0ec,
 0x97da, 0x0, 0x0, 0xe0f2, 0xeaa2, 0x0, 0x0, 0x0,
 0x0, 0xe0f0, 0xe0f3, 0x0, 0x0, 0x0, 0x0, 0xe0e5,
 0xe0f1, 0x0, 0x0, 0x8dba, 0x0, 0x0, 0xe0f4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0f5, 0x0,
 0x0, 0x0, 0x0, 0x979e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe0f6, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0f7, 0x0,
 0x0, 0x0, 0xe0e3, 0x0, 0x0, 0x0, 0x0, 0xe0f8,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8ac2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ea3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe0f9, 0x0, 0x0, 0x0, 0x0, 0xe0fa,
 0x0, 0x0, 0x0, 0x0, 0xe0fb, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x895a, 0x0, 0x0, 0x0,
 0xe140, 0x0, 0x955a, 0xe141, 0x0, 0x0, 0x8aa2, 0xe142,
 0x0, 0xe143, 0x0, 0x0, 0x0, 0x0, 0xe144, 0x0,
 0xe146, 0xe147, 0xe145, 0x0, 0x0, 0x0, 0x9572, 0xe149,
 0xe148, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe14b, 0xe14a, 0xe14c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe14d, 0xe14f, 0xe14e, 0x0,
 0x0, 0x8d99, 0x0, 0xe151, 0x0, 0xe150, 0x0, 0x0,
 0x8ac3, 0x0, 0x9072, 0x0, 0x935b, 0x0, 0xe152, 0x90b6,
 0x0, 0x0, 0x0, 0x8e59, 0x0, 0x8999, 0xe153, 0x0,
 0x9770, 0x0, 0x0, 0x95e1, 0xe154, 0x0, 0x0, 0x0,
 0x9363, 0x9752, 0x8d62, 0x905c, 0x0, 0x0, 0x0, 0x926a,
 0x99b2, 0x0, 0x92ac, 0x89e6, 0xe155, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe156, 0x0, 0xe15b, 0x0,
 0x0, 0xe159, 0xe158, 0x9dc0, 0x8a45, 0xe157, 0x0, 0x88d8,
 0x0, 0x94a8, 0x0, 0x0, 0x94c8, 0x0, 0x0, 0x0,
 0x0, 0x97af, 0xe15c, 0xe15a, 0x927b, 0x90a4, 0x0, 0x0,
 0x0, 0x954c, 0x0, 0xe15e, 0x97aa, 0x8c6c, 0xe15f, 0xe15d,
 0x94d4, 0xe160, 0x0, 0xe161, 0x0, 0x0, 0x88d9, 0x0,
 0x0, 0x8ff4, 0xe166, 0x0, 0xe163, 0x93eb, 0xe162, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b45, 0x0, 0x0,
 0xe169, 0x0, 0x0, 0x0, 0xe164, 0xe165, 0x0, 0xe168,
 0xe167, 0x9544, 0x0, 0x0, 0x9161, 0x9160, 0x0, 0x8b5e,
 0x0, 0x0, 0xe16a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe16b, 0x0, 0x0, 0xe16c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe16e, 0x0, 0xe16d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8975, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe176,
 0x94e6, 0xe170, 0x0, 0xe172, 0x0, 0x0, 0xe174, 0x905d,
 0x0, 0x0, 0xe175, 0xe173, 0x8ebe, 0x0, 0x0, 0x0,
 0xe16f, 0xe171, 0x0, 0x9561, 0x0, 0x8fc7, 0x0, 0x0,
 0xe178, 0x0, 0x0, 0xe177, 0x0, 0x0, 0x0, 0x0,
 0xe179, 0x0, 0x8ea4, 0x8dad, 0x0, 0x0, 0x9397, 0xe17a,
 0x0, 0x92c9, 0x0, 0x0, 0xe17c, 0x0, 0x0, 0x0,
 0x979f, 0xe17b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9189,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe182, 0x0,
 0xe184, 0xe185, 0x9273, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe183, 0x0, 0xe180, 0x0, 0xe17d, 0xe17e, 0x0, 0xe181,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe188,
 0x0, 0xe186, 0x0, 0xe187, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe189, 0xe18b,
 0xe18c, 0xe18d, 0x0, 0xe18e, 0x0, 0x0, 0xe18a, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe190, 0x0,
 0x0, 0x0, 0xe18f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe191, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x97c3, 0x0, 0x0, 0x0, 0xe194, 0xe192, 0xe193, 0x0,
 0x0, 0x0, 0x8ae0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x96fc, 0x0, 0x0, 0x0, 0x95c8, 0x0, 0xe196, 0x0,
 0x0, 0x0, 0xe195, 0x0, 0x0, 0x0, 0x0, 0xe197,
 0xe198, 0x0, 0x0, 0x0, 0x0, 0xe19c, 0xe199, 0xe19a,
 0xe19b, 0x0, 0xe19d, 0x0, 0x0, 0x0, 0xe19e, 0x0,
 0xe19f, 0x0, 0x0, 0x0, 0xe1a0, 0x0, 0xe1a1, 0x0,
 0x94ad, 0x936f, 0xe1a2, 0x9492, 0x9553, 0x0, 0xe1a3, 0x0,
 0x0, 0xe1a4, 0x9349, 0x0, 0x8a46, 0x8d63, 0xe1a5, 0x0,
 0x0, 0xe1a6, 0x0, 0x0, 0x94a9, 0xe1a7, 0x0, 0x8e48,
 0x0, 0x0, 0xe1a9, 0x0, 0x0, 0xe1a8, 0x0, 0x0,
 0xe1aa, 0xe1ab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x94e7, 0x0, 0xe1ac,
 0x0, 0x0, 0x0, 0xe1ad, 0x0, 0x0, 0xea89, 0xe1ae,
 0xe1af, 0xe1b0, 0x0, 0x0, 0x0, 0x0, 0x8e4d, 0x0,
 0x0, 0xe1b1, 0x9475, 0x0, 0x0, 0x967e, 0x0, 0x896d,
 0x0, 0x8976, 0x0, 0x0, 0xe1b2, 0x0, 0x0, 0x0,
 0x0, 0xe1b4, 0x0, 0x0, 0x0, 0xe1b3, 0x9390, 0x0,
 0x0, 0x0, 0x90b7, 0x9f58, 0x0, 0xe1b5, 0x96bf, 0x0,
 0xe1b6, 0x0, 0x8ac4, 0x94d5, 0xe1b7, 0x0, 0xe1b8, 0x0,
 0x0, 0xe1b9, 0x0, 0x0, 0x0, 0x96da, 0x0, 0x0,
 0x0, 0x96d3, 0x0, 0x92bc, 0x0, 0x0, 0x0, 0x918a,
 0x0, 0x0, 0xe1bb, 0x0, 0x0, 0x8f82, 0x0, 0x0,
 0x8fc8, 0x0, 0x0, 0xe1be, 0x0, 0x0, 0xe1bd, 0xe1bc,
 0x94fb, 0x0, 0x8ac5, 0x8ca7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe1c4, 0x0, 0x0, 0xe1c1, 0x905e, 0x96b0,
 0x0, 0x0, 0x0, 0xe1c0, 0xe1c2, 0xe1c3, 0x0, 0x0,
 0xe1bf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1c5, 0xe1c6,
 0x0, 0x92ad, 0x0, 0x8ae1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1c7, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe1c8, 0xe1cb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9087,
 0x0, 0x93c2, 0x0, 0xe1cc, 0x9672, 0x0, 0xe1c9, 0x0,
 0x0, 0xe1ca, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe1cf, 0x0, 0x0, 0x0, 0x0, 0xe1ce, 0xe1cd, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe1d1, 0x0, 0x0, 0xe1d0, 0x0, 0x0, 0xe1d2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe1d4, 0x0, 0xe1d3, 0x0,
 0x0, 0x0, 0x0, 0x95cb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8f75, 0x97c4, 0x0, 0x0, 0xe1d5, 0x0,
 0x0, 0x93b5, 0x0, 0x0, 0xe1d6, 0x0, 0x0, 0xe1d7,
 0x0, 0xe1db, 0xe1d9, 0xe1da, 0x0, 0xe1d8, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1dc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe1dd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1de, 0x0, 0x0,
 0xe1df, 0x96b5, 0xe1e0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x96ee, 0xe1e1, 0x0, 0x926d, 0x0, 0x948a, 0x0, 0x8be9,
 0x0, 0x0, 0x0, 0x925a, 0xe1e2, 0x8bb8, 0x0, 0x0,
 0x0, 0x90ce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe1e3, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8dbb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe1e4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe1e5, 0x0, 0x0, 0x8ca4, 0x8dd3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1e7,
 0x0, 0x0, 0x0, 0x0, 0x9375, 0x8dd4, 0x8b6d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9643, 0x0, 0x946a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9376, 0x0, 0x0, 0x0, 0x0, 0x8d7b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe1e9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8fc9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97b0, 0x8d64, 0x0, 0x0, 0x8ca5, 0x0,
 0x0, 0x94a1, 0x0, 0xe1eb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe1ed, 0x0, 0x0, 0x0, 0x0,
 0x8ce9, 0x0, 0x0, 0x0, 0x0, 0xe1ec, 0x92f4, 0x0,
 0x0, 0x0, 0x0, 0xe1ef, 0x8a56, 0xe1ea, 0x0, 0x0,
 0x94e8, 0x0, 0x894f, 0x0, 0x8dea, 0x0, 0x9871, 0x0,
 0x0, 0xe1ee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe1f0, 0x0, 0x0, 0x0, 0x95c9,
 0x0, 0x90d7, 0xe1f2, 0x0, 0x0, 0x0, 0x0, 0xe1f3,
 0x0, 0x0, 0x0, 0x0, 0xe1f1, 0x0, 0x0, 0x0,
 0x0, 0x8a6d, 0x0, 0xe1f9, 0x0, 0xe1f8, 0x0, 0x0,
 0x8ea5, 0x0, 0x0, 0x0, 0xe1fa, 0xe1f5, 0x0, 0x0,
 0x0, 0xe1fb, 0xe1f6, 0x0, 0x0, 0x0, 0x0, 0x94d6,
 0xe1f4, 0x0, 0x0, 0xe1f7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe241, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe240, 0x9681,
 0x0, 0x0, 0x0, 0xe1fc, 0x0, 0x0, 0x88e9, 0x0,
 0x0, 0x0, 0x0, 0xe243, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe242, 0x0, 0x0, 0x0,
 0x8fca, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe244, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9162, 0x0, 0x0,
 0xe246, 0xe245, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe247, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1e6, 0x0, 0x0,
 0x0, 0xe1e8, 0xe249, 0xe248, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8ea6, 0x0, 0x97e7, 0x0, 0x8ed0, 0x0, 0xe24a,
 0x8c56, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b5f, 0x8b46,
 0x8e83, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9753, 0x0, 0x0, 0xe250, 0x0, 0xe24f, 0x9163, 0xe24c,
 0x0, 0x0, 0xe24e, 0x0, 0x0, 0x8f6a, 0x905f, 0xe24d,
 0xe24b, 0x0, 0x9449, 0x0, 0x0, 0x8fcb, 0x0, 0x0,
 0x955b, 0x0, 0x0, 0x0, 0x0, 0x8dd5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9398,
 0x0, 0x0, 0xe251, 0x0, 0x0, 0x0, 0x0, 0xe252,
 0xe268, 0x8bd6, 0x0, 0x0, 0x985c, 0x9154, 0x0, 0x0,
 0x0, 0x0, 0xe253, 0x0, 0x0, 0x89d0, 0x92f5, 0x959f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe254, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b9a, 0xe255,
 0x0, 0x0, 0xe257, 0x0, 0x0, 0x0, 0xe258, 0x0,
 0x9448, 0x0, 0x0, 0xe259, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe25a, 0xe25b, 0x0, 0x0, 0x8bd7, 0x89d1, 0x93c3,
 0x8f47, 0x8e84, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe25c, 0x0, 0x8f48, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89c8, 0x9562, 0x0, 0x0, 0xe25d, 0x0, 0x0,
 0x94e9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9164,
 0x0, 0xe260, 0x0, 0xe261, 0x9489, 0x0, 0x9060, 0xe25e,
 0x0, 0x9281, 0x0, 0x0, 0xe25f, 0x0, 0x0, 0x0,
 0x8fcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x88da, 0x0, 0x0, 0x0, 0x0,
 0x8b48, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe262, 0x0, 0x0, 0x92f6, 0x0, 0xe263, 0x90c5, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x96ab, 0x0, 0x0, 0x9542,
 0xe264, 0xe265, 0x9274, 0x0, 0x97c5, 0x0, 0x0, 0xe267,
 0xe266, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8eed, 0x0,
 0x0, 0xe269, 0x88ee, 0x0, 0x0, 0x0, 0x0, 0xe26c,
 0x0, 0x0, 0x0, 0xe26a, 0x89d2, 0x8c6d, 0xe26b, 0x8d65,
 0x8d92, 0x0, 0x95e4, 0xe26d, 0x0, 0x0, 0x9673, 0x0,
 0x0, 0xe26f, 0x0, 0x0, 0x0, 0x90cf, 0x896e, 0x89b8,
 0x88aa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe26e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe270, 0xe271, 0x8ff5, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe272, 0x0, 0x8a6e, 0x0, 0x0, 0x0, 0x0,
 0xe274, 0x0, 0x0, 0x0, 0x8c8a, 0x0, 0x8b86, 0x0,
 0x0, 0xe275, 0x8bf3, 0x0, 0x0, 0xe276, 0x0, 0x90fa,
 0x0, 0x93cb, 0x0, 0x90de, 0x8df3, 0x0, 0x0, 0x0,
 0xe277, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9282, 0x918b, 0x0, 0xe279, 0xe27b, 0xe278,
 0xe27a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c41,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe27c, 0x8c45, 0x0, 0x0, 0x0, 0x8b87, 0x9771,
 0xe27e, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe280, 0x0,
 0x0, 0x0, 0x894d, 0x0, 0x0, 0x0, 0x0, 0xe283,
 0x0, 0x0, 0x0, 0x8a96, 0xe282, 0xe281, 0x0, 0xe285,
 0xe27d, 0x0, 0xe286, 0x97a7, 0x0, 0xe287, 0x0, 0xe288,
 0x0, 0x0, 0x9af2, 0xe28a, 0x0, 0xe289, 0x0, 0x0,
 0x0, 0xe28b, 0xe28c, 0x0, 0x97b3, 0xe28d, 0x0, 0xe8ed,
 0x8fcd, 0xe28e, 0xe28f, 0x8f76, 0x0, 0x93b6, 0xe290, 0x0,
 0x0, 0x0, 0x9247, 0x0, 0x0, 0xe291, 0x0, 0x925b,
 0xe292, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ba3, 0x0,
 0x995e, 0x927c, 0x8eb1, 0x0, 0x0, 0x0, 0x0, 0x8ac6,
 0x0, 0x0, 0xe293, 0x0, 0xe2a0, 0x0, 0xe296, 0x0,
 0x8b88, 0x0, 0xe295, 0xe2a2, 0x0, 0x0, 0x0, 0xe294,
 0x0, 0x8fce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe298, 0xe299, 0x0, 0x934a, 0x0, 0x0, 0xe29a, 0x0,
 0x8a7d, 0x0, 0x0, 0x0, 0x0, 0x9079, 0x9584, 0x0,
 0xe29c, 0x0, 0x0, 0x0, 0x91e6, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe297, 0x0, 0xe29b, 0xe29d, 0x0,
 0x0, 0x8df9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2a4, 0x954d, 0x0,
 0x94a4, 0x9399, 0x0, 0x8bd8, 0xe2a3, 0xe2a1, 0x0, 0x94b3,
 0xe29e, 0x927d, 0x939b, 0x0, 0x939a, 0x0, 0x8df4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2b6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2a6, 0x0, 0xe2a8,
 0x0, 0x0, 0x0, 0x0, 0xe2ab, 0x0, 0xe2ac, 0x0,
 0xe2a9, 0xe2aa, 0x0, 0x0, 0xe2a7, 0xe2a5, 0x0, 0x0,
 0x0, 0x0, 0xe29f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x95cd, 0x89d3,
 0x0, 0x0, 0x0, 0xe2b3, 0x0, 0xe2b0, 0x0, 0xe2b5,
 0x0, 0x0, 0xe2b4, 0x0, 0x9493, 0x96a5, 0x0, 0x8e5a,
 0xe2ae, 0xe2b7, 0xe2b2, 0x0, 0xe2b1, 0xe2ad, 0x0, 0xe2af,
 0x0, 0x8ac7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x925c, 0x0, 0x0, 0x90fb, 0x0, 0x0,
 0x0, 0x94a0, 0x0, 0x0, 0xe2bc, 0x0, 0x0, 0x0,
 0x94a2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x90df, 0xe2b9, 0x0, 0x0, 0x94cd, 0x0, 0xe2bd, 0x95d1,
 0x0, 0x927a, 0x0, 0xe2b8, 0xe2ba, 0x0, 0x0, 0xe2bb,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2be, 0x0, 0x0,
 0x8ec2, 0x0, 0x0, 0x0, 0x93c4, 0xe2c3, 0xe2c2, 0x0,
 0x0, 0xe2bf, 0x0, 0x0, 0x0, 0x9855, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe2c8, 0x0, 0x0, 0xe2cc, 0xe2c9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe2c5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2c6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2cb, 0x0, 0x0,
 0x0, 0xe2c0, 0x99d3, 0xe2c7, 0xe2c1, 0x0, 0x0, 0xe2ca,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2d0,
 0x0, 0x8ac8, 0x0, 0xe2cd, 0x0, 0x0, 0x0, 0xe2ce,
 0x0, 0x0, 0xe2cf, 0xe2d2, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2d1,
 0x94f4, 0x0, 0x0, 0x0, 0x0, 0xe2d3, 0x97fa, 0x95eb,
 0xe2d8, 0x0, 0x0, 0xe2d5, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe2d4, 0x90d0, 0x0, 0xe2d7,
 0xe2d9, 0x0, 0x0, 0x0, 0xe2d6, 0x0, 0xe2dd, 0x0,
 0xe2da, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe2db,
 0xe2c4, 0x0, 0x0, 0x0, 0xe2dc, 0xe2de, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe2df, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x95c4, 0x0, 0xe2e0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x96e0,
 0x0, 0x0, 0x8bcc, 0x8c48, 0xe2e1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x95b2, 0x0, 0x9088, 0x0, 0x96ae, 0x0,
 0x0, 0xe2e2, 0x0, 0x97b1, 0x0, 0x0, 0x9494, 0x0,
 0x9165, 0x9453, 0x0, 0x0, 0x8f6c, 0x0, 0x0, 0x0,
 0x0, 0x88be, 0x0, 0xe2e7, 0xe2e5, 0x0, 0xe2e3, 0x8a9f,
 0x0, 0x8fcf, 0xe2e8, 0x0, 0x0, 0xe2e6, 0x0, 0xe2e4,
 0xe2ec, 0x0, 0x0, 0xe2eb, 0xe2ea, 0xe2e9, 0x0, 0xe2ef,
 0x0, 0x0, 0x0, 0x0, 0xe2ed, 0x0, 0x0, 0x0,
 0xe2ee, 0x90b8, 0x0, 0x0, 0xe2f1, 0x0, 0x0, 0xe2f0,
 0x0, 0x0, 0x0, 0x0, 0x8cd0, 0x0, 0x0, 0x0,
 0x9157, 0x0, 0x0, 0x0, 0xe2f3, 0x0, 0x0, 0x0,
 0x939c, 0x0, 0xe2f2, 0x0, 0x0, 0x0, 0xe2f4, 0x0,
 0x95b3, 0x918c, 0x8d66, 0x0, 0xe2f5, 0x0, 0x0, 0x0,
 0x0, 0x97c6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe2f7, 0x0, 0x0, 0xe2f8, 0x0, 0xe2f9, 0x0,
 0xe2fa, 0x0, 0x8e85, 0x0, 0xe2fb, 0x8c6e, 0x0, 0x0,
 0x8b8a, 0x0, 0x8b49, 0x0, 0xe340, 0x0, 0x96f1, 0x8d67,
 0xe2fc, 0x0, 0x0, 0x0, 0xe343, 0x96e4, 0x0, 0x945b,
 0x0, 0x0, 0x9552, 0x0, 0x0, 0x0, 0x8f83, 0xe342,
 0x0, 0x8ed1, 0x8d68, 0x8e86, 0x8b89, 0x95b4, 0xe341, 0x0,
 0x0, 0x0, 0x9166, 0x9661, 0x8df5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e87, 0x92db, 0x0,
 0xe346, 0x97dd, 0x8dd7, 0x0, 0xe347, 0x9061, 0x0, 0xe349,
 0x0, 0x0, 0x0, 0x8fd0, 0x8dae, 0x0, 0x0, 0x0,
 0x0, 0xe348, 0x0, 0x0, 0x8f49, 0x8cbc, 0x9167, 0xe344,
 0xe34a, 0x0, 0x0, 0x0, 0x0, 0xe345, 0x8c6f, 0x0,
 0xe34d, 0xe351, 0x8c8b, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe34c, 0x0, 0x0, 0x0, 0x0, 0xe355, 0x0, 0x0,
 0x8d69, 0x0, 0x0, 0x978d, 0x88ba, 0xe352, 0x0, 0x0,
 0x8b8b, 0x0, 0xe34f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe350, 0x0, 0x0, 0x939d, 0xe34e, 0xe34b, 0x0, 0x8a47,
 0x90e2, 0x0, 0x0, 0x8ca6, 0x0, 0x0, 0x0, 0xe357,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe354, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe356, 0x0, 0x0, 0x0, 0xe353, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c70, 0x91b1, 0xe358, 0x918e, 0x0,
 0x0, 0xe365, 0x0, 0x0, 0xe361, 0xe35b, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe35f, 0x8ef8, 0x88db,
 0xe35a, 0xe362, 0xe366, 0x8d6a, 0x96d4, 0x0, 0x92d4, 0xe35c,
 0x0, 0x0, 0xe364, 0x0, 0xe359, 0x925d, 0x0, 0xe35e,
 0x88bb, 0x96c8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe35d, 0x0, 0x0, 0x8bd9, 0x94ea, 0x0, 0x0,
 0x0, 0x918d, 0x0, 0x97ce, 0x8f8f, 0x0, 0x0, 0xe38e,
 0x0, 0x0, 0xe367, 0x0, 0x90fc, 0x0, 0xe363, 0xe368,
 0xe36a, 0x0, 0x92f7, 0xe36d, 0x0, 0x0, 0xe369, 0x0,
 0x0, 0x0, 0x95d2, 0x8ac9, 0x0, 0x0, 0x96c9, 0x0,
 0x0, 0x88dc, 0x0, 0x0, 0xe36c, 0x0, 0x97fb, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe36b, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x898f, 0x0, 0x0, 0x93ea, 0xe36e,
 0x0, 0x0, 0x0, 0xe375, 0xe36f, 0xe376, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe372, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x949b, 0x0, 0x0,
 0x8ec8, 0xe374, 0x0, 0xe371, 0xe377, 0xe370, 0x0, 0x0,
 0x8f63, 0x0, 0x0, 0x0, 0x0, 0x9644, 0x0, 0x0,
 0x8f6b, 0x0, 0x0, 0xe373, 0xe380, 0x0, 0x0, 0xe37b,
 0x0, 0xe37e, 0x0, 0xe37c, 0xe381, 0xe37a, 0x0, 0xe360,
 0x90d1, 0x0, 0x0, 0x94c9, 0x0, 0xe37d, 0x0, 0x0,
 0xe378, 0x0, 0x0, 0x0, 0x9140, 0x8c71, 0x0, 0x8f4a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9044, 0x9155,
 0xe384, 0x0, 0x0, 0xe386, 0xe387, 0x0, 0x0, 0xe383,
 0xe385, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe379, 0xe382, 0x0, 0xe38a, 0xe389, 0x0, 0x0, 0x969a,
 0x0, 0x0, 0x8c4a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe388, 0x0, 0xe38c, 0xe38b, 0xe38f,
 0x0, 0xe391, 0x0, 0x0, 0x8e5b, 0xe38d, 0x0, 0x0,
 0x0, 0x0, 0xe392, 0xe393, 0x0, 0x0, 0xe394, 0x0,
 0xe39a, 0x935a, 0xe396, 0x0, 0xe395, 0xe397, 0xe398, 0x0,
 0xe399, 0x0, 0x0, 0x0, 0x0, 0xe39b, 0xe39c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8aca, 0x0, 0xe39d, 0x0, 0xe39e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe39f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3a0, 0xe3a1,
 0xe3a2, 0x0, 0xe3a3, 0xe3a4, 0x0, 0x0, 0xe3a6, 0xe3a5,
 0x0, 0x0, 0xe3a7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3a8, 0xe3a9, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3ac, 0xe3aa, 0xe3ab, 0x8ddf, 0x8c72, 0x0, 0x0,
 0x9275, 0x0, 0x94b1, 0x0, 0x8f90, 0x0, 0x0, 0x946c,
 0x0, 0x94eb, 0xe3ad, 0x9ceb, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3ae, 0xe3b0, 0x0, 0x9785,
 0xe3af, 0xe3b2, 0xe3b1, 0x0, 0x9772, 0x0, 0xe3b3, 0x0,
 0x94fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3b4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3b7, 0x0, 0x0, 0xe3b6,
 0xe3b5, 0x9285, 0x0, 0x0, 0x0, 0x0, 0xe3b8, 0x8c51,
 0x0, 0x0, 0x0, 0x9141, 0x8b60, 0x0, 0x0, 0x0,
 0x0, 0xe3bc, 0xe3b9, 0x0, 0x0, 0xe3ba, 0x0, 0x0,
 0x0, 0xe3bd, 0x0, 0xe3be, 0xe3bb, 0x0, 0x0, 0x0,
 0x8948, 0x0, 0x0, 0x0, 0x89a5, 0x0, 0x0, 0x0,
 0xe3c0, 0xe3c1, 0x0, 0x0, 0x0, 0xe3c2, 0x0, 0x9782,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f4b, 0x0, 0xe3c4,
 0xe3c3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9089, 0xe3c5, 0x0, 0x0, 0x0,
 0x0, 0xe3c6, 0x0, 0x0, 0xe3c7, 0x0, 0x8ae3, 0x0,
 0x0, 0x0, 0x0, 0x8acb, 0x0, 0x0, 0xe3c8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3c9, 0x0, 0x967c, 0x9783,
 0x0, 0x0, 0x0, 0x9773, 0x9856, 0x0, 0x8d6c, 0xe3cc,
 0x8ed2, 0xe3cb, 0x0, 0x0, 0x0, 0x0, 0xe3cd, 0x8ea7,
 0x0, 0x0, 0x0, 0x91cf, 0x0, 0xe3ce, 0x0, 0x0,
 0x8d6b, 0x0, 0x96d5, 0xe3cf, 0xe3d0, 0x0, 0x0, 0xe3d1,
 0x0, 0x0, 0x0, 0x0, 0xe3d2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe3d3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ea8, 0x0,
 0x0, 0x96eb, 0x0, 0x0, 0x0, 0x0, 0xe3d5, 0x0,
 0x925e, 0x0, 0xe3d4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3d7, 0x0, 0x0, 0x0, 0xe3d6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3d8, 0x0, 0x0,
 0x0, 0x90b9, 0x0, 0xe3d9, 0x0, 0xe3da, 0x0, 0x0,
 0x0, 0x95b7, 0xe3db, 0x0, 0x918f, 0xe3dc, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe3dd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97fc, 0xe3e0, 0x0, 0xe3df, 0xe3de, 0x92ae,
 0x0, 0xe3e1, 0x9045, 0x0, 0xe3e2, 0x0, 0x0, 0x0,
 0xe3e3, 0x9857, 0xe3e4, 0x0, 0x0, 0x0, 0x0, 0xe3e5,
 0xe3e7, 0xe3e6, 0x94a3, 0x0, 0x93f7, 0x0, 0x985d, 0x94a7,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3e9, 0x0,
 0x0, 0x8fd1, 0x0, 0x9549, 0x0, 0xe3ea, 0xe3e8, 0x0,
 0x8acc, 0x0, 0x0, 0x0, 0x8cd2, 0x8e88, 0x0, 0x0,
 0x94ec, 0x0, 0x0, 0x0, 0x8ca8, 0x9662, 0x0, 0xe3ed,
 0xe3eb, 0x0, 0x8d6d, 0x0, 0x8d6e, 0x88e7, 0x0, 0x8de6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9478, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88dd, 0xe3f2,
 0x0, 0x925f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9477,
 0x0, 0x91d9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe3f4, 0x0, 0x0, 0xe3f0, 0xe3f3, 0xe3ee, 0x0,
 0xe3f1, 0x9645, 0x0, 0x0, 0x8cd3, 0x0, 0x0, 0x88fb,
 0xe3ef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe3f6, 0x0, 0xe3f7, 0x0, 0x0, 0x93b7,
 0x0, 0x0, 0x0, 0x8bb9, 0x0, 0x0, 0x0, 0xe445,
 0x945c, 0x0, 0x0, 0x0, 0x0, 0x8e89, 0x0, 0x0,
 0x8bba, 0x90c6, 0x9865, 0x96ac, 0xe3f5, 0x90d2, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b72, 0xe3f8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3fa, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe3f9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe3fb, 0x0, 0x9245, 0x0, 0x945d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x92af, 0x0, 0x0, 0x0,
 0x0, 0xe442, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe441, 0x0, 0x0, 0x0, 0x0, 0xe3fc, 0x0,
 0x0, 0x9074, 0x0, 0x9585, 0xe444, 0x0, 0xe443, 0x8d6f,
 0x9872, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe454, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe448, 0xe449, 0x0, 0x0, 0x0, 0x0, 0x8eee, 0x0,
 0x0, 0xe447, 0x0, 0x8d98, 0xe446, 0x0, 0x0, 0xe44a,
 0x0, 0x0, 0x0, 0x92b0, 0x95a0, 0x0, 0x9142, 0x0,
 0x0, 0x0, 0x0, 0x91da, 0xe44e, 0x0, 0xe44f, 0xe44b,
 0x0, 0x0, 0x0, 0x0, 0xe44c, 0x0, 0xe44d, 0x0,
 0x0, 0x0, 0x0, 0x8d70, 0x0, 0x0, 0x0, 0xe455,
 0x0, 0xe451, 0x0, 0x0, 0x0, 0x0, 0x9586, 0x0,
 0x968c, 0x9547, 0x0, 0x0, 0xe450, 0x0, 0x0, 0xe453,
 0xe458, 0x0, 0x0, 0x0, 0x9663, 0xe456, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe457, 0x0, 0x0, 0x9156,
 0x0, 0x0, 0x0, 0xe45a, 0x0, 0xe45e, 0x0, 0x0,
 0xe45b, 0xe459, 0x945e, 0xe45c, 0x0, 0xe45d, 0x0, 0x0,
 0x0, 0x89b0, 0x0, 0xe464, 0xe45f, 0x0, 0x0, 0x0,
 0xe460, 0x0, 0x0, 0x0, 0xe461, 0x0, 0x919f, 0x0,
 0x0, 0x0, 0x0, 0xe463, 0xe462, 0xe465, 0x0, 0x0,
 0x0, 0x0, 0xe466, 0xe467, 0x0, 0x0, 0x9062, 0x0,
 0x89e7, 0x0, 0xe468, 0x97d5, 0x0, 0x8ea9, 0x0, 0x0,
 0x8f4c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e8a, 0x9276,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe469, 0xe46a, 0x8950,
 0x0, 0xe46b, 0x0, 0x0, 0xe46c, 0xe46d, 0x0, 0x0,
 0xe46e, 0x0, 0xe46f, 0x8bbb, 0x9da8, 0xe470, 0x0, 0x90e3,
 0xe471, 0x8ec9, 0x0, 0xe472, 0x0, 0x98ae, 0x0, 0x0,
 0x0, 0xe473, 0x95dc, 0x8ada, 0x0, 0x0, 0x9143, 0x8f77,
 0x0, 0x9591, 0x8f4d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe474, 0x8d71, 0xe475, 0x94ca,
 0x0, 0xe484, 0x0, 0x0, 0x0, 0x0, 0xe477, 0x0,
 0x91c7, 0x9495, 0x8cbd, 0xe476, 0x9144, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe478, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x92f8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe47a, 0xe479, 0xe47c, 0x0, 0x0,
 0xe47b, 0x0, 0xe47d, 0x0, 0x0, 0xe480, 0x0, 0xe47e,
 0x0, 0x8acd, 0x0, 0xe481, 0x0, 0xe482, 0xe483, 0x0,
 0x0, 0x8daf, 0x97c7, 0x0, 0xe485, 0x9046, 0x0, 0x0,
 0x0, 0x8990, 0xe486, 0xe487, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe488, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88f0, 0x0,
 0xe489, 0x0, 0x0, 0x0, 0x0, 0xe48a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9587, 0x0, 0x0, 0x0,
 0x8ec5, 0x0, 0xe48c, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8a48, 0x88b0, 0x0, 0x0, 0x0, 0x0, 0xe48b, 0xe48e,
 0x946d, 0x0, 0x9063, 0x0, 0x89d4, 0x0, 0x9646, 0x0,
 0x0, 0x0, 0x0, 0x8c7c, 0x8bda, 0x0, 0xe48d, 0x0,
 0x89e8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8aa1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8991, 0xe492, 0x97e8, 0x91db,
 0x0, 0x0, 0x9563, 0x0, 0xe49e, 0x0, 0x89d5, 0xe49c,
 0x0, 0xe49a, 0xe491, 0x0, 0xe48f, 0x0, 0xe490, 0x0,
 0x8ee1, 0x8bea, 0x9297, 0x0, 0x0, 0x0, 0x93cf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8970, 0x0, 0xe494, 0xe493,
 0x0, 0x0, 0x0, 0x0, 0xe499, 0xe495, 0xe498, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x96ce, 0xe497, 0x89d6,
 0x8a9d, 0xe49b, 0x0, 0x0, 0xe49d, 0x0, 0x0, 0x0,
 0x0, 0x8c73, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe4a1, 0xe4aa, 0xe4ab, 0x0, 0x0, 0x0, 0x88a9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4b2, 0x0,
 0x0, 0x0, 0x0, 0x88ef, 0x0, 0x0, 0xe4a9, 0x0,
 0x0, 0x0, 0xe4a8, 0x0, 0xe4a3, 0xe4a2, 0x0, 0xe4a0,
 0xe49f, 0x9283, 0x0, 0x91f9, 0xe4a5, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe4a4, 0x0, 0x0, 0x0, 0x0,
 0xe4a7, 0x0, 0x0, 0x0, 0x9190, 0x8c74, 0x0, 0x0,
 0x0, 0x0, 0x8960, 0xe4a6, 0x0, 0x8d72, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9191, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4b8, 0x0,
 0xe4b9, 0x0, 0x89d7, 0x0, 0x0, 0x0, 0x89ac, 0xe4b6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe4ac, 0x0, 0xe4b4, 0x0, 0xe4bb, 0xe4b5, 0x0, 0x0,
 0x0, 0xe4b3, 0x0, 0x0, 0x0, 0x0, 0xe496, 0x0,
 0x0, 0xe4b1, 0x0, 0x0, 0x0, 0xe4ad, 0x0, 0x0,
 0x0, 0x8ace, 0xe4af, 0xe4ba, 0x0, 0xe4b0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe4bc, 0x0, 0xe4ae, 0x949c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9789, 0x0, 0x0, 0x0,
 0xe4b7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe4cd, 0x0, 0x0, 0x0, 0xe4c5, 0x0, 0x0, 0x0,
 0x909b, 0x0, 0x0, 0x0, 0x0, 0x8b65, 0x0, 0x8bdb,
 0x0, 0xe4c0, 0x0, 0x0, 0x0, 0x0, 0x89d9, 0x0,
 0x0, 0x8fd2, 0x0, 0xe4c3, 0x0, 0x0, 0x0, 0x8dd8,
 0x0, 0x0, 0x9370, 0xe4c8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95ec, 0x0, 0xe4bf, 0x0,
 0x0, 0x0, 0x89d8, 0x8cd4, 0x9548, 0xe4c9, 0x0, 0xe4bd,
 0x0, 0x0, 0xe4c6, 0x0, 0x0, 0x0, 0xe4d0, 0x0,
 0xe4c1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4c2, 0x93b8,
 0x0, 0x0, 0xe4c7, 0x0, 0x0, 0x0, 0xe4c4, 0x9647,
 0xe4ca, 0x88de, 0x0, 0x0, 0x0, 0x0, 0xe4be, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe4cc, 0x0, 0xe4cb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x948b, 0xe4d2, 0x0, 0xe4dd,
 0x0, 0x0, 0x0, 0x0, 0x8a9e, 0x0, 0x0, 0x0,
 0xe4e0, 0x0, 0x0, 0xe4ce, 0x0, 0x0, 0x0, 0xe4d3,
 0x978e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe4dc, 0x0, 0x0, 0x9774, 0x0, 0x0, 0x0,
 0x0, 0x97a8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9298, 0x0, 0x0, 0x0, 0x8a8b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9592, 0xe4e2, 0x939f, 0x0,
 0x0, 0x88af, 0x0, 0x0, 0xe4db, 0x0, 0xe4d7, 0x9192,
 0xe4d1, 0xe4d9, 0xe4de, 0x0, 0x944b, 0x0, 0x0, 0x0,
 0x88a8, 0x0, 0xe4d6, 0x0, 0xe4df, 0x9598, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4da, 0x0, 0xe4d5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8fd3, 0x0,
 0x0, 0x0, 0x0, 0x8f4e, 0x0, 0x0, 0x0, 0x8eaa,
 0x0, 0x0, 0x0, 0x0, 0x96d6, 0x0, 0x0, 0x9566,
 0x0, 0x0, 0xe4e5, 0x0, 0xe4ee, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe4d8, 0x0, 0x0, 0x0, 0x0, 0x8a97, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8ff6, 0xe4e3, 0x0, 0xe4e8, 0x9193,
 0x0, 0x0, 0xe4e4, 0x0, 0xe4eb, 0x0, 0x0, 0x927e,
 0x0, 0xe4ec, 0x0, 0x0, 0x9775, 0xe4e1, 0x8a57, 0x0,
 0xe4e7, 0x0, 0x0, 0xe4ea, 0x96aa, 0x0, 0x0, 0x0,
 0x0, 0xe4ed, 0x0, 0x0, 0xe4e6, 0xe4e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9648,
 0x0, 0x9840, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4f1,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4f8,
 0x0, 0x0, 0xe4f0, 0x8ec1, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe4cf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95cc, 0x0, 0x96a0, 0xe4f7,
 0xe4f6, 0x0, 0xe4f2, 0xe4f3, 0x0, 0x8955, 0x0, 0x0,
 0x0, 0x0, 0xe4f5, 0x0, 0xe4ef, 0x0, 0x0, 0x0,
 0x0, 0x92d3, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4f4,
 0x88fc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x91a0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x95c1, 0x0, 0x0, 0xe4f9, 0xe540, 0x0, 0x94d7, 0x0,
 0x0, 0x0, 0x0, 0xe4fc, 0x8fd4, 0x8ec7, 0xe542, 0x0,
 0x0, 0x8bbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe543, 0x0, 0x9599, 0xe4fb, 0x0, 0xe4d4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe4fa, 0x0,
 0x0, 0x0, 0x0, 0x986e, 0x93a0, 0x9593, 0x0, 0x0,
 0xe54a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe550, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe551, 0x0, 0xe544, 0x0, 0x0, 0x0, 0x9496,
 0x0, 0x0, 0xe54e, 0xe546, 0x0, 0xe548, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe552, 0xe547, 0x0, 0x0, 0xe54b,
 0x0, 0x0, 0x8992, 0x0, 0x93e3, 0x0, 0xe54c, 0xe54f,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe545,
 0x0, 0x9145, 0x0, 0xe549, 0x8e46, 0x9064, 0x8c4f, 0x96f2,
 0x0, 0x96f7, 0x8f92, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe556, 0xe554, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x986d, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe553, 0x0, 0x0, 0x0,
 0x9795, 0x0, 0xe555, 0xe557, 0x0, 0x0, 0x0, 0x0,
 0xe558, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe55b,
 0xe559, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93a1,
 0xe55a, 0x0, 0x0, 0x0, 0x94cb, 0xe54d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8f93, 0x0, 0xe55c, 0xe561, 0x9194, 0x0,
 0x0, 0xe560, 0x0, 0x0, 0x0, 0xe541, 0x0, 0x0,
 0x0, 0xe562, 0x9168, 0x0, 0x0, 0xe55d, 0xe55f, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe55e, 0x0,
 0x0, 0x9f50, 0x9f41, 0x0, 0x0, 0xe564, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe563, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x9796, 0x0, 0xe1ba, 0xe565, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe566, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe567, 0x8cd5, 0x0, 0x8b73, 0x0, 0x0, 0x0, 0xe569,
 0x997c, 0x0, 0x0, 0x0, 0x0, 0x8b95, 0x0, 0x97b8,
 0x0, 0x8bf1, 0xe56a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe56b, 0x0, 0x0, 0x0, 0x928e, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe56c, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x93f8, 0x0, 0x88b8, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x89e1, 0xe571, 0xe572,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe56d, 0x0,
 0x8e5c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe56e, 0x9461,
 0x0, 0x0, 0x0, 0x0, 0xe56f, 0xe570, 0xe57a, 0x0,
 0x0, 0x0, 0xe574, 0xe577, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe573, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe575,
 0x0, 0xe576, 0x8ed6, 0x0, 0xe578, 0x0, 0x9260, 0x0,
 0x8c75, 0x8a61, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe57b,
 0x0, 0x0, 0x0, 0x0, 0x8a5e, 0x0, 0xe581, 0x0,
 0x0, 0xe57c, 0xe580, 0x0, 0x0, 0x0, 0x0, 0x94b8,
 0x0, 0x0, 0x0, 0x0, 0xe57d, 0x0, 0x0, 0xe57e,
 0x9567, 0x94d8, 0xe582, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x91fb, 0xe58c, 0x0, 0xe588, 0x0,
 0x0, 0x89e9, 0x0, 0xe586, 0x0, 0x9649, 0xe587, 0x0,
 0x0, 0xe584, 0x0, 0xe585, 0xe58a, 0xe58d, 0x0, 0x0,
 0xe58b, 0x0, 0x0, 0x0, 0xe589, 0xe583, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9277, 0x0, 0xe594, 0x0, 0x96a8,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe592, 0x0, 0x0, 0x0, 0xe593, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe58e,
 0x0, 0x0, 0xe590, 0x0, 0x0, 0x0, 0xe591, 0x0,
 0x0, 0x0, 0xe58f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x90e4, 0x0, 0x9858, 0xe598,
 0x0, 0xe599, 0x0, 0x0, 0x0, 0x0, 0xe59f, 0x0,
 0x9049, 0x0, 0xe59b, 0x0, 0xe59e, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe596, 0xe595, 0x0, 0x0, 0xe5a0, 0x0,
 0x0, 0x89da, 0x0, 0xe59c, 0x0, 0xe5a1, 0x0, 0x0,
 0x0, 0xe59d, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe59a,
 0x0, 0x92b1, 0x0, 0xe597, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x9488, 0x0, 0x0, 0xe5a5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x975a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe5a4, 0x0, 0x0, 0xe5a3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5ac, 0x0,
 0x0, 0x0, 0xe5a6, 0x0, 0x0, 0x0, 0xe5ae, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9786, 0xe5b1, 0x0,
 0xe5a8, 0x0, 0x0, 0xe5a9, 0x0, 0x0, 0x0, 0xe5ad,
 0x0, 0xe5b0, 0xe5af, 0x0, 0x0, 0x0, 0xe5a7, 0x0,
 0x0, 0x0, 0x0, 0xe5aa, 0x0, 0xe5bb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe5b4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe5b2, 0x0, 0x0, 0xe5b3, 0x0, 0x0,
 0x0, 0xe5b8, 0xe5b9, 0x0, 0x8a49, 0x0, 0x8b61, 0x0,
 0x0, 0xe5b7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5a2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5b6, 0xe5ba, 0xe5b5, 0x0, 0xe5bc, 0x0, 0x0, 0x0,
 0xe5be, 0xe5bd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe5c0, 0xe5bf, 0xe579, 0x0,
 0x0, 0x0, 0xe5c4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe5c1, 0x0, 0x0, 0x0,
 0x0, 0xe5c2, 0x0, 0x0, 0xe5c3, 0x0, 0xe5c5, 0x0,
 0x0, 0x0, 0x0, 0x8c8c, 0x0, 0xe5c7, 0x0, 0xe5c6,
 0x0, 0x8f4f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8d73,
 0x9fa5, 0x0, 0x0, 0x0, 0x0, 0xe5c8, 0x8f70, 0x0,
 0x0, 0x0, 0x8a58, 0x0, 0xe5c9, 0x0, 0x8971, 0x0,
 0x8fd5, 0xe5ca, 0x0, 0x0, 0x8d74, 0xe5cb, 0x88df, 0x0,
 0x0, 0x0, 0x0, 0x955c, 0x0, 0x0, 0xe5cc, 0x0,
 0x0, 0x0, 0x0, 0x908a, 0x0, 0xe5d3, 0x0, 0x0,
 0xe5d0, 0x0, 0x928f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5d1, 0xe5ce, 0x8bdc, 0x0, 0xe5cd, 0xe5d4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8c55, 0x0, 0x0, 0x91dc, 0x0,
 0xe5da, 0x0, 0x0, 0x0, 0x0, 0xe5d6, 0x0, 0x0,
 0x0, 0x91b3, 0xe5d5, 0x0, 0xe5d8, 0x0, 0x0, 0x0,
 0x0, 0xe5cf, 0x0, 0x0, 0x0, 0xe5d9, 0x0, 0xe5db,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x94ed, 0x0,
 0x0, 0xe5d7, 0x0, 0xe5dc, 0xe5de, 0x0, 0x0, 0x8cd1,
 0xe5d2, 0x0, 0x88bf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe5dd, 0x0, 0x8dd9, 0x97f4, 0xe5df, 0xe5e0,
 0x9195, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x97a0, 0x0, 0x0, 0x0, 0x0, 0xe5e1,
 0x9754, 0x0, 0x0, 0xe5e2, 0xe5e3, 0x0, 0x0, 0x95e2,
 0xe5e4, 0x0, 0x8dbe, 0x0, 0x97a1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe5e9, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5ea, 0x8fd6, 0xe5e8,
 0x0, 0x0, 0x0, 0x9787, 0xe5e5, 0x0, 0x0, 0xe5e7,
 0x90bb, 0x909e, 0x0, 0x0, 0x0, 0xe5e6, 0x0, 0xe5eb,
 0x0, 0x0, 0x95a1, 0x0, 0x0, 0xe5ed, 0x0, 0xe5ec,
 0x0, 0x0, 0x0, 0x8a8c, 0x0, 0x964a, 0xe5ee, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5fa, 0xe5f0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe5f1, 0x0, 0x0, 0x0, 0x0, 0xe5f2, 0xe5f3, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe5f7, 0x0, 0xe5f8, 0x0, 0x0, 0xe5f6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe5f4, 0x0, 0xe5ef, 0xe5f5,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe5f9,
 0xe8b5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x89a6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe5fc, 0x8bdd, 0xe5fb, 0x0, 0x0, 0x0, 0xe641,
 0x0, 0xe640, 0x0, 0x0, 0x0, 0xe643, 0x0, 0x0,
 0xe642, 0x0, 0xe644, 0x0, 0x0, 0x8f50, 0x0, 0xe645,
 0x0, 0x0, 0xe646, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe647, 0x90bc, 0x0, 0x9776, 0x0, 0xe648, 0x0,
 0x0, 0x95a2, 0x9465, 0xe649, 0x0, 0xe64a, 0x8ca9, 0x0,
 0x0, 0x0, 0x8b4b, 0x0, 0x0, 0x0, 0xe64b, 0x0,
 0x0, 0x8e8b, 0x9460, 0xe64c, 0x0, 0x8a6f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe64d, 0x0, 0x0, 0x0,
 0x0, 0xe64f, 0x9797, 0x0, 0xe64e, 0x9065, 0x0, 0xe650,
 0x0, 0x0, 0xe651, 0x0, 0x0, 0xe652, 0x8acf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe653, 0x0, 0x0,
 0xe654, 0x0, 0xe655, 0xe656, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8a70, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe657, 0x0, 0xe658, 0xe659,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x89f0, 0x0, 0x0,
 0x9047, 0xe65a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe65b, 0xea42,
 0x0, 0x0, 0x0, 0xe65c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8cbe, 0x0, 0x92f9, 0xe65d, 0x0,
 0x0, 0x0, 0x0, 0x8c76, 0x0, 0x9075, 0x0, 0xe660,
 0x0, 0x93a2, 0x0, 0xe65f, 0x0, 0x0, 0x8c50, 0x0,
 0x0, 0xe65e, 0x91f5, 0x8b4c, 0x0, 0x0, 0xe661, 0x0,
 0xe662, 0x0, 0x8fd7, 0x0, 0x0, 0x0, 0x8c8d, 0x0,
 0xe663, 0x0, 0x0, 0x0, 0x0, 0x964b, 0x0, 0x0,
 0x90dd, 0x0, 0x0, 0x0, 0x8b96, 0x0, 0x96f3, 0x9169,
 0x0, 0xe664, 0x0, 0x0, 0x0, 0x9066, 0x9290, 0x8fd8,
 0x0, 0x0, 0x0, 0x0, 0xe665, 0x0, 0x0, 0x0,
 0x0, 0xe668, 0x0, 0xe669, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8dbc, 0x91c0, 0xe667, 0x0, 0x8fd9,
 0x955d, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe666, 0x0,
 0x0, 0x8e8c, 0x0, 0x8972, 0x0, 0xe66d, 0x8c77, 0x0,
 0x0, 0x8e8e, 0x0, 0x0, 0x8e8d, 0x0, 0x986c, 0xe66c,
 0xe66b, 0x9146, 0x0, 0x8b6c, 0x9862, 0x8a59, 0x8fda, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe66a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe66f, 0x0, 0xe670,
 0xe66e, 0x0, 0x8cd6, 0x0, 0x975f, 0x0, 0x0, 0x8e8f,
 0x9446, 0x0, 0x0, 0x0, 0xe673, 0x0, 0x90be, 0x0,
 0x9261, 0x0, 0x0, 0x9755, 0x0, 0xe676, 0x0, 0x0,
 0x0, 0x8cea, 0x0, 0x90bd, 0xe672, 0x0, 0xe677, 0x8ceb,
 0xe674, 0xe675, 0x0, 0xe671, 0x0, 0x0, 0x0, 0x90e0,
 0x93c7, 0x0, 0x0, 0x924e, 0x0, 0x89db, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x94ee, 0x0, 0x0, 0x8b62,
 0x0, 0x0, 0x92b2, 0x0, 0x0, 0xe67a, 0x0, 0xe678,
 0x0, 0x0, 0x926b, 0x0, 0x0, 0x0, 0x90bf, 0x8ad0,
 0xe679, 0x0, 0x907a, 0x0, 0x0, 0x97c8, 0x0, 0x0,
 0x0, 0x985f, 0x0, 0x0, 0x0, 0xe67b, 0xe687, 0x92b3,
 0x0, 0xe686, 0x0, 0xe683, 0xe68b, 0xe684, 0x0, 0xe680,
 0x0, 0x92fa, 0xe67e, 0x0, 0x0, 0x0, 0xe67c, 0x0,
 0x9740, 0x8e90, 0x0, 0x0, 0xe681, 0x0, 0xe67d, 0x0,
 0x0, 0x0, 0xe685, 0x8f94, 0x0, 0x8cbf, 0x0, 0x0,
 0x0, 0x91f8, 0x0, 0x9664, 0x8979, 0x88e0, 0x0, 0x93a3,
 0x0, 0x0, 0xe689, 0x0, 0x0, 0x0, 0x0, 0xe688,
 0x0, 0x93e4, 0x0, 0xe68d, 0x0, 0x0, 0x0, 0xe682,
 0x0, 0xe68c, 0xe68e, 0x0, 0x8caa, 0xe68a, 0x8d75, 0x0,
 0x8ed3, 0x0, 0x0, 0xe68f, 0x9777, 0x0, 0x0, 0x0,
 0x0, 0xe692, 0x0, 0xe695, 0x0, 0x0, 0xe693, 0x9554,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe690, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8bde, 0x0, 0x0, 0x0,
 0x0, 0xe694, 0x0, 0x0, 0xe696, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe69a, 0x0, 0x0, 0xe697,
 0x0, 0xe699, 0xe698, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe69b, 0x0, 0x8eaf, 0x0, 0xe69d, 0xe69c, 0x9588,
 0x0, 0x0, 0xe69f, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8c78, 0x0, 0x0, 0x0, 0x0, 0xe69e, 0xe6a0,
 0x0, 0x0, 0xe6a1, 0x8b63, 0xe3bf, 0x8ff7, 0x0, 0xe6a2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6a3,
 0x0, 0x0, 0xe6a4, 0x0, 0x0, 0x8e5d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9dcc, 0x0, 0xe6a5, 0x0,
 0xe6a6, 0x0, 0x8f51, 0x0, 0xe6a7, 0xe6a8, 0x0, 0x0,
 0xe6a9, 0x0, 0x0, 0xe6aa, 0xe6ab, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x924a, 0x0, 0x0, 0xe6ac, 0x0, 0x0, 0x0,
 0x0, 0xe6ae, 0x0, 0xe6ad, 0x0, 0x0, 0x0, 0x0,
 0x93a4, 0x0, 0xe6af, 0x0, 0x964c, 0x0, 0xe6b0, 0x0,
 0xe6b1, 0x0, 0xe6b2, 0x0, 0x0, 0x0, 0x0, 0xe6b3,
 0x0, 0x0, 0x0, 0x0, 0x93d8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8fdb, 0xe6b4, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8d8b, 0x98ac, 0xe6b5, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe6b6, 0x955e, 0xe6b7, 0x0, 0xe6bf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6b8, 0x0, 0x0, 0xe6ba,
 0x0, 0x0, 0x0, 0xe6b9, 0xe6bb, 0x0, 0x9665, 0xe6bc,
 0xe6bd, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6be, 0x0,
 0x0, 0x0, 0xe6c0, 0x0, 0x0, 0x0, 0x0, 0x8a4c,
 0x92e5, 0x0, 0x9589, 0x8de0, 0x8d76, 0x0, 0x0, 0x0,
 0x0, 0x956e, 0x89dd, 0x94cc, 0xe6c3, 0x8ad1, 0x90d3, 0xe6c2,
 0xe6c7, 0x9299, 0x96e1, 0x0, 0xe6c5, 0xe6c6, 0x8b4d, 0x0,
 0xe6c8, 0x9483, 0x91dd, 0x0, 0x0, 0x94ef, 0x935c, 0xe6c4,
 0x0, 0x9666, 0x89ea, 0xe6ca, 0x9847, 0x92c0, 0x9864, 0x0,
 0x0, 0x8e91, 0xe6c9, 0x0, 0x91af, 0x0, 0x0, 0xe6da,
 0x9147, 0x0, 0x0, 0x93f6, 0x0, 0x956f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6cd, 0x8e5e, 0x8e92, 0x0,
 0x8fdc, 0x0, 0x9485, 0x0, 0x8cab, 0xe6cc, 0xe6cb, 0x0,
 0x958a, 0x0, 0x0, 0x0, 0x8ebf, 0x0, 0x0, 0x9371,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6cf, 0xe6d0, 0x8d77, 0xe6ce,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6d1, 0xe6d2, 0x0,
 0xe6d4, 0x91a1, 0x0, 0xe6d3, 0x8ae4, 0x0, 0xe6d6, 0x0,
 0xe6d5, 0xe6d7, 0x0, 0x0, 0xe6d9, 0xe6db, 0x0, 0xe6dc,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x90d4, 0x0, 0x8ecd,
 0xe6dd, 0x0, 0x0, 0x0, 0x8a71, 0x0, 0xe6de, 0x0,
 0x0, 0x9196, 0xe6df, 0x0, 0xe6e0, 0x958b, 0x0, 0x0,
 0x8b4e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe6e1, 0x0, 0x0, 0x0, 0x92b4, 0x0,
 0x0, 0x0, 0x0, 0x897a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe6e2, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8eef, 0x0, 0x0, 0x0,
 0x0, 0x9096, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x91ab, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe6e5, 0x0, 0x0, 0x0, 0xe6e4,
 0x0, 0x0, 0x0, 0xe6e3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe6eb, 0xe6e9, 0x0, 0x0,
 0xe6e6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6e8,
 0x0, 0x0, 0x0, 0xe6e7, 0xe6ea, 0x0, 0x8b97, 0x0,
 0xe6ee, 0x0, 0x90d5, 0x0, 0xe6ef, 0x0, 0x0, 0x0,
 0x0, 0x8cd7, 0x0, 0xe6ec, 0xe6ed, 0x0, 0x0, 0x0,
 0x9848, 0x0, 0x0, 0x0, 0x92b5, 0x0, 0x9148, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6f0, 0x0, 0x0,
 0xe6f3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe6f1, 0xe6f2, 0x9778, 0x0, 0x0, 0x0, 0x0,
 0x93a5, 0xe6f6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe6f4, 0xe6f5,
 0xe6f7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe748, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe6fa, 0x0, 0x0, 0x0, 0xe6fb, 0xe6f9, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe6f8, 0x0, 0x92fb, 0x0, 0x0,
 0xe740, 0xe744, 0xe741, 0xe6fc, 0x0, 0xe742, 0x0, 0x0,
 0x0, 0xe743, 0x0, 0x0, 0x0, 0x0, 0xe74a, 0x0,
 0x0, 0x0, 0xe745, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x90d6, 0xe747, 0x0, 0x0, 0xe749, 0xe746, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe74c, 0x0, 0x8f52, 0x0, 0xe74b,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe74d, 0x0, 0x0,
 0x0, 0x0, 0xe74e, 0x0, 0x0, 0xe751, 0xe750, 0x0,
 0xe74f, 0x0, 0x0, 0xe753, 0xe752, 0x0, 0x96f4, 0x0,
 0x0, 0x0, 0xe755, 0x0, 0xe754, 0xe756, 0x0, 0x0,
 0x0, 0x0, 0xe757, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe759, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe758, 0x9067, 0xe75a, 0x0, 0x0,
 0x8beb, 0xe75b, 0xe75d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe75e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe75f, 0xe75c,
 0x0, 0xe760, 0x0, 0x8ed4, 0xe761, 0x8b4f, 0x8c52, 0x0,
 0x0, 0x0, 0x0, 0x8cac, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe762, 0x0, 0x0, 0x0,
 0x93ee, 0x0, 0x0, 0x935d, 0xe763, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe766, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8eb2, 0x0, 0x0, 0xe765, 0xe764, 0x8c79, 0xe767,
 0x0, 0x0, 0x0, 0x0, 0x8a72, 0x0, 0xe769, 0x0,
 0x0, 0x0, 0x8dda, 0xe768, 0x0, 0xe771, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe76b, 0xe76d, 0x95e3, 0xe76a, 0x0,
 0x0, 0x0, 0xe76c, 0x0, 0xe770, 0xe76e, 0x8b50, 0x0,
 0xe76f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe772,
 0x0, 0x0, 0x9479, 0x97d6, 0x0, 0x0, 0x0, 0x0,
 0x8f53, 0x0, 0x0, 0x0, 0xe773, 0x0, 0x0, 0x0,
 0x0, 0x9741, 0xe775, 0x0, 0xe774, 0x0, 0x0, 0xe778,
 0x9760, 0x0, 0x0, 0xe777, 0x0, 0x8a8d, 0xe776, 0xe77b,
 0x0, 0x0, 0xe77a, 0x0, 0x0, 0xe779, 0x9351, 0xe77c,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe77d, 0x0, 0x0, 0x0, 0x0, 0xe77e, 0x0, 0x0,
 0x8d8c, 0x0, 0x8c44, 0xe780, 0xe781, 0xe782, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9068, 0xe783, 0x0, 0x8eab,
 0xe784, 0x0, 0x0, 0x0, 0xe785, 0x0, 0x0, 0x0,
 0x999f, 0x999e, 0x0, 0x0, 0x0, 0x0, 0xe786, 0xe390,
 0xe787, 0x9243, 0x904a, 0x945f, 0x0, 0x0, 0x0, 0x0,
 0xe788, 0x0, 0x0, 0x95d3, 0x92d2, 0x8d9e, 0x0, 0x0,
 0x9248, 0x0, 0x0, 0x8949, 0x0, 0x9698, 0x9076, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c7d,
 0x0, 0x0, 0x8bdf, 0x0, 0x0, 0x95d4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe789, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe78b, 0x0, 0x0, 0xe78a, 0x89de,
 0x0, 0x0, 0x93f4, 0xe78c, 0x9497, 0x0, 0x9352, 0x0,
 0xe78d, 0x8f71, 0x0, 0x0, 0x0, 0xe78f, 0x0, 0x0,
 0x96c0, 0xe79e, 0xe791, 0xe792, 0x0, 0x0, 0x92c7, 0x0,
 0x0, 0x91de, 0x9197, 0x0, 0x93a6, 0x0, 0xe790, 0x8b74,
 0x0, 0x0, 0x0, 0x0, 0xe799, 0x0, 0xe796, 0xe7a3,
 0x93a7, 0x9280, 0xe793, 0x0, 0x92fc, 0x9372, 0xe794, 0xe798,
 0x9080, 0x0, 0x9487, 0x92ca, 0x0, 0x0, 0x90c0, 0xe797,
 0x91ac, 0x91a2, 0xe795, 0x88a7, 0x9841, 0x0, 0x0, 0x0,
 0xe79a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x91df,
 0x0, 0x0, 0x8f54, 0x9069, 0x0, 0x0, 0xe79c, 0xe79b,
 0x0, 0x88ed, 0xe79d, 0x0, 0x0, 0x954e, 0x0, 0xe7a5,
 0x0, 0x0, 0x93d9, 0x908b, 0x0, 0x0, 0x9278, 0x0,
 0x8bf6, 0x0, 0xe7a4, 0x9756, 0x895e, 0x0, 0x95d5, 0x89df,
 0xe79f, 0xe7a0, 0xe7a1, 0xe7a2, 0x93b9, 0x9242, 0x88e1, 0xe7a6,
 0x0, 0xe7a7, 0xeaa1, 0x0, 0x0, 0x91bb, 0x0, 0xe7a8,
 0x0, 0x8993, 0x916b, 0x0, 0x8cad, 0x0, 0x9779, 0x0,
 0x0, 0xe7a9, 0x934b, 0x0, 0x0, 0x0, 0x9198, 0x8ed5,
 0xe7aa, 0x0, 0x0, 0xe7ad, 0x0, 0x0, 0x8f85, 0xe7ab,
 0x914a, 0x9149, 0x0, 0x88e2, 0x0, 0x97c9, 0xe7af, 0x0,
 0x94f0, 0xe7b1, 0xe7b0, 0xe7ae, 0xe284, 0x8ad2, 0x0, 0x0,
 0xe78e, 0x0, 0xe7b3, 0xe7b2, 0x0, 0x0, 0x0, 0x0,
 0xe7b4, 0x0, 0x9757, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x93df, 0x0, 0x0, 0x964d,
 0x0, 0xe7b5, 0x0, 0x8ed7, 0x0, 0x0, 0x0, 0x0,
 0xe7b6, 0x0, 0xe7b7, 0x0, 0x0, 0x0, 0xe7b8, 0x0,
 0x0, 0x9340, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x88e8, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x8d78, 0x0, 0x0, 0x0, 0x9859,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe7bc, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8c53, 0xe7b9, 0x0, 0xe7ba, 0x0, 0x0,
 0x0, 0x9594, 0x0, 0x0, 0x0, 0x0, 0x8a73, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9758, 0x0,
 0x8bbd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9373, 0x0,
 0x0, 0x0, 0x0, 0xe7bd, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7be, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe7bf, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9341, 0x0,
 0x0, 0xe7c1, 0x0, 0xe7c0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x93d1, 0xe7c2, 0x8f55, 0x8ede, 0x947a, 0x9291,
 0x0, 0x0, 0x0, 0x8ef0, 0x0, 0x908c, 0x0, 0xe7c3,
 0x0, 0xe7c4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x907c, 0xe7c5, 0x0, 0xe7c6, 0x0,
 0x0, 0x0, 0xe7c7, 0x978f, 0x0, 0x8f56, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7c9, 0xe7c8, 0x0, 0x8d79, 0x0,
 0x8d93, 0x8e5f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7cc, 0x0, 0x0, 0x0, 0x0,
 0x8f86, 0x0, 0xe7cb, 0x0, 0xe7ca, 0x0, 0x91e7, 0x0,
 0x0, 0x8ced, 0x0, 0x90c1, 0x0, 0x0, 0x0, 0x0,
 0x94ae, 0x0, 0x0, 0x0, 0x0, 0x8f58, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7cd, 0x0, 0x8fdd, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe7d0, 0xe7ce, 0x0, 0x0, 0x0,
 0xe7cf, 0x0, 0x0, 0x0, 0x0, 0xe7d2, 0xe7d1, 0x0,
 0x0, 0x8ff8, 0x0, 0xe7d3, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe7d4, 0xe7d5, 0x0, 0x0, 0x0, 0x0, 0x94ce,
 0x8dd1, 0x8edf, 0xe7d6, 0x0, 0xe7d7, 0x97a2, 0x8f64, 0x96ec,
 0x97ca, 0xe7d8, 0x8be0, 0x0, 0x0, 0x0, 0x0, 0xe7d9,
 0x0, 0x9342, 0x0, 0x0, 0xe7dc, 0x8a98, 0x906a, 0x0,
 0xe7da, 0x0, 0xe7db, 0x0, 0x92de, 0x0, 0x0, 0x9674,
 0x8bfa, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7de, 0xe7df,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7dd, 0x0, 0x0,
 0xe7e1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x93dd, 0x8a62,
 0x0, 0x0, 0xe7e5, 0x0, 0x0, 0xe7e2, 0xe7e4, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7e0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe86e, 0x0, 0x0, 0xe7e3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x97e9, 0x0, 0x0,
 0x8cd8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7ed, 0x0, 0x0, 0x0, 0x0, 0x9353, 0xe7e8, 0x0,
 0x0, 0xe7eb, 0xe7e9, 0x0, 0xe7ee, 0x0, 0x0, 0x0,
 0x0, 0xe7ef, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7e7, 0x0, 0x0, 0xe7f4, 0x8994, 0x0, 0x0, 0xe7e6,
 0x0, 0x0, 0x0, 0x94ab, 0x0, 0xe7ea, 0x0, 0x8fde,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8d7a, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9667,
 0x0, 0x8be2, 0x0, 0x0, 0x8f65, 0x0, 0x93ba, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x914c, 0x0, 0xe7f2, 0x0, 0xe7ec, 0xe7f1,
 0x0, 0x96c1, 0x0, 0x92b6, 0xe7f3, 0xe7f0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x914b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7f7, 0x0, 0xe7f6, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe7f5, 0x0, 0x0, 0x964e, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8f9b, 0x0, 0x0,
 0x0, 0x0, 0xe7f8, 0x95dd, 0x0, 0x0, 0x8973, 0x0,
 0x0, 0x0, 0x0, 0x9565, 0x9292, 0xe844, 0x0, 0x0,
 0x0, 0x0, 0x8b98, 0x0, 0xe7fa, 0x0, 0x8d7c, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8e4b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe7f9, 0x908d, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x908e, 0xe840, 0xe842, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ff9, 0x0, 0xe841, 0xe843, 0x0, 0x0,
 0x8bd1, 0x0, 0x9564, 0x0, 0x0, 0x8ee0, 0x9842, 0x0,
 0xe7fc, 0x8df6, 0x0, 0x0, 0x985e, 0x0, 0x0, 0xe845,
 0x0, 0x0, 0x0, 0x0, 0xe846, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe7fb, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x93e7, 0x0, 0x9374, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x92d5, 0x0, 0xe84b,
 0x0, 0x0, 0x0, 0x0, 0x9262, 0xe847, 0x0, 0x0,
 0x0, 0xe848, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8c4c, 0x0, 0xe84a,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8cae, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe849, 0x0, 0x8fdf,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8a99, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe84f, 0x0, 0x8dbd,
 0x9199, 0x0, 0x0, 0x92c8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8a5a, 0x0, 0x0, 0x0, 0xe84d, 0xe84e, 0x92c1, 0x0,
 0xe84c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe850, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe856, 0x0, 0x0, 0x0,
 0x0, 0xe859, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe858, 0x934c, 0x0, 0x0, 0x0, 0x0, 0xe851,
 0xe852, 0xe855, 0x0, 0x0, 0x0, 0x0, 0xe857, 0x0,
 0x0, 0x0, 0x8bbe, 0x0, 0x0, 0xe85a, 0xe854, 0x0,
 0x0, 0xe853, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe85e, 0x0, 0x0, 0x0,
 0xe85f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe860, 0x0, 0x0, 0xe85d, 0xe85c, 0x0, 0x0,
 0x0, 0x8fe0, 0x93a8, 0xe85b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe864, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe862, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe863, 0xe861,
 0x0, 0x91f6, 0x0, 0xe865, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe866, 0x0, 0x0, 0xe868, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8ad3, 0xe867, 0x96f8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe873, 0xe869, 0x0, 0x0, 0xe86c,
 0x0, 0xe86a, 0x0, 0xe86b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe86d, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe86f, 0x0, 0x0, 0x0, 0x0, 0xe870, 0x0,
 0xe871, 0x0, 0x0, 0x0, 0x0, 0xe874, 0xe872, 0xe875,
 0xe877, 0x0, 0xe876, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x92b7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x96e5, 0x0, 0xe878, 0x914d, 0x0, 0x0, 0x0,
 0xe879, 0x0, 0x95c2, 0xe87a, 0x8a4a, 0x0, 0x0, 0x0,
 0x895b, 0x0, 0x8ad5, 0x0, 0x8ad4, 0xe87b, 0x0, 0xe87c,
 0x0, 0xe87d, 0xe87e, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe880, 0x0, 0x8ad6, 0x8a74, 0x8d7d, 0x94b4, 0x0,
 0xe882, 0xe881, 0x0, 0x0, 0x0, 0x0, 0xe883, 0x0,
 0x0, 0x0, 0x0, 0x897b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe886, 0x0, 0xe885, 0xe884, 0x0, 0xe887,
 0x0, 0x0, 0x0, 0x0, 0xe88a, 0x0, 0x0, 0x0,
 0x88c5, 0x0, 0x0, 0xe888, 0x0, 0xe88c, 0xe88b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe88e, 0xe88d, 0xe88f,
 0x0, 0x93ac, 0x0, 0x0, 0x0, 0xe890, 0x0, 0x0,
 0x0, 0x0, 0xe891, 0xe893, 0x0, 0x0, 0xe892, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x958c, 0x0, 0x0,
 0x0, 0x0, 0xe894, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe895, 0x0, 0x8de3, 0x0, 0x0, 0x0, 0xe896,
 0xe897, 0x0, 0x0, 0x9668, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x916a, 0x0, 0x0, 0x0,
 0x88a2, 0x91c9, 0x0, 0xe898, 0x0, 0x958d, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe89b, 0xe899, 0x8d7e, 0x0,
 0xe89a, 0x8cc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x95c3, 0xe89d, 0xe89f, 0xe89e,
 0xe8a0, 0x0, 0x0, 0x8940, 0x9077, 0x8f9c, 0x8ad7, 0xe8a1,
 0x0, 0x0, 0x0, 0x9486, 0x0, 0xe8a3, 0x0, 0x0,
 0x0, 0x8941, 0x0, 0xe8a2, 0x92c2, 0x0, 0x97cb, 0x93a9,
 0xe89c, 0x97a4, 0x0, 0x8caf, 0x0, 0x0, 0x977a, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8bf7, 0x97b2,
 0x0, 0x8c47, 0x0, 0x91e0, 0xe440, 0x0, 0xe8a4, 0x8a4b,
 0x908f, 0x0, 0x0, 0x0, 0x0, 0x8a75, 0xe8a6, 0x0,
 0xe8a7, 0xe8a5, 0x8c84, 0x0, 0x8ddb, 0x8fe1, 0x0, 0x0,
 0x0, 0x8942, 0x0, 0x0, 0x97d7, 0x0, 0x0, 0x0,
 0xe8a9, 0xe7ac, 0x0, 0xe8a8, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe8ac, 0xe8aa, 0xe8ab, 0x0, 0xe8ad, 0x0, 0xe8ae,
 0x97ea, 0xe8af, 0xe8b0, 0x0, 0x90c7, 0x94b9, 0x0, 0x0,
 0x0, 0x909d, 0x8ae5, 0x0, 0x0, 0x9759, 0x89eb, 0x8f57,
 0x8cd9, 0x0, 0xe8b3, 0x0, 0xe8b2, 0x8e93, 0xe8b4, 0xe8b1,
 0x0, 0x0, 0x8e47, 0x0, 0x0, 0x0, 0xe8b8, 0xe5ab,
 0x0, 0x0, 0x99d4, 0x0, 0x9097, 0xe8b6, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x97a3, 0x93ef, 0x0, 0x0, 0x0,
 0x0, 0x894a, 0x0, 0x90e1, 0x8eb4, 0x0, 0x0, 0x0,
 0x0, 0x95b5, 0x0, 0x895f, 0x0, 0x0, 0x0, 0x97eb,
 0x978b, 0x0, 0xe8b9, 0x0, 0x9364, 0x0, 0x0, 0x0,
 0x0, 0x8ef9, 0x0, 0x0, 0x0, 0xe8ba, 0x0, 0xe8bb,
 0x906b, 0xe8bc, 0x0, 0x97ec, 0x0, 0x0, 0xe8b7, 0xe8be,
 0xe8c0, 0x0, 0xe8bf, 0x0, 0xe8bd, 0x0, 0x0, 0xe8c1,
 0x0, 0x0, 0xe8c2, 0x0, 0x0, 0x919a, 0x0, 0x89e0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8c3, 0x0, 0x0,
 0x96b6, 0x0, 0x0, 0xe8c4, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe8c5, 0x0, 0x9849, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9e50, 0xe8c6, 0x0, 0x0, 0xe8c7, 0xe8c8, 0x0,
 0x0, 0x0, 0x0, 0xe8cc, 0x0, 0xe8c9, 0x0, 0xe8ca,
 0x0, 0xe8cb, 0xe8cd, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x90c2, 0x0, 0x0, 0x0, 0x90c3,
 0x96f5, 0x0, 0x0, 0x0, 0x0, 0xe8ce, 0x0, 0x94f1,
 0x0, 0xe8cf, 0xea72, 0x96ca, 0x0, 0xe8d0, 0x0, 0xe8d1,
 0x0, 0xe8d2, 0x8a76, 0x0, 0xe8d4, 0x0, 0x9078, 0x0,
 0x0, 0x0, 0xe8d5, 0x0, 0x0, 0x8c43, 0x0, 0x0,
 0x0, 0x0, 0xe8d6, 0xe8da, 0x0, 0xe8d8, 0x0, 0x0,
 0x0, 0x0, 0xe8d9, 0x0, 0x0, 0x8a93, 0xe8d7, 0xe8db,
 0x0, 0x0, 0x0, 0x0, 0xe8dc, 0x0, 0x88c6, 0x0,
 0xe8dd, 0xe8de, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8fe2, 0x0, 0x0, 0x0, 0xe8df, 0x0, 0x0,
 0x0, 0x8b66, 0x0, 0x0, 0xe8e2, 0x0, 0x0, 0xe8e1,
 0x0, 0xe8e0, 0x0, 0x0, 0xe691, 0x0, 0x95da, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe8e3, 0xe8e4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe8e5, 0x0, 0x0, 0xe8e6,
 0x0, 0xe8e7, 0x0, 0x0, 0xe8e8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x8ad8, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8ea, 0x9442,
 0x0, 0x0, 0x0, 0xe8ec, 0x89b9, 0x0, 0xe8ef, 0xe8ee,
 0x0, 0x0, 0x0, 0x0, 0x8943, 0x0, 0x0, 0x0,
 0x8bbf, 0x0, 0x95c5, 0x92b8, 0x8da0, 0x0, 0x8d80, 0x8f87,
 0x0, 0x907b, 0x0, 0x0, 0x0, 0xe8f1, 0x0, 0x0,
 0xe8f0, 0x9761, 0x8ae6, 0x94d0, 0x93da, 0x0, 0x0, 0x0,
 0x909c, 0x97cc, 0x0, 0x8c7a, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe8f4, 0x0, 0x0, 0xe8f3, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x966a, 0x93aa, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x896f, 0x0, 0x0,
 0xe8f5, 0xe8f2, 0x0, 0x0, 0x9570, 0x978a, 0xe8f6, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe8f7,
 0x0, 0x0, 0x0, 0x0, 0xe8f9, 0x91e8, 0x8a7a, 0x8a7b,
 0xe8f8, 0x0, 0x0, 0x0, 0x0, 0x8ae7, 0x8cb0, 0x0,
 0x0, 0x8ae8, 0x0, 0x0, 0x935e, 0x0, 0x0, 0x97de,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8cda, 0x0, 0x0, 0x0, 0xe8fa, 0x0, 0x0, 0x0,
 0xe8fb, 0xe8fc, 0xe940, 0x0, 0xe942, 0xe941, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9597, 0x0, 0xe943, 0x0, 0x0, 0x0, 0x0,
 0xe944, 0x0, 0xe945, 0x0, 0x0, 0x0, 0x0, 0xe946,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe948, 0xe947, 0x0, 0xe949,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x94f2, 0xe3ca, 0x0, 0x0,
 0x9048, 0x0, 0x0, 0x8b51, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe94a, 0x0, 0xe94b, 0x0, 0x99aa, 0x9f5a,
 0x94d1, 0x0, 0x0, 0x88f9, 0x0, 0x88b9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e94, 0x964f, 0x8ffc,
 0x0, 0x0, 0x0, 0x0, 0xe94c, 0x0, 0x96dd, 0x0,
 0x0, 0x0, 0xe94d, 0x977b, 0x0, 0x8961, 0x0, 0x0,
 0x0, 0x8e60, 0x0, 0xe94e, 0x89ec, 0xe94f, 0x0, 0x0,
 0x0, 0xe950, 0x0, 0x0, 0x0, 0x0, 0xe952, 0xe953,
 0x0, 0xe955, 0xe951, 0x0, 0x0, 0xe954, 0x0, 0x0,
 0x0, 0x8ad9, 0x0, 0x0, 0x0, 0xe956, 0x0, 0xe957,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe958, 0xe959,
 0x0, 0x0, 0x0, 0xe95a, 0x0, 0x0, 0xe95c, 0x0,
 0x0, 0x0, 0xe95b, 0x0, 0xe95e, 0xe961, 0x0, 0x0,
 0x0, 0xe95d, 0xe95f, 0xe960, 0x0, 0x0, 0xe962, 0x0,
 0x8bc0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8ef1,
 0xe963, 0xe964, 0x8d81, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe965, 0x0,
 0x0, 0x8a5d, 0x0, 0x0, 0x0, 0x946e, 0xe966, 0xe967,
 0x0, 0x0, 0x0, 0x0, 0x9279, 0x93e9, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe968, 0x0, 0x0,
 0x0, 0x0, 0x949d, 0x0, 0x0, 0x91ca, 0x8977, 0x8bec,
 0x0, 0x8bed, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x9293, 0xe96d, 0x8bee, 0x0, 0x0, 0x89ed, 0x0,
 0x0, 0xe96c, 0x0, 0x0, 0xe96a, 0x0, 0xe96b, 0x0,
 0xe969, 0x0, 0x0, 0xe977, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe96e, 0xe96f,
 0x0, 0x0, 0xe970, 0xe971, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe973, 0x0, 0x0, 0xe972, 0x0, 0x0, 0x0,
 0x8f78, 0x0, 0xe974, 0x0, 0x0, 0x0, 0xe976, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8b52,
 0xe975, 0x0, 0x0, 0x919b, 0x8cb1, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe978, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x91cb, 0x0, 0x0, 0xe979, 0x0, 0x0, 0x0,
 0x0, 0x93ab, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe97a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe980,
 0x0, 0xe97d, 0x0, 0xe97c, 0xe97e, 0x0, 0xe97b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe982, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe981, 0x0,
 0xe984, 0x0, 0x0, 0x8bc1, 0xe983, 0x0, 0x0, 0x0,
 0xe985, 0x0, 0x0, 0xe986, 0x0, 0xe988, 0xe987, 0x0,
 0x0, 0x0, 0xe989, 0xe98b, 0xe98a, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8d9c, 0x0, 0x0, 0x0, 0x0, 0xe98c, 0x0,
 0x0, 0xe98d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8a5b, 0x0, 0x0, 0x0, 0xe98e, 0x0, 0x0,
 0x0, 0xe98f, 0x0, 0x0, 0x0, 0x9091, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe990, 0x0, 0xe991, 0x0, 0xe992, 0xe993, 0x0, 0x0,
 0x0, 0x8d82, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe994,
 0xe995, 0x0, 0x0, 0xe996, 0xe997, 0x0, 0x0, 0xe998,
 0x0, 0x0, 0x0, 0x94af, 0xe99a, 0x0, 0x9545, 0xe99b,
 0xe999, 0x0, 0xe99d, 0x0, 0x0, 0xe99c, 0x0, 0x0,
 0xe99e, 0x0, 0x0, 0x0, 0xe99f, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9a0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9a1, 0x0, 0xe9a2, 0x0, 0x0, 0x0, 0x0,
 0xe9a3, 0x0, 0x0, 0xe9a4, 0xe9a5, 0x0, 0xe9a6, 0x0,
 0xe9a7, 0xe9a8, 0xe9a9, 0xe9aa, 0x0, 0x0, 0x0, 0xe9ab,
 0xe9ac, 0x0, 0x9f54, 0xe9ad, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe2f6, 0x8b53, 0x0, 0x0,
 0x0, 0x0, 0x8a40, 0x8db0, 0xe9af, 0xe9ae, 0x96a3, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9b1, 0xe9b2,
 0xe9b0, 0x0, 0xe9b3, 0x0, 0x0, 0x9682, 0x0, 0x0,
 0x0, 0xe9b4, 0x0, 0x8b9b, 0x0, 0x0, 0x0, 0x0,
 0x9844, 0x0, 0x0, 0x0, 0x0, 0xe9b5, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xe9b7, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88bc,
 0x0, 0x0, 0xe9b8, 0x95a9, 0xe9b6, 0x0, 0x0, 0xe9b9,
 0xe9ba, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe9bb, 0xe9bc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9bd, 0x0, 0x968e, 0x8e4c, 0x0, 0x8df8, 0x914e,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9be, 0x0, 0x0,
 0x0, 0x0, 0xe9c1, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9bf, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9c2,
 0x0, 0x0, 0x8cef, 0xe9c0, 0x0, 0x0, 0x0, 0x0,
 0xe9c3, 0x0, 0xe9c4, 0xe9c5, 0x0, 0xe9c9, 0x0, 0x8e49,
 0x0, 0x0, 0x0, 0x0, 0x91e2, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe9ca, 0xe9c7, 0xe9c6, 0xe9c8, 0x0, 0x0,
 0x0, 0x8c7e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9ce, 0xe9cd, 0xe9cc, 0x0, 0x0, 0x88b1, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9d8, 0x0, 0xe9d4,
 0x0, 0xe9d5, 0xe9d1, 0xe9d7, 0x0, 0xe9d3, 0x8a82, 0x0,
 0x0, 0x986b, 0x0, 0xe9d6, 0xe9d2, 0xe9d0, 0xe9cf, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9da, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xe9dd, 0x0, 0x0, 0xe9dc, 0xe9db,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9568, 0xe9d9,
 0x88f1, 0xe9de, 0x0, 0xe9e0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x8a8f, 0xe9cb, 0x8956, 0x0, 0x0, 0xe9e2,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9e1,
 0xe9df, 0x924c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x9690, 0x0, 0x0, 0x0,
 0x0, 0x97d8, 0x0, 0x0, 0xe9e3, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xe9e4, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0xe9e5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xe9e6, 0x0, 0xe9e7, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x92b9,
 0x0, 0xe9e8, 0x0, 0x94b5, 0x0, 0xe9ed, 0xe9e9, 0x0,
 0x0, 0x0, 0xe9ea, 0x0, 0x0, 0x9650, 0x96c2, 0x0,
 0x93ce, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xe9ee, 0x0, 0x0,
 0xe9ef, 0x93bc, 0xe9ec, 0xe9eb, 0x0, 0x0, 0x0, 0x0,
 0x89a8, 0x0, 0x0, 0x0, 0xe9f7, 0x0, 0x0, 0xe9f6,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8995, 0x0, 0x0,
 0x0, 0xe9f4, 0x0, 0x0, 0x0, 0xe9f3, 0x0, 0x0,
 0xe9f1, 0x0, 0x8a9b, 0x0, 0xe9f0, 0x8eb0, 0x89a7, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x8d83, 0x0, 0x0,
 0xe9fa, 0xe9f9, 0x0, 0xe9f8, 0x0, 0x0, 0xe9f5, 0x0,
 0xe9fb, 0x0, 0xe9fc, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea44, 0xea43, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xea45, 0x0, 0x0, 0x894c, 0xea40,
 0xea41, 0x0, 0x8d94, 0x96b7, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x9651, 0x0, 0x0,
 0xea4a, 0x0, 0x0, 0xea46, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xea4b, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea48, 0x0, 0xea47, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x8c7b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xea4c, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea4d, 0x0, 0x0,
 0x0, 0x0, 0xea4e, 0x0, 0xea49, 0x0, 0x0, 0x0,
 0xe9f2, 0x0, 0x0, 0xea4f, 0x0, 0x92df, 0x0, 0x0,
 0x0, 0xea53, 0x0, 0xea54, 0xea52, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea51, 0xea57, 0x0, 0xea50, 0x0, 0xea55,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea56, 0x0, 0x0, 0x0, 0xea59, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea58, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea5b, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea5c, 0x0, 0xea5d,
 0x0, 0x0, 0x9868, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea5a, 0x91e9, 0x8deb, 0x0, 0x0, 0xea5e, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea5f, 0xea60, 0x0, 0x0, 0xea61, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea62, 0x0, 0x0,
 0x8cb2, 0xea63, 0x0, 0x0, 0x0, 0xea64, 0x0, 0x8ead,
 0x0, 0xea65, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea66, 0x0, 0x0, 0xea67, 0xea68, 0x0, 0x0, 0x0,
 0x0, 0xea6b, 0xea69, 0x985b, 0x0, 0xea6a, 0x0, 0x97ed,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea6c, 0x0, 0x97d9,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea6d, 0x949e, 0x0,
 0x0, 0xea6e, 0xea70, 0x0, 0x0, 0xea71, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0xea6f, 0x8d8d, 0x96cb, 0x9683, 0x9bf5, 0x0, 0x9f80, 0x969b,
 0x0, 0x0, 0x0, 0x0, 0x89a9, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xea73, 0x8b6f, 0xea74, 0xea75,
 0xea76, 0x0, 0x8d95, 0x0, 0xea77, 0x0, 0x0, 0x0,
 0xe0d2, 0x96d9, 0x0, 0x91e1, 0xea78, 0xea7a, 0xea79, 0x0,
 0xea7b, 0x0, 0x0, 0x0, 0x0, 0xea7c, 0x0, 0x0,
 0xea7d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea7e,
 0x0, 0x0, 0x0, 0x0, 0xea80, 0x0, 0xea81, 0xea82,
 0x0, 0xea83, 0x0, 0xea84, 0xea85, 0xea86, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea87,
 0xea88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9343, 0x0,
 0x0, 0x0, 0x0, 0x8cdb, 0x0, 0xea8a, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x916c, 0xea8b, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xea8c, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x9540, 0x0, 0x0, 0xea8d, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea8e, 0xe256, 0x0, 0x0, 0xe6d8, 0xe8eb,
 0x0, 0x0, 0xea8f, 0x0, 0xea90, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xea92,
 0xea93, 0xea94, 0x97ee, 0xea91, 0x0, 0x0, 0xea95, 0xea96,
 0x0, 0x0, 0xea98, 0x0, 0xea97, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xea9a, 0x0, 0x0, 0x0, 0xea9b, 0xea99,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x97b4, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0xea9c, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0xea9d, 0xe273, 0x0, 0x0,
 0xea9e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
 0x0, 0x8149, 0x0, 0x8194, 0x8190, 0x8193, 0x8195, 0x0,
 0x8169, 0x816a, 0x8196, 0x817b, 0x8143, 0x817c, 0x8144, 0x815e,
 0x824f, 0x8250, 0x8251, 0x8252, 0x8253, 0x8254, 0x8255, 0x8256,
 0x8257, 0x8258, 0x8146, 0x8147, 0x8183, 0x8181, 0x8184, 0x8148,
 0x8197, 0x8260, 0x8261, 0x8262, 0x8263, 0x8264, 0x8265, 0x8266,
 0x8267, 0x8268, 0x8269, 0x826a, 0x826b, 0x826c, 0x826d, 0x826e,
 0x826f, 0x8270, 0x8271, 0x8272, 0x8273, 0x8274, 0x8275, 0x8276,
 0x8277, 0x8278, 0x8279, 0x816d, 0x815f, 0x816e, 0x814f, 0x8151,
 0x814d, 0x8281, 0x8282, 0x8283, 0x8284, 0x8285, 0x8286, 0x8287,
 0x8288, 0x8289, 0x828a, 0x828b, 0x828c, 0x828d, 0x828e, 0x828f,
 0x8290, 0x8291, 0x8292, 0x8293, 0x8294, 0x8295, 0x8296, 0x8297,
 0x8298, 0x8299, 0x829a, 0x816f, 0x8162, 0x8170, 0x8160, 0x0,
 0x0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
 0x8191, 0x8192, 0x81ca, 0x8150, 0x0, 0x818f, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
0x0000,    };

#define DBCS_LeadingStart1    ((UCHAR)0x81)
#define DBCS_LeadingEnd1      ((UCHAR)0x9f)
#define DBCS_LeadingStart2    ((UCHAR)0xe0)
#define DBCS_LeadingEnd2      ((UCHAR)0xfc)
#define DBCS_TrailingStart    ((UCHAR)0x40)
#define DBCS_TrailingEnd      ((UCHAR)0xfc)
#define LeadingRange1       ( DBCS_LeadingEnd1 - DBCS_LeadingStart1 )
#define LeadingRange2       ( DBCS_LeadingEnd2 - DBCS_LeadingStart2 )
#define TrailingRange      ( DBCS_TrailingEnd - DBCS_TrailingStart )

#define LOBYTE(w)           ((UCHAR)(w))
#define HIBYTE(w)           ((UCHAR)(((USHORT)(w) >> 8) & 0xFF))
#define LEADING_BYTE(w)	      HIBYTE(w)
#define TRAILING_BYTE(w)      LOBYTE(w)

typedef struct _SJ_TO_UNICODE
{
    WCHAR SBCS_Table[256];
    WCHAR DBCS_Table1[LeadingRange1 + 1][TrailingRange + 1];
    WCHAR DBCS_Table2[LeadingRange2 + 1][TrailingRange + 1];
} SJ_TO_UNICODE;

SJ_TO_UNICODE sj_to_unicode = {

{ /////////////////////////////////////////// SBCS_Table

/* 0x0-0x7 */ 0x0,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
/* 0x8-0xf */ 0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
/* 0x10-0x17 */ 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
/* 0x18-0x1f */ 0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
/* 0x20-0x27 */ 0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,
/* 0x28-0x2f */ 0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
/* 0x30-0x37 */ 0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,
/* 0x38-0x3f */ 0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
/* 0x40-0x47 */ 0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,
/* 0x48-0x4f */ 0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
/* 0x50-0x57 */ 0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,
/* 0x58-0x5f */ 0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
/* 0x60-0x67 */ 0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,
/* 0x68-0x6f */ 0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
/* 0x70-0x77 */ 0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,
/* 0x78-0x7f */ 0x78,0x79,0x7a,0x7b,0x7c,0x7d,0xaf,0x7f,
/* 0x80-0x87 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x88-0x8f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x90-0x97 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x98-0x9f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xa0-0xa7 */ 0x0,0xff61,0xff62,0xff63,0xff64,0xff65,0xff66,0xff67,
/* 0xa8-0xaf */ 0xff68,0xff69,0xff6a,0xff6b,0xff6c,0xff6d,0xff6e,0xff6f,
/* 0xb0-0xb7 */ 0xff70,0xff71,0xff72,0xff73,0xff74,0xff75,0xff76,0xff77,
/* 0xb8-0xbf */ 0xff78,0xff79,0xff7a,0xff7b,0xff7c,0xff7d,0xff7e,0xff7f,
/* 0xc0-0xc7 */ 0xff80,0xff81,0xff82,0xff83,0xff84,0xff85,0xff86,0xff87,
/* 0xc8-0xcf */ 0xff88,0xff89,0xff8a,0xff8b,0xff8c,0xff8d,0xff8e,0xff8f,
/* 0xd0-0xd7 */ 0xff90,0xff91,0xff92,0xff93,0xff94,0xff95,0xff96,0xff97,
/* 0xd8-0xdf */ 0xff98,0xff99,0xff9a,0xff9b,0xff9c,0xff9d,0xff9e,0xff9f,
/* 0xe0-0xe7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xe8-0xef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xf0-0xf7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xf8-0xff */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
}, /////////////////////////////////////// SBCS_Table

{ //////////////////////////////////////// DBCS_Table1

{ /* 0x81 */
/* 0x8140 - 0x8147 */ 0x3000,0x3001,0x3002,0xff0c,0xff0e,0x30fb,0xff1a,0xff1b,
/* 0x8148 - 0x814f */ 0xff1f,0xff01,0x309b,0x309c,0xb4,0xff40,0xa8,0xff3e,
/* 0x8150 - 0x8157 */ 0xffe3,0xff3f,0x30fd,0x30fe,0x309d,0x309e,0x3003,0x3004,
/* 0x8158 - 0x815f */ 0x3005,0x3006,0x3007,0x30fc,0x2015,0xad,0xff0f,0xff3c,
/* 0x8160 - 0x8167 */ 0xff5e,0x2225,0xff5c,0x2026,0x2025,0x2018,0x2019,0x201c,
/* 0x8168 - 0x816f */ 0x201d,0xff08,0xff09,0x3014,0x3015,0xff3b,0xff3d,0xff5b,
/* 0x8170 - 0x8177 */ 0xff5d,0x3008,0x3009,0x300a,0x300b,0x300c,0x300d,0x300e,
/* 0x8178 - 0x817f */ 0x300f,0x3010,0x3011,0xff0b,0xff0d,0xb1,0xd7,0x0,
/* 0x8180 - 0x8187 */ 0xf7,0xff1d,0x2260,0xff1c,0xff1e,0x2266,0x2267,0x221e,
/* 0x8188 - 0x818f */ 0x2234,0x2642,0x2640,0xb0,0x2032,0x2033,0x2103,0xffe5,
/* 0x8190 - 0x8197 */ 0xff04,0xffe0,0xffe1,0xff05,0xff03,0xff06,0xff0a,0xff20,
/* 0x8198 - 0x819f */ 0xa7,0x2606,0x2605,0x25cb,0x25cf,0x25ce,0x25c7,0x25c6,
/* 0x81a0 - 0x81a7 */ 0x25a1,0x25a0,0x25b3,0x25b2,0x25bd,0x25bc,0x203b,0x3012,
/* 0x81a8 - 0x81af */ 0x2192,0x2190,0x2191,0x2193,0x3013,0x0,0x0,0x0,
/* 0x81b0 - 0x81b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81b8 - 0x81bf */ 0x2208,0x220b,0x2286,0x2287,0x2282,0x2283,0x222a,0x2229,
/* 0x81c0 - 0x81c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81c8 - 0x81cf */ 0x2227,0x2228,0xffe2,0x21d2,0x21d4,0x2200,0x2203,0x0,
/* 0x81d0 - 0x81d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81d8 - 0x81df */ 0x0,0x0,0x2220,0x22a5,0x2312,0x2202,0x2207,0x2261,
/* 0x81e0 - 0x81e7 */ 0x2252,0x226a,0x226b,0x221a,0x223d,0x221d,0x2235,0x222b,
/* 0x81e8 - 0x81ef */ 0x222c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x81f0 - 0x81f7 */ 0x212b,0x2030,0x266f,0x266d,0x266a,0x2020,0x2021,0xb6,
/* 0x81f8 - 0x81ff */ 0x0,0x0,0x0,0x0,0x20dd
}, /* 0x81 */

{ /* 0x82 */
/* 0x8240 - 0x8247 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8248 - 0x824f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff10,
/* 0x8250 - 0x8257 */ 0xff11,0xff12,0xff13,0xff14,0xff15,0xff16,0xff17,0xff18,
/* 0x8258 - 0x825f */ 0xff19,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8260 - 0x8267 */ 0xff21,0xff22,0xff23,0xff24,0xff25,0xff26,0xff27,0xff28,
/* 0x8268 - 0x826f */ 0xff29,0xff2a,0xff2b,0xff2c,0xff2d,0xff2e,0xff2f,0xff30,
/* 0x8270 - 0x8277 */ 0xff31,0xff32,0xff33,0xff34,0xff35,0xff36,0xff37,0xff38,
/* 0x8278 - 0x827f */ 0xff39,0xff3a,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8280 - 0x8287 */ 0x0,0xff41,0xff42,0xff43,0xff44,0xff45,0xff46,0xff47,
/* 0x8288 - 0x828f */ 0xff48,0xff49,0xff4a,0xff4b,0xff4c,0xff4d,0xff4e,0xff4f,
/* 0x8290 - 0x8297 */ 0xff50,0xff51,0xff52,0xff53,0xff54,0xff55,0xff56,0xff57,
/* 0x8298 - 0x829f */ 0xff58,0xff59,0xff5a,0x0,0x0,0x0,0x0,0x3041,
/* 0x82a0 - 0x82a7 */ 0x3042,0x3043,0x3044,0x3045,0x3046,0x3047,0x3048,0x3049,
/* 0x82a8 - 0x82af */ 0x304a,0x304b,0x304c,0x304d,0x304e,0x304f,0x3050,0x3051,
/* 0x82b0 - 0x82b7 */ 0x3052,0x3053,0x3054,0x3055,0x3056,0x3057,0x3058,0x3059,
/* 0x82b8 - 0x82bf */ 0x305a,0x305b,0x305c,0x305d,0x305e,0x305f,0x3060,0x3061,
/* 0x82c0 - 0x82c7 */ 0x3062,0x3063,0x3064,0x3065,0x3066,0x3067,0x3068,0x3069,
/* 0x82c8 - 0x82cf */ 0x306a,0x306b,0x306c,0x306d,0x306e,0x306f,0x3070,0x3071,
/* 0x82d0 - 0x82d7 */ 0x3072,0x3073,0x3074,0x3075,0x3076,0x3077,0x3078,0x3079,
/* 0x82d8 - 0x82df */ 0x307a,0x307b,0x307c,0x307d,0x307e,0x307f,0x3080,0x3081,
/* 0x82e0 - 0x82e7 */ 0x3082,0x3083,0x3084,0x3085,0x3086,0x3087,0x3088,0x3089,
/* 0x82e8 - 0x82ef */ 0x308a,0x308b,0x308c,0x308d,0x308e,0x308f,0x3090,0x3091,
/* 0x82f0 - 0x82f7 */ 0x3092,0x3093,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x82f8 - 0x82ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x82 */

{ /* 0x83 */
/* 0x8340 - 0x8347 */ 0x30a1,0x30a2,0x30a3,0x30a4,0x30a5,0x30a6,0x30a7,0x30a8,
/* 0x8348 - 0x834f */ 0x30a9,0x30aa,0x30ab,0x30ac,0x30ad,0x30ae,0x30af,0x30b0,
/* 0x8350 - 0x8357 */ 0x30b1,0x30b2,0x30b3,0x30b4,0x30b5,0x30b6,0x30b7,0x30b8,
/* 0x8358 - 0x835f */ 0x30b9,0x30ba,0x30bb,0x30bc,0x30bd,0x30be,0x30bf,0x30c0,
/* 0x8360 - 0x8367 */ 0x30c1,0x30c2,0x30c3,0x30c4,0x30c5,0x30c6,0x30c7,0x30c8,
/* 0x8368 - 0x836f */ 0x30c9,0x30ca,0x30cb,0x30cc,0x30cd,0x30ce,0x30cf,0x30d0,
/* 0x8370 - 0x8377 */ 0x30d1,0x30d2,0x30d3,0x30d4,0x30d5,0x30d6,0x30d7,0x30d8,
/* 0x8378 - 0x837f */ 0x30d9,0x30da,0x30db,0x30dc,0x30dd,0x30de,0x30df,0x0,
/* 0x8380 - 0x8387 */ 0x30e0,0x30e1,0x30e2,0x30e3,0x30e4,0x30e5,0x30e6,0x30e7,
/* 0x8388 - 0x838f */ 0x30e8,0x30e9,0x30ea,0x30eb,0x30ec,0x30ed,0x30ee,0x30ef,
/* 0x8390 - 0x8397 */ 0x30f0,0x30f1,0x30f2,0x30f3,0x30f4,0x30f5,0x30f6,0x0,
/* 0x8398 - 0x839f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x391,
/* 0x83a0 - 0x83a7 */ 0x392,0x393,0x394,0x395,0x396,0x397,0x398,0x399,
/* 0x83a8 - 0x83af */ 0x39a,0x39b,0x39c,0x39d,0x39e,0x39f,0x3a0,0x3a1,
/* 0x83b0 - 0x83b7 */ 0x3a3,0x3a4,0x3a5,0x3a6,0x3a7,0x3a8,0x3a9,0x0,
/* 0x83b8 - 0x83bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3b1,
/* 0x83c0 - 0x83c7 */ 0x3b2,0x3b3,0x3b4,0x3b5,0x3b6,0x3b7,0x3b8,0x3b9,
/* 0x83c8 - 0x83cf */ 0x3ba,0x3bb,0x3bc,0x3bd,0x3be,0x3bf,0x3c0,0x3c1,
/* 0x83d0 - 0x83d7 */ 0x3c3,0x3c4,0x3c5,0x3c6,0x3c7,0x3c8,0x3c9,0x0,
/* 0x83d8 - 0x83df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83e0 - 0x83e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83e8 - 0x83ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83f0 - 0x83f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x83f8 - 0x83ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x83 */

{ /* 0x84 */
/* 0x8440 - 0x8447 */ 0x410,0x411,0x412,0x413,0x414,0x415,0x401,0x416,
/* 0x8448 - 0x844f */ 0x417,0x418,0x419,0x41a,0x41b,0x41c,0x41d,0x41e,
/* 0x8450 - 0x8457 */ 0x41f,0x420,0x421,0x422,0x423,0x424,0x425,0x426,
/* 0x8458 - 0x845f */ 0x427,0x428,0x429,0x42a,0x42b,0x42c,0x42d,0x42e,
/* 0x8460 - 0x8467 */ 0x42f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8468 - 0x846f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8470 - 0x8477 */ 0x430,0x431,0x432,0x433,0x434,0x435,0x451,0x436,
/* 0x8478 - 0x847f */ 0x437,0x438,0x439,0x43a,0x43b,0x43c,0x43d,0x0,
/* 0x8480 - 0x8487 */ 0x43e,0x43f,0x440,0x441,0x442,0x443,0x444,0x445,
/* 0x8488 - 0x848f */ 0x446,0x447,0x448,0x449,0x44a,0x44b,0x44c,0x44d,
/* 0x8490 - 0x8497 */ 0x44e,0x44f,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8498 - 0x849f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2500,
/* 0x84a0 - 0x84a7 */ 0x2502,0x250c,0x2510,0x2518,0x2514,0x251c,0x252c,0x2524,
/* 0x84a8 - 0x84af */ 0x2534,0x253c,0x2501,0x2503,0x250f,0x2513,0x251b,0x2517,
/* 0x84b0 - 0x84b7 */ 0x2523,0x2533,0x252b,0x253b,0x254b,0x2520,0x252f,0x2528,
/* 0x84b8 - 0x84bf */ 0x2537,0x253f,0x251d,0x2530,0x2525,0x2538,0x2542,0x0,
/* 0x84c0 - 0x84c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84c8 - 0x84cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84d0 - 0x84d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84d8 - 0x84df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84e0 - 0x84e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84e8 - 0x84ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84f0 - 0x84f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x84f8 - 0x84ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x84 */

{ /* 0x85 */
/* 0x8540 - 0x8547 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8548 - 0x854f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8550 - 0x8557 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8558 - 0x855f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8560 - 0x8567 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8568 - 0x856f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8570 - 0x8577 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8578 - 0x857f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8580 - 0x8587 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8588 - 0x858f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8590 - 0x8597 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8598 - 0x859f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85a0 - 0x85a7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85a8 - 0x85af */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85b0 - 0x85b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85b8 - 0x85bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85c0 - 0x85c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85c8 - 0x85cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85d0 - 0x85d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85d8 - 0x85df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85e0 - 0x85e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85e8 - 0x85ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85f0 - 0x85f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x85f8 - 0x85ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x85 */

{ /* 0x86 */
/* 0x8640 - 0x8647 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8648 - 0x864f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8650 - 0x8657 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8658 - 0x865f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8660 - 0x8667 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8668 - 0x866f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8670 - 0x8677 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8678 - 0x867f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8680 - 0x8687 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8688 - 0x868f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8690 - 0x8697 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8698 - 0x869f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86a0 - 0x86a7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86a8 - 0x86af */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86b0 - 0x86b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86b8 - 0x86bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86c0 - 0x86c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86c8 - 0x86cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86d0 - 0x86d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86d8 - 0x86df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86e0 - 0x86e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86e8 - 0x86ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86f0 - 0x86f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x86f8 - 0x86ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x86 */

{ /* 0x87 */
/* 0x8740 - 0x8747 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8748 - 0x874f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8750 - 0x8757 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8758 - 0x875f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8760 - 0x8767 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8768 - 0x876f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8770 - 0x8777 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8778 - 0x877f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8780 - 0x8787 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8788 - 0x878f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8790 - 0x8797 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8798 - 0x879f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87a0 - 0x87a7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87a8 - 0x87af */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87b0 - 0x87b7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87b8 - 0x87bf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87c0 - 0x87c7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87c8 - 0x87cf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87d0 - 0x87d7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87d8 - 0x87df */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87e0 - 0x87e7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87e8 - 0x87ef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87f0 - 0x87f7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x87f8 - 0x87ff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0x87 */

{ /* 0x88 */
/* 0x8840 - 0x8847 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8848 - 0x884f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8850 - 0x8857 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8858 - 0x885f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8860 - 0x8867 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8868 - 0x886f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8870 - 0x8877 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8878 - 0x887f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8880 - 0x8887 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8888 - 0x888f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8890 - 0x8897 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x8898 - 0x889f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4e9c,
/* 0x88a0 - 0x88a7 */ 0x5516,0x5a03,0x963f,0x54c0,0x611b,0x6328,0x59f6,0x9022,
/* 0x88a8 - 0x88af */ 0x8475,0x831c,0x7a50,0x60aa,0x63e1,0x6e25,0x65ed,0x8466,
/* 0x88b0 - 0x88b7 */ 0x82a6,0x9bf5,0x6893,0x5727,0x65a1,0x6271,0x5b9b,0x59d0,
/* 0x88b8 - 0x88bf */ 0x867b,0x98f4,0x7d62,0x7dbe,0x9b8e,0x6216,0x7c9f,0x88b7,
/* 0x88c0 - 0x88c7 */ 0x5b89,0x5eb5,0x6309,0x6697,0x6848,0x95c7,0x978d,0x674f,
/* 0x88c8 - 0x88cf */ 0x4ee5,0x4f0a,0x4f4d,0x4f9d,0x5049,0x56f2,0x5937,0x59d4,
/* 0x88d0 - 0x88d7 */ 0x5a01,0x5c09,0x60df,0x610f,0x6170,0x6613,0x6905,0x70ba,
/* 0x88d8 - 0x88df */ 0x754f,0x7570,0x79fb,0x7dad,0x7def,0x80c3,0x840e,0x8863,
/* 0x88e0 - 0x88e7 */ 0x8b02,0x9055,0x907a,0x533b,0x4e95,0x4ea5,0x57df,0x80b2,
/* 0x88e8 - 0x88ef */ 0x90c1,0x78ef,0x4e00,0x58f1,0x6ea2,0x9038,0x7a32,0x8328,
/* 0x88f0 - 0x88f7 */ 0x828b,0x9c2f,0x5141,0x5370,0x54bd,0x54e1,0x56e0,0x59fb,
/* 0x88f8 - 0x88ff */ 0x5f15,0x98f2,0x6deb,0x80e4,0x852d
}, /* 0x88 */

{ /* 0x89 */
/* 0x8940 - 0x8947 */ 0x9662,0x9670,0x96a0,0x97fb,0x540b,0x53f3,0x5b87,0x70cf,
/* 0x8948 - 0x894f */ 0x7fbd,0x8fc2,0x96e8,0x536f,0x9d5c,0x7aba,0x4e11,0x7893,
/* 0x8950 - 0x8957 */ 0x81fc,0x6e26,0x5618,0x5504,0x6b1d,0x851a,0x9c3b,0x59e5,
/* 0x8958 - 0x895f */ 0x53a9,0x6d66,0x74dc,0x958f,0x5642,0x4e91,0x904b,0x96f2,
/* 0x8960 - 0x8967 */ 0x834f,0x990c,0x53e1,0x55b6,0x5b30,0x5f71,0x6620,0x66f3,
/* 0x8968 - 0x896f */ 0x6804,0x6c38,0x6cf3,0x6d29,0x745b,0x76c8,0x7a4e,0x9834,
/* 0x8970 - 0x8977 */ 0x82f1,0x885b,0x8a60,0x92ed,0x6db2,0x75ab,0x76ca,0x99c5,
/* 0x8978 - 0x897f */ 0x60a6,0x8b01,0x8d8a,0x95b2,0x698e,0x53ad,0x5186,0x0,
/* 0x8980 - 0x8987 */ 0x5712,0x5830,0x5944,0x5bb4,0x5ef6,0x6028,0x63a9,0x63f4,
/* 0x8988 - 0x898f */ 0x6cbf,0x6f14,0x708e,0x7114,0x7159,0x71d5,0x733f,0x7e01,
/* 0x8990 - 0x8997 */ 0x8276,0x82d1,0x8597,0x9060,0x925b,0x9d1b,0x5869,0x65bc,
/* 0x8998 - 0x899f */ 0x6c5a,0x7525,0x51f9,0x592e,0x5965,0x5f80,0x5fdc,0x62bc,
/* 0x89a0 - 0x89a7 */ 0x65fa,0x6a2a,0x6b27,0x6bb4,0x738b,0x7fc1,0x8956,0x9d2c,
/* 0x89a8 - 0x89af */ 0x9d0e,0x9ec4,0x5ca1,0x6c96,0x837b,0x5104,0x5c4b,0x61b6,
/* 0x89b0 - 0x89b7 */ 0x81c6,0x6876,0x7261,0x4e59,0x4ffa,0x5378,0x6069,0x6e29,
/* 0x89b8 - 0x89bf */ 0x7a4f,0x97f3,0x4e0b,0x5316,0x4eee,0x4f55,0x4f3d,0x4fa1,
/* 0x89c0 - 0x89c7 */ 0x4f73,0x52a0,0x53ef,0x5609,0x590f,0x5ac1,0x5bb6,0x5be1,
/* 0x89c8 - 0x89cf */ 0x79d1,0x6687,0x679c,0x67b6,0x6b4c,0x6cb3,0x706b,0x73c2,
/* 0x89d0 - 0x89d7 */ 0x798d,0x79be,0x7a3c,0x7b87,0x82b1,0x82db,0x8304,0x8377,
/* 0x89d8 - 0x89df */ 0x83ef,0x83d3,0x8766,0x8ab2,0x5629,0x8ca8,0x8fe6,0x904e,
/* 0x89e0 - 0x89e7 */ 0x971e,0x868a,0x4fc4,0x5ce8,0x6211,0x7259,0x753b,0x81e5,
/* 0x89e8 - 0x89ef */ 0x82bd,0x86fe,0x8cc0,0x96c5,0x9913,0x99d5,0x4ecb,0x4f1a,
/* 0x89f0 - 0x89f7 */ 0x89e3,0x56de,0x584a,0x58ca,0x5efb,0x5feb,0x602a,0x6094,
/* 0x89f8 - 0x89ff */ 0x6062,0x61d0,0x6212,0x62d0,0x6539
}, /* 0x89 */

{ /* 0x8a */
/* 0x8a40 - 0x8a47 */ 0x9b41,0x6666,0x68b0,0x6d77,0x7070,0x754c,0x7686,0x7d75,
/* 0x8a48 - 0x8a4f */ 0x82a5,0x87f9,0x958b,0x968e,0x8c9d,0x51f1,0x52be,0x5916,
/* 0x8a50 - 0x8a57 */ 0x54b3,0x5bb3,0x5d16,0x6168,0x6982,0x6daf,0x788d,0x84cb,
/* 0x8a58 - 0x8a5f */ 0x8857,0x8a72,0x93a7,0x9ab8,0x6d6c,0x99a8,0x86d9,0x57a3,
/* 0x8a60 - 0x8a67 */ 0x67ff,0x86ce,0x920e,0x5283,0x5687,0x5404,0x5ed3,0x62e1,
/* 0x8a68 - 0x8a6f */ 0x64b9,0x683c,0x6838,0x6bbb,0x7372,0x78ba,0x7a6b,0x899a,
/* 0x8a70 - 0x8a77 */ 0x89d2,0x8d6b,0x8f03,0x90ed,0x95a3,0x9694,0x9769,0x5b66,
/* 0x8a78 - 0x8a7f */ 0x5cb3,0x697d,0x984d,0x984e,0x639b,0x7b20,0x6a2b,0x0,
/* 0x8a80 - 0x8a87 */ 0x6a7f,0x68b6,0x9c0d,0x6f5f,0x5272,0x559d,0x6070,0x62ec,
/* 0x8a88 - 0x8a8f */ 0x6d3b,0x6e07,0x6ed1,0x845b,0x8910,0x8f44,0x4e14,0x9c39,
/* 0x8a90 - 0x8a97 */ 0x53f6,0x691b,0x6a3a,0x9784,0x682a,0x515c,0x7ac3,0x84b2,
/* 0x8a98 - 0x8a9f */ 0x91dc,0x938c,0x565b,0x9d28,0x6822,0x8305,0x8431,0x7ca5,
/* 0x8aa0 - 0x8aa7 */ 0x5208,0x82c5,0x74e6,0x4e7e,0x4f83,0x51a0,0x5bd2,0x520a,
/* 0x8aa8 - 0x8aaf */ 0x52d8,0x52e7,0x5dfb,0x559a,0x582a,0x59e6,0x5b8c,0x5b98,
/* 0x8ab0 - 0x8ab7 */ 0x5bdb,0x5e72,0x5e79,0x60a3,0x611f,0x6163,0x61be,0x63db,
/* 0x8ab8 - 0x8abf */ 0x6562,0x67d1,0x6853,0x68fa,0x6b3e,0x6b53,0x6c57,0x6f22,
/* 0x8ac0 - 0x8ac7 */ 0x6f97,0x6f45,0x74b0,0x7518,0x76e3,0x770b,0x7aff,0x7ba1,
/* 0x8ac8 - 0x8acf */ 0x7c21,0x7de9,0x7f36,0x7ff0,0x809d,0x8266,0x839e,0x89b3,
/* 0x8ad0 - 0x8ad7 */ 0x8acc,0x8cab,0x9084,0x9451,0x9593,0x9591,0x95a2,0x9665,
/* 0x8ad8 - 0x8adf */ 0x97d3,0x9928,0x8218,0x4e38,0x542b,0x5cb8,0x5dcc,0x73a9,
/* 0x8ae0 - 0x8ae7 */ 0x764c,0x773c,0x5ca9,0x7feb,0x8d0b,0x96c1,0x9811,0x9854,
/* 0x8ae8 - 0x8aef */ 0x9858,0x4f01,0x4f0e,0x5371,0x559c,0x5668,0x57fa,0x5947,
/* 0x8af0 - 0x8af7 */ 0x5b09,0x5bc4,0x5c90,0x5e0c,0x5e7e,0x5fcc,0x63ee,0x673a,
/* 0x8af8 - 0x8aff */ 0x65d7,0x65e2,0x671f,0x68cb,0x68c4
}, /* 0x8a */

{ /* 0x8b */
/* 0x8b40 - 0x8b47 */ 0x6a5f,0x5e30,0x6bc5,0x6c17,0x6c7d,0x757f,0x7948,0x5b63,
/* 0x8b48 - 0x8b4f */ 0x7a00,0x7d00,0x5fbd,0x898f,0x8a18,0x8cb4,0x8d77,0x8ecc,
/* 0x8b50 - 0x8b57 */ 0x8f1d,0x98e2,0x9a0e,0x9b3c,0x4e80,0x507d,0x5100,0x5993,
/* 0x8b58 - 0x8b5f */ 0x5b9c,0x622f,0x6280,0x64ec,0x6b3a,0x72a0,0x7591,0x7947,
/* 0x8b60 - 0x8b67 */ 0x7fa9,0x87fb,0x8abc,0x8b70,0x63ac,0x83ca,0x97a0,0x5409,
/* 0x8b68 - 0x8b6f */ 0x5403,0x55ab,0x6854,0x6a58,0x8a70,0x7827,0x6775,0x9ecd,
/* 0x8b70 - 0x8b77 */ 0x5374,0x5ba2,0x811a,0x8650,0x9006,0x4e18,0x4e45,0x4ec7,
/* 0x8b78 - 0x8b7f */ 0x4f11,0x53ca,0x5438,0x5bae,0x5f13,0x6025,0x6551,0x0,
/* 0x8b80 - 0x8b87 */ 0x673d,0x6c42,0x6c72,0x6ce3,0x7078,0x7403,0x7a76,0x7aae,
/* 0x8b88 - 0x8b8f */ 0x7b08,0x7d1a,0x7cfe,0x7d66,0x65e7,0x725b,0x53bb,0x5c45,
/* 0x8b90 - 0x8b97 */ 0x5de8,0x62d2,0x62e0,0x6319,0x6e20,0x865a,0x8a31,0x8ddd,
/* 0x8b98 - 0x8b9f */ 0x92f8,0x6f01,0x79a6,0x9b5a,0x4ea8,0x4eab,0x4eac,0x4f9b,
/* 0x8ba0 - 0x8ba7 */ 0x4fa0,0x50d1,0x5147,0x7af6,0x5171,0x51f6,0x5354,0x5321,
/* 0x8ba8 - 0x8baf */ 0x537f,0x53eb,0x55ac,0x5883,0x5ce1,0x5f37,0x5f4a,0x602f,
/* 0x8bb0 - 0x8bb7 */ 0x6050,0x606d,0x631f,0x6559,0x6a4b,0x6cc1,0x72c2,0x72ed,
/* 0x8bb8 - 0x8bbf */ 0x77ef,0x80f8,0x8105,0x8208,0x854e,0x90f7,0x93e1,0x97ff,
/* 0x8bc0 - 0x8bc7 */ 0x9957,0x9a5a,0x4ef0,0x51dd,0x5c2d,0x6681,0x696d,0x5c40,
/* 0x8bc8 - 0x8bcf */ 0x66f2,0x6975,0x7389,0x6850,0x7c81,0x50c5,0x52e4,0x5747,
/* 0x8bd0 - 0x8bd7 */ 0x5dfe,0x9326,0x65a4,0x6b23,0x6b3d,0x7434,0x7981,0x79bd,
/* 0x8bd8 - 0x8bdf */ 0x7b4b,0x7dca,0x82b9,0x83cc,0x887f,0x895f,0x8b39,0x8fd1,
/* 0x8be0 - 0x8be7 */ 0x91d1,0x541f,0x9280,0x4e5d,0x5036,0x53e5,0x533a,0x72d7,
/* 0x8be8 - 0x8bef */ 0x7396,0x77e9,0x82e6,0x8eaf,0x99c6,0x99c8,0x99d2,0x5177,
/* 0x8bf0 - 0x8bf7 */ 0x611a,0x865e,0x55b0,0x7a7a,0x5076,0x5bd3,0x9047,0x9685,
/* 0x8bf8 - 0x8bff */ 0x4e32,0x6adb,0x91e7,0x5c51,0x5c48
}, /* 0x8b */

{ /* 0x8c */
/* 0x8c40 - 0x8c47 */ 0x6398,0x7a9f,0x6c93,0x9774,0x8f61,0x7aaa,0x718a,0x9688,
/* 0x8c48 - 0x8c4f */ 0x7c82,0x6817,0x7e70,0x6851,0x936c,0x52f2,0x541b,0x85ab,
/* 0x8c50 - 0x8c57 */ 0x8a13,0x7fa4,0x8ecd,0x90e1,0x5366,0x8888,0x7941,0x4fc2,
/* 0x8c58 - 0x8c5f */ 0x50be,0x5211,0x5144,0x5553,0x572d,0x73ea,0x578b,0x5951,
/* 0x8c60 - 0x8c67 */ 0x5f62,0x5f84,0x6075,0x6176,0x6167,0x61a9,0x63b2,0x643a,
/* 0x8c68 - 0x8c6f */ 0x656c,0x666f,0x6842,0x6e13,0x7566,0x7a3d,0x7cfb,0x7d4c,
/* 0x8c70 - 0x8c77 */ 0x7d99,0x7e4b,0x7f6b,0x830e,0x834a,0x86cd,0x8a08,0x8a63,
/* 0x8c78 - 0x8c7f */ 0x8b66,0x8efd,0x981a,0x9d8f,0x82b8,0x8fce,0x9be8,0x0,
/* 0x8c80 - 0x8c87 */ 0x5287,0x621f,0x6483,0x6fc0,0x9699,0x6841,0x5091,0x6b20,
/* 0x8c88 - 0x8c8f */ 0x6c7a,0x6f54,0x7a74,0x7d50,0x8840,0x8a23,0x6708,0x4ef6,
/* 0x8c90 - 0x8c97 */ 0x5039,0x5026,0x5065,0x517c,0x5238,0x5263,0x55a7,0x570f,
/* 0x8c98 - 0x8c9f */ 0x5805,0x5acc,0x5efa,0x61b2,0x61f8,0x62f3,0x6372,0x691c,
/* 0x8ca0 - 0x8ca7 */ 0x6a29,0x727d,0x72ac,0x732e,0x7814,0x786f,0x7d79,0x770c,
/* 0x8ca8 - 0x8caf */ 0x80a9,0x898b,0x8b19,0x8ce2,0x8ed2,0x9063,0x9375,0x967a,
/* 0x8cb0 - 0x8cb7 */ 0x9855,0x9a13,0x9e78,0x5143,0x539f,0x53b3,0x5e7b,0x5f26,
/* 0x8cb8 - 0x8cbf */ 0x6e1b,0x6e90,0x7384,0x73fe,0x7d43,0x8237,0x8a00,0x8afa,
/* 0x8cc0 - 0x8cc7 */ 0x9650,0x4e4e,0x500b,0x53e4,0x547c,0x56fa,0x59d1,0x5b64,
/* 0x8cc8 - 0x8ccf */ 0x5df1,0x5eab,0x5f27,0x6238,0x6545,0x67af,0x6e56,0x72d0,
/* 0x8cd0 - 0x8cd7 */ 0x7cca,0x88b4,0x80a1,0x80e1,0x83f0,0x864e,0x8a87,0x8de8,
/* 0x8cd8 - 0x8cdf */ 0x9237,0x96c7,0x9867,0x9f13,0x4e94,0x4e92,0x4f0d,0x5348,
/* 0x8ce0 - 0x8ce7 */ 0x5449,0x543e,0x5a2f,0x5f8c,0x5fa1,0x609f,0x68a7,0x6a8e,
/* 0x8ce8 - 0x8cef */ 0x745a,0x7881,0x8a9e,0x8aa4,0x8b77,0x9190,0x4e5e,0x9bc9,
/* 0x8cf0 - 0x8cf7 */ 0x4ea4,0x4f7c,0x4faf,0x5019,0x5016,0x5149,0x516c,0x529f,
/* 0x8cf8 - 0x8cff */ 0x52b9,0x52fe,0x539a,0x53e3,0x5411
}, /* 0x8c */

{ /* 0x8d */
/* 0x8d40 - 0x8d47 */ 0x540e,0x5589,0x5751,0x57a2,0x597d,0x5b54,0x5b5d,0x5b8f,
/* 0x8d48 - 0x8d4f */ 0x5de5,0x5de7,0x5df7,0x5e78,0x5e83,0x5e9a,0x5eb7,0x5f18,
/* 0x8d50 - 0x8d57 */ 0x6052,0x614c,0x6297,0x62d8,0x63a7,0x653b,0x6602,0x6643,
/* 0x8d58 - 0x8d5f */ 0x66f4,0x676d,0x6821,0x6897,0x69cb,0x6c5f,0x6d2a,0x6d69,
/* 0x8d60 - 0x8d67 */ 0x6e2f,0x6e9d,0x7532,0x7687,0x786c,0x7a3f,0x7ce0,0x7d05,
/* 0x8d68 - 0x8d6f */ 0x7d18,0x7d5e,0x7db1,0x8015,0x8003,0x80af,0x80b1,0x8154,
/* 0x8d70 - 0x8d77 */ 0x818f,0x822a,0x8352,0x884c,0x8861,0x8b1b,0x8ca2,0x8cfc,
/* 0x8d78 - 0x8d7f */ 0x90ca,0x9175,0x9271,0x783f,0x92fc,0x95a4,0x964d,0x0,
/* 0x8d80 - 0x8d87 */ 0x9805,0x9999,0x9ad8,0x9d3b,0x525b,0x52ab,0x53f7,0x5408,
/* 0x8d88 - 0x8d8f */ 0x58d5,0x62f7,0x6fe0,0x8c6a,0x8f5f,0x9eb9,0x514b,0x523b,
/* 0x8d90 - 0x8d97 */ 0x544a,0x56fd,0x7a40,0x9177,0x9d60,0x9ed2,0x7344,0x6f09,
/* 0x8d98 - 0x8d9f */ 0x8170,0x7511,0x5ffd,0x60da,0x9aa8,0x72db,0x8fbc,0x6b64,
/* 0x8da0 - 0x8da7 */ 0x9803,0x4eca,0x56f0,0x5764,0x58be,0x5a5a,0x6068,0x61c7,
/* 0x8da8 - 0x8daf */ 0x660f,0x6606,0x6839,0x68b1,0x6df7,0x75d5,0x7d3a,0x826e,
/* 0x8db0 - 0x8db7 */ 0x9b42,0x4e9b,0x4f50,0x53c9,0x5506,0x5d6f,0x5de6,0x5dee,
/* 0x8db8 - 0x8dbf */ 0x67fb,0x6c99,0x7473,0x7802,0x8a50,0x9396,0x88df,0x5750,
/* 0x8dc0 - 0x8dc7 */ 0x5ea7,0x632b,0x50b5,0x50ac,0x518d,0x6700,0x54c9,0x585e,
/* 0x8dc8 - 0x8dcf */ 0x59bb,0x5bb0,0x5f69,0x624d,0x63a1,0x683d,0x6b73,0x6e08,
/* 0x8dd0 - 0x8dd7 */ 0x707d,0x91c7,0x7280,0x7815,0x7826,0x796d,0x658e,0x7d30,
/* 0x8dd8 - 0x8ddf */ 0x83dc,0x88c1,0x8f09,0x969b,0x5264,0x5728,0x6750,0x7f6a,
/* 0x8de0 - 0x8de7 */ 0x8ca1,0x51b4,0x5742,0x962a,0x583a,0x698a,0x80b4,0x54b2,
/* 0x8de8 - 0x8def */ 0x5d0e,0x57fc,0x7895,0x9dfa,0x4f5c,0x524a,0x548b,0x643e,
/* 0x8df0 - 0x8df7 */ 0x6628,0x6714,0x67f5,0x7a84,0x7b56,0x7d22,0x932f,0x685c,
/* 0x8df8 - 0x8dff */ 0x9bad,0x7b39,0x5319,0x518a,0x5237
}, /* 0x8d */

{ /* 0x8e */
/* 0x8e40 - 0x8e47 */ 0x5bdf,0x62f6,0x64ae,0x64e6,0x672d,0x6bba,0x85a9,0x96d1,
/* 0x8e48 - 0x8e4f */ 0x7690,0x9bd6,0x634c,0x9306,0x9bab,0x76bf,0x6652,0x4e09,
/* 0x8e50 - 0x8e57 */ 0x5098,0x53c2,0x5c71,0x60e8,0x6492,0x6563,0x685f,0x71e6,
/* 0x8e58 - 0x8e5f */ 0x73ca,0x7523,0x7b97,0x7e82,0x8695,0x8b83,0x8cdb,0x9178,
/* 0x8e60 - 0x8e67 */ 0x9910,0x65ac,0x66ab,0x6b8b,0x4ed5,0x4ed4,0x4f3a,0x4f7f,
/* 0x8e68 - 0x8e6f */ 0x523a,0x53f8,0x53f2,0x55e3,0x56db,0x58eb,0x59cb,0x59c9,
/* 0x8e70 - 0x8e77 */ 0x59ff,0x5b50,0x5c4d,0x5e02,0x5e2b,0x5fd7,0x601d,0x6307,
/* 0x8e78 - 0x8e7f */ 0x652f,0x5b5c,0x65af,0x65bd,0x65e8,0x679d,0x6b62,0x0,
/* 0x8e80 - 0x8e87 */ 0x6b7b,0x6c0f,0x7345,0x7949,0x79c1,0x7cf8,0x7d19,0x7d2b,
/* 0x8e88 - 0x8e8f */ 0x80a2,0x8102,0x81f3,0x8996,0x8a5e,0x8a69,0x8a66,0x8a8c,
/* 0x8e90 - 0x8e97 */ 0x8aee,0x8cc7,0x8cdc,0x96cc,0x98fc,0x6b6f,0x4e8b,0x4f3c,
/* 0x8e98 - 0x8e9f */ 0x4f8d,0x5150,0x5b57,0x5bfa,0x6148,0x6301,0x6642,0x6b21,
/* 0x8ea0 - 0x8ea7 */ 0x6ecb,0x6cbb,0x723e,0x74bd,0x75d4,0x78c1,0x793a,0x800c,
/* 0x8ea8 - 0x8eaf */ 0x8033,0x81ea,0x8494,0x8f9e,0x6c50,0x9e7f,0x5f0f,0x8b58,
/* 0x8eb0 - 0x8eb7 */ 0x9d2b,0x7afa,0x8ef8,0x5b8d,0x96eb,0x4e03,0x53f1,0x57f7,
/* 0x8eb8 - 0x8ebf */ 0x5931,0x5ac9,0x5ba4,0x6089,0x6e7f,0x6f06,0x75be,0x8cea,
/* 0x8ec0 - 0x8ec7 */ 0x5b9f,0x8500,0x7be0,0x5072,0x67f4,0x829d,0x5c61,0x854a,
/* 0x8ec8 - 0x8ecf */ 0x7e1e,0x820e,0x5199,0x5c04,0x6368,0x8d66,0x659c,0x716e,
/* 0x8ed0 - 0x8ed7 */ 0x793e,0x7d17,0x8005,0x8b1d,0x8eca,0x906e,0x86c7,0x90aa,
/* 0x8ed8 - 0x8edf */ 0x501f,0x52fa,0x5c3a,0x6753,0x707c,0x7235,0x914c,0x91c8,
/* 0x8ee0 - 0x8ee7 */ 0x932b,0x82e5,0x5bc2,0x5f31,0x60f9,0x4e3b,0x53d6,0x5b88,
/* 0x8ee8 - 0x8eef */ 0x624b,0x6731,0x6b8a,0x72e9,0x73e0,0x7a2e,0x816b,0x8da3,
/* 0x8ef0 - 0x8ef7 */ 0x9152,0x9996,0x5112,0x53d7,0x546a,0x5bff,0x6388,0x6a39,
/* 0x8ef8 - 0x8eff */ 0x7dac,0x9700,0x56da,0x53ce,0x5468
}, /* 0x8e */

{ /* 0x8f */
/* 0x8f40 - 0x8f47 */ 0x5b97,0x5c31,0x5dde,0x4fee,0x6101,0x62fe,0x6d32,0x79c0,
/* 0x8f48 - 0x8f4f */ 0x79cb,0x7d42,0x7e4d,0x7fd2,0x81ed,0x821f,0x8490,0x8846,
/* 0x8f50 - 0x8f57 */ 0x8972,0x8b90,0x8e74,0x8f2f,0x9031,0x914b,0x916c,0x96c6,
/* 0x8f58 - 0x8f5f */ 0x919c,0x4ec0,0x4f4f,0x5145,0x5341,0x5f93,0x620e,0x67d4,
/* 0x8f60 - 0x8f67 */ 0x6c41,0x6e0b,0x7363,0x7e26,0x91cd,0x9283,0x53d4,0x5919,
/* 0x8f68 - 0x8f6f */ 0x5bbf,0x6dd1,0x795d,0x7e2e,0x7c9b,0x587e,0x719f,0x51fa,
/* 0x8f70 - 0x8f77 */ 0x8853,0x8ff0,0x4fca,0x5cfb,0x6625,0x77ac,0x7ae3,0x821c,
/* 0x8f78 - 0x8f7f */ 0x99ff,0x51c6,0x5faa,0x65ec,0x696f,0x6b89,0x6df3,0x0,
/* 0x8f80 - 0x8f87 */ 0x6e96,0x6f64,0x76fe,0x7d14,0x5de1,0x9075,0x9187,0x9806,
/* 0x8f88 - 0x8f8f */ 0x51e6,0x521d,0x6240,0x6691,0x66d9,0x6e1a,0x5eb6,0x7dd2,
/* 0x8f90 - 0x8f97 */ 0x7f72,0x66f8,0x85af,0x85f7,0x8af8,0x52a9,0x53d9,0x5973,
/* 0x8f98 - 0x8f9f */ 0x5e8f,0x5f90,0x6055,0x92e4,0x9664,0x50b7,0x511f,0x52dd,
/* 0x8fa0 - 0x8fa7 */ 0x5320,0x5347,0x53ec,0x54e8,0x5546,0x5531,0x5617,0x5968,
/* 0x8fa8 - 0x8faf */ 0x59be,0x5a3c,0x5bb5,0x5c06,0x5c0f,0x5c11,0x5c1a,0x5e84,
/* 0x8fb0 - 0x8fb7 */ 0x5e8a,0x5ee0,0x5f70,0x627f,0x6284,0x62db,0x638c,0x6377,
/* 0x8fb8 - 0x8fbf */ 0x6607,0x660c,0x662d,0x6676,0x677e,0x68a2,0x6a1f,0x6a35,
/* 0x8fc0 - 0x8fc7 */ 0x6cbc,0x6d88,0x6e09,0x6e58,0x713c,0x7126,0x7167,0x75c7,
/* 0x8fc8 - 0x8fcf */ 0x7701,0x785d,0x7901,0x7965,0x79f0,0x7ae0,0x7b11,0x7ca7,
/* 0x8fd0 - 0x8fd7 */ 0x7d39,0x8096,0x83d6,0x848b,0x8549,0x885d,0x88f3,0x8a1f,
/* 0x8fd8 - 0x8fdf */ 0x8a3c,0x8a54,0x8a73,0x8c61,0x8cde,0x91a4,0x9266,0x937e,
/* 0x8fe0 - 0x8fe7 */ 0x9418,0x969c,0x9798,0x4e0a,0x4e08,0x4e1e,0x4e57,0x5197,
/* 0x8fe8 - 0x8fef */ 0x5270,0x57ce,0x5834,0x58cc,0x5b22,0x5e38,0x60c5,0x64fe,
/* 0x8ff0 - 0x8ff7 */ 0x6761,0x6756,0x6d44,0x72b6,0x7573,0x7a63,0x84b8,0x8b72,
/* 0x8ff8 - 0x8fff */ 0x91b8,0x9320,0x5631,0x57f4,0x98fe
}, /* 0x8f */

{ /* 0x90 */
/* 0x9040 - 0x9047 */ 0x62ed,0x690d,0x6b96,0x71ed,0x7e54,0x8077,0x8272,0x89e6,
/* 0x9048 - 0x904f */ 0x98df,0x8755,0x8fb1,0x5c3b,0x4f38,0x4fe1,0x4fb5,0x5507,
/* 0x9050 - 0x9057 */ 0x5a20,0x5bdd,0x5be9,0x5fc3,0x614e,0x632f,0x65b0,0x664b,
/* 0x9058 - 0x905f */ 0x68ee,0x699b,0x6d78,0x6df1,0x7533,0x75b9,0x771f,0x795e,
/* 0x9060 - 0x9067 */ 0x79e6,0x7d33,0x81e3,0x82af,0x85aa,0x89aa,0x8a3a,0x8eab,
/* 0x9068 - 0x906f */ 0x8f9b,0x9032,0x91dd,0x9707,0x4eba,0x4ec1,0x5203,0x5875,
/* 0x9070 - 0x9077 */ 0x58ec,0x5c0b,0x751a,0x5c3d,0x814e,0x8a0a,0x8fc5,0x9663,
/* 0x9078 - 0x907f */ 0x976d,0x7b25,0x8acf,0x9808,0x9162,0x56f3,0x53a8,0x0,
/* 0x9080 - 0x9087 */ 0x9017,0x5439,0x5782,0x5e25,0x63a8,0x6c34,0x708a,0x7761,
/* 0x9088 - 0x908f */ 0x7c8b,0x7fe0,0x8870,0x9042,0x9154,0x9310,0x9318,0x968f,
/* 0x9090 - 0x9097 */ 0x745e,0x9ac4,0x5d07,0x5d69,0x6570,0x67a2,0x8da8,0x96db,
/* 0x9098 - 0x909f */ 0x636e,0x6749,0x6919,0x83c5,0x9817,0x96c0,0x88fe,0x6f84,
/* 0x90a0 - 0x90a7 */ 0x647a,0x5bf8,0x4e16,0x702c,0x755d,0x662f,0x51c4,0x5236,
/* 0x90a8 - 0x90af */ 0x52e2,0x59d3,0x5f81,0x6027,0x6210,0x653f,0x6574,0x661f,
/* 0x90b0 - 0x90b7 */ 0x6674,0x68f2,0x6816,0x6b63,0x6e05,0x7272,0x751f,0x76db,
/* 0x90b8 - 0x90bf */ 0x7cbe,0x8056,0x58f0,0x88fd,0x897f,0x8aa0,0x8a93,0x8acb,
/* 0x90c0 - 0x90c7 */ 0x901d,0x9192,0x9752,0x9759,0x6589,0x7a0e,0x8106,0x96bb,
/* 0x90c8 - 0x90cf */ 0x5e2d,0x60dc,0x621a,0x65a5,0x6614,0x6790,0x77f3,0x7a4d,
/* 0x90d0 - 0x90d7 */ 0x7c4d,0x7e3e,0x810a,0x8cac,0x8d64,0x8de1,0x8e5f,0x78a9,
/* 0x90d8 - 0x90df */ 0x5207,0x62d9,0x63a5,0x6442,0x6298,0x8a2d,0x7a83,0x7bc0,
/* 0x90e0 - 0x90e7 */ 0x8aac,0x96ea,0x7d76,0x820c,0x8749,0x4ed9,0x5148,0x5343,
/* 0x90e8 - 0x90ef */ 0x5360,0x5ba3,0x5c02,0x5c16,0x5ddd,0x6226,0x6247,0x64b0,
/* 0x90f0 - 0x90f7 */ 0x6813,0x6834,0x6cc9,0x6d45,0x6d17,0x67d3,0x6f5c,0x714e,
/* 0x90f8 - 0x90ff */ 0x717d,0x65cb,0x7a7f,0x7bad,0x7dda
}, /* 0x90 */

{ /* 0x91 */
/* 0x9140 - 0x9147 */ 0x7e4a,0x7fa8,0x817a,0x821b,0x8239,0x85a6,0x8a6e,0x8cce,
/* 0x9148 - 0x914f */ 0x8df5,0x9078,0x9077,0x92ad,0x9291,0x9583,0x9bae,0x524d,
/* 0x9150 - 0x9157 */ 0x5584,0x6f38,0x7136,0x5168,0x7985,0x7e55,0x81b3,0x7cce,
/* 0x9158 - 0x915f */ 0x564c,0x5851,0x5ca8,0x63aa,0x66fe,0x66fd,0x695a,0x72d9,
/* 0x9160 - 0x9167 */ 0x758f,0x758e,0x790e,0x7956,0x79df,0x7c97,0x7d20,0x7d44,
/* 0x9168 - 0x916f */ 0x8607,0x8a34,0x963b,0x9061,0x9f20,0x50e7,0x5275,0x53cc,
/* 0x9170 - 0x9177 */ 0x53e2,0x5009,0x55aa,0x58ee,0x594f,0x723d,0x5b8b,0x5c64,
/* 0x9178 - 0x917f */ 0x531d,0x60e3,0x60f3,0x635c,0x6383,0x633f,0x63bb,0x0,
/* 0x9180 - 0x9187 */ 0x64cd,0x65e9,0x66f9,0x5de3,0x69cd,0x69fd,0x6f15,0x71e5,
/* 0x9188 - 0x918f */ 0x4e89,0x75e9,0x76f8,0x7a93,0x7cdf,0x7dcf,0x7d9c,0x8061,
/* 0x9190 - 0x9197 */ 0x8349,0x8358,0x846c,0x84bc,0x85fb,0x88c5,0x8d70,0x9001,
/* 0x9198 - 0x919f */ 0x906d,0x9397,0x971c,0x9a12,0x50cf,0x5897,0x618e,0x81d3,
/* 0x91a0 - 0x91a7 */ 0x8535,0x8d08,0x9020,0x4fc3,0x5074,0x5247,0x5373,0x606f,
/* 0x91a8 - 0x91af */ 0x6349,0x675f,0x6e2c,0x8db3,0x901f,0x4fd7,0x5c5e,0x8cca,
/* 0x91b0 - 0x91b7 */ 0x65cf,0x7d9a,0x5352,0x8896,0x5176,0x63c3,0x5b58,0x5b6b,
/* 0x91b8 - 0x91bf */ 0x5c0a,0x640d,0x6751,0x905c,0x4ed6,0x591a,0x592a,0x6c70,
/* 0x91c0 - 0x91c7 */ 0x8a51,0x553e,0x5815,0x59a5,0x60f0,0x6253,0x67c1,0x8235,
/* 0x91c8 - 0x91cf */ 0x6955,0x9640,0x99c4,0x9a28,0x4f53,0x5806,0x5bfe,0x8010,
/* 0x91d0 - 0x91d7 */ 0x5cb1,0x5e2f,0x5f85,0x6020,0x614b,0x6234,0x66ff,0x6cf0,
/* 0x91d8 - 0x91df */ 0x6ede,0x80ce,0x817f,0x82d4,0x888b,0x8cb8,0x9000,0x902e,
/* 0x91e0 - 0x91e7 */ 0x968a,0x9edb,0x9bdb,0x4ee3,0x53f0,0x5927,0x7b2c,0x918d,
/* 0x91e8 - 0x91ef */ 0x984c,0x9df9,0x6edd,0x7027,0x5353,0x5544,0x5b85,0x6258,
/* 0x91f0 - 0x91f7 */ 0x629e,0x62d3,0x6ca2,0x6fef,0x7422,0x8a17,0x9438,0x6fc1,
/* 0x91f8 - 0x91ff */ 0x8afe,0x8338,0x51e7,0x86f8,0x53ea
}, /* 0x91 */

{ /* 0x92 */
/* 0x9240 - 0x9247 */ 0x53e9,0x4f46,0x9054,0x8fb0,0x596a,0x8131,0x5dfd,0x7aea,
/* 0x9248 - 0x924f */ 0x8fbf,0x68da,0x8c37,0x72f8,0x9c48,0x6a3d,0x8ab0,0x4e39,
/* 0x9250 - 0x9257 */ 0x5358,0x5606,0x5766,0x62c5,0x63a2,0x65e6,0x6b4e,0x6de1,
/* 0x9258 - 0x925f */ 0x6e5b,0x70ad,0x77ed,0x7aef,0x7baa,0x7dbb,0x803d,0x80c6,
/* 0x9260 - 0x9267 */ 0x86cb,0x8a95,0x935b,0x56e3,0x58c7,0x5f3e,0x65ad,0x6696,
/* 0x9268 - 0x926f */ 0x6a80,0x6bb5,0x7537,0x8ac7,0x5024,0x77e5,0x5730,0x5f1b,
/* 0x9270 - 0x9277 */ 0x6065,0x667a,0x6c60,0x75f4,0x7a1a,0x7f6e,0x81f4,0x8718,
/* 0x9278 - 0x927f */ 0x9045,0x99b3,0x7bc9,0x755c,0x7af9,0x7b51,0x84c4,0x0,
/* 0x9280 - 0x9287 */ 0x9010,0x79e9,0x7a92,0x8336,0x5ae1,0x7740,0x4e2d,0x4ef2,
/* 0x9288 - 0x928f */ 0x5b99,0x5fe0,0x62bd,0x663c,0x67f1,0x6ce8,0x866b,0x8877,
/* 0x9290 - 0x9297 */ 0x8a3b,0x914e,0x92f3,0x99d0,0x6a17,0x7026,0x732a,0x82e7,
/* 0x9298 - 0x929f */ 0x8457,0x8caf,0x4e01,0x5146,0x51cb,0x558b,0x5bf5,0x5e16,
/* 0x92a0 - 0x92a7 */ 0x5e33,0x5e81,0x5f14,0x5f35,0x5f6b,0x5fb4,0x61f2,0x6311,
/* 0x92a8 - 0x92af */ 0x66a2,0x671d,0x6f6e,0x7252,0x753a,0x773a,0x8074,0x8139,
/* 0x92b0 - 0x92b7 */ 0x8178,0x8776,0x8abf,0x8adc,0x8d85,0x8df3,0x929a,0x9577,
/* 0x92b8 - 0x92bf */ 0x9802,0x9ce5,0x52c5,0x6357,0x76f4,0x6715,0x6c88,0x73cd,
/* 0x92c0 - 0x92c7 */ 0x8cc3,0x93ae,0x9673,0x6d25,0x589c,0x690e,0x69cc,0x8ffd,
/* 0x92c8 - 0x92cf */ 0x939a,0x75db,0x901a,0x585a,0x6802,0x63b4,0x69fb,0x4f43,
/* 0x92d0 - 0x92d7 */ 0x6f2c,0x67d8,0x8fbb,0x8526,0x7db4,0x9354,0x693f,0x6f70,
/* 0x92d8 - 0x92df */ 0x576a,0x58f7,0x5b2c,0x7d2c,0x722a,0x540a,0x91e3,0x9db4,
/* 0x92e0 - 0x92e7 */ 0x4ead,0x4f4e,0x505c,0x5075,0x5243,0x8c9e,0x5448,0x5824,
/* 0x92e8 - 0x92ef */ 0x5b9a,0x5e1d,0x5e95,0x5ead,0x5ef7,0x5f1f,0x608c,0x62b5,
/* 0x92f0 - 0x92f7 */ 0x633a,0x63d0,0x68af,0x6c40,0x7887,0x798e,0x7a0b,0x7de0,
/* 0x92f8 - 0x92ff */ 0x8247,0x8a02,0x8ae6,0x8e44,0x9013
}, /* 0x92 */

{ /* 0x93 */
/* 0x9340 - 0x9347 */ 0x90b8,0x912d,0x91d8,0x9f0e,0x6ce5,0x6458,0x64e2,0x6575,
/* 0x9348 - 0x934f */ 0x6ef4,0x7684,0x7b1b,0x9069,0x93d1,0x6eba,0x54f2,0x5fb9,
/* 0x9350 - 0x9357 */ 0x64a4,0x8f4d,0x8fed,0x9244,0x5178,0x586b,0x5929,0x5c55,
/* 0x9358 - 0x935f */ 0x5e97,0x6dfb,0x7e8f,0x751c,0x8cbc,0x8ee2,0x985b,0x70b9,
/* 0x9360 - 0x9367 */ 0x4f1d,0x6bbf,0x6fb1,0x7530,0x96fb,0x514e,0x5410,0x5835,
/* 0x9368 - 0x936f */ 0x5857,0x59ac,0x5c60,0x5f92,0x6597,0x675c,0x6e21,0x767b,
/* 0x9370 - 0x9377 */ 0x83df,0x8ced,0x9014,0x90fd,0x934d,0x7825,0x783a,0x52aa,
/* 0x9378 - 0x937f */ 0x5ea6,0x571f,0x5974,0x6012,0x5012,0x515a,0x51ac,0x0,
/* 0x9380 - 0x9387 */ 0x51cd,0x5200,0x5510,0x5854,0x5858,0x5957,0x5b95,0x5cf6,
/* 0x9388 - 0x938f */ 0x5d8b,0x60bc,0x6295,0x642d,0x6771,0x6843,0x68bc,0x68df,
/* 0x9390 - 0x9397 */ 0x76d7,0x6dd8,0x6e6f,0x6d9b,0x706f,0x71c8,0x5f53,0x75d8,
/* 0x9398 - 0x939f */ 0x7977,0x7b49,0x7b54,0x7b52,0x7cd6,0x7d71,0x5230,0x8463,
/* 0x93a0 - 0x93a7 */ 0x8569,0x85e4,0x8a0e,0x8b04,0x8c46,0x8e0f,0x9003,0x900f,
/* 0x93a8 - 0x93af */ 0x9419,0x9676,0x982d,0x9a30,0x95d8,0x50cd,0x52d5,0x540c,
/* 0x93b0 - 0x93b7 */ 0x5802,0x5c0e,0x61a7,0x649e,0x6d1e,0x77b3,0x7ae5,0x80f4,
/* 0x93b8 - 0x93bf */ 0x8404,0x9053,0x9285,0x5ce0,0x9d07,0x533f,0x5f97,0x5fb3,
/* 0x93c0 - 0x93c7 */ 0x6d9c,0x7279,0x7763,0x79bf,0x7be4,0x6bd2,0x72ec,0x8aad,
/* 0x93c8 - 0x93cf */ 0x6803,0x6a61,0x51f8,0x7a81,0x6934,0x5c4a,0x9cf6,0x82eb,
/* 0x93d0 - 0x93d7 */ 0x5bc5,0x9149,0x701e,0x5678,0x5c6f,0x60c7,0x6566,0x6c8c,
/* 0x93d8 - 0x93df */ 0x8c5a,0x9041,0x9813,0x5451,0x66c7,0x920d,0x5948,0x90a3,
/* 0x93e0 - 0x93e7 */ 0x5185,0x4e4d,0x51ea,0x8599,0x8b0e,0x7058,0x637a,0x934b,
/* 0x93e8 - 0x93ef */ 0x6962,0x99b4,0x7e04,0x7577,0x5357,0x6960,0x8edf,0x96e3,
/* 0x93f0 - 0x93f7 */ 0x6c5d,0x4e8c,0x5c3c,0x5f10,0x8fe9,0x5302,0x8cd1,0x8089,
/* 0x93f8 - 0x93ff */ 0x8679,0x5eff,0x65e5,0x4e73,0x5165
}, /* 0x93 */

{ /* 0x94 */
/* 0x9440 - 0x9447 */ 0x5982,0x5c3f,0x97ee,0x4efb,0x598a,0x5fcd,0x8a8d,0x6fe1,
/* 0x9448 - 0x944f */ 0x79b0,0x7962,0x5be7,0x8471,0x732b,0x71b1,0x5e74,0x5ff5,
/* 0x9450 - 0x9457 */ 0x637b,0x649a,0x71c3,0x7c98,0x4e43,0x5efc,0x4e4b,0x57dc,
/* 0x9458 - 0x945f */ 0x56a2,0x60a9,0x6fc3,0x7d0d,0x80fd,0x8133,0x81bf,0x8fb2,
/* 0x9460 - 0x9467 */ 0x8997,0x86a4,0x5df4,0x628a,0x64ad,0x8987,0x6777,0x6ce2,
/* 0x9468 - 0x946f */ 0x6d3e,0x7436,0x7834,0x5a46,0x7f75,0x82ad,0x99ac,0x4ff3,
/* 0x9470 - 0x9477 */ 0x5ec3,0x62dd,0x6392,0x6557,0x676f,0x76c3,0x724c,0x80cc,
/* 0x9478 - 0x947f */ 0x80ba,0x8f29,0x914d,0x500d,0x57f9,0x5a92,0x6885,0x0,
/* 0x9480 - 0x9487 */ 0x6973,0x7164,0x72fd,0x8cb7,0x58f2,0x8ce0,0x966a,0x9019,
/* 0x9488 - 0x948f */ 0x877f,0x79e4,0x77e7,0x8429,0x4f2f,0x5265,0x535a,0x62cd,
/* 0x9490 - 0x9497 */ 0x67cf,0x6cca,0x767d,0x7b94,0x7c95,0x8236,0x8584,0x8feb,
/* 0x9498 - 0x949f */ 0x66dd,0x6f20,0x7206,0x7e1b,0x83ab,0x99c1,0x9ea6,0x51fd,
/* 0x94a0 - 0x94a7 */ 0x7bb1,0x7872,0x7bb8,0x8087,0x7b48,0x6ae8,0x5e61,0x808c,
/* 0x94a8 - 0x94af */ 0x7551,0x7560,0x516b,0x9262,0x6e8c,0x767a,0x9197,0x9aea,
/* 0x94b0 - 0x94b7 */ 0x4f10,0x7f70,0x629c,0x7b4f,0x95a5,0x9ce9,0x567a,0x5859,
/* 0x94b8 - 0x94bf */ 0x86e4,0x96bc,0x4f34,0x5224,0x534a,0x53cd,0x53db,0x5e06,
/* 0x94c0 - 0x94c7 */ 0x642c,0x6591,0x677f,0x6c3e,0x6c4e,0x7248,0x72af,0x73ed,
/* 0x94c8 - 0x94cf */ 0x7554,0x7e41,0x822c,0x85e9,0x8ca9,0x7bc4,0x91c6,0x7169,
/* 0x94d0 - 0x94d7 */ 0x9812,0x98ef,0x633d,0x6669,0x756a,0x76e4,0x78d0,0x8543,
/* 0x94d8 - 0x94df */ 0x86ee,0x532a,0x5351,0x5426,0x5983,0x5e87,0x5f7c,0x60b2,
/* 0x94e0 - 0x94e7 */ 0x6249,0x6279,0x62ab,0x6590,0x6bd4,0x6ccc,0x75b2,0x76ae,
/* 0x94e8 - 0x94ef */ 0x7891,0x79d8,0x7dcb,0x7f77,0x80a5,0x88ab,0x8ab9,0x8cbb,
/* 0x94f0 - 0x94f7 */ 0x907f,0x975e,0x98db,0x6a0b,0x7c38,0x5099,0x5c3e,0x5fae,
/* 0x94f8 - 0x94ff */ 0x6787,0x6bd8,0x7435,0x7709,0x7f8e
}, /* 0x94 */

{ /* 0x95 */
/* 0x9540 - 0x9547 */ 0x9f3b,0x67ca,0x7a17,0x5339,0x758b,0x9aed,0x5f66,0x819d,
/* 0x9548 - 0x954f */ 0x83f1,0x8098,0x5f3c,0x5fc5,0x7562,0x7b46,0x903c,0x6867,
/* 0x9550 - 0x9557 */ 0x59eb,0x5a9b,0x7d10,0x767e,0x8b2c,0x4ff5,0x5f6a,0x6a19,
/* 0x9558 - 0x955f */ 0x6c37,0x6f02,0x74e2,0x7968,0x8868,0x8a55,0x8c79,0x5edf,
/* 0x9560 - 0x9567 */ 0x63cf,0x75c5,0x79d2,0x82d7,0x9328,0x92f2,0x849c,0x86ed,
/* 0x9568 - 0x956f */ 0x9c2d,0x54c1,0x5f6c,0x658c,0x6d5c,0x7015,0x8ca7,0x8cd3,
/* 0x9570 - 0x9577 */ 0x983b,0x654f,0x74f6,0x4e0d,0x4ed8,0x57e0,0x592b,0x5a66,
/* 0x9578 - 0x957f */ 0x5bcc,0x51a8,0x5e03,0x5e9c,0x6016,0x6276,0x6577,0x0,
/* 0x9580 - 0x9587 */ 0x65a7,0x666e,0x6d6e,0x7236,0x7b26,0x8150,0x819a,0x8299,
/* 0x9588 - 0x958f */ 0x8b5c,0x8ca0,0x8ce6,0x8d74,0x961c,0x9644,0x4fae,0x64ab,
/* 0x9590 - 0x9597 */ 0x6b66,0x821e,0x8461,0x856a,0x90e8,0x5c01,0x6953,0x98a8,
/* 0x9598 - 0x959f */ 0x847a,0x8557,0x4f0f,0x526f,0x5fa9,0x5e45,0x670d,0x798f,
/* 0x95a0 - 0x95a7 */ 0x8179,0x8907,0x8986,0x6df5,0x5f17,0x6255,0x6cb8,0x4ecf,
/* 0x95a8 - 0x95af */ 0x7269,0x9b92,0x5206,0x543b,0x5674,0x58b3,0x61a4,0x626e,
/* 0x95b0 - 0x95b7 */ 0x711a,0x596e,0x7c89,0x7cde,0x7d1b,0x96f0,0x6587,0x805e,
/* 0x95b8 - 0x95bf */ 0x4e19,0x4f75,0x5175,0x5840,0x5e63,0x5e73,0x5f0a,0x67c4,
/* 0x95c0 - 0x95c7 */ 0x4e26,0x853d,0x9589,0x965b,0x7c73,0x9801,0x50fb,0x58c1,
/* 0x95c8 - 0x95cf */ 0x7656,0x78a7,0x5225,0x77a5,0x8511,0x7b86,0x504f,0x5909,
/* 0x95d0 - 0x95d7 */ 0x7247,0x7bc7,0x7de8,0x8fba,0x8fd4,0x904d,0x4fbf,0x52c9,
/* 0x95d8 - 0x95df */ 0x5a29,0x5f01,0x97ad,0x4fdd,0x8217,0x92ea,0x5703,0x6355,
/* 0x95e0 - 0x95e7 */ 0x6b69,0x752b,0x88dc,0x8f14,0x7a42,0x52df,0x5893,0x6155,
/* 0x95e8 - 0x95ef */ 0x620a,0x66ae,0x6bcd,0x7c3f,0x83e9,0x5023,0x4ff8,0x5305,
/* 0x95f0 - 0x95f7 */ 0x5446,0x5831,0x5949,0x5b9d,0x5cf0,0x5cef,0x5d29,0x5e96,
/* 0x95f8 - 0x95ff */ 0x62b1,0x6367,0x653e,0x65b9,0x670b
}, /* 0x95 */

{ /* 0x96 */
/* 0x9640 - 0x9647 */ 0x6cd5,0x6ce1,0x70f9,0x7832,0x7e2b,0x80de,0x82b3,0x840c,
/* 0x9648 - 0x964f */ 0x84ec,0x8702,0x8912,0x8a2a,0x8c4a,0x90a6,0x92d2,0x98fd,
/* 0x9650 - 0x9657 */ 0x9cf3,0x9d6c,0x4e4f,0x4ea1,0x508d,0x5256,0x574a,0x59a8,
/* 0x9658 - 0x965f */ 0x5e3d,0x5fd8,0x5fd9,0x623f,0x66b4,0x671b,0x67d0,0x68d2,
/* 0x9660 - 0x9667 */ 0x5192,0x7d21,0x80aa,0x81a8,0x8b00,0x8c8c,0x8cbf,0x927e,
/* 0x9668 - 0x966f */ 0x9632,0x5420,0x982c,0x5317,0x50d5,0x535c,0x58a8,0x64b2,
/* 0x9670 - 0x9677 */ 0x6734,0x7267,0x7766,0x7a46,0x91e6,0x52c3,0x6ca1,0x6b86,
/* 0x9678 - 0x967f */ 0x5800,0x5e4c,0x5954,0x672c,0x7ffb,0x51e1,0x76c6,0x0,
/* 0x9680 - 0x9687 */ 0x6469,0x78e8,0x9b54,0x9ebb,0x57cb,0x59b9,0x6627,0x679a,
/* 0x9688 - 0x968f */ 0x6bce,0x54e9,0x69d9,0x5e55,0x819c,0x6795,0x9baa,0x67fe,
/* 0x9690 - 0x9697 */ 0x9c52,0x685d,0x4ea6,0x4fe3,0x53c8,0x62b9,0x672b,0x6cab,
/* 0x9698 - 0x969f */ 0x8fc4,0x4fad,0x7e6d,0x9ebf,0x4e07,0x6162,0x6e80,0x6f2b,
/* 0x96a0 - 0x96a7 */ 0x8513,0x5473,0x672a,0x9b45,0x5df3,0x7b95,0x5cac,0x5bc6,
/* 0x96a8 - 0x96af */ 0x871c,0x6e4a,0x84d1,0x7a14,0x8108,0x5999,0x7c8d,0x6c11,
/* 0x96b0 - 0x96b7 */ 0x7720,0x52d9,0x5922,0x7121,0x725f,0x77db,0x9727,0x9d61,
/* 0x96b8 - 0x96bf */ 0x690b,0x5a7f,0x5a18,0x51a5,0x540d,0x547d,0x660e,0x76df,
/* 0x96c0 - 0x96c7 */ 0x8ff7,0x9298,0x9cf4,0x59ea,0x725d,0x6ec5,0x514d,0x68c9,
/* 0x96c8 - 0x96cf */ 0x7dbf,0x7dec,0x9762,0x9eba,0x6478,0x6a21,0x8302,0x5984,
/* 0x96d0 - 0x96d7 */ 0x5b5f,0x6bdb,0x731b,0x76f2,0x7db2,0x8017,0x8499,0x5132,
/* 0x96d8 - 0x96df */ 0x6728,0x9ed9,0x76ee,0x6762,0x52ff,0x9905,0x5c24,0x623b,
/* 0x96e0 - 0x96e7 */ 0x7c7e,0x8cb0,0x554f,0x60b6,0x7d0b,0x9580,0x5301,0x4e5f,
/* 0x96e8 - 0x96ef */ 0x51b6,0x591c,0x723a,0x8036,0x91ce,0x5f25,0x77e2,0x5384,
/* 0x96f0 - 0x96f7 */ 0x5f79,0x7d04,0x85ac,0x8a33,0x8e8d,0x9756,0x67f3,0x85ae,
/* 0x96f8 - 0x96ff */ 0x9453,0x6109,0x6108,0x6cb9,0x7652
}, /* 0x96 */

{ /* 0x97 */
/* 0x9740 - 0x9747 */ 0x8aed,0x8f38,0x552f,0x4f51,0x512a,0x52c7,0x53cb,0x5ba5,
/* 0x9748 - 0x974f */ 0x5e7d,0x60a0,0x6182,0x63d6,0x6709,0x67da,0x6e67,0x6d8c,
/* 0x9750 - 0x9757 */ 0x7336,0x7337,0x7531,0x7950,0x88d5,0x8a98,0x904a,0x9091,
/* 0x9758 - 0x975f */ 0x90f5,0x96c4,0x878d,0x5915,0x4e88,0x4f59,0x4e0e,0x8a89,
/* 0x9760 - 0x9767 */ 0x8f3f,0x9810,0x50ad,0x5e7c,0x5996,0x5bb9,0x5eb8,0x63da,
/* 0x9768 - 0x976f */ 0x63fa,0x64c1,0x66dc,0x694a,0x69d8,0x6d0b,0x6eb6,0x7194,
/* 0x9770 - 0x9777 */ 0x7528,0x7aaf,0x7f8a,0x8000,0x8449,0x84c9,0x8981,0x8b21,
/* 0x9778 - 0x977f */ 0x8e0a,0x9065,0x967d,0x990a,0x617e,0x6291,0x6b32,0x0,
/* 0x9780 - 0x9787 */ 0x6c83,0x6d74,0x7fcc,0x7ffc,0x6dc0,0x7f85,0x87ba,0x88f8,
/* 0x9788 - 0x978f */ 0x6765,0x83b1,0x983c,0x96f7,0x6d1b,0x7d61,0x843d,0x916a,
/* 0x9790 - 0x9797 */ 0x4e71,0x5375,0x5d50,0x6b04,0x6feb,0x85cd,0x862d,0x89a7,
/* 0x9798 - 0x979f */ 0x5229,0x540f,0x5c65,0x674e,0x68a8,0x7406,0x7483,0x75e2,
/* 0x97a0 - 0x97a7 */ 0x88cf,0x88e1,0x91cc,0x96e2,0x9678,0x5f8b,0x7387,0x7acb,
/* 0x97a8 - 0x97af */ 0x844e,0x63a0,0x7565,0x5289,0x6d41,0x6e9c,0x7409,0x7559,
/* 0x97b0 - 0x97b7 */ 0x786b,0x7c92,0x9686,0x7adc,0x9f8d,0x4fb6,0x616e,0x65c5,
/* 0x97b8 - 0x97bf */ 0x865c,0x4e86,0x4eae,0x50da,0x4e21,0x51cc,0x5bee,0x6599,
/* 0x97c0 - 0x97c7 */ 0x6881,0x6dbc,0x731f,0x7642,0x77ad,0x7a1c,0x7ce7,0x826f,
/* 0x97c8 - 0x97cf */ 0x8ad2,0x907c,0x91cf,0x9675,0x9818,0x529b,0x7dd1,0x502b,
/* 0x97d0 - 0x97d7 */ 0x5398,0x6797,0x6dcb,0x71d0,0x7433,0x81e8,0x8f2a,0x96a3,
/* 0x97d8 - 0x97df */ 0x9c57,0x9e9f,0x7460,0x5841,0x6d99,0x7d2f,0x985e,0x4ee4,
/* 0x97e0 - 0x97e7 */ 0x4f36,0x4f8b,0x51b7,0x52b1,0x5dba,0x601c,0x73b2,0x793c,
/* 0x97e8 - 0x97ef */ 0x82d3,0x9234,0x96b7,0x96f6,0x970a,0x9e97,0x9f62,0x66a6,
/* 0x97f0 - 0x97f7 */ 0x6b74,0x5217,0x52a3,0x70c8,0x88c2,0x5ec9,0x604b,0x6190,
/* 0x97f8 - 0x97ff */ 0x6f23,0x7149,0x7c3e,0x7df4,0x806f
}, /* 0x97 */

{ /* 0x98 */
/* 0x9840 - 0x9847 */ 0x84ee,0x9023,0x932c,0x5442,0x9b6f,0x6ad3,0x7089,0x8cc2,
/* 0x9848 - 0x984f */ 0x8def,0x9732,0x52b4,0x5a41,0x5eca,0x5f04,0x6717,0x697c,
/* 0x9850 - 0x9857 */ 0x6994,0x6d6a,0x6f0f,0x7262,0x72fc,0x7bed,0x8001,0x807e,
/* 0x9858 - 0x985f */ 0x874b,0x90ce,0x516d,0x9e93,0x7984,0x808b,0x9332,0x8ad6,
/* 0x9860 - 0x9867 */ 0x502d,0x548c,0x8a71,0x6b6a,0x8cc4,0x8107,0x60d1,0x67a0,
/* 0x9868 - 0x986f */ 0x9df2,0x4e99,0x4e98,0x9c10,0x8a6b,0x85c1,0x8568,0x6900,
/* 0x9870 - 0x9877 */ 0x6e7e,0x7897,0x8155,0x0,0x0,0x0,0x0,0x0,
/* 0x9878 - 0x987f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9880 - 0x9887 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9888 - 0x988f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9890 - 0x9897 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0x9898 - 0x989f */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5f0c,
/* 0x98a0 - 0x98a7 */ 0x4e10,0x4e15,0x4e2a,0x4e31,0x4e36,0x4e3c,0x4e3f,0x4e42,
/* 0x98a8 - 0x98af */ 0x4e56,0x4e58,0x4e82,0x4e85,0x8c6b,0x4e8a,0x8212,0x5f0d,
/* 0x98b0 - 0x98b7 */ 0x4e8e,0x4e9e,0x4e9f,0x4ea0,0x4ea2,0x4eb0,0x4eb3,0x4eb6,
/* 0x98b8 - 0x98bf */ 0x4ece,0x4ecd,0x4ec4,0x4ec6,0x4ec2,0x4ed7,0x4ede,0x4eed,
/* 0x98c0 - 0x98c7 */ 0x4edf,0x4ef7,0x4f09,0x4f5a,0x4f30,0x4f5b,0x4f5d,0x4f57,
/* 0x98c8 - 0x98cf */ 0x4f47,0x4f76,0x4f88,0x4f8f,0x4f98,0x4f7b,0x4f69,0x4f70,
/* 0x98d0 - 0x98d7 */ 0x4f91,0x4f6f,0x4f86,0x4f96,0x5118,0x4fd4,0x4fdf,0x4fce,
/* 0x98d8 - 0x98df */ 0x4fd8,0x4fdb,0x4fd1,0x4fda,0x4fd0,0x4fe4,0x4fe5,0x501a,
/* 0x98e0 - 0x98e7 */ 0x5028,0x5014,0x502a,0x5025,0x5005,0x4f1c,0x4ff6,0x5021,
/* 0x98e8 - 0x98ef */ 0x5029,0x502c,0x4ffe,0x4fef,0x5011,0x5006,0x5043,0x5047,
/* 0x98f0 - 0x98f7 */ 0x6703,0x5055,0x5050,0x5048,0x505a,0x5056,0x506c,0x5078,
/* 0x98f8 - 0x98ff */ 0x5080,0x509a,0x5085,0x50b4,0x50b2
}, /* 0x98 */

{ /* 0x99 */
/* 0x9940 - 0x9947 */ 0x50c9,0x50ca,0x50b3,0x50c2,0x50d6,0x50de,0x50e5,0x50ed,
/* 0x9948 - 0x994f */ 0x50e3,0x50ee,0x50f9,0x50f5,0x5109,0x5101,0x5102,0x5116,
/* 0x9950 - 0x9957 */ 0x5115,0x5114,0x511a,0x5121,0x513a,0x5137,0x513c,0x513b,
/* 0x9958 - 0x995f */ 0x513f,0x5140,0x5152,0x514c,0x5154,0x5162,0x7af8,0x5169,
/* 0x9960 - 0x9967 */ 0x516a,0x516e,0x5180,0x5182,0x56d8,0x518c,0x5189,0x518f,
/* 0x9968 - 0x996f */ 0x5191,0x5193,0x5195,0x5196,0x51a4,0x51a6,0x51a2,0x51a9,
/* 0x9970 - 0x9977 */ 0x51aa,0x51ab,0x51b3,0x51b1,0x51b2,0x51b0,0x51b5,0x51bd,
/* 0x9978 - 0x997f */ 0x51c5,0x51c9,0x51db,0x51e0,0x8655,0x51e9,0x51ed,0x0,
/* 0x9980 - 0x9987 */ 0x51f0,0x51f5,0x51fe,0x5204,0x520b,0x5214,0x520e,0x5227,
/* 0x9988 - 0x998f */ 0x522a,0x522e,0x5233,0x5239,0x524f,0x5244,0x524b,0x524c,
/* 0x9990 - 0x9997 */ 0x525e,0x5254,0x526a,0x5274,0x5269,0x5273,0x527f,0x527d,
/* 0x9998 - 0x999f */ 0x528d,0x5294,0x5292,0x5271,0x5288,0x5291,0x8fa8,0x8fa7,
/* 0x99a0 - 0x99a7 */ 0x52ac,0x52ad,0x52bc,0x52b5,0x52c1,0x52cd,0x52d7,0x52de,
/* 0x99a8 - 0x99af */ 0x52e3,0x52e6,0x98ed,0x52e0,0x52f3,0x52f5,0x52f8,0x52f9,
/* 0x99b0 - 0x99b7 */ 0x5306,0x5308,0x7538,0x530d,0x5310,0x530f,0x5315,0x531a,
/* 0x99b8 - 0x99bf */ 0x5323,0x532f,0x5331,0x5333,0x5338,0x5340,0x5346,0x5345,
/* 0x99c0 - 0x99c7 */ 0x4e17,0x5349,0x534d,0x51d6,0x535e,0x5369,0x536e,0x5918,
/* 0x99c8 - 0x99cf */ 0x537b,0x5377,0x5382,0x5396,0x53a0,0x53a6,0x53a5,0x53ae,
/* 0x99d0 - 0x99d7 */ 0x53b0,0x53b6,0x53c3,0x7c12,0x96d9,0x53df,0x66fc,0x71ee,
/* 0x99d8 - 0x99df */ 0x53ee,0x53e8,0x53ed,0x53fa,0x5401,0x543d,0x5440,0x542c,
/* 0x99e0 - 0x99e7 */ 0x542d,0x543c,0x542e,0x5436,0x5429,0x541d,0x544e,0x548f,
/* 0x99e8 - 0x99ef */ 0x5475,0x548e,0x545f,0x5471,0x5477,0x5470,0x5492,0x547b,
/* 0x99f0 - 0x99f7 */ 0x5480,0x5476,0x5484,0x5490,0x5486,0x54c7,0x54a2,0x54b8,
/* 0x99f8 - 0x99ff */ 0x54a5,0x54ac,0x54c4,0x54c8,0x54a8
}, /* 0x99 */

{ /* 0x9a */
/* 0x9a40 - 0x9a47 */ 0x54ab,0x54c2,0x54a4,0x54be,0x54bc,0x54d8,0x54e5,0x54e6,
/* 0x9a48 - 0x9a4f */ 0x550f,0x5514,0x54fd,0x54ee,0x54ed,0x54fa,0x54e2,0x5539,
/* 0x9a50 - 0x9a57 */ 0x5540,0x5563,0x554c,0x552e,0x555c,0x5545,0x5556,0x5557,
/* 0x9a58 - 0x9a5f */ 0x5538,0x5533,0x555d,0x5599,0x5580,0x54af,0x558a,0x559f,
/* 0x9a60 - 0x9a67 */ 0x557b,0x557e,0x5598,0x559e,0x55ae,0x557c,0x5583,0x55a9,
/* 0x9a68 - 0x9a6f */ 0x5587,0x55a8,0x55da,0x55c5,0x55df,0x55c4,0x55dc,0x55e4,
/* 0x9a70 - 0x9a77 */ 0x55d4,0x5614,0x55f7,0x5616,0x55fe,0x55fd,0x561b,0x55f9,
/* 0x9a78 - 0x9a7f */ 0x564e,0x5650,0x71df,0x5634,0x5636,0x5632,0x5638,0x0,
/* 0x9a80 - 0x9a87 */ 0x566b,0x5664,0x562f,0x566c,0x566a,0x5686,0x5680,0x568a,
/* 0x9a88 - 0x9a8f */ 0x56a0,0x5694,0x568f,0x56a5,0x56ae,0x56b6,0x56b4,0x56c2,
/* 0x9a90 - 0x9a97 */ 0x56bc,0x56c1,0x56c3,0x56c0,0x56c8,0x56ce,0x56d1,0x56d3,
/* 0x9a98 - 0x9a9f */ 0x56d7,0x56ee,0x56f9,0x5700,0x56ff,0x5704,0x5709,0x5708,
/* 0x9aa0 - 0x9aa7 */ 0x570b,0x570d,0x5713,0x5718,0x5716,0x55c7,0x571c,0x5726,
/* 0x9aa8 - 0x9aaf */ 0x5737,0x5738,0x574e,0x573b,0x5740,0x574f,0x5769,0x57c0,
/* 0x9ab0 - 0x9ab7 */ 0x5788,0x5761,0x577f,0x5789,0x5793,0x57a0,0x57b3,0x57a4,
/* 0x9ab8 - 0x9abf */ 0x57aa,0x57b0,0x57c3,0x57c6,0x57d4,0x57d2,0x57d3,0x580a,
/* 0x9ac0 - 0x9ac7 */ 0x57d6,0x57e3,0x580b,0x5819,0x581d,0x5872,0x5821,0x5862,
/* 0x9ac8 - 0x9acf */ 0x584b,0x5870,0x6bc0,0x5852,0x583d,0x5879,0x5885,0x58b9,
/* 0x9ad0 - 0x9ad7 */ 0x589f,0x58ab,0x58ba,0x58de,0x58bb,0x58b8,0x58ae,0x58c5,
/* 0x9ad8 - 0x9adf */ 0x58d3,0x58d1,0x58d7,0x58d9,0x58d8,0x58e5,0x58dc,0x58e4,
/* 0x9ae0 - 0x9ae7 */ 0x58df,0x58ef,0x58fa,0x58f9,0x58fb,0x58fc,0x58fd,0x5902,
/* 0x9ae8 - 0x9aef */ 0x590a,0x5910,0x591b,0x68a6,0x5925,0x592c,0x592d,0x5932,
/* 0x9af0 - 0x9af7 */ 0x5938,0x593e,0x7ad2,0x5955,0x5950,0x594e,0x595a,0x5958,
/* 0x9af8 - 0x9aff */ 0x5962,0x5960,0x5967,0x596c,0x5969
}, /* 0x9a */

{ /* 0x9b */
/* 0x9b40 - 0x9b47 */ 0x5978,0x5981,0x599d,0x4f5e,0x4fab,0x59a3,0x59b2,0x59c6,
/* 0x9b48 - 0x9b4f */ 0x59e8,0x59dc,0x598d,0x59d9,0x59da,0x5a25,0x5a1f,0x5a11,
/* 0x9b50 - 0x9b57 */ 0x5a1c,0x5a09,0x5a1a,0x5a40,0x5a6c,0x5a49,0x5a35,0x5a36,
/* 0x9b58 - 0x9b5f */ 0x5a62,0x5a6a,0x5a9a,0x5abc,0x5abe,0x5acb,0x5ac2,0x5abd,
/* 0x9b60 - 0x9b67 */ 0x5ae3,0x5ad7,0x5ae6,0x5ae9,0x5ad6,0x5afa,0x5afb,0x5b0c,
/* 0x9b68 - 0x9b6f */ 0x5b0b,0x5b16,0x5b32,0x5ad0,0x5b2a,0x5b36,0x5b3e,0x5b43,
/* 0x9b70 - 0x9b77 */ 0x5b45,0x5b40,0x5b51,0x5b55,0x5b5a,0x5b5b,0x5b65,0x5b69,
/* 0x9b78 - 0x9b7f */ 0x5b70,0x5b73,0x5b75,0x5b78,0x6588,0x5b7a,0x5b80,0x0,
/* 0x9b80 - 0x9b87 */ 0x5b83,0x5ba6,0x5bb8,0x5bc3,0x5bc7,0x5bc9,0x5bd4,0x5bd0,
/* 0x9b88 - 0x9b8f */ 0x5be4,0x5be6,0x5be2,0x5bde,0x5be5,0x5beb,0x5bf0,0x5bf6,
/* 0x9b90 - 0x9b97 */ 0x5bf3,0x5c05,0x5c07,0x5c08,0x5c0d,0x5c13,0x5c20,0x5c22,
/* 0x9b98 - 0x9b9f */ 0x5c28,0x5c38,0x5c39,0x5c41,0x5c46,0x5c4e,0x5c53,0x5c50,
/* 0x9ba0 - 0x9ba7 */ 0x5c4f,0x5b71,0x5c6c,0x5c6e,0x4e62,0x5c76,0x5c79,0x5c8c,
/* 0x9ba8 - 0x9baf */ 0x5c91,0x5c94,0x599b,0x5cab,0x5cbb,0x5cb6,0x5cbc,0x5cb7,
/* 0x9bb0 - 0x9bb7 */ 0x5cc5,0x5cbe,0x5cc7,0x5cd9,0x5ce9,0x5cfd,0x5cfa,0x5ced,
/* 0x9bb8 - 0x9bbf */ 0x5d8c,0x5cea,0x5d0b,0x5d15,0x5d17,0x5d5c,0x5d1f,0x5d1b,
/* 0x9bc0 - 0x9bc7 */ 0x5d11,0x5d14,0x5d22,0x5d1a,0x5d19,0x5d18,0x5d4c,0x5d52,
/* 0x9bc8 - 0x9bcf */ 0x5d4e,0x5d4b,0x5d6c,0x5d73,0x5d76,0x5d87,0x5d84,0x5d82,
/* 0x9bd0 - 0x9bd7 */ 0x5da2,0x5d9d,0x5dac,0x5dae,0x5dbd,0x5d90,0x5db7,0x5dbc,
/* 0x9bd8 - 0x9bdf */ 0x5dc9,0x5dcd,0x5dd3,0x5dd2,0x5dd6,0x5ddb,0x5deb,0x5df2,
/* 0x9be0 - 0x9be7 */ 0x5df5,0x5e0b,0x5e1a,0x5e19,0x5e11,0x5e1b,0x5e36,0x5e37,
/* 0x9be8 - 0x9bef */ 0x5e44,0x5e43,0x5e40,0x5e4e,0x5e57,0x5e54,0x5e5f,0x5e62,
/* 0x9bf0 - 0x9bf7 */ 0x5e64,0x5e47,0x5e75,0x5e76,0x5e7a,0x9ebc,0x5e7f,0x5ea0,
/* 0x9bf8 - 0x9bff */ 0x5ec1,0x5ec2,0x5ec8,0x5ed0,0x5ecf
}, /* 0x9b */

{ /* 0x9c */
/* 0x9c40 - 0x9c47 */ 0x5ed6,0x5ee3,0x5edd,0x5eda,0x5edb,0x5ee2,0x5ee1,0x5ee8,
/* 0x9c48 - 0x9c4f */ 0x5ee9,0x5eec,0x5ef1,0x5ef3,0x5ef0,0x5ef4,0x5ef8,0x5efe,
/* 0x9c50 - 0x9c57 */ 0x5f03,0x5f09,0x5f5d,0x5f5c,0x5f0b,0x5f11,0x5f16,0x5f29,
/* 0x9c58 - 0x9c5f */ 0x5f2d,0x5f38,0x5f41,0x5f48,0x5f4c,0x5f4e,0x5f2f,0x5f51,
/* 0x9c60 - 0x9c67 */ 0x5f56,0x5f57,0x5f59,0x5f61,0x5f6d,0x5f73,0x5f77,0x5f83,
/* 0x9c68 - 0x9c6f */ 0x5f82,0x5f7f,0x5f8a,0x5f88,0x5f91,0x5f87,0x5f9e,0x5f99,
/* 0x9c70 - 0x9c77 */ 0x5f98,0x5fa0,0x5fa8,0x5fad,0x5fbc,0x5fd6,0x5ffb,0x5fe4,
/* 0x9c78 - 0x9c7f */ 0x5ff8,0x5ff1,0x5fdd,0x60b3,0x5fff,0x6021,0x6060,0x0,
/* 0x9c80 - 0x9c87 */ 0x6019,0x6010,0x6029,0x600e,0x6031,0x601b,0x6015,0x602b,
/* 0x9c88 - 0x9c8f */ 0x6026,0x600f,0x603a,0x605a,0x6041,0x606a,0x6077,0x605f,
/* 0x9c90 - 0x9c97 */ 0x604a,0x6046,0x604d,0x6063,0x6043,0x6064,0x6042,0x606c,
/* 0x9c98 - 0x9c9f */ 0x606b,0x6059,0x6081,0x608d,0x60e7,0x6083,0x609a,0x6084,
/* 0x9ca0 - 0x9ca7 */ 0x609b,0x6096,0x6097,0x6092,0x60a7,0x608b,0x60e1,0x60b8,
/* 0x9ca8 - 0x9caf */ 0x60e0,0x60d3,0x60b4,0x5ff0,0x60bd,0x60c6,0x60b5,0x60d8,
/* 0x9cb0 - 0x9cb7 */ 0x614d,0x6115,0x6106,0x60f6,0x60f7,0x6100,0x60f4,0x60fa,
/* 0x9cb8 - 0x9cbf */ 0x6103,0x6121,0x60fb,0x60f1,0x610d,0x610e,0x6147,0x613e,
/* 0x9cc0 - 0x9cc7 */ 0x6128,0x6127,0x614a,0x613f,0x613c,0x612c,0x6134,0x613d,
/* 0x9cc8 - 0x9ccf */ 0x6142,0x6144,0x6173,0x6177,0x6158,0x6159,0x615a,0x616b,
/* 0x9cd0 - 0x9cd7 */ 0x6174,0x616f,0x6165,0x6171,0x615f,0x615d,0x6153,0x6175,
/* 0x9cd8 - 0x9cdf */ 0x6199,0x6196,0x6187,0x61ac,0x6194,0x619a,0x618a,0x6191,
/* 0x9ce0 - 0x9ce7 */ 0x61ab,0x61ae,0x61cc,0x61ca,0x61c9,0x61f7,0x61c8,0x61c3,
/* 0x9ce8 - 0x9cef */ 0x61c6,0x61ba,0x61cb,0x7f79,0x61cd,0x61e6,0x61e3,0x61f6,
/* 0x9cf0 - 0x9cf7 */ 0x61fa,0x61f4,0x61ff,0x61fd,0x61fc,0x61fe,0x6200,0x6208,
/* 0x9cf8 - 0x9cff */ 0x6209,0x620d,0x620c,0x6214,0x621b
}, /* 0x9c */

{ /* 0x9d */
/* 0x9d40 - 0x9d47 */ 0x621e,0x6221,0x622a,0x622e,0x6230,0x6232,0x6233,0x6241,
/* 0x9d48 - 0x9d4f */ 0x624e,0x625e,0x6263,0x625b,0x6260,0x6268,0x627c,0x6282,
/* 0x9d50 - 0x9d57 */ 0x6289,0x627e,0x6292,0x6293,0x6296,0x62d4,0x6283,0x6294,
/* 0x9d58 - 0x9d5f */ 0x62d7,0x62d1,0x62bb,0x62cf,0x62ff,0x62c6,0x64d4,0x62c8,
/* 0x9d60 - 0x9d67 */ 0x62dc,0x62cc,0x62ca,0x62c2,0x62c7,0x629b,0x62c9,0x630c,
/* 0x9d68 - 0x9d6f */ 0x62ee,0x62f1,0x6327,0x6302,0x6308,0x62ef,0x62f5,0x6350,
/* 0x9d70 - 0x9d77 */ 0x633e,0x634d,0x641c,0x634f,0x6396,0x638e,0x6380,0x63ab,
/* 0x9d78 - 0x9d7f */ 0x6376,0x63a3,0x638f,0x6389,0x639f,0x63b5,0x636b,0x0,
/* 0x9d80 - 0x9d87 */ 0x6369,0x63be,0x63e9,0x63c0,0x63c6,0x63e3,0x63c9,0x63d2,
/* 0x9d88 - 0x9d8f */ 0x63f6,0x63c4,0x6416,0x6434,0x6406,0x6413,0x6426,0x6436,
/* 0x9d90 - 0x9d97 */ 0x651d,0x6417,0x6428,0x640f,0x6467,0x646f,0x6476,0x644e,
/* 0x9d98 - 0x9d9f */ 0x652a,0x6495,0x6493,0x64a5,0x64a9,0x6488,0x64bc,0x64da,
/* 0x9da0 - 0x9da7 */ 0x64d2,0x64c5,0x64c7,0x64bb,0x64d8,0x64c2,0x64f1,0x64e7,
/* 0x9da8 - 0x9daf */ 0x8209,0x64e0,0x64e1,0x62ac,0x64e3,0x64ef,0x652c,0x64f6,
/* 0x9db0 - 0x9db7 */ 0x64f4,0x64f2,0x64fa,0x6500,0x64fd,0x6518,0x651c,0x6505,
/* 0x9db8 - 0x9dbf */ 0x6524,0x6523,0x652b,0x6534,0x6535,0x6537,0x6536,0x6538,
/* 0x9dc0 - 0x9dc7 */ 0x754b,0x6548,0x6556,0x6555,0x654d,0x6558,0x655e,0x655d,
/* 0x9dc8 - 0x9dcf */ 0x6572,0x6578,0x6582,0x6583,0x8b8a,0x659b,0x659f,0x65ab,
/* 0x9dd0 - 0x9dd7 */ 0x65b7,0x65c3,0x65c6,0x65c1,0x65c4,0x65cc,0x65d2,0x65db,
/* 0x9dd8 - 0x9ddf */ 0x65d9,0x65e0,0x65e1,0x65f1,0x6772,0x660a,0x6603,0x65fb,
/* 0x9de0 - 0x9de7 */ 0x6773,0x6635,0x6636,0x6634,0x661c,0x664f,0x6644,0x6649,
/* 0x9de8 - 0x9def */ 0x6641,0x665e,0x665d,0x6664,0x6667,0x6668,0x665f,0x6662,
/* 0x9df0 - 0x9df7 */ 0x6670,0x6683,0x6688,0x668e,0x6689,0x6684,0x6698,0x669d,
/* 0x9df8 - 0x9dff */ 0x66c1,0x66b9,0x66c9,0x66be,0x66bc
}, /* 0x9d */

{ /* 0x9e */
/* 0x9e40 - 0x9e47 */ 0x66c4,0x66b8,0x66d6,0x66da,0x66e0,0x663f,0x66e6,0x66e9,
/* 0x9e48 - 0x9e4f */ 0x66f0,0x66f5,0x66f7,0x670f,0x6716,0x671e,0x6726,0x6727,
/* 0x9e50 - 0x9e57 */ 0x9738,0x672e,0x673f,0x6736,0x6741,0x6738,0x6737,0x6746,
/* 0x9e58 - 0x9e5f */ 0x675e,0x6760,0x6759,0x6763,0x6764,0x6789,0x6770,0x67a9,
/* 0x9e60 - 0x9e67 */ 0x677c,0x676a,0x678c,0x678b,0x67a6,0x67a1,0x6785,0x67b7,
/* 0x9e68 - 0x9e6f */ 0x67ef,0x67b4,0x67ec,0x67b3,0x67e9,0x67b8,0x67e4,0x67de,
/* 0x9e70 - 0x9e77 */ 0x67dd,0x67e2,0x67ee,0x67b9,0x67ce,0x67c6,0x67e7,0x6a9c,
/* 0x9e78 - 0x9e7f */ 0x681e,0x6846,0x6829,0x6840,0x684d,0x6832,0x684e,0x0,
/* 0x9e80 - 0x9e87 */ 0x68b3,0x682b,0x6859,0x6863,0x6877,0x687f,0x689f,0x688f,
/* 0x9e88 - 0x9e8f */ 0x68ad,0x6894,0x689d,0x689b,0x6883,0x6aae,0x68b9,0x6874,
/* 0x9e90 - 0x9e97 */ 0x68b5,0x68a0,0x68ba,0x690f,0x688d,0x687e,0x6901,0x68ca,
/* 0x9e98 - 0x9e9f */ 0x6908,0x68d8,0x6922,0x6926,0x68e1,0x690c,0x68cd,0x68d4,
/* 0x9ea0 - 0x9ea7 */ 0x68e7,0x68d5,0x6936,0x6912,0x6904,0x68d7,0x68e3,0x6925,
/* 0x9ea8 - 0x9eaf */ 0x68f9,0x68e0,0x68ef,0x6928,0x692a,0x691a,0x6923,0x6921,
/* 0x9eb0 - 0x9eb7 */ 0x68c6,0x6979,0x6977,0x695c,0x6978,0x696b,0x6954,0x697e,
/* 0x9eb8 - 0x9ebf */ 0x696e,0x6939,0x6974,0x693d,0x6959,0x6930,0x6961,0x695e,
/* 0x9ec0 - 0x9ec7 */ 0x695d,0x6981,0x696a,0x69b2,0x69ae,0x69d0,0x69bf,0x69c1,
/* 0x9ec8 - 0x9ecf */ 0x69d3,0x69be,0x69ce,0x5be8,0x69ca,0x69dd,0x69bb,0x69c3,
/* 0x9ed0 - 0x9ed7 */ 0x69a7,0x6a2e,0x6991,0x69a0,0x699c,0x6995,0x69b4,0x69de,
/* 0x9ed8 - 0x9edf */ 0x69e8,0x6a02,0x6a1b,0x69ff,0x6b0a,0x69f9,0x69f2,0x69e7,
/* 0x9ee0 - 0x9ee7 */ 0x6a05,0x69b1,0x6a1e,0x69ed,0x6a14,0x69eb,0x6a0a,0x6a12,
/* 0x9ee8 - 0x9eef */ 0x6ac1,0x6a23,0x6a13,0x6a44,0x6a0c,0x6a72,0x6a36,0x6a78,
/* 0x9ef0 - 0x9ef7 */ 0x6a47,0x6a62,0x6a59,0x6a66,0x6a48,0x6a38,0x6a22,0x6a90,
/* 0x9ef8 - 0x9eff */ 0x6a8d,0x6aa0,0x6a84,0x6aa2,0x6aa3
}, /* 0x9e */

{ /* 0x9f */
/* 0x9f40 - 0x9f47 */ 0x6a97,0x8617,0x6abb,0x6ac3,0x6ac2,0x6ab8,0x6ab3,0x6aac,
/* 0x9f48 - 0x9f4f */ 0x6ade,0x6ad1,0x6adf,0x6aaa,0x6ada,0x6aea,0x6afb,0x6b05,
/* 0x9f50 - 0x9f57 */ 0x8616,0x6afa,0x6b12,0x6b16,0x9b31,0x6b1f,0x6b38,0x6b37,
/* 0x9f58 - 0x9f5f */ 0x76dc,0x6b39,0x98ee,0x6b47,0x6b43,0x6b49,0x6b50,0x6b59,
/* 0x9f60 - 0x9f67 */ 0x6b54,0x6b5b,0x6b5f,0x6b61,0x6b78,0x6b79,0x6b7f,0x6b80,
/* 0x9f68 - 0x9f6f */ 0x6b84,0x6b83,0x6b8d,0x6b98,0x6b95,0x6b9e,0x6ba4,0x6baa,
/* 0x9f70 - 0x9f77 */ 0x6bab,0x6baf,0x6bb2,0x6bb1,0x6bb3,0x6bb7,0x6bbc,0x6bc6,
/* 0x9f78 - 0x9f7f */ 0x6bcb,0x6bd3,0x6bdf,0x6bec,0x6beb,0x6bf3,0x6bef,0x0,
/* 0x9f80 - 0x9f87 */ 0x9ebe,0x6c08,0x6c13,0x6c14,0x6c1b,0x6c24,0x6c23,0x6c5e,
/* 0x9f88 - 0x9f8f */ 0x6c55,0x6c62,0x6c6a,0x6c82,0x6c8d,0x6c9a,0x6c81,0x6c9b,
/* 0x9f90 - 0x9f97 */ 0x6c7e,0x6c68,0x6c73,0x6c92,0x6c90,0x6cc4,0x6cf1,0x6cd3,
/* 0x9f98 - 0x9f9f */ 0x6cbd,0x6cd7,0x6cc5,0x6cdd,0x6cae,0x6cb1,0x6cbe,0x6cba,
/* 0x9fa0 - 0x9fa7 */ 0x6cdb,0x6cef,0x6cd9,0x6cea,0x6d1f,0x884d,0x6d36,0x6d2b,
/* 0x9fa8 - 0x9faf */ 0x6d3d,0x6d38,0x6d19,0x6d35,0x6d33,0x6d12,0x6d0c,0x6d63,
/* 0x9fb0 - 0x9fb7 */ 0x6d93,0x6d64,0x6d5a,0x6d79,0x6d59,0x6d8e,0x6d95,0x6fe4,
/* 0x9fb8 - 0x9fbf */ 0x6d85,0x6df9,0x6e15,0x6e0a,0x6db5,0x6dc7,0x6de6,0x6db8,
/* 0x9fc0 - 0x9fc7 */ 0x6dc6,0x6dec,0x6dde,0x6dcc,0x6de8,0x6dd2,0x6dc5,0x6dfa,
/* 0x9fc8 - 0x9fcf */ 0x6dd9,0x6de4,0x6dd5,0x6dea,0x6dee,0x6e2d,0x6e6e,0x6e2e,
/* 0x9fd0 - 0x9fd7 */ 0x6e19,0x6e72,0x6e5f,0x6e3e,0x6e23,0x6e6b,0x6e2b,0x6e76,
/* 0x9fd8 - 0x9fdf */ 0x6e4d,0x6e1f,0x6e43,0x6e3a,0x6e4e,0x6e24,0x6eff,0x6e1d,
/* 0x9fe0 - 0x9fe7 */ 0x6e38,0x6e82,0x6eaa,0x6e98,0x6ec9,0x6eb7,0x6ed3,0x6ebd,
/* 0x9fe8 - 0x9fef */ 0x6eaf,0x6ec4,0x6eb2,0x6ed4,0x6ed5,0x6e8f,0x6ea5,0x6ec2,
/* 0x9ff0 - 0x9ff7 */ 0x6e9f,0x6f41,0x6f11,0x704c,0x6eec,0x6ef8,0x6efe,0x6f3f,
/* 0x9ff8 - 0x9fff */ 0x6ef2,0x6f31,0x6eef,0x6f32,0x6ecc
} /* 0x9f */

}, //////////////////////////////////////// DBCS_Table1

{ //////////////////////////////////////// DBCS_Table2

{ /* 0xe0 */
/* 0xe040 - 0xe047 */ 0x6f3e,0x6f13,0x6ef7,0x6f86,0x6f7a,0x6f78,0x6f81,0x6f80,
/* 0xe048 - 0xe04f */ 0x6f6f,0x6f5b,0x6ff3,0x6f6d,0x6f82,0x6f7c,0x6f58,0x6f8e,
/* 0xe050 - 0xe057 */ 0x6f91,0x6fc2,0x6f66,0x6fb3,0x6fa3,0x6fa1,0x6fa4,0x6fb9,
/* 0xe058 - 0xe05f */ 0x6fc6,0x6faa,0x6fdf,0x6fd5,0x6fec,0x6fd4,0x6fd8,0x6ff1,
/* 0xe060 - 0xe067 */ 0x6fee,0x6fdb,0x7009,0x700b,0x6ffa,0x7011,0x7001,0x700f,
/* 0xe068 - 0xe06f */ 0x6ffe,0x701b,0x701a,0x6f74,0x701d,0x7018,0x701f,0x7030,
/* 0xe070 - 0xe077 */ 0x703e,0x7032,0x7051,0x7063,0x7099,0x7092,0x70af,0x70f1,
/* 0xe078 - 0xe07f */ 0x70ac,0x70b8,0x70b3,0x70ae,0x70df,0x70cb,0x70dd,0x0,
/* 0xe080 - 0xe087 */ 0x70d9,0x7109,0x70fd,0x711c,0x7119,0x7165,0x7155,0x7188,
/* 0xe088 - 0xe08f */ 0x7166,0x7162,0x714c,0x7156,0x716c,0x718f,0x71fb,0x7184,
/* 0xe090 - 0xe097 */ 0x7195,0x71a8,0x71ac,0x71d7,0x71b9,0x71be,0x71d2,0x71c9,
/* 0xe098 - 0xe09f */ 0x71d4,0x71ce,0x71e0,0x71ec,0x71e7,0x71f5,0x71fc,0x71f9,
/* 0xe0a0 - 0xe0a7 */ 0x71ff,0x720d,0x7210,0x721b,0x7228,0x722d,0x722c,0x7230,
/* 0xe0a8 - 0xe0af */ 0x7232,0x723b,0x723c,0x723f,0x7240,0x7246,0x724b,0x7258,
/* 0xe0b0 - 0xe0b7 */ 0x7274,0x727e,0x7282,0x7281,0x7287,0x7292,0x7296,0x72a2,
/* 0xe0b8 - 0xe0bf */ 0x72a7,0x72b9,0x72b2,0x72c3,0x72c6,0x72c4,0x72ce,0x72d2,
/* 0xe0c0 - 0xe0c7 */ 0x72e2,0x72e0,0x72e1,0x72f9,0x72f7,0x500f,0x7317,0x730a,
/* 0xe0c8 - 0xe0cf */ 0x731c,0x7316,0x731d,0x7334,0x732f,0x7329,0x7325,0x733e,
/* 0xe0d0 - 0xe0d7 */ 0x734e,0x734f,0x9ed8,0x7357,0x736a,0x7368,0x7370,0x7378,
/* 0xe0d8 - 0xe0df */ 0x7375,0x737b,0x737a,0x73c8,0x73b3,0x73ce,0x73bb,0x73c0,
/* 0xe0e0 - 0xe0e7 */ 0x73e5,0x73ee,0x73de,0x74a2,0x7405,0x746f,0x7425,0x73f8,
/* 0xe0e8 - 0xe0ef */ 0x7432,0x743a,0x7455,0x743f,0x745f,0x7459,0x7441,0x745c,
/* 0xe0f0 - 0xe0f7 */ 0x7469,0x7470,0x7463,0x746a,0x7476,0x747e,0x748b,0x749e,
/* 0xe0f8 - 0xe0ff */ 0x74a7,0x74ca,0x74cf,0x74d4,0x73f1
}, /* 0xe0 */

{ /* 0xe1 */
/* 0xe140 - 0xe147 */ 0x74e0,0x74e3,0x74e7,0x74e9,0x74ee,0x74f2,0x74f0,0x74f1,
/* 0xe148 - 0xe14f */ 0x74f8,0x74f7,0x7504,0x7503,0x7505,0x750c,0x750e,0x750d,
/* 0xe150 - 0xe157 */ 0x7515,0x7513,0x751e,0x7526,0x752c,0x753c,0x7544,0x754d,
/* 0xe158 - 0xe15f */ 0x754a,0x7549,0x755b,0x7546,0x755a,0x7569,0x7564,0x7567,
/* 0xe160 - 0xe167 */ 0x756b,0x756d,0x7578,0x7576,0x7586,0x7587,0x7574,0x758a,
/* 0xe168 - 0xe16f */ 0x7589,0x7582,0x7594,0x759a,0x759d,0x75a5,0x75a3,0x75c2,
/* 0xe170 - 0xe177 */ 0x75b3,0x75c3,0x75b5,0x75bd,0x75b8,0x75bc,0x75b1,0x75cd,
/* 0xe178 - 0xe17f */ 0x75ca,0x75d2,0x75d9,0x75e3,0x75de,0x75fe,0x75ff,0x0,
/* 0xe180 - 0xe187 */ 0x75fc,0x7601,0x75f0,0x75fa,0x75f2,0x75f3,0x760b,0x760d,
/* 0xe188 - 0xe18f */ 0x7609,0x761f,0x7627,0x7620,0x7621,0x7622,0x7624,0x7634,
/* 0xe190 - 0xe197 */ 0x7630,0x763b,0x7647,0x7648,0x7646,0x765c,0x7658,0x7661,
/* 0xe198 - 0xe19f */ 0x7662,0x7668,0x7669,0x766a,0x7667,0x766c,0x7670,0x7672,
/* 0xe1a0 - 0xe1a7 */ 0x7676,0x7678,0x767c,0x7680,0x7683,0x7688,0x768b,0x768e,
/* 0xe1a8 - 0xe1af */ 0x7696,0x7693,0x7699,0x769a,0x76b0,0x76b4,0x76b8,0x76b9,
/* 0xe1b0 - 0xe1b7 */ 0x76ba,0x76c2,0x76cd,0x76d6,0x76d2,0x76de,0x76e1,0x76e5,
/* 0xe1b8 - 0xe1bf */ 0x76e7,0x76ea,0x862f,0x76fb,0x7708,0x7707,0x7704,0x7729,
/* 0xe1c0 - 0xe1c7 */ 0x7724,0x771e,0x7725,0x7726,0x771b,0x7737,0x7738,0x7747,
/* 0xe1c8 - 0xe1cf */ 0x775a,0x7768,0x776b,0x775b,0x7765,0x777f,0x777e,0x7779,
/* 0xe1d0 - 0xe1d7 */ 0x778e,0x778b,0x7791,0x77a0,0x779e,0x77b0,0x77b6,0x77b9,
/* 0xe1d8 - 0xe1df */ 0x77bf,0x77bc,0x77bd,0x77bb,0x77c7,0x77cd,0x77d7,0x77da,
/* 0xe1e0 - 0xe1e7 */ 0x77dc,0x77e3,0x77ee,0x77fc,0x780c,0x7812,0x7926,0x7820,
/* 0xe1e8 - 0xe1ef */ 0x792a,0x7845,0x788e,0x7874,0x7886,0x787c,0x789a,0x788c,
/* 0xe1f0 - 0xe1f7 */ 0x78a3,0x78b5,0x78aa,0x78af,0x78d1,0x78c6,0x78cb,0x78d4,
/* 0xe1f8 - 0xe1ff */ 0x78be,0x78bc,0x78c5,0x78ca,0x78ec
}, /* 0xe1 */

{ /* 0xe2 */
/* 0xe240 - 0xe247 */ 0x78e7,0x78da,0x78fd,0x78f4,0x7907,0x7912,0x7911,0x7919,
/* 0xe248 - 0xe24f */ 0x792c,0x792b,0x7940,0x7960,0x7957,0x795f,0x795a,0x7955,
/* 0xe250 - 0xe257 */ 0x7953,0x797a,0x797f,0x798a,0x799d,0x79a7,0x9f4b,0x79aa,
/* 0xe258 - 0xe25f */ 0x79ae,0x79b3,0x79b9,0x79ba,0x79c9,0x79d5,0x79e7,0x79ec,
/* 0xe260 - 0xe267 */ 0x79e1,0x79e3,0x7a08,0x7a0d,0x7a18,0x7a19,0x7a20,0x7a1f,
/* 0xe268 - 0xe26f */ 0x7980,0x7a31,0x7a3b,0x7a3e,0x7a37,0x7a43,0x7a57,0x7a49,
/* 0xe270 - 0xe277 */ 0x7a61,0x7a62,0x7a69,0x9f9d,0x7a70,0x7a79,0x7a7d,0x7a88,
/* 0xe278 - 0xe27f */ 0x7a97,0x7a95,0x7a98,0x7a96,0x7aa9,0x7ac8,0x7ab0,0x0,
/* 0xe280 - 0xe287 */ 0x7ab6,0x7ac5,0x7ac4,0x7abf,0x9083,0x7ac7,0x7aca,0x7acd,
/* 0xe288 - 0xe28f */ 0x7acf,0x7ad5,0x7ad3,0x7ad9,0x7ada,0x7add,0x7ae1,0x7ae2,
/* 0xe290 - 0xe297 */ 0x7ae6,0x7aed,0x7af0,0x7b02,0x7b0f,0x7b0a,0x7b06,0x7b33,
/* 0xe298 - 0xe29f */ 0x7b18,0x7b19,0x7b1e,0x7b35,0x7b28,0x7b36,0x7b50,0x7b7a,
/* 0xe2a0 - 0xe2a7 */ 0x7b04,0x7b4d,0x7b0b,0x7b4c,0x7b45,0x7b75,0x7b65,0x7b74,
/* 0xe2a8 - 0xe2af */ 0x7b67,0x7b70,0x7b71,0x7b6c,0x7b6e,0x7b9d,0x7b98,0x7b9f,
/* 0xe2b0 - 0xe2b7 */ 0x7b8d,0x7b9c,0x7b9a,0x7b8b,0x7b92,0x7b8f,0x7b5d,0x7b99,
/* 0xe2b8 - 0xe2bf */ 0x7bcb,0x7bc1,0x7bcc,0x7bcf,0x7bb4,0x7bc6,0x7bdd,0x7be9,
/* 0xe2c0 - 0xe2c7 */ 0x7c11,0x7c14,0x7be6,0x7be5,0x7c60,0x7c00,0x7c07,0x7c13,
/* 0xe2c8 - 0xe2cf */ 0x7bf3,0x7bf7,0x7c17,0x7c0d,0x7bf6,0x7c23,0x7c27,0x7c2a,
/* 0xe2d0 - 0xe2d7 */ 0x7c1f,0x7c37,0x7c2b,0x7c3d,0x7c4c,0x7c43,0x7c54,0x7c4f,
/* 0xe2d8 - 0xe2df */ 0x7c40,0x7c50,0x7c58,0x7c5f,0x7c64,0x7c56,0x7c65,0x7c6c,
/* 0xe2e0 - 0xe2e7 */ 0x7c75,0x7c83,0x7c90,0x7ca4,0x7cad,0x7ca2,0x7cab,0x7ca1,
/* 0xe2e8 - 0xe2ef */ 0x7ca8,0x7cb3,0x7cb2,0x7cb1,0x7cae,0x7cb9,0x7cbd,0x7cc0,
/* 0xe2f0 - 0xe2f7 */ 0x7cc5,0x7cc2,0x7cd8,0x7cd2,0x7cdc,0x7ce2,0x9b3b,0x7cef,
/* 0xe2f8 - 0xe2ff */ 0x7cf2,0x7cf4,0x7cf6,0x7cfa,0x7d06
}, /* 0xe2 */

{ /* 0xe3 */
/* 0xe340 - 0xe347 */ 0x7d02,0x7d1c,0x7d15,0x7d0a,0x7d45,0x7d4b,0x7d2e,0x7d32,
/* 0xe348 - 0xe34f */ 0x7d3f,0x7d35,0x7d46,0x7d73,0x7d56,0x7d4e,0x7d72,0x7d68,
/* 0xe350 - 0xe357 */ 0x7d6e,0x7d4f,0x7d63,0x7d93,0x7d89,0x7d5b,0x7d8f,0x7d7d,
/* 0xe358 - 0xe35f */ 0x7d9b,0x7dba,0x7dae,0x7da3,0x7db5,0x7dc7,0x7dbd,0x7dab,
/* 0xe360 - 0xe367 */ 0x7e3d,0x7da2,0x7daf,0x7ddc,0x7db8,0x7d9f,0x7db0,0x7dd8,
/* 0xe368 - 0xe36f */ 0x7ddd,0x7de4,0x7dde,0x7dfb,0x7df2,0x7de1,0x7e05,0x7e0a,
/* 0xe370 - 0xe377 */ 0x7e23,0x7e21,0x7e12,0x7e31,0x7e1f,0x7e09,0x7e0b,0x7e22,
/* 0xe378 - 0xe37f */ 0x7e46,0x7e66,0x7e3b,0x7e35,0x7e39,0x7e43,0x7e37,0x0,
/* 0xe380 - 0xe387 */ 0x7e32,0x7e3a,0x7e67,0x7e5d,0x7e56,0x7e5e,0x7e59,0x7e5a,
/* 0xe388 - 0xe38f */ 0x7e79,0x7e6a,0x7e69,0x7e7c,0x7e7b,0x7e83,0x7dd5,0x7e7d,
/* 0xe390 - 0xe397 */ 0x8fae,0x7e7f,0x7e88,0x7e89,0x7e8c,0x7e92,0x7e90,0x7e93,
/* 0xe398 - 0xe39f */ 0x7e94,0x7e96,0x7e8e,0x7e9b,0x7e9c,0x7f38,0x7f3a,0x7f45,
/* 0xe3a0 - 0xe3a7 */ 0x7f4c,0x7f4d,0x7f4e,0x7f50,0x7f51,0x7f55,0x7f54,0x7f58,
/* 0xe3a8 - 0xe3af */ 0x7f5f,0x7f60,0x7f68,0x7f69,0x7f67,0x7f78,0x7f82,0x7f86,
/* 0xe3b0 - 0xe3b7 */ 0x7f83,0x7f88,0x7f87,0x7f8c,0x7f94,0x7f9e,0x7f9d,0x7f9a,
/* 0xe3b8 - 0xe3bf */ 0x7fa3,0x7faf,0x7fb2,0x7fb9,0x7fae,0x7fb6,0x7fb8,0x8b71,
/* 0xe3c0 - 0xe3c7 */ 0x7fc5,0x7fc6,0x7fca,0x7fd5,0x7fd4,0x7fe1,0x7fe6,0x7fe9,
/* 0xe3c8 - 0xe3cf */ 0x7ff3,0x7ff9,0x98dc,0x8006,0x8004,0x800b,0x8012,0x8018,
/* 0xe3d0 - 0xe3d7 */ 0x8019,0x801c,0x8021,0x8028,0x803f,0x803b,0x804a,0x8046,
/* 0xe3d8 - 0xe3df */ 0x8052,0x8058,0x805a,0x805f,0x8062,0x8068,0x8073,0x8072,
/* 0xe3e0 - 0xe3e7 */ 0x8070,0x8076,0x8079,0x807d,0x807f,0x8084,0x8086,0x8085,
/* 0xe3e8 - 0xe3ef */ 0x809b,0x8093,0x809a,0x80ad,0x5190,0x80ac,0x80db,0x80e5,
/* 0xe3f0 - 0xe3f7 */ 0x80d9,0x80dd,0x80c4,0x80da,0x80d6,0x8109,0x80ef,0x80f1,
/* 0xe3f8 - 0xe3ff */ 0x811b,0x8129,0x8123,0x812f,0x814b
}, /* 0xe3 */

{ /* 0xe4 */
/* 0xe440 - 0xe447 */ 0x968b,0x8146,0x813e,0x8153,0x8151,0x80fc,0x8171,0x816e,
/* 0xe448 - 0xe44f */ 0x8165,0x8166,0x8174,0x8183,0x8188,0x818a,0x8180,0x8182,
/* 0xe450 - 0xe457 */ 0x81a0,0x8195,0x81a4,0x81a3,0x815f,0x8193,0x81a9,0x81b0,
/* 0xe458 - 0xe45f */ 0x81b5,0x81be,0x81b8,0x81bd,0x81c0,0x81c2,0x81ba,0x81c9,
/* 0xe460 - 0xe467 */ 0x81cd,0x81d1,0x81d9,0x81d8,0x81c8,0x81da,0x81df,0x81e0,
/* 0xe468 - 0xe46f */ 0x81e7,0x81fa,0x81fb,0x81fe,0x8201,0x8202,0x8205,0x8207,
/* 0xe470 - 0xe477 */ 0x820a,0x820d,0x8210,0x8216,0x8229,0x822b,0x8238,0x8233,
/* 0xe478 - 0xe47f */ 0x8240,0x8259,0x8258,0x825d,0x825a,0x825f,0x8264,0x0,
/* 0xe480 - 0xe487 */ 0x8262,0x8268,0x826a,0x826b,0x822e,0x8271,0x8277,0x8278,
/* 0xe488 - 0xe48f */ 0x827e,0x828d,0x8292,0x82ab,0x829f,0x82bb,0x82ac,0x82e1,
/* 0xe490 - 0xe497 */ 0x82e3,0x82df,0x82d2,0x82f4,0x82f3,0x82fa,0x8393,0x8303,
/* 0xe498 - 0xe49f */ 0x82fb,0x82f9,0x82de,0x8306,0x82dc,0x8309,0x82d9,0x8335,
/* 0xe4a0 - 0xe4a7 */ 0x8334,0x8316,0x8332,0x8331,0x8340,0x8339,0x8350,0x8345,
/* 0xe4a8 - 0xe4af */ 0x832f,0x832b,0x8317,0x8318,0x8385,0x839a,0x83aa,0x839f,
/* 0xe4b0 - 0xe4b7 */ 0x83a2,0x8396,0x8323,0x838e,0x8387,0x838a,0x837c,0x83b5,
/* 0xe4b8 - 0xe4bf */ 0x8373,0x8375,0x83a0,0x8389,0x83a8,0x83f4,0x8413,0x83eb,
/* 0xe4c0 - 0xe4c7 */ 0x83ce,0x83fd,0x8403,0x83d8,0x840b,0x83c1,0x83f7,0x8407,
/* 0xe4c8 - 0xe4cf */ 0x83e0,0x83f2,0x840d,0x8422,0x8420,0x83bd,0x8438,0x8506,
/* 0xe4d0 - 0xe4d7 */ 0x83fb,0x846d,0x842a,0x843c,0x855a,0x8484,0x8477,0x846b,
/* 0xe4d8 - 0xe4df */ 0x84ad,0x846e,0x8482,0x8469,0x8446,0x842c,0x846f,0x8479,
/* 0xe4e0 - 0xe4e7 */ 0x8435,0x84ca,0x8462,0x84b9,0x84bf,0x849f,0x84d9,0x84cd,
/* 0xe4e8 - 0xe4ef */ 0x84bb,0x84da,0x84d0,0x84c1,0x84c6,0x84d6,0x84a1,0x8521,
/* 0xe4f0 - 0xe4f7 */ 0x84ff,0x84f4,0x8517,0x8518,0x852c,0x851f,0x8515,0x8514,
/* 0xe4f8 - 0xe4ff */ 0x84fc,0x8540,0x8563,0x8558,0x8548
}, /* 0xe4 */

{ /* 0xe5 */
/* 0xe540 - 0xe547 */ 0x8541,0x8602,0x854b,0x8555,0x8580,0x85a4,0x8588,0x8591,
/* 0xe548 - 0xe54f */ 0x858a,0x85a8,0x856d,0x8594,0x859b,0x85ea,0x8587,0x859c,
/* 0xe550 - 0xe557 */ 0x8577,0x857e,0x8590,0x85c9,0x85ba,0x85cf,0x85b9,0x85d0,
/* 0xe558 - 0xe55f */ 0x85d5,0x85dd,0x85e5,0x85dc,0x85f9,0x860a,0x8613,0x860b,
/* 0xe560 - 0xe567 */ 0x85fe,0x85fa,0x8606,0x8622,0x861a,0x8630,0x863f,0x864d,
/* 0xe568 - 0xe56f */ 0x4e55,0x8654,0x865f,0x8667,0x8671,0x8693,0x86a3,0x86a9,
/* 0xe570 - 0xe577 */ 0x86aa,0x868b,0x868c,0x86b6,0x86af,0x86c4,0x86c6,0x86b0,
/* 0xe578 - 0xe57f */ 0x86c9,0x8823,0x86ab,0x86d4,0x86de,0x86e9,0x86ec,0x0,
/* 0xe580 - 0xe587 */ 0x86df,0x86db,0x86ef,0x8712,0x8706,0x8708,0x8700,0x8703,
/* 0xe588 - 0xe58f */ 0x86fb,0x8711,0x8709,0x870d,0x86f9,0x870a,0x8734,0x873f,
/* 0xe590 - 0xe597 */ 0x8737,0x873b,0x8725,0x8729,0x871a,0x8760,0x875f,0x8778,
/* 0xe598 - 0xe59f */ 0x874c,0x874e,0x8774,0x8757,0x8768,0x876e,0x8759,0x8753,
/* 0xe5a0 - 0xe5a7 */ 0x8763,0x876a,0x8805,0x87a2,0x879f,0x8782,0x87af,0x87cb,
/* 0xe5a8 - 0xe5af */ 0x87bd,0x87c0,0x87d0,0x96d6,0x87ab,0x87c4,0x87b3,0x87c7,
/* 0xe5b0 - 0xe5b7 */ 0x87c6,0x87bb,0x87ef,0x87f2,0x87e0,0x880f,0x880d,0x87fe,
/* 0xe5b8 - 0xe5bf */ 0x87f6,0x87f7,0x880e,0x87d2,0x8811,0x8816,0x8815,0x8822,
/* 0xe5c0 - 0xe5c7 */ 0x8821,0x8831,0x8836,0x8839,0x8827,0x883b,0x8844,0x8842,
/* 0xe5c8 - 0xe5cf */ 0x8852,0x8859,0x885e,0x8862,0x886b,0x8881,0x887e,0x889e,
/* 0xe5d0 - 0xe5d7 */ 0x8875,0x887d,0x88b5,0x8872,0x8882,0x8897,0x8892,0x88ae,
/* 0xe5d8 - 0xe5df */ 0x8899,0x88a2,0x888d,0x88a4,0x88b0,0x88bf,0x88b1,0x88c3,
/* 0xe5e0 - 0xe5e7 */ 0x88c4,0x88d4,0x88d8,0x88d9,0x88dd,0x88f9,0x8902,0x88fc,
/* 0xe5e8 - 0xe5ef */ 0x88f4,0x88e8,0x88f2,0x8904,0x890c,0x890a,0x8913,0x8943,
/* 0xe5f0 - 0xe5f7 */ 0x891e,0x8925,0x892a,0x892b,0x8941,0x8944,0x893b,0x8936,
/* 0xe5f8 - 0xe5ff */ 0x8938,0x894c,0x891d,0x8960,0x895e
}, /* 0xe5 */

{ /* 0xe6 */
/* 0xe640 - 0xe647 */ 0x8966,0x8964,0x896d,0x896a,0x896f,0x8974,0x8977,0x897e,
/* 0xe648 - 0xe64f */ 0x8983,0x8988,0x898a,0x8993,0x8998,0x89a1,0x89a9,0x89a6,
/* 0xe650 - 0xe657 */ 0x89ac,0x89af,0x89b2,0x89ba,0x89bd,0x89bf,0x89c0,0x89da,
/* 0xe658 - 0xe65f */ 0x89dc,0x89dd,0x89e7,0x89f4,0x89f8,0x8a03,0x8a16,0x8a10,
/* 0xe660 - 0xe667 */ 0x8a0c,0x8a1b,0x8a1d,0x8a25,0x8a36,0x8a41,0x8a5b,0x8a52,
/* 0xe668 - 0xe66f */ 0x8a46,0x8a48,0x8a7c,0x8a6d,0x8a6c,0x8a62,0x8a85,0x8a82,
/* 0xe670 - 0xe677 */ 0x8a84,0x8aa8,0x8aa1,0x8a91,0x8aa5,0x8aa6,0x8a9a,0x8aa3,
/* 0xe678 - 0xe67f */ 0x8ac4,0x8acd,0x8ac2,0x8ada,0x8aeb,0x8af3,0x8ae7,0x0,
/* 0xe680 - 0xe687 */ 0x8ae4,0x8af1,0x8b14,0x8ae0,0x8ae2,0x8af7,0x8ade,0x8adb,
/* 0xe688 - 0xe68f */ 0x8b0c,0x8b07,0x8b1a,0x8ae1,0x8b16,0x8b10,0x8b17,0x8b20,
/* 0xe690 - 0xe697 */ 0x8b33,0x97ab,0x8b26,0x8b2b,0x8b3e,0x8b28,0x8b41,0x8b4c,
/* 0xe698 - 0xe69f */ 0x8b4f,0x8b4e,0x8b49,0x8b56,0x8b5b,0x8b5a,0x8b6b,0x8b5f,
/* 0xe6a0 - 0xe6a7 */ 0x8b6c,0x8b6f,0x8b74,0x8b7d,0x8b80,0x8b8c,0x8b8e,0x8b92,
/* 0xe6a8 - 0xe6af */ 0x8b93,0x8b96,0x8b99,0x8b9a,0x8c3a,0x8c41,0x8c3f,0x8c48,
/* 0xe6b0 - 0xe6b7 */ 0x8c4c,0x8c4e,0x8c50,0x8c55,0x8c62,0x8c6c,0x8c78,0x8c7a,
/* 0xe6b8 - 0xe6bf */ 0x8c82,0x8c89,0x8c85,0x8c8a,0x8c8d,0x8c8e,0x8c94,0x8c7c,
/* 0xe6c0 - 0xe6c7 */ 0x8c98,0x621d,0x8cad,0x8caa,0x8cbd,0x8cb2,0x8cb3,0x8cae,
/* 0xe6c8 - 0xe6cf */ 0x8cb6,0x8cc8,0x8cc1,0x8ce4,0x8ce3,0x8cda,0x8cfd,0x8cfa,
/* 0xe6d0 - 0xe6d7 */ 0x8cfb,0x8d04,0x8d05,0x8d0a,0x8d07,0x8d0f,0x8d0d,0x8d10,
/* 0xe6d8 - 0xe6df */ 0x9f4e,0x8d13,0x8ccd,0x8d14,0x8d16,0x8d67,0x8d6d,0x8d71,
/* 0xe6e0 - 0xe6e7 */ 0x8d73,0x8d81,0x8d99,0x8dc2,0x8dbe,0x8dba,0x8dcf,0x8dda,
/* 0xe6e8 - 0xe6ef */ 0x8dd6,0x8dcc,0x8ddb,0x8dcb,0x8dea,0x8deb,0x8ddf,0x8de3,
/* 0xe6f0 - 0xe6f7 */ 0x8dfc,0x8e08,0x8e09,0x8dff,0x8e1d,0x8e1e,0x8e10,0x8e1f,
/* 0xe6f8 - 0xe6ff */ 0x8e42,0x8e35,0x8e30,0x8e34,0x8e4a
}, /* 0xe6 */

{ /* 0xe7 */
/* 0xe740 - 0xe747 */ 0x8e47,0x8e49,0x8e4c,0x8e50,0x8e48,0x8e59,0x8e64,0x8e60,
/* 0xe748 - 0xe74f */ 0x8e2a,0x8e63,0x8e55,0x8e76,0x8e72,0x8e7c,0x8e81,0x8e87,
/* 0xe750 - 0xe757 */ 0x8e85,0x8e84,0x8e8b,0x8e8a,0x8e93,0x8e91,0x8e94,0x8e99,
/* 0xe758 - 0xe75f */ 0x8eaa,0x8ea1,0x8eac,0x8eb0,0x8ec6,0x8eb1,0x8ebe,0x8ec5,
/* 0xe760 - 0xe767 */ 0x8ec8,0x8ecb,0x8edb,0x8ee3,0x8efc,0x8efb,0x8eeb,0x8efe,
/* 0xe768 - 0xe76f */ 0x8f0a,0x8f05,0x8f15,0x8f12,0x8f19,0x8f13,0x8f1c,0x8f1f,
/* 0xe770 - 0xe777 */ 0x8f1b,0x8f0c,0x8f26,0x8f33,0x8f3b,0x8f39,0x8f45,0x8f42,
/* 0xe778 - 0xe77f */ 0x8f3e,0x8f4c,0x8f49,0x8f46,0x8f4e,0x8f57,0x8f5c,0x0,
/* 0xe780 - 0xe787 */ 0x8f62,0x8f63,0x8f64,0x8f9c,0x8f9f,0x8fa3,0x8fad,0x8faf,
/* 0xe788 - 0xe78f */ 0x8fb7,0x8fda,0x8fe5,0x8fe2,0x8fea,0x8fef,0x9087,0x8ff4,
/* 0xe790 - 0xe797 */ 0x9005,0x8ff9,0x8ffa,0x9011,0x9015,0x9021,0x900d,0x901e,
/* 0xe798 - 0xe79f */ 0x9016,0x900b,0x9027,0x9036,0x9035,0x9039,0x8ff8,0x904f,
/* 0xe7a0 - 0xe7a7 */ 0x9050,0x9051,0x9052,0x900e,0x9049,0x903e,0x9056,0x9058,
/* 0xe7a8 - 0xe7af */ 0x905e,0x9068,0x906f,0x9076,0x96a8,0x9072,0x9082,0x907d,
/* 0xe7b0 - 0xe7b7 */ 0x9081,0x9080,0x908a,0x9089,0x908f,0x90a8,0x90af,0x90b1,
/* 0xe7b8 - 0xe7bf */ 0x90b5,0x90e2,0x90e4,0x6248,0x90db,0x9102,0x9112,0x9119,
/* 0xe7c0 - 0xe7c7 */ 0x9132,0x9130,0x914a,0x9156,0x9158,0x9163,0x9165,0x9169,
/* 0xe7c8 - 0xe7cf */ 0x9173,0x9172,0x918b,0x9189,0x9182,0x91a2,0x91ab,0x91af,
/* 0xe7d0 - 0xe7d7 */ 0x91aa,0x91b5,0x91b4,0x91ba,0x91c0,0x91c1,0x91c9,0x91cb,
/* 0xe7d8 - 0xe7df */ 0x91d0,0x91d6,0x91df,0x91e1,0x91db,0x91fc,0x91f5,0x91f6,
/* 0xe7e0 - 0xe7e7 */ 0x921e,0x91ff,0x9214,0x922c,0x9215,0x9211,0x925e,0x9257,
/* 0xe7e8 - 0xe7ef */ 0x9245,0x9249,0x9264,0x9248,0x9295,0x923f,0x924b,0x9250,
/* 0xe7f0 - 0xe7f7 */ 0x929c,0x9296,0x9293,0x929b,0x925a,0x92cf,0x92b9,0x92b7,
/* 0xe7f8 - 0xe7ff */ 0x92e9,0x930f,0x92fa,0x9344,0x932e
}, /* 0xe7 */

{ /* 0xe8 */
/* 0xe840 - 0xe847 */ 0x9319,0x9322,0x931a,0x9323,0x933a,0x9335,0x933b,0x935c,
/* 0xe848 - 0xe84f */ 0x9360,0x937c,0x936e,0x9356,0x93b0,0x93ac,0x93ad,0x9394,
/* 0xe850 - 0xe857 */ 0x93b9,0x93d6,0x93d7,0x93e8,0x93e5,0x93d8,0x93c3,0x93dd,
/* 0xe858 - 0xe85f */ 0x93d0,0x93c8,0x93e4,0x941a,0x9414,0x9413,0x9403,0x9407,
/* 0xe860 - 0xe867 */ 0x9410,0x9436,0x942b,0x9435,0x9421,0x943a,0x9441,0x9452,
/* 0xe868 - 0xe86f */ 0x9444,0x945b,0x9460,0x9462,0x945e,0x946a,0x9229,0x9470,
/* 0xe870 - 0xe877 */ 0x9475,0x9477,0x947d,0x945a,0x947c,0x947e,0x9481,0x947f,
/* 0xe878 - 0xe87f */ 0x9582,0x9587,0x958a,0x9594,0x9596,0x9598,0x9599,0x0,
/* 0xe880 - 0xe887 */ 0x95a0,0x95a8,0x95a7,0x95ad,0x95bc,0x95bb,0x95b9,0x95be,
/* 0xe888 - 0xe88f */ 0x95ca,0x6ff6,0x95c3,0x95cd,0x95cc,0x95d5,0x95d4,0x95d6,
/* 0xe890 - 0xe897 */ 0x95dc,0x95e1,0x95e5,0x95e2,0x9621,0x9628,0x962e,0x962f,
/* 0xe898 - 0xe89f */ 0x9642,0x964c,0x964f,0x964b,0x9677,0x965c,0x965e,0x965d,
/* 0xe8a0 - 0xe8a7 */ 0x965f,0x9666,0x9672,0x966c,0x968d,0x9698,0x9695,0x9697,
/* 0xe8a8 - 0xe8af */ 0x96aa,0x96a7,0x96b1,0x96b2,0x96b0,0x96b4,0x96b6,0x96b8,
/* 0xe8b0 - 0xe8b7 */ 0x96b9,0x96ce,0x96cb,0x96c9,0x96cd,0x894d,0x96dc,0x970d,
/* 0xe8b8 - 0xe8bf */ 0x96d5,0x96f9,0x9704,0x9706,0x9708,0x9713,0x970e,0x9711,
/* 0xe8c0 - 0xe8c7 */ 0x970f,0x9716,0x9719,0x9724,0x972a,0x9730,0x9739,0x973d,
/* 0xe8c8 - 0xe8cf */ 0x973e,0x9744,0x9746,0x9748,0x9742,0x9749,0x975c,0x9760,
/* 0xe8d0 - 0xe8d7 */ 0x9764,0x9766,0x9768,0x52d2,0x976b,0x9771,0x9779,0x9785,
/* 0xe8d8 - 0xe8df */ 0x977c,0x9781,0x977a,0x9786,0x978b,0x978f,0x9790,0x979c,
/* 0xe8e0 - 0xe8e7 */ 0x97a8,0x97a6,0x97a3,0x97b3,0x97b4,0x97c3,0x97c6,0x97c8,
/* 0xe8e8 - 0xe8ef */ 0x97cb,0x97dc,0x97ed,0x9f4f,0x97f2,0x7adf,0x97f6,0x97f5,
/* 0xe8f0 - 0xe8f7 */ 0x980f,0x980c,0x9838,0x9824,0x9821,0x9837,0x983d,0x9846,
/* 0xe8f8 - 0xe8ff */ 0x984f,0x984b,0x986b,0x986f,0x9870
}, /* 0xe8 */

{ /* 0xe9 */
/* 0xe940 - 0xe947 */ 0x9871,0x9874,0x9873,0x98aa,0x98af,0x98b1,0x98b6,0x98c4,
/* 0xe948 - 0xe94f */ 0x98c3,0x98c6,0x98e9,0x98eb,0x9903,0x9909,0x9912,0x9914,
/* 0xe950 - 0xe957 */ 0x9918,0x9921,0x991d,0x991e,0x9924,0x9920,0x992c,0x992e,
/* 0xe958 - 0xe95f */ 0x993d,0x993e,0x9942,0x9949,0x9945,0x9950,0x994b,0x9951,
/* 0xe960 - 0xe967 */ 0x9952,0x994c,0x9955,0x9997,0x9998,0x99a5,0x99ad,0x99ae,
/* 0xe968 - 0xe96f */ 0x99bc,0x99df,0x99db,0x99dd,0x99d8,0x99d1,0x99ed,0x99ee,
/* 0xe970 - 0xe977 */ 0x99f1,0x99f2,0x99fb,0x99f8,0x9a01,0x9a0f,0x9a05,0x99e2,
/* 0xe978 - 0xe97f */ 0x9a19,0x9a2b,0x9a37,0x9a45,0x9a42,0x9a40,0x9a43,0x0,
/* 0xe980 - 0xe987 */ 0x9a3e,0x9a55,0x9a4d,0x9a5b,0x9a57,0x9a5f,0x9a62,0x9a65,
/* 0xe988 - 0xe98f */ 0x9a64,0x9a69,0x9a6b,0x9a6a,0x9aad,0x9ab0,0x9abc,0x9ac0,
/* 0xe990 - 0xe997 */ 0x9acf,0x9ad1,0x9ad3,0x9ad4,0x9ade,0x9adf,0x9ae2,0x9ae3,
/* 0xe998 - 0xe99f */ 0x9ae6,0x9aef,0x9aeb,0x9aee,0x9af4,0x9af1,0x9af7,0x9afb,
/* 0xe9a0 - 0xe9a7 */ 0x9b06,0x9b18,0x9b1a,0x9b1f,0x9b22,0x9b23,0x9b25,0x9b27,
/* 0xe9a8 - 0xe9af */ 0x9b28,0x9b29,0x9b2a,0x9b2e,0x9b2f,0x9b32,0x9b44,0x9b43,
/* 0xe9b0 - 0xe9b7 */ 0x9b4f,0x9b4d,0x9b4e,0x9b51,0x9b58,0x9b74,0x9b93,0x9b83,
/* 0xe9b8 - 0xe9bf */ 0x9b91,0x9b96,0x9b97,0x9b9f,0x9ba0,0x9ba8,0x9bb4,0x9bc0,
/* 0xe9c0 - 0xe9c7 */ 0x9bca,0x9bb9,0x9bc6,0x9bcf,0x9bd1,0x9bd2,0x9be3,0x9be2,
/* 0xe9c8 - 0xe9cf */ 0x9be4,0x9bd4,0x9be1,0x9c3a,0x9bf2,0x9bf1,0x9bf0,0x9c15,
/* 0xe9d0 - 0xe9d7 */ 0x9c14,0x9c09,0x9c13,0x9c0c,0x9c06,0x9c08,0x9c12,0x9c0a,
/* 0xe9d8 - 0xe9df */ 0x9c04,0x9c2e,0x9c1b,0x9c25,0x9c24,0x9c21,0x9c30,0x9c47,
/* 0xe9e0 - 0xe9e7 */ 0x9c32,0x9c46,0x9c3e,0x9c5a,0x9c60,0x9c67,0x9c76,0x9c78,
/* 0xe9e8 - 0xe9ef */ 0x9ce7,0x9cec,0x9cf0,0x9d09,0x9d08,0x9ceb,0x9d03,0x9d06,
/* 0xe9f0 - 0xe9f7 */ 0x9d2a,0x9d26,0x9daf,0x9d23,0x9d1f,0x9d44,0x9d15,0x9d12,
/* 0xe9f8 - 0xe9ff */ 0x9d41,0x9d3f,0x9d3e,0x9d46,0x9d48
}, /* 0xe9 */

{ /* 0xea */
/* 0xea40 - 0xea47 */ 0x9d5d,0x9d5e,0x9d64,0x9d51,0x9d50,0x9d59,0x9d72,0x9d89,
/* 0xea48 - 0xea4f */ 0x9d87,0x9dab,0x9d6f,0x9d7a,0x9d9a,0x9da4,0x9da9,0x9db2,
/* 0xea50 - 0xea57 */ 0x9dc4,0x9dc1,0x9dbb,0x9db8,0x9dba,0x9dc6,0x9dcf,0x9dc2,
/* 0xea58 - 0xea5f */ 0x9dd9,0x9dd3,0x9df8,0x9de6,0x9ded,0x9def,0x9dfd,0x9e1a,
/* 0xea60 - 0xea67 */ 0x9e1b,0x9e1e,0x9e75,0x9e79,0x9e7d,0x9e81,0x9e88,0x9e8b,
/* 0xea68 - 0xea6f */ 0x9e8c,0x9e92,0x9e95,0x9e91,0x9e9d,0x9ea5,0x9ea9,0x9eb8,
/* 0xea70 - 0xea77 */ 0x9eaa,0x9ead,0x9761,0x9ecc,0x9ece,0x9ecf,0x9ed0,0x9ed4,
/* 0xea78 - 0xea7f */ 0x9edc,0x9ede,0x9edd,0x9ee0,0x9ee5,0x9ee8,0x9eef,0x0,
/* 0xea80 - 0xea87 */ 0x9ef4,0x9ef6,0x9ef7,0x9ef9,0x9efb,0x9efc,0x9efd,0x9f07,
/* 0xea88 - 0xea8f */ 0x9f08,0x76b7,0x9f15,0x9f21,0x9f2c,0x9f3e,0x9f4a,0x9f52,
/* 0xea90 - 0xea97 */ 0x9f54,0x9f63,0x9f5f,0x9f60,0x9f61,0x9f66,0x9f67,0x9f6c,
/* 0xea98 - 0xea9f */ 0x9f6a,0x9f77,0x9f72,0x9f76,0x9f95,0x9f9c,0x9fa0,0x582f,
/* 0xeaa0 - 0xeaa7 */ 0x69c7,0x9059,0x7464,0x51dc,0x7199,0x0,0x0,0x0,
/* 0xeaa8 - 0xeaaf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeab0 - 0xeab7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeab8 - 0xeabf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeac0 - 0xeac7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeac8 - 0xeacf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xead0 - 0xead7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xead8 - 0xeadf */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeae0 - 0xeae7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeae8 - 0xeaef */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeaf0 - 0xeaf7 */ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
/* 0xeaf8 - 0xeaff */ 0x0,0x0,0x0,0x0,0x0
}, /* 0xea */

{ /* 0xeb */
/* 0xeb40 - 0xeb47 */ 0xeac8,0xeac9,0xeaca,0xeacb,0xeacc,0xeacd,0xeace,0xeacf,
/* 0xeb48 - 0xeb4f */ 0xead0,0xead1,0xead2,0xead3,0xead4,0xead5,0xead6,0xead7,
/* 0xeb50 - 0xeb57 */ 0xead8,0xead9,0xeada,0xeadb,0xeadc,0xeadd,0xeade,0xeadf,
/* 0xeb58 - 0xeb5f */ 0xeae0,0xeae1,0xeae2,0xeae3,0xeae4,0xeae5,0xeae6,0xeae7,
/* 0xeb60 - 0xeb67 */ 0xeae8,0xeae9,0xeaea,0xeaeb,0xeaec,0xeaed,0xeaee,0xeaef,
/* 0xeb68 - 0xeb6f */ 0xeaf0,0xeaf1,0xeaf2,0xeaf3,0xeaf4,0xeaf5,0xeaf6,0xeaf7,
/* 0xeb70 - 0xeb77 */ 0xeaf8,0xeaf9,0xeafa,0xeafb,0xeafc,0xeafd,0xeafe,0xeaff,
/* 0xeb78 - 0xeb7f */ 0xeb00,0xeb01,0xeb02,0xeb03,0xeb04,0xeb05,0xeb06,0x0,
/* 0xeb80 - 0xeb87 */ 0xeb07,0xeb08,0xeb09,0xeb0a,0xeb0b,0xeb0c,0xeb0d,0xeb0e,
/* 0xeb88 - 0xeb8f */ 0xeb0f,0xeb10,0xeb11,0xeb12,0xeb13,0xeb14,0xeb15,0xeb16,
/* 0xeb90 - 0xeb97 */ 0xeb17,0xeb18,0xeb19,0xeb1a,0xeb1b,0xeb1c,0xeb1d,0xeb1e,
/* 0xeb98 - 0xeb9f */ 0xeb1f,0xeb20,0xeb21,0xeb22,0xeb23,0xeb24,0xeb25,0xeb26,
/* 0xeba0 - 0xeba7 */ 0xeb27,0xeb28,0xeb29,0xeb2a,0xeb2b,0xeb2c,0xeb2d,0xeb2e,
/* 0xeba8 - 0xebaf */ 0xeb2f,0xeb30,0xeb31,0xeb32,0xeb33,0xeb34,0xeb35,0xeb36,
/* 0xebb0 - 0xebb7 */ 0xeb37,0xeb38,0xeb39,0xeb3a,0xeb3b,0xeb3c,0xeb3d,0xeb3e,
/* 0xebb8 - 0xebbf */ 0xeb3f,0xeb40,0xeb41,0xeb42,0xeb43,0xeb44,0xeb45,0xeb46,
/* 0xebc0 - 0xebc7 */ 0xeb47,0xeb48,0xeb49,0xeb4a,0xeb4b,0xeb4c,0xeb4d,0xeb4e,
/* 0xebc8 - 0xebcf */ 0xeb4f,0xeb50,0xeb51,0xeb52,0xeb53,0xeb54,0xeb55,0xeb56,
/* 0xebd0 - 0xebd7 */ 0xeb57,0xeb58,0xeb59,0xeb5a,0xeb5b,0xeb5c,0xeb5d,0xeb5e,
/* 0xebd8 - 0xebdf */ 0xeb5f,0xeb60,0xeb61,0xeb62,0xeb63,0xeb64,0xeb65,0xeb66,
/* 0xebe0 - 0xebe7 */ 0xeb67,0xeb68,0xeb69,0xeb6a,0xeb6b,0xeb6c,0xeb6d,0xeb6e,
/* 0xebe8 - 0xebef */ 0xeb6f,0xeb70,0xeb71,0xeb72,0xeb73,0xeb74,0xeb75,0xeb76,
/* 0xebf0 - 0xebf7 */ 0xeb77,0xeb78,0xeb79,0xeb7a,0xeb7b,0xeb7c,0xeb7d,0xeb7e,
/* 0xebf8 - 0xebff */ 0xeb7f,0xeb80,0xeb81,0xeb82,0xeb83
}, /* 0xeb */

{ /* 0xec */
/* 0xec40 - 0xec47 */ 0xeb84,0xeb85,0xeb86,0xeb87,0xeb88,0xeb89,0xeb8a,0xeb8b,
/* 0xec48 - 0xec4f */ 0xeb8c,0xeb8d,0xeb8e,0xeb8f,0xeb90,0xeb91,0xeb92,0xeb93,
/* 0xec50 - 0xec57 */ 0xeb94,0xeb95,0xeb96,0xeb97,0xeb98,0xeb99,0xeb9a,0xeb9b,
/* 0xec58 - 0xec5f */ 0xeb9c,0xeb9d,0xeb9e,0xeb9f,0xeba0,0xeba1,0xeba2,0xeba3,
/* 0xec60 - 0xec67 */ 0xeba4,0xeba5,0xeba6,0xeba7,0xeba8,0xeba9,0xebaa,0xebab,
/* 0xec68 - 0xec6f */ 0xebac,0xebad,0xebae,0xebaf,0xebb0,0xebb1,0xebb2,0xebb3,
/* 0xec70 - 0xec77 */ 0xebb4,0xebb5,0xebb6,0xebb7,0xebb8,0xebb9,0xebba,0xebbb,
/* 0xec78 - 0xec7f */ 0xebbc,0xebbd,0xebbe,0xebbf,0xebc0,0xebc1,0xebc2,0x0,
/* 0xec80 - 0xec87 */ 0xebc3,0xebc4,0xebc5,0xebc6,0xebc7,0xebc8,0xebc9,0xebca,
/* 0xec88 - 0xec8f */ 0xebcb,0xebcc,0xebcd,0xebce,0xebcf,0xebd0,0xebd1,0xebd2,
/* 0xec90 - 0xec97 */ 0xebd3,0xebd4,0xebd5,0xebd6,0xebd7,0xebd8,0xebd9,0xebda,
/* 0xec98 - 0xec9f */ 0xebdb,0xebdc,0xebdd,0xebde,0xebdf,0xebe0,0xebe1,0xebe2,
/* 0xeca0 - 0xeca7 */ 0xebe3,0xebe4,0xebe5,0xebe6,0xebe7,0xebe8,0xebe9,0xebea,
/* 0xeca8 - 0xecaf */ 0xebeb,0xebec,0xebed,0xebee,0xebef,0xebf0,0xebf1,0xebf2,
/* 0xecb0 - 0xecb7 */ 0xebf3,0xebf4,0xebf5,0xebf6,0xebf7,0xebf8,0xebf9,0xebfa,
/* 0xecb8 - 0xecbf */ 0xebfb,0xebfc,0xebfd,0xebfe,0xebff,0xec00,0xec01,0xec02,
/* 0xecc0 - 0xecc7 */ 0xec03,0xec04,0xec05,0xec06,0xec07,0xec08,0xec09,0xec0a,
/* 0xecc8 - 0xeccf */ 0xec0b,0xec0c,0xec0d,0xec0e,0xec0f,0xec10,0xec11,0xec12,
/* 0xecd0 - 0xecd7 */ 0xec13,0xec14,0xec15,0xec16,0xec17,0xec18,0xec19,0xec1a,
/* 0xecd8 - 0xecdf */ 0xec1b,0xec1c,0xec1d,0xec1e,0xec1f,0xec20,0xec21,0xec22,
/* 0xece0 - 0xece7 */ 0xec23,0xec24,0xec25,0xec26,0xec27,0xec28,0xec29,0xec2a,
/* 0xece8 - 0xecef */ 0xec2b,0xec2c,0xec2d,0xec2e,0xec2f,0xec30,0xec31,0xec32,
/* 0xecf0 - 0xecf7 */ 0xec33,0xec34,0xec35,0xec36,0xec37,0xec38,0xec39,0xec3a,
/* 0xecf8 - 0xecff */ 0xec3b,0xec3c,0xec3d,0xec3e,0xec3f
}, /* 0xec */

{ /* 0xed */
/* 0xed40 - 0xed47 */ 0xec40,0xec41,0xec42,0xec43,0xec44,0xec45,0xec46,0xec47,
/* 0xed48 - 0xed4f */ 0xec48,0xec49,0xec4a,0xec4b,0xec4c,0xec4d,0xec4e,0xec4f,
/* 0xed50 - 0xed57 */ 0xec50,0xec51,0xec52,0xec53,0xec54,0xec55,0xec56,0xec57,
/* 0xed58 - 0xed5f */ 0xec58,0xec59,0xec5a,0xec5b,0xec5c,0xec5d,0xec5e,0xec5f,
/* 0xed60 - 0xed67 */ 0xec60,0xec61,0xec62,0xec63,0xec64,0xec65,0xec66,0xec67,
/* 0xed68 - 0xed6f */ 0xec68,0xec69,0xec6a,0xec6b,0xec6c,0xec6d,0xec6e,0xec6f,
/* 0xed70 - 0xed77 */ 0xec70,0xec71,0xec72,0xec73,0xec74,0xec75,0xec76,0xec77,
/* 0xed78 - 0xed7f */ 0xec78,0xec79,0xec7a,0xec7b,0xec7c,0xec7d,0xec7e,0x0,
/* 0xed80 - 0xed87 */ 0xec7f,0xec80,0xec81,0xec82,0xec83,0xec84,0xec85,0xec86,
/* 0xed88 - 0xed8f */ 0xec87,0xec88,0xec89,0xec8a,0xec8b,0xec8c,0xec8d,0xec8e,
/* 0xed90 - 0xed97 */ 0xec8f,0xec90,0xec91,0xec92,0xec93,0xec94,0xec95,0xec96,
/* 0xed98 - 0xed9f */ 0xec97,0xec98,0xec99,0xec9a,0xec9b,0xec9c,0xec9d,0xec9e,
/* 0xeda0 - 0xeda7 */ 0xec9f,0xeca0,0xeca1,0xeca2,0xeca3,0xeca4,0xeca5,0xeca6,
/* 0xeda8 - 0xedaf */ 0xeca7,0xeca8,0xeca9,0xecaa,0xecab,0xecac,0xecad,0xecae,
/* 0xedb0 - 0xedb7 */ 0xecaf,0xecb0,0xecb1,0xecb2,0xecb3,0xecb4,0xecb5,0xecb6,
/* 0xedb8 - 0xedbf */ 0xecb7,0xecb8,0xecb9,0xecba,0xecbb,0xecbc,0xecbd,0xecbe,
/* 0xedc0 - 0xedc7 */ 0xecbf,0xecc0,0xecc1,0xecc2,0xecc3,0xecc4,0xecc5,0xecc6,
/* 0xedc8 - 0xedcf */ 0xecc7,0xecc8,0xecc9,0xecca,0xeccb,0xeccc,0xeccd,0xecce,
/* 0xedd0 - 0xedd7 */ 0xeccf,0xecd0,0xecd1,0xecd2,0xecd3,0xecd4,0xecd5,0xecd6,
/* 0xedd8 - 0xeddf */ 0xecd7,0xecd8,0xecd9,0xecda,0xecdb,0xecdc,0xecdd,0xecde,
/* 0xede0 - 0xede7 */ 0xecdf,0xece0,0xece1,0xece2,0xece3,0xece4,0xece5,0xece6,
/* 0xede8 - 0xedef */ 0xece7,0xece8,0xece9,0xecea,0xeceb,0xecec,0xeced,0xecee,
/* 0xedf0 - 0xedf7 */ 0xecef,0xecf0,0xecf1,0xecf2,0xecf3,0xecf4,0xecf5,0xecf6,
/* 0xedf8 - 0xedff */ 0xecf7,0xecf8,0xecf9,0xecfa,0xecfb
}, /* 0xed */

{ /* 0xee */
/* 0xee40 - 0xee47 */ 0xecfc,0xecfd,0xecfe,0xecff,0xed00,0xed01,0xed02,0xed03,
/* 0xee48 - 0xee4f */ 0xed04,0xed05,0xed06,0xed07,0xed08,0xed09,0xed0a,0xed0b,
/* 0xee50 - 0xee57 */ 0xed0c,0xed0d,0xed0e,0xed0f,0xed10,0xed11,0xed12,0xed13,
/* 0xee58 - 0xee5f */ 0xed14,0xed15,0xed16,0xed17,0xed18,0xed19,0xed1a,0xed1b,
/* 0xee60 - 0xee67 */ 0xed1c,0xed1d,0xed1e,0xed1f,0xed20,0xed21,0xed22,0xed23,
/* 0xee68 - 0xee6f */ 0xed24,0xed25,0xed26,0xed27,0xed28,0xed29,0xed2a,0xed2b,
/* 0xee70 - 0xee77 */ 0xed2c,0xed2d,0xed2e,0xed2f,0xed30,0xed31,0xed32,0xed33,
/* 0xee78 - 0xee7f */ 0xed34,0xed35,0xed36,0xed37,0xed38,0xed39,0xed3a,0x0,
/* 0xee80 - 0xee87 */ 0xed3b,0xed3c,0xed3d,0xed3e,0xed3f,0xed40,0xed41,0xed42,
/* 0xee88 - 0xee8f */ 0xed43,0xed44,0xed45,0xed46,0xed47,0xed48,0xed49,0xed4a,
/* 0xee90 - 0xee97 */ 0xed4b,0xed4c,0xed4d,0xed4e,0xed4f,0xed50,0xed51,0xed52,
/* 0xee98 - 0xee9f */ 0xed53,0xed54,0xed55,0xed56,0xed57,0xed58,0xed59,0xed5a,
/* 0xeea0 - 0xeea7 */ 0xed5b,0xed5c,0xed5d,0xed5e,0xed5f,0xed60,0xed61,0xed62,
/* 0xeea8 - 0xeeaf */ 0xed63,0xed64,0xed65,0xed66,0xed67,0xed68,0xed69,0xed6a,
/* 0xeeb0 - 0xeeb7 */ 0xed6b,0xed6c,0xed6d,0xed6e,0xed6f,0xed70,0xed71,0xed72,
/* 0xeeb8 - 0xeebf */ 0xed73,0xed74,0xed75,0xed76,0xed77,0xed78,0xed79,0xed7a,
/* 0xeec0 - 0xeec7 */ 0xed7b,0xed7c,0xed7d,0xed7e,0xed7f,0xed80,0xed81,0xed82,
/* 0xeec8 - 0xeecf */ 0xed83,0xed84,0xed85,0xed86,0xed87,0xed88,0xed89,0xed8a,
/* 0xeed0 - 0xeed7 */ 0xed8b,0xed8c,0xed8d,0xed8e,0xed8f,0xed90,0xed91,0xed92,
/* 0xeed8 - 0xeedf */ 0xed93,0xed94,0xed95,0xed96,0xed97,0xed98,0xed99,0xed9a,
/* 0xeee0 - 0xeee7 */ 0xed9b,0xed9c,0xed9d,0xed9e,0xed9f,0xeda0,0xeda1,0xeda2,
/* 0xeee8 - 0xeeef */ 0xeda3,0xeda4,0xeda5,0xeda6,0xeda7,0xeda8,0xeda9,0xedaa,
/* 0xeef0 - 0xeef7 */ 0xedab,0xedac,0xedad,0xedae,0xedaf,0xedb0,0xedb1,0xedb2,
/* 0xeef8 - 0xeeff */ 0xedb3,0xedb4,0xedb5,0xedb6,0xedb7
}, /* 0xee */

{ /* 0xef */
/* 0xef40 - 0xef47 */ 0xedb8,0xedb9,0xedba,0xedbb,0xedbc,0xedbd,0xedbe,0xedbf,
/* 0xef48 - 0xef4f */ 0xedc0,0xedc1,0xedc2,0xedc3,0xedc4,0xedc5,0xedc6,0xedc7,
/* 0xef50 - 0xef57 */ 0xedc8,0xedc9,0xedca,0xedcb,0xedcc,0xedcd,0xedce,0xedcf,
/* 0xef58 - 0xef5f */ 0xedd0,0xedd1,0xedd2,0xedd3,0xedd4,0xedd5,0xedd6,0xedd7,
/* 0xef60 - 0xef67 */ 0xedd8,0xedd9,0xedda,0xeddb,0xeddc,0xeddd,0xedde,0xeddf,
/* 0xef68 - 0xef6f */ 0xede0,0xede1,0xede2,0xede3,0xede4,0xede5,0xede6,0xede7,
/* 0xef70 - 0xef77 */ 0xede8,0xede9,0xedea,0xedeb,0xedec,0xeded,0xedee,0xedef,
/* 0xef78 - 0xef7f */ 0xedf0,0xedf1,0xedf2,0xedf3,0xedf4,0xedf5,0xedf6,0x0,
/* 0xef80 - 0xef87 */ 0xedf7,0xedf8,0xedf9,0xedfa,0xedfb,0xedfc,0xedfd,0xedfe,
/* 0xef88 - 0xef8f */ 0xedff,0xee00,0xee01,0xee02,0xee03,0xee04,0xee05,0xee06,
/* 0xef90 - 0xef97 */ 0xee07,0xee08,0xee09,0xee0a,0xee0b,0xee0c,0xee0d,0xee0e,
/* 0xef98 - 0xef9f */ 0xee0f,0xee10,0xee11,0xee12,0xee13,0xee14,0xee15,0xee16,
/* 0xefa0 - 0xefa7 */ 0xee17,0xee18,0xee19,0xee1a,0xee1b,0xee1c,0xee1d,0xee1e,
/* 0xefa8 - 0xefaf */ 0xee1f,0xee20,0xee21,0xee22,0xee23,0xee24,0xee25,0xee26,
/* 0xefb0 - 0xefb7 */ 0xee27,0xee28,0xee29,0xee2a,0xee2b,0xee2c,0xee2d,0xee2e,
/* 0xefb8 - 0xefbf */ 0xee2f,0xee30,0xee31,0xee32,0xee33,0xee34,0xee35,0xee36,
/* 0xefc0 - 0xefc7 */ 0xee37,0xee38,0xee39,0xee3a,0xee3b,0xee3c,0xee3d,0xee3e,
/* 0xefc8 - 0xefcf */ 0xee3f,0xee40,0xee41,0xee42,0xee43,0xee44,0xee45,0xee46,
/* 0xefd0 - 0xefd7 */ 0xee47,0xee48,0xee49,0xee4a,0xee4b,0xee4c,0xee4d,0xee4e,
/* 0xefd8 - 0xefdf */ 0xee4f,0xee50,0xee51,0xee52,0xee53,0xee54,0xee55,0xee56,
/* 0xefe0 - 0xefe7 */ 0xee57,0xee58,0xee59,0xee5a,0xee5b,0xee5c,0xee5d,0xee5e,
/* 0xefe8 - 0xefef */ 0xee5f,0xee60,0xee61,0xee62,0xee63,0xee64,0xee65,0xee66,
/* 0xeff0 - 0xeff7 */ 0xee67,0xee68,0xee69,0xee6a,0xee6b,0xee6c,0xee6d,0xee6e,
/* 0xeff8 - 0xefff */ 0xee6f,0xee70,0xee71,0xee72,0xee73
}, /* 0xef */

{ /* 0xf0 */
/* 0xf040 - 0xf047 */ 0xee74,0xee75,0xee76,0xee77,0xee78,0xee79,0xee7a,0xee7b,
/* 0xf048 - 0xf04f */ 0xee7c,0xee7d,0xee7e,0xee7f,0xee80,0xee81,0xee82,0xee83,
/* 0xf050 - 0xf057 */ 0xee84,0xee85,0xee86,0xee87,0xee88,0xee89,0xee8a,0xee8b,
/* 0xf058 - 0xf05f */ 0xee8c,0xee8d,0xee8e,0xee8f,0xee90,0xee91,0xee92,0xee93,
/* 0xf060 - 0xf067 */ 0xee94,0xee95,0xee96,0xee97,0xee98,0xee99,0xee9a,0xee9b,
/* 0xf068 - 0xf06f */ 0xee9c,0xee9d,0xee9e,0xee9f,0xeea0,0xeea1,0xeea2,0xeea3,
/* 0xf070 - 0xf077 */ 0xeea4,0xeea5,0xeea6,0xeea7,0xeea8,0xeea9,0xeeaa,0xeeab,
/* 0xf078 - 0xf07f */ 0xeeac,0xeead,0xeeae,0xeeaf,0xeeb0,0xeeb1,0xeeb2,0x0,
/* 0xf080 - 0xf087 */ 0xeeb3,0xeeb4,0xeeb5,0xeeb6,0xeeb7,0xeeb8,0xeeb9,0xeeba,
/* 0xf088 - 0xf08f */ 0xeebb,0xeebc,0xeebd,0xeebe,0xeebf,0xeec0,0xeec1,0xeec2,
/* 0xf090 - 0xf097 */ 0xeec3,0xeec4,0xeec5,0xeec6,0xeec7,0xeec8,0xeec9,0xeeca,
/* 0xf098 - 0xf09f */ 0xeecb,0xeecc,0xeecd,0xeece,0xeecf,0xeed0,0xeed1,0xeed2,
/* 0xf0a0 - 0xf0a7 */ 0xeed3,0xeed4,0xeed5,0xeed6,0xeed7,0xeed8,0xeed9,0xeeda,
/* 0xf0a8 - 0xf0af */ 0xeedb,0xeedc,0xeedd,0xeede,0xeedf,0xeee0,0xeee1,0xeee2,
/* 0xf0b0 - 0xf0b7 */ 0xeee3,0xeee4,0xeee5,0xeee6,0xeee7,0xeee8,0xeee9,0xeeea,
/* 0xf0b8 - 0xf0bf */ 0xeeeb,0xeeec,0xeeed,0xeeee,0xeeef,0xeef0,0xeef1,0xeef2,
/* 0xf0c0 - 0xf0c7 */ 0xeef3,0xeef4,0xeef5,0xeef6,0xeef7,0xeef8,0xeef9,0xeefa,
/* 0xf0c8 - 0xf0cf */ 0xeefb,0xeefc,0xeefd,0xeefe,0xeeff,0xef00,0xef01,0xef02,
/* 0xf0d0 - 0xf0d7 */ 0xef03,0xef04,0xef05,0xef06,0xef07,0xef08,0xef09,0xef0a,
/* 0xf0d8 - 0xf0df */ 0xef0b,0xef0c,0xef0d,0xef0e,0xef0f,0xef10,0xef11,0xef12,
/* 0xf0e0 - 0xf0e7 */ 0xef13,0xef14,0xef15,0xef16,0xef17,0xef18,0xef19,0xef1a,
/* 0xf0e8 - 0xf0ef */ 0xef1b,0xef1c,0xef1d,0xef1e,0xef1f,0xef20,0xef21,0xef22,
/* 0xf0f0 - 0xf0f7 */ 0xef23,0xef24,0xef25,0xef26,0xef27,0xef28,0xef29,0xef2a,
/* 0xf0f8 - 0xf0ff */ 0xef2b,0xef2c,0xef2d,0xef2e,0xef2f
}, /* 0xf0 */

{ /* 0xf1 */
/* 0xf140 - 0xf147 */ 0xef30,0xef31,0xef32,0xef33,0xef34,0xef35,0xef36,0xef37,
/* 0xf148 - 0xf14f */ 0xef38,0xef39,0xef3a,0xef3b,0xef3c,0xef3d,0xef3e,0xef3f,
/* 0xf150 - 0xf157 */ 0xef40,0xef41,0xef42,0xef43,0xef44,0xef45,0xef46,0xef47,
/* 0xf158 - 0xf15f */ 0xef48,0xef49,0xef4a,0xef4b,0xef4c,0xef4d,0xef4e,0xef4f,
/* 0xf160 - 0xf167 */ 0xef50,0xef51,0xef52,0xef53,0xef54,0xef55,0xef56,0xef57,
/* 0xf168 - 0xf16f */ 0xef58,0xef59,0xef5a,0xef5b,0xef5c,0xef5d,0xef5e,0xef5f,
/* 0xf170 - 0xf177 */ 0xef60,0xef61,0xef62,0xef63,0xef64,0xef65,0xef66,0xef67,
/* 0xf178 - 0xf17f */ 0xef68,0xef69,0xef6a,0xef6b,0xef6c,0xef6d,0xef6e,0x0,
/* 0xf180 - 0xf187 */ 0xef6f,0xef70,0xef71,0xef72,0xef73,0xef74,0xef75,0xef76,
/* 0xf188 - 0xf18f */ 0xef77,0xef78,0xef79,0xef7a,0xef7b,0xef7c,0xef7d,0xef7e,
/* 0xf190 - 0xf197 */ 0xef7f,0xef80,0xef81,0xef82,0xef83,0xef84,0xef85,0xef86,
/* 0xf198 - 0xf19f */ 0xef87,0xef88,0xef89,0xef8a,0xef8b,0xef8c,0xef8d,0xef8e,
/* 0xf1a0 - 0xf1a7 */ 0xef8f,0xef90,0xef91,0xef92,0xef93,0xef94,0xef95,0xef96,
/* 0xf1a8 - 0xf1af */ 0xef97,0xef98,0xef99,0xef9a,0xef9b,0xef9c,0xef9d,0xef9e,
/* 0xf1b0 - 0xf1b7 */ 0xef9f,0xefa0,0xefa1,0xefa2,0xefa3,0xefa4,0xefa5,0xefa6,
/* 0xf1b8 - 0xf1bf */ 0xefa7,0xefa8,0xefa9,0xefaa,0xefab,0xefac,0xefad,0xefae,
/* 0xf1c0 - 0xf1c7 */ 0xefaf,0xefb0,0xefb1,0xefb2,0xefb3,0xefb4,0xefb5,0xefb6,
/* 0xf1c8 - 0xf1cf */ 0xefb7,0xefb8,0xefb9,0xefba,0xefbb,0xefbc,0xefbd,0xefbe,
/* 0xf1d0 - 0xf1d7 */ 0xefbf,0xefc0,0xefc1,0xefc2,0xefc3,0xefc4,0xefc5,0xefc6,
/* 0xf1d8 - 0xf1df */ 0xefc7,0xefc8,0xefc9,0xefca,0xefcb,0xefcc,0xefcd,0xefce,
/* 0xf1e0 - 0xf1e7 */ 0xefcf,0xefd0,0xefd1,0xefd2,0xefd3,0xefd4,0xefd5,0xefd6,
/* 0xf1e8 - 0xf1ef */ 0xefd7,0xefd8,0xefd9,0xefda,0xefdb,0xefdc,0xefdd,0xefde,
/* 0xf1f0 - 0xf1f7 */ 0xefdf,0xefe0,0xefe1,0xefe2,0xefe3,0xefe4,0xefe5,0xefe6,
/* 0xf1f8 - 0xf1ff */ 0xefe7,0xefe8,0xefe9,0xefea,0xefeb
}, /* 0xf1 */

{ /* 0xf2 */
/* 0xf240 - 0xf247 */ 0xefec,0xefed,0xefee,0xefef,0xeff0,0xeff1,0xeff2,0xeff3,
/* 0xf248 - 0xf24f */ 0xeff4,0xeff5,0xeff6,0xeff7,0xeff8,0xeff9,0xeffa,0xeffb,
/* 0xf250 - 0xf257 */ 0xeffc,0xeffd,0xeffe,0xefff,0xf000,0xf001,0xf002,0xf003,
/* 0xf258 - 0xf25f */ 0xf004,0xf005,0xf006,0xf007,0xf008,0xf009,0xf00a,0xf00b,
/* 0xf260 - 0xf267 */ 0xf00c,0xf00d,0xf00e,0xf00f,0xf010,0xf011,0xf012,0xf013,
/* 0xf268 - 0xf26f */ 0xf014,0xf015,0xf016,0xf017,0xf018,0xf019,0xf01a,0xf01b,
/* 0xf270 - 0xf277 */ 0xf01c,0xf01d,0xf01e,0xf01f,0xf020,0xf021,0xf022,0xf023,
/* 0xf278 - 0xf27f */ 0xf024,0xf025,0xf026,0xf027,0xf028,0xf029,0xf02a,0x0,
/* 0xf280 - 0xf287 */ 0xf02b,0xf02c,0xf02d,0xf02e,0xf02f,0xf030,0xf031,0xf032,
/* 0xf288 - 0xf28f */ 0xf033,0xf034,0xf035,0xf036,0xf037,0xf038,0xf039,0xf03a,
/* 0xf290 - 0xf297 */ 0xf03b,0xf03c,0xf03d,0xf03e,0xf03f,0xf040,0xf041,0xf042,
/* 0xf298 - 0xf29f */ 0xf043,0xf044,0xf045,0xf046,0xf047,0xf048,0xf049,0xf04a,
/* 0xf2a0 - 0xf2a7 */ 0xf04b,0xf04c,0xf04d,0xf04e,0xf04f,0xf050,0xf051,0xf052,
/* 0xf2a8 - 0xf2af */ 0xf053,0xf054,0xf055,0xf056,0xf057,0xf058,0xf059,0xf05a,
/* 0xf2b0 - 0xf2b7 */ 0xf05b,0xf05c,0xf05d,0xf05e,0xf05f,0xf060,0xf061,0xf062,
/* 0xf2b8 - 0xf2bf */ 0xf063,0xf064,0xf065,0xf066,0xf067,0xf068,0xf069,0xf06a,
/* 0xf2c0 - 0xf2c7 */ 0xf06b,0xf06c,0xf06d,0xf06e,0xf06f,0xf070,0xf071,0xf072,
/* 0xf2c8 - 0xf2cf */ 0xf073,0xf074,0xf075,0xf076,0xf077,0xf078,0xf079,0xf07a,
/* 0xf2d0 - 0xf2d7 */ 0xf07b,0xf07c,0xf07d,0xf07e,0xf07f,0xf080,0xf081,0xf082,
/* 0xf2d8 - 0xf2df */ 0xf083,0xf084,0xf085,0xf086,0xf087,0xf088,0xf089,0xf08a,
/* 0xf2e0 - 0xf2e7 */ 0xf08b,0xf08c,0xf08d,0xf08e,0xf08f,0xf090,0xf091,0xf092,
/* 0xf2e8 - 0xf2ef */ 0xf093,0xf094,0xf095,0xf096,0xf097,0xf098,0xf099,0xf09a,
/* 0xf2f0 - 0xf2f7 */ 0xf09b,0xf09c,0xf09d,0xf09e,0xf09f,0xf0a0,0xf0a1,0xf0a2,
/* 0xf2f8 - 0xf2ff */ 0xf0a3,0xf0a4,0xf0a5,0xf0a6,0xf0a7
}, /* 0xf2 */

{ /* 0xf3 */
/* 0xf340 - 0xf347 */ 0xf0a8,0xf0a9,0xf0aa,0xf0ab,0xf0ac,0xf0ad,0xf0ae,0xf0af,
/* 0xf348 - 0xf34f */ 0xf0b0,0xf0b1,0xf0b2,0xf0b3,0xf0b4,0xf0b5,0xf0b6,0xf0b7,
/* 0xf350 - 0xf357 */ 0xf0b8,0xf0b9,0xf0ba,0xf0bb,0xf0bc,0xf0bd,0xf0be,0xf0bf,
/* 0xf358 - 0xf35f */ 0xf0c0,0xf0c1,0xf0c2,0xf0c3,0xf0c4,0xf0c5,0xf0c6,0xf0c7,
/* 0xf360 - 0xf367 */ 0xf0c8,0xf0c9,0xf0ca,0xf0cb,0xf0cc,0xf0cd,0xf0ce,0xf0cf,
/* 0xf368 - 0xf36f */ 0xf0d0,0xf0d1,0xf0d2,0xf0d3,0xf0d4,0xf0d5,0xf0d6,0xf0d7,
/* 0xf370 - 0xf377 */ 0xf0d8,0xf0d9,0xf0da,0xf0db,0xf0dc,0xf0dd,0xf0de,0xf0df,
/* 0xf378 - 0xf37f */ 0xf0e0,0xf0e1,0xf0e2,0xf0e3,0xf0e4,0xf0e5,0xf0e6,0x0,
/* 0xf380 - 0xf387 */ 0xf0e7,0xf0e8,0xf0e9,0xf0ea,0xf0eb,0xf0ec,0xf0ed,0xf0ee,
/* 0xf388 - 0xf38f */ 0xf0ef,0xf0f0,0xf0f1,0xf0f2,0xf0f3,0xf0f4,0xf0f5,0xf0f6,
/* 0xf390 - 0xf397 */ 0xf0f7,0xf0f8,0xf0f9,0xf0fa,0xf0fb,0xf0fc,0xf0fd,0xf0fe,
/* 0xf398 - 0xf39f */ 0xf0ff,0xf100,0xf101,0xf102,0xf103,0xf104,0xf105,0xf106,
/* 0xf3a0 - 0xf3a7 */ 0xf107,0xf108,0xf109,0xf10a,0xf10b,0xf10c,0xf10d,0xf10e,
/* 0xf3a8 - 0xf3af */ 0xf10f,0xf110,0xf111,0xf112,0xf113,0xf114,0xf115,0xf116,
/* 0xf3b0 - 0xf3b7 */ 0xf117,0xf118,0xf119,0xf11a,0xf11b,0xf11c,0xf11d,0xf11e,
/* 0xf3b8 - 0xf3bf */ 0xf11f,0xf120,0xf121,0xf122,0xf123,0xf124,0xf125,0xf126,
/* 0xf3c0 - 0xf3c7 */ 0xf127,0xf128,0xf129,0xf12a,0xf12b,0xf12c,0xf12d,0xf12e,
/* 0xf3c8 - 0xf3cf */ 0xf12f,0xf130,0xf131,0xf132,0xf133,0xf134,0xf135,0xf136,
/* 0xf3d0 - 0xf3d7 */ 0xf137,0xf138,0xf139,0xf13a,0xf13b,0xf13c,0xf13d,0xf13e,
/* 0xf3d8 - 0xf3df */ 0xf13f,0xf140,0xf141,0xf142,0xf143,0xf144,0xf145,0xf146,
/* 0xf3e0 - 0xf3e7 */ 0xf147,0xf148,0xf149,0xf14a,0xf14b,0xf14c,0xf14d,0xf14e,
/* 0xf3e8 - 0xf3ef */ 0xf14f,0xf150,0xf151,0xf152,0xf153,0xf154,0xf155,0xf156,
/* 0xf3f0 - 0xf3f7 */ 0xf157,0xf158,0xf159,0xf15a,0xf15b,0xf15c,0xf15d,0xf15e,
/* 0xf3f8 - 0xf3ff */ 0xf15f,0xf160,0xf161,0xf162,0xf163
}, /* 0xf3 */

{ /* 0xf4 */
/* 0xf440 - 0xf447 */ 0xf164,0xf165,0xf166,0xf167,0xf168,0xf169,0xf16a,0xf16b,
/* 0xf448 - 0xf44f */ 0xf16c,0xf16d,0xf16e,0xf16f,0xf170,0xf171,0xf172,0xf173,
/* 0xf450 - 0xf457 */ 0xf174,0xf175,0xf176,0xf177,0xf178,0xf179,0xf17a,0xf17b,
/* 0xf458 - 0xf45f */ 0xf17c,0xf17d,0xf17e,0xf17f,0xf180,0xf181,0xf182,0xf183,
/* 0xf460 - 0xf467 */ 0xf184,0xf185,0xf186,0xf187,0xf188,0xf189,0xf18a,0xf18b,
/* 0xf468 - 0xf46f */ 0xf18c,0xf18d,0xf18e,0xf18f,0xf190,0xf191,0xf192,0xf193,
/* 0xf470 - 0xf477 */ 0xf194,0xf195,0xf196,0xf197,0xf198,0xf199,0xf19a,0xf19b,
/* 0xf478 - 0xf47f */ 0xf19c,0xf19d,0xf19e,0xf19f,0xf1a0,0xf1a1,0xf1a2,0x0,
/* 0xf480 - 0xf487 */ 0xf1a3,0xf1a4,0xf1a5,0xf1a6,0xf1a7,0xf1a8,0xf1a9,0xf1aa,
/* 0xf488 - 0xf48f */ 0xf1ab,0xf1ac,0xf1ad,0xf1ae,0xf1af,0xf1b0,0xf1b1,0xf1b2,
/* 0xf490 - 0xf497 */ 0xf1b3,0xf1b4,0xf1b5,0xf1b6,0xf1b7,0xf1b8,0xf1b9,0xf1ba,
/* 0xf498 - 0xf49f */ 0xf1bb,0xf1bc,0xf1bd,0xf1be,0xf1bf,0xf1c0,0xf1c1,0xf1c2,
/* 0xf4a0 - 0xf4a7 */ 0xf1c3,0xf1c4,0xf1c5,0xf1c6,0xf1c7,0xf1c8,0xf1c9,0xf1ca,
/* 0xf4a8 - 0xf4af */ 0xf1cb,0xf1cc,0xf1cd,0xf1ce,0xf1cf,0xf1d0,0xf1d1,0xf1d2,
/* 0xf4b0 - 0xf4b7 */ 0xf1d3,0xf1d4,0xf1d5,0xf1d6,0xf1d7,0xf1d8,0xf1d9,0xf1da,
/* 0xf4b8 - 0xf4bf */ 0xf1db,0xf1dc,0xf1dd,0xf1de,0xf1df,0xf1e0,0xf1e1,0xf1e2,
/* 0xf4c0 - 0xf4c7 */ 0xf1e3,0xf1e4,0xf1e5,0xf1e6,0xf1e7,0xf1e8,0xf1e9,0xf1ea,
/* 0xf4c8 - 0xf4cf */ 0xf1eb,0xf1ec,0xf1ed,0xf1ee,0xf1ef,0xf1f0,0xf1f1,0xf1f2,
/* 0xf4d0 - 0xf4d7 */ 0xf1f3,0xf1f4,0xf1f5,0xf1f6,0xf1f7,0xf1f8,0xf1f9,0xf1fa,
/* 0xf4d8 - 0xf4df */ 0xf1fb,0xf1fc,0xf1fd,0xf1fe,0xf1ff,0xf200,0xf201,0xf202,
/* 0xf4e0 - 0xf4e7 */ 0xf203,0xf204,0xf205,0xf206,0xf207,0xf208,0xf209,0xf20a,
/* 0xf4e8 - 0xf4ef */ 0xf20b,0xf20c,0xf20d,0xf20e,0xf20f,0xf210,0xf211,0xf212,
/* 0xf4f0 - 0xf4f7 */ 0xf213,0xf214,0xf215,0xf216,0xf217,0xf218,0xf219,0xf21a,
/* 0xf4f8 - 0xf4ff */ 0xf21b,0xf21c,0xf21d,0xf21e,0xf21f
}, /* 0xf4 */

{ /* 0xf5 */
/* 0xf540 - 0xf547 */ 0xf220,0xf221,0xf222,0xf223,0xf224,0xf225,0xf226,0xf227,
/* 0xf548 - 0xf54f */ 0xf228,0xf229,0xf22a,0xf22b,0xf22c,0xf22d,0xf22e,0xf22f,
/* 0xf550 - 0xf557 */ 0xf230,0xf231,0xf232,0xf233,0xf234,0xf235,0xf236,0xf237,
/* 0xf558 - 0xf55f */ 0xf238,0xf239,0xf23a,0xf23b,0xf23c,0xf23d,0xf23e,0xf23f,
/* 0xf560 - 0xf567 */ 0xf240,0xf241,0xf242,0xf243,0xf244,0xf245,0xf246,0xf247,
/* 0xf568 - 0xf56f */ 0xf248,0xf249,0xf24a,0xf24b,0xf24c,0xf24d,0xf24e,0xf24f,
/* 0xf570 - 0xf577 */ 0xf250,0xf251,0xf252,0xf253,0xf254,0xf255,0xf256,0xf257,
/* 0xf578 - 0xf57f */ 0xf258,0xf259,0xf25a,0xf25b,0xf25c,0xf25d,0xf25e,0x0,
/* 0xf580 - 0xf587 */ 0xf25f,0xf260,0xf261,0xf262,0xf263,0xf264,0xf265,0xf266,
/* 0xf588 - 0xf58f */ 0xf267,0xf268,0xf269,0xf26a,0xf26b,0xf26c,0xf26d,0xf26e,
/* 0xf590 - 0xf597 */ 0xf26f,0xf270,0xf271,0xf272,0xf273,0xf274,0xf275,0xf276,
/* 0xf598 - 0xf59f */ 0xf277,0xf278,0xf279,0xf27a,0xf27b,0xf27c,0xf27d,0xf27e,
/* 0xf5a0 - 0xf5a7 */ 0xf27f,0xf280,0xf281,0xf282,0xf283,0xf284,0xf285,0xf286,
/* 0xf5a8 - 0xf5af */ 0xf287,0xf288,0xf289,0xf28a,0xf28b,0xf28c,0xf28d,0xf28e,
/* 0xf5b0 - 0xf5b7 */ 0xf28f,0xf290,0xf291,0xf292,0xf293,0xf294,0xf295,0xf296,
/* 0xf5b8 - 0xf5bf */ 0xf297,0xf298,0xf299,0xf29a,0xf29b,0xf29c,0xf29d,0xf29e,
/* 0xf5c0 - 0xf5c7 */ 0xf29f,0xf2a0,0xf2a1,0xf2a2,0xf2a3,0xf2a4,0xf2a5,0xf2a6,
/* 0xf5c8 - 0xf5cf */ 0xf2a7,0xf2a8,0xf2a9,0xf2aa,0xf2ab,0xf2ac,0xf2ad,0xf2ae,
/* 0xf5d0 - 0xf5d7 */ 0xf2af,0xf2b0,0xf2b1,0xf2b2,0xf2b3,0xf2b4,0xf2b5,0xf2b6,
/* 0xf5d8 - 0xf5df */ 0xf2b7,0xf2b8,0xf2b9,0xf2ba,0xf2bb,0xf2bc,0xf2bd,0xf2be,
/* 0xf5e0 - 0xf5e7 */ 0xf2bf,0xf2c0,0xf2c1,0xf2c2,0xf2c3,0xf2c4,0xf2c5,0xf2c6,
/* 0xf5e8 - 0xf5ef */ 0xf2c7,0xf2c8,0xf2c9,0xf2ca,0xf2cb,0xf2cc,0xf2cd,0xf2ce,
/* 0xf5f0 - 0xf5f7 */ 0xf2cf,0xf2d0,0xf2d1,0xf2d2,0xf2d3,0xf2d4,0xf2d5,0xf2d6,
/* 0xf5f8 - 0xf5ff */ 0xf2d7,0xf2d8,0xf2d9,0xf2da,0xf2db
}, /* 0xf5 */

{ /* 0xf6 */
/* 0xf640 - 0xf647 */ 0xf2dc,0xf2dd,0xf2de,0xf2df,0xf2e0,0xf2e1,0xf2e2,0xf2e3,
/* 0xf648 - 0xf64f */ 0xf2e4,0xf2e5,0xf2e6,0xf2e7,0xf2e8,0xf2e9,0xf2ea,0xf2eb,
/* 0xf650 - 0xf657 */ 0xf2ec,0xf2ed,0xf2ee,0xf2ef,0xf2f0,0xf2f1,0xf2f2,0xf2f3,
/* 0xf658 - 0xf65f */ 0xf2f4,0xf2f5,0xf2f6,0xf2f7,0xf2f8,0xf2f9,0xf2fa,0xf2fb,
/* 0xf660 - 0xf667 */ 0xf2fc,0xf2fd,0xf2fe,0xf2ff,0xf300,0xf301,0xf302,0xf303,
/* 0xf668 - 0xf66f */ 0xf304,0xf305,0xf306,0xf307,0xf308,0xf309,0xf30a,0xf30b,
/* 0xf670 - 0xf677 */ 0xf30c,0xf30d,0xf30e,0xf30f,0xf310,0xf311,0xf312,0xf313,
/* 0xf678 - 0xf67f */ 0xf314,0xf315,0xf316,0xf317,0xf318,0xf319,0xf31a,0x0,
/* 0xf680 - 0xf687 */ 0xf31b,0xf31c,0xf31d,0xf31e,0xf31f,0xf320,0xf321,0xf322,
/* 0xf688 - 0xf68f */ 0xf323,0xf324,0xf325,0xf326,0xf327,0xf328,0xf329,0xf32a,
/* 0xf690 - 0xf697 */ 0xf32b,0xf32c,0xf32d,0xf32e,0xf32f,0xf330,0xf331,0xf332,
/* 0xf698 - 0xf69f */ 0xf333,0xf334,0xf335,0xf336,0xf337,0xf338,0xf339,0xf33a,
/* 0xf6a0 - 0xf6a7 */ 0xf33b,0xf33c,0xf33d,0xf33e,0xf33f,0xf340,0xf341,0xf342,
/* 0xf6a8 - 0xf6af */ 0xf343,0xf344,0xf345,0xf346,0xf347,0xf348,0xf349,0xf34a,
/* 0xf6b0 - 0xf6b7 */ 0xf34b,0xf34c,0xf34d,0xf34e,0xf34f,0xf350,0xf351,0xf352,
/* 0xf6b8 - 0xf6bf */ 0xf353,0xf354,0xf355,0xf356,0xf357,0xf358,0xf359,0xf35a,
/* 0xf6c0 - 0xf6c7 */ 0xf35b,0xf35c,0xf35d,0xf35e,0xf35f,0xf360,0xf361,0xf362,
/* 0xf6c8 - 0xf6cf */ 0xf363,0xf364,0xf365,0xf366,0xf367,0xf368,0xf369,0xf36a,
/* 0xf6d0 - 0xf6d7 */ 0xf36b,0xf36c,0xf36d,0xf36e,0xf36f,0xf370,0xf371,0xf372,
/* 0xf6d8 - 0xf6df */ 0xf373,0xf374,0xf375,0xf376,0xf377,0xf378,0xf379,0xf37a,
/* 0xf6e0 - 0xf6e7 */ 0xf37b,0xf37c,0xf37d,0xf37e,0xf37f,0xf380,0xf381,0xf382,
/* 0xf6e8 - 0xf6ef */ 0xf383,0xf384,0xf385,0xf386,0xf387,0xf388,0xf389,0xf38a,
/* 0xf6f0 - 0xf6f7 */ 0xf38b,0xf38c,0xf38d,0xf38e,0xf38f,0xf390,0xf391,0xf392,
/* 0xf6f8 - 0xf6ff */ 0xf393,0xf394,0xf395,0xf396,0xf397
}, /* 0xf6 */

{ /* 0xf7 */
/* 0xf740 - 0xf747 */ 0xf398,0xf399,0xf39a,0xf39b,0xf39c,0xf39d,0xf39e,0xf39f,
/* 0xf748 - 0xf74f */ 0xf3a0,0xf3a1,0xf3a2,0xf3a3,0xf3a4,0xf3a5,0xf3a6,0xf3a7,
/* 0xf750 - 0xf757 */ 0xf3a8,0xf3a9,0xf3aa,0xf3ab,0xf3ac,0xf3ad,0xf3ae,0xf3af,
/* 0xf758 - 0xf75f */ 0xf3b0,0xf3b1,0xf3b2,0xf3b3,0xf3b4,0xf3b5,0xf3b6,0xf3b7,
/* 0xf760 - 0xf767 */ 0xf3b8,0xf3b9,0xf3ba,0xf3bb,0xf3bc,0xf3bd,0xf3be,0xf3bf,
/* 0xf768 - 0xf76f */ 0xf3c0,0xf3c1,0xf3c2,0xf3c3,0xf3c4,0xf3c5,0xf3c6,0xf3c7,
/* 0xf770 - 0xf777 */ 0xf3c8,0xf3c9,0xf3ca,0xf3cb,0xf3cc,0xf3cd,0xf3ce,0xf3cf,
/* 0xf778 - 0xf77f */ 0xf3d0,0xf3d1,0xf3d2,0xf3d3,0xf3d4,0xf3d5,0xf3d6,0x0,
/* 0xf780 - 0xf787 */ 0xf3d7,0xf3d8,0xf3d9,0xf3da,0xf3db,0xf3dc,0xf3dd,0xf3de,
/* 0xf788 - 0xf78f */ 0xf3df,0xf3e0,0xf3e1,0xf3e2,0xf3e3,0xf3e4,0xf3e5,0xf3e6,
/* 0xf790 - 0xf797 */ 0xf3e7,0xf3e8,0xf3e9,0xf3ea,0xf3eb,0xf3ec,0xf3ed,0xf3ee,
/* 0xf798 - 0xf79f */ 0xf3ef,0xf3f0,0xf3f1,0xf3f2,0xf3f3,0xf3f4,0xf3f5,0xf3f6,
/* 0xf7a0 - 0xf7a7 */ 0xf3f7,0xf3f8,0xf3f9,0xf3fa,0xf3fb,0xf3fc,0xf3fd,0xf3fe,
/* 0xf7a8 - 0xf7af */ 0xf3ff,0xf400,0xf401,0xf402,0xf403,0xf404,0xf405,0xf406,
/* 0xf7b0 - 0xf7b7 */ 0xf407,0xf408,0xf409,0xf40a,0xf40b,0xf40c,0xf40d,0xf40e,
/* 0xf7b8 - 0xf7bf */ 0xf40f,0xf410,0xf411,0xf412,0xf413,0xf414,0xf415,0xf416,
/* 0xf7c0 - 0xf7c7 */ 0xf417,0xf418,0xf419,0xf41a,0xf41b,0xf41c,0xf41d,0xf41e,
/* 0xf7c8 - 0xf7cf */ 0xf41f,0xf420,0xf421,0xf422,0xf423,0xf424,0xf425,0xf426,
/* 0xf7d0 - 0xf7d7 */ 0xf427,0xf428,0xf429,0xf42a,0xf42b,0xf42c,0xf42d,0xf42e,
/* 0xf7d8 - 0xf7df */ 0xf42f,0xf430,0xf431,0xf432,0xf433,0xf434,0xf435,0xf436,
/* 0xf7e0 - 0xf7e7 */ 0xf437,0xf438,0xf439,0xf43a,0xf43b,0xf43c,0xf43d,0xf43e,
/* 0xf7e8 - 0xf7ef */ 0xf43f,0xf440,0xf441,0xf442,0xf443,0xf444,0xf445,0xf446,
/* 0xf7f0 - 0xf7f7 */ 0xf447,0xf448,0xf449,0xf44a,0xf44b,0xf44c,0xf44d,0xf44e,
/* 0xf7f8 - 0xf7ff */ 0xf44f,0xf450,0xf451,0xf452,0xf453
}, /* 0xf7 */

{ /* 0xf8 */
/* 0xf840 - 0xf847 */ 0xf454,0xf455,0xf456,0xf457,0xf458,0xf459,0xf45a,0xf45b,
/* 0xf848 - 0xf84f */ 0xf45c,0xf45d,0xf45e,0xf45f,0xf460,0xf461,0xf462,0xf463,
/* 0xf850 - 0xf857 */ 0xf464,0xf465,0xf466,0xf467,0xf468,0xf469,0xf46a,0xf46b,
/* 0xf858 - 0xf85f */ 0xf46c,0xf46d,0xf46e,0xf46f,0xf470,0xf471,0xf472,0xf473,
/* 0xf860 - 0xf867 */ 0xf474,0xf475,0xf476,0xf477,0xf478,0xf479,0xf47a,0xf47b,
/* 0xf868 - 0xf86f */ 0xf47c,0xf47d,0xf47e,0xf47f,0xf480,0xf481,0xf482,0xf483,
/* 0xf870 - 0xf877 */ 0xf484,0xf485,0xf486,0xf487,0xf488,0xf489,0xf48a,0xf48b,
/* 0xf878 - 0xf87f */ 0xf48c,0xf48d,0xf48e,0xf48f,0xf490,0xf491,0xf492,0x0,
/* 0xf880 - 0xf887 */ 0xf493,0xf494,0xf495,0xf496,0xf497,0xf498,0xf499,0xf49a,
/* 0xf888 - 0xf88f */ 0xf49b,0xf49c,0xf49d,0xf49e,0xf49f,0xf4a0,0xf4a1,0xf4a2,
/* 0xf890 - 0xf897 */ 0xf4a3,0xf4a4,0xf4a5,0xf4a6,0xf4a7,0xf4a8,0xf4a9,0xf4aa,
/* 0xf898 - 0xf89f */ 0xf4ab,0xf4ac,0xf4ad,0xf4ae,0xf4af,0xf4b0,0xf4b1,0xf4b2,
/* 0xf8a0 - 0xf8a7 */ 0xf4b3,0xf4b4,0xf4b5,0xf4b6,0xf4b7,0xf4b8,0xf4b9,0xf4ba,
/* 0xf8a8 - 0xf8af */ 0xf4bb,0xf4bc,0xf4bd,0xf4be,0xf4bf,0xf4c0,0xf4c1,0xf4c2,
/* 0xf8b0 - 0xf8b7 */ 0xf4c3,0xf4c4,0xf4c5,0xf4c6,0xf4c7,0xf4c8,0xf4c9,0xf4ca,
/* 0xf8b8 - 0xf8bf */ 0xf4cb,0xf4cc,0xf4cd,0xf4ce,0xf4cf,0xf4d0,0xf4d1,0xf4d2,
/* 0xf8c0 - 0xf8c7 */ 0xf4d3,0xf4d4,0xf4d5,0xf4d6,0xf4d7,0xf4d8,0xf4d9,0xf4da,
/* 0xf8c8 - 0xf8cf */ 0xf4db,0xf4dc,0xf4dd,0xf4de,0xf4df,0xf4e0,0xf4e1,0xf4e2,
/* 0xf8d0 - 0xf8d7 */ 0xf4e3,0xf4e4,0xf4e5,0xf4e6,0xf4e7,0xf4e8,0xf4e9,0xf4ea,
/* 0xf8d8 - 0xf8df */ 0xf4eb,0xf4ec,0xf4ed,0xf4ee,0xf4ef,0xf4f0,0xf4f1,0xf4f2,
/* 0xf8e0 - 0xf8e7 */ 0xf4f3,0xf4f4,0xf4f5,0xf4f6,0xf4f7,0xf4f8,0xf4f9,0xf4fa,
/* 0xf8e8 - 0xf8ef */ 0xf4fb,0xf4fc,0xf4fd,0xf4fe,0xf4ff,0xf500,0xf501,0xf502,
/* 0xf8f0 - 0xf8f7 */ 0xf503,0xf504,0xf505,0xf506,0xf507,0xf508,0xf509,0xf50a,
/* 0xf8f8 - 0xf8ff */ 0xf50b,0xf50c,0xf50d,0xf50e,0xf50f
}, /* 0xf8 */

{ /* 0xf9 */
/* 0xf940 - 0xf947 */ 0xf510,0xf511,0xf512,0xf513,0xf514,0xf515,0xf516,0xf517,
/* 0xf948 - 0xf94f */ 0xf518,0xf519,0xf51a,0xf51b,0xf51c,0xf51d,0xf51e,0xf51f,
/* 0xf950 - 0xf957 */ 0xf520,0xf521,0xf522,0xf523,0xf524,0xf525,0xf526,0xf527,
/* 0xf958 - 0xf95f */ 0xf528,0xf529,0xf52a,0xf52b,0xf52c,0xf52d,0xf52e,0xf52f,
/* 0xf960 - 0xf967 */ 0xf530,0xf531,0xf532,0xf533,0xf534,0xf535,0xf536,0xf537,
/* 0xf968 - 0xf96f */ 0xf538,0xf539,0xf53a,0xf53b,0xf53c,0xf53d,0xf53e,0xf53f,
/* 0xf970 - 0xf977 */ 0xf540,0xf541,0xf542,0xf543,0xf544,0xf545,0xf546,0xf547,
/* 0xf978 - 0xf97f */ 0xf548,0xf549,0xf54a,0xf54b,0xf54c,0xf54d,0xf54e,0x0,
/* 0xf980 - 0xf987 */ 0xf54f,0xf550,0xf551,0xf552,0xf553,0xf554,0xf555,0xf556,
/* 0xf988 - 0xf98f */ 0xf557,0xf558,0xf559,0xf55a,0xf55b,0xf55c,0xf55d,0xf55e,
/* 0xf990 - 0xf997 */ 0xf55f,0xf560,0xf561,0xf562,0xf563,0xf564,0xf565,0xf566,
/* 0xf998 - 0xf99f */ 0xf567,0xf568,0xf569,0xf56a,0xf56b,0xf56c,0xf56d,0xf56e,
/* 0xf9a0 - 0xf9a7 */ 0xf56f,0xf570,0xf571,0xf572,0xf573,0xf574,0xf575,0xf576,
/* 0xf9a8 - 0xf9af */ 0xf577,0xf578,0xf579,0xf57a,0xf57b,0xf57c,0xf57d,0xf57e,
/* 0xf9b0 - 0xf9b7 */ 0xf57f,0xf580,0xf581,0xf582,0xf583,0xf584,0xf585,0xf586,
/* 0xf9b8 - 0xf9bf */ 0xf587,0xf588,0xf589,0xf58a,0xf58b,0xf58c,0xf58d,0xf58e,
/* 0xf9c0 - 0xf9c7 */ 0xf58f,0xf590,0xf591,0xf592,0xf593,0xf594,0xf595,0xf596,
/* 0xf9c8 - 0xf9cf */ 0xf597,0xf598,0xf599,0xf59a,0xf59b,0xf59c,0xf59d,0xf59e,
/* 0xf9d0 - 0xf9d7 */ 0xf59f,0xf5a0,0xf5a1,0xf5a2,0xf5a3,0xf5a4,0xf5a5,0xf5a6,
/* 0xf9d8 - 0xf9df */ 0xf5a7,0xf5a8,0xf5a9,0xf5aa,0xf5ab,0xf5ac,0xf5ad,0xf5ae,
/* 0xf9e0 - 0xf9e7 */ 0xf5af,0xf5b0,0xf5b1,0xf5b2,0xf5b3,0xf5b4,0xf5b5,0xf5b6,
/* 0xf9e8 - 0xf9ef */ 0xf5b7,0xf5b8,0xf5b9,0xf5ba,0xf5bb,0xf5bc,0xf5bd,0xf5be,
/* 0xf9f0 - 0xf9f7 */ 0xf5bf,0xf5c0,0xf5c1,0xf5c2,0xf5c3,0xf5c4,0xf5c5,0xf5c6,
/* 0xf9f8 - 0xf9ff */ 0xf5c7,0xf5c8,0xf5c9,0xf5ca,0xf5cb
}, /* 0xf9 */

{ /* 0xfa */
/* 0xfa40 - 0xfa47 */ 0xf5cc,0xf5cd,0xf5ce,0xf5cf,0xf5d0,0xf5d1,0xf5d2,0xf5d3,
/* 0xfa48 - 0xfa4f */ 0xf5d4,0xf5d5,0xf5d6,0xf5d7,0xf5d8,0xf5d9,0xf5da,0xf5db,
/* 0xfa50 - 0xfa57 */ 0xf5dc,0xf5dd,0xf5de,0xf5df,0xf5e0,0xf5e1,0xf5e2,0xf5e3,
/* 0xfa58 - 0xfa5f */ 0xf5e4,0xf5e5,0xf5e6,0xf5e7,0xf5e8,0xf5e9,0xf5ea,0xf5eb,
/* 0xfa60 - 0xfa67 */ 0xf5ec,0xf5ed,0xf5ee,0xf5ef,0xf5f0,0xf5f1,0xf5f2,0xf5f3,
/* 0xfa68 - 0xfa6f */ 0xf5f4,0xf5f5,0xf5f6,0xf5f7,0xf5f8,0xf5f9,0xf5fa,0xf5fb,
/* 0xfa70 - 0xfa77 */ 0xf5fc,0xf5fd,0xf5fe,0xf5ff,0xf600,0xf601,0xf602,0xf603,
/* 0xfa78 - 0xfa7f */ 0xf604,0xf605,0xf606,0xf607,0xf608,0xf609,0xf60a,0x0,
/* 0xfa80 - 0xfa87 */ 0xf60b,0xf60c,0xf60d,0xf60e,0xf60f,0xf610,0xf611,0xf612,
/* 0xfa88 - 0xfa8f */ 0xf613,0xf614,0xf615,0xf616,0xf617,0xf618,0xf619,0xf61a,
/* 0xfa90 - 0xfa97 */ 0xf61b,0xf61c,0xf61d,0xf61e,0xf61f,0xf620,0xf621,0xf622,
/* 0xfa98 - 0xfa9f */ 0xf623,0xf624,0xf625,0xf626,0xf627,0xf628,0xf629,0xf62a,
/* 0xfaa0 - 0xfaa7 */ 0xf62b,0xf62c,0xf62d,0xf62e,0xf62f,0xf630,0xf631,0xf632,
/* 0xfaa8 - 0xfaaf */ 0xf633,0xf634,0xf635,0xf636,0xf637,0xf638,0xf639,0xf63a,
/* 0xfab0 - 0xfab7 */ 0xf63b,0xf63c,0xf63d,0xf63e,0xf63f,0xf640,0xf641,0xf642,
/* 0xfab8 - 0xfabf */ 0xf643,0xf644,0xf645,0xf646,0xf647,0xf648,0xf649,0xf64a,
/* 0xfac0 - 0xfac7 */ 0xf64b,0xf64c,0xf64d,0xf64e,0xf64f,0xf650,0xf651,0xf652,
/* 0xfac8 - 0xfacf */ 0xf653,0xf654,0xf655,0xf656,0xf657,0xf658,0xf659,0xf65a,
/* 0xfad0 - 0xfad7 */ 0xf65b,0xf65c,0xf65d,0xf65e,0xf65f,0xf660,0xf661,0xf662,
/* 0xfad8 - 0xfadf */ 0xf663,0xf664,0xf665,0xf666,0xf667,0xf668,0xf669,0xf66a,
/* 0xfae0 - 0xfae7 */ 0xf66b,0xf66c,0xf66d,0xf66e,0xf66f,0xf670,0xf671,0xf672,
/* 0xfae8 - 0xfaef */ 0xf673,0xf674,0xf675,0xf676,0xf677,0xf678,0xf679,0xf67a,
/* 0xfaf0 - 0xfaf7 */ 0xf67b,0xf67c,0xf67d,0xf67e,0xf67f,0xf680,0xf681,0xf682,
/* 0xfaf8 - 0xfaff */ 0xf683,0xf684,0xf685,0xf686,0xf687
}, /* 0xfa */

{ /* 0xfb */
/* 0xfb40 - 0xfb47 */ 0xf688,0xf689,0xf68a,0xf68b,0xf68c,0xf68d,0xf68e,0xf68f,
/* 0xfb48 - 0xfb4f */ 0xf690,0xf691,0xf692,0xf693,0xf694,0xf695,0xf696,0xf697,
/* 0xfb50 - 0xfb57 */ 0xf698,0xf699,0xf69a,0xf69b,0xf69c,0xf69d,0xf69e,0xf69f,
/* 0xfb58 - 0xfb5f */ 0xf6a0,0xf6a1,0xf6a2,0xf6a3,0xf6a4,0xf6a5,0xf6a6,0xf6a7,
/* 0xfb60 - 0xfb67 */ 0xf6a8,0xf6a9,0xf6aa,0xf6ab,0xf6ac,0xf6ad,0xf6ae,0xf6af,
/* 0xfb68 - 0xfb6f */ 0xf6b0,0xf6b1,0xf6b2,0xf6b3,0xf6b4,0xf6b5,0xf6b6,0xf6b7,
/* 0xfb70 - 0xfb77 */ 0xf6b8,0xf6b9,0xf6ba,0xf6bb,0xf6bc,0xf6bd,0xf6be,0xf6bf,
/* 0xfb78 - 0xfb7f */ 0xf6c0,0xf6c1,0xf6c2,0xf6c3,0xf6c4,0xf6c5,0xf6c6,0x0,
/* 0xfb80 - 0xfb87 */ 0xf6c7,0xf6c8,0xf6c9,0xf6ca,0xf6cb,0xf6cc,0xf6cd,0xf6ce,
/* 0xfb88 - 0xfb8f */ 0xf6cf,0xf6d0,0xf6d1,0xf6d2,0xf6d3,0xf6d4,0xf6d5,0xf6d6,
/* 0xfb90 - 0xfb97 */ 0xf6d7,0xf6d8,0xf6d9,0xf6da,0xf6db,0xf6dc,0xf6dd,0xf6de,
/* 0xfb98 - 0xfb9f */ 0xf6df,0xf6e0,0xf6e1,0xf6e2,0xf6e3,0xf6e4,0xf6e5,0xf6e6,
/* 0xfba0 - 0xfba7 */ 0xf6e7,0xf6e8,0xf6e9,0xf6ea,0xf6eb,0xf6ec,0xf6ed,0xf6ee,
/* 0xfba8 - 0xfbaf */ 0xf6ef,0xf6f0,0xf6f1,0xf6f2,0xf6f3,0xf6f4,0xf6f5,0xf6f6,
/* 0xfbb0 - 0xfbb7 */ 0xf6f7,0xf6f8,0xf6f9,0xf6fa,0xf6fb,0xf6fc,0xf6fd,0xf6fe,
/* 0xfbb8 - 0xfbbf */ 0xf6ff,0xf700,0xf701,0xf702,0xf703,0xf704,0xf705,0xf706,
/* 0xfbc0 - 0xfbc7 */ 0xf707,0xf708,0xf709,0xf70a,0xf70b,0xf70c,0xf70d,0xf70e,
/* 0xfbc8 - 0xfbcf */ 0xf70f,0xf710,0xf711,0xf712,0xf713,0xf714,0xf715,0xf716,
/* 0xfbd0 - 0xfbd7 */ 0xf717,0xf718,0xf719,0xf71a,0xf71b,0xf71c,0xf71d,0xf71e,
/* 0xfbd8 - 0xfbdf */ 0xf71f,0xf720,0xf721,0xf722,0xf723,0xf724,0xf725,0xf726,
/* 0xfbe0 - 0xfbe7 */ 0xf727,0xf728,0xf729,0xf72a,0xf72b,0xf72c,0xf72d,0xf72e,
/* 0xfbe8 - 0xfbef */ 0xf72f,0xf730,0xf731,0xf732,0xf733,0xf734,0xf735,0xf736,
/* 0xfbf0 - 0xfbf7 */ 0xf737,0xf738,0xf739,0xf73a,0xf73b,0xf73c,0xf73d,0xf73e,
/* 0xfbf8 - 0xfbff */ 0xf73f,0xf740,0xf741,0xf742,0xf743
}, /* 0xfb */

{ /* 0xfc */
/* 0xfc40 - 0xfc47 */ 0xf744,0xf745,0xf746,0xf747,0xf748,0xf749,0xf74a,0xf74b,
/* 0xfc48 - 0xfc4f */ 0xf74c,0xf74d,0xf74e,0xf74f,0xf750,0xf751,0xf752,0xf753,
/* 0xfc50 - 0xfc57 */ 0xf754,0xf755,0xf756,0xf757,0xf758,0xf759,0xf75a,0xf75b,
/* 0xfc58 - 0xfc5f */ 0xf75c,0xf75d,0xf75e,0xf75f,0xf760,0xf761,0xf762,0xf763,
/* 0xfc60 - 0xfc67 */ 0xf764,0xf765,0xf766,0xf767,0xf768,0xf769,0xf76a,0xf76b,
/* 0xfc68 - 0xfc6f */ 0xf76c,0xf76d,0xf76e,0xf76f,0xf770,0xf771,0xf772,0xf773,
/* 0xfc70 - 0xfc77 */ 0xf774,0xf775,0xf776,0xf777,0xf778,0xf779,0xf77a,0xf77b,
/* 0xfc78 - 0xfc7f */ 0xf77c,0xf77d,0xf77e,0xf77f,0xf780,0xf781,0xf782,0x0,
/* 0xfc80 - 0xfc87 */ 0xf783,0xf784,0xf785,0xf786,0xf787,0xf788,0xf789,0xf78a,
/* 0xfc88 - 0xfc8f */ 0xf78b,0xf78c,0xf78d,0xf78e,0xf78f,0xf790,0xf791,0xf792,
/* 0xfc90 - 0xfc97 */ 0xf793,0xf794,0xf795,0xf796,0xf797,0xf798,0xf799,0xf79a,
/* 0xfc98 - 0xfc9f */ 0xf79b,0xf79c,0xf79d,0xf79e,0xf79f,0xf7a0,0xf7a1,0xf7a2,
/* 0xfca0 - 0xfca7 */ 0xf7a3,0xf7a4,0xf7a5,0xf7a6,0xf7a7,0xf7a8,0xf7a9,0xf7aa,
/* 0xfca8 - 0xfcaf */ 0xf7ab,0xf7ac,0xf7ad,0xf7ae,0xf7af,0xf7b0,0xf7b1,0xf7b2,
/* 0xfcb0 - 0xfcb7 */ 0xf7b3,0xf7b4,0xf7b5,0xf7b6,0xf7b7,0xf7b8,0xf7b9,0xf7ba,
/* 0xfcb8 - 0xfcbf */ 0xf7bb,0xf7bc,0xf7bd,0xf7be,0xf7bf,0xf7c0,0xf7c1,0xf7c2,
/* 0xfcc0 - 0xfcc7 */ 0xf7c3,0xf7c4,0xf7c5,0xf7c6,0xf7c7,0xf7c8,0xf7c9,0xf7ca,
/* 0xfcc8 - 0xfccf */ 0xf7cb,0xf7cc,0xf7cd,0xf7ce,0xf7cf,0xf7d0,0xf7d1,0xf7d2,
/* 0xfcd0 - 0xfcd7 */ 0xf7d3,0xf7d4,0xf7d5,0xf7d6,0xf7d7,0xf7d8,0xf7d9,0xf7da,
/* 0xfcd8 - 0xfcdf */ 0xf7db,0xf7dc,0xf7dd,0xf7de,0xf7df,0xf7e0,0xf7e1,0xf7e2,
/* 0xfce0 - 0xfce7 */ 0xf7e3,0xf7e4,0xf7e5,0xf7e6,0xf7e7,0xf7e8,0xf7e9,0xf7ea,
/* 0xfce8 - 0xfcef */ 0xf7eb,0xf7ec,0xf7ed,0xf7ee,0xf7ef,0xf7f0,0xf7f1,0xf7f2,
/* 0xfcf0 - 0xfcf7 */ 0xf7f3,0xf7f4,0xf7f5,0xf7f6,0xf7f7,0xf7f8,0xf7f9,0xf7fa,
/* 0xfcf8 - 0xfcff */ 0xf7fb,0xf7fc,0xf7fd,0xf7fe,0xf7ff
} /* 0xfc */
} ///////////////////////////////////////// DBCS_Table2
}; // sj_to_unicode

WCHAR sjtouni( USHORT code )
{
   USHORT ch1, ch2;
   USHORT usReturn = 0;

   if ( code <= (USHORT)0xff )
   {
       usReturn = sj_to_unicode.SBCS_Table[code];
       if ( usReturn == 0 )
           usReturn = code;
   }
   else
   {
       ch1 = LEADING_BYTE( code );
       ch2 = TRAILING_BYTE( code );

       if ( ch1 >= DBCS_LeadingStart1 &&
            ch1 <= DBCS_LeadingEnd1   &&
            ch2 >= DBCS_TrailingStart &&
            ch2 <= DBCS_TrailingEnd )
       {
           usReturn = sj_to_unicode.DBCS_Table1[ ch1 - DBCS_LeadingStart1 ][ ch2 - DBCS_TrailingStart ] ;
       }
       else if ( ch1 >= DBCS_LeadingStart2 &&
                 ch1 <= DBCS_LeadingEnd2   &&
                 ch2 >= DBCS_TrailingStart &&
                 ch2 <= DBCS_TrailingEnd )
       {
           usReturn =  sj_to_unicode.DBCS_Table2[ ch1 - DBCS_LeadingStart2 ][ ch2 - DBCS_TrailingStart ] ;
       }
       if ( usReturn == 0 )
           usReturn = 0x0020;
   }
   return ( usReturn );
}
#else

/*
 * Unicode to code page 1252 (Windows 3.1 ANSI) translation table.
 *
 * The table is indexed using an 8:4:4 scheme.  The first 256 entries
 * of this table are indexed by the high byte of the Unicode character.
 * If a non-zero value is found this value is used as an offset into
 * the table from which to begin the lookup using the high nibble of
 * the low byte of the Unicode character.  Again, if a non-zero value
 * is found that value is used as an offset into the table from which
 * to begin the last lookup.  This offset is then combined with the low
 * nibble of the low byte of the Unicode character to form the final
 * index into the table.  The value contained at that location is the
 * value of the ANSI character.
 */

USHORT TmpUnicodeToAnsiTable[] = {

    //
    // The first 256 entries are indexed by the high byte of the
    // Unicode character.
    //

    0x0100, 0x0110, 0x0120, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0130, 0x0140, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    //
    // second level tables begin here.  They are indexed
    // by the high nibble of the low byte (bits 4-7) of
    // the Unicode character.
    //

    0x0150, 0x0160, 0x0170, 0x0180, 0x0190, 0x01a0, 0x01b0, 0x01c0,
    0x0000, 0x0000, 0x01d0, 0x01e0, 0x01f0, 0x0200, 0x0210, 0x0220,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0230, 0x0240, 0x0250,
    0x0000, 0x0260, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0270, 0x0280, 0x0000, 0x0000,

    0x0000, 0x0290, 0x02a0, 0x02b0, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x02c0, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    //
    // third level tables begin here.  They are indexed
    // by the low nibble of the low byte (bits 0x0-3) of
    // the Unicode character.
    //

    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,

    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,

    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,

    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,

    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,

    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,

    0x0060, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,

    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x007d, 0x007e, 0x007f,

    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,
    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,

    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,

    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,

    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,

    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,

    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,

    0x0000, 0x0000, 0x008c, 0x009c, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x008a, 0x009a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x009f, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0083, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0088, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0098, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0000, 0x0096, 0x0097, 0x0000, 0x0000, 0x0000,
    0x0091, 0x0092, 0x0082, 0x0000, 0x0093, 0x0094, 0x0084, 0x0000,

    0x0086, 0x0087, 0x0095, 0x0000, 0x0000, 0x0000, 0x0085, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0089, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x008b, 0x009b, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,

    0x0000, 0x0000, 0x0099, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
    };
#endif // DBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\unicode\rcunicod.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rcunicod.c

Abstract:

    Routines added to rcpp to support 16-bit unicode file parsing.
	Note that as of Aug 91, rcpp will not fully transfer the unicode
	characters but only the string constants are guaranteed to be passed
	cleanly.

Author:

    David J. Marsyla (t-davema) 25-Aug-1991

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <process.h>
#include "rcunicod.h"

#ifdef DBCS

//
// Prototypes for conversion routines between Unicode and 932.
//

NTSTATUS
xxxRtlMultiByteToUnicodeN(
    PWSTR UnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    );

NTSTATUS
xxxRtlUnicodeToMultiByteN(
    PCHAR MultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    );

#endif // DBCS

#ifndef DBCS
// SHUNK: A_fwrite is not called from RC. Remove this for now.

INT
A_fwrite (
IN		CHAR	*pchMBString,
IN		INT		nSizeOfItem,
IN		INT		nCountToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function will write out an 8-bit string as a unicode string.
	Note, this function is very slow, but hey, I don't have time to optimize
	it now.
	As of Aug 91, only codepage 1252 is being supported.

Arguments:

    pchMBString		    - This is a 8-bit multi byte string to write to the file
					  	  as a unicode string.

    nSizeOfItem			- Ignored, we always use sizeof (CHAR).

    nCountToWrite		- How long is this string.

    fpOutputFile		- File pointer to send the character.

Return Value:
  
	The number of bytes written.
	If the return does not equal nCountToWrite than an error has occured at
	some point in the write.

--*/

{
    WCHAR	wchUniCharToWrite;
    INT		cCountWritten = 0;

    UNREFERENCED_PARAMETER(nSizeOfItem);

    //
    // Write the string out as a two byte unicode string.
    // For now do this with multiple calls to U_fputc.
    //

    while (nCountToWrite--) {

	wchUniCharToWrite = RtlAnsiCharToUnicodeChar(&pchMBString);

	//
	// Write the current unicode char, break if an error occured.
	//

	if (U_fputc (wchUniCharToWrite, fpOutputFile) == 
	    (INT)wchUniCharToWrite) {

	    break;
	}

	cCountWritten++;
    }

    return (cCountWritten);
}

#endif	// DBCS


#ifndef DBCS
// SHUNK: U_fwrite is not called from RC. Remove this for now.

INT
U_fwrite (
IN		WCHAR	*pwchUnicodeString,
IN		INT		nSizeOfItem,
IN		INT		nCountToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function will write out a 16-bit string directly.  It does no
	translation on the string as it is written.

Arguments:

    pchUnicodeString    - This is a 16-bit unicode string to write to the file.

    nSizeOfItem			- Ignored.  We always use sizeof (WCHAR).

    nCountToWrite		- How long is this string.

    fpOutputFile		- File pointer to send the character.

Return Value:
  
	The number of bytes written.
	If the return does not equal nCountToWrite than an error has occured at
	some point in the write.

--*/

{
    UNREFERENCED_PARAMETER(nSizeOfItem);
    //
    // Write the string out as a two byte unicode string.
    //

    return (fwrite (pwchUnicodeString, sizeof (WCHAR), nCountToWrite,
        fpOutputFile));
}

#endif	// DBCS


#ifndef DBCS
// SHUNK: A_fputc is not called from RC. Remove this for now.

INT
A_fputc (
IN		CHAR	chCharToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function is translates the character passed to it using the 1252
	codepage and then sends it to U_fputc.
	As of Aug 91, only codepage 1252 is being supported.

Arguments:

    chCharToWrite	    - This is a 8-bit character to be output.

    fpOutputFile		- File pointer to send the character.

Return Value:
  
    The character written.
    EOF = There was some sort of error writing the data out.

--*/

{
    WCHAR	wchUniCharToWrite;
    PUCHAR	puch;

    //
    // Translate the char and write it as it's unicode equivalent.
    //

    puch = &chCharToWrite;
    wchUniCharToWrite = RtlAnsiCharToUnicodeChar(&puch);

    if (U_fputc (wchUniCharToWrite, fpOutputFile) == (INT)wchUniCharToWrite) {

	return ((INT)chCharToWrite);
    }
    else {

	return (EOF);
    }
}

#endif	// DBCS


#ifndef DBCS
// SHUNK: U_fputc is not called from RC. Remove this for now.

INT
U_fputc (
IN		WCHAR	wcCharToWrite,
IN      FILE	*fpOutputFile
)

/*++

Routine Description:

    This function is simply the unicode version of fputc.  It will output
	a two byte character instead of the standard byte.

Arguments:

    wcCharToWrite	- This is a 16-bit unicode character to be output.
			It is assumed that any codepage translation has
			already been done to the character.

    fpOutputFile	- File pointer to send the character.

Return Value:
  
    The character written.
    EOF = There was some sort of error writing the data out.

--*/

{
    INT		cCountWritten;

    //
    // Write the char out as a two byte unicode character.
    //

    cCountWritten = fwrite (&wcCharToWrite, sizeof (WCHAR), 1, fpOutputFile);

    if (cCountWritten == sizeof (WCHAR)) {

	return (wcCharToWrite);		// Successful write.

    }
    else {

#ifdef ASSERT_ERRORS
	printf ("Error writing character in U_fputc\n");
	exit (1);
#endif
	return (EOF);				// Some sort of error occured.

    }
}

#endif	// DBCS


BOOL
UnicodeFromMBString (
OUT		WCHAR	*pwchUnicodeString,
IN		CHAR	*pchMBString,
IN		INT	nCountStrLength
)

/*++

Routine Description:

    This function will translate a multi-byte string into it's unicode
	equivalent.  Note that the destination unicode string must be large
	enough to hold the translated bytes.
	As of Aug 91, only codepage 1252 is being supported.

Arguments:

    pwchUnicodeString	- This is a pointer to storage for the destination
			  unicode string.  Note it must be nCountStrLength
			  large.

    pchMBString		- Pointer to the input multi-byte string to convert.

    nCountStrLength	- Count of bytes to translate.

Return Value:
  
	TRUE - All of the characters mapped correctly into Unicode.
	FALSE - One or more characters did not map.  These characters have
			been translated to 0xFFFF.  The rest of the string has been
			converted correctly.

--*/

{
#ifdef DBCS
    NTSTATUS Status;
    
    //
    // Convert ANSI string to Unicode string based on ACP.
    //
    Status = xxxRtlMultiByteToUnicodeN(pwchUnicodeString,
                                    NULL,
                                    pchMBString,
                                    nCountStrLength);

    return(NT_SUCCESS(Status)? TRUE : FALSE);
#else // !DBCS
    UNICODE_STRING	Unicode;
    ANSI_STRING		Ansi;

    Ansi.MaximumLength = Ansi.Length = nCountStrLength;
    Unicode.MaximumLength = nCountStrLength*sizeof(WCHAR) + sizeof(WCHAR);
    Ansi.Buffer = pchMBString;
    Unicode.Buffer = pwchUnicodeString;
    return RtlAnsiStringToUnicodeString(&Unicode,&Ansi,FALSE)==STATUS_SUCCESS;
#endif // !DBCS

}



BOOL
MBStringFromUnicode (
OUT		CHAR	*pchMBString,
IN		WCHAR	*pwchUnicodeString,
IN		INT		nCountStrLength
)

/*++

Routine Description:

    This function will translate a unicode string into a multi-byte string.
	Note that the destination string must be large enough to hold the
	translated bytes.
	As of Aug 91, only the translation is simply done by truncating the 
	unicode character.  We do this because we are not expecting anything
	strange.

Arguments:

    pwchUnicodeString	- This is a pointer to storage for the destination
			  unicode string.  Note it must be nCountStrLength
						  large.

    pchMBString		- Pointer to the input multi-byte string to convert.

    nCountStrLength	- Count of bytes to translate.

Return Value:
  
	TRUE - All of the characters mapped correctly into the MB string.
	FALSE - One or more characters did not map.  As of Aug 91, this will
			never happen.

--*/

{
#ifdef DBCS
    NTSTATUS Status;

    //
    // Convert Unicode string to ANSI string based on ACP.
    //
    Status = xxxRtlUnicodeToMultiByteN(pchMBString,
                                    NULL,
                                    pwchUnicodeString,
                                    nCountStrLength);

    return(NT_SUCCESS(Status)? TRUE : FALSE);
#else // !DBCS
    UNICODE_STRING	Unicode;
    ANSI_STRING		Ansi;

    Unicode.Length = nCountStrLength*sizeof(WCHAR);
    Unicode.MaximumLength = nCountStrLength*sizeof(WCHAR)+sizeof(WCHAR);
    Ansi.MaximumLength = Unicode.MaximumLength / sizeof(WCHAR);
    Ansi.Buffer = pchMBString;
    Unicode.Buffer = pwchUnicodeString;
    return RtlUnicodeStringToAnsiString(&Ansi,&Unicode,FALSE)==STATUS_SUCCESS;
#endif // !DBCS
}



#ifndef DBCS
// SHUNK:  Char1252FromUnicode() is not called any more.

INT
Char1252FromUnicode (
IN		WCHAR	wchUnicodeChar
)

/*++

Routine Description:

    This function will translate a unicode character into it's equivalent
	codepage 1252 character.  If the character does not map correctly,
	then 0xFFFF is returned.

Arguments:

    wchUnicodeChar		- This is a 16-bit unicode character.

Return Value:
  
	Value <= 0xFF - Codepage 1252 equivalent for this string.
	0xFFFF - The character did not translate properly.

--*/

{
    UNICODE_STRING	Unicode;
    ANSI_STRING		Ansi;
    UCHAR		c;
    INT			s;

    Ansi.Length = Unicode.Length = 1;
    Ansi.MaximumLength = Unicode.MaximumLength = 1;
    Ansi.Buffer = &c;
    Unicode.Buffer = &wchUnicodeChar;
    s = RtlUnicodeStringToAnsiString(&Ansi,&Unicode,FALSE);
    if (s != STATUS_SUCCESS)
	return 0xffff;
    return (INT)c;

}

#endif // DBCS


INT
DetermineFileType (
IN      FILE	*fpInputFile
)

/*++

Routine Description:

    This function is used to determine what type of file is being read. 
	Note that it assumes that the first few bytes of the given file contain
	mostly ascii characters.  This routine was originally intended for use
	on .rc files and include files.
	Note, the file is returned to it's proper position after function.

Arguments:

    fpInputFile			- File pointer to file we are checking, must be
						  open with read permissions.

Return Value:
  
	DFT_FILE_IS_UNKNOWN     - It was impossible to determine what type of file
							  we were checking.  This usually happens when EOF
							  is unexpectedly reached.
	DFT_FILE_IS_8_BIT       - File was determined to be in standard 8-bit
							  format.
	DFT_FILE_IS_16_BIT      - File was determined to be a 16 bit unicode file
							  which can be directly read into a WCHAR array.
	DFT_FILE_IS_16_BIT_REV  - File was*/

{
    CHAR	rgchTestBytes [DFT_TEST_SIZE << 2];	// Storage for test data.

    INT		cNumberBytesTested = 0;			// Test information.

    INT		cNumberOddZerosFound = 0;
    INT		cNumberEvenZerosFound = 0;
    INT		cNumberAsciiFound = 0;
    INT		cCountRead;						// Temp storage for count read.

    LONG	lStartFilePos;					// Storage for file position.

    INT		fSysEndianType;					// System endian type.

    INT		fFileType = DFT_FILE_IS_UNKNOWN;// File type, when found.

    fSysEndianType = DetermineSysEndianType ();

    //
    // Store position so we can get back to it.
    //
    	lStartFilePos = ftell (fpInputFile);

    // 
    // Make sure we start on an even byte to simplify routines.
    //
    	if (lStartFilePos % 2) {

	fgetc (fpInputFile);
    }

    do {
	INT		wT;

	//
	// Read in the first test segment.
	//

	cCountRead = fread (rgchTestBytes, sizeof (CHAR), DFT_TEST_SIZE << 2,
	    fpInputFile);

	//
	// Determine results and add to totals.
	//

	for (wT = 0; wT < cCountRead; wT++) {

	    if (rgchTestBytes [wT] == 0) {

		if (wT % 2) {

		    cNumberOddZerosFound++;

		}
		else {

		    cNumberEvenZerosFound++;
		}
	    }

	    if (isprint (rgchTestBytes [wT]) ||
		rgchTestBytes[wT] == '\t' ||
		rgchTestBytes[wT] == '\n' ||
		rgchTestBytes[wT] == '\r') {

		cNumberAsciiFound++;
	    }
	}

	cNumberBytesTested += cCountRead;

	//
	// Check if we have a definite pattern.
	//

	 {
	    INT		cMajorityTested;		// 80% of the bytes tested.

	    cMajorityTested = cNumberBytesTested << 2;
	    cMajorityTested /= 5;

	    if (cNumberAsciiFound > cMajorityTested) {

		fFileType = DFT_FILE_IS_8_BIT;

	    }
	    else if (cNumberOddZerosFound > (cMajorityTested >> 1)) {

		//
		// File type was determined to be little endian.
		// If system is also little endian, byte order is correct.
				//
		fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ? 
		    DFT_FILE_IS_16_BIT : DFT_FILE_IS_16_BIT_REV;

	    }
	    else if (cNumberEvenZerosFound > (cMajorityTested >> 1)) {

		//
		// File type was determined to be big endian.
		// If system is also big endian, byte order is correct.
				//
		fFileType = (fSysEndianType == DSE_SYS_LITTLE_ENDIAN) ? 
		    DFT_FILE_IS_16_BIT_REV : DFT_FILE_IS_16_BIT;

	    }
	}

    } while (cCountRead == (DFT_TEST_SIZE << 2) && 
        fFileType == DFT_FILE_IS_UNKNOWN);

    //
    // Return to starting file position.  (usually beginning)
    //

    fseek (fpInputFile, lStartFilePos, SEEK_SET);

    return (fFileType);
}



INT
DetermineSysEndianType (
VOID
)

/*++

Routine Description:

    This function is used to determine how the current system stores its
	integers in memory.  

    For those of us who are confused by little endian and big endian formats,
	here is a breif recap.
    
    Little Endian:  (This is used on Intel 80x86 chips.  The MIPS RS4000 chip
		 is switchable, but will run in little endian format for NT.)
       This is where the high order bytes of a short or long are stored higher
       in memory.  For example the number 0x80402010 is stored as follows.
         Address:        Value:
             00            10
             01            20
             02            40
             03            80
       This looks backwards when memory is dumped in order: 10 20 40 80
    
    Big Endian:  (This is not currently used on any NT systems but hey, this
         is supposed to be portable!!)
       This is where the high*/

{
    INT		nCheckInteger;
    CHAR	rgchTestBytes [sizeof (INT)];

    //
    // Clear the test bytes to zero.
    //

    *((INT * )rgchTestBytes) = 0;

    //
    // Set first to some value.
    //

    rgchTestBytes [0] = (CHAR)0xFF;

    //
    // Map it to an integer.
    //

    nCheckInteger = *((INT * )rgchTestBytes);

    //
    // See if value was stored in low order of integer. 
    // If so then system is little endian.
    //

    if (nCheckInteger == 0xFF) {

	return (DSE_SYS_LITTLE_ENDIAN);
    }
    else {

	return (DSE_SYS_LITTLE_ENDIAN);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\buffer.cpp ===
/*****************************************************************************
 *
 *  buffer.cpp
 *
 *      Lame buffering implementation.
 *
 *****************************************************************************/

#include "sdview.h"

BOOL IOBuffer::NextLine(String &str)
{
    str.Reset();

    do {

        /*
         *  Drain what we can from the current buffer.
         */
        int i = 0;

        while (i < _cchBufUsed && _rgchBuf[i++] != TEXT('\n')) {
            /* Keep looking */
        }

        if (i) {
            /* _rgchBuf[i] is the first char not to append */
            str.Append(_rgchBuf, i);

            memcpy(_rgchBuf, _rgchBuf+i, _cchBufUsed - i);
            _cchBufUsed -= i;

            /* Stop if we copied a \n */
            if (str[str.Length()-1] == TEXT('\n')) {
                return TRUE;
            }
        }

        /*
         *  Refill from the file until it's all gone.
         */
        if (_hRead)
        {
            DWORD dwBytesRead;
            if (!ReadFile(_hRead, _rgchBuf, _cchBuf, &dwBytesRead, NULL)) {
                _hRead = NULL;
            }
#ifdef UNICODE
    #error Need to convert from ANSI to UNICODE here
#endif
            _cchBufUsed = dwBytesRead;
        }

    } while (_hRead);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\roshare\roshare.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    roshare.c

Abstract:

    This program is a quick-and-dirty app that allows a readonly ACL to
    be placed on a local server share.  The ACL allows everyone Read
    access only.

Author:

    Chuck Lenzmeier (chuckl) 20-Sep-1992

Revision History:

--*/

#define UNICODE 1
#define VERBOSE 0

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <lm.h>

#include <stdio.h>
//#include <string.h>

#define MAX_NAMES 60

BOOL
FindSid(
    LPTSTR Name,
    PSID *Sid
    );

VOID
DumpSid(
    LPTSTR   String,
    PISID    Sid
    );

BOOL
ConstructAcl( 
    PACL *acl, 
    LPTSTR Names[], 
    ULONG Index 
    );

__cdecl
main (
    int argc,
    char *argv[]
    )
{
    ANSI_STRING ansiShareName;
    UNICODE_STRING shareName;
    LPSHARE_INFO_502 shi502;
    SECURITY_DESCRIPTOR desc;
    DWORD aclBuffer[256/4];
    PACL acl = (PACL)aclBuffer;
    SID_IDENTIFIER_AUTHORITY worldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID sid;
    ACCESS_MASK mask;
    int i;
    BOOL ok;
    NTSTATUS status;
    DWORD error;
    DWORD parmerr;
    LPTSTR Names[MAX_NAMES];
    BOOL ExplicitNames = FALSE;
    ULONG Index;

    //
    // Make sure at least one share name was specified.
    //

    if ( argc < 2 ) goto usage;

    //
    // Initialize the security descriptor and the ACL.
    //

    ok = InitializeSecurityDescriptor( &desc, SECURITY_DESCRIPTOR_REVISION );
    if ( !ok ) {
        error = GetLastError();
        printf( "InitializeSecurityDescriptor failed: %d\n", error );
        return error;
    }

    ok = InitializeAcl( acl, 256, ACL_REVISION );
    if ( !ok ) {
        error = GetLastError();
        printf( "InitializeAcl failed: %d\n", error );
        return error;
    }

    //
    // Check to see if there are any usernames specified for
    // the ACL.
    //

    if ( _stricmp( argv[1], "-u") == 0 ) {

#if VERBOSE
        printf("Processing names\n");
#endif

        ExplicitNames = TRUE;
        i=2;  // skip the argument
        Index = 0;

        while ( (_stricmp(argv[i], "-s") != 0) && (Index < MAX_NAMES)) {
            Names[Index++] = (LPTSTR)argv[i++];
        }

        if ( Index > 0 ) {
            ok = ConstructAcl( &acl, Names, Index );
            if ( !ok ) {
                fprintf(stderr, "Unable to create ACL, quitting\n");
                return( ERROR_INVALID_PARAMETER );
            }
        } else {
            goto usage;
        }

    } else {
#if VERBOSE
        printf("No names\n");
#endif

        //
        // Get the SID for World (aka Everyone).
        //
    
        ok = AllocateAndInitializeSid(
                &worldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &sid
                );

        if ( !ok ) {
            error = GetLastError();
            printf( "AllocateAndInitializeSid failed: %d\n", error );
            return error;
        }
    
        //
        // Add an ACE that allows World read access.
        //
    
        mask = GENERIC_READ | GENERIC_EXECUTE;
        ok = AddAccessAllowedAce( acl, ACL_REVISION, mask, sid );

        if ( !ok ) {
            error = GetLastError();
            printf( "AddAccessAllowedAce failed: %d\n", error );
            return error;
        }
    }

    //
    // Associate the ACL with the security descriptor.
    //

    ok = SetSecurityDescriptorDacl( &desc, TRUE, acl, FALSE );

    if ( !ok ) {
        error = GetLastError();
        printf( "SetSecurityDescriptorDacl failed: %d\n", error );
        return error;
    }

    //
    // For each share in the argument list, add the ACL to the share.
    // Note that this will override a preexisting ACL.
    //

    for ( i = (ExplicitNames ? i+1 : 1) ; i < argc; i++ ) {

        //
        // Convert the share name to Unicode.
        //

        RtlInitAnsiString( &ansiShareName, argv[i] );
        status = RtlAnsiStringToUnicodeString(
                    &shareName,
                    &ansiShareName,
                    TRUE
                    );
        if ( !NT_SUCCESS(status) ) {
            printf( "Error converting string %s to Unicode: %x\n",
                    argv[i], status );
            continue;
        }

        //
        // Get the current share information.  If the share doesn't
        // exist, continue with the next one in the list.
        //

        error = NetShareGetInfo(
                    NULL,
                    shareName.Buffer,
                    502,
                    (LPBYTE *)&shi502 );
        if ( error == NERR_NetNameNotFound ) {
            printf( "Share %s doesn't exist\n", argv[i] );
            continue;
        }
        if ( error == ERROR_ACCESS_DENIED ) {
            printf( "Access denied.  Log in as an admin or power user\n" );
            break;
        }
        if ( error != NO_ERROR ) {
            printf( "Unable to get info for share %s: %d\n",
                    argv[i], error );
            continue;
        }

        //
        // Change the security descriptor for the share and set the new
        // information.
        //

        shi502->shi502_security_descriptor = &desc;

        error = NetShareSetInfo(
                    NULL,
                    shareName.Buffer,
                    502,
                    (LPBYTE)shi502,
                    &parmerr
                    );
        if ( error == NERR_NetNameNotFound ) {
            printf( "Share %s doesn't exist\n", argv[i] );
            continue;
        }
        if ( error == ERROR_ACCESS_DENIED ) {
            printf( "Access denied.  Log in as an admin or power user\n" );
            break;
        }
        if ( error != NO_ERROR ) {
            printf( "Unable to set info for share %s: %d, %d\n",
                    argv[i], error, parmerr );
            continue;
        }

        printf( "Readonly ACL added to share %s\n", argv[i] );

    } // for ( i = 1; i < argc; i++ )

    return NO_ERROR;

usage:

    printf( "Usage: %s [-u domain\\name1 [domain\\name2]... -s ] share [share]...\n", argv[0] );
    return ERROR_INVALID_PARAMETER;

}


BOOL
FindSid(
    LPTSTR Name,
    PSID *Sid
    )
{
    DWORD SidLength = 0;
    TCHAR DomainName[256];
    DWORD DomainNameLength = 256;
    SID_NAME_USE Use;
    BOOL Result;
    UNICODE_STRING UName;
    ANSI_STRING AName;
    NTSTATUS status;

    printf("\nName: %s\n",Name);

    //
    // Convert name to unicode
    //

    RtlInitAnsiString( &AName, (PCSZ)Name );
    status = RtlAnsiStringToUnicodeString(
                &UName,
                &AName,
                TRUE
                );
    if ( !NT_SUCCESS(status) ) {
        printf( "Error converting string %s to Unicode: %x\n",
                Name, status );
        return( FALSE );
    }


    Result = LookupAccountName(
                 NULL,
                 UName.Buffer,
                 (PSID)NULL,
                 &SidLength,
                 DomainName,
                 &DomainNameLength,
                 &Use
                 );

    if ( !Result && (GetLastError() == ERROR_INSUFFICIENT_BUFFER) ) {

        *Sid = LocalAlloc( 0, SidLength );

        Result = LookupAccountName(
                     NULL,
                     UName.Buffer,
                     *Sid,
                     &SidLength,
                     DomainName,
                     &DomainNameLength,
                     &Use
                     );

        if ( !Result) {
            printf("2nd Lookup %s failed, error = %d\n",Name,GetLastError());
        } else {
#if VERBOSE
            DumpSid( "2nd Lookup worked\n", (PISID)(*Sid) );
#endif
        }

    } else {
        printf("1st Lookup %s failed, error = %d\n",Name,GetLastError());
    }

    return( Result );
}   

#if VERBOSE

VOID
DumpSid(
    LPTSTR   String,
    PISID    Sid
    )
{
    char    tab[80];
    int     i;
    PULONG  psa;

    printf(String);
    memset(tab, ' ', strlen(String));
    tab[strlen(String)] = 0;
    printf(   "Revision            : %d\n"
                "%s"
                "SubAuthorityCount   : %d\n"
                "%s"
                "IdentifierAuthority : %d-%d-%d-%d-%d-%d\n",
                Sid->Revision,
                tab,
                Sid->SubAuthorityCount,
                tab,
                ((PUCHAR)&Sid->IdentifierAuthority)[0],
                ((PUCHAR)&Sid->IdentifierAuthority)[1],
                ((PUCHAR)&Sid->IdentifierAuthority)[2],
                ((PUCHAR)&Sid->IdentifierAuthority)[3],
                ((PUCHAR)&Sid->IdentifierAuthority)[4],
                ((PUCHAR)&Sid->IdentifierAuthority)[5]
                );
    psa = (PULONG)&Sid->SubAuthority;
    for (i=0; i<(int)Sid->SubAuthorityCount; ++i) {
        printf(
                "%s"
                "SubAuthority        : %d\n",
                tab,
                *psa++
                );
    }
}

#endif

BOOL
ConstructAcl( 
    PACL *acl, 
    LPTSTR Names[],
    ULONG Index 
    )
{
    ULONG i;
    PSID Sids[MAX_NAMES];
    ULONG TotalSidLength = 0;
    ULONG TotalAclLength = 0;
    BOOL Result;
    DWORD error;

    for ( i=0; i<Index ; i++) {

        Result = FindSid( Names[i], &Sids[i] );          

        if ( !Result ) {
            fprintf(stderr, "Unable to map name %s, quitting\n", Names[i]);
            return( FALSE );
        } else {
            TotalSidLength += GetLengthSid( Sids[i] );
        }
    }

    //
    // This is a slight overestimate
    //

    TotalAclLength = TotalSidLength + 
                     sizeof( ACL )  + 
                     Index * sizeof( ACCESS_ALLOWED_ACE );

    *acl = LocalAlloc( 0, TotalAclLength );

    if ( *acl == NULL ) {
        fprintf(stderr, "Out of memory\n");
        return( FALSE );
    }

    Result = InitializeAcl( *acl, TotalAclLength, ACL_REVISION );

    //
    // This should not fail
    //

    if ( !Result ) {
        error = GetLastError();
        fprintf( stderr, "InitializeAcl failed: %d\n", error );
        return FALSE;
    }

    for ( i=0; i<Index ; i++) {

        Result = AddAccessAllowedAce( *acl, 
                                      ACL_REVISION, 
                                      GENERIC_READ | GENERIC_EXECUTE, 
                                      Sids[i]
                                      );
        if ( !Result ) {
            error = GetLastError();
            fprintf( stderr, "AddAccessAllowedAce failed: %d\n", error );
            return FALSE;
        }
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\rm\rm.c ===
/*** RM.C - a generalized remove and unremove mechanism ***********************
*
*       Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
*
* Purpose:
*  The three tools EXP, RM and UNDEL are used to delete files so
*  that they can be undeleted.  This is done my renaming the file into
*  a hidden directory called DELETED.
*
* Notes:
*  All deleted files are kept in the directory .\deleted with a unique name.
*  The names are then kept in .\deleted\index.
*     deleted name (RM_RECLEN bytes).
*  The rm command will rename to the appropriate directory and make an entry.
*  the undelete command will rename back if there is a single item otherwise
*  it will give a list of alternatives.  The exp command will free all deleted
*  objects.
*
* Revision History:
*  07-Feb-1990 bw Add 'void' to walk() definition
*  08-Jan-1990 SB SLM version upgrading added; Add CopyRightYrs Macro
*  03-Jan-1990 SB define QH_TOPIC_NOT_FOUND
*  21-Dec-1989 SB Changes for new index file format
*  20-Dec-1989 SB Add check for return code of 3 for qh
*  14-Dec-1989 LN Update Copyright to include 1990
*  23-Oct-1989 LN Version no bumped to 1.01
*  12-Oct-1989 LN Changed Usage message
*  02-Oct-1989 LN Changed Version no to 1.00
*  08-Aug-1989 BW Add Version number and update copyright.
*  15-May-1987 WB Add /help
*  22-Apr-1987 DL Add /k
*  06-Apr-1987 BW Add copyright notice to usage.
*  30-Mar-1990 BW Get help on RM.EXE, not EXP.EXE
*  17-Oct-1990 w-barry Temporarily replaced 'rename' with 'rename_NT' until
*                      DosMove is completely implemented on NT.
*
******************************************************************************/

/* I N C L U D E    Files */

#include <process.h>
#include <string.h>

/* Next two from ZTools */
#include <stdio.h>
#include <conio.h>
#include <windows.h>
#include <tools.h>

/* D E F I N E s */

#define CopyRightYrs "1987-98"
/* Need 2 steps, first to get correct values in and 2nd to paste them */
/* paste() is hacked to allow LEADING  ZEROES    */
#define paste(a, b, c) #a ".0" #b ".00" #c
#define VERSION(major, minor, buildno) paste(major, minor, buildno)
#define QH_TOPIC_NOT_FOUND 3

/* G L O B A L s */

flagType fRecursive = FALSE;            /* TRUE => descend tree              */
flagType fPrompt = FALSE;               /* TRUE => query for removal         */
flagType fForce = FALSE;                /* TRUE => no query for R/O files    */
flagType fKeepRO = FALSE;               /* TRUE => keep R/O files            */
flagType fTakeOwnership = FALSE;        /* TRUE => attempt takeown if fail   */
flagType fExpunge = FALSE;              /* TRUE => expunge immediately       */
flagType fDelayUntilReboot = FALSE;     /* TRUE => do delete next reboot     */

// Forward Function Declarations...
void Usage( void );
void walk( char *, struct findType *, void * );

#if 0
extern BOOL TakeOwnership( char *lpFileName );
#endif /* 0 */

void Usage()
{
    printf(
"Microsoft File Removal Utility.  Version %s\n"
"Copyright (C) Microsoft Corp %s. All rights reserved.\n\n"
"Usage: RM [/help] [/ikft] [/x [/d]] [/r dir] files\n"
"    /help  invoke Quick Help for this utility\n"
"    /i     inquire of user for each file for permission to remove\n"
"    /k     keep read only files, no prompting to remove them\n"
"    /r dir recurse into subdirectories\n"
"    /f     force delete of read only files without prompting\n"
"    /t     attempt to take ownership of file if delete fails\n"
"    /x     dont save deleted files in deleted subdirectory\n"
"    /d     delay until next reboot.\n",
    VERSION(rmj, rmm, rup), CopyRightYrs);
    exit(1);
}

void walk(p, b, dummy)
char *p;
struct findType *b;
void * dummy;
{
    char buf[MAX_PATH];
    int i, rc;

    if (strcmp(b->fbuf.cFileName, ".") && strcmp(b->fbuf.cFileName, "..") &&
        _strcmpi(b->fbuf.cFileName, "deleted")) {
        if (HASATTR(b->fbuf.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)) {
            if (fRecursive) {
                switch (strend(p)[-1]) {
                case '/':
                case '\\':
                    sprintf(buf, "%s*.*", p);
                    break;
                default:
                    sprintf(buf, "%s\\*.*", p);
                    }
                forfile(buf, -1, walk, NULL);
                }
            }
        else if (fKeepRO && HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY)) {
            printf("%s skipped\n", p);
            return;
        }
        else {
            if (fPrompt || (!fForce && HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY))) {
                printf("%s? ", p);
                fflush(stdout);
                switch (_getch()) {
                case 'y':
                case 'Y':
                    printf("Yes\n");
                    break;
                case 'p':
                case 'P':
                    printf("Proceeding without asking again\n");
                    fPrompt = FALSE;
                    break;
                default:
                    printf(" skipped\n");
                    return;
                    }
                }
            fflush(stdout);
            if (HASATTR(b->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY))
                SetFileAttributes(p, b->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY);

            for (i=0; i<2; i++) {
                if (fExpunge) {
                    if (fDelayUntilReboot) {
                        if (MoveFileEx(p, NULL, MOVEFILE_DELAY_UNTIL_REBOOT)) {
                            rc = 0;
                            }
                        else {
                            rc = 1;
                            }
                        }
                    else
                    if (DeleteFile(p)) {
                        rc = 0;
                        }
                    else {
                        rc = 1;
                        }
                    }
                else {
                    rc = fdelete(p);
                    }

#if 0
                if (rc == 0 || !fTakeOwnership) {
                    break;
                    }

                printf( "%s file not deleted - attempting to take ownership and try again.\n" );
                if (!TakeOwnership( p )) {
                    printf( "%s file not deleted - unable to take ownership.\n" );
                    rc = 0;
                    break;
                    }
#else
                    break;
#endif /* 0 */
                }

            switch (rc) {
            case 0:
                break;
            case 1:
                printf("%s file does not exist\n" , p);
                break;
            case 2:
                printf("%s rename failed: %s\n", p, error());
                break;
            default:
                printf("%s internal error: %s\n", p, error());
                break;
                }
            }
        }
    dummy;
}

__cdecl main(c, v)
int c;
char *v[];
{
    register char *p;
    int iRetCode;

    ConvertAppToOem( c, v );
    SHIFT(c,v);
    while (c && fSwitChr(*v[0])) {
        p = *v;
        while (*++p != '\0')
            switch (*p) {
            case 'f':
                fForce = TRUE;
                break;
            case 'i':
                fPrompt = TRUE;
                break;
            case 'k':
                fKeepRO = TRUE;
                break;
            case 'r':
                fRecursive = TRUE;
                break;
            case 't':
                fTakeOwnership = TRUE;
                break;
            case 'x':
                fExpunge = TRUE;
                break;
            case 'd':
                if (fExpunge) {
                    fDelayUntilReboot = TRUE;
                    break;
                    }
                // Fall thru if /d without /x
            case 'h':
                if (!_strcmpi(p, "help")) {
                    iRetCode = (int) _spawnlp(P_WAIT, "qh.exe", "qh", "/u",
                                       "rm.exe", NULL);
                    /* When qh returns QH_TOPIC_NOT_FOUND or when we
                     *    get -1 (returned when the spawn fails) then
                     *    give Usage() message
                     */
                    if (iRetCode != QH_TOPIC_NOT_FOUND && iRetCode != -1)
                        exit(0);
                }
                /*
                 * else fall thru...
                 */
            default:
                Usage();
            }
        SHIFT(c,v);
    }

    while (c) {
        if (!forfile(*v, -1, walk, NULL)) {
            printf("%s does not exist\n", *v);
        }
        SHIFT(c,v);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\restools\unicode\nlsxlat.c ===
/****************************** Module Header ******************************\
* Module Name: nlsxlat.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* This modules contains the private routines for character translation:
* 8-bit <=> Unicode.
*
* History:
* 03-Jan-1992 gregoryw
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>

/*
 * External declarations - these are temporary tables
 */
extern USHORT TmpUnicodeToAnsiTable[];
extern WCHAR TmpAnsiToUnicodeTable[];
#ifdef DBCS
extern WCHAR sjtouni( USHORT );
#define IsDBCSFirst(w) (((unsigned char)w >= 0x81 && (unsigned char)w <= 0x9f) || (((unsigned char)w >= 0xe0 && (unsigned char)w <= 0xfc)))
#endif // DBCS

/*
 * Various defines for data access
 */
#define DBCS_TABLE_SIZE 256

#define LONIBBLE(b)         ((UCHAR)((UCHAR)(b) & 0xF))
#define HINIBBLE(b)         ((UCHAR)(((UCHAR)(b) >> 4) & 0xF))

#define LOBYTE(w)           ((UCHAR)(w))
#define HIBYTE(w)           ((UCHAR)(((USHORT)(w) >> 8) & 0xFF))

/*
 * Global data used by the translation routines.
 *
 */
UCHAR    NlsLeadByteInfo[DBCS_TABLE_SIZE]; // Lead byte info. for ACP
PUSHORT *NlsMbCodePageTables;         // Multibyte to Unicode translation tables
PUSHORT  NlsAnsiToUnicodeData = TmpAnsiToUnicodeTable; // Ansi CP to Unicode translation table
PUSHORT  NlsUnicodeToAnsiData = TmpUnicodeToAnsiTable; // Unicode to Ansi CP translation table


NTSTATUS
xxxRtlMultiByteToUnicodeN(
    OUT PWCH UnicodeString,
    OUT PULONG BytesInUnicodeString OPTIONAL,
    IN PCH MultiByteString,
    IN ULONG BytesInMultiByteString)

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    ANSI Code Page (ACP) installed at boot time.  Single byte characters
    in the range 0x00 - 0x7f are simply zero extended as a performance
    enhancement.  In some far eastern code pages 0x5c is defined as the
    Yen sign.  For system translation we always want to consider 0x5c
    to be the backslash character.  We get this for free by zero extending.

    NOTE: This routine only supports precomposed Unicode characters.

Arguments:

    UnicodeString - Returns a unicode string that is equivalent to
        the ansi source string.

    BytesInUnicodeString - Returns the number of bytes in the returned
        unicode string pointed to by UnicodeString.

    MultiByteString - Supplies the ansi source string that is to be
        converted to unicode.

    BytesInMultiByteString - The number of bytes in the string pointed to
        by MultiByteString.

Return Value:

    SUCCESS - The conversion was successful


--*/

{
    UCHAR Entry;
    PWCH UnicodeStringAnchor;
    PUSHORT DBCSTable;

    UnicodeStringAnchor = UnicodeString;

#ifdef DBCS
        while (BytesInMultiByteString--) {
            if ( IsDBCSFirst( *MultiByteString ) ) {
                if (!BytesInMultiByteString) {
                    return STATUS_UNSUCCESSFUL;
                }
                *UnicodeString++ = sjtouni( (((USHORT)(*(PUCHAR)MultiByteString++)) << 8) +
                                            (USHORT)(*(PUCHAR)MultiByteString++)
                                          );
                BytesInMultiByteString--;
            } else {
                *UnicodeString++ = sjtouni( *(PUCHAR)MultiByteString++ );
            }
        }
#else
    if (NlsMbCodePageTag) {
        //
        // The ACP is a multibyte code page.  Check each character
        // to see if it is a lead byte before doing the translation.
        //
        while (BytesInMultiByteString--) {
            if ( NlsLeadByteInfo[*MultiByteString]) {
                //
                // Lead byte - translate the trail byte using the table
                // that corresponds to this lead byte.  NOTE: make sure
                // we have a trail byte to convert.
                //
                if (!BytesInMultiByteString) {
                    return STATUS_UNSUCCESSFUL;
                }
                Entry = NlsLeadByteInfo[*MultiByteString++];
                DBCSTable = NlsMbCodePageTables[HINIBBLE(Entry)] + (LONIBBLE(Entry) * DBCS_TABLE_SIZE);
                *UnicodeString++ = DBCSTable[*MultiByteString++];
                BytesInMultiByteString--;
            } else {
                //
                // Single byte character.
                //
                if (*MultiByteString & 0x80) {
                    *UnicodeString++ = NlsAnsiToUnicodeData[*MultiByteString++];
                } else {
                    *UnicodeString++ = (WCHAR)*MultiByteString++;
                }
            }
        }
    } else {
        //
        // The ACP is a single byte code page.
        //
        while (BytesInMultiByteString--) {
            if (*MultiByteString & 0x80) {
                *UnicodeString++ = NlsAnsiToUnicodeData[*MultiByteString++];
            } else {
                *UnicodeString++ = (WCHAR)*MultiByteString++;
            }
        }
    }
#endif

    if (ARGUMENT_PRESENT(BytesInUnicodeString)) {
        *BytesInUnicodeString = (ULONG)((PCH)UnicodeString - (PCH)UnicodeStringAnchor);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
xxxRtlUnicodeToMultiByteN(
    OUT PCH MultiByteString,
    OUT PULONG BytesInMultiByteString OPTIONAL,
    IN PWCH UnicodeString,
    IN ULONG BytesInUnicodeString)

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    ANSI Code Page (ACP) loaded at boot time.

Arguments:

    MultiByteString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done
        because a character in the unicode string does not map to an
        ansi character in the ACP, an error is returned.

    BytesInMultiByteString - Returns the number of bytes in the returned
        ansi string pointed to by MultiByteString.

    UnicodeString - Supplies the unicode source string that is to be
        converted to ansi.

    BytesInUnicodeString - The number of bytes in the the string pointed to by
        UnicodeString.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The conversion failed.  A unicode character was encountered
        that has no translation for the current ANSI Code Page (ACP).

--*/

{
    USHORT Offset;
    USHORT Entry;
    ULONG CharsInUnicodeString;
    PCH MultiByteStringAnchor;

    MultiByteStringAnchor = MultiByteString;

    /*
     * convert from bytes to chars for easier loop handling.
     */
    CharsInUnicodeString = BytesInUnicodeString / sizeof(WCHAR);

    while (CharsInUnicodeString--) {
        Offset = NlsUnicodeToAnsiData[HIBYTE(*UnicodeString)];
        if (Offset != 0) {
            Offset = NlsUnicodeToAnsiData[Offset + HINIBBLE(*UnicodeString)];
            if (Offset != 0) {
                Entry = NlsUnicodeToAnsiData[Offset + LONIBBLE(*UnicodeString)];
                if (HIBYTE(Entry) != 0) {
                    *MultiByteString++ = HIBYTE(Entry);  // lead byte
                }
                *MultiByteString++ = LOBYTE(Entry);
            } else {
                //
                // no translation for this Unicode character.  Return
                // an error.
                //
#ifdef DBCS // RtlUnicodeToMultiByteN : temporary hack to avoid error return
                if ( *UnicodeString <= (WCHAR)0xff )
                    *MultiByteString++ = (UCHAR)*UnicodeString;
                else
                    *MultiByteString++ = '\x20';
#else
                return STATUS_UNSUCCESSFUL;
#endif
            }
        } else {
            //
            // no translation for this Unicode character.  Return an error.
            //
#ifdef DBCS // RtlUnicodeToMultiByteN : temporary hack to avoid error return
            if ( *UnicodeString <= (WCHAR)0xff )
                *MultiByteString++ = (UCHAR)*UnicodeString;
            else
                *MultiByteString++ = '\x20';
#else
            return STATUS_UNSUCCESSFUL;
#endif
        }
        UnicodeString++;
    }

    if (ARGUMENT_PRESENT(BytesInMultiByteString)) {
        *BytesInMultiByteString = (ULONG)(MultiByteString - MultiByteStringAnchor);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sclist\sclist.c ===
//----------------------------------------------------------------------//
//
// Oct 1996 - fixed bug 54583 - simple typo in usage text		//
//		a-martih (Martin Holladay)
//
//----------------------------------------------------------------------//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

SC_HANDLE hSvc;
ENUM_SERVICE_STATUS SvcStat[1024];
ULONG i;
ULONG Resume;
ULONG NumSvc;
LPSTR p;
LPSTR CmdLine;
BOOL  StoppedOnly;
BOOL  RunningOnly;
CHAR  MachineName[256];
CHAR  ch;

int
__cdecl
main( void )
{
    CmdLine = GetCommandLine();

    //
    // skip the program name
    //
    while( *CmdLine && *CmdLine != ' ' ) {
        CmdLine += 1;
    }
    //
    // skip any white space
    //
    while( *CmdLine && *CmdLine == ' ' ) {
        CmdLine += 1;
    }
    //
    // get the command line options
    //
    while( *CmdLine && (*CmdLine == '-' || *CmdLine == '/') ) {
        CmdLine += 1;
        ch = (CHAR)tolower(*CmdLine);
        CmdLine += 1;
        switch( ch ) {
            case 's':
                StoppedOnly = TRUE;
                break;

            case 'r':
                RunningOnly = TRUE;
                break;

            default:
                fputs("\n"
                    "Microsoft (R) Windows NT (TM) Version 5.0 SCLIST\n"
                    "Copyright (C) Microsoft Corp. All rights reserved\n\n"
                    "usage: SCLIST [-?] [-r] [-s] [MachineName]\n"
                    "              [-?] Display this message\n"
                    "              [-r] Display only running services\n"
                    "              [-s] Display only stopped services\n"
                    "              [-MachineName] Machine name to list services\n",
                    stderr );
                exit(0);
        }
        while( *CmdLine == ' ' ) {
            CmdLine += 1;
        }
    }

    //
    // get the machine name
    //
    if (*CmdLine) {
        //
        // skip any white space
        //
        while( *CmdLine && *CmdLine == ' ' ) {
            CmdLine += 1;
        }
        //
        // get the machine name
        //
        p = MachineName;
        while( *CmdLine && *CmdLine != ' ' ) {
            *p++ = *CmdLine;
            CmdLine += 1;
        }
        *p = 0;
    }

    hSvc = OpenSCManager( MachineName, NULL,  SC_MANAGER_ENUMERATE_SERVICE );
    if (!hSvc) {
        printf( "could not open service manager for %s\n",
            MachineName[0] ? MachineName : "Local Machine" );
        return 1;
    }

    if (!EnumServicesStatus(
            hSvc,
            SERVICE_WIN32,
            SERVICE_ACTIVE | SERVICE_INACTIVE,
            SvcStat,
            sizeof(SvcStat),
            &i,
            &NumSvc,
            &Resume
            )) {
        printf( "could not enumerate services for %s\n",
            MachineName[0] ? MachineName : "Local Machine" );
        return 1;
    }

    printf( "\n" );
    printf( "--------------------------------------------\n" );
    printf( "- Service list for %s ", MachineName[0] ? MachineName : "Local Machine" );
    if (StoppedOnly || RunningOnly) {
        printf( "(" );
        if (RunningOnly) {
            printf( "running" );
        }
        if (StoppedOnly) {
            printf( "stopped" );
        }
        printf( ")" );
    }
    printf( "\n" );
    printf( "--------------------------------------------\n" );
    for (i=0; i<NumSvc; i++) {
        if (RunningOnly && SvcStat[i].ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
            continue;
        }
        if (StoppedOnly && SvcStat[i].ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            continue;
        }
        switch( SvcStat[i].ServiceStatus.dwCurrentState ) {
            case SERVICE_STOPPED:
                p = "stopped";
                break;

            case SERVICE_START_PENDING:
                p = "start pending";
                break;

            case SERVICE_STOP_PENDING:
                p = "stop pending";
                break;

            case SERVICE_RUNNING:
                p = "running";
                break;

            case SERVICE_CONTINUE_PENDING:
                p = "continue pending";
                break;

            case SERVICE_PAUSE_PENDING:
                p = "pause pending";
                break;

            case SERVICE_PAUSED:
                p = "paused";
                break;
        }
        printf( "%-16s %-32s %s\n", p, SvcStat[i].lpServiceName, SvcStat[i].lpDisplayName );
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\changes.cpp ===
/*****************************************************************************
 *
 *  changes.cpp
 *
 *      View the result of a change query.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  class CChanges
 *
 *****************************************************************************/

class CChanges : public LVFrame, public BGTask {

    friend DWORD CALLBACK CChanges_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    typedef LVFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_DELETEITEM(UINT uiMsg, WPARAM wParam, LPARAM lParam);

    int     GetChangelist(int iItem);

private:                            /* Helpers */
    CChanges()
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_CHANGES));
    }

    void _AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu);

    static DWORD CALLBACK s_BGInvoke(LPVOID lpParam);
    DWORD _BGInvoke();
    BOOL _BGGetSdCommandLine(String &str);
    void _BuildHint();
    void _ViewBug();
    int  _GetBugNumber(int iItem);

private:
    StringCache _scQuery;
    StringCache _scHint;
    StringCache _scUser;
};

int _CChanges_AddError(HWND hwndChild, LPCTSTR psz)
{
    LVITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iItem = MAXLONG;
    lvi.iSubItem = 0;
    lvi.pszText = CCAST(LPTSTR, psz);
    lvi.iItem = ListView_InsertItem(hwndChild, &lvi);

    if (lvi.iItem == 0) {
        ListView_SetCurSel(hwndChild, 0);   /* Select the first item */
    }
    return lvi.iItem;
}

int CChanges::GetChangelist(int iItem)
{
    if (iItem == -1) {
        iItem = GetCurSel();
    }
    if (iItem >= 0) {

        LVITEM lvi;
        TCHAR sz[64];

        if (ListView_GetItemText(_hwndChild, iItem, sz, ARRAYSIZE(sz))) {
            Substring ss;
            if (Parse(TEXT("$d$e"), sz, &ss)) {
                return StrToInt(sz);
            }
        }
    }
    return -1;
}

LRESULT CChanges::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    static const LVFCOLUMN s_rgcol[] = {
        {  7 ,IDS_COL_CHANGE    ,LVCFMT_RIGHT   },
        { 15 ,IDS_COL_DATE      ,LVCFMT_LEFT    },
        { 10 ,IDS_COL_DEV       ,LVCFMT_LEFT    },
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    LRESULT lres = super::HandleMessage(uiMsg, wParam, lParam);
    if (lres == 0 &&
        SetWindowMenu(MAKEINTRESOURCE(IDM_CHANGES)) &&
        CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_NOSORTHEADER,
                    LVS_EX_LABELTIP | LVS_EX_HEADERDRAGDROP |
                    LVS_EX_INFOTIP | LVS_EX_FULLROWSELECT) &&
        AddColumns(s_rgcol) &&
        BGStartTask(s_BGInvoke, this)) {

        String str;
        str << TEXT("sdv changes ") << _pszQuery;
        SetWindowText(_hwnd, str);
        lres = 0;
    } else {
        lres = -1;
    }
    return lres;
}

LRESULT CChanges::ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return BGFilterSetCursor(super::HandleMessage(uiMsg, wParam, lParam));
}

int CChanges::_GetBugNumber(int iItem)
{
    // 3 = checkin comment
    return ParseBugNumberFromSubItem(_hwndChild, iItem, 3);
}

LRESULT CChanges::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_VIEWDESC:
        ON_LM_ITEMACTIVATE(LM_ITEMACTIVATE, GetCurSel(), 0);
        return 0;

    case IDM_VIEWWINDIFF:
        WindiffChangelist(GetChangelist(GetCurSel()));
        return 0;

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(GetCurSel());
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        return 0;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

void CChanges::_AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu)
{
    AdjustBugMenu(hmenu, _GetBugNumber(iItem), fContextMenu);
}

LRESULT CChanges::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), GetCurSel(), FALSE);
    return 0;
}

LRESULT CChanges::ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPTSTR pszInfoTip = RECAST(LPTSTR, GetLVItem((int)wParam));
    if (pszInfoTip) {
        NMLVGETINFOTIP *pgit = RECAST(NMLVGETINFOTIP *, lParam);
        pgit->pszText = pszInfoTip;
    }
    return 0;
}

LRESULT CChanges::ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange = GetChangelist((int)wParam);
    if (iChange > 0) {
        if (_scHint.IsEmpty()) {
            _BuildHint();
        }
        String str;
        str << iChange << _scHint;
        LaunchThreadTask(CDescribe_ThreadProc, str);
    }

    return 0;
}

LRESULT CChanges::ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_CHANGES_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, (int)wParam, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

LRESULT CChanges::ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    String str;
    for (int iItem = (int)wParam; iItem < (int)lParam; iItem++) {
        LPTSTR pszInfoTip = RECAST(LPTSTR, GetLVItem(iItem));
        if (pszInfoTip) {
            str << pszInfoTip << TEXT("\r\n");
        }
    }
    SetClipboardText(_hwnd, str);
    return 0;
}

LRESULT CChanges::ON_LM_DELETEITEM(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    if (lParam) {
        LocalFree(RECAST(HLOCAL, lParam));
    }
    return 0;
}

LRESULT
CChanges::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_SETCURSOR);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(LM_ITEMACTIVATE);
    FW_MSG(LM_GETINFOTIP);
    FW_MSG(LM_GETCONTEXTMENU);
    FW_MSG(LM_COPYTOCLIPBOARD);
    FW_MSG(LM_DELETEITEM);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  We build the hint only on demand since it takes a while and we
//  don't want to slow down the initial query.
//
void CChanges::_BuildHint()
{
    String str;

    if (!_scQuery.IsEmpty()) {
        String strTok, strPath;
        Tokenizer tok(_scQuery);
        while (tok.Token(strTok)) {
            Substring ss;
            if (Parse(TEXT("$p"), strTok, &ss) && ss.Length() > 0) {
                ss.Finalize();          // Strip off the revision specifier
                if (MapToFullDepotPath(strTok, strPath)) {
                    str << TEXT(' ') << QuoteSpaces(strPath);
                }
            }
        }
    }

    _scHint = str;
}

//
//  A private helper class that captures the parsing state machine.
//
class ChangesParseState : public CommentParser
{
public:
    ChangesParseState(HWND hwndChild) : _iItem(-1), _hwndChild(hwndChild) {}

    void Flush()
    {
        if (_iItem >= 0) {
            _strFullDescription.Chomp();
            LVITEM lvi;
            lvi.iItem = _iItem;
            lvi.iSubItem = 0;
            lvi.mask = LVIF_PARAM;
            lvi.lParam = RECAST(LPARAM, StrDup(_strFullDescription));
            ListView_SetItem(_hwndChild, &lvi);
        }
        _iItem = -1;
        CommentParser::Reset();
        _strFullDescription.Reset();
    }

    void AddLine(LPCTSTR psz)
    {
        _strFullDescription << psz;
    }

    void AddError(LPCTSTR psz)
    {
        _iItem = _CChanges_AddError(_hwndChild, psz);
    }

    void AddEntry(Substring *rgss)
    {
        LVITEM lvi;
        lvi.mask = LVIF_TEXT;
        lvi.iItem = MAXLONG;
        lvi.iSubItem = 0;
        lvi.pszText = rgss[0].Finalize();
        _iItem = lvi.iItem = ListView_InsertItem(_hwndChild, &lvi);

        if (lvi.iItem >= 0) {
            lvi.iSubItem = 1;
            lvi.pszText = rgss[1].Finalize();
            ListView_SetItem(_hwndChild, &lvi);

            lvi.iSubItem = 2;
            lvi.pszText = rgss[2].Finalize();
            LPTSTR psz = StrChr(lvi.pszText, TEXT('\\'));
            if (psz) {
                lvi.pszText = psz+1;
            }
            ListView_SetItem(_hwndChild, &lvi);

            if (lvi.iItem == 0) {
                ListView_SetCurSel(_hwndChild, 0);  /* Select the first item */
            }
        }
    }

    void SetListViewSubItemText(int iSubItem, LPCTSTR psz)
    {
        if (_iItem >= 0) {
            LVITEM lvi;
            lvi.mask = LVIF_TEXT;
            lvi.iItem = _iItem;
            lvi.iSubItem = iSubItem;
            lvi.pszText = CCAST(LPTSTR, psz);
            ListView_SetItem(_hwndChild, &lvi);
        }
    }

    void SetDev(LPCTSTR psz)
    {
        SetListViewSubItemText(2, psz);
    }

    void SetComment(LPCTSTR psz)
    {
        SetListViewSubItemText(3, psz);
    }

private:
    HWND        _hwndChild;
    int         _iItem;
    BOOL        _fHaveComment;
    String      _strFullDescription;
};


DWORD CALLBACK CChanges::s_BGInvoke(LPVOID lpParam)
{
    CChanges *self = RECAST(CChanges *, lpParam);
    return self->_BGInvoke();
}

BOOL CChanges::_BGGetSdCommandLine(String &str)
{
    str.Reset();
    str << TEXT("changes -l -s submitted ");

    /*
     *  Parse the switches as best we can.
     */
    BOOL fMSeen = FALSE;
    GetOpt opt(TEXT("mu"), _pszQuery);
    for (;;) {

        switch (opt.NextSwitch()) {
        case TEXT('m'):
            fMSeen = TRUE;
            str << TEXT("-m ") << opt.GetValue() << TEXT(" ");
            break;

        case TEXT('i'):
            str << TEXT("-i ");
            break;

        case TEXT('u'):
            if (GlobalSettings.IsVersion(1, 60)) {
                str << TEXT("-u ") << opt.GetValue() << TEXT(" ");
            } else {
                _scUser = opt.GetValue();
            }
            break;

        case TEXT('\0'):
            goto L_switch;    // two-level break

        default:
            Help(_hwnd, TEXT("#chang"));
            return FALSE;
        }
    }
L_switch:;

    if (!fMSeen) {
        str << TEXT("-m50 ");
    }

    /*
     *  If no filename is given, use *
     *
     *  The query string will be useful later, so cache that away, too.
     */
    String strQuery;

    if (opt.Finished()) {
        strQuery << TEXT("*");
    } else {
        while (opt.Token()) {
            if (opt.GetValue()[0]) {
               strQuery << ResolveBranchAndQuoteSpaces(opt.GetValue()) << TEXT(" ");
            }
        }
    }

    str << strQuery;
    _scQuery = strQuery;

    return TRUE;
}


DWORD CChanges::_BGInvoke()
{
    String str;
    if (_BGGetSdCommandLine(str)) {
        SDChildProcess proc(str);
        IOBuffer buf(proc.Handle());
        ChangesParseState state(_hwndChild);
        while (buf.NextLine(str)) {
            Substring rgss[3];          // changeno, date, userid
            if (Parse(TEXT("Change $d on $D by $p"), str, rgss)) {
                state.Flush();
                state.AddLine(str);
                if (!_scUser.IsEmpty() &&
                    lstrcmpi(rgss[2].Finalize(), _scUser) != 0) {
                    /* This change is not for us; ignore it */
                } else {
                    state.AddEntry(rgss);
                }
            } else if (str[0] == TEXT('\r')) {
                state.AddLine(str);
            } else if (str[0] == TEXT('\t')) {
                state.AddLine(str);
                str.Chomp();
                state.AddComment(str);
            } else {
                state.Flush();
                str.Chomp();
                state.AddError(str);
            }
        }
        state.Flush();
    } else {
        PostMessage(_hwnd, WM_CLOSE, 0, 0);
    }
    BGEndTask();
    return 0;
}

DWORD CALLBACK CChanges_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new CChanges, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\filelog.cpp ===
/*****************************************************************************
 *
 *  filelog.cpp
 *
 *      View a filelog.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  LogEntry
 *
 *  A single item in a filelog treelist.
 *
 *****************************************************************************/

class LogEntry : public TreeItem {

public:
    LogEntry(LPCTSTR pszRev,
             LPCTSTR pszChange,
             LPCTSTR pszOp,
             LPCTSTR pszDate,
             LPCTSTR pszDev);
    LogEntry() { }

    int GetRev() const { return _iRev; }

    void SetChildPath(LPCTSTR pszChildPath);
    const StringCache& GetChildPath() const { return _scChildPath; }

    void SetIntegrateType(LPCTSTR pszType);
    void SetIsDonor() { _fDonor = TRUE; }
    void SetComment(LPCTSTR pszComment) { _scComment = pszComment; }
    void SetDev(LPCTSTR pszDev) { _scDev = pszDev; }
    void SetFullDescription(LPCTSTR pszFullDescription) {  _scFullDescription = pszFullDescription; }
    void SetChurn(int cAdded, int cDeleted) { _cAdded = cAdded; _cDeleted = cDeleted; }
    BOOL IsChurnSet() const { return _cAdded >= 0; }

    LRESULT GetDispInfo(NMTREELIST *pdi, int iColumn);
    LRESULT GetInfoTip(NMTREELIST *pdi);

    LPCTSTR GetChange() const { return _scChange; }
    LPCTSTR GetComment() const { return _scComment; }

private:
    void GetRevDispInfo(NMTREELIST *ptl);
    void GetChurnDispInfo(NMTREELIST *ptl);
    void GetImage(NMTREELIST *ptl);
private:
    int         _iRev;                  // File revision number
    int         _cDeleted;              // Number of lines deleted
    int         _cAdded;                // Number of lines added
    int         _iOp;                   // Checkin operation
    BOOL        _fDonor;                // Is integration donor
    StringCache _scChange;              // Change number
    StringCache _scOp;                  // Checkin operation (edit, delete, tc.)
    StringCache _scDate;                // Checkin date
    StringCache _scDev;                 // Checkin dev
    StringCache _scComment;             // Checkin comment
    StringCache _scFullDescription;     // Full checkin description
    StringCache _scChildPath;           // Depot path of child items
};

void LogEntry::SetChildPath(LPCTSTR pszChildPath)
{
    String str(pszChildPath);

    LPTSTR pszSharp = StrChr(str, TEXT('#'));
    if (pszSharp) {
        LPTSTR pszComma = StrChr(pszSharp, TEXT(','));

        if (!pszComma) {
            String strT(pszSharp);
            str << TEXT(",") << strT;
        }
    }

    _scChildPath = str;

    SetExpandable();
}

LogEntryImageMap c_rgleim[] = {
    {   TEXT("?")                   ,      -1       },  // OP_UNKNOWN
    {   TEXT("edit")                ,       0       },  // OP_EDIT
    {   TEXT("delete")              ,       1       },  // OP_DELETE
    {   TEXT("add")                 ,       2       },  // OP_ADD
    {   TEXT("integrate")           ,       3       },  // OP_INTEGRATE
    {   TEXT("merge")               ,       3       },  // OP_MERGE
    {   TEXT("branch")              ,       4       },  // OP_BRANCH
    {   TEXT("copy")                ,       5       },  // OP_COPY
    {   TEXT("ignored")             ,       6       },  // OP_IGNORED
};

int ParseOp(LPCTSTR psz)
{
    int i;
    for (i = ARRAYSIZE(c_rgleim) - 1; i > 0; i--) {
        if (StrCmp(c_rgleim[i]._pszOp, psz) == 0) {
            break;
        }
    }
    return i;
}

void LogEntry::SetIntegrateType(LPCTSTR pszType)
{
    if (_iOp == OP_INTEGRATE) {
        _iOp = ParseOp(pszType);
    }
}

LogEntry::LogEntry(
             LPCTSTR pszRev,
             LPCTSTR pszChange,
             LPCTSTR pszOp,
             LPCTSTR pszDate,
             LPCTSTR pszDev)
    : _iRev(StrToInt(pszRev))
    , _scChange(pszChange)
    , _iOp(ParseOp(pszOp))
    , _scDate(pszDate)
    , _scDev(pszDev)
    , _cAdded(-1)
{
}

void LogEntry::GetImage(NMTREELIST *ptl)
{
    ptl->iSubItem = c_rgleim[_iOp]._iImage;
    ptl->cchTextMax = INDEXTOOVERLAYMASK(_fDonor);
}

//
// Combine the pszParent and the pszRev to form the real pszRev
// Since the rev is the more important thing, I will display it
// in the form
//
//      19 Lab06_DEV/foo.cpp
//
//

void LogEntry::GetRevDispInfo(NMTREELIST *ptl)
{
    OutputStringBuffer str(ptl->pszText, ptl->cchTextMax);
    str << _iRev;
    LogEntry *ple = SAFECAST(LogEntry*, Parent());
    if (ple->GetChildPath()) {
        str << TEXT(" ") << BranchOf(ple->GetChildPath()) <<
               TEXT("/") << FilenameOf(ple->GetChildPath());
    }
}

void LogEntry::GetChurnDispInfo(NMTREELIST *ptl)
{
    if (_cAdded >= 0) {
        OutputStringBuffer str(ptl->pszText, ptl->cchTextMax);
        str << _cDeleted << TEXT('/') << _cAdded;
    }
}


LRESULT LogEntry::GetDispInfo(NMTREELIST *ptl, int iColumn)
{
    switch (iColumn) {
    case -1: GetImage(ptl); break;
    case 0: GetRevDispInfo(ptl); break;
    case 1: ptl->pszText = _scChange; break;
    case 2: ptl->pszText = CCAST(LPTSTR, c_rgleim[_iOp]._pszOp); break;
    case 3: ptl->pszText = _scDate; break;
    case 4: ptl->pszText = _scDev; break;
    case 5: GetChurnDispInfo(ptl); break;
    case 6: ptl->pszText = _scComment; break;
    }
    return 0;
}


LRESULT LogEntry::GetInfoTip(NMTREELIST *ptl)
{
    ptl->pszText = _scFullDescription;
    return 0;
}

/*****************************************************************************
 *
 *  class CFileLog
 *
 *****************************************************************************/

class CFileLog : public TLFrame {

    friend DWORD CALLBACK CFileLog_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    enum {
        FL_INITIALIZE = WM_APP
    };

    typedef TLFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_FL_INITIALIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:                            /* Helpers */
    CFileLog() : TLFrame(new LogEntry)
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_FILELOG));
    }

    LogEntry *LEGetCurSel() { return SAFECAST(LogEntry*, TLGetCurSel()); }

    // -ds support was added in version 1.50
    BOOL IsChurnEnabled()
        { return GlobalSettings.IsChurnEnabled() &&
                 GlobalSettings.IsVersion(1, 50); }

    BOOL _ChooseColumns();
    BOOL _ParseQuery();
    LRESULT _FillChildren(LogEntry *pleRoot, LPCTSTR pszRootPath);
    LRESULT _OnItemActivate(LogEntry *ple);
    LRESULT _OnGetContextMenu(LogEntry *ple);

    BOOL _IsViewFileLogEnabled(LogEntry *ple);
    LRESULT _ViewFileLog(LogEntry *ple);
    LRESULT _ViewChangelist(LogEntry *ple);
    void _AdjustMenu(HMENU hmenu, LogEntry *ple, BOOL fContextMenu);

    int _GetChangeNumber(LogEntry *ple);
    int _GetBugNumber(LogEntry *ple);

    struct FLCOLUMN {
        const LVFCOLUMN*    _rgcol;
        const int *         _rgColMap;
        int                 _ccol;
    };

private:
    const FLCOLUMN*     _pflc;
    BOOL                _fIsRestrictedRoot;

    // Used during initialization
    int                 _iHighlightRev;
    LogEntry *          _pleHighlight;
    StringCache         _scSwitches;
    StringCache         _scPath;
};

BOOL CFileLog::_ChooseColumns()
{
    static const LVFCOLUMN c_rgcolChurn[] = {
        { 30 ,IDS_COL_REV       ,LVCFMT_LEFT    },
        {  7 ,IDS_COL_CHANGE    ,LVCFMT_RIGHT   },
        {  7 ,IDS_COL_OP        ,LVCFMT_LEFT    },
        { 15 ,IDS_COL_DATE      ,LVCFMT_LEFT    },
        { 10 ,IDS_COL_DEV       ,LVCFMT_LEFT    },
        {  7 ,IDS_COL_CHURN     ,LVCFMT_LEFT    },
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    static const int c_rgiChurn[] = { 0, 1, 2, 3, 4, 5, 6 };

    static const FLCOLUMN c_flcChurn = {
        c_rgcolChurn,
        c_rgiChurn,
        ARRAYSIZE(c_rgiChurn),
    };

    static const LVFCOLUMN c_rgcolNoChurn[] = {
        { 30 ,IDS_COL_REV       ,LVCFMT_LEFT    },
        {  7 ,IDS_COL_CHANGE    ,LVCFMT_RIGHT   },
        {  7 ,IDS_COL_OP        ,LVCFMT_LEFT    },
        { 15 ,IDS_COL_DATE      ,LVCFMT_LEFT    },
        { 10 ,IDS_COL_DEV       ,LVCFMT_LEFT    },
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    static const int c_rgiNoChurn[] = { 0, 1, 2, 3, 4, 6 };

    static const FLCOLUMN c_flcNoChurn = {
        c_rgcolNoChurn,
        c_rgiNoChurn,
        ARRAYSIZE(c_rgiNoChurn),
    };

    if (IsChurnEnabled()) {
        _pflc = &c_flcChurn;
    } else {
        _pflc = &c_flcNoChurn;
    }

    return AddColumns(_pflc->_rgcol);
}


LRESULT CFileLog::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    if (_ParseQuery()) {
        lres = super::HandleMessage(uiMsg, wParam, lParam);
        if (lres == 0 &&
            _tree.GetRoot() &&
            SetWindowMenu(MAKEINTRESOURCE(IDM_FILELOG)) &&
            CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                        LVS_NOSORTHEADER,
                        LVS_EX_LABELTIP | LVS_EX_HEADERDRAGDROP |
                        LVS_EX_INFOTIP | LVS_EX_FULLROWSELECT) &&
            _ChooseColumns()) {
            PostMessage(_hwnd, FL_INITIALIZE, 0, 0);
        } else {
            lres = -1;
        }
    } else {
        Help(_hwnd, TEXT("#filel"));
        lres = -1;
    }
    return lres;
}

LRESULT CFileLog::ON_FL_INITIALIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _FillChildren(SAFECAST(LogEntry*, _tree.GetRoot()), _scPath);
    _tree.Expand(_tree.GetRoot());

    // Clean out the stuff that's used only for the initial root expand
    _scSwitches = NULL;
    _iHighlightRev = 0;
    if (_pleHighlight) {
        _tree.SetCurSel(_pleHighlight);
    } else {
        ListView_SetCurSel(_hwndChild, 0);
    }
    return 0;
}

int CFileLog::_GetBugNumber(LogEntry *ple)
{
    if (ple) {
        return ParseBugNumber(ple->GetComment());
    } else {
        return 0;
    }
}

int CFileLog::_GetChangeNumber(LogEntry *ple)
{
    if (ple) {
        return StrToInt(ple->GetChange());
    } else {
        return 0;
    }
}

//
//  View Filelog is enabled if it would show you something different
//  from what you're looking at right now.
//
BOOL CFileLog::_IsViewFileLogEnabled(LogEntry *ple)
{
    if (!ple) {
        return FALSE;               // not even an item!
    }

    if (_fIsRestrictedRoot) {
        return TRUE;                // View Filelog shows unrestricted
    }

    //
    //  Short-circuit the common case where you are already at top-level.
    //
    if (ple->Parent() == _tree.GetRoot()) {
        return FALSE;               // You're looking at it already
    }

    //
    //  Watch out for the loopback scenario where you chase integrations
    //  out and then back in...
    //
    LPCTSTR pszRoot = SAFECAST(LogEntry *, _tree.GetRoot())->GetChildPath();
    LPCTSTR pszThis = SAFECAST(LogEntry *, ple->Parent())->GetChildPath();
    int cchRoot = lstrlen(pszRoot);

    if (StrCmpNI(pszRoot, pszThis, cchRoot) == 0 &&
        (pszThis[cchRoot] == TEXT('#') || pszThis[cchRoot] == TEXT('\0'))) {
        return FALSE;
    }

    return TRUE;
}

LRESULT CFileLog::_ViewFileLog(LogEntry *ple)
{
    if (!_IsViewFileLogEnabled(ple)) {
        return 0;
    }

    Substring ss;
    if (Parse(TEXT("$P"), SAFECAST(LogEntry *, ple->Parent())->GetChildPath(), &ss)) {
        String str;
        str << TEXT("-#") << ple->GetRev() << TEXT(" ") << ss;
        LaunchThreadTask(CFileLog_ThreadProc, str);
    }
    return 0;
}

LRESULT CFileLog::_ViewChangelist(LogEntry *ple)
{
    if (ple) {
        LaunchThreadTask(CDescribe_ThreadProc, ple->GetChange());
    }
    return 0;
}

LRESULT CFileLog::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_VIEWDESC:
        return _ViewChangelist(LEGetCurSel());

    case IDM_VIEWFILEDIFF:
        return _OnItemActivate(LEGetCurSel());

    case IDM_VIEWWINDIFF:
        WindiffChangelist(_GetChangeNumber(LEGetCurSel()));
        return 0;

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(LEGetCurSel());
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        break;

    case IDM_VIEWFILELOG:
        _ViewFileLog(LEGetCurSel());
        break;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

void CFileLog::_AdjustMenu(HMENU hmenu, LogEntry *ple, BOOL fContextMenu)
{
    AdjustBugMenu(hmenu, _GetBugNumber(ple), fContextMenu);

    // Disable IDM_VIEWFILELOG if it would just show you the same window
    // you're looking at right now.
    BOOL fEnable = _IsViewFileLogEnabled(ple);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILELOG, fEnable, fContextMenu);
}

LRESULT CFileLog::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), LEGetCurSel(), FALSE);
    return 0;
}

LRESULT CFileLog::_OnGetContextMenu(LogEntry *ple)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_FILELOG_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, ple, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

LRESULT CFileLog::_OnItemActivate(LogEntry *ple)
{
    if (ple) {
        LogEntry *pleParent = SAFECAST(LogEntry*, ple->Parent());

        // Trim the parent path to remove the sharp.
        String strPath(pleParent->GetChildPath());
        LPTSTR pszSharp = StrChr(strPath, TEXT('#'));
        if (pszSharp) {
            strPath.SetLength((int)(pszSharp - strPath));
        }

        // Append the version we care about
        strPath << TEXT('#') << ple->GetRev();

        // And ask windiff to view it

        WindiffOneChange(strPath);
    }
    return 0;
}

LRESULT CFileLog::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMTREELIST *ptl = RECAST(NMTREELIST*, lParam);
    LogEntry *ple;

    switch (ptl->hdr.code) {
    case TLN_GETDISPINFO:
        ple = SAFECAST(LogEntry*, ptl->pti);
        if (ptl->iSubItem < 0) {
            return ple->GetDispInfo(ptl, ptl->iSubItem);
        } else if (ptl->iSubItem < _pflc->_ccol) {
            return ple->GetDispInfo(ptl, _pflc->_rgColMap[ptl->iSubItem]);
        } else {
            ASSERT(0); // invalid column
            return 0;
        }

    case TLN_FILLCHILDREN:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return _FillChildren(ple, ple->GetChildPath());

    case TLN_ITEMACTIVATE:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return _OnItemActivate(ple);

    case TLN_GETINFOTIP:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return ple->GetInfoTip(ptl);

    case TLN_DELETEITEM:
        ple = SAFECAST(LogEntry*, ptl->pti);
        delete ple;
        return 0;

    case TLN_GETCONTEXTMENU:
        ple = SAFECAST(LogEntry*, ptl->pti);
        return _OnGetContextMenu(ple);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT
CFileLog::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(WM_NOTIFY);
    FW_MSG(FL_INITIALIZE);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  A private helper class that captures the parsing state machine.
//

class FileLogParseState : public CommentParser
{
public:
    FileLogParseState() : _pleCurrent(NULL), _pleInsertAfter(NULL) { }

    LogEntry *GetCurrentLogEntry() const { return _pleCurrent; }

    void Flush()
    {
        if (_pleCurrent) {
            //
            //  Trim the trailing CRLF off the last line of the full
            //  description.
            //
            _strFullDescription.Chomp();
            _pleCurrent->SetFullDescription(_strFullDescription);
            _pleCurrent = NULL;
        }
        _cAdded = _cDeleted = 0;
        CommentParser::Reset();
        _strFullDescription.Reset();
    }

    void AddEntry(Tree &tree, LogEntry *pleRoot, String& str, Substring *rgss)
    {
        LPCTSTR pszChildPath = pleRoot->GetChildPath();
        _strFullDescription.Append(pszChildPath, StrCSpn(pszChildPath, TEXT("#")));
        _strFullDescription << TEXT("\r\n") << str;
        LogEntry *ple = new LogEntry(rgss[0].Finalize(),    // Rev
                                     rgss[1].Finalize(),    // Change
                                     rgss[2].Finalize(),    // Op
                                     rgss[3].Finalize(),    // Date
                                     rgss[4].Finalize());   // Dev
        if (ple) {
            if (tree.Insert(ple, pleRoot, _pleInsertAfter)) {
                _pleInsertAfter = _pleCurrent = ple;
            } else {
                delete ple;
            }
        }
    }

    void AddLine(const String& str)
    {
        _strFullDescription << str;
    }

    void SetDev(LPCTSTR psz)
    {
        if (_pleCurrent) {
            _pleCurrent->SetDev(psz);
        }
    }

    void SetComment(LPCTSTR psz)
    {
        if (_pleCurrent) {
            _pleCurrent->SetComment(psz);
        }
    }


    void SetIntegrateType(LPCTSTR pszType, LPCTSTR pszDepotPath)
    {
        if (_pleCurrent) {
            _pleCurrent->SetIntegrateType(pszType);
            _pleCurrent->SetChildPath(pszDepotPath);
        }
    }

    void SetIsDonor()
    {
        if (_pleCurrent) {
            _pleCurrent->SetIsDonor();
        }
    }

    void AddedLines(LPCTSTR psz)
    {
        _cAdded += StrToInt(psz);
    }

    void DeletedLines(LPCTSTR psz)
    {
        _cDeleted += StrToInt(psz);
    }

    void SetChurn()
    {
        if (_pleCurrent) {
            _pleCurrent->SetChurn(_cAdded, _cDeleted);
        }
    }

    void ParseDiffResult(String& str)
    {
        Substring rgss[3];

        if (Parse(TEXT("add $d chunks $d"), str, rgss)) {
            AddedLines(rgss[1].Finalize());
        } else if (Parse(TEXT("deleted $d chunks $d"), str, rgss)) {
            DeletedLines(rgss[1].Finalize());
        } else if (Parse(TEXT("changed $d chunks $d / $d"), str, rgss)) {
            DeletedLines(rgss[1].Finalize());
            AddedLines(rgss[2].Finalize());
            SetChurn();
        }
    }

    BOOL GetFinishDiffCommand(LPCTSTR pszRootPath, String& str)
    {
        if (_pleCurrent && !_pleCurrent->IsChurnSet() && _pleCurrent->GetRev() > 1) {
            str = TEXT("diff2 -ds \"");
            int cchRootPath = StrCSpn(pszRootPath, TEXT("#"));
            str.Append(pszRootPath, cchRootPath);
            str << TEXT("#") << (_pleCurrent->GetRev() - 1) << TEXT("\" \"");
            str.Append(pszRootPath, cchRootPath);
            str << TEXT("#") <<  _pleCurrent->GetRev()      << TEXT("\"");
            return TRUE;
        } else {
            return FALSE;
        }
    }

private:
    int         _cAdded;
    int         _cDeleted;
    LogEntry   *_pleCurrent;
    LogEntry   *_pleInsertAfter;
    String      _strFullDescription;
};

BOOL CFileLog::_ParseQuery()
{
    String str;

    /*
     *  Parse the switches as best we can.
     *
     */
    str.Reset();
    GetOpt opt(TEXT("m#"), _pszQuery);
    for (;;) {

        switch (opt.NextSwitch()) {
        case TEXT('m'):
            _fIsRestrictedRoot = TRUE;
            str << TEXT("-m ") << opt.GetValue() << TEXT(" ");
            break;

        case TEXT('#'):
            _iHighlightRev = StrToInt(opt.GetValue());
            break;

        case TEXT('\0'):
            goto L_switch;    // two-level break

        default:
            // Caller will display help for us
            return FALSE;
        }
    }
L_switch:;

    _scSwitches = str;

    str.Reset();
    str << TEXT("sdv filelog ") << _scSwitches << opt.GetTokenizer().Unparsed();
    SetWindowText(_hwnd, str);

    /*
     *  There must be exactly one token remaining and it can't be a
     *  wildcard.
     */
    if (opt.Token() && opt.Finished() && !ContainsWildcards(opt.GetValue())) {
        _scPath = opt.GetValue();
        if (StrChr(_scPath, TEXT('#')) || StrChr(_scPath, TEXT('@'))) {
            _fIsRestrictedRoot = TRUE;
        }

    } else {
        return FALSE;
    }

    return TRUE;
}

LRESULT CFileLog::_FillChildren(LogEntry *pleRoot, LPCTSTR pszRootPath)
{
    LRESULT lres = 0;
    if (!pszRootPath[0]) {
        return -1;
    }

    WaitCursor wait;

    String str("filelog -l ");
    str << _scSwitches;
    if (IsChurnEnabled()) {
        str << TEXT("-ds ");
    }

    str << ResolveBranchAndQuoteSpaces(pszRootPath);

    SDChildProcess proc(str);
    FileLogParseState state;
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {

        Substring rgss[5];  // Rev, Change, Op, Date, Dev
        LPTSTR pszRest;

        if (Parse(TEXT("... #$d change $d $w on $D by $u"), str, rgss)) {
            state.Flush();
            state.AddEntry(_tree, pleRoot, str, rgss);
            if (state.GetCurrentLogEntry() &&
                state.GetCurrentLogEntry()->GetRev() == _iHighlightRev) {
                _pleHighlight = state.GetCurrentLogEntry();
            }
        } else if (Parse(TEXT("$P"), str, rgss)) {
            if (pleRoot->GetChildPath().IsEmpty()) {
                str.Chomp();
                pleRoot->SetChildPath(rgss[0].Finalize());
            }
        } else {
            state.AddLine(str);
            str.Chomp();
            if (str[0] == TEXT('\t')) {
                state.AddComment(str+1);
            } else if ((pszRest = Parse(TEXT("... ... $w from "), str, rgss)) != NULL) {
                state.SetIntegrateType(rgss[0].Finalize(), pszRest);
            } else if (Parse(TEXT("... ... $w into "), str, rgss) ||
                       Parse(TEXT("... ... ignored by "), str, rgss)) {
                state.SetIsDonor();

                // SUBTLE!  We check for "ignored" after "ignored by".
            } else if ((pszRest = Parse(TEXT("... ... ignored "), str, rgss)) != NULL) {
                state.SetIntegrateType("ignored", pszRest);
            } else {
                state.ParseDiffResult(str);
            }
        }
    }

    // "sd filelog -d" doesn't spit out a diff for the last guy,
    // so kick off a special one-shot "sd diff2" to get that diff.
    if (IsChurnEnabled() &&
        state.GetFinishDiffCommand(pszRootPath, str)) {
        SDChildProcess proc2(str);
        if (proc2.IsRunning()) {
            buf.Init(proc2.Handle());
            while (buf.NextLine(str)) {
                state.AddLine(str);
                state.ParseDiffResult(str);
            }
        }
    }

    state.Flush();

    return lres;
}

DWORD CALLBACK CFileLog_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new CFileLog, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\opened.cpp ===
/*****************************************************************************
 *
 *  opened.cpp
 *
 *      View the list of opened files and pending changes.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  OpenedEntry
 *
 *  We list the changes in descending numerical order, except that
 *  "default" goes at the top of the list (rather than at the bottom,
 *  which is what StrToInt would've given us).
 *
 *****************************************************************************/

MakeStringFormat(ChangeList)
MakeStringFormat(PendingOp)

class OpenedEntry : public TreeItem {

public:
    OpenedEntry(ChangeList clChange, LPCTSTR pszComment);
    OpenedEntry(PendingOp opOp, LPCTSTR pszFile);
    OpenedEntry() { }

    void SetComment(LPCTSTR pszComment) { _scComment = pszComment; }
    void SetFullDescription(LPCTSTR pszFullDescription) {  _scFullDescription = pszFullDescription; }

    LRESULT GetDispInfo(NMTREELIST *pdi, int iColumn);
    LRESULT GetInfoTip(NMTREELIST *pdi);

    LPCTSTR GetChange() const { return _scChange; }
    LPCTSTR GetComment() const { return _scComment; }
    int     GetOp() const { return _iOp; }
    UINT    GetSortKey() const { return _uiSort; }
    BOOL    IsAddLike() const { return _iOp == OP_ADD || _iOp == OP_BRANCH; }
    BOOL    IsDelLike() const { return _iOp == OP_DELETE; }
    BOOL    HasComment() const { return !_scComment.IsEmpty(); }

    static  UINT ComputeSortKey(LPCTSTR pszChange)
        { return (UINT)StrToInt(pszChange) - 1; }

    static  UINT SortKey_DefaultChange() { return (UINT)0-1; }

private:
    void GetImage(NMTREELIST *ptl);
private:
    UINT    _uiSort;                    // Sort key
    int     _iOp;                       // Checkin operation
    StringCache _scChange;              // Change number or operation
    StringCache _scComment;             // Checkin comment or path
    StringCache _scFullDescription;     // Full checkin description
};

OpenedEntry::OpenedEntry(ChangeList clChange, LPCTSTR pszComment)
    : _scChange(clChange)
    , _uiSort(ComputeSortKey(clChange))
    , _iOp(OP_EDIT)
    , _scComment(pszComment)
{
}

OpenedEntry::OpenedEntry(PendingOp opOp, LPCTSTR pszComment)
    : _scChange(opOp)
    , _iOp(ParseOp(opOp))
    , _scComment(pszComment)
{
}

void OpenedEntry::GetImage(NMTREELIST *ptl)
{
    if (_iOp > 0) {
        ptl->iSubItem = c_rgleim[_iOp]._iImage;
    } else {
        ptl->iSubItem = 0;
    }
}

LRESULT OpenedEntry::GetDispInfo(NMTREELIST *ptl, int iColumn)
{
    switch (iColumn) {
    case -1: GetImage(ptl); break;
    case 0: ptl->pszText = _scChange; break;
    case 1: ptl->pszText = _scComment; break;
    }
    return 0;
}


LRESULT OpenedEntry::GetInfoTip(NMTREELIST *ptl)
{
    ptl->pszText = _scFullDescription;
    return 0;
}

/*****************************************************************************
 *
 *  class COpened
 *
 *****************************************************************************/

class COpened : public TLFrame, public BGTask {

    friend DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    enum {
        OM_INITIALIZED = WM_APP
    };

    typedef TLFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_OM_INITIALIZED(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:                            /* Helpers */
    COpened() : TLFrame(new OpenedEntry)
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_OPENED));
    }

    OpenedEntry *OEGetCurSel() { return SAFECAST(OpenedEntry*, TLGetCurSel()); }

    LRESULT _FillChildren(OpenedEntry *pleRoot, LPCTSTR pszRootPath);
    LRESULT _OnItemActivate(OpenedEntry *ple);
    LRESULT _OnGetContextMenu(OpenedEntry *ple);

    BOOL _IsViewFileLogEnabled(OpenedEntry *ple);
    LRESULT _ViewFileLog(OpenedEntry *ple);
    void _AdjustMenu(HMENU hmenu, OpenedEntry *ple, BOOL fContextMenu);

    int _GetChangeNumber(OpenedEntry *ple);
    int _GetBugNumber(OpenedEntry *ple);

    static DWORD CALLBACK s_BGInvoke(LPVOID lpParam);
    DWORD _BGInvoke();
    LPCTSTR _BGParse(StringCache *pscUser);
    void _BGGetChanges(LPCTSTR pszUser);
    void _BGFillInChanges();
    OpenedEntry *_BGFindChange(LPCTSTR pszChange, BOOL fCreate);
    void _BGGetOpened(LPCTSTR pszArgs, LPCTSTR pszUser);

    BOOL  _IsChangeHeader(OpenedEntry *ple)
        { return ple && ple->Parent() == _tree.GetRoot(); }

    BOOL  _IsChangeFile(OpenedEntry *ple)
        { return ple && ple->Parent() != _tree.GetRoot(); }

private:
};

LRESULT COpened::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    static const LVFCOLUMN c_rgcol[] = {
        { 15 ,IDS_COL_CHANGE    ,LVCFMT_LEFT    },
        { 60 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    lres = super::HandleMessage(uiMsg, wParam, lParam);
    if (lres == 0 &&
        _tree.GetRoot() &&
        SetWindowMenu(MAKEINTRESOURCE(IDM_OPENED)) &&
        CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                    LVS_NOSORTHEADER,
                    LVS_EX_LABELTIP | LVS_EX_HEADERDRAGDROP |
                    LVS_EX_INFOTIP | LVS_EX_FULLROWSELECT) &&
        AddColumns(c_rgcol) &&
        BGStartTask(s_BGInvoke, this)) {
        SetWindowText(_hwnd, TEXT("sdv opened"));
    } else {
        lres = -1;
    }
    return lres;
}

int COpened::_GetBugNumber(OpenedEntry *ple)
{
    if (_IsChangeFile(ple)) {
        ple = SAFECAST(OpenedEntry *, ple->Parent());
    }

    if (ple) {
        return ParseBugNumber(ple->GetComment());
    } else {
        return 0;
    }
}

int COpened::_GetChangeNumber(OpenedEntry *ple)
{
    if (_IsChangeFile(ple)) {
        ple = SAFECAST(OpenedEntry *, ple->Parent());
    }

    if (ple) {
        return StrToInt(ple->GetChange());
    } else {
        return 0;
    }
}

BOOL COpened::_IsViewFileLogEnabled(OpenedEntry *ple)
{
    if (!_IsChangeFile(ple)) {
        return FALSE;               // not even a file!
    }

    //
    //  Some of the ops create files so there's nothing to see.
    //
    if (ple->IsAddLike()) {
        return FALSE;
    }

    return TRUE;
}

LRESULT COpened::_ViewFileLog(OpenedEntry *poe)
{
    if (!_IsViewFileLogEnabled(poe)) {
        return 0;
    }

    Substring ss;
    if (Parse(TEXT("$P"), poe->GetComment(), &ss)) {
        String str;
        str << TEXT("-#") << ss._pszMax << TEXT(" ") << ss;
        LaunchThreadTask(CFileLog_ThreadProc, str);
    }
    return 0;
}

LRESULT COpened::ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return BGFilterSetCursor(super::HandleMessage(uiMsg, wParam, lParam));
}

LRESULT COpened::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {

    case IDM_VIEWFILEDIFF:
        return _OnItemActivate(OEGetCurSel());

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(OEGetCurSel());
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        break;

    case IDM_VIEWFILELOG:
        _ViewFileLog(OEGetCurSel());
        break;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

void COpened::_AdjustMenu(HMENU hmenu, OpenedEntry *ple, BOOL fContextMenu)
{
    AdjustBugMenu(hmenu, _GetBugNumber(ple), fContextMenu);

    BOOL fEnable = _IsViewFileLogEnabled(ple);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILELOG, fEnable, fContextMenu);

    fEnable = _IsChangeFile(ple);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILEDIFF, fEnable, fContextMenu);

    MakeMenuPretty(hmenu);
}

LRESULT COpened::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), OEGetCurSel(), FALSE);
    return 0;
}

LRESULT COpened::_OnGetContextMenu(OpenedEntry *ple)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_OPENED_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, ple, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

LRESULT COpened::_OnItemActivate(OpenedEntry *ple)
{
    if (_IsChangeFile(ple)) {
        //
        //  Map the full depot path to a local file so we can pass it
        //  to windiff.  We can't use "sd diff" because that will fail
        //  on a borrowed enlistment.
        //
        String strLocal;
        if (MapToLocalPath(ple->GetComment(), strLocal)) {
            Substring ss;
            if (Parse(TEXT("$p"), strLocal, &ss)) {
                String str;
                str << TEXT("windiff ");
                if (ple->IsAddLike()) {
                    str << TEXT("nul ");
                } else {
                    str << QuoteSpaces(ple->GetComment());
                }
                str << TEXT(" ");
                if (ple->IsDelLike()) {
                    str << TEXT("nul ");
                } else {
                    str << QuoteSpaces(ss.Finalize());
                }
                SpawnProcess(str);
            }
        }
    }
    return 0;
}

LRESULT COpened::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMTREELIST *ptl = RECAST(NMTREELIST*, lParam);
    OpenedEntry *ple;

    switch (ptl->hdr.code) {
    case TLN_GETDISPINFO:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        if (ptl->iSubItem < 0) {
            return ple->GetDispInfo(ptl, ptl->iSubItem);
        } else if (ptl->iSubItem < 2) {
            return ple->GetDispInfo(ptl, ptl->iSubItem);
        } else {
            ASSERT(0); // invalid column
            return 0;
        }

    case TLN_ITEMACTIVATE:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        return _OnItemActivate(ple);

    case TLN_GETINFOTIP:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        return ple->GetInfoTip(ptl);

    case TLN_DELETEITEM:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        delete ple;
        return 0;

    case TLN_GETCONTEXTMENU:
        ple = SAFECAST(OpenedEntry*, ptl->pti);
        return _OnGetContextMenu(ple);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT COpened::ON_OM_INITIALIZED(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _tree.Expand(_tree.GetRoot());

    //
    //  Also expand the first changelist since it's usually what
    //  you are interested in.
    //
    TreeItem *pti = _tree.GetRoot()->FirstChild();
    if (pti) {
        _tree.Expand(pti);
    }

    return 0;
}

LRESULT
COpened::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_SETCURSOR);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(WM_NOTIFY);
    FW_MSG(OM_INITIALIZED);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  A private helper class that captures the parsing state machine.
//

class PendingChangesParseState
{
public:
    PendingChangesParseState() : _poeCurrent(NULL), _poeInsertAfter(NULL) { }

    OpenedEntry *GetCurrent() const { return _poeCurrent; }

    void Flush(Tree& tree)
    {
        if (_poeCurrent) {
            //
            //  Trim the trailing CRLF off the last line of the full
            //  description.
            //
            _strFullDescription.Chomp();
            _poeCurrent->SetFullDescription(_strFullDescription);
            tree.RedrawItem(_poeCurrent);
            _poeCurrent = NULL;
        }
        _fHaveComment = FALSE;
        _strFullDescription.Reset();
    }

    void AddEntry(Tree &tree, String& str, Substring *rgss)
    {
        OpenedEntry *poe = new OpenedEntry(ChangeList(rgss[0].Finalize()), // Change
                                           NULL);               // Comment
        if (poe) {
            if (tree.Insert(poe, tree.GetRoot(), _poeInsertAfter)) {
                _poeInsertAfter = _poeCurrent = poe;
            } else {
                delete poe;
            }
        }
    }

    void SetEntry(OpenedEntry *poe)
    {
        _poeCurrent = poe;
    }

    void AddLine(const String& str)
    {
        _strFullDescription << str;
    }

    //
    //  We cannot use the CommentParser because we don't have a Dev
    //  column; besides, we don't want to handle proxy checkins here.
    //  Show the real unfiltered checkin comment.
    //
    void AddComment(LPTSTR psz)
    {
        if (_fHaveComment) return;
        if (!_poeCurrent) return;

        //
        //  Ignore leading spaces.
        //
        while (*psz == TEXT('\t') || *psz == TEXT(' ')) psz++;

        //
        //  Skip blank description lines.
        //
        if (*psz == TEXT('\0')) return;

        //
        //  Use the first nonblank comment line as the text and toss the rest.
        //
        //  Change all tabs to spaces because listview doesn't like tabs.
        //
        ChangeTabsToSpaces(psz);

        _poeCurrent->SetComment(psz);
        _fHaveComment = TRUE;
    }

private:
    BOOL        _fHaveComment;
    OpenedEntry*_poeCurrent;
    OpenedEntry*_poeInsertAfter;
    String      _strFullDescription;
};

DWORD CALLBACK COpened::s_BGInvoke(LPVOID lpParam)
{
    COpened *self = RECAST(COpened *, lpParam);
    return self->_BGInvoke();
}

//
//  Returns unparsed string (or NULL)
//  and puts user name in pscUser.
//
//
LPCTSTR COpened::_BGParse(StringCache *pscUser)
{
    /*
     *  Parse the switches as best we can.
     *
     */
    GetOpt opt(TEXT("u"), _pszQuery);
    for (;;) {

        switch (opt.NextSwitch()) {
        case TEXT('u'):
            *pscUser = opt.GetValue();
            break;

        case TEXT('\0'):
            goto L_switch;    // two-level break

        default:
            // Caller will display help for us
            return NULL;
        }
    }
L_switch:;

    if (pscUser->IsEmpty()) {
        *pscUser = GlobalSettings.GetUserName();
    }

    String str;
    str << TEXT("sdv opened -u ") << *pscUser;
    SetWindowText(_hwnd, str);

    /*
     *  The rest goes to "sd opened".
     */
    return opt.GetTokenizer().Unparsed();
}

void COpened::_BGGetChanges(LPCTSTR pszUser)
{
    LPCTSTR pszClient = GlobalSettings.GetClientName();
    UINT cchClient = lstrlen(pszClient);

    String str;
    str << TEXT("changes -l -s pending");
    if (GlobalSettings.IsVersion(1, 60)) {
        str << TEXT(" -u ") << QuoteSpaces(pszUser);
    }

    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    PendingChangesParseState state;
    while (buf.NextLine(str)) {
        Substring rgss[4];          // changeno, date, domain\userid, client
        if (Parse(TEXT("Change $d on $D by $u@$w"), str, rgss)) {
            state.Flush(_tree);
            if (rgss[3].Length() == cchClient &&
                StrCmpNI(rgss[3].Start(), pszClient, cchClient) == 0) {
                state.AddLine(str);
                state.AddEntry(_tree, str, rgss);
            }
        } else if (state.GetCurrent()) {
            state.AddLine(str);
            if (str[0] == TEXT('\t')) {
                str.Chomp();
                state.AddComment(str);
            }
        }
    }
    state.Flush(_tree);
}

OpenedEntry *COpened::_BGFindChange(LPCTSTR pszChange, BOOL fCreate)
{
    UINT uiKey = OpenedEntry::ComputeSortKey(pszChange);
    OpenedEntry *poeInsertAfter = NULL;

    OpenedEntry *poe = SAFECAST(OpenedEntry *, _tree.GetRoot()->FirstChild());
    if (poe == PTI_ONDEMAND) {
        poe = NULL;
    }

    while (poe) {
        if (poe->GetSortKey() == uiKey) {
            return poe;
        }

        if (poe->GetSortKey() < uiKey) {
            break;
        }
        poeInsertAfter = poe;
        poe = SAFECAST(OpenedEntry *, poe->NextSibling());
    }

    //
    //  Create it if necessary.  (We always create "default".)
    //
    if (fCreate || StrCmp(pszChange, TEXT("default")) == 0) {
        poe = new OpenedEntry(ChangeList(pszChange), NULL);
        if (poe) {
            if (_tree.Insert(poe, _tree.GetRoot(), poeInsertAfter)) {
                return poe;
            }
            delete poe;
        }
    }
    return NULL;
}


void COpened::_BGGetOpened(LPCTSTR pszArgs, LPCTSTR pszUser)
{
    String str, strOrig;
    str << TEXT("opened ") << pszArgs;

    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {
        Substring rgss[6];          // path, version, op, changeno, type, user
        LPTSTR pszRest = Parse(TEXT("$P#$d - $w "), str, rgss);
        if (pszRest) {
            strOrig = str;

            rgss[1].Finalize();             // End of revision (path#version)

            //
            //  Parsing is such sweet sorrow.
            //
            //  "default change" but "change 1234".
            //
            LPTSTR pszRest2;
            if ((pszRest2 = Parse(TEXT("change $d $w"), pszRest, &rgss[3])) ||
                (pszRest2 = Parse(TEXT("$w change $w"), pszRest, &rgss[3]))) {
                *pszRest2++ = TEXT('\0'); // relies on the fact that we didn't chomp
                if (Parse(TEXT("by $p"), pszRest2, &rgss[5])) {
                    // Some nondefault user, how about that
                    rgss[5].Finalize();
                } else {
                    // Default user
                    rgss[5].SetStart(GlobalSettings.GetUserName());
                }
                if (lstrcmpi(rgss[5].Start(), pszUser) == 0) {
                    OpenedEntry *poeParent = _BGFindChange(rgss[3].Finalize(), pszArgs[0]);
                    if (poeParent) {
                        OpenedEntry *poe = new OpenedEntry(PendingOp(rgss[2].Finalize()),
                                                           rgss[0].Start());
                        if (poe) {
                            if (_tree.Insert(poe, poeParent, PTI_APPEND)) {
                                strOrig.Chomp();
                                poe->SetFullDescription(strOrig);
                            } else {
                                delete poe;
                            }
                        }
                    }
                }
            }
        }
    }
}

void COpened::_BGFillInChanges()
{
    String str;
    str << TEXT("describe -s ");
    BOOL fAnyChanges = FALSE;

    OpenedEntry *poe = SAFECAST(OpenedEntry *, _tree.GetRoot()->FirstChild());
    if (poe == PTI_ONDEMAND) {
        poe = NULL;
    }

    while (poe) {
        if (poe->GetSortKey() != OpenedEntry::SortKey_DefaultChange() &&
            !poe->HasComment()) {
            str << poe->GetChange() << TEXT(" ");
            fAnyChanges = TRUE;
        }
        poe = SAFECAST(OpenedEntry *, poe->NextSibling());
    }

    if (fAnyChanges) {
        SDChildProcess proc(str);
        IOBuffer buf(proc.Handle());
        PendingChangesParseState state;
        while (buf.NextLine(str)) {
            Substring rgss[4];          // changeno, domain\userid, client, date
            if (Parse(TEXT("Change $d by $u@$w on $D"), str, rgss)) {
                state.Flush(_tree);
                state.AddLine(str);
                OpenedEntry *poe = _BGFindChange(rgss[0].Finalize(), FALSE);
                state.SetEntry(poe);
            } else if (state.GetCurrent()) {
                if (str[0] == TEXT('A')) {      // "Affected files"
                    state.Flush(_tree);
                } else {
                    state.AddLine(str);
                    if (str[0] == TEXT('\t')) {
                        str.Chomp();
                        state.AddComment(str);
                    }
                }
            }
        }
        state.Flush(_tree);
    }
}


DWORD COpened::_BGInvoke()
{
    StringCache scUser;
    LPCTSTR pszUnparsed = _BGParse(&scUser);
    if (pszUnparsed) {
        //  If no parameters, then go hunt down all the changelists
        //  so we can find the empty ones, too.  Otherwise, we will
        //  figure them out as we see the results of "sd opened".
        if (!*pszUnparsed) {
            _BGGetChanges(scUser);
        }
        _BGGetOpened(pszUnparsed, scUser);
        PostMessage(_hwnd, OM_INITIALIZED, 0, 0);
        _BGFillInChanges();
    } else {
        Help(_hwnd, TEXT("#opene"));
        PostMessage(_hwnd, WM_CLOSE, 0, 0);
    }
    BGEndTask();
    return 0;
}

DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new COpened, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\describe.cpp ===
/*****************************************************************************
 *
 *  describe.cpp
 *
 *      View a changelist a description.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  class CDescribe
 *
 *****************************************************************************/

//
//  The LPARAM of the listview item has the following form:
//
//  HIWORD = enum CATEGORY
//  LOWORD = original index (to break ties during sorting)
//
enum CATEGORY {
    CAT_HEADER,                 // changelist header
    CAT_MATCHED,                // file that matches the pattern
    CAT_BLANK1,                 // separates matched from unmatched
    CAT_UNMATCHED,              // files that don't match the pattern
    CAT_BLANK2,                 // separates unmatched from unchanged
    CAT_UNCHANGED,              // unmatched files that weren't change
};

class CDescribe : public LVFrame, public BGTask {

    friend DWORD CALLBACK CDescribe_ThreadProc(LPVOID lpParameter);

protected:
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    enum {
        DM_RECALC = WM_APP
    };

    typedef LVFrame super;

    LRESULT ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_DM_RECALC(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:                            /* Helpers */
    CDescribe()
    {
        SetAcceleratorTable(MAKEINTRESOURCE(IDA_DESCRIBE));
    }

    void _ResetChildWidth();
    void _AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu);
    LPTSTR _GetSanitizedLine(int iItem, LPTSTR pszBuf, UINT cch);
    void ViewOneFile();
    void ViewFileLog();
    int _GetBugNumber(int iItem, BOOL fContextMenu);

    static LPTSTR _SanitizeClipboardText(LPTSTR psz);

    static DWORD CALLBACK s_BGInvoke(LPVOID lpParam);
    DWORD _BGInvoke();

private:
    int         _cxMax;
    int         _iBug;
    Substring   _ssChange;
};

LRESULT CDescribe::ON_WM_CREATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    static const LVFCOLUMN s_rgcol[] = {
        { 30 ,IDS_COL_COMMENT   ,LVCFMT_LEFT    },
        {  0 ,0                 ,0              },
    };

    LRESULT lres;

    if (Parse(TEXT("$d"), _pszQuery, &_ssChange)) {
        String str;
        str << TEXT("sdv describe ") << _ssChange;
        SetWindowText(_hwnd, str);

        lres = super::HandleMessage(uiMsg, wParam, lParam);
        if (lres == 0 &&
            SetWindowMenu(MAKEINTRESOURCE(IDM_DESCRIBE)) &&
            CreateChild(LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS |
                        LVS_NOCOLUMNHEADER,
                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT) &&
            AddColumns(s_rgcol) &&
            (SetWindowRedraw(_hwndChild, FALSE), TRUE) &&
            BGStartTask(s_BGInvoke, this)) {
        } else {
            lres = -1;
        }
    } else {
        Help(_hwnd, TEXT("#descr"));
        lres = -1;
    }
    return lres;
}

LRESULT CDescribe::ON_WM_SETCURSOR(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return BGFilterSetCursor(super::HandleMessage(uiMsg, wParam, lParam));
}

LPTSTR CDescribe::_GetSanitizedLine(int iItem, LPTSTR pszBuf, UINT cch)
{
    LPTSTR pszPath = NULL;
    if (iItem >= 0 &&
        ListView_GetItemText(_hwndChild, iItem, pszBuf, cch)) {
        LPTSTR psz =_SanitizeClipboardText(pszBuf);
        if (psz != pszBuf) {
            pszPath = psz;
        }
    }
    return pszPath;
}

void CDescribe::ViewOneFile()
{
    TCHAR sz[MAX_PATH];
    LPTSTR pszPath = _GetSanitizedLine(GetCurSel(), sz, ARRAYSIZE(sz));
    if (pszPath) {
        WindiffOneChange(pszPath);
    }
}

void CDescribe::ViewFileLog()
{
    TCHAR sz[MAX_PATH];
    LPTSTR pszPath = _GetSanitizedLine(GetCurSel(), sz, ARRAYSIZE(sz));
    if (pszPath) {
        String str;
        LPTSTR pszSharp = StrChr(pszPath, TEXT('#'));
        if (pszSharp) {
            *pszSharp++ = TEXT('\0');
            str << TEXT("-#") << pszSharp << TEXT(' ');
        }
        str << pszPath;
        LaunchThreadTask(CFileLog_ThreadProc, str);
    }
}

LRESULT CDescribe::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iChange, iBug;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_VIEWFILEDIFF:
        ViewOneFile();
        return 0;

    case IDM_VIEWWINDIFF:
        WindiffChangelist(StrToInt(_ssChange._pszMin));
        return 0;

    case IDM_VIEWBUG:
        iBug = _GetBugNumber(GetCurSel(), FALSE);
        if (iBug) {
            OpenBugWindow(_hwnd, iBug);
        }
        break;

    case IDM_VIEWFILELOG:
        ViewFileLog();
        break;

    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  Execute the default context menu item.
//
LRESULT CDescribe::ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu = RECAST(HMENU, ON_LM_GETCONTEXTMENU(LM_GETCONTEXTMENU, wParam, 0));
    if (hmenu) {
        FORWARD_WM_COMMAND(_hwnd, GetMenuItemID(hmenu, 0), NULL, 0, SendMessage);
        DestroyMenu(hmenu);
    }
    return 0;
}

int CDescribe::_GetBugNumber(int iItem, BOOL fContextMenu)
{
    LPARAM lParam = RECAST(LPARAM, GetLVItem(iItem));
    int iBug = 0;
    if (HIWORD(lParam) == CAT_HEADER && iItem != 0) {
        iBug = ParseBugNumberFromSubItem(_hwndChild, iItem, 0);
    }

    // If no bug number on the selection, use the default bug number
    // for this changelist.

    if (iBug == 0 && !fContextMenu) {
        iBug = _iBug;
    }

    return iBug;
}

void CDescribe::_AdjustMenu(HMENU hmenu, int iItem, BOOL fContextMenu)
{
    TCHAR sz[MAX_PATH];
    sz[0] = TEXT('\0');
    if (iItem >= 0) {
        ListView_GetItemText(_hwndChild, iItem, sz, ARRAYSIZE(sz));
    }

    //
    //  Disable IDM_VIEWFILEDIFF and IDM_VIEWFILELOG
    //  if this is not a "..." item.
    //
    BOOL fEnable = (Parse(TEXT("... "), sz, NULL) != NULL);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILEDIFF, fEnable, fContextMenu);
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWFILELOG, fEnable, fContextMenu);

    //
    //  If a context menu, then nuke IDM_VIEWWINDIFF if this is not
    //  the "Change" item.
    //

    if (fContextMenu && iItem != 0) {
        DeleteMenu(hmenu, IDM_VIEWWINDIFF, MF_BYCOMMAND);
    }

    AdjustBugMenu(hmenu, _GetBugNumber(iItem, fContextMenu), fContextMenu);

    MakeMenuPretty(hmenu);
}

LRESULT CDescribe::ON_WM_INITMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    _AdjustMenu(RECAST(HMENU, wParam), GetCurSel(), FALSE);
    return 0;
}

LRESULT CDescribe::ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HMENU hmenu = LoadPopupMenu(MAKEINTRESOURCE(IDM_DESCRIBE_POPUP));
    if (hmenu) {
        _AdjustMenu(hmenu, (int)wParam, TRUE);
    }
    return RECAST(LRESULT, hmenu);
}

//
//  If the line begins "...", then strip off everything except for the
//  depot specification.
//
LPTSTR CDescribe::_SanitizeClipboardText(LPTSTR psz)
{
    Substring rgss[2];
    if (Parse(TEXT("... $P#$d"), psz, rgss)) {
        *(rgss[1]._pszMax) = TEXT('\0');
        return rgss[0].Start();
    } else {
        return psz;
    }
}

LRESULT CDescribe::ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    String str;
    TCHAR sz[MAX_PATH];

    int iMin = (int)wParam;
    int iMax = (int)lParam;

    // If a single-line copy, then special rules apply
    if (iMin + 1 == iMax) {
        if (ListView_GetItemText(_hwndChild, iMin, sz, ARRAYSIZE(sz))) {
            str << _SanitizeClipboardText(sz);
        }
    } else {
        for (int iItem = iMin; iItem < iMax; iItem++) {
            if (ListView_GetItemText(_hwndChild, iItem, sz, ARRAYSIZE(sz))) {
                str << sz;
            }
            str << TEXT("\r\n");
        }
    }
    SetClipboardText(_hwnd, str);
    return 0;
}

LRESULT CDescribe::ON_DM_RECALC(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    ListView_SetColumnWidth(_hwndChild, 0, LVSCW_AUTOSIZE);
    _cxMax = ListView_GetColumnWidth(_hwndChild, 0);
    _ResetChildWidth();

    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARTIAL;
    lvfi.psz = TEXT("...");

    int iFirst = ListView_FindItem(_hwndChild, -1, &lvfi);
    if (iFirst >= 0) {
        ListView_SetCurSel(_hwndChild, iFirst);
    }

    SetWindowRedraw(_hwndChild, TRUE);

    return 0;
}

void CDescribe::_ResetChildWidth()
{
    RECT rc;
    GetClientRect(_hwndChild, &rc);
    int cxMargins = GetSystemMetrics(SM_CXEDGE) * 2;
    int cxCol = max(_cxMax + cxMargins, rc.right);
    ListView_SetColumnWidth(_hwndChild, 0, cxCol);
}

LRESULT CDescribe::ON_WM_SIZE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    super::HandleMessage(uiMsg, wParam, lParam);
    if (_cxMax) {
        _ResetChildWidth();
    }
    return 0;
}

LRESULT
CDescribe::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_CREATE);
    FW_MSG(WM_SETCURSOR);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_INITMENU);
    FW_MSG(WM_SIZE);
    FW_MSG(LM_ITEMACTIVATE);
    FW_MSG(LM_GETCONTEXTMENU);
    FW_MSG(LM_COPYTOCLIPBOARD);
    FW_MSG(DM_RECALC);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

//
//  A private helper class that captures the parsing state machine.
//

class DescribeParseState
{
    enum PHASE {
        PHASE_HEADERS,              // collecting the header
        PHASE_FILES,                // collecting the files
        PHASE_DIFFS,                // collecting the diffs
    };

public:
    DescribeParseState(HWND hwndChild, LPCTSTR pszPattern)
        : _m(pszPattern)
        , _hwndChild(hwndChild)
        , _iPhase(PHASE_HEADERS)
        , _iLine(0)
        , _iMatch(-1)
        , _iBug(0)
        , _fAnyMatch(FALSE) { }

    void AddLine(LPTSTR psz, int iCat)
    {
        LVITEM lvi;
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = _iLine;
        lvi.iSubItem = 0;
        lvi.pszText = psz;
        lvi.lParam = MAKELONG(_iLine, iCat);
        _iLine++;

        ChangeTabsToSpaces(psz);

        ListView_InsertItem(_hwndChild, &lvi);
    }

    void SetMatchLine(LPTSTR psz)
    {
        // Turn the "====" into "..." so we can search for it
        LPTSTR pszDots = psz+1;
        pszDots[0] = TEXT('.');
        pszDots[1] = TEXT('.');
        pszDots[2] = TEXT('.');

        LPTSTR pszSharp = StrChr(pszDots, TEXT('#'));
        if (!pszSharp) return;
        pszSharp[1] = TEXT('\0');   // this wipes out the thing after the '#'

        LVFINDINFO lvfi;
        lvfi.flags = LVFI_PARTIAL;
        lvfi.psz = pszDots;

        _iMatch = ListView_FindItem(_hwndChild, 0, &lvfi);

        if (_iMatch >= 0) {
            _cAdded = _cDeleted = 0;
        }
    }

    void FlushMatch()
    {
        if (_iMatch >= 0) {
            String str;
            str.Grow(MAX_PATH-1);
            LVITEM lvi;
            lvi.iItem = _iMatch;
            lvi.mask = LVIF_TEXT | LVIF_PARAM;
            lvi.iSubItem = 0;
            lvi.pszText = str;
            lvi.cchTextMax = str.BufferLength();
            if (ListView_GetItem(_hwndChild, &lvi)) {
                str.SetLength(lstrlen(str));
                str << TEXT(" (") << _cDeleted << TEXT('/') << _cAdded << TEXT(")");
                lvi.pszText = str;
                if (_cDeleted + _cAdded == 0) {
                    lvi.lParam = MAKELONG(LOWORD(lvi.lParam), CAT_UNCHANGED);
                }
                ListView_SetItem(_hwndChild, &lvi);
            }
            _iMatch = -1;
        }
    }

    void ParseLine(String& str)
    {
        Substring rgss[3];

        switch (_iPhase) {
        case PHASE_HEADERS:
            if (Parse(TEXT("... "), str, NULL)) {
                _iPhase = PHASE_FILES;
                goto L_PHASE_FILES;
            }
            if (_iBug == 0 && str[0] == TEXT('\t')) {
                _iBug = ParseBugNumber(str);
            }
            AddLine(str, CAT_HEADER);
            break;

        case PHASE_FILES:
            if (Parse(TEXT("... "), str, NULL)) {
L_PHASE_FILES:
                int iCat;
                if (_m.Matches(str + 4)) {
                    _fAnyMatch = TRUE;
                    iCat = CAT_MATCHED;
                } else {
                    iCat = CAT_UNMATCHED;
                }
                AddLine(str, iCat);
            } else {
                _iPhase = PHASE_DIFFS;
            }
            break;

        case PHASE_DIFFS:
            if (Parse(TEXT("==== "), str, NULL)) {
                SetMatchLine(str);
            } else if (Parse(TEXT("add $d chunks $d lines"), str, rgss)) {
                _cAdded += StrToInt(rgss[1].Finalize());
            } else if (Parse(TEXT("deleted $d chunks $d lines"), str, rgss)) {
                _cDeleted += StrToInt(rgss[1].Finalize());
            } else if (Parse(TEXT("changed $d chunks $d / $d lines"), str, rgss)) {
                _cDeleted += StrToInt(rgss[1].Finalize());
                _cAdded += StrToInt(rgss[2].Finalize());
                FlushMatch();
            }
            break;
        }
    }

    int Finish()
    {
        if (_fAnyMatch) {
            AddLine(TEXT(""), CAT_BLANK1);
        }
        AddLine(TEXT(""), CAT_BLANK2);
        ListView_SortItems(_hwndChild, s_Compare, 0);

        return _iBug;
    }

    static int CALLBACK s_Compare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
    {
        return (int)(lParam1 - lParam2);
    }

private:
    Match       _m;
    HWND        _hwndChild;
    int         _iPhase;
    int         _iLine;
    int         _iMatch;
    int         _iBug;
    int         _cAdded;
    int         _cDeleted;
    BOOL        _fAnyMatch;
};

DWORD CALLBACK CDescribe::s_BGInvoke(LPVOID lpParam)
{
    CDescribe *self = RECAST(CDescribe *, lpParam);
    return self->_BGInvoke();
}

DWORD CDescribe::_BGInvoke()
{
    DescribeParseState state(_hwndChild, _ssChange._pszMax);

    String str;
    str << TEXT("describe ");
    if (GlobalSettings.IsChurnEnabled()) {
        str << TEXT("-ds ");
    } else {
        str << TEXT("-s ");
    }
    str << _ssChange;

    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {
        str.Chomp();
        state.ParseLine(str);
    }

    _iBug = state.Finish();

    PostMessage(_hwnd, DM_RECALC, 0, 0);

    BGEndTask();
    return 0;
}

DWORD CALLBACK CDescribe_ThreadProc(LPVOID lpParameter)
{
    return FrameWindow::RunThread(new CDescribe, lpParameter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\match.cpp ===
/*****************************************************************************
 *
 *  match.cpp
 *
 *      Highly-specialized depot path matching class
 *
 *****************************************************************************/

#include "sdview.h"

Match::Match(LPCTSTR pszPattern)
{
    Tokenizer tok(pszPattern);
    String str, strPath, strPats;

    while (tok.Token(str)) {
        if (MapToFullDepotPath(str, strPath)) {
            _AddPattern(strPath, strPats);
        }
    }

    _pszzPats = new TCHAR[strPats.Length()];
    if (_pszzPats) {
        CopyMemory(_pszzPats, strPats, strPats.Length() * sizeof(TCHAR));
        _pszEnd = _pszzPats + strPats.Length();
    }
}

BOOL Match::Matches(LPCTSTR pszPath)
{
    LPCTSTR pszPat;

    if (_pszzPats) {
        for (pszPat = _pszzPats;
             pszPat < _pszEnd; pszPat += lstrlen(pszPat) + 1) {
            if (_Matches(pszPat, pszPath)) {
                return TRUE;
            }
        }
    }
    return FALSE;
}

#define PAT_END     ((TCHAR)0)
#define PAT_START   ((TCHAR)1)
#define PAT_DOTS    ((TCHAR)2)
#define PAT_STAR    ((TCHAR)3)
#define PAT_BRANCH  ((TCHAR)4)

#define MAX_BACKTRACK 20 // totally arbitrary

void Match::_AddPattern(LPTSTR pszPat, String& strPats)
{
    CharLower(pszPat);

    //
    //  "compile" the pattern by changing "..." to PAT_DOTS and
    //  "%1" and "*" to PAT_STAR.
    //
    //  Oh, and change "//depot/blah/" and "//depot/private/blah/" to
    //  "//depot/<PAT_BRANCH>" so we can track across branches.
    //
    LPTSTR pszIn, pszOut;
    int iWildcards = 0;
    int cSlashes = 0;
    TCHAR pat;
    pszIn = pszOut = pszPat;
    for (;;) {
        switch (*pszIn) {
        case TEXT('\r'):
        case TEXT('\n'):
        case TEXT('\0'):
            goto endcompile;

        case TEXT('.'):
            if (pszIn[1] == TEXT('.') && pszIn[2] == TEXT('.')) {
                pszIn += 3;
                pat = PAT_DOTS;
                goto L_wildcard;
            } else {
                goto L_default;
            }
            break;

        case TEXT('%'):
            if ((UINT)(pszIn[1] - TEXT('1')) < 9) {
                pszIn += 2;
                pat = PAT_STAR;
                goto L_wildcard;
            } else {
                goto L_default;
            }
            break;

        case TEXT('*'):
            pszIn++;
            pat = PAT_STAR;
            goto L_wildcard;

        L_wildcard:
            //
            //  Collapse consecutive wildcards for perf.  Otherwise
            //  a search string of a****b will take exponential
            //  time.
            //
            if (pszOut[-1] == pat) {
                // ** and ...... are the same as * and ... (respectively)
                // so just throw away the second wildcard.
            } else if (pszOut[-1] == (PAT_STAR + PAT_DOTS - pat)) {
                // ...* and *... are the same as "..."
                pszOut[-1] = PAT_DOTS;
            } else if (iWildcards++ < MAX_BACKTRACK) {
                // just a regular ol' wildcard
                *pszOut++ = pat;
            } else {
                *pszOut++ = PAT_DOTS;   // Give up when the limit is reached
                goto endcompile;
            }
            break;

        case TEXT('/'):
            cSlashes++;
            if (cSlashes == 3) {
                if (StringBeginsWith(pszIn, TEXT("/private/"))) {
                    // a private branch
                    *pszOut++ = PAT_BRANCH;
                    pszIn += 9;     // length of "/private/"
                } else {
                    // a main branch
                    *pszOut++ = PAT_BRANCH;
                }
                // Skip over the branch name
                while (*pszIn != TEXT('/') &&
                       *pszIn != TEXT('\r') &&
                       *pszIn != TEXT('\n') &&
                       *pszIn != TEXT('\0')) {
                    pszIn++;
                }
            } else {
                goto L_default;
            }
            break;

        L_default:
        default:
            *pszOut++ = *pszIn++;
        }
    }
endcompile:;
    *pszOut++ = PAT_END;

    // Now add it to the list of patterns we care about
    strPats << PAT_START << Substring(pszPat, pszOut);
}

//
//  This is the fun part -- funky pattern matching.
//
//  The pszPath is assumed to be of the form
//
//      //depot/fully/qualified/path#n
//
//  PAT_DOTS matches any string.
//  PAT_STAR matches any string not including slash.
//
//  This code is adapted from code I wrote back in 1993 for the
//  Windows 95 Netware emulation layer.  I've also seen it stolen
//  by Wininet.  I guess good code never dies.  Or maybe it's just
//  that pattern matching is hard.  (I suspect the latter because
//  the Wininet folks stole the code and then adapted it incorrectly.)
//
BOOL Match::_Matches(LPCTSTR pszPat, LPCTSTR pszPath)
{
    struct Backtrack {
        int iStart;
        int iEnd;
    };

    Backtrack rgbt[MAX_BACKTRACK+1]; /* +1 for PAT_START fake-backtrack point */
    Backtrack *pbt = rgbt;

    int i, j;      /* i = index to pattern, j = index to target */
    int m = lstrlen(pszPath);   /* m = length of target */
    int back;      /* First available slot in backtrack array */
    i = -1;        /* Will be advanced to 0 */
    j = 0;

advance:
    ++i;
    switch (pszPat[i]) {
    case PAT_START:  pbt->iEnd = 0; goto advance;
    case PAT_END:    if (pszPath[j] == TEXT('#')) return TRUE;
                     else goto retreat;

    case PAT_DOTS:   pbt++; // this is a backtracking rule
                     pbt->iStart = j;
                     pbt->iEnd = j = m; goto advance;


    case PAT_STAR:   pbt++; // this is a backtracking rule
                     pbt->iStart = j;
                     while (pszPath[j] != TEXT('/') &&
                            pszPath[j] != TEXT('#') &&
                            pszPath[j] != TEXT('\0')) {
                        j++;
                     }
                     pbt->iEnd = j; goto advance;

    case PAT_BRANCH:        // this is a non-backtracking rule
                     if (pszPath[j] != TEXT('/')) goto retreat;
                     if (StringBeginsWith(&pszPath[j], TEXT("/private/"))) {
                        j += 8;
                     }
                     // Skip over the branch name
                     do {
                        j++;
                     } while (pszPath[j] != TEXT('/') &&
                              pszPath[j] != TEXT('#') &&
                              pszPath[j] != TEXT('\0'));
                     goto advance;

    default:         if (pszPath[j] == pszPat[i]) {
                        j++;
                        goto advance;
                     } else if (pszPath[j] >= TEXT('A') &&
                                pszPath[j] <= TEXT('Z') &&
                                pszPath[j] - TEXT('A') + TEXT('a') == pszPat[i]) {
                        // I hate case-insensitivity
                        j++;
                        goto advance;
                     } else goto retreat;
    }

retreat:
    --i;
    switch (pszPat[i]) {
    case PAT_START:  return FALSE;  // cannot backtrack further
    case PAT_DOTS:
    case PAT_STAR:   if (pbt->iStart == pbt->iEnd) {
                        pbt--;
                        goto retreat;
                     }
                     j = --pbt->iEnd; goto advance;
    default:         goto retreat;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\pipe.cpp ===
/*****************************************************************************
 *
 *  pipe.cpp
 *
 *      Run a command, reading its output.
 *
 *****************************************************************************/

#include "sdview.h"

void ChildProcess::Start(LPCTSTR pszCommand)
{
    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    HANDLE hWrite;
    BOOL fSuccess = CreatePipe(&_hRead, &hWrite, &sa, 0);
    if (fSuccess) {
        STARTUPINFO si = { 0 };
        PROCESS_INFORMATION pi;
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = hWrite;

        // Dup stdout to stderr in case client closes one of them.
        if (DuplicateHandle(GetCurrentProcess(), hWrite,
                            GetCurrentProcess(), &si.hStdError, 0,
                            TRUE, DUPLICATE_SAME_ACCESS)) {

            TCHAR szCommand[MAX_PATH];
            lstrcpyn(szCommand, pszCommand, ARRAYSIZE(szCommand));

            fSuccess = CreateProcess(NULL, szCommand, NULL, NULL, TRUE,
                                     CREATE_NEW_PROCESS_GROUP | CREATE_NO_WINDOW | DETACHED_PROCESS,
                                     NULL, NULL, &si, &pi);

            if (fSuccess) {
                CloseHandle(pi.hThread);
                _hProcess = pi.hProcess;
                _dwPid = pi.dwProcessId;
            }

            CloseHandle(si.hStdError);
        }
        CloseHandle(hWrite);

    }
}

void ChildProcess::Stop()
{
    if (_hProcess) {
        CloseHandle(_hProcess);
        _hProcess = NULL;
    }

    if (_hRead) {
        CloseHandle(_hRead);
        _hRead = NULL;
    }

    _dwPid = 0;
}

void ChildProcess::Kill()
{
    if (_dwPid) {
        GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, _dwPid);
    }
}

SDChildProcess::SDChildProcess(LPCTSTR pszCommand)
{
    String str;
    str << QuoteSpaces(GlobalSettings.GetSdPath()) << TEXT(" ") <<
                       GlobalSettings.GetSdOpts() << TEXT(" ");

    if (!GlobalSettings.GetFakeDir().IsEmpty()) {
        str << TEXT("-d ") << QuoteSpaces(GlobalSettings.GetFakeDir()) << TEXT(" ");
    }

    str << pszCommand;
    Start(str);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\parse.cpp ===
/*****************************************************************************
 *
 *  parse.cpp
 *
 *      Lame string parser.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  Ctype stuff
 *
 *  The vast majority of characters we encounter are below 128, so use fast
 *  table lookup for those.
 *
 *****************************************************************************/

const BYTE c_rgbCtype[128] = {

    C_NONE , C_NONE , C_NONE , C_NONE , // 00-03
    C_NONE , C_NONE , C_NONE , C_NONE , // 04-07
    C_NONE , C_NONE , C_NONE , C_NONE , // 08-0B
    C_NONE , C_NONE , C_NONE , C_NONE , // 0C-0F
    C_NONE , C_NONE , C_NONE , C_NONE , // 10-13
    C_NONE , C_NONE , C_NONE , C_NONE , // 14-17
    C_NONE , C_NONE , C_NONE , C_NONE , // 18-1B
    C_NONE , C_NONE , C_NONE , C_NONE , // 1C-1F

    C_SPACE, C_NONE , C_NONE , C_NONE , // 20-23
    C_NONE , C_NONE , C_NONE , C_NONE , // 24-27
    C_NONE , C_NONE , C_NONE , C_BRNCH, // 28-2B
    C_NONE , C_DASH , C_NONE , C_BRNCH, // 2C-2F
    C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, // 30-33
    C_DIGIT, C_DIGIT, C_DIGIT, C_DIGIT, // 34-37
    C_DIGIT, C_DIGIT, C_NONE , C_NONE , // 38-3B
    C_NONE , C_NONE , C_NONE , C_NONE , // 3C-3F

    C_NONE , C_ALPHA, C_ALPHA, C_ALPHA, // 40-43
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 44-47
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 48-4B
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 4C-4F
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 50-53
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 54-57
    C_ALPHA, C_ALPHA, C_ALPHA, C_NONE , // 58-5B
    C_NONE , C_NONE , C_NONE , C_BRNCH, // 5C-5F

    C_NONE , C_ALPHA, C_ALPHA, C_ALPHA, // 60-63
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 64-67
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 68-6B
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 6C-6F
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 70-73
    C_ALPHA, C_ALPHA, C_ALPHA, C_ALPHA, // 74-77
    C_ALPHA, C_ALPHA, C_ALPHA, C_NONE , // 78-7B
    C_NONE , C_NONE , C_NONE , C_NONE , // 7C-7F

};

/*****************************************************************************
 *
 *  _ParseP
 *
 *      Parse a partial depot path.
 *
 *      A partial depot path extends up to the next "#" or "@".
 *
 *      If we find a "//", ":", or "\\" (double backslash) then we have
 *      gone too far and started parsing something else, so backtrack to
 *      the end of the previous word.
 *
 *      A full depot path is a partial depot path that begins with
 *      two slashes.
 *
 *****************************************************************************/

LPCTSTR _ParseP(LPCTSTR pszParse, Substring *rgss)
{
    rgss->SetStart(pszParse);

    LPCTSTR pszLastSpace = NULL;

    while (*pszParse && *pszParse != TEXT('#') && *pszParse != TEXT('@')) {
        if (pszLastSpace) {
            if ((pszParse[0] == TEXT('/') && pszParse[1] == TEXT('/')) ||
                (pszParse[0] == TEXT('\\') && pszParse[1] == TEXT('\\')) ||
                (pszParse[0] == TEXT(':'))) {
                // Back up over the word we ate by mistake
                pszParse = pszLastSpace;
                // Back up over the whitespace we ate by mistake
                while (pszParse >= rgss->Start() && IsSpace(pszParse[-1])) {
                    pszParse--;
                }
                break;
            }
        }
        if (*pszParse == TEXT(' ')) {
            pszLastSpace = pszParse;
        }
        pszParse++;
    }

    rgss->SetEnd(pszParse);             // Null string is possible

    return pszParse;
}

/*****************************************************************************
 *
 *  Parse strings
 *
 *  $D  date
 *  $P  full depot path
 *  $W  optional whitespace (does not consume a Substring slot)
 *  $a  email alias
 *  $b  branch name
 *  $d  digits
 *  $e  end of string (does not consume a Substring slot)
 *  $p  partial depot path, may not be null
 *  $u  user (with optional domain removed)
 *  $w  arbitrary word (whitespace-delimited)
 *
 *  NEED:
 *
 *  $R  maximal file revision specifier
 *  $q  quoted string
 *
 *  NOTE: Some pains were taken to make this a non-backtracking parser.
 *  If you want to add a backtracking rule, try to find a way so you don't.
 *
 *****************************************************************************/

LPTSTR Parse(LPCTSTR pszFormat, LPCTSTR pszParse, Substring *rgss)
{
    SIZE_T siz;
    while (*pszFormat) {

        if (*pszFormat == TEXT('$')) {
            pszFormat++;
            switch (*pszFormat++) {

            //
            //  Keep the switch cases in alphabetical order, please.
            //  Just helps maintain my sanity.
            //

            case TEXT('D'):             // Date
                rgss->SetStart(pszParse);
                if (lstrlen(pszParse) < 19) {
                    return NULL;        // Not long enough to be a date
                }
                pszParse += 19;
                rgss->SetEnd(pszParse);
                rgss++;
                break;

            case TEXT('P'):             // Full depot path
                if (pszParse[0] != TEXT('/') || pszParse[1] != TEXT('/')) {
                    return NULL;        // Must begin with //
                }
                goto L_p;               // Now treat as if it were partial

            case TEXT('W'):             // Optional whitespace
                while (*pszParse && (UINT)*pszParse <= (UINT)TEXT(' ')) {
                    pszParse++;
                }
                break;

            case TEXT('a'):             // Email alias
                rgss->SetStart(pszParse);
                if (IsAlpha(*pszParse)) {   // First char must be alpha
                    while (IsAlias(*pszParse)) {
                        pszParse++;
                    }
                }
                siz = rgss->SetEnd(pszParse);
                if (siz == 0 || siz > 8) {
                    return NULL;        // Must be 1 to 8 chars
                }
                rgss++;
                break;

            case TEXT('b'):             // Branch name
                rgss->SetStart(pszParse);
                while (IsBranch(*pszParse)) {
                    pszParse++;
                }
                siz = rgss->SetEnd(pszParse);
                if (siz == 0) {
                    return NULL;        // Must be at least one char
                }
                rgss++;
                break;

            case TEXT('d'):             // Digits
                rgss->SetStart(pszParse);
                while (IsDigit(*pszParse)) {
                    pszParse++;
                }
                if (rgss->SetEnd(pszParse) == 0) {
                    return NULL;        // Must have at least one digit
                }
                rgss++;
                break;

            case TEXT('e'):             // End of string
                if (*pszParse) {
                    return NULL;
                }
                break;

L_p:        case TEXT('p'):             // Partial depot path
                pszParse = _ParseP(pszParse, rgss);
                if (!pszParse) {
                    return NULL;        // Parse failure
                }
                rgss++;
                break;

            case TEXT('u'):             // Userid
                rgss->SetStart(pszParse);
                while (_IsWord(*pszParse) && *pszParse != TEXT('@')) {
                    if (*pszParse == TEXT('\\')) {
                        rgss->SetStart(pszParse+1);
                    }
                    pszParse++;
                }
                if (rgss->SetEnd(pszParse) == 0) {
                    return NULL;        // Must have at least one character
                }
                rgss++;
                break;

#if 0
            case TEXT('s'):             // String
                rgss->SetStart(pszParse);
                while ((_IsPrint(*pszParse) || *pszParse == TEXT('\t')) &&
                       *pszParse != *pszFormat) {
                    pszParse++;
                }
                rgss->SetEnd(pszParse); // Null string is okay
                rgss++;
                break;
#endif

            case TEXT('w'):
                rgss->SetStart(pszParse);
                while (_IsWord(*pszParse)) {
                    pszParse++;
                }
                if (rgss->SetEnd(pszParse) == 0) {
                    return NULL;        // Must have at least one character
                }
                rgss++;
                break;

            default:                    // ?
                ASSERT(0);
                return NULL;
            }

        } else if (*pszParse == *pszFormat) {
            pszParse++;
            pszFormat++;
        } else {
            return NULL;
        }

    }

    return CCAST(LPTSTR, pszParse);
}

/*****************************************************************************
 *
 *  Tokenizer
 *
 *****************************************************************************/

void Tokenizer::Restart(LPCTSTR psz)
{
    /* Skip spaces */
    while (IsSpace(*psz)) {
        psz++;
    }
    _psz = psz;
}

BOOL Tokenizer::Token(String& str)
{
    str.Reset();

    if (!*_psz) return FALSE;

    //
    //  Quote state:
    //
    //  Bit 0: In quote?
    //  Bit 1: Was previous character part of a run of quotation marks?
    //
    int iQuote = 0;

    //
    //  Wacko boundary case.  The opening quotation mark should not
    //  be counted as part of a run of quotation marks.
    //
    if (*_psz == TEXT('"')) {
        iQuote = 1;
        _psz++;
    }

    while (*_psz && ((iQuote & 1) || !IsSpace(*_psz))) {
        if (*_psz == TEXT('"')) {
            iQuote ^= 1 ^ 2;
            if (!(iQuote & 2)) {
                str << TEXT('"');
            }
        } else {
            iQuote &= ~2;
            str << *_psz;
        }
        _psz++;
    }

    Restart(_psz);              /* Eat any trailing spaces */

    return TRUE;
}

/*****************************************************************************
 *
 *  GetOpt
 *
 *****************************************************************************/

//
//  Returns the switch character, or '\0' if no more switches.
//
//  The option that terminated switch parsing is left in the tokenizer.
//
TCHAR GetOpt::NextSwitch()
{
    if (!_pszUnparsed) {
        LPCTSTR pszTokUndo = _tok.Unparsed();
        if (!_tok.Token(_str)) {
            return TEXT('\0');              // end of command line
        }

        if (_str[0] != TEXT('-')) {
            _tok.Restart(pszTokUndo);       // so caller can re-read it
            _pszValue = _str;               // all future values will go nere
            return TEXT('\0');              // end of command line

        }

        if (_str[1] == TEXT('\0')) {        // base - end switches
            _pszValue = _str;               // all future values will go nere
            return TEXT('\0');              // but do not re-read it
        }

        _pszUnparsed = &_str[1];
    }

    TCHAR tchSwitch = *_pszUnparsed;
    LPCTSTR pszParam;
    for (pszParam = _pszParams; *pszParam; pszParam++) {
        if (tchSwitch == *pszParam) {

            /*
             *  Value can come immediately afterwards or as a separate token.
             */
            _pszValue = _pszUnparsed + 1;

            if (_pszValue[0] == TEXT('\0')) {
                _tok.Token(_str);
                _pszValue = _str;
            }

            _pszUnparsed = NULL;
            return tchSwitch;
        }
    }

    _pszUnparsed++;
    if (!*_pszUnparsed) _pszUnparsed = NULL;
    return tchSwitch;
}

/*****************************************************************************
 *
 *  CommentParser - Parses checkin comments
 *
 *****************************************************************************/

void CommentParser::AddComment(LPTSTR psz)
{
    if (_fHaveComment) return;

    //
    //  Ignore leading spaces.
    //
    while (*psz == TEXT('\t') || *psz == TEXT(' ')) psz++;

    //
    //  Skip blank description lines.
    //
    if (*psz == TEXT('\0')) return;

    //
    //  Okay, here comes the money.  Is this a Gauntlet checkin?
    //
    LPTSTR pszRest = Parse(TEXT("Checkin by - "), psz, NULL);
    if (pszRest) {
        //
        //  You betcha.  This overrides the dev column.
        //
        SetDev(pszRest);
    } else {
        //
        //  No, it's a regular comment.  Use the first nonblank comment
        //  line as the text and toss the rest.
        //
        //  Change all tabs to spaces because listview doesn't like tabs.
        //
        ChangeTabsToSpaces(psz);

        //
        //  If the comment begins with [alias] or (alias), then move
        //  that alias to the developer column.  Digits can optionally
        //  be inserted before the alias.
        //
        Substring rgss[2];

        if ((pszRest = Parse("[$a]$W", psz, rgss)) ||
            (pszRest = Parse("($a)$W", psz, rgss))) {
            SetDev(rgss[0].Finalize());
            psz = pszRest;
        } else if ((pszRest = Parse("$d$W[$a]$W", psz, rgss)) ||
                   (pszRest = Parse("$d$W($a)$W", psz, rgss))) {
            SetDev(rgss[1].Finalize());
            //
            //  Now collapse out the alias.
            //
            lstrcpy(rgss[1].Start()-1, pszRest);
        }

        SetComment(psz);
        _fHaveComment = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\lvframe.cpp ===
/*****************************************************************************
 *
 *  lvframe.cpp
 *
 *      Frame window that hosts a listview.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  class LVFrame
 *
 *****************************************************************************/

LRESULT
LVFrame::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_NOTIFY);
    FW_MSG(WM_COMMAND);
    FW_MSG(WM_CONTEXTMENU);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT LVFrame::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *pnm = RECAST(NMHDR *, lParam);

    if (pnm->idFrom == IDC_LIST) {
        switch (pnm->code) {

        case LVN_ITEMACTIVATE:
            {
                NMITEMACTIVATE *pia = CONTAINING_RECORD(pnm, NMITEMACTIVATE, hdr);
                return SendSelfMessage(LM_ITEMACTIVATE, pia->iItem, 0);
            }
            break;

        case LVN_GETINFOTIP:
            {
                NMLVGETINFOTIP *pgit = CONTAINING_RECORD(pnm, NMLVGETINFOTIP, hdr);
                LPTSTR pszBuf = pgit->pszText;
                SendSelfMessage(LM_GETINFOTIP, pgit->iItem, RECAST(LPARAM, pgit));
                LPTSTR pszInfoTip = pgit->pszText;
                pgit->pszText = pszBuf;
                _it.SetInfoTip(pgit, pszInfoTip);
            }
            return 0;

        case LVN_DELETEITEM:
            {
                NMLISTVIEW *plv = CONTAINING_RECORD(pnm, NMLISTVIEW, hdr);
                SendSelfMessage(LM_DELETEITEM, plv->iItem, plv->lParam);
            }
            return 0;

        default:;
        }
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT LVFrame::ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iSel;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {
    case IDM_COPY:
        iSel = GetCurSel();
        if (iSel >= 0) {
            SendSelfMessage(LM_COPYTOCLIPBOARD, iSel, iSel + 1);
        }
        return 0;

    case IDM_COPYALL:
        SendSelfMessage(LM_COPYTOCLIPBOARD, 0, ListView_GetItemCount(_hwndChild));
        return 0;
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}



LRESULT LVFrame::ON_WM_CONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int iItem;
    HMENU hmenu;

    if ((DWORD)lParam == 0xFFFFFFFF) {
        iItem = ListView_GetCurSel(_hwndChild);
        if (iItem < 0) {
            goto fail;
        }

        RECT rc;
        if (!ListView_GetItemRect(_hwndChild, iItem, &rc, LVIR_LABEL)) {
            goto fail;
        }
        MapWindowRect(_hwndChild, HWND_DESKTOP, &rc);
        int cyHalf = (rc.bottom - rc.top)/2;
        lParam = MAKELPARAM(rc.left + cyHalf, rc.top + cyHalf);
    } else {
        LVHITTESTINFO hti;
        hti.pt.x = GET_X_LPARAM(lParam);
        hti.pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(_hwndChild, &hti.pt);
        iItem = ListView_HitTest(_hwndChild, &hti);
        if (iItem < 0) {
            goto fail;
        }
        ListView_SetCurSel(_hwndChild, iItem);
    }

    hmenu = RECAST(HMENU, SendSelfMessage(LM_GETCONTEXTMENU, iItem, 0));
    if (!hmenu) {
        goto fail;
    }

    TrackPopupMenuEx(hmenu,
                     TPM_LEFTALIGN | TPM_TOPALIGN |
                     TPM_RIGHTBUTTON | TPM_NONOTIFY,
                     GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam),
                     _hwnd, NULL);
    DestroyMenu(hmenu);
    return 0;

fail:
    return super::HandleMessage(uiMsg, wParam, lParam);
}

BOOL LVFrame::CreateChild(DWORD dwStyle, DWORD dwExStyle)
{
    _hwndChild = CreateWindowEx(WS_EX_CLIENTEDGE,
                           WC_LISTVIEW, NULL,
                           WS_CHILD | WS_VISIBLE |
                           WS_BORDER | WS_TABSTOP |
                           WS_CLIPSIBLINGS | WS_CLIPCHILDREN |
                           dwStyle,
                           0,0,0,0,
                           _hwnd, RECAST(HMENU, IDC_LIST), g_hinst, 0);

    if (!_hwndChild) return FALSE;

    ListView_SetExtendedListViewStyleEx(_hwndChild, dwExStyle, dwExStyle);

    SetFocus(_hwndChild);

    _it.Attach(_hwndChild);

    return TRUE;
}

BOOL LVFrame::AddColumns(const LVFCOLUMN *pcol)
{
    int cxChar = LOWORD(GetDialogBaseUnits());

    for (; pcol->cch; pcol++) {
        LVCOLUMN lvc;
        TCHAR szName[MAX_PATH];
        LoadString(g_hinst, pcol->ids, szName, ARRAYSIZE(szName));

        lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lvc.fmt = pcol->fmt;
        lvc.pszText = szName;
        lvc.cx = pcol->cch * cxChar;
        ListView_InsertColumn(_hwndChild, MAXLONG, &lvc);
    }
    return TRUE;
}

void *LVFrame::GetLVItem(int iItem)
{
    LVITEM lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;
    lvi.lParam = 0;
    ListView_GetItem(_hwndChild, &lvi);
    return RECAST(LPVOID, lvi.lParam);
}

/*****************************************************************************
 *
 *  LVInfoTip
 *
 *****************************************************************************/

void LVInfoTip::Attach(HWND hwnd)
{
    if (SetProp(hwnd, GetSubclassProperty(), RECAST(HANDLE, this))) {
        _wndprocPrev = SubclassWindow(hwnd, SubclassWndProc);
    }

    // Those infotips can get really long, so set the autopop delay
    // to the maximum allowable value.
    HWND hwndTT = ListView_GetToolTips(hwnd);
    if (hwndTT) {
        SendMessage(hwndTT, TTM_SETDELAYTIME, TTDT_AUTOPOP, MAXSHORT);
    }

}

void LVInfoTip::FreeLastTipAlt()
{
    if (_pszLastTipAlt) {
        LPSSTR pszFree = _pszLastTipAlt;
        _pszLastTipAlt = NULL;
        delete [] pszFree;
    }
}

void LVInfoTip::SetInfoTip(NMLVGETINFOTIP *pgit, LPCTSTR pszTip)
{
    _pszLastTip = NULL;
    FreeLastTipAlt();

    if (pgit->pszText != pszTip) {
        if (lstrlen(pszTip) >= pgit->cchTextMax) {
            _pszLastTip = pszTip;
        }
        lstrcpyn(pgit->pszText, pszTip, pgit->cchTextMax);
    }

}

//
//  Convert from TCHAR to SCHAR.
//
inline int T2S(LPCTSTR pszIn, int cchIn, LPSSTR pszOut, int cchOut)
{
#ifdef UNICODE
    return WideCharToMultiByte(CP_ACP, 0, pszIn, cchIn, pszOut, cchOut, NULL, NULL);
#else
    return MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, pszOut, cchOut);
#endif
}

//
//  Make _pszLastTipAlt match _pszLastTip, but of opposite character set.
//
BOOL LVInfoTip::ThunkLastTip()
{
    ASSERT(_pszLastTip);
    FreeLastTipAlt();
    int cch = T2S(_pszLastTip, -1, NULL, 0);
    if (cch) {
        _pszLastTipAlt = new SCHAR[cch];
        if (_pszLastTipAlt &&
            T2S(_pszLastTip, -1, _pszLastTipAlt, cch)) {
            return TRUE;
        }
    }
    return FALSE;
}

LRESULT LVInfoTip::SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LVInfoTip *self = RECAST(LVInfoTip *, GetProp(hwnd, GetSubclassProperty()));
    if (self) {
        LRESULT lres;
        NMHDR *pnm;
        switch (uMsg) {
        case WM_NOTIFY:
            pnm = RECAST(NMHDR *, lParam);
            switch (pnm->code) {
            case TTN_GETDISPINFOA:
            case TTN_GETDISPINFOW:
                lres = CallWindowProc(self->_wndprocPrev, hwnd, uMsg, wParam, lParam);
                if (SendMessage(pnm->hwndFrom, TTM_GETMAXTIPWIDTH, 0, 0) >= 0) {

                    // It's an infotip.  Tweak it to suit our needs.
                    NMTTDISPINFO *ptdi = CONTAINING_RECORD(pnm, NMTTDISPINFO, hdr);

                    // Set the width to the maximum allowed without going single-line.
                    SendMessage(pnm->hwndFrom, TTM_SETMAXTIPWIDTH, 0, MAXLONG);

                    // If we overflowed the returned buffer, then listview used
                    // only a partial infotip.  So fill in the rest here.
                    if (self->_pszLastTip) {
                        if (pnm->code == TTN_GETDISPINFO) {
                            ptdi->lpszText = CCAST(LPTSTR, self->_pszLastTip);
                        } else {
                            if (self->ThunkLastTip()) {
                                ptdi->lpszText = RECAST(LPTSTR, self->_pszLastTipAlt);
                            }
                        }
                    }
                } else {
                    self->_pszLastTip = NULL;
                }
                return lres;
            }
        }
        return CallWindowProc(self->_wndprocPrev, hwnd, uMsg, wParam, lParam);
    } else {
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\sdview.h ===
/*
 *   Private headers
 */

#ifndef STRICT
#define STRICT
#endif

#ifndef WIN32_LEAN_AND_MEAN     /* build.exe will define it for us on NT */
#define WIN32_LEAN_AND_MEAN
#endif
#undef WINVER                   /* build process defines this */
#define WINVER 0x0400           /* Windows 95 compatible */
#define _WIN32_WINDOWS  0x0400  /* Windows 95 compatible */
#include <windows.h>            /* Everybody's favourite */
#include <commctrl.h>

#ifndef RC_INVOKED
#include <windowsx.h>           /* Message crackers */
#include <shlwapi.h>
#include <shellapi.h>
#endif

/*****************************************************************************
 *
 *  Resources
 *
 *****************************************************************************/

/*
 *  Icons
 */
#define IDI_SDV                         0x0001

/*
 *  Bitmaps
 */
#define IDB_PLUS                        0x0001
#define IDB_IMAGES                      0x0002

/*
 *  Strings
 */
#define IDS_TITLE                       0x0001
#define IDS_IE4                         0x0002
#define IDS_SD_EXEC_ERR                 0x0003
#define IDS_DEFAULT_BUGPAGE             0x0004
#define IDS_VIEWBUG_FORMAT              0x0005
#define IDS_VIEWBUG_NONE                0x0006

#define IDS_COL_REV                     0x0100
#define IDS_COL_CHANGE                  0x0101
#define IDS_COL_OP                      0x0102
#define IDS_COL_DATE                    0x0103
#define IDS_COL_DEV                     0x0104
#define IDS_COL_CHURN                   0x0105
#define IDS_COL_COMMENT                 0x0106

/*
 * Menus
 */
#define IDM_CHANGES                     1
#define IDM_CHANGES_POPUP               2

#define IDM_DESCRIBE                    3
#define IDM_DESCRIBE_POPUP              4

#define IDM_FILELOG                     5
#define IDM_FILELOG_POPUP               6

#define IDM_OPENED                      7
#define IDM_OPENED_POPUP                8


#define   IDM_EXIT                      100
#define   IDM_EXITALL                   101

#define   IDM_COPY                      102
#define   IDM_COPYALL                   103

#define   IDM_VIEWDESC                  104
#define   IDM_VIEWFILEDIFF              105
#define   IDM_VIEWWINDIFF               106
#define   IDM_VIEWBUG                   107
#define   IDM_VIEWFILELOG               108

#define   IDM_HELP                      200

/*
 * Accelerators
 */
#define IDA_CHANGES                     1
#define IDA_DESCRIBE                    2
#define IDA_FILELOG                     3
#define IDA_OPENED                      4

/*****************************************************************************
 *
 *  Assorted goo
 *
 *****************************************************************************/

#ifndef RC_INVOKED

extern HINSTANCE    g_hinst;
extern HCURSOR      g_hcurWait;
extern HCURSOR      g_hcurArrow;
extern HCURSOR      g_hcurAppStarting;
extern LONG         g_lThreads;
extern TCHAR        g_szTitle[MAX_PATH];
extern UINT         g_wShowWindow;

DWORD EndThreadTask(DWORD dwExitCode);

#ifndef ARRAYSIZE
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#endif

#ifndef NO_VTABLE
#define NO_VTABLE   __declspec(novtable)
#endif

/*
 *  Because C++ syntax is so ugly.
 */
#define SAFECAST(T, p)  static_cast<T>(p)
#define RECAST(T, p)    reinterpret_cast<T>(p)
#define CCAST(T, p)     const_cast<T>(p)

/*****************************************************************************
 *
 *  Utility goo
 *
 *****************************************************************************/

class String;

int ListView_GetCurSel(HWND hwnd);
void ListView_SetCurSel(HWND hwnd, int iIndex);
int ListView_GetSubItemText(HWND hwnd, int iItem, int iSubItem, LPTSTR pszBuf, int cch);
#undef ListView_GetItemText
#define ListView_GetItemText(hwnd, iItem, pszBuf, cch) \
        ListView_GetSubItemText(hwnd, iItem, 0, pszBuf, cch)

void ChangeTabsToSpaces(LPTSTR psz);

void PremungeFilespec(LPTSTR psz);
void PostmungeFilespec(LPTSTR psz);

BOOL ContainsWildcards(LPCTSTR psz);

enum MAPTOX {
    MAPTOX_DEPOT,           //  //depot/path
    MAPTOX_CLIENT,          //  //CLIENT/path
    MAPTOX_LOCAL,           //  C:\src\path
};
BOOL MapToXPath(LPCTSTR pszSD, String& strOut, MAPTOX X);

inline BOOL MapToFullDepotPath(LPCTSTR pszSD, String& strOut)
    { return MapToXPath(pszSD, strOut, MAPTOX_DEPOT); }
inline BOOL MapToClientPath(LPCTSTR pszSD, String& strOut)
    { return MapToXPath(pszSD, strOut, MAPTOX_CLIENT); }
BOOL MapToLocalPath(LPCTSTR pszSD, String& strOut);

void Help(HWND hwnd, LPCTSTR pszAnchor);

BOOL SpawnProcess(LPTSTR pszCommand);
void WindiffChangelist(int iChange);
void WindiffOneChange(LPTSTR pszPath);

int ParseBugNumber(LPCTSTR psz);
int ParseBugNumberFromSubItem(HWND hwnd, int iItem, int iSubItem);
void AdjustBugMenu(HMENU hmenu, int iBug, BOOL fContextMenu);
void OpenBugWindow(HWND hwnd, int iBug);

void JiggleMouse();
HMENU LoadPopupMenu(LPCTSTR pszMenu);
void MakeMenuPretty(HMENU hmenu);
void EnableDisableOrRemoveMenuItem(HMENU hmenu, UINT id, BOOL fEnable, BOOL fDelete);
void SetClipboardText(HWND hwnd, LPCTSTR psz);

// SCHAR is the opposite of TCHAR
#ifdef UNICODE
typedef  CHAR SCHAR;
#else
typedef WCHAR SCHAR;
#endif
typedef SCHAR *LPSSTR;
typedef const SCHAR *LPCSSTR;

/*****************************************************************************
 *
 *  Change types
 *
 *****************************************************************************/

enum {
    OP_UNKNOWN,
    OP_EDIT,
    OP_DELETE,
    OP_ADD,
    OP_INTEGRATE,
    OP_MERGE,
    OP_BRANCH,
    OP_COPY,
    OP_IGNORED,
    OP_MAX,
};


extern struct LogEntryImageMap {
    LPCTSTR _pszOp;
    int     _iImage;
} c_rgleim[];

int ParseOp(LPCTSTR psz);

/*****************************************************************************
 *
 *  Assertion goo
 *
 *****************************************************************************/

#ifdef DEBUG
void AssertFailed(char *psz, char *pszFile, int iLine);
#define ASSERT(f) ((f) || (AssertFailed(#f, __FILE__, __LINE__), 0))
#else
#define ASSERT sizeof
#endif

#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:

/*****************************************************************************
 *
 *  Downlevel OS support (is this still needed?)
 *
 *****************************************************************************/

#undef SUPPORT_DOWNLEVEL
#ifdef SUPPORT_DOWNLEVEL

typedef BOOL (WINAPI *QUEUEUSERWORKITEM)(LPTHREAD_START_ROUTINE, LPVOID, ULONG);
typedef BOOL (WINAPI *ALLOWSETFOREGROUNDWINDOW)(DWORD);

extern QUEUEUSERWORKITEM _QueueUserWorkItem;
extern ALLOWSETFOREGROUNDWINDOW _AllowSetForegroundWindow;

#else

#define _QueueUserWorkItem          QueueUserWorkItem
#define _AllowSetForegroundWindow   AllowSetForegroundWindow

#endif

/*****************************************************************************
 *
 *  Ctype
 *
 *****************************************************************************/

#define C_NONE      0x00
#define C_SPACE     0x01
#define C_DIGIT     0x02
#define C_ALPHA     0x04
#define C_DASH      0x08
#define C_BRNCH     0x10

#define B_DEFAULT   C_NONE              // Characters above 128 are this

extern const BYTE c_rgbCtype[128];

inline BOOL _InOrder(UINT tch1, UINT tch2, UINT tch3)
{
    return tch2 - tch1 <= tch3 - tch1;
}

inline BOOL _Ctype(TCHAR tch, BYTE fl)
{
    UINT ui = (UINT)tch;
    BYTE b;
    if (ui < ARRAYSIZE(c_rgbCtype)) {
        b = c_rgbCtype[ui];
    } else {
        b = B_DEFAULT;
    }
    return b & fl;
}

inline BOOL IsSpace(TCHAR tch)
{
    return _Ctype(tch, C_SPACE);
}

inline BOOL IsDigit(TCHAR tch)
{
    return _Ctype(tch, C_DIGIT);
}

inline BOOL IsNZDigit(TCHAR tch)
{
    return _InOrder(TEXT('1'), tch, TEXT('9'));
}

inline BOOL IsAlpha(TCHAR tch)
{
    return _Ctype(tch, C_ALPHA);
}

inline BOOL IsAlias(TCHAR tch)
{
    return _Ctype(tch, C_DASH | C_DIGIT | C_ALPHA);
}

inline BOOL IsBranch(TCHAR tch)
{
    return _Ctype(tch, C_DASH | C_DIGIT | C_ALPHA | C_BRNCH);
}

inline BOOL _IsPrint(TCHAR tch)
{
    return _InOrder(TEXT(' '), tch, TEXT('~'));
}

#define _IsWord(ch) ((UINT)(ch) > TEXT(' '))

/*****************************************************************************
 *
 *  Commands
 *
 *****************************************************************************/

extern DWORD CALLBACK CChanges_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK CDescribe_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK CFileLog_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK CFileOut_ThreadProc(LPVOID lpParameter);
extern DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter);

BOOL LaunchThreadTask(LPTHREAD_START_ROUTINE pfn, LPCTSTR pszArgs);

/*****************************************************************************
 *
 *  String, _String, OutputStringBuffer
 *
 *  An extremely lame low-performance string class
 *  Be careful what you do with it since you can't do much.
 *
 *  _String is the base class that does the heavy lifting and shunts long
 *  strings into the heap.
 *
 *  String collects strings into a private buffer (which can overflow into
 *  the heap).
 *
 *  OutputStringBuffer collects strings into the buffer provided
 *  (which can overflow into the heap).  On destruction, copies the result
 *  if necessary back to the buffer provided.
 *
 *****************************************************************************/

class _String
{
public:
    explicit _String(LPTSTR pszBufOrig, UINT cchBufOrig);
    ~_String();
    void Reset();
    operator LPTSTR() const { return _pszBuf; }
    LPTSTR Buffer() const { return _pszBuf; }
    int BufferLength() const { return _cchBuf; }
    _String& operator<<(LPCTSTR psz) { Append(psz); return *this; }
    _String& operator<<(const _String& str) { Append(str); return *this; }
    _String& operator<<(int i);
    _String& operator<<(TCHAR tch);
    _String& operator=(LPCTSTR psz) { Reset(); Append(psz); return *this; }
    int Length() const { return _cchLen; }
    BOOL Append(LPCTSTR psz);
    BOOL Append(const _String& str) { return Append(str, str.Length()); }
    BOOL Append(LPCTSTR psz, int cchLen);
    BOOL Grow(int cchLen) { return Append(NULL, cchLen); }
    BOOL Ensure(int cchLen);
    void Trim(int cchTrim = 1) { _pszBuf[_cchLen -= cchTrim] = TEXT('\0'); }
    void SetLength(int cchLen) { ASSERT(_cchLen < _cchBuf); _cchLen = cchLen; }
    void Chomp();
protected:
    LPTSTR OriginalBuffer() const { return _pszBufOrig; }
private:

    // Disallow the default copy constructor and assignment operator.
    // Since our class has pointers, a block copy is never correct.
    _String(const _String&); // never defined
    _String& operator=(const _String&); // never defined

    LPTSTR  _pszBuf;
    int     _cchLen;
    int     _cchBuf;
    LPTSTR  _pszBufOrig;
};

class String : public _String
{
public:
    explicit String() : _String(_szBuf, ARRAYSIZE(_szBuf)) { }
    explicit String(LPCTSTR psz) : _String(_szBuf, ARRAYSIZE(_szBuf)) { Append(psz); }
    String& operator=(LPCTSTR psz) { _String::operator=(psz); return *this; }

private:
    /* Almost all strings are smaller than this */
    TCHAR   _szBuf[MAX_PATH];
};

class OutputStringBuffer : public _String
{
public:
    OutputStringBuffer(LPTSTR pszBuf, UINT cchBuf)
        : _String(pszBuf, cchBuf)
        , _cchBufOrig(cchBuf) { }
    ~OutputStringBuffer();
private:
    int     _cchBufOrig;
};

/*****************************************************************************
 *
 *  Custom output formats for "str << blah"
 *
 *****************************************************************************/

class _StringFormat {
public:
    operator LPCTSTR() const { return _pszDepotPath; }
    _StringFormat(LPCTSTR pszDepotPath) : _pszDepotPath(pszDepotPath) { }
protected:
    LPCTSTR _pszDepotPath;
};

#define MakeStringFormat(T)                                     \
class T : public _StringFormat {                                \
public:                                                         \
    T(LPCTSTR pszDepotPath) : _StringFormat(pszDepotPath) { }   \
};                                                              \
_String& operator<<(_String& str, T t);                         \

MakeStringFormat(QuoteSpaces)
MakeStringFormat(BranchOf)
MakeStringFormat(FilenameOf)
MakeStringFormat(ResolveBranchAndQuoteSpaces)

class StringResource {
public:
    operator UINT() const { return _ids; }
    StringResource(UINT ids) : _ids(ids) { }
protected:
    UINT _ids;
};
_String& operator<<(_String& str, StringResource sr);

#define StringBeginsWith(psz, sz) (StrCmpN(psz, sz, ARRAYSIZE(sz) - 1) == 0)

/*****************************************************************************
 *
 *  StringCache is a class that babysits a string pointer.
 *
 *  _StringCache is the version that requires explicit
 *  construction/destruction.  It is safe to use in global structures.
 *
 *****************************************************************************/

struct _StringCache {
public:
    _StringCache& operator=(LPCTSTR psz);
    BOOL IsEmpty() const { return _psz == NULL; }
    operator LPTSTR() const { return Value(); }
    LPTSTR Value() const { return IsEmpty() ? TEXT("") : _psz; }

public:
    LPTSTR _psz;
};

class StringCache : public _StringCache
{
public:
    StringCache() { _psz = NULL; }
    StringCache(LPCTSTR psz) { _psz = NULL; *this = psz; }
    ~StringCache() { *this = NULL; }
    StringCache& operator=(LPCTSTR psz)
        { *SAFECAST(_StringCache*,this) = psz; return *this; }
};

/*
 *  match.cpp - Highly-specialized depot path matching class
 */
class Match {
public:
    Match(LPCTSTR pszPattern);
    ~Match() { delete [] _pszzPats; }
    BOOL Matches(LPCTSTR pszPath);

private:
    void _AddPattern(LPTSTR pszPat, String& strPats);
    BOOL _Matches(LPCTSTR pszPat, LPCTSTR pszPath);
private:
    LPTSTR      _pszzPats;
    LPTSTR      _pszEnd;
};

/*
 *  pipe.cpp
 */

class ChildProcess
{
public:
    explicit ChildProcess() { Construct(); }
    explicit ChildProcess(LPCTSTR pszCommand) { Construct(); Start(pszCommand); }
    void Start(LPCTSTR pszCommand);
    ~ChildProcess() { Stop(); }

    BOOL IsRunning() const { return _dwPid; }
    HANDLE Handle() const { return _hRead; }
    void Kill();
    void Stop();

private:
    void Construct()
    {
        _hProcess = NULL;
        _hRead = NULL;
        _dwPid = 0;
    }


private:
    HANDLE  _hRead;
    HANDLE  _hProcess;
    DWORD   _dwPid;
};

class SDChildProcess : public ChildProcess
{
public:
    explicit SDChildProcess(LPCTSTR pszCommand);
};

/*
 *  buffer.cpp
 */

class IOBuffer
{
public:
    IOBuffer(HANDLE hRead) { Init(hRead); }
    void Init(HANDLE hRead) { _hRead = hRead; _cchBufUsed = 0; }
    BOOL NextLine(String &);

private:
    enum {
        _cchBuf = MAX_PATH,
    };

    HANDLE  _hRead;
    TCHAR   _rgchBuf[_cchBuf];
    int     _cchBufUsed;            /* Number of bytes already in buffer */
};

/*****************************************************************************
 *
 *  LVInfoTip - lvframe.cpp
 *
 *  Special hack class to support extra-long infotips in listview.
 *
 *****************************************************************************/

class LVInfoTip
{
public:
    void    Attach(HWND hwnd);
    ~LVInfoTip() { FreeLastTipAlt(); }
    void    SetInfoTip(NMLVGETINFOTIP *pgit, LPCTSTR pszTip);
private:
    void    FreeLastTipAlt();
    BOOL    ThunkLastTip();

    static LRESULT SubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LPCTSTR GetSubclassProperty() { return TEXT("LVInfoTip"); }

private:
    WNDPROC     _wndprocPrev;
    BOOL        _fGotInfoTip;
    LPCTSTR     _pszLastTip;
    LPSSTR      _pszLastTipAlt;
};

/*****************************************************************************
 *
 *  TreeList - treelist.cpp
 *
 *  A tree-like listview.
 *
 *****************************************************************************/

/*
 *  We maintain our own tree structure and add/delete items in the
 *  listview as necessary as tree nodes are expanded/collapsed.
 */

#define PTI_ONDEMAND RECAST(TreeItem*, -1)
#define PTI_APPEND   RECAST(TreeItem*, -1)

class TreeItem {
public:
    TreeItem *  Parent() const { return _ptiParent; }
    TreeItem *  NextSibling() const { return _ptiNext; }
    TreeItem *  FirstChild() const { return _ptiChild; }
    TreeItem *  NextVisible();
    BOOL        IsExpanded() const { return _cVisKids > 0; }
    BOOL        IsExpandable() const { return _ptiChild != NULL; }
    BOOL        IsVisible();
    BOOL        IsVisibleOrRoot();
    void        SetExpandable() { SetFirstChild(PTI_ONDEMAND); }
    void        SetNotExpandable() { SetFirstChild(NULL); }

private:
    friend class Tree;

    BOOL        IsSentinel() const { return this == NULL || this == PTI_ONDEMAND; }
    void        SetFirstChild(TreeItem *pti) { ASSERT(_ptiChild->IsSentinel()); _ptiChild = pti; }

private:
    TreeItem *  _ptiParent;
    TreeItem *  _ptiNext;
    TreeItem *  _ptiChild;

    int         _iDepth;
    int         _iVisIndex;
    int         _cVisKids;
};

#define TLN_GETDISPINFO         100     // Get pszText/cchTextMax given pti/iSubItem
#define TLN_FILLCHILDREN        101     // Fill children of pti
#define TLN_ITEMACTIVATE        102     // Default action on pti
#define TLN_GETINFOTIP          103     // Get pszText/cchTextMax given pti
#define TLN_DELETEITEM          104     // Destruct the node
#define TLN_GETCONTEXTMENU      105     // Display a context menu

struct NMTREELIST {
    NMHDR hdr;
    TreeItem *pti;
    int iSubItem;
    LPTSTR pszText;
    int cchTextMax;                     // Doubles as state
};

class Tree {
public:
    Tree(TreeItem *ptiRoot);
    ~Tree();
    TreeItem*   GetRoot() { return _ptiRoot; }
    BOOL Insert(TreeItem *pti, TreeItem *ptiParent, TreeItem *ptiAfter);
    void SetHWND(HWND hwnd);
    int Expand(TreeItem *pti);
    int Collapse(TreeItem *pti);
    int ToggleExpand(TreeItem *pti);
    void RedrawItem(TreeItem *pti);
    TreeItem *GetCurSel();
    void SetCurSel(TreeItem *pti);
    HIMAGELIST SetImageList(HIMAGELIST himl);

public: //$$// make these protected someday
    LRESULT OnGetDispInfo(NMLVDISPINFO *plvd);
    LRESULT OnCacheHint(NMLVCACHEHINT *phint);
    LRESULT OnItemActivate(int iItem);
    LRESULT OnKeyDown(NMLVKEYDOWN *pkd);
    LRESULT OnClick(NMITEMACTIVATE *pia);
    LRESULT OnGetInfoTip(NMLVGETINFOTIP *pgit);
    LRESULT OnGetContextMenu(int iItem);
    LRESULT OnCopyToClipboard(int iMin, int iMax);

private:
    void Recalc(TreeItem *pti);
    void UpdateCache(TreeItem *pti, int iItem);
    LRESULT SendNotify(int code, NMHDR *pnm);
    TreeItem* IndexToItem(int iItem);
    int InsertListviewItem(int iItem);
    void UpdateVisibleCounts(TreeItem *pti, int cDelta);
    void DeleteNode(TreeItem *pti);
    void SendDeleteNotify(TreeItem *pti);

private:
    HWND        _hwnd;
    TreeItem*   _ptiRoot;

    int         _iHint;
    TreeItem*   _ptiHint;
};


/*****************************************************************************
 *
 *  FrameWindow - window.cpp
 *
 *  A window that frames an inner control.  The inner control is resized
 *  to fill the client area.
 *
 *****************************************************************************/

#define FW_MSG(msg) case msg: return ON_##msg(uiMsg, wParam, lParam)

class NO_VTABLE FrameWindow {

public:
    static DWORD RunThread(FrameWindow *self, LPVOID lpParameter);

protected:
    void SetAcceleratorTable(LPCTSTR pszAccel)
    {
        _haccel = LoadAccelerators(g_hinst, pszAccel);
    }

    BOOL SetWindowMenu(LPCTSTR pszMenu)
    {
        return SetMenu(_hwnd, LoadMenu(g_hinst, pszMenu));
    }

    virtual LRESULT HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual ~FrameWindow() { }

    //
    //  For talking back to yourself (typically from a base class back
    //  to a derived class).  Short-circuits the WndProc wrapper for
    //  perf.  Do not use cross-thread!
    //
    LRESULT SendSelfMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        return HandleMessage(uMsg, wParam, lParam);
    }

private:
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);
    HWND CreateFrameWindow();

protected:
    HWND            _hwnd;
    HWND            _hwndChild;
    HACCEL          _haccel;
    LPTSTR          _pszQuery;
};

/*****************************************************************************
 *
 *  LVFrame - lvframe.cpp
 *
 *  A FrameWindow that frames a listview in report mode.
 *
 *****************************************************************************/

#define LM_ITEMACTIVATE     (WM_USER + 100) // wParam = iItem
#define LM_GETINFOTIP       (WM_USER + 101) // wParam = iItem, lParam -> NMLVGETINFOTIP
#define LM_GETCONTEXTMENU   (WM_USER + 102) // wParam = iItem
#define LM_COPYTOCLIPBOARD  (WM_USER + 103) // wParam = iMin, lParam = iMax (exclusive)
#define LM_DELETEITEM       (WM_USER + 104) // wParam = iItem, lParam = lParam

typedef struct LVFCOLUMN {
    UINT cch;
    UINT ids;
    UINT fmt;
} LVFCOLUMN;

class NO_VTABLE LVFrame : public FrameWindow {

    typedef FrameWindow super;

protected:
    enum { IDC_LIST = 1 };
    BOOL CreateChild(DWORD dwStyle, DWORD dwExStyle);
    BOOL AddColumns(const LVFCOLUMN *rgcol);

    void *GetLVItem(int iItem);
    int GetCurSel() { return ListView_GetCurSel(_hwndChild); }

    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:

    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_COMMAND(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_WM_CONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);

private:
    LVInfoTip   _it;
};

/*****************************************************************************
 *
 *  TLFrame - tlframe.cpp
 *
 *  Wraps the Tree class.  If I were less lazy, I would merge it into
 *  this class, but right now Tree is a separate class because I stole
 *  the code from sdflog...
 *
 *****************************************************************************/

class NO_VTABLE TLFrame : public LVFrame {

    typedef LVFrame super;

protected:
    TLFrame(TreeItem *ptiRoot) : _tree(ptiRoot) { }
    LRESULT HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    BOOL CreateChild(DWORD dwStyle, DWORD dwExStyle);
    TreeItem *TLGetCurSel() { return _tree.GetCurSel(); };

private:
    LRESULT ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam);
    LRESULT ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam);

protected:
    Tree        _tree;
};

/*****************************************************************************
 *
 *  BGTask
 *
 *****************************************************************************/

class BGTask
{
protected:
    BGTask() : _hDone(CreateEvent(NULL, TRUE, TRUE, NULL)), _fPending(FALSE) { }
    BOOL BGConstructed() const { return _hDone != NULL; }
    BOOL BGTaskPending() const { return _fPending; }
    ~BGTask();
    BOOL BGStartTask(LPTHREAD_START_ROUTINE pfn, LPVOID Context);
    void BGEndTask();
    LRESULT BGFilterSetCursor(LRESULT lres);
private:
    BOOL    _fPending;
    HANDLE  _hDone;
};

/*****************************************************************************
 *
 *  Parser
 *
 *****************************************************************************/

class Substring
{
public:
    LPTSTR _pszMin;         // First character of the substring
    LPTSTR _pszMax;         // One past the last character of the substring

    explicit Substring() { }
    explicit Substring(LPCTSTR pszMin, LPCTSTR pszMax)
        : _pszMin(CCAST(LPTSTR, pszMin)),
          _pszMax(CCAST(LPTSTR, pszMax)) { }

    LPTSTR SetStart(LPCTSTR psz)
    {
        return _pszMin = CCAST(LPTSTR, psz);
    }

    LPTSTR Start() { return _pszMin; }
    SIZE_T Length() const { return _pszMax - _pszMin; }

    SIZE_T SetEnd(LPCTSTR psz)
    {
        _pszMax = CCAST(LPTSTR, psz);
        return Length();
    }

    LPTSTR Finalize()       // This method works only on mutable substrings
    {
        *_pszMax = TEXT('\0');
        return _pszMin;
    }
};

LPTSTR Parse(LPCTSTR pszFormat, LPCTSTR pszParse, Substring *rgss);
inline _String& operator<<(_String& str, Substring ss)
{
    str.Append(ss._pszMin, (int)(ss._pszMax - ss._pszMin));
    return str;
}

/*****************************************************************************
 *
 *  CommentParser - Parses checkin comments
 *
 *****************************************************************************/

class NO_VTABLE CommentParser {

public:

    virtual void SetDev(LPCTSTR psz) = 0;
    virtual void SetComment(LPCTSTR psz) = 0;

    void Reset() { _fHaveComment = FALSE; }
    void AddComment(LPTSTR psz);

    CommentParser() { Reset(); }

private:
    BOOL    _fHaveComment;
};


/*****************************************************************************
 *
 *  Tokenizer
 *
 *****************************************************************************/

class Tokenizer
{
public:
    explicit Tokenizer() { }
    explicit Tokenizer(LPCTSTR psz) { Restart(psz); }
    void Restart(LPCTSTR psz);
    LPCTSTR Unparsed() const { return _psz; }
    BOOL Token(String& str);
    BOOL Finished() const { return !*_psz; }
private:
    LPCTSTR _psz;
};

/*****************************************************************************
 *
 *  GetOpt
 *
 *  pszParams is the list of switches that take parameters.  By default,
 *  switches do not take parameters.
 *
 *****************************************************************************/

class GetOpt
{
public:
    GetOpt(LPCTSTR pszParams, LPCTSTR pszArg)
        : _pszParams(pszParams), _pszUnparsed(NULL), _tok(pszArg) { }
    TCHAR NextSwitch();
    BOOL Token() { return _tok.Token(_str); }
    BOOL Finished() { return _tok.Finished(); }
    LPCTSTR GetValue() const { return _pszValue; }
    Tokenizer GetTokenizer() const { return _tok; }

private:
    LPCTSTR     _pszParams;
    LPTSTR      _pszUnparsed;
    LPTSTR      _pszValue;
    Tokenizer   _tok;
    String      _str;
};

/*****************************************************************************
 *
 *  WaitCursor
 *
 *****************************************************************************/

class WaitCursor
{
public:
    explicit WaitCursor() : _hcur(SetCursor(g_hcurWait)) { }
    ~WaitCursor() { SetCursor(_hcur); }
private:
    HCURSOR _hcur;
};

/*****************************************************************************
 *
 *  Annoying version-checking functions
 *
 *****************************************************************************/

inline BOOL VER1GE(UINT A,
                   UINT a)
{ return A >= a; }

inline BOOL VER2GE(UINT A, UINT B,
                   UINT a, UINT b)
{ return A > a || (A == a && VER1GE(B,b)); }

inline BOOL VER3GE(UINT A, UINT B, UINT C,
                   UINT a, UINT b, UINT c)
{ return A > a || (A == a && VER2GE(B,C,b,c)); }

inline BOOL VER4GE(UINT A, UINT B, UINT C, UINT D,
                   UINT a, UINT b, UINT c, UINT d)
{ return A > a || (A == a && VER3GE(B,C,D,b,c,d)); }


/*****************************************************************************
 *
 *  Globals
 *
 *****************************************************************************/

struct CGlobals
{
public:
    void    Initialize();

    BOOL                IsChurnEnabled() const { return _fChurn; }
    const _StringCache& GetSdOpts()      const { return _pszSdOpts; }
    const _StringCache& GetUserName()    const { return _rgpszSettings[SETTING_USERNAME]; }
    const _StringCache& GetClientName()  const { return _rgpszSettings[SETTING_CLIENTNAME]; }
    const _StringCache& GetClientRoot()  const { return _rgpszSettings[SETTING_CLIENTROOT]; }
    const _StringCache& GetFakeDir()     const { return _pszFakeDir; }
    const _StringCache& GetLocalRoot()   const { return _pszLocalRoot; }
    LPCTSTR             GetSdPath()      const { return _szSd; }
    String&             FormatBugUrl(String& str, int iBug) const
    {
        str << _pszBugPagePre << iBug << _pszBugPagePost;
        return str;
    }

    void    SetChurn(BOOL fChurn) { _fChurn = fChurn; }
    void    SetSdOpts(LPCTSTR psz) { _pszSdOpts = psz; }
    BOOL    IsVersion(UINT major) { return VER1GE(_Major(), major); }
    BOOL    IsVersion(UINT major, UINT minor)
        { return VER2GE(_Major(), _Minor(), major, minor); }


private:
    void _InitSdPath();
    void _InitInfo();
    void _InitFakeDir();
    void _InitServerVersion();
    void _InitBugPage();

    UINT _Major() { return _rguiVer[VERSION_MAJOR]; }
    UINT _Minor() { return _rguiVer[VERSION_MINOR]; }

    enum {
        SETTING_USERNAME,
        SETTING_CLIENTNAME,
        SETTING_CLIENTROOT,
        SETTING_LOCALDIR,
        SETTING_SERVERVERSION,
        SETTING_MAX
    };

    enum {
        VERSION_MAJOR,
        VERSION_MINOR,
        VERSION_BUILD,
        VERSION_QFE,
        VERSION_MAX,
    };

private:
    BOOL    _fChurn;
    _StringCache _pszSdOpts;
    _StringCache _pszLocalRoot;
    _StringCache _pszFakeDir;
    _StringCache _pszBugPagePre;
    _StringCache _pszBugPagePost;
    _StringCache _rgpszSettings[SETTING_MAX];
    UINT    _rguiVer[VERSION_MAX];
    TCHAR   _szSd[MAX_PATH];
};

extern CGlobals GlobalSettings;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\sdview.cpp ===
/*****************************************************************************
 *
 *  sdview.cpp
 *
 *      Lame SD Viewer app.
 *
 *****************************************************************************/

#include "sdview.h"

HINSTANCE   g_hinst;
HCURSOR     g_hcurWait;
HCURSOR     g_hcurArrow;
HCURSOR     g_hcurAppStarting;
LONG        g_lThreads;
UINT        g_wShowWindow;
CGlobals    GlobalSettings;

/*****************************************************************************
 *
 *  Stubs - will be filled in with goodies eventually
 *
 *****************************************************************************/

DWORD CALLBACK CFileOut_ThreadProc(LPVOID lpParameter)
{
    MessageBox(NULL, RECAST(LPTSTR, lpParameter), TEXT("fileout"), MB_OK);
    return EndThreadTask(0);
}

#if 0
DWORD CALLBACK COpened_ThreadProc(LPVOID lpParameter)
{
    MessageBox(NULL, RECAST(LPTSTR, lpParameter), TEXT("opened"), MB_OK);
    return EndThreadTask(0);
}
#endif

/*****************************************************************************
 *
 *  Eschew the C runtime.  Also, bonus-initialize memory to zero.
 *
 *****************************************************************************/

void * __cdecl operator new(size_t cb)
{
    return RECAST(LPVOID, LocalAlloc(LPTR, cb));
}

void __cdecl operator delete(void *pv)
{
    LocalFree(RECAST(HLOCAL, pv));
}

int __cdecl _purecall(void)
{
    return 0;
}

/*****************************************************************************
 *
 *  Assertion goo
 *
 *****************************************************************************/

#ifdef DEBUG
void AssertFailed(char *psz, char *pszFile, int iLine)
{
    static BOOL fAsserting = FALSE;

    if (!fAsserting) {
        fAsserting = TRUE;
        String strTitle(TEXT("Assertion failed - "));
        strTitle << pszFile << TEXT(" - line ") << iLine;
        MessageBox(NULL, psz, strTitle, MB_OK);
        fAsserting = FALSE;
    }
}
#endif

/*****************************************************************************
 *
 *  LaunchThreadTask
 *
 *****************************************************************************/

BOOL LaunchThreadTask(LPTHREAD_START_ROUTINE pfn, LPCTSTR pszArgs)
{
    BOOL fSuccess = FALSE;
    LPTSTR psz = StrDup(pszArgs);
    if (psz) {
        InterlockedIncrement(&g_lThreads);
        if (_QueueUserWorkItem(pfn, CCAST(LPTSTR, psz), WT_EXECUTELONGFUNCTION)) {
            fSuccess = TRUE;
        } else {
            LocalFree(psz);
            InterlockedDecrement(&g_lThreads);
        }
    }
    return fSuccess;
}

/*****************************************************************************
 *
 *  EndThreadTask
 *
 *      When a task finishes, exit with "return EndThreadTask(dwExitCode)".
 *      This decrements the count of active thread tasks and terminates
 *      the process if this is the last one.
 *
 *****************************************************************************/

DWORD
EndThreadTask(DWORD dwExitCode)
{
    if (InterlockedDecrement(&g_lThreads) <= 0) {
        ExitProcess(dwExitCode);
    }
    return dwExitCode;
}

/*****************************************************************************
 *
 *  Listview stuff
 *
 *****************************************************************************/

int ListView_GetCurSel(HWND hwnd)
{
    return ListView_GetNextItem(hwnd, -1, LVNI_FOCUSED);
}

void ListView_SetCurSel(HWND hwnd, int iIndex)

{
    ListView_SetItemState(hwnd, iIndex,
                          LVIS_SELECTED | LVIS_FOCUSED,
                          LVIS_SELECTED | LVIS_FOCUSED);
}

int ListView_GetSubItemText(HWND hwnd, int iItem, int iSubItem, LPTSTR pszBuf, int cch)
{
    LVITEM lvi;
    lvi.iSubItem = iSubItem;
    lvi.pszText= pszBuf;
    lvi.cchTextMax = cch;
    return (int)::SendMessage(hwnd, LVM_GETITEMTEXT, iItem, RECAST(LPARAM, &lvi));
}

void ChangeTabsToSpaces(LPTSTR psz)
{
    while ((psz = StrChr(psz, TEXT('\t'))) != NULL) *psz = TEXT(' ');
}

/*****************************************************************************
 *
 *  LoadPopupMenu
 *
 *****************************************************************************/

HMENU LoadPopupMenu(LPCTSTR pszMenu)
{
    HMENU hmenuParent = LoadMenu(g_hinst, pszMenu);
    if (hmenuParent) {
        HMENU hmenuPopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hmenuPopup;
    } else {
        return NULL;
    }
}

/*****************************************************************************
 *
 *  EnableDisableOrRemoveMenuItem
 *
 *  Enable, disable or remove, accordingly.
 *
 *****************************************************************************/

void EnableDisableOrRemoveMenuItem(HMENU hmenu, UINT id, BOOL fEnable, BOOL fDelete)
{
    if (fEnable) {
        EnableMenuItem(hmenu, id, MF_BYCOMMAND | MF_ENABLED);
    } else if (fDelete) {
        DeleteMenu(hmenu, id, MF_BYCOMMAND);
    } else {
        EnableMenuItem(hmenu, id, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
    }
}

/*****************************************************************************
 *
 *  MakeMenuPretty
 *
 *  Remove separators at the top and at the bottom, and collapse
 *  multiple consecutive separators.
 *
 *****************************************************************************/

void MakeMenuPretty(HMENU hmenu)
{
    BOOL fPrevSep = TRUE;
    int iCount = GetMenuItemCount(hmenu);
    for (int iItem = 0; iItem < iCount; iItem++) {
        UINT uiState = GetMenuState(hmenu, 0, MF_BYPOSITION);
        if (uiState & MF_SEPARATOR) {
            if (fPrevSep) {
                DeleteMenu(hmenu, iItem, MF_BYPOSITION);
                iCount--;
                iItem--;            // Will be incremented by loop control
            }
            fPrevSep = TRUE;
        } else {
            fPrevSep = FALSE;
        }
    }
    if (iCount && fPrevSep) {
        DeleteMenu(hmenu, iCount - 1, MF_BYPOSITION);
    }
}

/*****************************************************************************
 *
 *  JiggleMouse
 *
 *
 *      Jiggle the mouse to force a cursor recomputation.
 *
 *****************************************************************************/

void JiggleMouse()
{
    POINT pt;
    if (GetCursorPos(&pt)) {
        SetCursorPos(pt.x, pt.y);
    }
}

/*****************************************************************************
 *
 *  BGTask
 *
 *****************************************************************************/

BGTask::~BGTask()
{
    if (_hDone) {
        /*
         *  Theoretically we don't need to pump messages because
         *  we destroyed all the windows we created so our thread
         *  should be clear of any windows.  Except that Cicero will
         *  secretly create a window on our thread, so we have
         *  to pump messages anyway...
         */
        while (MsgWaitForMultipleObjects(1, &_hDone, FALSE,
                                         INFINITE, QS_ALLINPUT) == WAIT_OBJECT_0+1) {
            MSG msg;
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CloseHandle(_hDone);
    }
}

BOOL BGTask::BGStartTask(LPTHREAD_START_ROUTINE pfn, LPVOID Context)
{
    ASSERT(!_fPending);
    if (BGConstructed()) {
        /*
         *  Must reset before queueing the work item to avoid a race where
         *  the work item completes before we return from the Queue call.
         */
        ResetEvent(_hDone);
        _fPending = QueueUserWorkItem(pfn, Context, WT_EXECUTELONGFUNCTION);
        if (_fPending) {
            JiggleMouse();
        } else {
            BGEndTask();    // pretend task completed (because it never started)
        }
    }
    return _fPending;
}

void BGTask::BGEndTask()
{
    SetEvent(_hDone);
    _fPending = FALSE;
    JiggleMouse();
}

LRESULT BGTask::BGFilterSetCursor(LRESULT lres)
{
    if (BGTaskPending()) {
        if (GetCursor() == g_hcurArrow) {
            SetCursor(g_hcurAppStarting);
            lres = TRUE;
        }
    }
    return lres;
}

/*****************************************************************************
 *
 *  PremungeFileSpec
 *
 *  Due to complex view specifications this can be led astray when "..."
 *  gets involved.  As a workaround (HACK!) we change "..." to "???",
 *  do the mapping, then map back.
 *
 *  We choose "???" because it has so many magical properties...
 *
 *  -   not a valid filename, so cannot match a local file specification.
 *  -   not a valid Source Depot wildcard, so cannot go wild on the server,
 *  -   not a single question mark, which SD treats as equivalent to "help".
 *  -   same length as "..." so can be updated in place.
 *
 *  Any revision specifiers remain attached to the string.
 *
 *****************************************************************************/

void _ChangeTo(LPTSTR psz, LPCTSTR pszFrom, LPCTSTR pszTo)
{
    ASSERT(lstrlen(pszFrom) == lstrlen(pszTo));
    while ((psz = StrStr(psz, pszFrom)) != NULL) {
        memcpy(psz, pszTo, lstrlen(pszTo) * sizeof(pszTo[0]));
    }
}

void PremungeFilespec(LPTSTR psz)
{
    _ChangeTo(psz, TEXT("..."), TEXT("???"));
}

void PostmungeFilespec(LPTSTR psz)
{
    _ChangeTo(psz, TEXT("???"), TEXT("..."));
}

/*****************************************************************************
 *
 *  MapToXPath
 *
 *****************************************************************************/

BOOL MapToXPath(LPCTSTR pszSD, String& strOut, MAPTOX X)
{
    if (X == MAPTOX_DEPOT) {
        //
        //  Early-out: Is it already a full depot path?
        //
        if (pszSD[0] == TEXT('/')) {
            strOut = pszSD;
            return TRUE;
        }
    }


    //
    //  Borrow strOut to compose the query string.
    //
    Substring ssPath;
    strOut.Reset();
    if (Parse(TEXT("$p"), pszSD, &ssPath) && ssPath.Length() > 0) {
        strOut << ssPath;
    } else {
        return FALSE;
    }

    PremungeFilespec(strOut);

    String str;
    str << TEXT("where ") << QuoteSpaces(strOut);

    WaitCursor wait;
    SDChildProcess proc(str);
    IOBuffer buf(proc.Handle());
    while (buf.NextLine(str)) {
        str.Chomp();
        Substring rgss[3];
        if (rgss[2].SetStart(Parse(TEXT("$P $P "), str, rgss))) {
            PostmungeFilespec(str);
            rgss[2].SetEnd(str + str.Length());
            strOut.Reset();
            strOut << rgss[X] << ssPath._pszMax;
            return TRUE;
        }
    }
    return FALSE;
}

/*****************************************************************************
 *
 *  MapToLocalPath
 *
 *      MapToXPath does most of the work, but then we have to do some
 *      magic munging if we are running from a fake directory.
 *
 *****************************************************************************/

BOOL MapToLocalPath(LPCTSTR pszSD, String& strOut)
{
    BOOL fSuccess = MapToXPath(pszSD, strOut, MAPTOX_LOCAL);
    if (fSuccess && !GlobalSettings.GetFakeDir().IsEmpty()) {
        if (strOut.BufferLength() < MAX_PATH) {
            if (!strOut.Grow(MAX_PATH - strOut.BufferLength())) {
                return FALSE;       // Out of memory
            }
        }
        LPCTSTR pszRest = strOut + lstrlen(GlobalSettings.GetFakeDir());
        if (*pszRest == TEXT('\\')) {
            pszRest++;
        }
        PathCombine(strOut.Buffer(), GlobalSettings.GetLocalRoot(), pszRest);
        fSuccess = TRUE;
    }
    return fSuccess;
}

/*****************************************************************************
 *
 *  SpawnProcess
 *
 *****************************************************************************/

BOOL SpawnProcess(LPTSTR pszCommand)
{
    STARTUPINFO si = { 0 };
    PROCESS_INFORMATION pi;

    BOOL fSuccess = CreateProcess(NULL, pszCommand, NULL, NULL, FALSE, 0,
                                  NULL, NULL, &si, &pi);
    if (fSuccess) {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    return fSuccess;
}

/*****************************************************************************
 *
 *  WindiffChangelist
 *
 *****************************************************************************/

void WindiffChangelist(int iChange)
{
    if (iChange > 0) {
        String str;
        str << TEXT("windiff.exe -ld") << iChange;
        SpawnProcess(str);
    }
}

/*****************************************************************************
 *
 *  WindiffOneChange
 *
 *****************************************************************************/

void WindiffOneChange(LPTSTR pszPath)
{
    Substring rgss[2];
    if (Parse(TEXT("$P#$d$e"), pszPath, rgss)) {
        String str;
        str << TEXT("windiff.exe ");

        rgss[0].Finalize();
        int iVersion = StrToInt(rgss[1].Start());
        if (iVersion > 1) {
            /* Edit is easy */
            str << QuoteSpaces(rgss[0].Start()) << TEXT("#") << (iVersion - 1);
        } else {
            /* Add uses NUL as the base file */
            str << TEXT("NUL");
        }

        str << TEXT(' ');
        str << QuoteSpaces(rgss[0].Start()) << TEXT("#") << iVersion;

        SpawnProcess(str);
    }
}

/*****************************************************************************
 *
 *  ParseBugNumber
 *
 *  See if there's a bug number in there.
 *
 *      Digits at the beginning - bug number.
 *      Digits after a space or punctuation mark - bug number.
 *      Digits after the word "bug" or the letter "B" - bug number.
 *
 *  A valid bug number must begin with a nonzero digit.
 *
 *****************************************************************************/

int ParseBugNumber(LPCTSTR psz)
{
    Substring ss;
    LPCTSTR pszStart = psz;

    while (*psz) {
        if (IsDigit(*psz)) {
            if (*psz == TEXT('0')) {
                // Nope, cannot begin with zero
            } else if (psz == pszStart) {
                return StrToInt(psz);       // woo-hoo!
            } else switch (psz[-1]) {
            case 'B':
            case 'g':
            case 'G':
                return StrToInt(psz);       // Comes after a B or a G

            default:
                if (!IsAlpha(psz[-1])) {
                    return StrToInt(psz);   // Comes after a space or punctuation
                }
            }
            // Phooey, a digit string beginning with 0; not a bug.
            while (IsDigit(*psz)) psz++;
        } else {
            psz++;
        }
    }

    return 0;
}

/*****************************************************************************
 *
 *  ParseBugNumberFromSubItem
 *
 *      Sometimes we use this just to parse regular numbers since regular
 *      numbers pass the Bug Number Test.
 *
 *****************************************************************************/

int ParseBugNumberFromSubItem(HWND hwnd, int iItem, int iSubItem)
{
    TCHAR sz[MAX_PATH];
    sz[0] = TEXT('\0');
    if (iItem >= 0) {
        ListView_GetSubItemText(hwnd, iItem, iSubItem, sz, ARRAYSIZE(sz));
    }

    return ParseBugNumber(sz);
}

/*****************************************************************************
 *
 *  AdjustBugMenu
 *
 *****************************************************************************/

inline void _TrimAtTab(LPTSTR psz)
{
    psz = StrChr(psz, TEXT('\t'));
    if (psz) *psz = TEXT('\0');
}

void AdjustBugMenu(HMENU hmenu, int iBug, BOOL fContextMenu)
{
    TCHAR sz[MAX_PATH];
    String str;

    if (iBug) {
        str << StringResource(IDS_VIEWBUG_FORMAT);
        wnsprintf(sz, ARRAYSIZE(sz), str, iBug);
        if (fContextMenu) {
            _TrimAtTab(sz);
        }
        ModifyMenu(hmenu, IDM_VIEWBUG, MF_BYCOMMAND, IDM_VIEWBUG, sz);
    } else {
        str << StringResource(IDS_VIEWBUG_NONE);
        ModifyMenu(hmenu, IDM_VIEWBUG, MF_BYCOMMAND, IDM_VIEWBUG, str);
    }
    EnableDisableOrRemoveMenuItem(hmenu, IDM_VIEWBUG, iBug, fContextMenu);
}

/*****************************************************************************
 *
 *  OpenBugWindow
 *
 *****************************************************************************/

void OpenBugWindow(HWND hwnd, int iBug)
{
    String str;
    GlobalSettings.FormatBugUrl(str, iBug);

    LPCTSTR pszArgs = PathGetArgs(str);
    PathRemoveArgs(str);
    PathUnquoteSpaces(str);

    _AllowSetForegroundWindow(-1);
    ShellExecute(hwnd, NULL, str, pszArgs, 0, SW_NORMAL);
}


/*****************************************************************************
 *
 *  SetClipboardText
 *
 *****************************************************************************/

#ifdef UNICODE
#define CF_TSTR     CF_UNICODETEXT
#else
#define CF_TSTR     CF_TEXT
#endif

void SetClipboardText(HWND hwnd, LPCTSTR psz)
{
    if (OpenClipboard(hwnd)) {
        EmptyClipboard();
        int cch = lstrlen(psz) + 1;
        HGLOBAL hglob = GlobalAlloc(GMEM_MOVEABLE, cch * sizeof(*psz));
        if (hglob) {
            LPTSTR pszCopy = RECAST(LPTSTR, GlobalLock(hglob));
            if (pszCopy) {
                lstrcpy(pszCopy, psz);
                GlobalUnlock(hglob);
                if (SetClipboardData(CF_TSTR, hglob)) {
                    hglob = NULL;       // ownership transfer
                }
            }
            if (hglob) {
                GlobalFree(hglob);
            }
        }
        CloseClipboard();
    }
}

/*****************************************************************************
 *
 *  ContainsWildcards
 *
 *  The SD wildcards are
 *
 *      *       (asterisk)
 *      ...     (ellipsis)
 *      %n      (percent sign followed by anything)
 *      (null)  (null string -- shorthand for "//...")
 *
 *****************************************************************************/

BOOL ContainsWildcards(LPCTSTR psz)
{
    if (*psz == TEXT('#') || *psz == TEXT('@') || *psz == TEXT('\0')) {
        return TRUE;            // Null string wildcard
    }

    for (; *psz; psz++) {
        if (*psz == TEXT('*') || *psz == TEXT('%')) {
            return TRUE;
        }
        if (psz[0] == TEXT('.') && psz[1] == TEXT('.') && psz[2] == TEXT('.')) {
            return TRUE;
        }
    }
    return FALSE;
}

/*****************************************************************************
 *
 *      Downlevel support
 *
 *****************************************************************************/

#ifdef SUPPORT_DOWNLEVEL

/*
 *  If there is no thread pool, then chew an entire thread.
 */
BOOL WINAPI
Emulate_QueueUserWorkItem(LPTHREAD_START_ROUTINE pfn, LPVOID Context, ULONG Flags)
{
    DWORD dwId;
    HANDLE hThread = CreateThread(NULL, 0, pfn, Context, 0, &dwId);
    if (hThread) {
        CloseHandle(hThread);
        return TRUE;
    }
    return FALSE;
}

BOOL WINAPI
Emulate_AllowSetForegroundWindow(DWORD dwProcessId)
{
    return FALSE;
}

QUEUEUSERWORKITEM _QueueUserWorkItem;
ALLOWSETFOREGROUNDWINDOW _AllowSetForegroundWindow;

template<class T>
T GetProcFromModule(LPCTSTR pszModule, LPCSTR pszProc, T Default)
{
    T t;
    HMODULE hmod = GetModuleHandle(pszModule);
    if (pszModule) {
        t = RECAST(T, GetProcAddress(hmod, pszProc));
        if (!t) {
            t = Default;
        }
    } else {
        t = Default;
    }
    return t;
}


#define GetProc(mod, fn) \
    _##fn = GetProcFromModule(TEXT(mod), #fn, Emulate_##fn)

void InitDownlevel()
{
    GetProc("KERNEL32", QueueUserWorkItem);
    GetProc("USER32",   AllowSetForegroundWindow);

}

#undef GetProc

#else

#define InitDownlevel()

#endif

/*****************************************************************************
 *
 *      Main program stuff
 *
 *****************************************************************************/

LONG GetDllVersion(LPCTSTR pszDll)
{
    HINSTANCE hinst = LoadLibrary(pszDll);
    DWORD dwVersion = 0;
    if (hinst) {
        DLLGETVERSIONPROC DllGetVersion;
        DllGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hinst, "DllGetVersion");
        if (DllGetVersion) {
            DLLVERSIONINFO dvi;
            dvi.cbSize = sizeof(dvi);
            if (SUCCEEDED(DllGetVersion(&dvi))) {
                dwVersion = MAKELONG(dvi.dwMinorVersion, dvi.dwMajorVersion);
            }
        }
        // Leak the DLL - we're going to use him anyway
    }
    return dwVersion;
}

/*****************************************************************************
 *
 *  Globals
 *
 *****************************************************************************/

BOOL InitGlobals()
{
    g_hinst = GetModuleHandle(0);
    g_hcurWait = LoadCursor(NULL, IDC_WAIT);
    g_hcurArrow = LoadCursor(NULL, IDC_ARROW);
    g_hcurAppStarting = LoadCursor(NULL, IDC_APPSTARTING);

    if (GetDllVersion(TEXT("Comctl32.dll")) < MAKELONG(71, 4) ||
        GetDllVersion(TEXT("Shlwapi.dll")) < MAKELONG(71, 4)) {
        TCHAR sz[MAX_PATH];
        LoadString(g_hinst, IDS_IE4, sz, ARRAYSIZE(sz));
//$$//BUGBUG//        MessageBox(NULL, sz, g_szTitle, MB_OK);
        return FALSE;
    }

    InitDownlevel();
    InitCommonControls();

    /*
     *  Get the SW_ flag for the first window.
     */
    STARTUPINFOA si;
    si.cb = sizeof(si);
    si.dwFlags = 0;
    GetStartupInfoA(&si);

    if (si.dwFlags & STARTF_USESHOWWINDOW) {
        g_wShowWindow = si.wShowWindow;
    } else {
        g_wShowWindow = SW_SHOWDEFAULT;
    }

    return TRUE;
}

void TermGlobals()
{
}

/*****************************************************************************
 *
 *  Help
 *
 *****************************************************************************/

void Help(HWND hwnd, LPCTSTR pszAnchor)
{

    TCHAR szSelf[MAX_PATH];
    GetModuleFileName(g_hinst, szSelf, ARRAYSIZE(szSelf));

    String str;
    str << TEXT("res://") << szSelf << TEXT("/tips.htm");

    if (pszAnchor) {
        str << pszAnchor;
    }

    _AllowSetForegroundWindow(-1);
    ShellExecute(hwnd, NULL, str, 0, 0, SW_NORMAL);
}

/*****************************************************************************
 *
 *  CGlobals::Initialize
 *
 *****************************************************************************/

void CGlobals::Initialize()
{
    /*
     *  The order of these three steps is important.
     *
     *  -   We have to get the path before we can call sd.
     *
     *  -   We need the "sd info" in order to determine what
     *      the proper fake directory is.
     */

    _InitSdPath();
    _InitInfo();
    _InitFakeDir();
    _InitServerVersion();
    _InitBugPage();
}

/*****************************************************************************
 *
 *  CGlobals::_InitSdPath
 *
 *  The environment variable "SD" provides the path to the program to use.
 *  The default is "sd", but for debugging, you can set it to "fakesd",
 *  or if you're using that other company's product, you might even want
 *  to set it to that other company's program...
 *
 *****************************************************************************/

void CGlobals::_InitSdPath()
{
    TCHAR szSd[MAX_PATH];
    LPTSTR pszSdExe;

    DWORD cb = GetEnvironmentVariable(TEXT("SD"), szSd, ARRAYSIZE(szSd));
    if (cb == 0 || cb > ARRAYSIZE(szSd)) {
        pszSdExe = TEXT("SD.EXE");      // Default value
    } else {
        pszSdExe = szSd;
    }

    cb = SearchPath(NULL, pszSdExe, TEXT(".exe"), ARRAYSIZE(_szSd), _szSd, NULL);
    if (cb == 0 || cb > ARRAYSIZE(_szSd)) {
        /*
         *  Not found on path, eek!  Just use sd.exe and wait for the
         *  fireworks.
         */
        lstrcpyn(_szSd, TEXT("SD.EXE"), ARRAYSIZE(_szSd));
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitInfo
 *
 *      Collect the results of the "sd info" command.
 *
 *****************************************************************************/

void CGlobals::_InitInfo()
{
    static const LPCTSTR s_rgpsz[] = {
        TEXT("User name: "),
        TEXT("Client name: "),
        TEXT("Client root: "),
        TEXT("Current directory: "),
        TEXT("Server version: "),
    };

    COMPILETIME_ASSERT(ARRAYSIZE(s_rgpsz) == ARRAYSIZE(_rgpszSettings));

    WaitCursor wait;
    SDChildProcess proc(TEXT("info"));
    IOBuffer buf(proc.Handle());
    String str;
    while (buf.NextLine(str)) {
        str.Chomp();
        int i;
        for (i = 0; i < ARRAYSIZE(s_rgpsz); i++) {
            LPTSTR pszRest = Parse(s_rgpsz[i], str, NULL);
            if (pszRest) {
                _rgpszSettings[i] = pszRest;
            }
        }
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitFakeDir
 *
 *      See if the user is borrowing another person's enlistment.
 *      If so, then virtualize the directory (by walking the tree
 *      looking for an sd.ini file) to keep sd happy.
 *
 *      DO NOT WHINE if anything is wrong.  Magical resolution of
 *      borrowed directories is just a nicety.
 *
 *****************************************************************************/

void CGlobals::_InitFakeDir()
{
    /*
     *  If the client root is not a prefix of the current directory,
     *  then cook up a virtual current directory that will keep sd happy.
     */
    _StringCache& pszClientRoot = _rgpszSettings[SETTING_CLIENTROOT];
    _StringCache& pszLocalDir   = _rgpszSettings[SETTING_LOCALDIR];
    if (!pszClientRoot.IsEmpty() && !pszLocalDir.IsEmpty() &&
        !PathIsPrefix(pszClientRoot, pszLocalDir)) {

        TCHAR szDir[MAX_PATH];
        TCHAR szOriginalDir[MAX_PATH];
        TCHAR szSdIni[MAX_PATH];

        szDir[0] = TEXT('\0');

        GetCurrentDirectory(ARRAYSIZE(szDir), szDir);
        if (!szDir[0]) return;      // Freaky

        lstrcpyn(szOriginalDir, szDir, ARRAYSIZE(szOriginalDir));

        do {
            PathCombine(szSdIni, szDir, TEXT("sd.ini"));
            if (PathFileExists(szSdIni)) {

                _pszLocalRoot = szDir;
                //
                //  Now work from the root back to the current directory.
                //
                LPTSTR pszSuffix = szOriginalDir + lstrlen(szDir);
                if (pszSuffix[0] == TEXT('\\')) {
                    pszSuffix++;
                }

                PathCombine(szSdIni, _rgpszSettings[SETTING_CLIENTROOT], pszSuffix);
                _pszFakeDir = szSdIni;
                break;
            }
        } while (PathRemoveFileSpec(szDir));
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitServerVersion
 *
 *****************************************************************************/

void CGlobals::_InitServerVersion()
{
    Substring rgss[5];
    if (Parse(TEXT("$w $d.$d.$d.$d"), _rgpszSettings[SETTING_SERVERVERSION], rgss)) {
        for (int i = 0; i < VERSION_MAX; i++) {
            _rguiVer[i] = StrToInt(rgss[1+i].Start());
        }
    }
}

/*****************************************************************************
 *
 *  CGlobals::_InitBugPage
 *
 *****************************************************************************/

void CGlobals::_InitBugPage()
{
    TCHAR szRaid[MAX_PATH];

    DWORD cb = GetEnvironmentVariable(TEXT("SDVRAID"), szRaid, ARRAYSIZE(szRaid));
    if (cb == 0 || cb > ARRAYSIZE(szRaid)) {
        LoadString(g_hinst, IDS_DEFAULT_BUGPAGE, szRaid, ARRAYSIZE(szRaid));
    }

    LPTSTR pszSharp = StrChr(szRaid, TEXT('#'));
    if (pszSharp) {
        *pszSharp++ = TEXT('\0');
    }
    _pszBugPagePre = szRaid;
    _pszBugPagePost = pszSharp;
}

/*****************************************************************************
 *
 *  CommandLineParser
 *
 *****************************************************************************/

class CommandLineParser
{
public:
    CommandLineParser() : _tok(GetCommandLine()) {}
    BOOL ParseCommandLine();
    void Invoke();

private:
    BOOL ParseMetaParam();
    BOOL TokenWithUndo();
    void UndoToken() { _tok.Restart(_pszUndo); }

private:
    Tokenizer   _tok;
    LPCTSTR     _pszUndo;
    LPTHREAD_START_ROUTINE _pfn;
    String      _str;
};

BOOL CommandLineParser::TokenWithUndo()
{
    _pszUndo = _tok.Unparsed();
    return _tok.Token(_str);
}

BOOL CommandLineParser::ParseMetaParam()
{
    switch (_str[2]) {
    case TEXT('s'):
        if (_str[3] == TEXT('\0')) {
            _tok.Token(_str);
            GlobalSettings.SetSdOpts(_str);
        } else {
            GlobalSettings.SetSdOpts(_str+3);
        }
         break;

    case TEXT('#'):
        switch (_str[3]) {
        case TEXT('+'):
        case TEXT('\0'):
            GlobalSettings.SetChurn(TRUE);
            break;
        case TEXT('-'):
            GlobalSettings.SetChurn(FALSE);
            break;
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CommandLineParser::ParseCommandLine()
{
    _tok.Token(_str);       // Throw away program name

    /*
     *  First collect the meta-parameters.  These begin with two dashes.
     */

    while (TokenWithUndo()) {
        if (_str[0] == TEXT('-') && _str[1] == TEXT('-')) {
            if (!ParseMetaParam()) {
                return FALSE;
            }
        } else {
            break;
        }
    }

    /*
     *  Next thing had better be a command!
     */
    if (lstrcmpi(_str, TEXT("changes")) == 0) {
        _pfn = CChanges_ThreadProc;
    } else if (lstrcmpi(_str, TEXT("describe")) == 0) {
        _pfn = CDescribe_ThreadProc;
    } else if (lstrcmpi(_str, TEXT("filelog")) == 0) {
        _pfn = CFileLog_ThreadProc;
    } else if (lstrcmpi(_str, TEXT("fileout")) == 0) {
        _pfn = CFileOut_ThreadProc;
    } else if (lstrcmpi(_str, TEXT("opened")) == 0) {
        _pfn = COpened_ThreadProc;
    } else {
        /*
         *  Eek!  Must use psychic powers!
         */

        Substring ss;
        if (_str[0] == TEXT('\0')) {
            /*
             *  If no args, then it's "changes".
             */
            _pfn = CChanges_ThreadProc;
        } else if (_str[0] == TEXT('-')) {
            /*
             *  If it begins with a dash, then it's "changes".
             */
            _pfn = CChanges_ThreadProc;
        } else if (Parse(TEXT("$d$e"), _str, &ss)) {
            /*
             *  If first word is all digits, then it's "describe".
             */
            _pfn = CDescribe_ThreadProc;
        } else if (_tok.Finished() && !ContainsWildcards(_str)) {
            /*
             *  If only one argument that contains no wildcards,
             *  then it's "filelog".
             */
            _pfn = CFileLog_ThreadProc;
        } else {
            /*
             *  If all else fails, assume "changes".
             */
            _pfn = CChanges_ThreadProc;
        }

        UndoToken();                /* Undo all the tokens we accidentally ate */
    }

    return TRUE;
}

void CommandLineParser::Invoke()
{
    LPTSTR psz = StrDup(_tok.Unparsed());
    if (psz) {
        InterlockedIncrement(&g_lThreads);
        ExitThread(_pfn(psz));
    }
}

/*****************************************************************************
 *
 *  Entry
 *
 *      Program entry point.
 *
 *****************************************************************************/

EXTERN_C void PASCAL
Entry(void)
{
    if (InitGlobals()) {
        CommandLineParser parse;
        if (!parse.ParseCommandLine()) {
            Help(NULL, NULL);
        } else {
            GlobalSettings.Initialize();
            parse.Invoke();
        }
    }

    ExitProcess(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\global.h ===
// Global definitions for secedit project

#define WM_SECEDITNOTIFY    WM_USER+100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\tlframe.cpp ===
/*****************************************************************************
 *
 *  tlframe.cpp
 *
 *      Frame window that hosts a treelist.
 *
 *****************************************************************************/

#include "sdview.h"

/*****************************************************************************
 *
 *  TLFrame
 *
 *****************************************************************************/

LRESULT TLFrame::ON_WM_NOTIFY(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    NMHDR *pnm = RECAST(NMHDR *, lParam);

    if (pnm->idFrom == IDC_LIST) {
        switch (pnm->code) {

        case LVN_GETDISPINFO:
            return _tree.OnGetDispInfo(CONTAINING_RECORD(pnm, NMLVDISPINFO, hdr));

        case LVN_ODCACHEHINT:
            return _tree.OnCacheHint(CONTAINING_RECORD(pnm, NMLVCACHEHINT, hdr));

        case LVN_KEYDOWN:
            return _tree.OnKeyDown(CONTAINING_RECORD(pnm, NMLVKEYDOWN, hdr));

        case NM_CLICK:
            return _tree.OnClick(CONTAINING_RECORD(pnm, NMITEMACTIVATE, hdr));
        }
    }
    return super::HandleMessage(uiMsg, wParam, lParam);
}

LRESULT TLFrame::ON_LM_ITEMACTIVATE(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnItemActivate((int)wParam);
}

LRESULT TLFrame::ON_LM_GETINFOTIP(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnGetInfoTip(RECAST(NMLVGETINFOTIP *, lParam));
}

LRESULT TLFrame::ON_LM_GETCONTEXTMENU(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnGetContextMenu((int)wParam);
}

LRESULT TLFrame::ON_LM_COPYTOCLIPBOARD(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    return _tree.OnCopyToClipboard((int)wParam, (int)lParam);
}

BOOL TLFrame::CreateChild(DWORD dwStyle, DWORD dwExStyle)
{
    BOOL fResult = super::CreateChild(dwStyle | LVS_OWNERDATA, dwExStyle);
    if (fResult) {
        _tree.SetHWND(_hwndChild);
        HIMAGELIST himl = ImageList_LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_IMAGES),
                                               16, 0, RGB(0xFF, 0x00, 0xFF));
        _tree.SetImageList(himl);
        ImageList_SetOverlayImage(himl, 7, 1);
    }
    return fResult;
}

LRESULT
TLFrame::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {
    FW_MSG(WM_NOTIFY);
    FW_MSG(LM_ITEMACTIVATE);
    FW_MSG(LM_GETINFOTIP);
    FW_MSG(LM_GETCONTEXTMENU);
    FW_MSG(LM_COPYTOCLIPBOARD);
    }

    return super::HandleMessage(uiMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\window.cpp ===
/*****************************************************************************
 *
 *  window.cpp
 *
 *****************************************************************************/

#include "sdview.h"

LRESULT CALLBACK FrameWindow::WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    FrameWindow *self;

    if (uiMsg == WM_NCCREATE) {
        LPCREATESTRUCT lpcs = RECAST(LPCREATESTRUCT, lParam);
        self = RECAST(FrameWindow *, lpcs->lpCreateParams);
        self->_hwnd = hwnd;
        SetWindowLongPtr(self->_hwnd, GWLP_USERDATA, RECAST(LPARAM, self));
    } else {
        self = RECAST(FrameWindow *, GetWindowLongPtr(hwnd, GWLP_USERDATA));
    }

    if (self) {
        return self->HandleMessage(uiMsg, wParam, lParam);
    } else {
        return DefWindowProc(hwnd, uiMsg, wParam, lParam);
    }
}

//
//  Default message handler.  Messages land here after passing through
//  all the derived classes.
//
LRESULT FrameWindow::HandleMessage(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg) {

    case WM_NCDESTROY:
        _hwnd = NULL;
        PostQuitMessage(0);
        break;

    case WM_SIZE:
        if (_hwndChild) {
            SetWindowPos(_hwndChild, NULL, 0, 0,
                         GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam),
                         SWP_NOZORDER | SWP_NOACTIVATE);
        }
        return 0;

    case WM_SETFOCUS:
        if (_hwndChild) {
            SetFocus(_hwndChild);
        }
        return 0;

    case WM_CLOSE:
        if (GetKeyState(VK_SHIFT) < 0) {
            g_lThreads = 1;     // force app to exit
        }
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDM_EXIT:
            DestroyWindow(_hwnd);
            break;

        case IDM_EXITALL:
            g_lThreads = 1;     // force app to exit
            DestroyWindow(_hwnd);
            break;
        }
        break;

    case WM_HELP:
        Help(_hwnd, NULL);
        break;
    }

    return DefWindowProc(_hwnd, uiMsg, wParam, lParam);

}

#define CLASSNAME TEXT("SD View")

HWND FrameWindow::CreateFrameWindow()
{
    WNDCLASS wc;
    if (!GetClassInfo(g_hinst, CLASSNAME, &wc)) {
        wc.style = 0;
        wc.lpfnWndProc = WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hinst;
        wc.hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SDV));
        wc.hCursor = g_hcurArrow;
        wc.hbrBackground = RECAST(HBRUSH, COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = CLASSNAME;

        if (!RegisterClass(&wc)) {
            return NULL;
        }
    }

    _hwnd = CreateWindow(
            CLASSNAME,                      /* Class Name */
            NULL,                           /* Title */
            WS_CLIPCHILDREN | WS_VISIBLE |
            WS_OVERLAPPEDWINDOW,            /* Style */
            CW_USEDEFAULT, CW_USEDEFAULT,   /* Position */
            CW_USEDEFAULT, CW_USEDEFAULT,   /* Size */
            NULL,                           /* Parent */
            NULL,                           /* No menu */
            g_hinst,                        /* Instance */
            this);                          /* Special parameters */

    return _hwnd;
}


DWORD FrameWindow::RunThread(FrameWindow *self, LPVOID lpParameter)
{
    if (self) {
        self->_pszQuery = RECAST(LPTSTR, lpParameter);

        if (self->CreateFrameWindow()) {
            MSG msg;
            while (GetMessage(&msg, NULL, 0, 0)) {
                if (self->_haccel && TranslateAccelerator(self->_hwnd, self->_haccel, &msg)) {
                } else {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
        }
        delete self;
    }

    if (lpParameter) {
        LocalFree(lpParameter);
    }

    return EndThreadTask(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\acledit.c ===
/****************************************************************************

   PROGRAM: TOKEN.C

   PURPOSE: Contains routines that manipulate tokens

****************************************************************************/

#include "SECEDIT.h"
#include <sedapi.h>

BOOL
EditTokenDefaultAcl(
    HWND    Owner,
    HANDLE  Instance,
    LPWSTR  ObjectName,
    HANDLE  Token,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD   *EditResult
    );



/***************************************************************************\
* ApplySecurity
*
* Purpose : Called by ACL editor to set new default DACL on token
*
* Returns ERROR_SUCCESS or win error code.
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

DWORD
ApplySecurity(
    HWND    hwndParent,
    HANDLE  hInstance,
    ULONG   CallbackContext,
    PSECURITY_DESCRIPTOR SecDesc,
    PSECURITY_DESCRIPTOR SecDescNewObjects,
    BOOLEAN ApplyToSubContainers,
    BOOLEAN ApplyToSubObjects,
    LPDWORD StatusReturn
    )
{
    HANDLE MyToken = (HANDLE)CallbackContext;
    HANDLE Token = NULL;
    PTOKEN_DEFAULT_DACL DefaultDacl = NULL;
    NTSTATUS Status;
    BOOLEAN DaclPresent;
    BOOLEAN DaclDefaulted;

    *StatusReturn = SED_STATUS_FAILED_TO_MODIFY;

    //
    // Get a handle to the token
    //

    Token = OpenToken(MyToken, TOKEN_ADJUST_DEFAULT);

    if (Token == NULL) {
        DbgPrint("SECEDIT : Failed to open the token for TOKEN_ADJUST_DEFAULT access\n");
        goto CleanupAndExit;
    }

    DefaultDacl = Alloc(sizeof(TOKEN_DEFAULT_DACL));
    if (DefaultDacl == NULL) {
        goto CleanupAndExit;
    }

    Status = RtlGetDaclSecurityDescriptor (
                    SecDesc,
                    &DaclPresent,
                    &DefaultDacl->DefaultDacl,
                    &DaclDefaulted
                    );
    ASSERT(NT_SUCCESS(Status));

    ASSERT(DaclPresent);

    if (SetTokenInfo(Token, TokenDefaultDacl, (PVOID)DefaultDacl)) {
        *StatusReturn = SED_STATUS_MODIFIED;
    }

CleanupAndExit:

    if (Token != NULL) {
        CloseToken(Token);
    }
    if (DefaultDacl != NULL) {
        Free(DefaultDacl);
    }

    if (*StatusReturn != SED_STATUS_MODIFIED) {
        MessageBox(hwndParent, "Failed to set default DACL", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
    }

    return(ERROR_SUCCESS);
}


/***************************************************************************\
* EditDefaultAcl
*
* Purpose : Displays and allows the user to edit the default Acl on the
* passed token.
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Instance,
    HANDLE  MyToken
    )
{
    NTSTATUS Status;
    BOOL    Success = FALSE;
    DWORD   EditResult;
    HANDLE  Token = NULL;
    PTOKEN_DEFAULT_DACL DefaultDacl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PTOKEN_OWNER Owner = NULL;
    PTOKEN_PRIMARY_GROUP PrimaryGroup = NULL;
    WCHAR string[MAX_STRING_LENGTH];

    //
    // Get the window text so we can use it as the token name
    //

    GetWindowTextW(((PMYTOKEN)MyToken)->hwnd, string, sizeof(string)/sizeof(*string));


    //
    // Get a handle to the token
    //

    Token = OpenToken(MyToken, TOKEN_QUERY);

    if (Token == NULL) {
        DbgPrint("SECEDIT : Failed to open the token with TOKEN_QUERY access\n");
        goto CleanupAndExit;
    }


    //
    // Read the default DACL from the token
    //

    if (!GetTokenInfo(Token, TokenDefaultDacl, (PPVOID)&DefaultDacl)) {
        DbgPrint("SECEDIT : Failed to read default DACL from token\n");
        goto CleanupAndExit;
    }


    //
    // Get the owner and group of the token
    //

    if (!GetTokenInfo(Token, TokenOwner, (PPVOID)&Owner)) {
        DbgPrint("SECEDIT : Failed to read owner from token\n");
        goto CleanupAndExit;
    }

    if (!GetTokenInfo(Token, TokenPrimaryGroup, (PPVOID)&PrimaryGroup)) {
        DbgPrint("SECEDIT : Failed to read primary group from token\n");
        goto CleanupAndExit;
    }




    //
    // Create a security descriptor
    //

    SecurityDescriptor = Alloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (SecurityDescriptor == NULL) {
        DbgPrint("SECEDIT : Failed to allocate security descriptor\n");
        goto CleanupAndExit;
    }

    Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    ASSERT(NT_SUCCESS(Status));




    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                        SecurityDescriptor,
                        TRUE,   // DACL present
                        DefaultDacl->DefaultDacl,
                        FALSE   // DACL defaulted
                        );
    ASSERT(NT_SUCCESS(Status));

    //
    // Put the owner and group in the security descriptor to keep the
    // ACL editor happy
    //

    Status = RtlSetOwnerSecurityDescriptor(
                        SecurityDescriptor,
                        Owner->Owner,
                        FALSE // Owner defaulted
                        );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlSetGroupSecurityDescriptor(
                        SecurityDescriptor,
                        PrimaryGroup->PrimaryGroup,
                        FALSE // Owner defaulted
                        );
    ASSERT(NT_SUCCESS(Status));



    ASSERT(RtlValidSecurityDescriptor(SecurityDescriptor));

    //
    // Call the ACL editor, it will call our ApplySecurity function
    // to store any ACL changes in the token.
    //

    Success = EditTokenDefaultAcl(
                        hwndOwner,
                        Instance,
                        string,
                        MyToken,
                        SecurityDescriptor,
                        &EditResult
                        );
    if (!Success) {
        DbgPrint("SECEDIT: Failed to edit token DACL\n");
    }

CleanupAndExit:

    if (DefaultDacl != NULL) {
        FreeTokenInfo(DefaultDacl);
    }
    if (SecurityDescriptor != NULL) {
        FreeTokenInfo(SecurityDescriptor);
    }
    if (PrimaryGroup != NULL) {
        FreeTokenInfo(PrimaryGroup);
    }
    if (Owner != NULL) {
        FreeTokenInfo(Owner);
    }

    if (Token != NULL) {
        CloseToken(Token);
    }


    return(Success);
}


/***************************************************************************\
* EditTokenDefaultAcl
*
* Purpose : Displays and allows the user to edit the default Acl on the
* passed token.
*
* Returns TRUE on success, FALSE on failure (Use GetLastError for detail)
*
* History:
* 09-17-92 Davidc       Created.
\***************************************************************************/

BOOL
EditTokenDefaultAcl(
    HWND    Owner,
    HANDLE  Instance,
    LPWSTR  ObjectName,
    HANDLE  MyToken,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD   *EditResult
    )
{
    DWORD Result;
    SED_OBJECT_TYPE_DESCRIPTOR sedobjdesc;
    GENERIC_MAPPING GenericMapping;
    SED_HELP_INFO sedhelpinfo ;
    SED_APPLICATION_ACCESSES SedAppAccesses ;
    SED_APPLICATION_ACCESS  SedAppAccess[20];
    ULONG i;

    //
    // Initialize the application accesses
    //

    i=0;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ASSIGN_PRIMARY;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Assign Primary";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_DUPLICATE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Duplicate";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_IMPERSONATE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Impersonate";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_QUERY;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Query";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_QUERY_SOURCE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Query source";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ADJUST_PRIVILEGES;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Adjust Privileges";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ADJUST_GROUPS;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Adjust Groups";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE_SPECIAL;
    SedAppAccess[i].AccessMask1 =       TOKEN_ADJUST_DEFAULT;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Adjust Default";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       GENERIC_ALL;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"All Access";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       TOKEN_READ;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Read";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       TOKEN_WRITE;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"Write";
    i++;

    SedAppAccess[i].Type =              SED_DESC_TYPE_RESOURCE;
    SedAppAccess[i].AccessMask1 =       0;
    SedAppAccess[i].AccessMask2 =       0;
    SedAppAccess[i].PermissionTitle =   L"None";
    i++;

    ASSERT((sizeof(SedAppAccess)/sizeof(*SedAppAccess)) >= i);


    SedAppAccesses.Count           = i;
    SedAppAccesses.AccessGroup     = SedAppAccess;
    SedAppAccesses.DefaultPermName = L"Read";


    //
    // Initialize generic mapping
    //

    GenericMapping.GenericRead    = TOKEN_READ;
    GenericMapping.GenericWrite   = TOKEN_WRITE;
    GenericMapping.GenericExecute = TOKEN_EXECUTE;
    GenericMapping.GenericAll     = TOKEN_ALL_ACCESS;

    //
    // Initialize help info
    //

    sedhelpinfo.pszHelpFileName = L"secedit.hlp";
    sedhelpinfo.aulHelpContext[HC_MAIN_DLG] = 0 ;
    sedhelpinfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] = 0 ;
    sedhelpinfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;
    sedhelpinfo.aulHelpContext[HC_ADD_USER_DLG] = 0 ;


    //
    // Initialize object description
    //

    sedobjdesc.Revision                    = SED_REVISION1;
    sedobjdesc.IsContainer                 = FALSE;
    sedobjdesc.AllowNewObjectPerms         = FALSE;
    sedobjdesc.MapSpecificPermsToGeneric   = FALSE;
    sedobjdesc.GenericMapping              = &GenericMapping;
    sedobjdesc.GenericMappingNewObjects    = &GenericMapping;
    sedobjdesc.HelpInfo                    = &sedhelpinfo;
    sedobjdesc.ObjectTypeName              = L"Token";
    sedobjdesc.ApplyToSubContainerTitle    = L"ApplyToSubContainerTitle";
    sedobjdesc.ApplyToSubContainerHelpText = L"ApplyToSubContainerHelpText";
    sedobjdesc.ApplyToSubContainerConfirmation = L"ApplyToSubContainerConfirmation";
    sedobjdesc.SpecialObjectAccessTitle    = L"Special...";
    sedobjdesc.SpecialNewObjectAccessTitle = L"SpecialNewObjectAccessTitle";


    //
    // Call the ACL editor, it will call our ApplySecurity function
    // to store any ACL changes in the token.
    //

    Result = SedDiscretionaryAclEditor(
                        Owner,
                        Instance,
                        NULL,               // server
                        &sedobjdesc,        // object type
                        &SedAppAccesses,    // application accesses
                        ObjectName,
                        ApplySecurity,      // Callback
                        (ULONG_PTR)MyToken,     // Context
                        SecurityDescriptor,
                        FALSE,              // Couldn't read DACL
                        EditResult
                        );

    if (Result != ERROR_SUCCESS) {
        DbgPrint("SECEDIT: Acleditor failed, error = %d\n", Result);
        SetLastError(Result);
    }

    return (Result == ERROR_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\string.cpp ===
/*****************************************************************************
 *
 *  string.cpp
 *
 *      World's lamest string class.
 *
 *****************************************************************************/

#include "sdview.h"

_String::_String(LPTSTR pszBufOrig, UINT cchBufOrig)
    : _pszBufOrig(pszBufOrig)
    , _pszBuf(pszBufOrig)
    , _cchBuf(cchBufOrig)
{
    Reset();
}

_String::~_String()
{
    if (_pszBuf != _pszBufOrig) {
        LocalFree(_pszBuf);
    }
}

//
//  Notice that Reset does not free the allocated buffer.  Once we've
//  switched to using an allocated buffer, we may as well continue to
//  use it.
//

void _String::Reset()
{
    ASSERT(_cchBuf);
    _cchLen = 0;
    _pszBuf[0] = TEXT('\0');
}

BOOL _String::Append(LPCTSTR psz, int cch)
{
    int cchNeeded = _cchLen + cch + 1;
    if (cchNeeded > _cchBuf)
    {
        LPTSTR pszNew;
        if (_pszBuf != _pszBufOrig) {
            pszNew = RECAST(LPTSTR, LocalReAlloc(_pszBuf, cchNeeded * sizeof(TCHAR), LMEM_MOVEABLE));
        } else {
            pszNew = RECAST(LPTSTR, LocalAlloc(LMEM_FIXED, cchNeeded * sizeof(TCHAR)));
        }

        if (!pszNew) {
            return FALSE;
        }

        if (_pszBuf == _pszBufOrig) {
            memcpy(pszNew, _pszBuf, _cchBuf * sizeof(TCHAR));
        }
        _cchBuf = cchNeeded;
        _pszBuf = pszNew;
    }

    if (psz) {
        lstrcpyn(_pszBuf + _cchLen, psz, cch + 1);
    }
    _cchLen += cch;
    _pszBuf[_cchLen] = TEXT('\0');

    return TRUE;
}

_String& _String::operator<<(int i)
{
    TCHAR sz[64];
    wsprintf(sz, TEXT("%d"), i);
    return *this << sz;
}

//
//  This could be inline but it's not worth it.
//
_String& _String::operator<<(TCHAR tch)
{
    Append(&tch, 1);
    return *this;
}

//
//  This could be inline but it's not worth it.
//
BOOL _String::Append(LPCTSTR psz)
{
    return Append(psz, lstrlen(psz));
}

BOOL _String::Ensure(int cch)
{
    BOOL f;

    if (Length() + cch < BufferLength()) {
        f = TRUE;                           // Already big enough
    } else {
        f = Grow(cch);
        if (f) {
            _cchLen -= cch;
        }
    }
    return f;
}

//
//  Remove any trailing CRLF
//
void _String::Chomp()
{
    if (Length() > 0 && Buffer()[Length()-1] == TEXT('\n')) {
        Trim();
    }
    if (Length() > 0 && Buffer()[Length()-1] == TEXT('\r')) {
        Trim();
    }
}


OutputStringBuffer::~OutputStringBuffer()
{
    if (Buffer() != OriginalBuffer()) {
        lstrcpyn(OriginalBuffer(), Buffer(), _cchBufOrig);
    }
}

/*****************************************************************************
 *
 *  QuoteSpaces
 *
 *      Append the string, quoting it if it contains any spaces
 *      or if it is the null string.
 *
 *****************************************************************************/

_String& operator<<(_String& str, QuoteSpaces qs)
{
    if (qs) {
        if (qs[0] == TEXT('\0') || StrChr(qs, TEXT(' '))) {
            str << '"' << SAFECAST(LPCTSTR, qs) << '"';
        } else {
            str << SAFECAST(LPCTSTR, qs);
        }
    }
    return str;
}

/*****************************************************************************
 *
 *  BranchOf
 *
 *      Given a full depot path, append the branch name.
 *
 *****************************************************************************/

_String& operator<<(_String& str, BranchOf bof)
{
    if (bof && bof[0] == TEXT('/') && bof[1] == TEXT('/')) {
        //
        //  Skip over the word "//depot" -- or whatever it is.
        //  Some admins are stupid and give the root of the depot
        //  some other strange name.
        //
        LPCTSTR pszBranch = StrChr(bof + 2, TEXT('/'));
        if (pszBranch) {
            pszBranch++;
            //
            //  If the next phrase is "private", then we are in a
            //  private branch; skip a step.
            //
            if (StringBeginsWith(pszBranch, TEXT("private/"))) {
                pszBranch += 8;
            }

            LPCTSTR pszSlash = StrChr(pszBranch, TEXT('/'));
            if (pszSlash) {
                str << Substring(pszBranch, pszSlash);
            }
        }
    }
    return str;
}

/*****************************************************************************
 *
 *  FilenameOf
 *
 *      Given a full depot path, possibly with revision tag,
 *      append just the filename part.
 *
 *****************************************************************************/

_String& operator<<(_String& str, FilenameOf fof)
{
    if (fof) {
        LPCTSTR pszFile = StrRChr(fof, NULL, TEXT('/'));
        if (pszFile) {
            pszFile++;
        } else {
            pszFile = fof;
        }
        str.Append(pszFile, StrCSpn(pszFile, TEXT("#")));
    }
    return str;
}

/*****************************************************************************
 *
 *  StringResource
 *
 *      Given a string resource identifier, append the corresponding string.
 *
 *****************************************************************************/

_String& operator<<(_String& str, StringResource sr)
{
    HRSRC hrsrc = FindResource(g_hinst, MAKEINTRESOURCE(1 + sr / 16), RT_STRING);
    if (hrsrc) {
        HGLOBAL hglob = LoadResource(g_hinst, hrsrc);
        if (hglob) {
            LPWSTR pwch = RECAST(LPWSTR, LockResource(hglob));
            if (pwch) {
                UINT ui;
                for (ui = 0; ui < sr % 16; ui++) {
                    pwch += *pwch + 1;
                }
#ifdef UNICODE
                str.Append(pwch+1, *pwch);
#else
                int cch = WideCharToMultiByte(CP_ACP, 0, pwch+1, *pwch,
                                              NULL, 0, NULL, NULL);
                if (str.Grow(cch)) {
                    WideCharToMultiByte(CP_ACP, 0, pwch+1, *pwch,
                                        str.Buffer() + str.Length() - cch,
                                        cch,
                                        NULL, NULL);
                }
#endif
            }
        }
    }

    return str;
}

/*****************************************************************************
 *
 *  ResolveBranchAndQuoteSpaces
 *
 *      If the file specifier contains a "branch:" prefix, resolve it.
 *      Then append the result (with spaces quoted).
 *
 *****************************************************************************/

//
//  The real work happens in the worker function.
//
_String& _ResolveBranchAndQuoteSpaces(_String& strOut, LPCTSTR pszSpec, LPCTSTR pszColon)
{
    String str;
    String strFull;
    LPCTSTR pszSD = pszColon + 1;

    if (MapToFullDepotPath(pszSD, strFull)) {

        //
        //  Copy the word "//depot" -- or whatever it is.
        //  Some admins are stupid and give the root of the depot
        //  some other strange name.
        //
        LPCTSTR pszBranch = StrChr(strFull + 2, TEXT('/'));
        if (pszBranch) {
            pszBranch++;            // Include the slash
            str << Substring(strFull, pszBranch);

            //
            //  Bonus: If the branch name begins with "/" then
            //  we treat it as a private branch.
            //
            if (pszSpec[0] == TEXT('/')) {
                str << "private";
            }
            str << Substring(pszSpec, pszColon);

            //
            //  If the next phrase is "private", then we are in a
            //  private branch; skip a step.
            //
            if (StringBeginsWith(pszBranch, TEXT("private/"))) {
                pszBranch += 8;
            }

            LPCTSTR pszSlash = StrChr(pszBranch, TEXT('/'));
            if (pszSlash) {
                str << pszSlash;
            }
            strOut << QuoteSpaces(str);
        } else {
            str << QuoteSpaces(strFull);
        }
    } else {
        //
        //  If anything went wrong, then just ignore the branch prefix.
        //
        str << QuoteSpaces(pszSD);
    }

    return str;
}

_String& operator<<(_String& str, ResolveBranchAndQuoteSpaces rb)
{
    Substring ss;
    if (Parse(TEXT("$b:"), rb, &ss)) {
        ASSERT(ss._pszMax[0] == TEXT(':'));
        return _ResolveBranchAndQuoteSpaces(str, rb, ss._pszMax);
    } else {
        return str << QuoteSpaces(rb);
    }
}

/*****************************************************************************
 *
 *  _StringCache=
 *
 *****************************************************************************/

_StringCache& _StringCache::operator=(LPCTSTR psz)
{
    if (_psz) {
        LocalFree(_psz);
    }
    if (psz) {
        _psz = StrDup(psz);
    } else {
        _psz = NULL;
    }
    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\acledit.h ===
BOOL
EditDefaultDacl(
    HWND    hwndOwner,
    HANDLE  Instance,
    HANDLE  MyToken
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sdv\treelist.cpp ===
/*****************************************************************************
 *
 *  treelist.cpp
 *
 *      A tree-like listview.  (Worst of both worlds!)
 *
 *****************************************************************************/

//
//  state icon: Doesn't get ugly highlight when selected
//          but indent doesn't work unless there is a small imagelist
//
//  image: gets ugly highlight
//      but at least indent works

#include "sdview.h"

TreeItem *TreeItem::NextVisible()
{
    if (IsExpanded()) {
        return FirstChild();
    }

    TreeItem *pti = this;
    do {
        if (pti->NextSibling()) {
            return pti->NextSibling();
        }
        pti = pti->Parent();
    } while (pti);

    return NULL;
}

BOOL TreeItem::IsVisibleOrRoot()
{
    TreeItem *pti = Parent();

    while (pti) {
        ASSERT(pti->IsExpandable());
        if (!pti->IsExpanded())
        {
            return FALSE;
        }
        pti = pti->Parent();
    }

    // Made it all the way to the root without incident
    return TRUE;
}

BOOL TreeItem::IsVisible()
{
    TreeItem *pti = Parent();

    //
    //  The root itself is not visible.
    //
    if (!pti) {
        return FALSE;
    }

    return IsVisibleOrRoot();
}

Tree::Tree(TreeItem *ptiRoot)
    : _ptiRoot(ptiRoot)
    , _iHint(-1)
    , _ptiHint(ptiRoot)
{
    if (_ptiRoot) {
        _ptiRoot->_ptiChild = PTI_ONDEMAND;
        _ptiRoot->_iVisIndex = -1;
        _ptiRoot->_iDepth = -1;
    }
}

Tree::~Tree()
{
    DeleteNode(_ptiRoot);
}

void Tree::SetHWND(HWND hwnd)
{
    _hwnd = hwnd;
    SHFILEINFO sfi;
    HIMAGELIST himl = ImageList_LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_PLUS),
                                           16, 0, RGB(0xFF, 0x00, 0xFF));

    ListView_SetImageList(_hwnd, himl, LVSIL_STATE);
    ListView_SetCallbackMask(_hwnd, LVIS_STATEIMAGEMASK | LVIS_OVERLAYMASK);
}

HIMAGELIST Tree::SetImageList(HIMAGELIST himl)
{
    return RECAST(HIMAGELIST, ListView_SetImageList(_hwnd, himl, LVSIL_SMALL));
}

LRESULT Tree::SendNotify(int code, NMHDR *pnm)
{
    pnm->hwndFrom = _hwnd;
    pnm->code = code;
    pnm->idFrom = GetDlgCtrlID(_hwnd);
    return ::SendMessage(GetParent(_hwnd), WM_NOTIFY, pnm->idFrom, RECAST(LPARAM, pnm));
}


LRESULT Tree::OnCacheHint(NMLVCACHEHINT *phint)
{
    _ptiHint = IndexToItem(phint->iFrom);
    _iHint = phint->iFrom;
    return 0;
}

//
//  pti = the first item that needs to be recalced
//
void Tree::Recalc(TreeItem *pti)
{
    int iItem = pti->_iVisIndex;

    if (_iHint > iItem) {
        _iHint = iItem;
        _ptiHint = pti;
    }

    do {
        pti->_iVisIndex = iItem;
        pti = pti->NextVisible();
        iItem++;
    } while (pti);
}

TreeItem* Tree::IndexToItem(int iItem)
{
    int iHave;
    TreeItem *ptiHave;
    if (iItem >= _iHint && _ptiHint) {
        iHave = _iHint;
        ptiHave = _ptiHint;
        ASSERT(ptiHave->_iVisIndex == iHave);
    } else {
        iHave = -1;
        ptiHave = _ptiRoot;
    }

    while (iHave < iItem && ptiHave) {
        ASSERT(ptiHave->_iVisIndex == iHave);
        ptiHave = ptiHave->NextVisible();
        iHave++;
    }

    return ptiHave;
}

int Tree::InsertListviewItem(int iItem)
{
    LVITEM lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = 0;
    return ListView_InsertItem(_hwnd, &lvi);
}

BOOL Tree::Insert(TreeItem *pti, TreeItem *ptiParent, TreeItem *ptiAfter)
{
    pti->_ptiParent = ptiParent;

    TreeItem **pptiUpdate;

    // Convenience:  PTI_APPEND appends as last child
    if (ptiAfter == PTI_APPEND) {
        ptiAfter = ptiParent->FirstChild();
        if (ptiAfter == PTI_ONDEMAND) {
            ptiAfter = NULL;
        } else if (ptiAfter) {
            while (ptiAfter->NextSibling()) {
                ptiAfter = ptiAfter->NextSibling();
            }
        }
    }

    if (ptiAfter) {
        pti->_iVisIndex = ptiAfter->_iVisIndex + 1;
        pptiUpdate = &ptiAfter->_ptiNext;
    } else {
        pti->_iVisIndex = ptiParent->_iVisIndex + 1;
        pptiUpdate = &ptiParent->_ptiChild;
        if (ptiParent->_ptiChild == PTI_ONDEMAND) {
            ptiParent->_ptiChild = NULL;
        }
    }

    if (ptiParent->IsExpanded()) {
        if (InsertListviewItem(pti->_iVisIndex) < 0) {
            return FALSE;
        }
        ptiParent->_cVisKids++;
    }

    pti->_ptiNext = *pptiUpdate;
    *pptiUpdate = pti;
    pti->_iDepth = ptiParent->_iDepth + 1;

    if (ptiParent->IsExpanded()) {
        Recalc(pti);
    }

    return TRUE;
}

//
//  Update the visible kids count for pti and all its parents.
//  Sop when we find a node that is collapsed (which means
//  the visible kids counter is no longer being kept track of).
//

void Tree::UpdateVisibleCounts(TreeItem *pti, int cDelta)
{
    //
    //  Earlying-out the cDelta==0 case is a clear optimization,
    //  and it's actually important in the goofy scenario where
    //  an expand failed (so the item being updated isn't even
    //  expandable any more).
    //
    if (cDelta) {
        do {
            ASSERT(pti->IsExpandable());
            pti->_cVisKids += cDelta;
            pti = pti->Parent();
        } while (pti && pti->IsExpanded());
    }
}

int Tree::Expand(TreeItem *ptiRoot)
{
    if (ptiRoot->IsExpanded()) {
        return 0;
    }

    if (!ptiRoot->IsExpandable()) {
        return 0;
    }

    if (ptiRoot->FirstChild() == PTI_ONDEMAND) {
        NMTREELIST tl;
        tl.pti = ptiRoot;
        SendNotify(TLN_FILLCHILDREN, &tl.hdr);

        //
        //  If the callback failed to insert any items, then turn the
        //  entry into an unexpandable item.  (We need to redraw it
        //  so the new button shows up.)
        //
        if (ptiRoot->FirstChild() == PTI_ONDEMAND) {
            ptiRoot->SetNotExpandable();
        }
    }

    BOOL fRootVisible = ptiRoot->IsVisibleOrRoot();

    TreeItem *pti = ptiRoot->FirstChild();
    int iNewIndex = ptiRoot->_iVisIndex + 1;
    int cExpanded = 0;

    while (pti) {
        cExpanded += 1 + pti->_cVisKids;
        if (fRootVisible) {
            // Start at -1 so we also include the item itself
            for (int i = -1; i < pti->_cVisKids; i++) {
                InsertListviewItem(iNewIndex);
                iNewIndex++;
            }
        }
        pti = pti->NextSibling();
    }

    UpdateVisibleCounts(ptiRoot, cExpanded);

    if (fRootVisible) {
        Recalc(ptiRoot);

        // Also need to redraw the root item because its button changed
        ListView_RedrawItems(_hwnd, ptiRoot->_iVisIndex, ptiRoot->_iVisIndex);
    }

    return cExpanded;
}

int Tree::Collapse(TreeItem *ptiRoot)
{
    if (!ptiRoot->IsExpanded()) {
        return 0;
    }

    if (!ptiRoot->IsExpandable()) {
        return 0;
    }

    TreeItem *pti = ptiRoot->FirstChild();
    int iDelIndex = ptiRoot->_iVisIndex + 1;
    int cCollapsed = 0;
    BOOL fRootVisible = ptiRoot->IsVisibleOrRoot();

    //
    //  HACKHACK for some reason, listview in ownerdata mode animates
    //  deletes but not insertions.  What's worse, the deletion animation
    //  occurs even if the item being deleted isn't even visible (because
    //  we deleted a screenful of items ahead of it).  So let's just disable
    //  redraws while doing collapses.
    //
    if (fRootVisible) {
        SetWindowRedraw(_hwnd, FALSE);
    }

    while (pti) {
        cCollapsed += 1 + pti->_cVisKids;
        if (fRootVisible) {
            // Start at -1 so we also include the item itself
            for (int i = -1; i < pti->_cVisKids; i++) {
                ListView_DeleteItem(_hwnd, iDelIndex);
            }
        }
        pti = pti->NextSibling();
    }

    UpdateVisibleCounts(ptiRoot, -cCollapsed);

    if (fRootVisible) {
        Recalc(ptiRoot);

        // Also need to redraw the root item because its button changed
        ListView_RedrawItems(_hwnd, ptiRoot->_iVisIndex, ptiRoot->_iVisIndex);

        SetWindowRedraw(_hwnd, TRUE);
    }

    return cCollapsed;
}

int Tree::ToggleExpand(TreeItem *pti)
{
    if (pti->IsExpandable()) {
        if (pti->IsExpanded()) {
            return -Collapse(pti);
        } else {
            return Expand(pti);
        }
    }
    return 0;
}

void Tree::RedrawItem(TreeItem *pti)
{
    if (pti->IsVisible()) {
        ListView_RedrawItems(_hwnd, pti->_iVisIndex, pti->_iVisIndex);
    }
}


LRESULT Tree::OnClick(NMITEMACTIVATE *pia)
{
    if (pia->iSubItem == 0) {
        // Maybe it was a click on the +/- button
        LVHITTESTINFO hti;
        hti.pt = pia->ptAction;
        ListView_HitTest(_hwnd, &hti);
        if (hti.flags & (LVHT_ONITEMICON | LVHT_ONITEMSTATEICON)) {
            TreeItem *pti = IndexToItem(pia->iItem);
            if (pti) {
                ToggleExpand(pti);
            }
        }

    }
    return 0;
}

LRESULT Tree::OnItemActivate(int iItem)
{
    NMTREELIST tl;
    tl.pti = IndexToItem(iItem);
    if (tl.pti) {
        SendNotify(TLN_ITEMACTIVATE, &tl.hdr);
    }
    return 0;
}

//
//  Classic treeview keys:
//
//  Ctrl+(Left, Right, PgUp, Home, PgDn, End, Up, Down) = scroll the
//  window without changing selection.
//
//  Enter = activate
//  PgUp, PgDn, Home, End = navigate
//  Numpad+, Numpad- = expand/collapse
//  Numpad* = expand all
//  Left = collapse focus item or move to parent
//  Right = expand focus item or move down
//  Backspace = move to parent
//
//  We don't mimic it perfectly, but we get close enough that hopefully
//  nobody will notice.
//
LRESULT Tree::OnKeyDown(NMLVKEYDOWN *pkd)
{
    if (GetKeyState(VK_CONTROL) < 0) {
        // Allow key to go through - listview will do the work
    } else {
        TreeItem *pti;
        switch (pkd->wVKey) {

        case VK_ADD:
            pti = GetCurSel();
            if (pti) {
                Expand(pti);
            }
            return 1;

        case VK_SUBTRACT:
            pti = GetCurSel();
            if (pti) {
                Collapse(pti);
            }
            return 1;

        case VK_LEFT:
            pti = GetCurSel();
            if (pti) {
                if (pti->IsExpanded()) {
                    Collapse(pti);
                } else {
                    SetCurSel(pti->Parent());
                }
            }
            return 1;

        case VK_BACK:
            pti = GetCurSel();
            if (pti) {
                SetCurSel(pti->Parent());
            }
            return 1;

        case VK_RIGHT:
            pti = GetCurSel();
            if (pti) {
                if (!Expand(pti)) {
                    pti = pti->NextVisible();
                    if (pti) {
                        SetCurSel(pti);
                    }
                }
            }
            return 1;
        }
    }
    return 0;
}

//
//  Convert the item number into a tree item.
//
LRESULT Tree::OnGetDispInfo(NMLVDISPINFO *plvd)
{
    TreeItem *pti = IndexToItem(plvd->item.iItem);
    ASSERT(pti);
    if (!pti) {
        return 0;
    }

    if (plvd->item.mask & LVIF_STATE) {
        if (pti->IsExpandable()) {
            // State images are 1-based
            plvd->item.state |= INDEXTOSTATEIMAGEMASK(pti->IsExpanded() ? 1 : 2);
        }
    }

    if (plvd->item.mask & LVIF_INDENT) {
        plvd->item.iIndent = pti->_iDepth;
    }

    NMTREELIST tl;
    tl.pti = pti;

    if (plvd->item.mask & (LVIF_IMAGE | LVIF_STATE)) {
        tl.iSubItem = -1;
        tl.cchTextMax = 0;
        SendNotify(TLN_GETDISPINFO, &tl.hdr);
        plvd->item.iImage = tl.iSubItem;
        if (plvd->item.stateMask & LVIS_OVERLAYMASK) {
            plvd->item.state |= tl.cchTextMax;
        }

    }

    if (plvd->item.mask & LVIF_TEXT) {
        tl.iSubItem = plvd->item.iSubItem;
        tl.pszText = plvd->item.pszText;
        tl.cchTextMax = plvd->item.cchTextMax;

        SendNotify(TLN_GETDISPINFO, &tl.hdr);

        plvd->item.pszText = tl.pszText;
    }

    return 0;
}

LRESULT Tree::OnGetInfoTip(NMLVGETINFOTIP *pgit)
{
    TreeItem *pti = IndexToItem(pgit->iItem);
    ASSERT(pti);
    if (pti) {
        NMTREELIST tl;
        tl.pti = pti;
        tl.pszText = pgit->pszText;
        tl.cchTextMax = pgit->cchTextMax;

        SendNotify(TLN_GETINFOTIP, &tl.hdr);

        pgit->pszText = tl.pszText;
    }

    return 0;
}

LRESULT Tree::OnGetContextMenu(int iItem)
{
    TreeItem *pti = IndexToItem(iItem);
    ASSERT(pti);
    if (pti) {
        NMTREELIST tl;
        tl.pti = pti;
        return SendNotify(TLN_GETCONTEXTMENU, &tl.hdr);
    }
    return 0;
}

LRESULT Tree::OnCopyToClipboard(int iMin, int iMax)
{
    TreeItem *pti = IndexToItem(iMin);
    ASSERT(pti);
    if (pti) {
        TreeItem *ptiMax = IndexToItem(iMax);
        String str;
        while (pti != ptiMax) {
            NMTREELIST tl;
            tl.pti = pti;
            tl.pszText = NULL;
            tl.cchTextMax = 0;
            SendNotify(TLN_GETINFOTIP, &tl.hdr);
            if (tl.pszText) {
                str << tl.pszText << TEXT("\r\n");
            }
            pti = pti->NextVisible();
        }
        SetClipboardText(_hwnd, str);
    }
    return 0;
}

TreeItem *Tree::GetCurSel()
{
    int iItem = ListView_GetCurSel(_hwnd);
    if (iItem >= 0) {
        return IndexToItem(iItem);
    }
    return NULL;
}

void Tree::SetCurSel(TreeItem *pti)
{
    if (pti->IsVisible()) {
        ListView_SetCurSel(_hwnd, pti->_iVisIndex);
        ListView_EnsureVisible(_hwnd, pti->_iVisIndex, FALSE);
    }
}

void Tree::DeleteNode(TreeItem *pti)
{
    if (pti) {

        // Nuke all the kids, recursively
        TreeItem *ptiKid = pti->FirstChild();
        if (!ptiKid->IsSentinel()) {
            do {
                TreeItem *ptiNext = ptiKid->NextSibling();
                DeleteNode(ptiKid);
                ptiKid = ptiNext;
            } while (ptiKid);
        }

        // This is moved to a subroutine so we don't eat stack
        // in this highly-recursive function.
        SendDeleteNotify(pti);
    }
}

void Tree::SendDeleteNotify(TreeItem *pti)
{
    NMTREELIST tl;
    tl.pti = pti;
    SendNotify(TLN_DELETEITEM, &tl.hdr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\lsa.h ===
BOOL    LsaInit(VOID);
BOOL    LsaTerminate(VOID);
BOOL    SID2Name(PSID, LPSTR, UINT);
BOOL    PRIV2Name(LUID, LPSTR, UINT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\dlg.h ===
#define IDD_MAIN                    100
#define IDS_USERID                  102
#define IDS_LOGONSESSION            104
#define IDC_DEFAULTOWNER            106
#define IDL_DISABLEDGROUPS          111
#define IDB_DISABLEPRIVILEGE        112
#define IDB_ENABLEPRIVILEGE         113
#define IDL_ENABLEDPRIVILEGES       117
#define IDL_DISABLEDPRIVILEGES      118
#define IDL_ENABLEDGROUPS           123
#define IDB_DISABLEGROUP            124
#define IDB_ENABLEGROUP             125
#define IDC_PRIMARYGROUP            126
#define IDB_MORE                    110
#define IDS_TOKENID                 208
#define IDS_EXPIRATIONTIME          209
#define IDS_TOKENTYPE               210
#define IDS_IMPERSONATION           211
#define IDS_DYNAMICCHARGED          212
#define IDS_DYNAMICAVAILABLE        213
#define IDS_MODIFIEDID              214
#define IDD_MORE                    101
#define IDD_WINDOWLIST              220
#define IDLB_WINDOWLIST             222
#define IDD_ABOUT                   4000
#define IDD_ACTIVEWINDOW            4500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by secedit.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\lsa.c ===
/****************************************************************************

   PROGRAM: LSA.C

   PURPOSE: Utility routines that access the LSA.

****************************************************************************/

#include "SECEDIT.h"
#include <string.h>


// Module global that holds handle to LSA once it has been opened.
static LSA_HANDLE  LsaHandle = NULL;

LSA_HANDLE OpenLsa(VOID);
VOID    CloseLsa(LSA_HANDLE);


/****************************************************************************

   FUNCTION: LsaInit

   PURPOSE:  Does any initialization required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaInit(VOID)
{

#ifdef LSA_AVAILABLE
    LsaHandle = OpenLsa();

    return (LsaHandle != NULL);
#endif

    return (TRUE);
}


/****************************************************************************

   FUNCTION: LsaTerminate

   PURPOSE:  Does any cleanup required for this module

   RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL LsaTerminate(VOID)
{

#ifdef LSA_AVAILABLE
    if (LsaHandle != NULL) {
        CloseLsa(LsaHandle);
    }
#endif

    LsaHandle = NULL;

    return(TRUE);
}


#ifdef LSA_AVAILABLE
/****************************************************************************

   FUNCTION: OpenLsa

   PURPOSE:  Opens the Lsa
             Returns handle to Lsa or NULL on failure

****************************************************************************/
LSA_HANDLE OpenLsa(VOID)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE ConnectHandle = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open a handle to the LSA.  Specifying NULL for the Server means that the
    // server is the same as the client.
    //

    Status = LsaOpenPolicy(NULL,
                        &ObjectAttributes,
                        POLICY_LOOKUP_NAMES,
                        &ConnectHandle
                        );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Open failed 0x%lx\n", Status);
        return NULL;
    }

    return(ConnectHandle);
}


/****************************************************************************

    FUNCTION: CloseLsa

    PURPOSE:  Closes the Lsa

****************************************************************************/
VOID CloseLsa(
    LSA_HANDLE LsaHandle)
{
    NTSTATUS Status;

    Status = LsaClose(LsaHandle);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("LSM - Lsa Close failed 0x%lx\n", Status);
    }

    return;
}
#endif


#ifdef LSA_AVAILABLE
/****************************************************************************

   FUNCTION: SID2Name

   PURPOSE: Converts a SID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL SID2Name(
    PSID    Sid,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    NTSTATUS    Status;
    ANSI_STRING    AnsiName;
    PLSA_REFERENCED_DOMAIN_LIST DomainList;
    PLSA_TRANSLATED_NAME NameList;

    if (LsaHandle == NULL) {
        DbgPrint("SECEDIT : Lsa not open yet\n");
        return(FALSE);
    }



    Status = LsaLookupSids(LsaHandle, 1, &Sid, &DomainList, &NameList);

    if (NT_SUCCESS(Status)) {

        // Convert to ansi string
        RtlUnicodeStringToAnsiString(&AnsiName, &NameList->Name, TRUE);

        // Free up the returned data
        LsaFreeMemory((PVOID)DomainList);
        LsaFreeMemory((PVOID)NameList);

        // Copy the ansi string into our local variable
        strncpy(String, AnsiName.Buffer, MaxStringBytes);

        // Free up the ansi string
        RtlFreeAnsiString(&AnsiName);

        return(TRUE);
    }

    return(FALSE);
}

#else

#include "..\..\..\inc\seopaque.h"

/****************************************************************************

   FUNCTION: SID2Name

   PURPOSE: Converts a SID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL SID2Name(
    PSID    Sid,
    LPSTR   String,
    UINT    MaxStringBytes)
{
    UCHAR   Buffer[128];
    UCHAR   i;
    ULONG   Tmp;
    PISID   iSid = (PISID)Sid;  // pointer to opaque structure

    PSID    NextSid = (PSID)Alloc(RtlLengthRequiredSid(1));


    NTSTATUS       Status;
    ANSI_STRING    AnsiName;

    if (NextSid == NULL) {
        DbgPrint("SECEDIT: SID2Name failed to allocate space for SID\n");
        return(FALSE);
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_WORLD_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "World");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_LOCAL_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Local");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_CREATOR_OWNER_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Creator");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_DIALUP_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Dialup");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_NETWORK_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Network");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_BATCH_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Batch");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }

    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_INTERACTIVE_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Interactive");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }


    {
        SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
        RtlInitializeSid(NextSid, &SidAuthority, 1 );
        *(RtlSubAuthoritySid(NextSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        if (RtlEqualSid(Sid, NextSid)) {
            strcpy(String, "Local System");
            Free((PVOID)NextSid);
            return(TRUE);
        }
    }



    Free((PVOID)NextSid);


    wsprintf(Buffer, "S-%u-", (USHORT)iSid->Revision );
    lstrcpy(String, Buffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        wsprintf(Buffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        lstrcat(String, Buffer);
    } else {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        wsprintf(Buffer, "%lu", Tmp);
        lstrcat(String, Buffer);
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        wsprintf(Buffer, "-%lu", iSid->SubAuthority[i]);
        lstrcat(String, Buffer);
    }

    return(TRUE);
}
#endif


/****************************************************************************

   FUNCTION: PRIV2Name

   PURPOSE: Converts a PRIVILEGE into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL PRIV2Name(
    LUID    Privilege,
    LPSTR   lpstr,
    UINT    MaxStringBytes)
{
    NTSTATUS        Status;
    STRING          String;
    PUNICODE_STRING UString;

    LSA_HANDLE  PolicyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;



    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL);
    Status = LsaOpenPolicy( NULL, &ObjectAttributes, POLICY_LOOKUP_NAMES, &PolicyHandle);
    Status = LsaLookupPrivilegeName(PolicyHandle, &Privilege, &UString);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("SECEDIT: LsaLookupPrivilegeName failed, status = 0x%lx\n", Status);
        strcpy(lpstr, "<Unknown>");
    } else {

        //
        // Convert it to ANSI - because that's what the rest of the app is.
        //

        if (UString->Length > (USHORT)MaxStringBytes) {
            DbgPrint("SECEDIT: Truncating returned privilege name: *%Z*\n", UString);
            UString->Length = (USHORT)MaxStringBytes;
            DbgPrint("                                         To: *%Z*\n", UString);
        }

        String.Length = 0;
        String.MaximumLength = (USHORT)MaxStringBytes;
        String.Buffer = lpstr;
        Status = RtlUnicodeStringToAnsiString( &String, UString, FALSE );
        ASSERT(NT_SUCCESS(Status));
        LsaFreeMemory( UString );

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\token.h ===
typedef struct {
    DWORD                   ProcessId;
    DWORD                   ThreadId;
    PTOKEN_USER             UserId;
    PTOKEN_GROUPS           Groups;
    PTOKEN_OWNER            DefaultOwner;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup;
    PTOKEN_PRIVILEGES       Privileges;
    PTOKEN_STATISTICS       TokenStats;

} MYTOKEN;
typedef MYTOKEN *PMYTOKEN;

HANDLE  OpenMyToken(HWND);
BOOL    CloseMyToken(HWND, HANDLE, BOOL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\secedit.c ===
/****************************************************************************

   PROGRAM: SECEDIT.C

   PURPOSE: Displays the usrs current token and eventually allows the user
            to edit parts of it.

****************************************************************************/


#include "SECEDIT.h"
#include "string.h"

static char pszMainWindowClass[] = "Main Window Class";

HANDLE hInst;

// Global used to store handle to MYTOKEN
HANDLE  hMyToken;



BOOL    InitApplication(HANDLE);
BOOL    InitInstance(HANDLE, INT);
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL    EditWindowContext(HWND, HWND);
INT_PTR APIENTRY MainDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY MoreDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ListDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ActiveWindowDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    MainDlgInit(HWND, LPARAM);
BOOL    MainDlgEnd(HWND, BOOL);
BOOL    EnablePrivilege(HWND, BOOL);
BOOL    EnableGroup(HWND, BOOL);
BOOL    SetDefaultOwner(HWND);
BOOL    SetPrimaryGroup(HWND);
BOOL    MoreDlgInit(HWND hDlg);
BOOL    DisplayMyToken(HWND, HANDLE);
BOOL    ListDlgInit(HWND);
BOOL    APIENTRY WindowEnum(HWND, LPARAM);
HWND    ListDlgEnd(HWND);



/****************************************************************************

   FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

   PURPOSE: calls initialization function, processes message loop

****************************************************************************/

INT
__stdcall
WinMain(
       HINSTANCE hInstance,
       HINSTANCE hPrevInstance,
       LPSTR lpCmdLine,
       INT nCmdShow
       )
{
    MSG Message;

    if (!hPrevInstance) {
        if (!InitApplication(hInstance)) {
            DbgPrint("SECEDIT - InitApplication failed\n");
            return (FALSE);
        }
    }

    if (!InitInstance(hInstance, nCmdShow)) {
        DbgPrint("SECEDIT - InitInstance failed\n");
        return (FALSE);
    }

    while (GetMessage(&Message, NULL, 0, 0)) {
        TranslateMessage(&Message);
        DispatchMessage(&Message);
    }

    return ((int)Message.wParam);
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL
InitApplication(
               HANDLE hInstance
               )
{
    WNDCLASS  wc;
    NTSTATUS  Status;


    // Register the main window class

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  (LPSTR)IDM_MAINMENU;
    wc.lpszClassName = pszMainWindowClass;

    return (RegisterClass(&wc));
}


/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL
InitInstance(
            HANDLE hInstance,
            INT nCmdShow
            )
{
    HWND    hwnd;

    // Store instance in global
    hInst = hInstance;

    // Create the main window
    hwnd = CreateWindow(
                       pszMainWindowClass,
                       "Security Context Editor",
                       WS_OVERLAPPEDWINDOW,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       NULL,
                       NULL,
                       hInstance,
                       NULL);

    if (hwnd == NULL) {
        return(FALSE);
    }

    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);

    return (TRUE);
}


/****************************************************************************

    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LONG)

    PURPOSE:  Processes messages for main window

    COMMENTS:

****************************************************************************/

LRESULT
APIENTRY
MainWndProc(
           HWND hwnd,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    HWND    hwndEdit;
    WNDPROC lpProc;

    switch (message) {

        case WM_CREATE:
            SetHooks(hwnd);
            return(0); // Continue creating window
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {

                case IDM_PROGRAMMANAGER:

                    hwndEdit = FindWindow(NULL, "Program Manager");
                    if (hwndEdit == NULL) {
                        DbgPrint("SECEDIT : Failed to find program manager window\n");
                        break;
                    }

                    EditWindowContext(hwnd, hwndEdit);
                    break;

                case IDM_WINDOWLIST:

                    lpProc = (WNDPROC)MakeProcInstance(ListDlgProc, hInst);
                    hwndEdit = (HWND)DialogBox(hInst,(LPSTR)IDD_WINDOWLIST, hwnd, lpProc);
                    FreeProcInstance(lpProc);

                    EditWindowContext(hwnd, hwndEdit);
                    break;

                case IDM_ACTIVEWINDOW:

                    lpProc = (WNDPROC)MakeProcInstance(ActiveWindowDlgProc, hInst);
                    hwndEdit = (HWND)DialogBox(hInst,(LPSTR)IDD_ACTIVEWINDOW, hwnd, lpProc);
                    FreeProcInstance(lpProc);
                    break;

                case IDM_ABOUT:

                    lpProc = (WNDPROC)MakeProcInstance(AboutDlgProc, hInst);
                    DialogBox(hInst,(LPSTR)IDD_ABOUT, hwnd, lpProc);
                    FreeProcInstance(lpProc);
                    break;

                default:
                    break;
            }
            break;

        case WM_SECEDITNOTIFY:
            // Our hook proc posted us a message
            SetForegroundWindow(hwnd);
            EditWindowContext(hwnd, (HWND)wParam);
            break;

        case WM_DESTROY:
            ReleaseHooks(hwnd);
            PostQuitMessage(0);
            break;

        default:
            return(DefWindowProc(hwnd, message, wParam, lParam));

    }

    return 0;
}


/****************************************************************************

    FUNCTION: EditWindowContext

    PURPOSE:  Displays and allows the user to edit the security context
              of the specified window.

              Currently this means editting the security context of the
              process that owns this window

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/

BOOL
EditWindowContext(
                 HWND hwndParent,
                 HWND hwndEdit
                 )
{
    WNDPROC lpProc;

    if (hwndEdit == NULL) {
        DbgPrint("SECEDIT : hwndEdit = NULL\n");
        return(FALSE);
    }

    lpProc = (WNDPROC)MakeProcInstance(MainDlgProc, hInst);
    DialogBoxParam(hInst,(LPSTR)IDD_MAIN, hwndParent, lpProc, (LONG_PTR)hwndEdit);
    FreeProcInstance(lpProc);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MainDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    WM_COMMAND     - application menu (About dialog box)
    WM_DESTROY     - destroy window

    COMMENTS:

****************************************************************************/

INT_PTR
APIENTRY
MainDlgProc(
           HWND hDlg,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    WNDPROC lpProc;

    switch (message) {

        case WM_INITDIALOG:

            if (!MainDlgInit(hDlg, lParam)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    // we're done, drop through to quit dialog....

                case IDCANCEL:

                    MainDlgEnd(hDlg, LOWORD(wParam) == IDOK);

                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                case IDB_DISABLEPRIVILEGE:
                case IDB_ENABLEPRIVILEGE:
                    EnablePrivilege(hDlg, LOWORD(wParam) == IDB_ENABLEPRIVILEGE);
                    return(TRUE);
                    break;

                case IDB_DISABLEGROUP:
                case IDB_ENABLEGROUP:
                    EnableGroup(hDlg, LOWORD(wParam) == IDB_ENABLEGROUP);
                    return(TRUE);
                    break;

                case IDC_DEFAULTOWNER:
                    SetDefaultOwner(hDlg);
                    return(TRUE);

                case IDC_PRIMARYGROUP:
                    SetPrimaryGroup(hDlg);
                    return(TRUE);

                case IDB_MORE:

                    lpProc = (WNDPROC)MakeProcInstance(MoreDlgProc, hInst);
                    DialogBox(hInst,(LPSTR)IDD_MORE, hDlg, lpProc);
                    FreeProcInstance(lpProc);
                    return(TRUE);

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

#ifdef NTBUILD
    DBG_UNREFERENCED_PARAMETER(lParam);
#endif
}


/****************************************************************************

    FUNCTION: MainDlgInit(HWND)

    PURPOSE:  Initialises the controls in the main dialog window.

    RETURNS:   TRUE on success, FALSE if dialog should be terminated.

****************************************************************************/
BOOL
MainDlgInit(
           HWND    hDlg,
           LPARAM  lParam
           )
{
    HWND        hwnd = (HWND)lParam;
    CHAR        string[MAX_STRING_BYTES];
    INT         length;

    // Since we use a global to store the pointer to our MYTOKEN
    // structure, check we don't get called again before we have
    // quit out of the last dialog.
    if (hMyToken != NULL) {
        DbgPrint("SECEDIT: Already editting a context\n");
        return(FALSE);
    }

    if (hwnd == NULL) {
        DbgPrint("SECEDIT: Window handle is NULL\n");
        return(FALSE);
    }

    if (!LsaInit()) {
        DbgPrint("SECEDIT - LsaInit failed\n");
        return(FALSE);
    }

    hMyToken = OpenMyToken(hwnd);
    if (hMyToken == NULL) {
        DbgPrint("SECEDIT: Failed to open mytoken\n");

        strcpy(string, "Unable to access security context for\n<");
        length = strlen(string);
        GetWindowText(hwnd, &(string[length]), MAX_STRING_BYTES - length);
        strcat(string, ">");
        MessageBox(hDlg, string, NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

        LsaTerminate();
        return(FALSE);
    }

    DisplayMyToken(hDlg, hMyToken);

    // Set the dialog caption appropriately
    GetWindowText(hDlg, string, MAX_STRING_BYTES);
    strcat(string, " for <");
    length = strlen(string);
    GetWindowText(hwnd, &string[length], MAX_STRING_BYTES - length);
    strcat(string, ">");
    SetWindowText(hDlg, string);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MainDlgEnd(HWND)

    PURPOSE:  Do whatever we have to do to clean up when dialog ends

    RETURNS:  TRUE on success, FALSE on failure.

****************************************************************************/
BOOL
MainDlgEnd(
          HWND    hDlg,
          BOOL    fSaveChanges
          )
{
    BOOL Success;

    LsaTerminate();

    Success = CloseMyToken(hDlg, hMyToken, fSaveChanges);

    hMyToken = NULL;

    return(Success);
}


/****************************************************************************

    FUNCTION: DisplayMyToken

    PURPOSE:  Reads data out of mytoken and puts in dialog controls.

    RETURNS:   TRUE on success, FALSE on failure

****************************************************************************/
BOOL
DisplayMyToken(
              HWND    hDlg,
              HANDLE  hMyToken
              )
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    CHAR        string[MAX_STRING_BYTES];
    UINT        GroupIndex;
    UINT        PrivIndex;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    //
    // Authentication ID
    //
    if (pMyToken->TokenStats != NULL) {

        wsprintf(string, "0x%lx-%lx",
                 pMyToken->TokenStats->AuthenticationId.HighPart,
                 pMyToken->TokenStats->AuthenticationId.LowPart);

        SetDlgItemText(hDlg, IDS_LOGONSESSION, string);

    } else {
        DbgPrint("SECEDIT : No token statistics in mytoken\n");
    }

    //
    // Groups
    //
    if (pMyToken->Groups != NULL) {

        for (GroupIndex=0; GroupIndex < pMyToken->Groups->GroupCount; GroupIndex++ ) {

            PSID Sid = pMyToken->Groups->Groups[GroupIndex].Sid;
            ULONG Attributes = pMyToken->Groups->Groups[GroupIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_GROUP_ENABLED) {
                ControlID = IDL_ENABLEDGROUPS;
            } else {
                ControlID = IDL_DISABLEDGROUPS;
            }

            if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

                // Add to disable or enabled group box
                AddLBItem(hDlg, ControlID, string, GroupIndex);

                // Add this group to default owner combo box if it's valid
                if (Attributes & SE_GROUP_OWNER) {
                    AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LONG_PTR)Sid);
                }

                // Add this group to primary group combo box
                AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LONG_PTR)Sid);

            } else {
                DbgPrint("SECEDIT: Failed to convert Group sid to string\n");
            }
        }
    } else {
        DbgPrint("SECEDIT : No group info in mytoken\n");
    }


    //
    // User ID
    //
    if (pMyToken->UserId != NULL) {

        PSID    Sid = pMyToken->UserId->User.Sid;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            // Set user-name static text
            SetDlgItemText(hDlg, IDS_USERID, string);

            // Add to default owner combo box
            AddCBItem(hDlg, IDC_DEFAULTOWNER, string, (LONG_PTR)Sid);

            // Add to primary group combo box
            AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LONG_PTR)Sid);

        } else {
            DbgPrint("SECEDIT: Failed to convert User ID SID to string\n");
        }

    } else {
        DbgPrint("SECEDIT: No user id in mytoken\n");
    }


    //
    // Default Owner
    //
    if (pMyToken->DefaultOwner != NULL) {

        PSID    Sid = pMyToken->DefaultOwner->Owner;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {

            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_DEFAULTOWNER, Sid);

            if (iItem >= 0) {
                SendMessage(GetDlgItem(hDlg, IDC_DEFAULTOWNER), CB_SETCURSEL, iItem, 0);
            } else {
                DbgPrint("SECEDIT: Default Owner is not userID or one of our groups\n");
            }

        } else {
            DbgPrint("SECEDIT: Failed to convert Default Owner SID to string\n");
        }
    } else {
        DbgPrint("SECEDIT: No default owner in mytoken\n");
    }


    //
    // Primary group
    //

    if (pMyToken->PrimaryGroup != NULL) {

        PSID    Sid = pMyToken->PrimaryGroup->PrimaryGroup;

        if (SID2Name(Sid, string, MAX_STRING_BYTES)) {
            INT     iItem;

            iItem = FindCBSid(hDlg, IDC_PRIMARYGROUP, Sid);

            if (iItem < 0) {
                // Group is not already in combo-box, add it
                iItem = AddCBItem(hDlg, IDC_PRIMARYGROUP, string, (LONG_PTR)Sid);
            }

            // Select the primary group
            SendMessage(GetDlgItem(hDlg, IDC_PRIMARYGROUP), CB_SETCURSEL, iItem, 0);

        } else {
            DbgPrint("SECEDIT: Failed to convert primary group SID to string\n");
        }
    } else {
        DbgPrint("SECEDIT: No primary group in mytoken\n");
    }


    //
    // Privileges
    //

    if (pMyToken->Privileges != NULL) {

        for (PrivIndex=0; PrivIndex < pMyToken->Privileges->PrivilegeCount; PrivIndex++ ) {

            LUID Privilege = pMyToken->Privileges->Privileges[PrivIndex].Luid;
            ULONG Attributes = pMyToken->Privileges->Privileges[PrivIndex].Attributes;
            USHORT  ControlID;

            if (Attributes & SE_PRIVILEGE_ENABLED) {
                ControlID = IDL_ENABLEDPRIVILEGES;
            } else {
                ControlID = IDL_DISABLEDPRIVILEGES;
            }

            if (PRIV2Name(Privilege, string, MAX_STRING_BYTES)) {

                // Add this privelege to the appropriate list-box
                AddLBItem(hDlg, ControlID, string, PrivIndex);

            } else {
                DbgPrint("SECEDIT: Failed to convert privilege to string\n");
            }
        }
    } else {
        DbgPrint("SECEDIT: No privelege info in mytoken\n");
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnablePrivilege(HWND, fEnable)

    PURPOSE:  Enables or disables one or more privileges.
              If fEnable = TRUE, the selected privileges in the disabled
              privilege control are enabled.
              Vice versa for fEnable = FALSE

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL
EnablePrivilege(
               HWND    hDlg,
               BOOL    fEnable
               )
{
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_PRIVILEGES Privileges;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    Privileges = pMyToken->Privileges;
    if (Privileges == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDPRIVILEGES;
        idTo   = IDL_ENABLEDPRIVILEGES;
    } else {
        idFrom = IDL_ENABLEDPRIVILEGES;
        idTo   = IDL_DISABLEDPRIVILEGES;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);


    // Find how many items are selected
    //
    cItems = (int)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems =  (int)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    PrivIndex;
        UCHAR   PrivilegeName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        PrivIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)PrivilegeName);


        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add privilege to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)PrivilegeName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LONG)PrivIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Privileges->Privileges[PrivIndex].Attributes |= SE_PRIVILEGE_ENABLED;
        } else {
            Privileges->Privileges[PrivIndex].Attributes &= ~SE_PRIVILEGE_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: EnableGroup(HWND, fEnable)

    PURPOSE:  Enables or disables one or more selected groups.
              If fEnable = TRUE, the selected groups in the disabled
              group control are enabled.
              If fEnable = FALSE the selected groups in the enabled
              group control are disabled.

    RETURNS:    TRUE on success, FALSE on failure

****************************************************************************/
BOOL
EnableGroup(
           HWND    hDlg,
           BOOL    fEnable
           )
{
    HWND    hwndFrom;
    HWND    hwndTo;
    USHORT  idFrom;
    USHORT  idTo;
    INT     cItems;
    PINT    pItems;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_GROUPS Groups;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    Groups = pMyToken->Groups;
    if (Groups == NULL) {
        return(FALSE);
    }

    // Calculate source and destination controls
    //
    if (fEnable) {
        idFrom = IDL_DISABLEDGROUPS;
        idTo   = IDL_ENABLEDGROUPS;
    } else {
        idFrom = IDL_ENABLEDGROUPS;
        idTo   = IDL_DISABLEDGROUPS;
    }
    hwndFrom = GetDlgItem(hDlg, idFrom);
    hwndTo   = GetDlgItem(hDlg, idTo);

    // Find how many items are selected
    //
    cItems = (int)SendMessage(hwndFrom, LB_GETSELCOUNT, 0, 0);
    if (cItems <= 0) {
        // No items selected
        return(TRUE);
    }

    // Allocate space for the item array
    //
    pItems = Alloc(cItems * sizeof(*pItems));
    if (pItems == NULL) {
        return(FALSE);
    }

    // Read the selected items into the array
    //
    cItems =  (int)SendMessage(hwndFrom, LB_GETSELITEMS, (WPARAM)cItems, (LPARAM)pItems);
    if (cItems == LB_ERR) {
        // Something went wrong
        Free(pItems);
        return(FALSE);
    }


    while (cItems-- > 0) {

        INT     iItem;
        UINT    GroupIndex;
        UCHAR   GroupName[MAX_STRING_BYTES];

        iItem = pItems[cItems];  // Read the item index from the selected item array

        // Read the text and data from the source item
        //
        GroupIndex = (UINT)SendMessage(hwndFrom, LB_GETITEMDATA, iItem, 0);
        SendMessage(hwndFrom, LB_GETTEXT, iItem, (LPARAM)GroupName);

        // Check it's not a mandatory group (Can-not be disabled)
        //
        if (Groups->Groups[GroupIndex].Attributes & SE_GROUP_MANDATORY) {
            CHAR    buf[256];
            strcpy(buf, "'");
            strcat(buf, GroupName);
            strcat(buf, "' is a mandatory group and cannot be disabled");
            MessageBox(hDlg, buf, NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
            continue;   // skip to next group
        }

        // Delete item from source control
        //
        SendMessage(hwndFrom, LB_DELETESTRING, iItem, 0);


        // Add item to destination control
        //
        iItem = (INT)SendMessage(hwndTo, LB_ADDSTRING, 0, (LPARAM)GroupName);
        SendMessage(hwndTo, LB_SETITEMDATA, iItem, (LONG)GroupIndex);


        // Modify global data structure to reflect change
        //
        if (fEnable) {
            Groups->Groups[GroupIndex].Attributes |= SE_GROUP_ENABLED;
        } else {
            Groups->Groups[GroupIndex].Attributes &= ~SE_GROUP_ENABLED;
        }
    }

    // Free up space allocated for selected item array
    Free(pItems);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetDefaultOwner()

    PURPOSE:  Sets the default owner to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
SetDefaultOwner(
               HWND    hDlg
               )
{
    HWND    hwnd;
    INT     iItem;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_OWNER DefaultOwner;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    DefaultOwner = pMyToken->DefaultOwner;
    if (DefaultOwner == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_DEFAULTOWNER);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    DefaultOwner->Owner = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: SetPrimaryGroup()

    PURPOSE:  Sets the primary group to the new value selected by the user.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
SetPrimaryGroup(
               HWND    hDlg
               )
{
    HWND    hwnd;
    INT     iItem;
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    PrimaryGroup = pMyToken->PrimaryGroup;
    if (PrimaryGroup == NULL) {
        return(FALSE);
    }

    hwnd = GetDlgItem(hDlg, IDC_PRIMARYGROUP);

    iItem = (INT)SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    if (iItem == CB_ERR) {
        // No selection ?
        return(FALSE);
    }

    // Modify global data structure to reflect change
    PrimaryGroup->PrimaryGroup = (PSID)SendMessage(hwnd, CB_GETITEMDATA, iItem, 0);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: MoreDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR
APIENTRY
MoreDlgProc(
           HWND hDlg,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{

    switch (message) {

        case WM_INITDIALOG:

            if (!MoreDlgInit(hDlg)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:

                    // we're done, drop through to quit dialog....

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: MoreDlgInit(HWND)

    PURPOSE:  Initialises the controls in the more dialog window.

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
MoreDlgInit(
           HWND    hDlg
           )
{
    CHAR    string[MAX_STRING_BYTES];
    PMYTOKEN pMyToken = (PMYTOKEN)hMyToken;
    PTOKEN_STATISTICS Statistics;

    if (pMyToken == NULL) {
        return(FALSE);
    }

    Statistics = pMyToken->TokenStats;
    if (Statistics == NULL) {
        DbgPrint("SECEDIT: No token statistics in mytoken\n");
        return(FALSE);
    }

    if (LUID2String(Statistics->TokenId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENID, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert tokenid luid to string\n");
    }

    if (Time2String(Statistics->ExpirationTime, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_EXPIRATIONTIME, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert expiration time to string\n");
    }

    if (TokenType2String(Statistics->TokenType, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_TOKENTYPE, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert token type to string\n");
    }

    if (Statistics->TokenType == TokenPrimary) {
        SetDlgItemText(hDlg, IDS_IMPERSONATION, "N/A");
    } else {
        if (ImpersonationLevel2String(Statistics->ImpersonationLevel, string, MAX_STRING_BYTES)) {
            SetDlgItemText(hDlg, IDS_IMPERSONATION, string);
        } else {
            DbgPrint("SECEDIT: Failed to convert impersonation level to string\n");
        }
    }

    if (Dynamic2String(Statistics->DynamicCharged, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICCHARGED, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert dynamic charged to string\n");
    }

    if (Dynamic2String(Statistics->DynamicAvailable, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_DYNAMICAVAILABLE, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert dynamic available to string\n");
    }

    if (LUID2String(Statistics->ModifiedId, string, MAX_STRING_BYTES)) {
        SetDlgItemText(hDlg, IDS_MODIFIEDID, string);
    } else {
        DbgPrint("SECEDIT: Failed to convert modifiedid luid to string\n");
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: ListDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR
APIENTRY
ListDlgProc(
           HWND hDlg,
           UINT message,
           WPARAM wParam,
           LPARAM lParam
           )
{
    HWND    hwndEdit = NULL;

    switch (message) {

        case WM_INITDIALOG:

            if (!ListDlgInit(hDlg)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    hwndEdit = ListDlgEnd(hDlg);

                    // We're done, drop through to enddialog...

                case IDCANCEL:
                    EndDialog(hDlg, (INT_PTR)hwndEdit);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: ListDlgInit(HWND)

    PURPOSE:  Initialise the window list dialog

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
ListDlgInit(
           HWND    hDlg
           )
{
    // Fill the list box with top-level windows and their handles
    EnumWindows(WindowEnum, (LONG_PTR)hDlg);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: WindowEnum

    PURPOSE:  Window enumeration call-back function.
              Adds each window to the window list-box

    RETURNS:  TRUE to continue enumeration, FALSE to stop.

****************************************************************************/
BOOL
APIENTRY
WindowEnum(
          HWND    hwnd,
          LPARAM  lParam
          )
{
    HWND    hDlg = (HWND)lParam;
    CHAR    string[MAX_STRING_BYTES];

    if (GetWindowText(hwnd, string, MAX_STRING_BYTES) != 0) {

        // This window has a caption, so add it to the list-box

        AddLBItem(hDlg, IDLB_WINDOWLIST, string, (LONG_PTR)hwnd);
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: ListDlgEnd(HWND)

    PURPOSE:  Cleans up after window list dialog

    RETURNS:  handle to window the user has selected or NULL

****************************************************************************/
HWND
ListDlgEnd(
          HWND    hDlg
          )
{
    HWND    hwndListBox = GetDlgItem(hDlg, IDLB_WINDOWLIST);
    HWND    hwndEdit;
    INT     iItem;

    // Read selection from list-box and get its hwnd

    iItem = (INT)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);

    if (iItem == LB_ERR) {
        // No selection
        hwndEdit = NULL;
    } else {
        hwndEdit = (HWND)SendMessage(hwndListBox, LB_GETITEMDATA, iItem, 0);
    }

    return (hwndEdit);
}


/****************************************************************************

    FUNCTION: AboutDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for About dialog

****************************************************************************/

INT_PTR
APIENTRY
AboutDlgProc(
            HWND    hDlg,
            UINT    message,
            WPARAM  wParam,
            LPARAM  lParam
            )
{

    switch (message) {

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:

                    // we're done, drop through to quit dialog....

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: ActiveWindowDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for Active Window Dialog

****************************************************************************/

INT_PTR
APIENTRY
ActiveWindowDlgProc(
                   HWND    hDlg,
                   UINT    message,
                   WPARAM  wParam,
                   LPARAM  lParam
                   )
{
    switch (message) {
        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:

                    // we're done, drop through to quit dialog....

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\secedit.h ===
#ifdef WIN32
#define LSA_AVAILABLE
#define NTBUILD
#endif

#ifndef RC_INVOKED
#ifdef NTBUILD
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#endif

#include <windows.h>

#ifndef RC_INVOKED
#include <ntlsa.h>
#include <port1632.h>

#include "..\global.h"
#endif

#include "dlg.h"

typedef PVOID   *PPVOID;

// Resource ids
#define IDM_MAINMENU                    3000
#define IDM_ABOUT                       3001
#define IDM_PROGRAMMANAGER              3002
#define IDM_WINDOWLIST                  3003
#define IDM_ACTIVEWINDOW                3004
#define IDI_APPICON                     3005

// Define the maximum length of a resource string
#define MAX_STRING_LENGTH       255
#define MAX_STRING_BYTES        (MAX_STRING_LENGTH + 1)

#ifndef RC_INVOKED
#include "token.h"
#include "util.h"
#include "lsa.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\util.h ===
PVOID   Alloc(SIZE_T);
SIZE_T  GetAllocSize(PVOID);
BOOL    Free(PVOID);

BOOL    LUID2String(LUID, LPSTR, UINT);
BOOL    Time2String(TIME, LPSTR, UINT);
BOOL    TokenType2String(TOKEN_TYPE, LPSTR, UINT);
BOOL    ImpersonationLevel2String(SECURITY_IMPERSONATION_LEVEL, LPSTR, UINT);
BOOL    Dynamic2String(ULONG, LPSTR, UINT);
INT     AddItem(HWND, INT, LPSTR, LONG_PTR, BOOL);
INT     FindSid(HWND, INT, PSID, BOOL);
BOOL    SetHooks(HWND);
BOOL    ReleaseHooks(HWND);

// Useful macros

#define AddLBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, FALSE))

#define AddCBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, TRUE))

#define FindLBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, FALSE))

#define FindCBSid(hDlg, ControlID, data) \
        (FindSid(hDlg, ControlID, data, TRUE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\token.c ===
/****************************************************************************

   PROGRAM: TOKEN.C

   PURPOSE: Contains routines that manipulate tokens

****************************************************************************/

#include "SECEDIT.h"

HANDLE  AllocMyToken(VOID);
BOOL    ReadMyToken(HANDLE);
BOOL    WriteMyToken(HWND, HANDLE);
BOOL    FreeMyToken(HANDLE);
HANDLE  OpenToken(HANDLE, ACCESS_MASK);
BOOL    CloseToken(HANDLE);
PVOID   AllocTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS);
BOOL    GetTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS, PPVOID);
BOOL    SetTokenInfo(HANDLE, TOKEN_INFORMATION_CLASS, PVOID);
BOOL    FreeTokenInfo(PVOID);


/****************************************************************************

   FUNCTION: OpenMyToken

   PURPOSE: Opens the token of the process of the specified window.

   RETURNS : Handle to mytoken on success, or NULL on failure.

****************************************************************************/

HANDLE OpenMyToken(
    HWND    hwnd)
{
    DWORD       ThreadId;
    DWORD       ProcessId;
    PMYTOKEN    pMyToken;
    HANDLE      hMyToken;

    ThreadId = GetWindowThreadProcessId(hwnd, &ProcessId);

    DbgPrint("Process Id = %ld, ThreadId = %ld\n", ProcessId, ThreadId);

    if (ThreadId == 0) {
        DbgPrint("SECEDIT: GetWindowThreadProcessId failed\n");
        return(NULL);
    }

    //
    // Build a MYTOKEN structure.

    hMyToken = AllocMyToken();
    if (hMyToken == NULL) {
        return(NULL);
    }

    pMyToken = (PMYTOKEN)hMyToken;

    pMyToken->ProcessId = ProcessId;
    pMyToken->ThreadId = ThreadId;

    if (!ReadMyToken(hMyToken)) {
        DbgPrint("SECEDIT : Failed to read token info\n");
        Free(pMyToken);
        return(NULL);
    }

    return(hMyToken);
}


/****************************************************************************

   FUNCTION: ReadMyToken

   PURPOSE: Reads the token info and stores in mytoken structure

   RETURNS : TRUE on success, FALSE on failure

****************************************************************************/

BOOL ReadMyToken(
    HANDLE  hMyToken)
{
    HANDLE      Token;
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    Token = OpenToken(hMyToken, TOKEN_QUERY);

    if (Token == NULL) {
        DbgPrint("SECEDIT : Failed to open the token with TOKEN_QUERY access\n");
        return(FALSE);
    }

    if (!GetTokenInfo(Token, TokenStatistics, (PPVOID)&(pMyToken->TokenStats))) {
        DbgPrint("SECEDIT : Failed to read token statistics from token\n");
    }

    if (!GetTokenInfo(Token, TokenGroups, (PPVOID)&(pMyToken->Groups))) {
        DbgPrint("SECEDIT : Failed to read group info from token\n");
    }

    if (!GetTokenInfo(Token, TokenUser, (PPVOID)&(pMyToken->UserId))) {
        DbgPrint("SECEDIT : Failed to read userid from token\n");
    }

    if (!GetTokenInfo(Token, TokenOwner, (PPVOID)&(pMyToken->DefaultOwner))) {
        DbgPrint("SECEDIT : Failed to read default owner from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrimaryGroup, (PPVOID)&(pMyToken->PrimaryGroup))) {
        DbgPrint("SECEDIT : Failed to read primary group from token\n");
    }

    if (!GetTokenInfo(Token, TokenPrivileges, (PPVOID)&(pMyToken->Privileges))) {
        DbgPrint("SECEDIT : Failed to read privilege info from token\n");
    }

    CloseToken(Token);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: CloseMyToken

   PURPOSE: Closes the specified mytoken handle
            If fSaveChanges = TRUE, the token information is saved,
            otherwise it is discarded.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseMyToken(
    HWND    hDlg,
    HANDLE  hMyToken,
    BOOL    fSaveChanges)
{
    if (fSaveChanges) {
        WriteMyToken(hDlg, hMyToken);
    }

    return FreeMyToken(hMyToken);
}

/****************************************************************************

   FUNCTION: AllocMyToken

   PURPOSE: Allocates space for mytoken structure.

   RETURNS : HANDLE to mytoken or NULL on failure.

****************************************************************************/

HANDLE AllocMyToken(VOID)
{
    PMYTOKEN    pMyToken;

    pMyToken = (PMYTOKEN)Alloc(sizeof(MYTOKEN));

    return((HANDLE)pMyToken);
}


/****************************************************************************

   FUNCTION: FreeMyToken

   PURPOSE: Frees the memory allocated to mytoken structure.

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL FreeMyToken(
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;

    if (pMyToken->TokenStats != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->TokenStats));
    }

    if (pMyToken->UserId != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->UserId));
    }

    if (pMyToken->PrimaryGroup != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->PrimaryGroup));
    }

    if (pMyToken->DefaultOwner != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->DefaultOwner));
    }

    if (pMyToken->Groups != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Groups));
    }

    if (pMyToken->Privileges != NULL) {
        FreeTokenInfo((PVOID)(pMyToken->Privileges));
    }

    Free((PVOID)pMyToken);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: WriteMyToken

   PURPOSE: Writes the token information out to the token

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL WriteMyToken(
    HWND    hDlg,
    HANDLE  hMyToken)
{
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    HANDLE      Token;

    //
    // Save default owner and primary group
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_DEFAULT);

    if (Token == NULL) {

        DbgPrint("SECEDIT: Failed to open token with TOKEN_ADJUST_DEFAULT access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change default owner or primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        // Set default owner
        //
        if ((pMyToken->DefaultOwner != NULL) &&
           (!SetTokenInfo(Token, TokenOwner, (PVOID)(pMyToken->DefaultOwner)))) {
            MessageBox(hDlg, "Failed to set default owner", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        // Set primary group
        //
        if ((pMyToken->PrimaryGroup != NULL) &&
           (!SetTokenInfo(Token, TokenPrimaryGroup, (PVOID)(pMyToken->PrimaryGroup)))) {
            MessageBox(hDlg, "Failed to set primary group", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    //
    // Save group info
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_GROUPS);

    if (Token == NULL) {

        DbgPrint("SECEDIT: Failed to open token with TOKEN_ADJUST_GROUPS access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Groups != NULL) &&
           (!SetTokenInfo(Token, TokenGroups, (PVOID)(pMyToken->Groups)))) {
            MessageBox(hDlg, "Failed to change group settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }


    //
    // Change privileges
    //

    Token = OpenToken(hMyToken, TOKEN_ADJUST_PRIVILEGES);

    if (Token == NULL) {

        DbgPrint("SECEDIT: Failed to open token with TOKEN_ADJUST_PRIVILEGES access\n");
        MessageBox(hDlg, "Failed to open token with access required\nUnable to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);

    } else {

        if ((pMyToken->Privileges != NULL) &&
           (!SetTokenInfo(Token, TokenPrivileges, (PVOID)(pMyToken->Privileges)))) {
            MessageBox(hDlg, "Failed to change privilege settings", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        }

        CloseToken(Token);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: OpenToken

   PURPOSE: Opens the token with the specified access

   RETURNS : Handle to token on success, or NULL on failure.

****************************************************************************/

HANDLE OpenToken(
    HANDLE      hMyToken,
    ACCESS_MASK DesiredAccess)
{
    NTSTATUS    Status;
    HANDLE      Token;
    HANDLE      Process;
    PMYTOKEN    pMyToken = (PMYTOKEN)hMyToken;
    DWORD       ThreadId = pMyToken->ThreadId;
    DWORD       ProcessId = pMyToken->ProcessId;

    Process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, ProcessId);
    if (Process == NULL) {
        DbgPrint("SECEDIT: OpenProcess failed, last error = %ld\n", GetLastError());
        return(NULL);
    }

    Status = NtOpenProcessToken(
                 Process,
                 DesiredAccess,
                 &Token
                 );

    CloseHandle(Process);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("SECEDIT: Failed to open token with access = 0x%x, status = 0x%lx\n", DesiredAccess, Status);
        return(NULL);
    }

    return(Token);
}


/****************************************************************************

   FUNCTION: CloseToken

   PURPOSE: Closes the specified token handle

   RETURNS : TRUE on success, FALSE on failure.

****************************************************************************/

BOOL CloseToken(
    HANDLE  Token)
{
    NTSTATUS    Status;

    Status = NtClose(Token);

    return(TRUE);
}


/****************************************************************************

   FUNCTION: AllocTokenInfo

   PURPOSE: Allocates memory to hold the parameter that
            NTQueryInformationToken will return.
            Memory should be freed later using FreeTokenInfo

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID AllocTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass)
{
    NTSTATUS Status;
    ULONG   InfoLength;

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 NULL,                     // TokenInformation
                 0,                        // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
#ifdef NTBUILD
        DbgPrint("SECEDIT: NtQueryInformationToken did NOT return buffer_too_small, status = 0x%lx\n", Status);
#endif
        return(NULL);
    }

    return Alloc(InfoLength);
}


/****************************************************************************

   FUNCTION: FreeTokenInfo

   PURPOSE: Frees the memory previously allocated with AllocTokenInfo

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL FreeTokenInfo(
    PVOID   Buffer)
{
    return(Free(Buffer));
}


/****************************************************************************

   FUNCTION: GetTokenInfo

   PURPOSE: Allocates a buffer and reads the specified data
            out of the token and into it.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL GetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PPVOID   pBuffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;
    ULONG   InfoLength;
    PVOID   Buffer;

    *pBuffer = NULL;    // Prepare for failure

    Buffer = AllocTokenInfo(Token, TokenInformationClass);
    if (Buffer == NULL) {
        return(FALSE);
    }

    BufferSize = (ULONG)GetAllocSize(Buffer);

    Status = NtQueryInformationToken(
                 Token,                    // Handle
                 TokenInformationClass,    // TokenInformationClass
                 Buffer,                   // TokenInformation
                 BufferSize,               // TokenInformationLength
                 &InfoLength               // ReturnLength
                 );

    if (!NT_SUCCESS(Status)) {
#ifdef NTBUILD
        DbgPrint("SECEDIT: NtQueryInformationToken failed, status = 0x%lx\n", Status);
#endif
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    if (InfoLength > BufferSize) {
#ifdef NTBUILD
        DbgPrint("SECEDIT: NtQueryInformationToken failed, DataSize > BufferSize");
#endif
        FreeTokenInfo(Buffer);
        return(FALSE);
    }

    *pBuffer = Buffer;

    return(TRUE);
}


/****************************************************************************

   FUNCTION: SetTokenInfo

   PURPOSE: Sets the specified information in the given token.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/

BOOL SetTokenInfo(
    HANDLE  Token,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID   Buffer)
{
    NTSTATUS Status;
    ULONG   BufferSize;

    BufferSize = (ULONG)GetAllocSize(Buffer);

    switch (TokenInformationClass) {

    case TokenOwner:
    case TokenPrimaryGroup:
    case TokenDefaultDacl:

        Status = NtSetInformationToken(
                     Token,                    // Handle
                     TokenInformationClass,    // TokenInformationClass
                     Buffer,                   // TokenInformation
                     BufferSize                // TokenInformationLength
                     );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("SECEDIT: NtSetInformationToken failed, info class = 0x%x, status = 0x%lx\n",
                                TokenInformationClass, Status);
            return(FALSE);
        }
        break;


    case TokenGroups:

        Status = NtAdjustGroupsToken(
                    Token,                      // Handle
                    FALSE,                      // Reset to default
                    (PTOKEN_GROUPS)Buffer,      // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("SECEDIT: NtAdjustGroupsToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    case TokenPrivileges:

        Status = NtAdjustPrivilegesToken(
                    Token,                      // Handle
                    FALSE,                      // Disable all privileges
                    (PTOKEN_PRIVILEGES)Buffer,  // New State
                    BufferSize,                 // Buffer Length
                    NULL,                       // Previous State
                    NULL                        // Return Length
                    );

        if (!NT_SUCCESS(Status)) {
            DbgPrint("SECEDIT: NtAdjustPrivilegesToken failed, status = 0x%lx\n", Status);
            return(FALSE);
        }
        break;


    default:

        // Unrecognised information type
        DbgPrint("SECEDIT: SetTokenInfo passed unrecognised infoclass, class = 0x%x\n", TokenInformationClass);

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\command.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL PerfmonCommand (HWND hwnd, 
                     WPARAM wParam, 
                     LPARAM lParam) ;


void PrepareMenu (HMENU hMenu) ;

void ViewChart (HWND hWnd) ;

void ViewLog (HWND hWnd) ;

void ViewAlert (HWND hWnd) ;

void ViewReport (HWND hWnd) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\dll\hookdll.c ===
/****************************************************************************

   PROGRAM: SECEDIT.C

   PURPOSE: Displays the usrs current token and eventually allows the user
            to edit parts of it.

****************************************************************************/


#include "hookdll.h"


/****************************************************************************

   FUNCTION: KeyboardHookProc

   PURPOSE: Handles keyboard input

   RETURNS: 1 if message should be discarded, 0 for normal processing

****************************************************************************/

LRESULT
APIENTRY
KeyboardHookProc(
    INT     nCode,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    HWND    hwndNotify;
    HWND    hwndEdit;

    if (nCode < 0) {
        return(CallNextHookEx(NULL, nCode, wParam, lParam));
    }

    // Is F11 being pressed ?
    if ((wParam == VK_F11) && ((lParam & (1<<31)) == 0)) {

        // Yes, notify our parent app
        hwndNotify = FindWindow(NULL, "Security Context Editor");

        hwndEdit = GetActiveWindow();

        if (hwndNotify != NULL) {
            PostMessage(hwndNotify, WM_SECEDITNOTIFY, (WPARAM)hwndEdit, 0);

            return(1);  // Stop anyone else getting this key press
        } else {
            DbgPrint("SECEDIT: Keyboard hook could not find app window\n");
        }
    }

    return(CallNextHookEx(NULL, nCode, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\dll\hookdll.h ===
#ifdef WIN32
#define NTBUILD
#endif

#ifdef NTBUILD
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif
#include <windows.h>
#include <port1632.h>

#include "..\global.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\secedit\app\util.c ===
/****************************************************************************

   PROGRAM: UTIL.C

   PURPOSE: System utility routines

****************************************************************************/

#include "SECEDIT.h"
#include <string.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID
Alloc(
     SIZE_T   Bytes
     )
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

SIZE_T
GetAllocSize(
            PVOID   Buffer)
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL
Free(
    PVOID   Buffer
    )
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


/****************************************************************************

   FUNCTION: LUID2String

   PURPOSE: Converts a LUID into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
LUID2String(
           LUID    Luid,
           LPSTR   String,
           UINT    MaxStringBytes
           )
{

    if (Luid.HighPart == 0) {
        wsprintf(String, "0x%lx", Luid.LowPart);
    } else {
        wsprintf(String, "0x%lx%08lx", Luid.HighPart, Luid.LowPart);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Time2String

   PURPOSE: Converts a time into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
Time2String(
           TIME    Time,
           LPSTR   String,
           UINT    MaxStringBytes
           )
{
    TIME_FIELDS TimeFields;

    RtlTimeToTimeFields(&Time, &TimeFields);

    if (TimeFields.Year > 2900) {
        strcpy(String, "Never");
    } else {
        wsprintf(String, "%d/%d/%d  %02d:%02d:%02d",
                 TimeFields.Year, TimeFields.Month, TimeFields.Day,
                 TimeFields.Hour, TimeFields.Minute, TimeFields.Second);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: TokenType2String

   PURPOSE: Converts a tokentype into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
TokenType2String(
                TOKEN_TYPE TokenType,
                LPSTR   String,
                UINT    MaxStringBytes
                )
{

    switch (TokenType) {

        case TokenPrimary:
            strcpy(String, "Primary");
            break;

        case TokenImpersonation:
            strcpy(String, "Impersonation");
            break;

        default:
            DbgPrint("SECEDIT: TokenType2String fed unrecognised token type : 0x%x\n", TokenType);
            return(FALSE);
            break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: ImpersonationLevel2String

   PURPOSE: Converts an impersonation level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
ImpersonationLevel2String(
                         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
                         LPSTR   String,
                         UINT    MaxStringBytes
                         )
{

    switch (ImpersonationLevel) {

        case SecurityAnonymous:
            strcpy(String, "Anonymous");
            break;

        case SecurityIdentification:
            strcpy(String, "Identification");
            break;

        case SecurityImpersonation:
            strcpy(String, "Impersonation");
            break;

        case SecurityDelegation:
            strcpy(String, "Delegation");
            break;

        default:
            DbgPrint("SECEDIT: ImpersonationLevel2String fed unrecognised impersonation level : 0x%x\n", ImpersonationLevel);
            return(FALSE);
            break;
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: Dynamic2String

   PURPOSE: Converts an dynamic quota level into a readable string.

   RETURNS : TRUE on success otherwise FALSE.

****************************************************************************/
BOOL
Dynamic2String(
              ULONG   Dynamic,
              LPSTR   String,
              UINT    MaxStringBytes
              )
{
    wsprintf(String, "%ld", Dynamic);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: AddItem

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT
AddItem(
       HWND    hDlg,
       INT     ControlID,
       LPSTR   String,
       LONG_PTR Data,
       BOOL    fCBox
       )
{
    HWND    hwnd;
    INT_PTR iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    iItem = SendMessage(hwnd, AddStringMsg, 0, (LONG_PTR)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return((INT)iItem);
}


/****************************************************************************

    FUNCTION: FindSid

    PURPOSE:  Searches for the specified Sid in a control.

    RETURNS:  Index of matching item or < 0 on error

****************************************************************************/
INT
FindSid(
       HWND    hDlg,
       INT     ControlID,
       PSID    Sid,
       BOOL    fCBox
       )
{
    HWND    hwnd;
    INT     cItems;
    USHORT  GetCountMsg = LB_GETCOUNT;
    USHORT  GetDataMsg = LB_GETITEMDATA;

    if (fCBox) {
        GetCountMsg = CB_GETCOUNT;
        GetDataMsg = CB_GETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    cItems = (INT)SendMessage(hwnd, GetCountMsg, 0, 0);

    if (cItems >= 0) {

        INT     iItem;
        PSID    ItemSid;

        for (iItem =0; iItem < cItems; iItem ++) {

            ItemSid = (PSID)SendMessage(hwnd, GetDataMsg, iItem, 0);
            if (RtlEqualSid(ItemSid, Sid)) {
                return(iItem);
            }
        }
    }

    return(-1);
}


static HHOOK   hHookKeyboard = NULL;

/****************************************************************************

   FUNCTION: SetHooks

   PURPOSE: Installs input hooks

   RETURNS: TRUE on success, FALSE on failure

****************************************************************************/

BOOL
SetHooks(
        HWND    hwnd
        )
{
    HANDLE  hModHookDll;
    HOOKPROC lpfnKeyboardHookProc;

    if (hwnd == NULL) {
        // No-one to notify !
        return(FALSE);
    }

    if (hHookKeyboard != NULL) {
        // Hooks already installed
        return(FALSE);
    }

    hModHookDll = LoadLibrary("SECEDIT.DLL");
    if (hModHookDll == NULL) {
        DbgPrint("Failed to load secedit.dll\n");
        MessageBox(hwnd, "Failed to find secedit.dll.\nActive window context editting disabled.",
                   NULL, MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);
        return(FALSE);
    }

    lpfnKeyboardHookProc = (HOOKPROC)GetProcAddress(hModHookDll, "KeyboardHookProc");
    if (lpfnKeyboardHookProc == NULL) {
        DbgPrint("Failed to find keyboard hook entry point in secedit.dll\n");
        return(FALSE);
    }

    // Install sytem-wide keyboard hook
    hHookKeyboard = SetWindowsHookEx(WH_KEYBOARD, lpfnKeyboardHookProc, hModHookDll, 0);
    if (hHookKeyboard == NULL) {
        DbgPrint("SECEDIT: failed to install system keyboard hook\n");
        return(FALSE);
    }

    return(TRUE);
}


/****************************************************************************

   FUNCTION: ReleaseHooks

   PURPOSE: Uninstalls input hooks

   RETURNS: TRUE on success, FALSE on failure

****************************************************************************/

BOOL
ReleaseHooks(
            HWND    hwnd
            )
{
    BOOL    Success;

    if (hHookKeyboard == NULL) {
        // Hooks not installed
        return(FALSE);
    }

    Success = UnhookWindowsHookEx(hHookKeyboard);
    if (!Success) {
        DbgPrint("SECEDIT: Failed to release keyboard hook\n");
    }

    // Reset global
    hHookKeyboard = NULL;

    return(Success);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\addline.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include <stdio.h>
#include <math.h>

#include "setedit.h"
#include "addline.h"

#include "grafdata.h"   // for ChartInsertLine, ChartDeleteLine
#include "graph.h"      // for SizeGraphComponents
#include "legend.h"     // for LegendAddItem
#include "line.h"       // for LineAllocate, LineFree.
#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"   // for QueryPerformanceData
#include "perfmops.h"   // for dlg_error_box
#include "system.h"     // for SystemGet
#include "utils.h"
#include "counters.h"
#include "pmhelpid.h"   // Help IDs

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define ADDLINEDETAILLEVEL    PERF_DETAIL_WIZARD

#define iInitialExplainLen    256

// defines used in owner-drawn items
#define OWNER_DRAWN_ITEM      2
#define OWNER_DRAW_FOCUS      1

//==========================================================================//
//                                Local Data                                //
//==========================================================================//

// defined in PerfData.c
extern WCHAR   NULL_NAME[] ;


COLORREF argbColors[] =
{
    RGB (0xff, 0x00, 0x00),
    RGB (0x00, 0x80, 0x00),
    RGB (0x00, 0x00, 0xff),
    RGB (0xff, 0xff, 0x00),
    RGB (0xff, 0x00, 0xff),
    RGB (0x00, 0xff, 0xff),
    RGB (0x80, 0x00, 0x00),
    RGB (0x40, 0x40, 0x40),
    RGB (0x00, 0x00, 0x80),
    RGB (0x80, 0x80, 0x00),
    RGB (0x80, 0x00, 0x80),
    RGB (0x00, 0x80, 0x80),
    RGB (0x40, 0x00, 0x00),
    RGB (0x00, 0x40, 0x00),
    RGB (0x00, 0x00, 0x40),
    RGB (0x00, 0x00, 0x00)
} ;


TCHAR *apszScaleFmt[] =
{
    TEXT("%7.7f"),
    TEXT("%6.6f"),
    TEXT("%5.5f"),
    TEXT("%4.4f"),
    TEXT("%3.3f"),
    TEXT("%2.2f"),
    TEXT("%1.1f"),
    TEXT("%2.1f"),
    TEXT("%3.1f"),
    TEXT("%4.1f"),
    TEXT("%5.1f"),
    TEXT("%6.1f"),
    TEXT("%7.1f")
} ;
#define DEFAULT_SCALE 0
#define NUMBER_OF_SCALE sizeof(apszScaleFmt)/sizeof(apszScaleFmt[0])

int               iLineType ;
static PPERFDATA  pPerfData ;
PPERFSYSTEM       pSystem ;
PLINESTRUCT       pLineEdit ;
PPERFSYSTEM       *ppSystemFirst ;
PLINEVISUAL       pVisual ;

#define bEditLine (pLineEdit != NULL)


BOOL              ComputerChange ;
BOOL              InstanceNameChange ;
DWORD             ParentObjectTitleIndex ;
LPTSTR            pCurrentSystem;

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define InChartAdd()             \
   (iLineType == LineTypeChart)


#define InAlertAdd()             \
   (iLineType == LineTypeAlert)

#define InReportAdd()            \
   (iLineType == LineTypeReport)




#define NumColorIndexes()     \
   (sizeof (argbColors) / sizeof (argbColors[0]))

#define NumWidthIndexes()  5

#define NumStyleIndexes()  4


//==========================================================================//
//                              Forward Declarations                        //
//==========================================================================//

BOOL /*static*/ OnObjectChanged (HDLG hDlg) ;


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


PPERFINSTANCEDEF
ParentInstance (
               PPERFINSTANCEDEF pInstance
               )
{
    PPERFOBJECT          parent_obj ;
    PPERFINSTANCEDEF     parent_instance ;
    PERF_COUNTER_BLOCK   *counter_blk;
    LONG                 i ;

    parent_obj =
    GetObjectDefByTitleIndex (pPerfData,
                              pInstance->ParentObjectTitleIndex) ;
    if (!parent_obj)
        return (NULL) ;


    // Then get the parent instance.
    // NOTE: can use unique ID field to match here instead
    // of name compare.
    for (i = 0,
         parent_instance = (PERF_INSTANCE_DEFINITION *) ( (PBYTE)parent_obj
                                                          + parent_obj->DefinitionLength);
        i < parent_obj->NumInstances;
        i++, parent_instance = (PERF_INSTANCE_DEFINITION *) ( (PBYTE)counter_blk
                                                              + counter_blk->ByteLength)) {  // for
        counter_blk = (PERF_COUNTER_BLOCK *) ( (PBYTE)parent_instance
                                               + parent_instance->ByteLength);
        if ((DWORD)i == pInstance->ParentObjectInstance)
            return (parent_instance) ;
    }

    return (NULL) ;
}


PPERFOBJECT
SelectedObject (
               HWND hWndObjects,
               LPTSTR lpszObjectName
               )
/*
   Effect:        Return the pObject associated with the currently selected
                  combo-box item of hWndObjects. Set lpszObjectName to
                  the object's name.

                  If no item is selected in the combobox, return NULL.

   Assert:        The pObject for each CB item was added when the string
                  was added to the CB, by CBLoadObjects.

   See Also:      LoadObjects.
*/
{
    INT_PTR           iIndex ;

    iIndex = CBSelection (hWndObjects) ;
    if (iIndex == CB_ERR)
        return (NULL) ;

    if (lpszObjectName)
        CBString (hWndObjects, iIndex, lpszObjectName) ;

    return ((PPERFOBJECT) CBData (hWndObjects, iIndex)) ;
}



PPERFCOUNTERDEF
SelectedCounter (
                HWND hWndCounters,
                LPTSTR lpszCounterName
                )
/*
   Effect:        Return the pCounter associated with the currently selected
                  LB item of hWndCounters. Set lpszCounterName to
                  the Counter's name.

                  If no item is selected in the listbox, return NULL.

   Assert:        The pCounter for each LB item was added when the string
                  was added to the LB, by LoadCounters.

   See Also:      LoadCounters.
*/
{
    INT_PTR       iIndex ;

    iIndex = LBSelection (hWndCounters) ;
    if (iIndex == LB_ERR)
        return (NULL) ;

    if (lpszCounterName)
        LBString (hWndCounters, iIndex, lpszCounterName) ;
    return ((PPERFCOUNTERDEF) LBData (hWndCounters, iIndex)) ;
}



void
VisualIncrement (
                PLINEVISUAL pVisual
                )
/*
   Effect:        Cycle through the combinations of color, width, and
                  style to distinguish between lines.  The color attributes
                  are like a number:
                        <style> <width> <color>

                  Since color is the LSB, it is always incremented. The
                  others are incremented whenever the color rolls over.

                  If a current index is -1, that means don't increment
                  that visual attribute.
*/
{
    pVisual->iColorIndex =
    (pVisual->iColorIndex + 1) % NumColorIndexes () ;

    if (pVisual->iColorIndex)
        return ;


    if (pVisual->iWidthIndex == -1)
        return ;


    pVisual->iWidthIndex =
    (pVisual->iWidthIndex + 1) % NumWidthIndexes () ;

    if (pVisual->iWidthIndex)
        return ;


    if (pVisual->iStyleIndex == -1)
        return ;


    pVisual->iStyleIndex =
    (pVisual->iStyleIndex + 1) % NumStyleIndexes () ;
}


COLORREF
LineColor (
          int iColorIndex
          )
{
    return (argbColors [iColorIndex]) ;
}


int
LineWidth (
          int iWidthIndex
          )
{
    switch (iWidthIndex) {
        case 0:
            return (1) ;
            break ;

        case 1:
            return (3) ;
            break ;

        case 2:
            return (5) ;
            break ;

        case 3:
            return (7) ;
            break ;

        case 4:
            return (9) ;
            break ;
    }
    return 1;
}


int
LineStyle (
          int iStyleIndex
          )
{
    return (iStyleIndex) ;
}

void
SetInstanceNames (
                 HDLG hDlg,
                 HWND hWndInstances,
                 INT_PTR iInstanceIndex
                 )
{
    TCHAR             szInstance [256], szInstanceParent [256] ;
    PPERFINSTANCEDEF  pInstance ;
    PPERFINSTANCEDEF  pInstanceParent ;

    szInstance [0] = szInstanceParent [0] = TEXT('\0') ;

    pInstance = (PPERFINSTANCEDEF) LBData (hWndInstances, iInstanceIndex) ;
    if (pInstance == (PPERFINSTANCEDEF) LB_ERR) {
        pInstance = NULL;
    } else {
        // get the instance and parent names
        GetInstanceNameStr (pInstance, szInstance) ;
        pInstanceParent = ParentInstance (pInstance) ;

        if (pInstanceParent) {
            GetInstanceNameStr (pInstanceParent, szInstanceParent) ;
        }
    }

    DialogSetString (hDlg, IDD_ADDLINEPARENTNAME, szInstanceParent) ;
    DialogSetString (hDlg, IDD_ADDLINEINSTANCENAME, szInstance) ;
    ParentObjectTitleIndex = pInstance->ParentObjectTitleIndex ;

}

BOOL
/*static*/
LoadInstances (
              HDLG hDlg
              )
{
    PPERFOBJECT       pObject ;
    PPERFINSTANCEDEF  pInstance, pInstanceParent ;
    TCHAR             szInstance [256], szInstanceParent [256] ;
    TCHAR             szCompositeName [256 * 2] ;
    TCHAR             szInstCompositeName [256 * 2] ;

    LONG              iInstance ;
    UINT_PTR          iIndex ;

    int               xTextExtent = 0 ;
    int               currentTextExtent ;
    HFONT             hFont ;
    HDC               hDC = 0 ;
    HWND              hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
    HWND              hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);

    // turn off horiz. scrollbar
    LBSetHorzExtent (hWndInstances, 0) ;
    LBReset (hWndInstances) ;

    InstanceNameChange = FALSE ;

    pObject = SelectedObject (hWndObjects, NULL) ;
    if (!pObject)
        return (FALSE) ;

    if (pObject->NumInstances <= 0) {
        MLBSetSelection (hWndInstances, 0, TRUE) ;
        DialogSetString (hDlg, IDD_ADDLINEPARENTNAME, TEXT("\0")) ;
        DialogSetString (hDlg, IDD_ADDLINEINSTANCENAME, TEXT("\0")) ;
        return (FALSE) ;
    }

    // turn off Listbox redraw
    LBSetRedraw (hWndInstances, FALSE) ;

    if (bEditLine) {
        if (pLineEdit->lnObject.NumInstances > 0) {
            if (pLineEdit->lnInstanceDef.ParentObjectTitleIndex) {
                // Get the Parent Object Instance Name.
                // and prefix it to the Instance Name, to make
                // the string we want to display.
                TSPRINTF (szInstCompositeName,
                          TEXT("%s ==> %s"),
                          pLineEdit->lnPINName,
                          pLineEdit->lnInstanceName) ;
                DialogSetString (hDlg, IDD_ADDLINEPARENTNAME, pLineEdit->lnPINName) ;
            } else {
                lstrcpy (szInstCompositeName, pLineEdit->lnInstanceName) ;
                DialogSetString (hDlg, IDD_ADDLINEPARENTNAME, TEXT("\0")) ;
            }
            DialogSetString (hDlg, IDD_ADDLINEINSTANCENAME, pLineEdit->lnInstanceName) ;
        } else {
            szInstCompositeName[0] = TEXT('\0');
        }
    }

    if (!bEditLine && (hDC = GetDC (hWndInstances))) {
        hFont = (HFONT)SendMessage(hWndInstances, WM_GETFONT, 0, 0L);
        if (hFont)
            SelectObject(hDC, hFont);
    }


    for (iInstance = 0, pInstance = FirstInstance (pObject) ;
        iInstance < pObject->NumInstances;
        iInstance++, pInstance = NextInstance (pInstance)) {
        GetInstanceNameStr (pInstance, szInstance) ;
        pInstanceParent = ParentInstance (pInstance) ;

        if (pInstanceParent) {
            GetInstanceNameStr (pInstanceParent, szInstanceParent) ;
            TSPRINTF (szCompositeName, TEXT("%s ==> %s"),
                      szInstanceParent, szInstance) ;
            iIndex = LBAdd (hWndInstances, szCompositeName) ;
        } else {
            iIndex = LBAdd (hWndInstances, szInstance) ;
        }

        if (iIndex != LB_ERR) {
            LBSetData (hWndInstances, iIndex, (LPARAM) pInstance) ;
        }

        // get the biggest text width
        if (hDC) {
            currentTextExtent = TextWidth (hDC, szCompositeName) + xScrollWidth / 2  ;
            if (currentTextExtent > xTextExtent) {
                xTextExtent = currentTextExtent ;
            }
        }
    }

    if (hDC) {
        // turn on horiz. scrollbar if necessary...
        LBSetHorzExtent (hWndInstances, xTextExtent) ;
        ReleaseDC (hWndInstances, hDC) ;
    }


    if (!bEditLine || szInstCompositeName[0] == TEXT('\0')) {
        MLBSetSelection (hWndInstances, 0, TRUE) ;
        if (!bEditLine) {
            SetInstanceNames (hDlg, hWndInstances, 0) ;
        }
    } else {
        BOOL bSetSelection = TRUE ;

        iIndex = LBFind (hWndInstances, szInstCompositeName) ;
        if (iIndex == LB_ERR) {
            if (bEditLine) {
                bSetSelection = FALSE ;
            }
            iIndex = 0 ;
        }

        if (bSetSelection) {
            MLBSetSelection (hWndInstances, iIndex, TRUE) ;
        }

        LBSetVisible (hWndInstances, iIndex) ;
    }

    // turn on Listbox redraw
    LBSetRedraw (hWndInstances, TRUE) ;

    return TRUE;
}


BOOL
OnCounterChanged (
                 HDLG hDlg
                 )
/*
   Effect:        Perform any actions necessary when the counter has changed.
                  In particular, display the explanation for the counter
                  that has the focus rectangle.
*/
{
    LPTSTR         lpszText ;
    PPERFCOUNTERDEF pCounter ;
    int            iStatus ;
    INT_PTR        iFocusIndex ;
    HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);
    HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;

    iFocusIndex = LBFocus (hWndCounters) ;
    if (iFocusIndex == LB_ERR)
        return (FALSE) ;

    pCounter = (PPERFCOUNTERDEF) LBData (hWndCounters, iFocusIndex) ;
    if ((!pCounter) || (pCounter == (PPERFCOUNTERDEF)LB_ERR))
        return (FALSE) ;

    // no need to get help text before the button is clicked
    if (!bExplainTextButtonHit)
        return (FALSE) ;

    // Create initial string
    lpszText = MemoryAllocate (iInitialExplainLen * sizeof (TCHAR)) ;
    if (!lpszText)
        return (FALSE);

    while (TRUE) {
        lpszText[0] = TEXT('\0') ;

      #ifdef UNICODE
        iStatus = QueryPerformanceName  (pSystem,
                                         pCounter->CounterHelpTitleIndex,
                                         iLanguage,
                                         (DWORD)(MemorySize (lpszText) / sizeof(TCHAR)),
                                         lpszText,
                                         TRUE) ;
      #else
        iStatus = QueryPerformanceNameW (pSystem,
                                         pCounter->CounterHelpTitleIndex,
                                         iLanguage,
                                         MemorySize (lpszText),
                                         lpszText,
                                         TRUE) ;
      #endif

        if (iStatus == ERROR_SUCCESS)
            break ;

        if (iStatus == ERROR_MORE_DATA)
            lpszText =
            MemoryResize (lpszText,
                          MemorySize (lpszText) + iInitialExplainLen) ;
        else
            break ;
    }

    // Don't use my DialogSetString, it won't handle such large strings.
    SetDlgItemText (hDlg, IDD_ADDLINEEXPLAIN, lpszText) ;
    MemoryFree (lpszText) ;

    return (TRUE) ;
}



BOOL
LoadCounters (
             HDLG hDlg,
             UINT iSelectCounterDefn
             )
{
    PPERFOBJECT       pObject ;

    TCHAR             szCounterName [256] ;
    TCHAR             szDefaultCounterName [256] ;
    PPERFCOUNTERDEF   pCounter ;
    UINT              i ;
    INT_PTR           iIndex ;
    int               xTextExtent = 0 ;
    int               currentTextExtent ;
    HFONT             hFont ;
    HDC               hDC = 0 ;
    BOOL              bSetSelection = TRUE ;
    HWND              hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
    HWND              hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);


    strclr (szDefaultCounterName) ;

    // turn off horiz. scrollbar
    LBSetHorzExtent (hWndCounters, 0) ;
    LBReset (hWndCounters) ;

    pObject = SelectedObject (hWndObjects, NULL) ;
    if (!pObject)
        return (FALSE) ;

    if (!bEditLine && (hDC = GetDC (hWndCounters))) {
        hFont = (HFONT)SendMessage(hWndCounters, WM_GETFONT, 0, 0L);
        if (hFont)
            SelectObject(hDC, hFont);
    }

    // turn off Listbox redraw
    LBSetRedraw (hWndCounters, FALSE) ;

    for (i = 0, pCounter = FirstCounter (pObject) ;
        i < pObject->NumCounters ;
        i++, pCounter = NextCounter (pCounter)) {
        if (pCounter->CounterType != PERF_SAMPLE_BASE &&
            pCounter->CounterType != PERF_COUNTER_NODATA &&
            pCounter->CounterType != PERF_AVERAGE_BASE &&
            pCounter->CounterType != PERF_COUNTER_QUEUELEN_TYPE &&
            pCounter->CounterType != PERF_COUNTER_MULTI_BASE &&
            pCounter->CounterType != PERF_RAW_BASE &&
            pCounter->DetailLevel <= ADDLINEDETAILLEVEL) {
            szCounterName[0] = TEXT('\0') ;
            QueryPerformanceName (pSystem,
                                  pCounter->CounterNameTitleIndex,
                                  0, sizeof (szCounterName) / sizeof(TCHAR),
                                  szCounterName,
                                  FALSE) ;

            // if szCounterName is not empty, add it to the listbox
            if (!strsame(szCounterName, NULL_NAME)) {
                iIndex = LBAdd (hWndCounters, szCounterName) ;
                LBSetData (hWndCounters, iIndex, (DWORD_PTR) pCounter) ;

                // get the biggest text width
                if (hDC) {
                    currentTextExtent = TextWidth (hDC, szCounterName) + xScrollWidth / 2 ;
                    if (currentTextExtent > xTextExtent) {
                        xTextExtent = currentTextExtent ;
                    }
                }

                if (iSelectCounterDefn == i)
                    lstrcpy (szDefaultCounterName, szCounterName) ;
            }
        }
    }

    if (bEditLine)
        lstrcpy (szDefaultCounterName, pLineEdit->lnCounterName) ;

    iIndex = LBFind (hWndCounters, szDefaultCounterName) ;
    if (iIndex == LB_ERR) {
        if (bEditLine) {
            bSetSelection = FALSE ;
        }
        iIndex = 0 ;
    }

    if (bSetSelection) {
        MLBSetSelection (hWndCounters, iIndex, TRUE) ;
    }
    LBSetVisible (hWndCounters, iIndex) ;

    if (hDC) {
        // turn on horiz. scrollbar if necessary...
        LBSetHorzExtent (hWndCounters, xTextExtent) ;
        ReleaseDC (hWndCounters, hDC) ;
    }

    // turn on Listbox redraw
    LBSetRedraw (hWndCounters, TRUE) ;

    OnCounterChanged (hDlg) ;

    return TRUE;
}


void
LoadObjects (
            HDLG hDlg,
            PPERFDATA pPerfData
            )
/*
   Effect:        Load into the object CB the objects for the current
                  pPerfData.
*/
{
    LPTSTR         lpszObject ;
    HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);


    lpszObject = bEditLine ? pLineEdit->lnObjectName : NULL ;

    CBLoadObjects (hWndObjects,
                   pPerfData,
                   pSystem,
                   ADDLINEDETAILLEVEL,
                   lpszObject,
                   FALSE) ;
    OnObjectChanged (hDlg) ;
    //   UpdateWindow (hDlg) ;
}



void
OnComputerChanged (
                  HDLG hDlg
                  )
{

    PPERFSYSTEM pLocalSystem;
    PPERFDATA   pLocalPerfData;

    pLocalPerfData = pPerfData;
    pLocalSystem = GetComputer (hDlg,
                                IDD_ADDLINECOMPUTER,
                                TRUE,
                                &pLocalPerfData,
                                ppSystemFirst) ;
    if (pLocalSystem && pLocalPerfData) {
        pSystem = pLocalSystem;
        pPerfData = pLocalPerfData;
        LoadObjects (hDlg, pPerfData) ;
        ComputerChange = FALSE ;
    }

}




BOOL
AddOneChartLine (
                HWND hDlg,
                PPERFCOUNTERDEF pCounter,
                LPTSTR lpszCounter,
                PPERFINSTANCEDEF pInstance
                )
{
    TCHAR             szComputer [MAX_SYSTEM_NAME_LENGTH] ;

    PERF_OBJECT_TYPE  UNALIGNED *pObject ;
    TCHAR             szObject [PerfObjectLen] ;

    TCHAR             szInstance [256] ;

    PLINE             pLine ;
    //   int               i ;
    int               iCounterIndex ;
    int               j ;

    PPERFINSTANCEDEF  pInstanceParent ;
    PERF_COUNTER_BLOCK *pCounterBlock ;
    TCHAR          szInstanceParent [256] ;
    TCHAR          szObjectParent [256] ;
    HWND           hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ;
    HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
    HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;
    HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;
    HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);


    //=============================//
    // Get selected data values    //
    //=============================//



    DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;

    pObject = (PERF_OBJECT_TYPE UNALIGNED *)SelectedObject (hWndObjects, szObject) ;
    if (!pObject)
        return (FALSE) ;

    if (InstanceNameChange) {
        szInstance[0] = szInstanceParent[0] = TEXT('\0') ;
        DialogText (hDlg, IDD_ADDLINEINSTANCENAME, szInstance) ;
        DialogText (hDlg, IDD_ADDLINEPARENTNAME ,szInstanceParent) ;
    } else if (pInstance)
        GetInstanceNameStr (pInstance, szInstance) ;

    //=============================//
    // Allocate the line           //
    //=============================//

    pLine = LineAllocate () ;
    if (!pLine) {
        DlgErrorBox (hDlg, ERR_NO_MEMORY);
        return (FALSE) ;
    }


    //=============================//
    // Set line's data values      //
    //=============================//

    pLine->iLineType = iLineType ;
    pLine->lnSystemName = StringAllocate (szComputer) ;

    pLine->lnObject = *pObject ;
    pLine->lnObjectName = StringAllocate (szObject) ;

    pLine->lnCounterDef = *pCounter ;
    pLine->lnCounterName = StringAllocate (lpszCounter) ;

    if (InstanceNameChange) {
        pLine->lnUniqueID = (DWORD) PERF_NO_UNIQUE_ID ;
        pLine->lnInstanceDef.ParentObjectTitleIndex = ParentObjectTitleIndex ;
        pLine->bUserEdit = TRUE ;
        pLine->lnInstanceName = StringAllocate (szInstance) ;
        pLine->lnPINName = StringAllocate (szInstanceParent) ;
        if (ParentObjectTitleIndex) {
            szObjectParent[0] = (TCHAR)'\0';
            QueryPerformanceName (pSystem,
                                  ParentObjectTitleIndex,
                                  0,  PerfObjectLen, szObjectParent, FALSE) ;
            pLine->lnParentObjName = StringAllocate (szObjectParent) ;
        }
    } else if (pObject->NumInstances > 0 && pInstance) {
        pLine->lnInstanceDef = *pInstance ;
        pLine->lnInstanceName = StringAllocate (szInstance) ;

        pLine->lnUniqueID = pInstance->UniqueID ;

        pLine->dwInstanceIndex = 0;

        if (pInstance->ParentObjectTitleIndex) {
            szObjectParent[0] = (TCHAR)'\0';
            QueryPerformanceName (pSystem,
                                  pInstance->ParentObjectTitleIndex,
                                  0,  PerfObjectLen, szObjectParent, FALSE) ;
            pLine->lnParentObjName = StringAllocate (szObjectParent) ;
        }

        pInstanceParent = ParentInstance (pInstance) ;
        if (pInstanceParent) {
            GetInstanceNameStr (pInstanceParent, szInstanceParent) ;
            if (pInstance->ParentObjectTitleIndex) {
                pLine->lnPINName = StringAllocate (szInstanceParent) ;
            }
        }
    }

    pLine->lnCounterType = pCounter->CounterType;
    pLine->lnCounterLength = pCounter->CounterSize;

    pLine->lnOldTime = pPerfData->PerfTime ;
    pLine->lnNewTime = pPerfData->PerfTime ;

    for (j = 0 ; j < 2 ; j++) {
        pLine->lnaCounterValue[j].LowPart = 0 ;
        pLine->lnaCounterValue[j].HighPart = 0 ;
    }


    //=============================//
    // Chart-related Values        //
    //=============================//

    pLine->iScaleIndex = (int)CBSelection (hWndScales) ;
    if (pLine->iScaleIndex == 0) {
        // use the default scale
        pLine->eScale = (FLOAT) pow ((double)10.0,
                                     (double)pCounter->DefaultScale) ;
    } else {
        pLine->eScale = DialogFloat (hDlg, IDD_ADDLINESCALE, NULL) ;
    }

    if (pObject->NumInstances > 0 && pInstance) {
        pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pInstance +
                                                 pInstance->ByteLength);
    } else {
        pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pObject +
                                                 pObject->DefinitionLength);
    }

    if (pLine->lnCounterLength <= 4)
        pLine->lnaOldCounterValue[0].LowPart =
        * ( (DWORD FAR *) ( (PBYTE)pCounterBlock +
                            pCounter[0].CounterOffset));
    else {
        pLine->lnaOldCounterValue[0] =
        * ( (LARGE_INTEGER UNALIGNED *) ( (PBYTE)pCounterBlock +
                                          pCounter[0].CounterOffset));
    }

    // Get second counter, only if we are not at
    // the end of the counters; some computations
    // require a second counter

    iCounterIndex = CounterIndex (pCounter, (PPERFOBJECT)pObject) ;
    if ((UINT) iCounterIndex < pObject->NumCounters - 1 &&
        iCounterIndex != -1) {
        if (pLine->lnCounterLength <= 4)
            pLine->lnaOldCounterValue[1].LowPart =
            * ( (DWORD FAR *) ( (PBYTE)pCounterBlock +
                                pCounter[1].CounterOffset));
        else
            pLine->lnaOldCounterValue[1] =
            * ( (LARGE_INTEGER UNALIGNED *) ( (PBYTE)pCounterBlock +
                                              pCounter[1].CounterOffset));
    }

    //   pLine->valNext = CounterFuncEntry;
    pLine->valNext = CounterEntry;

    pLine->lnaOldCounterValue[0] = pLine->lnaCounterValue[0];
    pLine->lnaOldCounterValue[1] = pLine->lnaCounterValue[1];

    //=============================//
    // Visual Values               //
    //=============================//

    pLine->Visual.iColorIndex = (int)CBSelection (hWndColors) ;
    pLine->Visual.crColor = LineColor (pLine->Visual.iColorIndex) ;

    pLine->Visual.iWidthIndex = (int)CBSelection (hWndWidths) ;
    pLine->Visual.iWidth = LineWidth (pLine->Visual.iWidthIndex) ;

    pLine->Visual.iStyleIndex = (int)CBSelection (hWndStyles) ;
    pLine->Visual.iStyle = LineStyle (pLine->Visual.iStyleIndex) ;

    *pVisual = pLine->Visual ;
    if (!bEditLine)
        VisualIncrement (pVisual) ;

    CBSetSelection (hWndColors, pVisual->iColorIndex) ;
    CBSetSelection (hWndWidths, pVisual->iWidthIndex) ;
    CBSetSelection (hWndStyles, pVisual->iStyleIndex) ;

    if (iLineType == LineTypeChart) {
        pLine->hPen = LineCreatePen (NULL, &(pLine->Visual), FALSE) ;
    }

    //=============================//
    // Insert the line!            //
    //=============================//

    if (InsertLine (pLine) == FALSE) {
        // no inert occurred due to either line already existed
        // or error detected.
        LineFree (pLine) ;
    }

    return TRUE;
}


BOOL
AddCounter (
           HWND hDlg,
           PPERFCOUNTERDEF pCounter,
           LPTSTR lpszCounter
           )
{
    int               iInstanceIndex ;
    int               iInstanceNum ;
    PPERFINSTANCEDEF  pInstance ;
    HWND              hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);

    // NOTE: for now, we don't check for duplicate lines
    if (!IsCounterSupported (pCounter->CounterType)) {
        DlgErrorBox (hDlg, ERR_COUNTER_NOT_IMP);
        return (FALSE) ;
    }


    if ((iInstanceNum = LBNumItems (hWndInstances)) && iInstanceNum != LB_ERR) {

        if (iInstanceNum > 1) {
            // delay some of the insert actions for performacne improvement
            bDelayAddAction = TRUE ;

            LegendSetRedraw (hWndGraphLegend, FALSE) ;
        }

        // count how many items are selected  If more than 1 items selected,
        // we don't want to use the changes in the Instance/Parent names editboxes.
        if (InstanceNameChange) {
            int   ItemsSelectCount = 0 ;
            for (iInstanceIndex = 0 ;
                iInstanceIndex < iInstanceNum ;
                iInstanceIndex++) {
                if (LBSelected (hWndInstances, iInstanceIndex)) {
                    ItemsSelectCount++ ;
                    if (ItemsSelectCount > 2) {
                        InstanceNameChange = FALSE ;
                        break ;
                    }
                }
            }
        }

        for (iInstanceIndex = 0 ;
            iInstanceIndex < iInstanceNum ;
            iInstanceIndex++) {
            if (LBSelected (hWndInstances, iInstanceIndex)) {
                pInstance = (PPERFINSTANCEDEF) LBData (hWndInstances, iInstanceIndex) ;
                if (pInstance == (PPERFINSTANCEDEF) LB_ERR) {
                    pInstance = NULL;
                }
                AddOneChartLine (hDlg, pCounter, lpszCounter, pInstance) ;
            }
        }

        if (bDelayAddAction) {
            // now do the post add-line actions
            bDelayAddAction = FALSE ;
            GraphAddAction () ;
            LegendSetRedraw (hWndGraphLegend, TRUE) ;
        }
    } else {
        // no instance, then forget the changes in Insatnce/Parent names editboxes
        InstanceNameChange = FALSE ;

        pInstance = NULL;
        AddOneChartLine (hDlg, pCounter, lpszCounter, pInstance) ;
    }

    return (TRUE) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


BOOL
/*static*/
OnInitDialog (
             HWND hDlg
             )
{
    int            i ;
    FLOAT          ScaleFactor ;
    TCHAR          tempBuff[ShortTextLen] ;
    TCHAR          szCaption [WindowCaptionLen] ;
    TCHAR          szRemoteComputerName[MAX_COMPUTERNAME_LENGTH + 3] ;
    HWND           hWndComputer = DialogControl (hDlg, IDD_ADDLINECOMPUTER);
    HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);
    HWND           hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);
    HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);
    HWND           hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ;
    HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
    HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;
    HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;

    // this is used to tell UPdateLines not to mark any
    // system as not used
    bAddLineInProgress = TRUE ;

    // turn this off until the Explain text button is clicked
    bExplainTextButtonHit = FALSE ;


    pPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ;

    pSystem = NULL ;

    DialogSetString (hDlg, IDD_ADDLINECOMPUTER,
                     bEditLine ? pLineEdit->lnSystemName : LocalComputerName) ;

    OnComputerChanged (hDlg) ;

    //=============================//
    // Set default line values     //
    //=============================//


    //=============================//
    // Fill line attribute CBs     //
    //=============================//

    // Load the colors combobox, select the default color.
    for (i = 0 ; i < NumColorIndexes () ; i++)
        CBAdd (hWndColors, IntToPtr(i)) ;
    CBSetSelection (hWndColors, pVisual->iColorIndex) ;

    // Load the widths combobox, select the default width.
    for (i = 0 ; i < NumWidthIndexes () ; i++)
        CBAdd (hWndWidths, IntToPtr(i)) ;
    CBSetSelection (hWndWidths, pVisual->iWidthIndex) ;

    // Load the styles combobox, select the default style.
    for (i = 0 ; i < NumStyleIndexes () ; i++)
        CBAdd (hWndStyles, IntToPtr(i)) ;
    CBSetSelection (hWndStyles, pVisual->iStyleIndex) ;

#if (!WIDESTYLES)
    DialogEnable (hDlg, IDD_ADDLINESTYLE, pVisual->iWidthIndex == 0) ;
    DialogEnable (hDlg, IDD_ADDLINESTYLETEXT, pVisual->iWidthIndex == 0) ;

    if (pVisual->iWidthIndex == 0 && pVisual->iStyleIndex > 0) {
        DialogEnable (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ;
        DialogEnable (hDlg, IDD_ADDLINEWIDTH, FALSE) ;
    }
#endif

    // Init the scale combo box.

    StringLoad (IDS_DEFAULT, tempBuff) ;
    CBAdd (hWndScales, tempBuff) ;

    // we are formatting the scale factors during run-time so
    // the c-runtime library will pick up the default locale
    // decimal "charatcer".
    ScaleFactor = (FLOAT)0.0000001 ;
    for (i = 0 ; i < NUMBER_OF_SCALE ; i++) {
        TSPRINTF(tempBuff, apszScaleFmt[i], ScaleFactor) ;
        ConvertDecimalPoint (tempBuff);
        ScaleFactor *= (FLOAT) 10.0 ;
        CBAdd (hWndScales, tempBuff) ;
    }

    CBSetSelection (hWndScales, bEditLine ? pLineEdit->iScaleIndex : DEFAULT_SCALE) ;



    if (bEditLine) {
        DialogSetText (hDlg, IDD_ADDLINEADD, IDS_OK) ;
        DialogEnable (hDlg, IDD_ADDLINEOBJECTTEXT, FALSE) ;
        DialogEnable (hDlg, IDD_ADDLINEOBJECT, FALSE) ;
        DialogEnable (hDlg, IDD_ADDLINECOUNTERTEXT, FALSE) ;
        DialogEnable (hDlg, IDD_ADDLINECOUNTER, FALSE) ;
        DialogEnable (hDlg, IDD_ADDLINEINSTANCE, FALSE) ;
        DialogEnable (hDlg, IDD_ADDLINEINSTANCETEXT, FALSE) ;

        if (pLineEdit->lnInstanceName) {
            DialogSetString (hDlg, IDD_ADDLINEINSTANCENAME, pLineEdit->lnInstanceName) ;
        } else {
            DialogSetString (hDlg, IDD_ADDLINEINSTANCENAME, TEXT("\0")) ;
        }
        if (pLineEdit->lnPINName) {
            DialogSetString (hDlg, IDD_ADDLINEPARENTNAME, pLineEdit->lnPINName) ;
        } else {
            DialogSetString (hDlg, IDD_ADDLINEPARENTNAME, TEXT("\0")) ;
        }
    } else {
        // set the scroll limit on the edit box
        EditSetLimit (GetDlgItem(hDlg, IDD_CHOOSECOMPUTERNAME),
                      MAX_SYSTEM_NAME_LENGTH-1) ;

    }


    //=============================//
    // LineType specific init      //
    //=============================//

    switch (iLineType) {
        case LineTypeChart:
            dwCurrentDlgID = bEditLine ?
                             HC_PM_idDlgEditChartLine : HC_PM_idDlgEditAddToChart ;

            StringLoad (bEditLine ?
                        IDS_EDITCHART : IDS_ADDTOCHART, szCaption) ;

            break ;

    }

    SetWindowText (hDlg, szCaption) ;
    SendDlgItemMessage (hDlg,
                        IDD_ADDLINEEXPLAIN, WM_SETFONT,
                        (WPARAM) hFontScales, (LPARAM) FALSE) ;
    WindowCenter (hDlg) ;
    return (TRUE) ;
}


BOOL
/*static*/
OnObjectChanged (
                HDLG hDlg
                )
/*
   Effect:        Perform any actions necessary when the user has selected
                  a new object category from the object CB, or when a default
                  object is first selected into the dialog. In particular,
                  find and load the counters, instances, etc., for this
                  object.

   Called by:     OnInitDialog, AddLineDlgProc (in response to an
                  IDM_ADDLINEOBJECT notification).
*/
{
    PPERFOBJECT    pObject ;
    HWND           hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE);
    HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);
    HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT);

    LBReset (hWndInstances) ;
    LBReset (hWndCounters) ;

    pObject = SelectedObject (hWndObjects, NULL) ;
    if (!pObject)
        return (FALSE) ;

    LoadCounters (hDlg, (UINT)pObject->DefaultCounter) ;
    LoadInstances (hDlg) ;

    return TRUE;
}



void
/*static*/
OnEllipses (
           HWND hDlg
           )
{
    TCHAR          szComputer [256] ;

    DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;
    if (ChooseComputer (hDlg, szComputer)) {
        SetHourglassCursor() ;
        DialogSetString (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;
        if (!bEditLine)
            OnComputerChanged (hDlg) ;
    }
}

BOOL
LineModifyAttributes (
                     HWND hDlg,
                     PLINE pLineToModify
                     )
{
    LINEVISUAL  LineVisual ;
    HPEN        hLinePen ;
    int         iScaleIndex ;        // chart attribute
    FLOAT          eScale ;             // chart attribute


    HPEN        hTempPen ;
    HWND        hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ;
    HWND        hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
    HWND        hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;
    HWND        hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ;

    //=============================//
    // Visual Values               //
    //=============================//

    LineVisual.iColorIndex = (int)CBSelection (hWndColors) ;
    LineVisual.crColor = LineColor (LineVisual.iColorIndex) ;

    LineVisual.iWidthIndex = (int)CBSelection (hWndWidths) ;
    LineVisual.iWidth = LineWidth (LineVisual.iWidthIndex) ;

    LineVisual.iStyleIndex = (int)CBSelection (hWndStyles) ;
    LineVisual.iStyle = LineStyle (LineVisual.iStyleIndex) ;

    hLinePen = LineCreatePen (NULL, &(LineVisual), FALSE) ;

    //=============================//
    // Chart-related Values        //
    //=============================//

    iScaleIndex = (int)CBSelection (hWndScales) ;
    if (iScaleIndex == 0) {
        // use the default scale
        eScale = (FLOAT) pow ((double)10.0,
                              (double)pLineToModify->lnCounterDef.DefaultScale) ;
    } else {
        eScale = DialogFloat (hDlg, IDD_ADDLINESCALE, NULL) ;
    }

    // Just do it..
    pLineToModify->Visual = LineVisual ;
    if (pLineToModify->hPen) {
        hTempPen = pLineToModify->hPen ;
        pLineToModify->hPen = hLinePen ;
        DeletePen (hTempPen) ;
    }

    pLineToModify->iScaleIndex = iScaleIndex ;
    pLineToModify->eScale = eScale ;

    return (TRUE) ;

}

BOOL
OnAddLines (
           HWND hDlg
           )
{
    PPERFCOUNTERDEF   pCounter ;
    TCHAR             szCounter [256] ;
    int               iCounter ;
    int               iCounterNum ;
    HWND              hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER);

    if (ComputerChange && !bEditLine) {
        // if computer has changed, don't want to continue
        // because the perfdata may have changed
        OnComputerChanged (hDlg) ;
        return (TRUE) ;
    }

    //=============================//
    // Dialog Values Acceptable?   //
    //=============================//

    if (bEditLine) {
        TCHAR             szInstance [256] ;
        TCHAR             szComputer [256] ;
        TCHAR             szInstanceParent [256] ;

        if (ComputerChange) {
            if (pLineEdit->lnSystemName)
                MemoryFree (pLineEdit->lnSystemName) ;

            DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ;
            pLineEdit->lnSystemName = StringAllocate (szComputer) ;
        }

        if (InstanceNameChange) {
            szInstance[0] = szInstanceParent[0] = TEXT('\0') ;
            DialogText (hDlg, IDD_ADDLINEINSTANCENAME, szInstance) ;
            DialogText (hDlg, IDD_ADDLINEPARENTNAME ,szInstanceParent) ;

            if (pLineEdit->lnInstanceName)
                MemoryFree (pLineEdit->lnInstanceName) ;

            if (pLineEdit->lnPINName)
                MemoryFree (pLineEdit->lnPINName) ;

            pLineEdit->lnUniqueID = (DWORD) PERF_NO_UNIQUE_ID ;
            pLineEdit->lnInstanceName = StringAllocate (szInstance) ;
            pLineEdit->lnPINName = StringAllocate (szInstanceParent) ;
        }
        LineModifyAttributes (hDlg, pLineEdit) ;
        EndDialog (hDlg, TRUE) ;
    }

    // If the user changed the textbox for computer name and pressed enter,
    // the OnAddLines function would be called without a check of the
    // computer name. This solves that problem.
    else {

        iCounterNum = LBNumItems (hWndCounters) ;
        for (iCounter = 0 ;
            iCounter < iCounterNum ;
            iCounter++) {
            // NOTE: for now, we don't check for duplicate lines
            if (LBSelected (hWndCounters, iCounter)) {
                pCounter = (PPERFCOUNTERDEF) LBData (hWndCounters, iCounter) ;
                LBString (hWndCounters, iCounter, szCounter) ;

                if (!IsCounterSupported (pCounter->CounterType)) {
                    DlgErrorBox (hDlg, ERR_COUNTER_NOT_IMP);
                } else {
                    AddCounter (hDlg, pCounter, szCounter) ;
                }
            }
        }
        DialogSetText (hDlg, IDCANCEL, IDS_DONE) ;
    }

    SizeGraphComponents (hWndGraph) ;

    WindowInvalidate (PerfmonViewWindow ()) ;

    return TRUE;

}


void
OnExpandExplain (
                HWND hDlg
                )
/*
   Effect:        Perform actions needed when user clicks on the Explain...
                  button. In particular, expand the dialog size to
                  uncover the explain edit box, and gray out the button.
*/
{
    RECT           rectWindow ;

    // Disable button first
    DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ;

    // go get the help text
    bExplainTextButtonHit = TRUE ;
    OnCounterChanged (hDlg) ;

    GetWindowRect (hDlg, &rectWindow) ;
    MoveWindow (hDlg,
                rectWindow.left,
                rectWindow.top,
                rectWindow.right - rectWindow.left,
                rectWindow.bottom - rectWindow.top +
                DialogHeight (hDlg, IDD_ADDLINEEXPLAINGROUP) +
                yScrollHeight,
                TRUE) ;
}



BOOL
/*static*/
OnCommand (
          HWND hDlg,
          WPARAM wParam,
          LPARAM lParam
          )
{
    INT_PTR        iWidthIndex ;
    INT_PTR        iStyleIndex ;
    HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ;
    HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ;

    switch (LOWORD (wParam)) {

        case IDD_ADDLINEWIDTH:
            iWidthIndex = CBSelection (hWndWidths) ;
#if (!WIDESTYLES)
            DialogEnable (hDlg, IDD_ADDLINESTYLETEXT,
                          iWidthIndex == 0  || iWidthIndex == CB_ERR) ;
            DialogEnable (hDlg, IDD_ADDLINESTYLE,
                          iWidthIndex == 0  || iWidthIndex == CB_ERR) ;
#endif
            break ;

        case IDD_ADDLINESTYLE:
            iStyleIndex = CBSelection (hWndStyles) ;
#if (!WIDESTYLES)
            DialogEnable (hDlg, IDD_ADDLINEWIDTHTEXT,
                          iStyleIndex == 0  || iStyleIndex == CB_ERR) ;
            DialogEnable (hDlg, IDD_ADDLINEWIDTH,
                          iStyleIndex == 0  || iStyleIndex == CB_ERR) ;
#endif
            break ;

        case IDCANCEL:
            EndDialog (hDlg, 0);
            return (TRUE);
            break ;

        case IDD_ADDLINEADD :

            if (ComputerChange && !bEditLine) {
                SetHourglassCursor() ;
                OnComputerChanged (hDlg) ;
            } else {
                SetHourglassCursor() ;
                OnAddLines (hDlg) ;
                SetArrowCursor() ;
            }
            break;

        case IDD_ADDLINEEXPANDEXPLAIN :
            if (ComputerChange) {
                SetHourglassCursor() ;
                OnComputerChanged (hDlg) ;
            } else {
                OnExpandExplain (hDlg) ;
            }
            break;

        case IDD_ADDLINEELLIPSES:
            SetHourglassCursor() ;
            OnEllipses (hDlg) ;
            SetArrowCursor() ;
            break ;


        case IDD_ADDLINECOUNTER:
            if (ComputerChange) {
                SetHourglassCursor() ;
                OnComputerChanged (hDlg) ;
            } else if (HIWORD (wParam) == LBN_SELCHANGE)
                OnCounterChanged (hDlg) ;
            break ;


        case IDD_ADDLINEOBJECT:
            if (ComputerChange) {
                SetHourglassCursor() ;
                OnComputerChanged (hDlg) ;
            } else if (HIWORD (wParam) == CBN_SELCHANGE)
                OnObjectChanged (hDlg) ;
            break ;

        case IDD_ADDLINEINSTANCE:
            if (ComputerChange) {
                SetHourglassCursor() ;
                OnComputerChanged (hDlg) ;
            } else if (HIWORD (wParam) == LBN_SELCHANGE) {
                INT_PTR iIndex ;
                iIndex = SendMessage ((HWND)lParam, LB_GETCARETINDEX, 0, 0) ;
                SetInstanceNames (hDlg, (HWND)lParam, iIndex) ;
                InstanceNameChange = FALSE ;
            }
            break ;

        case IDD_ADDLINECOMPUTER:
            if (HIWORD (wParam) == EN_UPDATE) {
                ComputerChange = TRUE ;
            }
            break ;

        case IDD_ADDLINEPARENTNAME:
        case IDD_ADDLINEINSTANCENAME:
            if (HIWORD (wParam) == EN_UPDATE) {
                InstanceNameChange = TRUE ;
            }
            break ;

        default:
            break;
    }

    return (FALSE) ;
}


void
/*static*/
OnMeasureItem (
              HWND hDlg,
              PMEASUREITEMSTRUCT pMI
              )
{
    pMI->CtlType    = ODT_COMBOBOX ;
    pMI->CtlID      = IDD_ADDLINECOLOR ;
    pMI->itemData   = 0 ;
    pMI->itemWidth  = 0 ;

    // need 14 in order to draw the thickest line width
    pMI->itemHeight = 14 ;
    //   pMI->itemHeight = 12 ;
}

//***************************************************************************
//                                                                          *
//  FUNCTION   : HandleSelectionState(LPDRAWITEMSTRUCT)                     *
//                                                                          *
//  PURPOSE    : Handles a change in an item selection state. If an item is *
//               selected, a black rectangular frame is drawn around that   *
//               item; if an item is de-selected, the frame is removed.     *
//                                                                          *
//  COMMENT    : The black selection frame is slightly larger than the gray *
//               focus frame so they won't paint over each other.           *
//                                                                          *
//***************************************************************************
void
static
HandleSelectionState (
                     LPDRAWITEMSTRUCT  lpdis
                     )
{
    HBRUSH  hbr ;

    if (lpdis->itemState & ODS_SELECTED) {
        // selecting item -- paint a black frame
        hbr = GetStockObject(BLACK_BRUSH) ;
    } else {
        // de-selecting item -- remove frame
        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;
    }
    if (hbr) {
        FrameRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hbr) ;
        DeleteObject (hbr) ;
    }
}

//***************************************************************************
//                                                                          *
//  FUNCTION   : HandleFocusState(LPDRAWITEMSTRUCT)                         *
//                                                                          *
//  PURPOSE    : Handle a change in item focus state. If an item gains the  *
//               input focus, a gray rectangular frame is drawn around that *
//               item; if an item loses the input focus, the gray frame is  *
//               removed.                                                   *
//                                                                          *
//  COMMENT    : The gray focus frame is slightly smaller than the black    *
//               selection frame so they won't paint over each other.       *
//                                                                          *
//***************************************************************************
void
static
HandleFocusState (
                 LPDRAWITEMSTRUCT  lpdis
                 )
{
    RECT       rc ;
    HBRUSH  hbr ;

    // Resize rectangle to place focus frame between the selection
    // frame and the item.
    CopyRect ((LPRECT)&rc, (LPRECT)&lpdis->rcItem) ;
    InflateRect ((LPRECT)&rc, -OWNER_DRAW_FOCUS, -OWNER_DRAW_FOCUS) ;

    if (lpdis->itemState & ODS_FOCUS) {
        // gaining input focus -- paint a gray frame
        hbr = GetStockObject(GRAY_BRUSH) ;
    } else {
        // losing input focus -- remove (paint over) frame
        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ;
    }
    if (hbr) {
        FrameRect(lpdis->hDC, (LPRECT)&rc, hbr) ;
        DeleteObject (hbr) ;
    }
}

void
/*static*/
OnDrawItem (
           HWND hDlg,
           PDRAWITEMSTRUCT pDI
           )
{
    HDC            hDC ;
    PRECT          prect ;
    INT            itemID, CtlID, itemAction ;
    LOGBRUSH       logBrush ;
    HANDLE         hBrush,
    hOldBrush,
    hPen,
    hOldPen ;
    INT            x1, y1, x2, y2, cy ;
    POINT          point ;
    INT            iPenWidth ;
    COLORREF       BackgroundColor ;

    hDC        = pDI-> hDC ;
    CtlID      = pDI->CtlID ;
    prect      = &pDI->rcItem ;
    itemID     = pDI->itemID ;
    itemAction = pDI->itemAction ;


    if (itemID == -1) {
        // invalid ID, can't go on
        HandleFocusState (pDI) ;
    } else if (itemAction == ODA_SELECT) {
        HandleSelectionState(pDI);
    } else if (itemAction == ODA_FOCUS) {
        HandleFocusState (pDI) ;
    } else {

        // draw the entire item

        InflateRect (prect, -OWNER_DRAWN_ITEM, -OWNER_DRAWN_ITEM) ;

        switch (CtlID) {
            case IDD_ADDLINECOLOR:

                // Draw a color rectangle into the control area

                logBrush.lbStyle = BS_SOLID ;
                logBrush.lbColor = (COLORREF) argbColors[itemID] ;
                logBrush.lbHatch = 0 ;

                hBrush = CreateBrushIndirect (&logBrush) ;
                if (!hBrush)
                    break;
                hOldBrush = SelectObject (hDC, hBrush) ;

                hPen = GetStockObject (NULL_PEN) ;
                hOldPen = SelectObject (hDC, hPen) ;

                x1 = prect->left ;
                y1 = prect->top ;
                x2 = prect->right ;
                y2 = prect->bottom ;

                Rectangle (hDC, x1, y1, x2, y2) ;

                SelectObject (hDC, hOldBrush) ;
                DeleteObject (hBrush) ;

                InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ;

                HandleSelectionState (pDI) ;
                HandleFocusState (pDI) ;

                break ;

            case IDD_ADDLINEWIDTH:
            case IDD_ADDLINESTYLE:

                // First draw a rectangle, white interior, null border
                hBrush = GetStockObject (WHITE_BRUSH) ;
                if (!hBrush)
                    break;
                hOldBrush = SelectObject (hDC, hBrush) ;

                // we need to set the bk color in order to draw
                // the dash lines coorectly during focus.  Otherwise,
                // the COLOR_WINDOW background will make all dash lines
                // look like solid line...
                BackgroundColor = SetBkColor (hDC, crWhite) ;

                hPen = GetStockObject (NULL_PEN) ;
                hOldPen = SelectObject (hDC, hPen) ;

                x1 = prect->left ;
                y1 = prect->top ;
                x2 = prect->right ;
                y2 = prect->bottom ;

                Rectangle (hDC, x1, y1, x2, y2) ;

                SelectObject (hDC, hOldPen) ;

                // Draw a line of the itemID width in the middle
                // of the control area.

                if (CtlID == IDD_ADDLINEWIDTH) {
                    iPenWidth = LineWidth (itemID) ;
                    hPen = CreatePen (PS_SOLID, iPenWidth, RGB (0, 0, 0)) ;
                } else {
                    hPen = CreatePen (itemID, 1, RGB (0, 0, 0)) ;
                }

                if (!hPen)
                    break;
                hOldPen = SelectObject (hDC, hPen) ;

                x1 = prect->left + 8 ;
                cy = prect->bottom - prect->top ;
                y1 = prect->top + (cy / 2) - 1 ;
                x2 = prect->right - 8 ;
                MoveToEx (hDC, x1, y1, &point) ;
                LineTo (hDC, x2, y1) ;

                SelectObject (hDC, hOldPen) ;
                DeleteObject (hPen) ;
                SelectObject (hDC, hOldBrush) ;
                BackgroundColor = SetBkColor (hDC, BackgroundColor) ;

                InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ;

                HandleSelectionState (pDI) ;
                HandleFocusState (pDI) ;

                break ;
        }
    }
}


void
/*static*/
OnDestroy (
          HDLG hDlg
          )
{
    MemoryFree (pPerfData) ;


    pLineEdit = NULL ;
    bAddLineInProgress = FALSE ;
    dwCurrentDlgID = 0 ;
    bExplainTextButtonHit = FALSE ;
}



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



INT_PTR
FAR
PASCAL
AddLineDlgProc (
               HWND hDlg,
               UINT msg,
               WPARAM wParam,
               LPARAM lParam
               )
{

    BOOL Status;

    switch (msg) {
        case WM_COMMAND:
            OnCommand (hDlg, wParam, lParam) ;
            return (FALSE) ;
            break ;

        case WM_INITDIALOG:
            SetHourglassCursor() ;
            Status = OnInitDialog (hDlg) ;
            SetArrowCursor() ;

            // set focus on the "Add" button instead of the "Computer"
            SetFocus (DialogControl (hDlg, IDD_ADDLINEADD)) ;
            return FALSE ;
            break ;

        case WM_MEASUREITEM:
            OnMeasureItem (hDlg, (PMEASUREITEMSTRUCT) lParam) ;
            return (TRUE) ;
            break ;

        case WM_DRAWITEM:
            OnDrawItem (hDlg, (PDRAWITEMSTRUCT) lParam) ;
            return (TRUE) ;
            break ;

        case WM_DESTROY:
            OnDestroy (hDlg) ;
            break ;

        default:
            break;
    }

    return (FALSE) ;
}




BOOL
AddLine (
        HWND hWndParent,
        PPERFSYSTEM *ppSystemFirstView,
        PLINEVISUAL pLineVisual,
        LPTSTR pInCurrentSystem,
        int iLineTypeToAdd
        )
/*
   Effect:        Display the add line dialog box, allowing the user
                  to specify the computer, object, counter, instance,
                  and scale for a line.  The user can also select the
                  visual aspects of color, width and line style.

*/
{
    pLineEdit = NULL ;

    ppSystemFirst = ppSystemFirstView ;
    iLineType = iLineTypeToAdd ;
    pVisual = pLineVisual ;
    pCurrentSystem = pInCurrentSystem;

    return (DialogBox (hInstance, idDlgAddLine, hWndParent, AddLineDlgProc) ? TRUE : FALSE) ;
}



BOOL
EditLine (
         HWND hWndParent,
         PPERFSYSTEM *ppSystemFirstView,
         PLINE pLineToEdit,
         int iLineTypeToEdit
         )
{
    if (!pLineToEdit) {
        MessageBeep (0) ;
        return (FALSE) ;
    }

    pLineEdit = pLineToEdit ;

    ppSystemFirst = ppSystemFirstView ;
    iLineType = iLineTypeToEdit ;
    pVisual = &(pLineToEdit->Visual) ;

    return (DialogBox (hInstance, idDlgAddLine, hWndParent, AddLineDlgProc) ? TRUE : FALSE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\command.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            Command.c -- PerfmonCommand routine and helpers.

            This file contains the PerfmonCommand routine, which handles
            all of the user's menu selections.

  Copyright 1992-1993, Microsoft Corporation. All Rights Reserved.
            Microsoft Confidential.
==============================================================================
*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "stdio.h"
#include "setedit.h"
#include "command.h"    // External declarations for this file
#include <shellapi.h>   // for ShellAbout

#include "cderr.h"
#include "dialogs.h"
#include "fileopen.h"   // for FileOpen
#include "grafdata.h"   // for ChartDeleteLine ClearGraphDisplay & ToggleGraphRefresh
#include "init.h"       // for PerfmonClose
#include "legend.h"
#include "status.h"     // for StatusUpdateIcons
#include "toolbar.h"    // for ToolbarDepressButton
#include "utils.h"
#include "perfmops.h"   // for SaveWorkspace

int static deltax ;
int static deltay ;

#define ABOUT_TIMER_ID 10

INT_PTR
FAR
WINAPI
AboutDlgProc (
             HWND hDlg,
             UINT iMessage,
             WPARAM wParam,
             LPARAM lParam)
{
    BOOL           bHandled ;

    bHandled = TRUE ;
    switch (iMessage) {
        case WM_INITDIALOG:
            deltax = 0 ;
            deltay = 0 ;
            dwCurrentDlgID = 0 ;
            SetTimer(hDlg, ABOUT_TIMER_ID, 1000, NULL) ;
            WindowCenter (hDlg) ;
            return (TRUE) ;

        case WM_TIMER:
            deltax += 2 ;
            if (deltax > 60)
                deltax = 0 ;

            deltay += 5 ;
            if (deltay > 60)
                deltay = 0 ;

            WindowInvalidate (DialogControl (hDlg, 524)) ;
            break ;

        case WM_DRAWITEM:
            {
                int xPos, yPos ;
                LPDRAWITEMSTRUCT lpItem ;

                lpItem = (LPDRAWITEMSTRUCT) lParam ;
                xPos = lpItem->rcItem.left + deltax ;
                yPos = lpItem->rcItem.top + deltay ;
                DrawIcon (lpItem->hDC, xPos, yPos, hIcon) ;
            }
            break ;

        case WM_CLOSE:
            dwCurrentDlgID = 0 ;
            KillTimer (hDlg, ABOUT_TIMER_ID) ;
            EndDialog (hDlg, 1) ;
            break ;

        case WM_COMMAND:
            switch (wParam) {
                case IDD_OK:
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, 1) ;
                    break ;

                default:
                    bHandled = FALSE ;
                    break;
            }
            break;


        default:
            bHandled = FALSE ;
            break ;
    }

    return (bHandled) ;
}


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


void
ChangeView (
           HWND hWnd,
           int iNewView
           )
{

    // only Chart view
    iPerfmonView = IDM_VIEWCHART ;
    WindowShow (hWndGraph, TRUE) ;

    DrawMenuBar(hWnd) ;
    StatusLineReady (hWndStatus) ;
}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void
ViewChart (
          HWND hWnd
          )
{
    if (Options.bMenubar)
        SetMenu (hWnd, hMenuChart) ;
    ChangeView (hWnd, IDM_VIEWCHART) ;
}



#ifdef KEEP_MANUALREFRESH
void
ToggleRefresh (
              HWND hWnd
              )
{
    BOOL           bRefresh ;

    bRefresh = ToggleGraphRefresh (hWndGraph) ;

    MenuCheck (GetMenu (hWnd), IDM_OPTIONSMANUALREFRESH, bRefresh) ;
}
#endif


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL
PerfmonCommand (
               HWND hWnd,
               WPARAM wParam,
               LPARAM lParam
               )
/*
   Effect:        Respond to the user's menu selection, found in wParam.
                  In particular, branch to the appropriate OnXXX function
                  to perform the action associated with each command.

   Called By:     MainWndProc (perfmon.c), in response to a WM_COMMAND
                  message.
*/
{
    PLINESTRUCT    pLine ;
    BOOL           bPrepareMenu = TRUE ;

    switch (LOWORD (wParam)) {

        //=============================//
        // Toolbar Commands            //
        //=============================//

        case IDM_TOOLBARADD:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_EDITADDCHART, lParam) ;
            break ;


        case IDM_TOOLBARMODIFY:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_EDITMODIFYCHART, lParam) ;
            break ;


        case IDM_TOOLBARDELETE:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_EDITDELETECHART, lParam) ;
            break ;


        case IDM_TOOLBARREFRESH:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSREFRESHNOWCHART, lParam) ;
            break ;


        case IDM_TOOLBAROPTIONS:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_OPTIONSCHART, lParam) ;
            break ;

            //=============================//
            // "File" Commands             //
            //=============================//

        case IDM_FILENEWCHART:
            if (QuerySaveChart (hWnd, pGraphs))
                ResetGraphView (hWndGraph) ;
            break ;

        case IDM_FILEOPENCHART:
            if (QuerySaveChart (hWnd, pGraphs))
                FileOpen (hWndGraph, IDS_CHARTFILE, NULL) ;
            break ;

        case IDM_FILESAVECHART:
        case IDM_FILESAVEASCHART:
            bPrepareMenu = FALSE ;
            SaveChart (hWndGraph, 0,
                       (LOWORD (wParam) == IDM_FILESAVEASCHART) ? TRUE : FALSE) ;
            break;

        case IDM_FILEEXIT:
            if (QuerySaveChart (hWnd, pGraphs)) {
                PerfmonClose (hWnd) ;
                bPrepareMenu = FALSE ;

            }
            break ;

            //=============================//
            // "Edit" Commands             //
            //=============================//

        case IDM_EDITADDCHART:
            AddChart (hWnd) ;
            break;

        case IDM_EDITDELETECHART:
            pLine = CurrentGraphLine (hWndGraph) ;
            if (pLine)
                ChartDeleteLine(pGraphs, pLine) ;
            break ;

        case IDM_EDITMODIFYCHART:
            EditChart (hWnd) ;
            break ;

            //=============================//
            // "Options" Commands          //
            //=============================//

        case IDM_OPTIONSCHART:
            DialogBox(hInstance, idDlgChartOptions, hWnd, GraphOptionDlg);
            break;

        case IDM_OPTIONSDISPLAYMENU:
            // ShowPerfmonMenu will update Options.bMenubar..
            ShowPerfmonMenu (!Options.bMenubar) ;
            break ;

        case IDM_OPTIONSDISPLAYTOOL:
            Options.bToolbar = !Options.bToolbar ;
            SizePerfmonComponents () ;
            break ;

        case IDM_OPTIONSDISPLAYSTATUS:
            Options.bStatusbar = !Options.bStatusbar ;
            SizePerfmonComponents () ;
            break ;

        case IDM_OPTIONSDISPLAYONTOP:
            Options.bAlwaysOnTop = !Options.bAlwaysOnTop ;
            //         WindowSetTopmost (hWndMain, Options.bAlwaysOnTop) ;
            break ;

            //=============================//
            // "Help" Commands             //
            //=============================//

        case IDM_HELPABOUT:
            {
                TCHAR          szApplication [WindowCaptionLen] ;

                bPrepareMenu = FALSE ;

                if (GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_CONTROL) < 0) {
                    DialogBox (hInstance, idDlgAbout, hWndMain, AboutDlgProc) ;
                } else {
                    StringLoad (IDS_APPNAME, szApplication) ;
                    ShellAbout (hWnd, szApplication, NULL, hIcon) ;
                }
            }
            break ;

            //======================================//
            //  Generic messages from ACCELERATORS  //
            //======================================//
        case IDM_FILEOPENFILE:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_FILEOPENCHART, lParam) ;
            break ;

        case IDM_FILESAVEFILE:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_FILESAVECHART, lParam) ;
            break ;

        case IDM_FILESAVEASFILE:
            bPrepareMenu = FALSE ;
            SendMessage (hWnd, WM_COMMAND, IDM_FILESAVEASCHART, lParam) ;
            break ;

        case IDM_TOOLBARID:
            // msg from the toolbar control
            bPrepareMenu = FALSE ;
            OnToolbarHit (wParam, lParam) ;
            break ;

        default:
            return (FALSE) ;
    }

    if (bPrepareMenu) {
        PrepareMenu (GetMenu (hWnd)) ;
    }

    return (TRUE) ;
}



void
PrepareMenu (
            HMENU hMenu
            )
{
    BOOL           bPlayingLog ;
    BOOL           bCurrentLine ;
    BOOL           bManualRefresh ;
    BOOL           bLogCollecting ;
    BOOL           bRefresh ;

    // hMenu is NULL when the menu bar display option is off.
    // In that case, we still have to enable/disable all tool buttons
    // So, I have commented out the next 2 lines...
    //   if (!hMenu)
    //      return ;

    bLogCollecting = FALSE ;
    bPlayingLog = FALSE ;

    bCurrentLine = (CurrentGraphLine (hWndGraph) != NULL) ;
    bRefresh = GraphRefresh (hWndGraph) ;
    bManualRefresh = !bPlayingLog && bCurrentLine ;

    if (hMenu) {
        MenuCheck (hMenu, IDM_VIEWCHART, TRUE) ;
        MenuEnableItem (hMenu, IDM_FILEEXPORTCHART, bCurrentLine) ;
        MenuEnableItem (hMenu, IDM_EDITMODIFYCHART, bCurrentLine) ;
        MenuEnableItem (hMenu, IDM_EDITDELETECHART, bCurrentLine) ;
    }


    ToolbarEnableButton (hWndToolbar, EditTool,
                         bCurrentLine &&
                         (iPerfmonView != IDM_VIEWREPORT &&
                          iPerfmonView != IDM_VIEWLOG)) ;

    ToolbarEnableButton (hWndToolbar, DeleteTool, bCurrentLine) ;

    // None of the alert or report options make sense when playing back a log.
    ToolbarEnableButton (hWndToolbar,
                         OptionsTool,
                         !bPlayingLog ||
                         iPerfmonView != IDM_VIEWREPORT) ;

    if (hMenu) {
        // check/uncheck all the display options
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYMENU, Options.bMenubar) ;
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYTOOL, Options.bToolbar) ;
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYSTATUS, Options.bStatusbar) ;
        MenuCheck (hMenu, IDM_OPTIONSDISPLAYONTOP, Options.bAlwaysOnTop) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\addline.h ===
void /*static*/ OnComputerChanged (HDLG hDlg) ;


BOOL AddLine (HWND hWndParent, 
              PPERFSYSTEM *ppSystemFirstView,
              PLINEVISUAL pLineVisual,
              LPTSTR pCurrentLine,
              int iLineTypeToAdd) ;


BOOL EditLine (HWND hWndParent,
               PPERFSYSTEM *ppSystemFirstView,
               PLINE pLineToEdit,
               int iLineTypeToEdit) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\counters.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992-1993   Microsoft Corporation

Module Name:

    counters.c  

Abstract:

    This module contains the routines to calculate "DataPoint" values from
    the registry data.

    The algoritms were lifted from RussBls's "Data.C" in winmeter.

    All the math is done in floating point to get the correct results, at
    the sacrifice of efficiency on a 386 with not 387. We can always
    revisit these routines later.

Revision History:

    Bob Watson  11/04/92
        -- modified calculations to use more integer math and "early
            exits" to improve efficiency on slower & non-coprocessor
            machines
--*/

//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "setedit.h"       // perfmon include files
#include "counters.h"      // Exported declarations for this file


//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define INVERT             PERF_COUNTER_TIMER_INV
#define NS100_INVERT       PERF_100NSEC_TIMER_INV
#define NS100              PERF_100NSEC_TIMER
#define TIMER_MULTI        PERF_COUNTER_MULTI_TIMER
#define TIMER_MULTI_INVERT PERF_COUNTER_MULTI_TIMER_INV
#define NS100_MULTI        PERF_100NSEC_MULTI_TIMER
#define NS100_MULTI_INVERT PERF_100NSEC_MULTI_TIMER_INV


#define FRACTION 1
#define BULK     1

#define TOO_BIG (FLOAT)1500000000


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


#define LargeIntegerLessThanOrEqualZero(X) ((X).QuadPart <= 0)


FLOAT
eLIntToFloat(
    IN PLARGE_INTEGER pLargeInt
)
/*++

Routine Description:

    Converts a large integer to a floating point number

Arguments:

    IN pLargeInt    Pointer to large integer to return as a floating point
                    number.

Return Value:

    Floating point representation of Large Integer passed in arg. list
--*/
{
    FLOAT   eSum;

    if (pLargeInt->HighPart == 0) {
        return (FLOAT) pLargeInt->LowPart;
    } else {

        // Scale the high portion so it's value is in the upper 32 bit
        // range.  Then add it to the low portion.

        eSum = (FLOAT) pLargeInt->HighPart * 4.294967296E9f ;
        eSum += (FLOAT) pLargeInt->LowPart  ;

        return (eSum) ;
    }
} //eLIntToFloat

FLOAT
eGetTimeInterval(
    IN PLARGE_INTEGER pliCurrentTime,
    IN PLARGE_INTEGER pliPreviousTime,
    IN PLARGE_INTEGER pliFreq
)
/*++

Routine Description:

    Get the difference between the current and previous time counts,
        then divide by the frequency.
    
Arguments:

    IN pCurrentTime
    IN pPreviousTime
        used to compute the duration of this sample (the time between
        samples

    IN pliFreq
        # of  counts (clock ticks) per second

Return Value:

    Floating point representation of Time Interval (seconds)
--*/
{
    FLOAT   eTimeDifference;
    FLOAT   eFreq;
    FLOAT   eTimeInterval ;

    LARGE_INTEGER liDifference;

    // Get the number of counts that have occured since the last sample

    liDifference.QuadPart = pliCurrentTime->QuadPart -
            pliPreviousTime->QuadPart;

    if (LargeIntegerLessThanOrEqualZero(liDifference)) {
        return (FLOAT) 0.0f;
    } else {
        eTimeDifference = eLIntToFloat(&liDifference);

        // Get the counts per second

        eFreq = eLIntToFloat(pliFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Get the time since the last sample.

        eTimeInterval = eTimeDifference / eFreq ;

        return (eTimeInterval) ;
    }
} // eGetTimeInterval

FLOAT
Counter_Counter_Common(
    IN PLINESTRUCT pLineStruct,
    IN INT iType
)
/*++

Routine Description:

    Take the difference between the current and previous counts
        then divide by the time interval
    
Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type
        

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eCount ;

    LARGE_INTEGER   liDifference;

    if (iType != BULK) {
        liDifference.HighPart = 0;
        liDifference.LowPart = pLineStruct->lnaCounterValue[0].LowPart -
                            pLineStruct->lnaOldCounterValue[0].LowPart;
    } else {
        liDifference.QuadPart = pLineStruct->lnaCounterValue[0].QuadPart -
                        pLineStruct->lnaOldCounterValue[0].QuadPart;
    }
    
    if (LargeIntegerLessThanOrEqualZero(liDifference)) {
        return (FLOAT) 0.0f;
    } else {
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                        &pLineStruct->lnOldTime,
                                        &pLineStruct->lnPerfFreq) ;
        if (eTimeInterval <= 0.0f) {
            return (FLOAT) 0.0f;
        } else {
            eDifference = eLIntToFloat (&liDifference);

            eCount         = eDifference / eTimeInterval ;

            return(eCount) ;
        }
    }
} // Counter_Counter_Common


FLOAT
Counter_Average_Timer(
    IN PLINESTRUCT pLineStruct
)
/*++

Routine Description:

    Take the differences between the current and previous times and counts
    divide the time interval by the counts multiply by 10,000,000 (convert
    from 100 nsec to sec)
    
Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeInterval;
    FLOAT   eCount;

    LARGE_INTEGER    liDifference;

    // Get the current and previous counts.

    liDifference.HighPart = 0;
    liDifference.LowPart = pLineStruct->lnaCounterValue[1].LowPart - 
            pLineStruct->lnaOldCounterValue[1].LowPart;

    if ( LargeIntegerLessThanOrEqualZero(liDifference)) {
        return (FLOAT) 0.0f;
    } else {
        // Get the amount of time that has passed since the last sample
        eTimeInterval = eGetTimeInterval(&pLineStruct->lnaCounterValue[0],
                                            &pLineStruct->lnaOldCounterValue[0],
                                            &pLineStruct->lnPerfFreq) ;

        if (eTimeInterval < 0.0f) { // return 0 if negative time has passed
            return (0.0f);
        } else {
            // Get the number of counts in this time interval.
            eCount = eTimeInterval / eLIntToFloat (&liDifference);
            return(eCount) ;
        }
    }
} //Counter_Average_Timer



FLOAT
Counter_Average_Bulk(
    IN PLINESTRUCT pLineStruct
)
/*++

Routine Description:

    Take the differences between the current and previous byte counts and
    operation counts divide the bulk count by the operation counts
    
Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eBulkDelta;
    FLOAT   eDifference;
    FLOAT   eCount;

    LARGE_INTEGER liDifference;
    LARGE_INTEGER liBulkDelta;

    // Get the bulk count increment since the last sample

    liBulkDelta.QuadPart = pLineStruct->lnaCounterValue[0].QuadPart -
            pLineStruct->lnaOldCounterValue[0].QuadPart;

    if (LargeIntegerLessThanOrEqualZero(liBulkDelta)) {
        return (FLOAT) 0.0f;
    } else {
        // Get the current and previous counts.
        liDifference.HighPart = 0;
        liDifference.LowPart = pLineStruct->lnaCounterValue[1].LowPart -
                pLineStruct->lnaOldCounterValue[1].LowPart;

        // Get the number of counts in this time interval.

        if ( LargeIntegerLessThanOrEqualZero(liDifference)) {
            // Counter value invalid
            return (FLOAT) 0.0f;
        } else {
            eBulkDelta = eLIntToFloat (&liBulkDelta);
            eDifference = eLIntToFloat (&liDifference);
            eCount = eBulkDelta / eDifference ;

            // Scale the value to up to 1 second

            return(eCount) ;
        }
    }
} // Counter_Average_Bulk



FLOAT
Counter_Timer_Common(
    IN  PLINESTRUCT pLineStruct,
    IN  INT iType
)
/*++

Routine Description:

    Take the difference between the current and previous counts,
        Normalize the count (counts per interval)
        divide by the time interval (count = % of interval)
        if (invert)
            subtract from 1 (the normalized size of an interval)
        multiply by 100 (convert to a percentage)
        this value from 100.
    
Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eTimeInterval;
    FLOAT   eDifference;
    FLOAT   eFreq;
    FLOAT   eFraction;
    FLOAT   eMultiBase;
    FLOAT   eCount ;

    LARGE_INTEGER   liTimeInterval;
    LARGE_INTEGER   liDifference;

    // Get the amount of time that has passed since the last sample

    if (iType == NS100 ||
        iType == NS100_INVERT ||
        iType == NS100_MULTI ||
        iType == NS100_MULTI_INVERT) {
            liTimeInterval.QuadPart = pLineStruct->lnNewTime100Ns.QuadPart -
                pLineStruct->lnOldTime100Ns.QuadPart;
            eTimeInterval = eLIntToFloat (&liTimeInterval);
    } else {
            eTimeInterval = eGetTimeInterval(&pLineStruct->lnNewTime,
                                            &pLineStruct->lnOldTime,
                                            &pLineStruct->lnPerfFreq) ;
    }

    if (eTimeInterval <= 0.0f)
       return (FLOAT) 0.0f;

    // Get the current and previous counts.

    liDifference.QuadPart = pLineStruct->lnaCounterValue[0].QuadPart -
            pLineStruct->lnaOldCounterValue[0].QuadPart;

    // Get the number of counts in this time interval.
    // (1, 2, 3 or any number of seconds could have gone by since
    // the last sample)

    eDifference = eLIntToFloat (&liDifference) ;

    if (iType == 0 || iType == INVERT)
    {
        // Get the counts per interval (second)

        eFreq = eLIntToFloat(&pLineStruct->lnPerfFreq) ;
        if (eFreq <= 0.0f)
           return (FLOAT) 0.0f;

        // Calculate the fraction of the counts that are used by whatever
        // we are measuring

        eFraction = eDifference / eFreq ;
    }
    else
    {
        eFraction = eDifference ;
    }

    // Calculate the fraction of time used by what were measuring.

    eCount = eFraction / eTimeInterval ;

    // If this is  an inverted count take care of the inversion.

    if (iType == INVERT || iType == NS100_INVERT)
        eCount = (FLOAT) 1.0 - eCount ;

    // If this is  an inverted multi count take care of the inversion.

    if (iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT) {
        eMultiBase  = (FLOAT)pLineStruct->lnaCounterValue[1].LowPart ;
        eCount = (FLOAT) eMultiBase - eCount ;
    }

    // Scale the value to up to 100.

    eCount *= 100.0f ;

    if (eCount < 0.0f) eCount = 0.0f ;

    if (eCount > 100.0f &&
        iType != NS100_MULTI &&
        iType != NS100_MULTI_INVERT &&
        iType != TIMER_MULTI &&
        iType != TIMER_MULTI_INVERT) {

        eCount = 100.0f;
    }

    return(eCount) ;
} // Counter_Timer_Common


FLOAT
Counter_Raw_Fraction(
    IN PLINESTRUCT pLineStruct
)
/*++

Routine Description:

    Evaluate a raw fraction (no time, just two values: Numerator and
        Denominator) and multiply by 100 (to make a percentage;

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eCount ;

    LARGE_INTEGER   liNumerator;

    if ( pLineStruct->lnaCounterValue[0].LowPart == 0 ||
            pLineStruct->lnaCounterValue[1].LowPart == 0 ) {
        // invalid value
        return (0.0f);
    } else {
        liNumerator.QuadPart =
            pLineStruct->lnaCounterValue[0].LowPart * 100L;
        eCount = eLIntToFloat(&liNumerator)  /
                 (FLOAT) pLineStruct->lnaCounterValue[1].LowPart;
        return(eCount) ;
    }
} // Counter_Raw_Fraction


FLOAT
eElapsedTime(
    PLINESTRUCT pLineStruct,
    INT iType
)
/*++

Routine Description:

    Converts 100NS elapsed time to fractional seconds

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Unused.

Return Value:

    Floating point representation of elapsed time in seconds
--*/
{
    FLOAT   eSeconds ;

    LARGE_INTEGER   liDifference;

    if (LargeIntegerLessThanOrEqualZero(pLineStruct->lnaCounterValue[0] )) {
        // no data [start time = 0] so return 0
        return (FLOAT) 0.0f;
    } else {
        // otherwise compute difference between current time and start time
        liDifference.QuadPart =
            pLineStruct->lnNewTime.QuadPart - // sample time in obj. units
            pLineStruct->lnaCounterValue[0].QuadPart;   // start time in obj. units

        if (LargeIntegerLessThanOrEqualZero(liDifference) ||
            LargeIntegerLessThanOrEqualZero(pLineStruct->lnObject.PerfFreq)) {
            return (FLOAT) 0.0f;
        } else {
            // convert to fractional seconds using object counter
            eSeconds = eLIntToFloat (&liDifference) /
                eLIntToFloat (&pLineStruct->lnObject.PerfFreq);

            return (eSeconds);
        }
    }
    
} // eElapsedTime


FLOAT
Sample_Common(
    PLINESTRUCT pLineStruct,
    INT iType
)
/*++

Routine Description:

    Divites "Top" differenced by Base Difference

Arguments:

    IN pLineStruct
        Line structure containing data to perform computations on

    IN iType
        Counter Type

Return Value:

    Floating point representation of outcome
--*/
{
    FLOAT   eCount ;

    LONG    lDifference;
    LONG    lBaseDifference;

    lDifference = pLineStruct->lnaCounterValue[0].LowPart -
        pLineStruct->lnaOldCounterValue[0].LowPart ;

    if (lDifference <= 0) {
        return (FLOAT) 0.0f;
    } else {
        lBaseDifference = pLineStruct->lnaCounterValue[1].LowPart -
            pLineStruct->lnaOldCounterValue[1].LowPart ;

        if ( lBaseDifference <= 0 ) {
            // invalid value
            return (0.0f);
        } else {
            eCount = (FLOAT)lDifference / (FLOAT)lBaseDifference ;

            if (iType == FRACTION) {
                eCount *= (FLOAT) 100.0f ;
            }
            return(eCount) ;
        }
    }
} // Sample_Common


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


/*****************************************************************************
 * Counter_Counter - Take the difference between the current and previous
 *                   counts then divide by the time interval
 ****************************************************************************/
#define Counter_Counter(pLineStruct)      \
        Counter_Counter_Common(pLineStruct, 0)
#if 0
FLOAT Counter_Counter(PLINESTRUCT pLineStruct)
{
        return Counter_Counter_Common(pLineStruct, 0) ;
}
#endif

/*****************************************************************************
 * Counter_Bulk    - Take the difference between the current and previous
 *                   counts then divide by the time interval
 *                   Same as a Counter_counter except it uses large_ints
 ****************************************************************************/
#define Counter_Bulk(pLineStruct)         \
        Counter_Counter_Common(pLineStruct, BULK)
#if 0
FLOAT Counter_Bulk(PLINESTRUCT pLineStruct)
{
        return Counter_Counter_Common(pLineStruct, BULK) ;
}
#endif


/*****************************************************************************
 * Counter_Timer100Ns -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, NS100)
#if 0
FLOAT Counter_Timer100Ns(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, NS100) ;
}
#endif

/*****************************************************************************
 * Counter_Timer100Ns_Inv -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns_Inv(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, NS100_INVERT)
#if 0
FLOAT Counter_Timer100Ns_Inv(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, NS100_INVERT) ;

}
#endif

/*****************************************************************************
 * Counter_Timer_Multi -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer_Multi(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, TIMER_MULTI)
#if 0
FLOAT Counter_Timer_Multi(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, TIMER_MULTI) ;
}
#endif

/*****************************************************************************
 * Counter_Timer_Multi_Inv -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer_Multi_Inv(pLineStruct)       \
        Counter_Timer_Common(pLineStruct, TIMER_MULTI_INVERT)
#if 0
FLOAT Counter_Timer_Multi_Inv(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, TIMER_MULTI_INVERT) ;
}
#endif


/*****************************************************************************
 * Counter_Timer100Ns_Multi -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns_Multi(pLineStruct)     \
        Counter_Timer_Common(pLineStruct, NS100_MULTI)
#if 0
FLOAT Counter_Timer100Ns_Multi(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, NS100_MULTI) ;
}
#endif

/*****************************************************************************
 * Counter_Timer100Ns_Multi_Inv -
 *
 *      Need to review with RussBl exactly what he is doing here.
 ****************************************************************************/
#define Counter_Timer100Ns_Multi_Inv(pLineStruct)    \
        Counter_Timer_Common(pLineStruct, NS100_MULTI_INVERT)
#if 0
FLOAT Counter_Timer100Ns_Multi_Inv(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, NS100_MULTI_INVERT) ;
}
#endif

/*****************************************************************************
 * Counter_Timer - Take the difference between the current and previous
 *                 counts,
 *                 Normalize the count (counts per interval)
 *                 divide by the time interval (count = % of interval)
 *                 multiply by 100 (convert to a percentage)
 *                 this value from 100.
 ****************************************************************************/
#define Counter_Timer(pLineStruct)       \
        Counter_Timer_Common(pLineStruct, 0)
#if 0
FLOAT Counter_Timer(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, 0) ;
}
#endif


/*****************************************************************************
 * Counter_Timer_Inv - Take the difference between the current and previous
 *                     counts,
 *                     Normalize the count (counts per interval)
 *                     divide by the time interval (count = % of interval)
 *                     subtract from 1 (the normalized size of an interval)
 *                     multiply by 100 (convert to a percentage)
 *                     this value from 100.
 ****************************************************************************/
#define Counter_Timer_Inv(pLineStruct)         \
      Counter_Timer_Common(pLineStruct, INVERT)
#if 0
FLOAT Counter_Timer_Inv(PLINESTRUCT pLineStruct)
{
        return Counter_Timer_Common(pLineStruct, INVERT) ;
}
#endif

/*****************************************************************************
 * Sample_Counter -
 ****************************************************************************/
#define Sample_Counter(pLineStruct)      \
      Sample_Common(pLineStruct, 0)
#if 0
FLOAT Sample_Counter(PLINESTRUCT pLineStruct)
{
        return Sample_Common(pLineStruct, 0) ;
}
#endif

/*****************************************************************************
 * Sample_Fraction -
 ****************************************************************************/
#define Sample_Fraction(pLineStruct)     \
     Sample_Common(pLineStruct, FRACTION)
#if 0
FLOAT Sample_Fraction(PLINESTRUCT pLineStruct)
{
        return Sample_Common(pLineStruct, FRACTION) ;
}
#endif

/*****************************************************************************
 * Counter_Rawcount - This is just a raw count.
 ****************************************************************************/
#define Counter_Rawcount(pLineStruct)     \
   ((FLOAT) (pLineStruct->lnaCounterValue[0].LowPart))
#if 0
FLOAT Counter_Rawcount(PLINESTRUCT pLineStruct)
   {
   return((FLOAT) (pLineStruct->lnaCounterValue[0].LowPart)) ;
   }
#endif

/*****************************************************************************
 * Counter_Large_Rawcount - This is just a raw count.
 ****************************************************************************/
#define Counter_Large_Rawcount(pLineStruct)     \
   ((FLOAT) eLIntToFloat(&(pLineStruct->lnaCounterValue[0])))

/*****************************************************************************
 * Counter_Elapsed_Time -
 ****************************************************************************/
#define Counter_Elapsed_Time(pLineStruct)         \
    eElapsedTime (pLineStruct, 0)
#if 0
FLOAT Counter_Elapsed_Time (PLINESTRUCT pLineStruct)
{
    return eElapsedTime (pLineStruct, 0);
}
#endif

/*****************************************************************************
 * Counter_Null - The counters that return nothing go here.
 ****************************************************************************/
#define Counter_Null(pline)        \
        ((FLOAT) 0.0)
#if 0
FLOAT Counter_Null(PLINESTRUCT pline)
{
        return((FLOAT) 0.0);
        pline;
}
#endif


FLOAT
CounterEntry (
    PLINESTRUCT pLine
)
{
    switch (pLine->lnCounterType) {
        case  PERF_COUNTER_COUNTER:
            return Counter_Counter (pLine);

        case  PERF_COUNTER_TIMER:
            return Counter_Timer (pLine);

        case  PERF_COUNTER_QUEUELEN_TYPE:
            return Counter_Queuelen(pLine);

        case  PERF_COUNTER_BULK_COUNT:
            return Counter_Bulk (pLine);

        case  PERF_COUNTER_TEXT:
            return Counter_Null (pLine);

        case  PERF_COUNTER_RAWCOUNT:
        case  PERF_COUNTER_RAWCOUNT_HEX:
            return Counter_Rawcount(pLine);

        case  PERF_COUNTER_LARGE_RAWCOUNT:
        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX:
            return Counter_Large_Rawcount(pLine);

        case  PERF_SAMPLE_FRACTION:
            return Sample_Fraction(pLine);

        case  PERF_SAMPLE_COUNTER:
            return Sample_Counter (pLine);

        case  PERF_COUNTER_NODATA:
            return Counter_Null (pLine);

        case  PERF_COUNTER_TIMER_INV:
            return Counter_Timer_Inv (pLine);

        case  PERF_RAW_BASE:
//      case  PERF_SAMPLE_BASE:
//      case  PERF_AVERAGE_BASE:
            return Counter_Null (pLine);

        case  PERF_AVERAGE_TIMER:
            return Counter_Average_Timer (pLine);

        case  PERF_AVERAGE_BULK:
            return Counter_Average_Bulk (pLine);

        case  PERF_100NSEC_TIMER:
            return Counter_Timer100Ns (pLine);

        case  PERF_100NSEC_TIMER_INV:
            return Counter_Timer100Ns_Inv (pLine);

        case  PERF_COUNTER_MULTI_TIMER:
            return Counter_Timer_Multi (pLine);

        case  PERF_COUNTER_MULTI_TIMER_INV:
            return Counter_Timer_Multi_Inv (pLine);

        case  PERF_COUNTER_MULTI_BASE:
            return Counter_Null (pLine);

        case  PERF_100NSEC_MULTI_TIMER:
            return Counter_Timer100Ns_Multi (pLine);
                 
        case  PERF_100NSEC_MULTI_TIMER_INV:
            return Counter_Timer100Ns_Multi_Inv (pLine);

        case  PERF_RAW_FRACTION:
            return Counter_Raw_Fraction (pLine);

        case  PERF_ELAPSED_TIME:
            return Counter_Elapsed_Time (pLine);
           
        default:
            return Counter_Null (pLine);

    }
}


BOOL
IsCounterSupported (
    DWORD dwCounterType
)
{
    switch (dwCounterType) {
// supported counters
        case  PERF_COUNTER_COUNTER:
        case  PERF_COUNTER_TIMER:
        case  PERF_COUNTER_QUEUELEN_TYPE:
        case  PERF_COUNTER_BULK_COUNT:
        case  PERF_COUNTER_RAWCOUNT:
        case  PERF_COUNTER_RAWCOUNT_HEX:
        case  PERF_COUNTER_LARGE_RAWCOUNT:
        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX:
        case  PERF_SAMPLE_FRACTION:
        case  PERF_SAMPLE_COUNTER:
        case  PERF_COUNTER_TIMER_INV:
        case  PERF_AVERAGE_TIMER:
        case  PERF_AVERAGE_BULK:
        case  PERF_100NSEC_TIMER:
        case  PERF_100NSEC_TIMER_INV:
        case  PERF_COUNTER_MULTI_TIMER:
        case  PERF_COUNTER_MULTI_TIMER_INV:
        case  PERF_100NSEC_MULTI_TIMER:
        case  PERF_100NSEC_MULTI_TIMER_INV:
        case  PERF_RAW_FRACTION:
        case  PERF_ELAPSED_TIME:
            return TRUE;

// unsupported counters
        case  PERF_COUNTER_TEXT:
        case  PERF_COUNTER_NODATA:
        case  PERF_RAW_BASE:
//      case  PERF_SAMPLE_BASE:
//      case  PERF_AVERAGE_BASE:
        case  PERF_COUNTER_MULTI_BASE:
        default:
            return FALSE;

    }
}
















=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\fileopen.h ===
BOOL FileOpen (HWND hWndParent, int nStringResourceID, LPTSTR lpInputFileName) ;
BOOL FileGetName (HWND hWndParent, int nStringResourceID, LPTSTR lpFileName) ;

BOOL APIENTRY FileOpenHookProc (HWND hDlg, UINT iMessage, 
                                WPARAM wParam, LPARAM lParam) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\counters.h ===
FLOAT CounterEntry (PLINESTRUCT pLine);
BOOL IsCounterSupported ( DWORD dwCounterType );

FLOAT Counter_Counter(PLINESTRUCT pline);
FLOAT Counter_Bulk(PLINESTRUCT pline);
FLOAT Counter_Timer(PLINESTRUCT pline);
FLOAT Counter_Queuelen(PLINESTRUCT pline);
FLOAT Counter_Text(PLINESTRUCT pline);
FLOAT Counter_Rawcount(PLINESTRUCT pline);
FLOAT Sample_Fraction(PLINESTRUCT pline);
FLOAT Sample_Counter(PLINESTRUCT pline);
FLOAT Counter_Timer_Inv(PLINESTRUCT pline);
FLOAT Counter_Timer100Ns(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer100Ns_Inv(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer_Multi(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer_Multi_Inv(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer100Ns_Multi(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Timer100Ns_Multi_Inv(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Average_Timer(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Average_Bulk(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Raw_Fraction(PLINESTRUCT pLineStruct) ;
FLOAT Counter_Elapsed_Time (PLINESTRUCT pLineStruct);

FLOAT Counter_Null(PLINESTRUCT pline);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\dialogs.c ===
/*****************************************************************************
 *
 *  Dialogs.c - This module handles the Menu and Dialog user interactions.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 ****************************************************************************/

#include <stdio.h>
#include <wchar.h>   // for swscanf

#include "setedit.h"

#include "graph.h"
#include "cderr.h"
#include "utils.h"
#include "perfmops.h"
#include "grafdata.h"  // for ToggleGraphRefresh
#include "pmhelpid.h"  // Help IDs

BOOL          LocalManualRefresh ;

INT_PTR
GraphOptionDlg(
              HWND hDlg,
              UINT msg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    static GRAPH_OPTIONS goLocalCopy ;

    INT            iTimeMilliseconds ;
    TCHAR          szBuff[MiscTextLen] ;
    PGRAPHSTRUCT   lgraph;

    lParam ;
    lgraph = pGraphs;

    switch (msg) {

        case WM_INITDIALOG:

            dwCurrentDlgID = HC_PM_idDlgOptionChart ;

            // Init the Radio button, Check boxes and text fields.

            goLocalCopy.iGraphOrHistogram =
            lgraph->gOptions.iGraphOrHistogram ;
            if (lgraph->gOptions.iGraphOrHistogram == LINE_GRAPH)
                CheckRadioButton(hDlg, ID_GRAPH, ID_HISTOGRAM, ID_GRAPH) ;
            else
                CheckRadioButton(hDlg, ID_GRAPH, ID_HISTOGRAM, ID_HISTOGRAM) ;

            CheckDlgButton(hDlg, ID_LEGEND, lgraph->gOptions.bLegendChecked) ;
            if (!(lgraph->gOptions.bLegendChecked)) {
                // can't display valuebar w/o legend
                DialogEnable (hDlg, IDD_CHARTOPTIONSVALUEBAR, FALSE) ;
            }

            CheckDlgButton(hDlg, ID_LABELS, lgraph->gOptions.bLabelsChecked) ;
            CheckDlgButton(hDlg, ID_VERT_GRID, lgraph->gOptions.bVertGridChecked) ;
            CheckDlgButton(hDlg, ID_HORZ_GRID, lgraph->gOptions.bHorzGridChecked) ;
            CheckDlgButton(hDlg, IDD_CHARTOPTIONSVALUEBAR,
                           lgraph->gOptions.bStatusBarChecked) ;

            TSPRINTF(szBuff, TEXT("%d"), lgraph->gOptions.iVertMax) ;
            SendDlgItemMessage(hDlg, ID_VERT_MAX, WM_SETTEXT, 0, (LPARAM) szBuff) ;

            TSPRINTF(szBuff, TEXT("%3.3f"), lgraph->gOptions.eTimeInterval) ;
            ConvertDecimalPoint (szBuff);
            SendDlgItemMessage(hDlg, IDD_CHARTOPTIONSINTERVAL, WM_SETTEXT, 0, (LPARAM) szBuff) ;

            // Pickup a local copy of the Graph Options.

            goLocalCopy = lgraph->gOptions ;
            LocalManualRefresh = lgraph->bManualRefresh ;

            CheckRadioButton (hDlg,
                              IDD_CHARTOPTIONSMANUALREFRESH,
                              IDD_CHARTOPTIONSPERIODIC,
                              LocalManualRefresh ? IDD_CHARTOPTIONSMANUALREFRESH :
                              IDD_CHARTOPTIONSPERIODIC) ;

            if (lgraph->bManualRefresh) {
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVALTEXT, FALSE) ;
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVAL, FALSE) ;
            } else {
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVALTEXT, TRUE) ;
                DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVAL, TRUE) ;
            }

            EditSetLimit (GetDlgItem(hDlg, ID_VERT_MAX),
                          sizeof(szBuff) / sizeof(TCHAR) - 1) ;

            EditSetLimit (GetDlgItem(hDlg, IDD_CHARTOPTIONSINTERVAL),
                          ShortTextLen) ;

            WindowCenter (hDlg) ;
            return(TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case ID_VERT_MAX:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        DialogText(hDlg, ID_VERT_MAX, szBuff) ;
                        swscanf(szBuff, TEXT("%d"), &goLocalCopy.iVertMax) ;
                    }
                    break ;


                case IDD_CHARTOPTIONSINTERVAL:
                    if (HIWORD(wParam) == EN_CHANGE) {
                        goLocalCopy.eTimeInterval =
                        DialogFloat (hDlg, IDD_CHARTOPTIONSINTERVAL, NULL) ;
                    }
                    break ;

                case IDD_CHARTOPTIONSPERIODIC:
                case IDD_CHARTOPTIONSMANUALREFRESH:
                    // check if the Manual refresh is currently checked.
                    // Then toggle the ManualRefresh button
                    LocalManualRefresh =
                    IsDlgButtonChecked (hDlg, IDD_CHARTOPTIONSMANUALREFRESH) ;
                    CheckRadioButton (hDlg,
                                      IDD_CHARTOPTIONSMANUALREFRESH,
                                      IDD_CHARTOPTIONSPERIODIC,
                                      LocalManualRefresh ? IDD_CHARTOPTIONSPERIODIC :
                                      IDD_CHARTOPTIONSMANUALREFRESH) ;

                    // gray out time interval if necessary...
                    DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVALTEXT,
                                  LocalManualRefresh) ;
                    DialogEnable (hDlg, IDD_CHARTOPTIONSINTERVAL,
                                  LocalManualRefresh) ;
                    LocalManualRefresh = !LocalManualRefresh ;
                    break ;

                case IDD_CHARTOPTIONSVALUEBAR:
                    if (goLocalCopy.bStatusBarChecked == TRUE)
                        goLocalCopy.bStatusBarChecked = FALSE ;
                    else
                        goLocalCopy.bStatusBarChecked = TRUE ;
                    break ;


                case ID_LEGEND:
                    if (goLocalCopy.bLegendChecked == TRUE)
                        goLocalCopy.bLegendChecked = FALSE ;
                    else
                        goLocalCopy.bLegendChecked = TRUE ;

                    DialogEnable (hDlg, IDD_CHARTOPTIONSVALUEBAR,
                                  goLocalCopy.bLegendChecked) ;

                    break ;


                case ID_LABELS:
                    if (goLocalCopy.bLabelsChecked == TRUE)
                        goLocalCopy.bLabelsChecked = FALSE ;
                    else
                        goLocalCopy.bLabelsChecked = TRUE ;
                    break ;


                case ID_VERT_GRID:
                    if (goLocalCopy.bVertGridChecked == TRUE)
                        goLocalCopy.bVertGridChecked = FALSE ;
                    else
                        goLocalCopy.bVertGridChecked = TRUE ;
                    break ;


                case ID_HORZ_GRID:
                    if (goLocalCopy.bHorzGridChecked == TRUE)
                        goLocalCopy.bHorzGridChecked = FALSE ;
                    else
                        goLocalCopy.bHorzGridChecked = TRUE ;
                    break ;


                case ID_GRAPH:
                case ID_HISTOGRAM:
                    if (goLocalCopy.iGraphOrHistogram == BAR_GRAPH) {
                        goLocalCopy.iGraphOrHistogram = LINE_GRAPH ;
                    } else {
                        goLocalCopy.iGraphOrHistogram = BAR_GRAPH ;
                    }
                    CheckRadioButton(hDlg, ID_GRAPH, ID_HISTOGRAM,
                                     goLocalCopy.iGraphOrHistogram == LINE_GRAPH ?
                                     ID_GRAPH : ID_HISTOGRAM) ;

                    break ;

                case IDOK:
                    //  verify some numeric entries first
                    if (goLocalCopy.iVertMax > MAX_VERTICAL ||
                        goLocalCopy.iVertMax < MIN_VERTICAL) {
                        DlgErrorBox (hDlg, ERR_BADVERTMAX) ;
                        SetFocus (DialogControl (hDlg, ID_VERT_MAX)) ;
                        EditSetTextEndPos (hDlg, ID_VERT_MAX) ;
                        return (FALSE) ;
                        break ;
                    }
                    if (goLocalCopy.eTimeInterval > MAX_INTERVALSEC ||
                        goLocalCopy.eTimeInterval < MIN_INTERVALSEC) {
                        DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ;
                        SetFocus (DialogControl (hDlg, IDD_CHARTOPTIONSINTERVAL)) ;
                        EditSetTextEndPos (hDlg, IDD_CHARTOPTIONSINTERVAL) ;
                        return (FALSE) ;
                        break ;
                    }

                    // We need to send a size message to the main window
                    // so it can setup the redraw of the graph and legend.

                    lgraph->gOptions.bLegendChecked    = goLocalCopy.bLegendChecked ;
                    lgraph->gOptions.bStatusBarChecked = goLocalCopy.bStatusBarChecked ;

                    if (lgraph->gOptions.eTimeInterval != goLocalCopy.eTimeInterval
                        && !LocalManualRefresh) {
                        iTimeMilliseconds = (INT) (goLocalCopy.eTimeInterval * (FLOAT) 1000.0) ;
                        pGraphs->gInterval = iTimeMilliseconds ;
                        lgraph->bManualRefresh = LocalManualRefresh ;

                    } else if (LocalManualRefresh != lgraph->bManualRefresh) {
                        ToggleGraphRefresh (hWndGraph) ;
                    }
                    // Assign the local copy of the graph options to the
                    // global copy.

                    lgraph->gOptions = goLocalCopy ;

                    //               SizeGraphComponents (hWndGraph) ;
                    //               WindowInvalidate (hWndGraph) ;
                    dwCurrentDlgID = 0 ;
                    EndDialog (hDlg, 1) ;
                    return (TRUE) ;
                    break ;


                case IDCANCEL:
                    dwCurrentDlgID = 0 ;
                    EndDialog(hDlg,0);
                    return(TRUE);

                case ID_HELP:
                    CallWinHelp (dwCurrentDlgID) ;
                    break ;

                default:
                    break;
            }
            break;

        default:
            break;

    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\fileopen.c ===
#include "setedit.h"
#include "cderr.h"

#include "fileutil.h"   // for FileOpen, FileRead
#include "grafdata.h"   // for OpenChart
#include "utils.h"      // for strempty
#include "perfmops.h"   // for OpenWorkspace
#include "pmhelpid.h"   // Help IDs
#include <dlgs.h>       // for pshHelp

#define OptionsOFNStyle \
   (OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_ENABLEHOOK)

BOOL APIENTRY FileOpenHookProc (HWND hDlg, 
                                UINT iMessage, 
                                WPARAM wParam, 
                                LPARAM lParam)
{
   BOOL     bHandled = FALSE ;
   
   // only intercept the Help button and bring up our WinHelp data
   if (iMessage == WM_COMMAND && wParam == pshHelp)
      {
//      CallWinHelp (dwCurrentDlgID) ;
      bHandled = TRUE ;
      }
   else if (iMessage == WM_INITDIALOG)
      {
      WindowCenter (hDlg) ;
      bHandled = TRUE ;
      }

   return (bHandled) ;
}



BOOL FileOpen (HWND hWndParent, int nStringResourceID, LPTSTR lpInputFileName)
   {
   OPENFILENAME   ofn ;
   TCHAR          szFileSpec [256] ;
   TCHAR          szFileTitle [80] ;
   TCHAR          szDialogTitle [80] ;
   HANDLE         hFile ;
   PERFFILEHEADER FileHeader ;
   
   TCHAR          aszOpenFilter[LongTextLen] ;
   int            StringLength ;
   BOOL           retCode ;
   LPTSTR         pFileName = NULL ;
   BOOL           bNoFile = FALSE;

   if (lpInputFileName == NULL) {
      bNoFile = TRUE;
   }
   else if (strempty(lpInputFileName)) {
      bNoFile = TRUE;
   }

   aszOpenFilter[0] = 0;
   if (bNoFile)
      {

      dwCurrentDlgID = HC_PM_idDlgFileOpen ;

      // get the file extension strings
      LoadString (hInstance, nStringResourceID, aszOpenFilter,
         sizeof(aszOpenFilter) / sizeof(TCHAR)) ;
      StringLength = lstrlen (aszOpenFilter) + 1 ;
      LoadString (hInstance, nStringResourceID+1,
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;

#ifdef ADVANCED_PERFMON
      // get workspace file extension strings
      LoadString (hInstance, IDS_WORKSPACEFILE, 
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
      LoadString (hInstance, IDS_WORKSPACEFILEEXT,
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1;
#endif

      // get all file extension strings
      LoadString (hInstance, IDS_ALLFILES, 
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
      LoadString (hInstance, IDS_ALLFILESEXT,
         &aszOpenFilter[StringLength],
         sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
      StringLength += lstrlen (&aszOpenFilter[StringLength]) ;

      // setup the end strings
      aszOpenFilter[StringLength+1] = aszOpenFilter[StringLength+2] = TEXT('\0') ;

      strclr (szFileSpec) ;
      strclr (szFileTitle) ;

      StringLoad (IDS_FILEOPEN_TITLE, szDialogTitle) ;
      memset (&ofn, 0, sizeof(OPENFILENAME)) ;
      ofn.lStructSize = sizeof(OPENFILENAME) ;
      ofn.hwndOwner = hWndParent ;
      ofn.hInstance = hInstance;
      ofn.lpstrTitle = szDialogTitle ;
      ofn.lpstrFilter = aszOpenFilter ;
      ofn.nFilterIndex = 1L ;

      ofn.lpstrFile = szFileSpec;
      ofn.nMaxFile = sizeof(szFileSpec);
      ofn.lpstrFileTitle = szFileTitle;
      ofn.nMaxFileTitle = sizeof(szFileTitle);
      ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ENABLEHOOK ;
      ofn.lpfnHook = (LPOFNHOOKPROC) FileOpenHookProc ;

      if (!GetOpenFileName(&ofn))
         {
         dwCurrentDlgID = 0 ;
         return (FALSE) ;
         }

      dwCurrentDlgID = 0 ;

      hFile = FileHandleOpen (szFileSpec) ;
      pFileName = szFileSpec ;

      }  // NULL lpFileName

   else
      {
      // open the input file
      hFile = FileHandleOpen (lpInputFileName) ;
      if (hFile && hFile != INVALID_HANDLE_VALUE &&
          SearchPath (NULL, lpInputFileName, NULL,
            sizeof(szFileSpec)/sizeof(TCHAR) - 1,
            szFileSpec, &pFileName))
         {
         pFileName = szFileSpec ;
         }
      else
         {
         pFileName = NULL ;
         }
      }

   if (!hFile || hFile == INVALID_HANDLE_VALUE)
      {
      return (FALSE) ;
      }

   if (!FileRead (hFile, &FileHeader, sizeof (FileHeader)))
      {
      CloseHandle (hFile) ;
      if (strempty(lpInputFileName))
         {
         DlgErrorBox (hWndParent, ERR_BAD_SETTING_FILE, pFileName) ;
         }
      return (FALSE) ;
      }


   //=============================//
   // Chart File?                 //
   //=============================//

   if (strsame (FileHeader.szSignature, szPerfChartSignature))
      {
      retCode = OpenChart (hWndGraph,
                           hFile,
                           FileHeader.dwMajorVersion,
                           FileHeader.dwMinorVersion,
                           TRUE) ;
      if (retCode)
         {
         ChangeSaveFileName (pFileName, IDM_VIEWCHART) ;
         }
      else
         {
         goto ErrExit ;
         }
      return (retCode) ;
      }

   //=============================//
   // Unknown file type           //
   //=============================//
   CloseHandle (hFile) ;

ErrExit:

   DlgErrorBox (hWndParent, ERR_BAD_SETTING_FILE, pFileName) ;
   return (FALSE) ;
   }  // FileOpen


BOOL FileGetName (HWND hWndParent, int nStringResourceID, LPTSTR lpFileName)
   {
   OPENFILENAME   ofn ;
   TCHAR          szFileSpec [256] ;
   TCHAR          szFileTitle [80] ;
   TCHAR          szDialogTitle [80] ;
   TCHAR          aszOpenFilter[LongTextLen] ;
   int            StringLength = 0;

   if (lpFileName)
      {

      if (nStringResourceID != IDS_EXPORTFILE)
         {
         // get the file extension strings
         LoadString (hInstance, nStringResourceID,
            aszOpenFilter,
            sizeof(aszOpenFilter) / sizeof(TCHAR) ) ;
         StringLength = lstrlen (aszOpenFilter) + 1 ;
         LoadString (hInstance, nStringResourceID+1,
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;

         StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
         // get all file extension strings
         LoadString (hInstance, IDS_ALLFILES, 
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
         StringLength += lstrlen (&aszOpenFilter[StringLength]) + 1 ;
         LoadString (hInstance, IDS_ALLFILESEXT,
            &aszOpenFilter[StringLength],
            sizeof(aszOpenFilter) / sizeof(TCHAR) - StringLength) ;
         }

      // setup the end strings
      StringLength += lstrlen (&aszOpenFilter[StringLength]) ;
      aszOpenFilter[StringLength+1] = aszOpenFilter[StringLength+2] = TEXT('\0') ;

      strclr (szFileSpec) ;
      strclr (szFileTitle) ;

      dwCurrentDlgID = HC_PM_idDlgFileSaveAs ;
      StringLoad (IDS_SAVEAS_TITLE, szDialogTitle) ;

      memset (&ofn, 0, sizeof(OPENFILENAME)) ;
      ofn.lStructSize = sizeof(OPENFILENAME) ;
      ofn.hwndOwner = hWndParent ;
      ofn.hInstance = hInstance;
      ofn.lpstrTitle = szDialogTitle ;
      ofn.lpstrFilter = aszOpenFilter ;
      ofn.nFilterIndex = 1L ;

      ofn.lpstrFile = szFileSpec;
      ofn.nMaxFile = sizeof(szFileSpec);
      ofn.lpstrFileTitle = szFileTitle;
      ofn.nMaxFileTitle = sizeof(szFileTitle);

      ofn.Flags = OptionsOFNStyle ;
      ofn.lpfnHook = (LPOFNHOOKPROC) FileOpenHookProc ;

      if (!GetSaveFileName(&ofn))
         {
         dwCurrentDlgID = 0 ;
         return (FALSE) ;
         }
      dwCurrentDlgID = 0 ;
      }
   else
      {
      return (FALSE) ;
      }

   lstrcpy (lpFileName, ofn.lpstrFile) ;

   return (TRUE) ;
   } // FileGetName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\fileutil.c ===
//#include <string.h>
//#include <tchar.h>

#include <stdio.h>
#include "setedit.h"
#include "fileutil.h"
#include "utils.h"

#include <string.h>     // for strncpy
#ifdef UNICODE
#define _tcsrchr	wcsrchr
#else
#define _tcsrchr	strrchr
#endif

#define DRIVE_DELIMITER          TEXT(':')
#define DIRECTORY_DELIMITER      TEXT('\\')
#define EXTENSION_DELIMITER      TEXT('.')


#if 0
VOID FileErrorMessageBox(HWND hWnd, LPTSTR lpszFileName, DWORD ErrorCode)
   {
   TCHAR szErrorMessage[FILE_ERROR_MESSAGE_SIZE] ;
   TCHAR szErrorMessageTemplate[FILE_ERROR_MESSAGE_SIZE] ;

   StringLoad (IDS_FILE_ERROR, szErrorMessageTemplate) ;
   TSPRINTF((LPTSTR)szErrorMessage,
            (LPTSTR)szErrorMessageTemplate,
            lpszFileName,
            ErrorCode) ;

   MessageBox (hWnd, (LPTSTR)szErrorMessage, NULL,
              MB_OK | MB_ICONSTOP | MB_TASKMODAL);
   return ;
   }
#endif


BOOL FileRead (HANDLE hFile,
               LPMEMORY lpMemory,
               DWORD nAmtToRead)
   {  // FileRead
   BOOL           bSuccess ;
   DWORD          nAmtRead ;

   bSuccess = ReadFile (hFile, lpMemory, nAmtToRead, &nAmtRead, NULL) ;
   return (bSuccess && (nAmtRead == nAmtToRead)) ;
   }  // FileRead



BOOL FileWrite (HANDLE hFile,
                LPMEMORY lpMemory,
                DWORD nAmtToWrite)
   {  // FileWrite
   BOOL           bSuccess ;
   DWORD          nAmtWritten ;

   bSuccess = WriteFile (hFile, lpMemory, nAmtToWrite, &nAmtWritten, NULL) ;
   return (bSuccess && (nAmtWritten == nAmtToWrite)) ;
   }  // FileWrite

                
#if 0
HANDLE FileHandleOpen (LPTSTR lpszFilePath)
   {  // FileHandleOpen
   return ((HANDLE) CreateFile (lpszFilePath,
                                GENERIC_READ |
                                GENERIC_WRITE,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE,
                                NULL, 
                                OPEN_EXISTING,
                                0,
                                NULL)) ;
   }  // FileHandleOpen


HANDLE FileHandleCreate (LPTSTR lpszFilePath)
   {  // FileHandleCreate
   return ((HANDLE) CreateFile (lpszFilePath, 
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL)) ;
   }  // FileHandleCreate



long FileSeekEnd (HANDLE hFile,
                  long lAmtToMove)
   {  // FileSeekEnd
   return (SetFilePointer (hFile, lAmtToMove, NULL, FILE_END)) ;
   }  // FileSeekEnd


long FileSeekBegin (HANDLE hFile,
                    long lAmtToMove)
   {  // FileSeekBegin
   return (SetFilePointer (hFile, lAmtToMove, NULL, FILE_BEGIN)) ;
   }  // FileSeekBegin


long FileSeekCurrent (HANDLE hFile,
                      long lAmtToMove)
   {  // FileSeekCurrent
   return  (SetFilePointer (hFile, lAmtToMove, NULL, FILE_CURRENT)) ;
   }  // FileSeekCurrent
   


long FileTell (HANDLE hFile)
   {  // FileTell
   return (SetFilePointer (hFile, 0, NULL, FILE_CURRENT)) ;
   }  // FileTell
#endif



LPMEMORY FileMap (HANDLE hFile, HANDLE *phMapHandle)
/*
   To Do:         Error reporting!!
*/
   {  // FileMap
   HANDLE         hMapping ;


   *phMapHandle = 0 ;
   hMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY,
                                 0, 0, NULL) ;
   if (!hMapping)
      return (NULL) ;

   *phMapHandle = hMapping ;
   return (MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, 0)) ;
   }  // FileMap



BOOL FileUnMap (LPVOID pBase, HANDLE hMapping)
/*
   To Do:         Error reporting!!
*/
   {  // FileUnMap
   UnmapViewOfFile(pBase) ;
   CloseHandle (hMapping) ;
   return (TRUE) ;
   }  // FileUnMap



void FileNameExtension (LPTSTR lpszSpec,
                        LPTSTR lpszFileNameExtension)
/*
   Effect:        Return the name and extension portion only of lpszSpec
                  int lpszFileNameExtension.

   Assert:        lpszFileNameExtension is large enough to hold a name,
                  delimiter, extension, and terminating null character.
*/
   {  // FileNameExtension
   LPTSTR          lpszDelimiter ;

   lpszDelimiter = _tcsrchr ((LPCTSTR)lpszSpec, (TCHAR)DIRECTORY_DELIMITER) ;
   if (!lpszDelimiter)
      lpszDelimiter = _tcsrchr ((LPCTSTR)lpszSpec, (TCHAR)DRIVE_DELIMITER) ;

   lstrcpy (lpszFileNameExtension, 
           lpszDelimiter ? ++lpszDelimiter : lpszSpec) ;
   }  // FileNameExtension



void FileDriveDirectory (LPTSTR lpszFileSpec,
                         LPTSTR lpszDirectory)
/*
   Effect:        Extract the drive and directory from the file 
                  specification lpszFileSpec, and return the it in
                  lpszDirectory.

   Internals:     Copy the the whole spec to lpszDirectory. Use lstrrchr
                  to find the *last* directory delimiter ('\') and 
                  truncate the string right after that. 

   Note:          This function assumes that the specification lpszFileSpec
                  is fairly complete, in that it contains both a directory
                  and a file name.
*/
   {  // FileDriveDirectory
   LPTSTR          lpszDelimiter ;

   lstrcpy (lpszDirectory, lpszFileSpec) ;
   lpszDelimiter = _tcsrchr ((LPCTSTR)lpszDirectory, (TCHAR)DIRECTORY_DELIMITER) ;
   if (lpszDelimiter)
      *(++lpszDelimiter) = TEXT('\0') ;
   }  // FileDriveDirectory





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\globals.h ===
#ifdef DEFINE_GLOBALS

#define GLOBAL   

// #include "counters.h"

// initialize some of the globals
// only perfmon.c will define DEFINE_GLOBALS

int     aiIntervals [] = { 1, 5, 15, 30, 60, 120, 300, 600, 3600 } ;



#else
// only perfmon.c define DEFINE_GLOBALS,
// all other references to them as extern
#define GLOBAL extern

#define  NumIntervals   9
GLOBAL   int            aiIntervals [] ;

#endif



//=============================//
// Graph Data Information      //
//=============================//


GLOBAL   PPERFSYSTEM    pSysInfo ;
GLOBAL   PGRAPHSTRUCT   pGraphs;


//=============================//
// Font Information            //
//=============================//


GLOBAL   HFONT          hFontScales ;
GLOBAL   HFONT          hFontScalesBold ;
GLOBAL   LONG           HalfTextHeight;

//=============================//
// Control Information         //
//=============================//


GLOBAL   INT            iPerfmonView ;
GLOBAL   LANGID         iLanguage ;
GLOBAL   LANGID         iEnglishLanguage ;
GLOBAL   OPTIONS        Options ;

GLOBAL   HICON          hIcon ;
GLOBAL   HANDLE         hInstance;
GLOBAL   HANDLE         hAccelerators ;

GLOBAL   HMENU          hMenuChart ;


//=============================//
// Windows                     //
//=============================//


GLOBAL   HWND    hWndMain ;
GLOBAL   HWND    hWndGraph ;
GLOBAL   HWND    hWndGraphLegend ;
GLOBAL   HWND    hWndToolbar ;
GLOBAL   HWND    hWndStatus ;


//=============================//
// System Metrics              //
//=============================//


GLOBAL   int     xScreenWidth ;
GLOBAL   int     yScreenHeight ;

GLOBAL   int     xBorderWidth ;
GLOBAL   int     yBorderHeight ;

GLOBAL   int     xScrollWidth ;
GLOBAL   int     yScrollHeight ;

GLOBAL   int     xScrollThumbWidth ;
GLOBAL   int     yScrollThumbHeight ;


GLOBAL   int     xDlgBorderWidth ;
GLOBAL   int     yDlgBorderHeight ;

GLOBAL   int     MinimumSize ;

//=============================//
// Miscellaneous               //
//=============================//

GLOBAL   int            iUnviewedAlerts ;
GLOBAL   COLORREF       crLastUnviewedAlert ;

GLOBAL   LPTSTR         pChartFileName ;
GLOBAL   LPTSTR         pChartFullFileName ;

// globals for perfmornance improvements

// frequently used GDI objects 
GLOBAL   UINT     ColorBtnFace ;  // for concave/convex button painting
GLOBAL   HBRUSH   hBrushFace ;    // for concave/convex button painting
GLOBAL   HPEN     hPenHighlight ; // for concave/convex button painting
GLOBAL   HPEN     hPenShadow ;    // for concave/convex button painting
GLOBAL   HPEN     hWhitePen ;     // for chart highlighting
GLOBAL   HANDLE   hbLightGray ;   // for painting the background

// bPerfmonIconic is TRUE when perfmon is minimized.
// Thus, we don't need to update chart or report view until
// it is not iconized
GLOBAL   BOOL     bPerfmonIconic ;

// bAddLineInPorgress is TRUE when Addline dialog is up.  It is used
// in freeing unused system during data collecting. (But not while
// addline dialog is still up)
GLOBAL   BOOL     bAddLineInProgress ;

// bDelayAddAction is TRUE when reading setting files or adding more
// than 1 counter.  This is to delay some of the costly screen adjustments
// until we have added all the lines.
GLOBAL   BOOL     bDelayAddAction ;


// bExplainTxtButtonHit is TRUE when the ExplainText button in addline 
// dialog is clicked.  This is to save time and memory for fetching the
// help text, during BuildNameTable(), unless it is needed.
GLOBAL   BOOL     bExplainTextButtonHit ;

// globals used for WinHelp
GLOBAL   DWORD          dwCurrentDlgID ;
GLOBAL   DWORD          dwCurrentMenuID ;
GLOBAL   LPTSTR         pszHelpFile ;


// Following includes space for trailing NULL and preceeding \\'s
GLOBAL   TCHAR  LocalComputerName[MAX_COMPUTERNAME_LENGTH + 3];

// Flag to indicate if we need to close local machine
GLOBAL   BOOL           bCloseLocalMachine ;

// Timeout for data collection thread in msec
GLOBAL   DWORD          DataTimeOut ;

// flag to indicate duplicate instance names should be allowed
GLOBAL  BOOL            bMonitorDuplicateInstances;


// 20 sec for the data thread timeout
#define  DEFAULT_DATA_TIMEOUT    20000L

//=============================//
// Log Playback Information    //
//=============================//

GLOBAL   PLAYBACKLOG    PlaybackLog ;

GLOBAL   REPORT         Report ;
GLOBAL   ALERT          Alert ;
GLOBAL   LOG            Log ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\dlgids.h ===
#define IDD_OK             IDOK
#define IDD_CANCEL         IDCANCEL


/*	BUTTON ID'S                */


#define ID_ADD			    10
#define ID_START		    11
#define ID_STOP 		    12

#define ID_COMPUTER		 14
#define ID_OBJECT		    15
#define ID_INSTANCE		 16
#define ID_COUNTER		 17
#define ID_FILE 		    21

#define ID_TIME 		    26



#define ID_MAX_ENTRIES	 32

#define ID_THRESHOLD		 35
#define ID_FOREGR		    36
#define ID_BACKGR		    37
#define ID_TIME_LINE		 38

#define ID_POPUP		    40
#define ID_ELLIPSIS		 42
#define ID_TIME_SCROLL	 43
#define ID_BOOKMARK_IN	 45


#define ID_TIME_IN		 49
#define ID_FILE_IN		 50
#define ID_MAX_IN		    51
#define ID_NUM_IN		    52

#define ID_VERTICAL		 54
#define ID_CCOLOR		    55
#define ID_ENTER_SCALE	 56
#define ID_ENTER_VERT	 57
#define ID_ENTER_INTR	 58
#define ID_LOGTIME       62


#define ID_HELP          112
#define ID_LEGEND        201
#define ID_MENU          202
#define ID_LABELS        203
#define ID_VERT_GRID     204
#define ID_HORZ_GRID     205
#define ID_VERT_MAX      208
#define ID_GRAPH         211
#define ID_HISTOGRAM     212
#define ID_COMPUTER_EDIT_FIELD      301

#define ID_INTERVAL                 402


//=============================//
// Log Display Dialog          //
//=============================//


#define IDD_LOGFILETEXT          3001
#define IDD_LOGFILE              3002
#define IDD_LOGSTATUSTEXT        3003
#define IDD_LOGSTATUS            3004
#define IDD_LOGINTERVALTEXT      3005
#define IDD_LOGINTERVAL          3006
#define IDD_LOGSIZETEXT          3007
#define IDD_LOGSIZE              3008
#define IDD_LOGENTRIESTEXT       3009
#define IDD_LOGENTRIES           3010


//=============================//
// Log Options Dialog          //
//=============================//


#define IDD_LOGOPTSTART             3101
#define IDD_LOGOPTPAUSE             3102
#define IDD_LOGOPTINTERVALTEXT      3103
#define IDD_LOGOPTINTERVAL          3104
#define IDD_LOGOPTIONSMANUALREFRESH 3105
#define IDD_LOGOPTIONSPERIODIC      3106


//=============================//
// Add Log Dialog              //
//=============================//


#define IDD_ADDLOGCOMPUTER       3201
#define IDD_ADDLOGOBJECTTEXT     3202
#define IDD_ADDLOGOBJECT         3203
#define IDD_ADDLOGELLIPSES       3204
#define IDD_ADDLOGADD            3205
#define IDD_ADDLOGDONE           3206
#define IDD_ADDLOGHELP           3207


//=============================//
// Timeframe Dialog            //
//=============================//


#define IDD_TIMEFRAMETIMELINE    3301
#define IDD_TIMEFRAMEHELP        3302
#define IDD_TIMEFRAMESTOPTIME    3303
#define IDD_TIMEFRAMESTOPDATE    3304
#define IDD_TIMEFRAMESTARTDATE   3305
#define IDD_TIMEFRAMESTARTTIME   3306
#define IDD_TIMEFRAMESETSTART    3307
#define IDD_TIMEFRAMESTOP        3308
#define IDD_TIMEFRAMEBOOKMARKS   3309
#define IDD_TIMEFRAMESETSTOP     3310
#define IDD_TIMEFRAMEBOOKMARKGRP 3311



//=============================//
// Alert Display Dialog        //
//=============================//

#define IDD_ALERTLOGTEXT         3401
#define IDD_ALERTLOG             3402
#define IDD_ALERTLEGENDTEXT      3403
#define IDD_ALERTLEGEND          3404
#define IDD_ALERTINTERVALTEXT    3405
#define IDD_ALERTINTERVAL        3406


//=============================//
// Add Line Dialog             //
//=============================//


#define IDD_ADDLINECOMPUTERTEXT        3501
#define IDD_ADDLINECOMPUTER            3502
#define IDD_ADDLINEELLIPSES            3503
#define IDD_ADDLINEOBJECTTEXT          3504
#define IDD_ADDLINEOBJECT              3505
#define IDD_ADDLINECOUNTERTEXT         3506
#define IDD_ADDLINECOUNTER             3507
#define IDD_ADDLINEINSTANCETEXT        3508
#define IDD_ADDLINEINSTANCE            3509

#define IDD_ADDLINECOLORTEXT           3510
#define IDD_ADDLINECOLOR               3511
#define IDD_ADDLINESCALETEXT           3512
#define IDD_ADDLINESCALE               3513
#define IDD_ADDLINEWIDTHTEXT           3514
#define IDD_ADDLINEWIDTH               3515
#define IDD_ADDLINESTYLETEXT           3516
#define IDD_ADDLINESTYLE               3517

#define IDD_ADDLINEADD                 3521
#define IDD_ADDLINEHELP                3523

#define IDD_ADDLINEPARENTNAMETEXT      3530
#define IDD_ADDLINEPARENTNAME          3531
#define IDD_ADDLINEINSTANCENAMETEXT    3532
#define IDD_ADDLINEINSTANCENAME        3533


#define IDD_ADDLINEEXPANDEXPLAIN       3541
#define IDD_ADDLINEEXPLAINGROUP        3542
#define IDD_ADDLINEEXPLAIN             3543


//=============================//
// Report Options Dialog       //
//=============================//


#define IDD_REPORTOPTIONSINTERVALTEXT  3601
#define IDD_REPORTOPTIONSINTERVAL      3602
#define IDD_REPORTOPTIONSMANUALREFRESH 3603
#define IDD_REPORTOPTIONSPERIODIC      3604


//=============================//
// Display Options Dialog      //
//=============================//


#define IDD_DISPLAYMENU                3701
#define IDD_DISPLAYTOOLBAR             3702
#define IDD_DISPLAYSTATUS              3703
#define IDD_DISPLAYONTOP               3704
#define IDD_DISPLAYHELP                3705


//=============================//
// Data Source Dialog          //
//=============================//


#define IDD_DATASOURCENOW              3801
#define IDD_DATASOURCEFILE             3802
#define IDD_DATASOURCECHANGEFILE       3803
#define IDD_DATASOURCEHELP             3804
#define IDD_DATASOURCEFILENAME         3805



//=============================//
// Alert Options Dialog        //
//=============================//


#define IDD_ALERTOPTIONSINTERVAL       3901
#define IDD_ALERTOPTIONSBEEP           3902
#define IDD_ALERTOPTIONSNUMBEEPS       3903
#define IDD_ALERTOPTIONSPOPUP          3904
#define IDD_ALERTOPTIONSEVENTLOG       3905
#define IDD_ALERTOPTIONSNETWORKALERT   3906
#define IDD_ALERTOPTIONSMSGNAME        3907
#define IDD_ALERTOPTIONSMSGNAMETEXT    3908
#define IDD_ALERTOPTIONSMANUALREFRESH  3909
#define IDD_ALERTOPTIONSPERIODIC       3911
#define IDD_ALERTOPTIONSINTERVALTEXT   3912
#define IDD_ALERTOPTIONSNETGROUPTEXT   3913

//=============================//
// Chart Options Dialog        //
//=============================//


#define IDD_CHARTOPTIONSINTERVAL       4001
#define IDD_CHARTOPTIONSINTERVALTEXT   4002
#define IDD_CHARTOPTIONSVALUEBAR       4003
#define IDD_CHARTOPTIONSMANUALREFRESH  4004
#define IDD_CHARTOPTIONSPERIODIC       4005
#define IDD_CHARTOPTIONSUPDATETEXT     4006

//=============================//
// Bookmark Options Dialog     //
//=============================//


#define IDD_BOOKMARKCOMMENT            4101
#define IDD_BOOKMARKLIST               4102
#define IDD_BOOKMARKHELP               4103

//=========================//
// Export Options Dialog   //
//=========================//

#define IDD_EXPORTCOMMAS               4201
#define IDD_EXPORTTAB                  4202
#define IDD_EXPORTDELIMITERTEXT        4203
#define IDD_EXPORTHELP                 4204

//==========================//
//   Generic Menu items     //
// (used by ACCELERATORS)   //
//==========================//
#define IDM_FILEOPENFILE               4701
#define IDM_FILESAVEFILE               4702
#define IDM_FILESAVEASFILE             4703
#define IDM_CHARTHIGHLIGHTON           4704

//=============//
// Toolbar ID  //
//=============//
#define IDM_TOOLBARID                  4801
#define WM_F1DOWN                      WM_USER+100

//===============================//
// Select Computer from log file //
//===============================//
#define IDD_CHOOSECOMPUTERTEXT         4901
#define IDD_CHOOSECOMPUTERTEXT1        4902
#define IDD_CHOOSECOMPUTERNAME         4903
#define IDD_CHOOSECOMPUTERLISTBOX      4904


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\graph.h ===
/*****************************************************************************
 *
 *  Graph.h - Header for graphing window.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/


#define GRAPH_BORDER 4


BOOL GraphInitializeApplication (void) ;


HWND CreateGraphWindow (HWND hWndParent) ;


void SizeGraphComponents (HWND hWnd) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\fileutil.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

#define FILE_ERROR_MESSAGE_SIZE 256


VOID FileErrorMessageBox(HWND hWnd,
                         LPTSTR lpszFileName,
                         DWORD ErrorCode) ;


BOOL FileRead (HANDLE hFile,
               LPMEMORY lpMemory,
               DWORD nAmtToRead) ;

BOOL FileWrite (HANDLE hFile,
                LPMEMORY lpMemory,
                DWORD nAmtToWrite) ;


#define FileSeekBegin(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_BEGIN)

#define FileSeekEnd(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_END)

#define FileSeekCurrent(hFile, lAmtToMove) \
   SetFilePointer (hFile, lAmtToMove, NULL, FILE_CURRENT)

#define FileTell(hFile) \
   SetFilePointer (hFile, 0, NULL, FILE_CURRENT)

#define FileHandleOpen(lpszFilePath)         \
   (HANDLE) CreateFile (lpszFilePath,        \
      GENERIC_READ | GENERIC_WRITE,          \
      FILE_SHARE_READ,                       \
      NULL, OPEN_EXISTING,                   \
      FILE_ATTRIBUTE_NORMAL, NULL)

#define FileHandleReadOnly(lpszFilePath)     \
   (HANDLE) CreateFile (lpszFilePath,        \
      GENERIC_READ ,                         \
      FILE_SHARE_READ,                       \
      NULL, OPEN_EXISTING,                   \
      FILE_ATTRIBUTE_NORMAL, NULL)

#define FileHandleCreate(lpszFilePath)       \
   (HANDLE) CreateFile (lpszFilePath,        \
      GENERIC_READ | GENERIC_WRITE,          \
      FILE_SHARE_READ,                       \
      NULL, CREATE_ALWAYS,                   \
      FILE_ATTRIBUTE_NORMAL, NULL)

int FileHandleSeekCurrent (HANDLE hFile,
                           int iAmtToMove,
                           LPTSTR lpszFilePath) ;


int FileHandleSeekStart (HANDLE hFile,
                         int iAmtToMove,
                         LPTSTR lpszFilePath) ;


BOOL FileHandleWrite (HANDLE hFile, 
                      LPMEMORY lpBuffer,
                      int cbWrite,
                      LPTSTR lpszFilePath) ;


LPMEMORY FileMap (HANDLE hFile, HANDLE *phMapHandle) ;


BOOL FileUnMap (LPVOID pBase, HANDLE hMapHandle) ;


void FileDriveDirectory (LPTSTR lpszFileSpec,
                         LPTSTR lpszDirectory) ;


void FileNameExtension (LPTSTR lpszSpec,
                        LPTSTR lpszFileNameExtension) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\init.h ===
BOOL PerfmonInitialize (HINSTANCE hCurrentInstance,
                        HINSTANCE hPrevInstance,
                        LPCSTR lpszCmdLine,
                        int nCmdShow) ;


void PerfmonClose (HWND hWndMain) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\dialogs.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

INT_PTR GraphOptionDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR BookmarkDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR AboutDlg(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) ;
BOOL DisplayAlertOptions ( HWND hWndParent, HWND hWndAlert);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\grafdata.h ===
//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//
#if 0
PGRAPHSTRUCT GraphData (HWND hWndGraphDisplay) ;
#endif
#define GraphData(hWndGraphDisplay)       \
      (pGraphs)

FLOAT eUpdateAve(FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues,
                 INT iDataPoint, INT iTotalValidPoints) ;

FLOAT eUpdateMin(FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues, 
                 INT iTotalValidPoints, INT iDataPoint, INT gMaxPoints) ;


FLOAT eUpdateMax(FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues,
                 INT iTotalValidPoints) ;


PPERFSYSTEM InsertSystem(LPTSTR SysName) ;


BOOL ChartInsertLine (PGRAPHSTRUCT pGraph,
                      PLINE pLineNew) ;

VOID ChartDeleteLine (PGRAPHSTRUCT lgraph,
                      PLINESTRUCT pline) ;


void ResetGraph (PGRAPHSTRUCT pGraph) ;
void ResetGraphView (HWND hWndGraph) ;

void ClearGraphDisplay (PGRAPHSTRUCT pGraph) ;



BOOL InsertGraph(HWND hwnd) ;


void PlaybackChart (HWND hWndChart) ;

#if 0
PLINESTRUCT CurrentGraphLine (HWND hWndGraph) ;
#endif
#define CurrentGraphLine(hWndGraph)       \
   (LegendCurrentLine (hWndGraphLegend))


BOOL AddChart (HWND hWndParent) ;


BOOL EditChart (HWND hWndParent) ;


BOOL HandleGraphTimer (void) ;


VOID ClearGraphTimer(PGRAPHSTRUCT pGraph) ;


BOOL QuerySaveChart (HWND hWndParent, PGRAPHSTRUCT pGraph) ;
BOOL SaveChart (HWND hWndGraph, HANDLE hInputFile, BOOL bGetFileName) ;
BOOL OpenChart (HWND hWndGraph, HANDLE hFile, 
         DWORD dwMajorVersion, DWORD dwMinorVersion, BOOL bChartFile) ;

void ExportChart (void) ;

BOOL BuildNewValueListForGraph(void) ;

VOID UpdateValueBarData (PGRAPHSTRUCT pGraph) ;

void GraphAddAction (void) ;

BOOL ToggleGraphRefresh (HWND hWnd) ;

BOOL GraphRefresh (HWND hWnd) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\grafdata.c ===
/*****************************************************************************
 *
 *  Grafdata.c - This module handles the non-drawing functions of the graph,
 *      such as allocating linked structures and their memory, freeing it,
 *      unlinking, starting and stopping the timer,
 *      setting up the first graph (CPU), and all the numeric functions for
 *      the different counter types.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//

#include <stdio.h>      // for sprintf

#include "setedit.h"       // main perfmon declarations
#include "grafdata.h"      // external declarations for this file
#include <float.h>         // for FLT_MAX constant

#include "addline.h"       // for AddLine, EditLine
#include "counters.h"      // for Counter_Counter, et al.
#include "graph.h"         // for SizeGraphComponents
#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"      // for UpdateLines
#include "legend.h"
#include "system.h"        // for SystemGet
#include "utils.h"
#include "line.h"          // for LineFree
// #include "valuebar.h"      // for StatusTimer

#include "fileopen.h"      // for FileGetName
#include "fileutil.h"      // for FileRead...
#include "menuids.h"       // for IDM_VIEWCHART
#include "perfmops.h"      // for ExportFileHeader
#include "status.h"        // for StatusLineReady

extern BOOL SaveFileHandler(HWND hWnd,DWORD type) ;

// this macro is used in doing a simple DDA (Digital Differential Analyzer)
// * 10 + 5 is to make the result round up with .5
#define DDA_DISTRIBUTE(TotalTics, numOfData) \
   ((TotalTics * 10 / numOfData) + 5) / 10

#define szSmallValueFormat         TEXT("%10.3f")
#define szLargeValueFormat         TEXT("%10.0f")

//==========================================================================//
//                                Local Data                                //
//==========================================================================//




//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


/****************************************************************************
 * eUpdateMinMaxAve -
 ****************************************************************************/
void eUpdateMinMaxAve (FLOAT eValue, PLINESTRUCT pLineStruct, INT iValidValues,
   INT iTotalValidPoints, INT iDataPoint, INT gMaxPoints)
{
INT     i ;
INT     iDataNum = iTotalValidPoints ;
FLOAT   eMin,
        eMax,
        eSum,
        eNewValue ;


   eMax = eMin = eValue ;

   eSum = eValue ;

   if (iValidValues == iTotalValidPoints)
      {
      for (i=0 ; i < iValidValues ; i++)
         {
         if (i == iDataPoint)
            {
            // skip the data point we are going to replace
            continue ;
            }

         eNewValue = pLineStruct->lnValues[i] ;
         
         eSum += eNewValue ;

         if (eNewValue > eMax)
            {
            eMax = eNewValue ;
            }

         if (eNewValue < eMin)
            {
            eMin = eNewValue ;
            }
         }
      }
   else
      {
      // special case when we start the new line in the middle of the chart
      for (i = iDataPoint, iTotalValidPoints-- ;
          iTotalValidPoints > 0 ;
          iTotalValidPoints-- )
         {
         i-- ;
         if (i < 0)
            {
            // for the wrap-around case..
            i = gMaxPoints - 1 ;
            }

         if (i == iDataPoint)
            {
            // skip the data point we are going to replace
            continue ;
            }
         eNewValue = pLineStruct->lnValues[i] ;

         eSum += eNewValue ;

         if (eNewValue > eMax)
            {
            eMax = eNewValue ;
            }

         if (eNewValue < eMin)
            {
            eMin = eNewValue ;
            }
         }
      }

   pLineStruct->lnMinValue = eMin ;
   pLineStruct->lnMaxValue = eMax ;

   if (iDataNum)
      {
      pLineStruct->lnAveValue = eSum / (FLOAT) iDataNum ;
      }
   else
      {
      pLineStruct->lnAveValue = (FLOAT) 0.0 ;
      }
}



BOOL HandleGraphTimer (void)
   {
   return(TRUE);
   }


VOID GetGraphConfig(PGRAPHSTRUCT pGraph)
{

    LoadRefreshSettings(pGraph);
    LoadLineGraphSettings(pGraph);


    // Init the structure
    pGraph->pLineFirst = NULL;

    //NOTE: put the rest of this in Config

    pGraph->gOptions.bLegendChecked    = TRUE;
    pGraph->gOptions.bMenuChecked      = TRUE;
    pGraph->gOptions.bLabelsChecked    = TRUE;
    pGraph->gOptions.bVertGridChecked  = FALSE;
    pGraph->gOptions.bHorzGridChecked  = FALSE;
    pGraph->gOptions.bStatusBarChecked = TRUE;
    pGraph->gOptions.GraphVGrid        = TRUE;
    pGraph->gOptions.GraphHGrid        = TRUE;
    pGraph->gOptions.HistVGrid         = TRUE;
    pGraph->gOptions.HistHGrid         = TRUE;

    pGraph->gOptions.iGraphOrHistogram = LINE_GRAPH;       // vs. BAR_GRAPH
    pGraph->gOptions.iVertMax = DEF_GRAPH_VMAX;

    return;
}


BOOL InsertGraph (HWND hWnd)
   {
   PGRAPHSTRUCT    pGraph;

   pGraph = MemoryAllocate (sizeof (GRAPHSTRUCT)) ;
   if (!pGraph)
      return (FALSE) ;


   pGraphs = pGraph;

   
   GetGraphConfig(pGraph);
   pGraph->bManualRefresh = FALSE ;

   pGraph->gMaxValues = DEFAULT_MAX_VALUES;
   pGraph->pptDataPoints = NULL ;

   pGraph->pDataTime = NULL ;

   pGraph->hWnd = hWnd ;
   pGraph->bModified = TRUE ;   // creating a graph means it's been modified

   pGraph->Visual.iColorIndex = 0 ;
   pGraph->Visual.iWidthIndex = 0 ;
   pGraph->Visual.iStyleIndex = 0 ;

   return(TRUE) ;
   }




BOOL ChartInsertLine (PGRAPHSTRUCT pGraph, 
                      PLINE pLine)
/*
   Effect:        Insert the line pLine into the graph pGraph and 
                  allocate space for the graph's number of values.

   Returns:       Whether the line could be added and space allocated.

   See Also:      LineAllocate (line.c), ChartDeleteLine.
*/
   {  // ChartInsertLine
   PLINE          pLineEquivalent ;
   INT            i ;
   FLOAT          *pTempPts;
   HPEN           tempPen ;

   pGraph->bModified = TRUE ;

   pLineEquivalent = FindEquivalentLine (pLine, pGraph->pLineFirst) ;
   if (pLineEquivalent)
      {
        if (bMonitorDuplicateInstances) {
            pLine->dwInstanceIndex = pLineEquivalent->dwInstanceIndex + 1;
        } else {
            pLineEquivalent->Visual = pLine->Visual ;
            pLineEquivalent->iScaleIndex = pLine->iScaleIndex ;
            pLineEquivalent->eScale = pLine->eScale ;

            tempPen = pLineEquivalent->hPen ;
            pLineEquivalent->hPen =  pLine->hPen ;
            pLine->hPen = tempPen ;
            return FALSE ;
        }  
      }

    LineAppend (&pGraph->pLineFirst, pLine) ;

    // Add the line to the legend, resize the legend window, and then
    // select the new line as the current legend item. Do it in this 
    // sequence to avoid the legend scroll bar momentarily appearing and
    // then disappearing, since the resize will obviate the scroll bar.

    LegendAddItem (hWndGraphLegend, pLine) ;

    if (!bDelayAddAction)
        {
        SizeGraphComponents (hWndGraph) ;
        LegendSetSelection (hWndGraphLegend, 
                        LegendNumItems (hWndGraphLegend) - 1) ;
        }

   return (TRUE) ;
   }  // ChartInsertLine


VOID ChartDeleteLine (PGRAPHSTRUCT pGraph, 
                      PLINESTRUCT pLine)
   {
   PLINESTRUCT npLine;


   pGraph->bModified = TRUE ;

   if (pGraph->pLineFirst == pLine)
       pGraph->pLineFirst = pLine->pLineNext;
   else
   {
       for (npLine = pGraph->pLineFirst; npLine; npLine = npLine->pLineNext)
       {
           if (npLine->pLineNext == pLine)
               npLine->pLineNext = pLine->pLineNext;
       }
   }

   if (!pGraph->pLineFirst)
      {
      ResetGraph (pGraph) ;
      }
   else
      {
//      BuildNewValueListForGraph () ;
      }

   // Delete the legend entry for this line.
   // If the line was highlighted then this will undo the highlight.

   LegendDeleteItem (hWndGraphLegend, pLine) ;

   LineFree (pLine) ;

   SizeGraphComponents (hWndGraph) ;


   }


FLOAT Counter_Queuelen(PLINESTRUCT pLine)
{

    return((FLOAT)0.0);
//    pLine;
}


void ClearGraphDisplay (PGRAPHSTRUCT pGraph)
   {
   PLINESTRUCT    pLine;

   // reset the timeline data
//   pGraph->gKnownValue = -1 ;
//   pGraph->gTimeLine.iValidValues = 0 ;
//   pGraph->gTimeLine.xLastTime = 0 ;
//   memset (pGraph->pDataTime, 0, sizeof(SYSTEMTIME) * pGraph->gMaxValues) ;

   // loop through lines,
   // If one of the lines is highlighted then do the calculations
   // for average, min, & max on that line.

//   for (pLine=pGraph->pLineFirst; pLine; pLine=pLine->pLineNext)
//      { // for

//      pLine->bFirstTime = 2 ;
//      pLine->lnMinValue = FLT_MAX ;
//      pLine->lnMaxValue = - FLT_MAX ;
//      pLine->lnAveValue = 0.0F ;
//      pLine->lnValidValues = 0 ;
//      memset (pLine->lnValues, 0, sizeof(FLOAT) * pGraph->gMaxValues) ;
//      }

//   StatusTimer (hWndGraphStatus, TRUE) ;
   }

void ResetGraphView (HWND hWndGraph)
   {
   PGRAPHSTRUCT      pGraph ;

   pGraph = GraphData (hWndGraph) ;


   if (!pGraph)
      {
      return ;
      }

   ChangeSaveFileName (NULL, IDM_VIEWCHART) ;

   if (pGraph->pSystemFirst)
      {
      ResetGraph (pGraph) ;
      }
   }  // ResetGraphView

void ResetGraph (PGRAPHSTRUCT pGraph)
   {
   ClearLegend (hWndGraphLegend) ;
   if (pGraph->pLineFirst)
      {
      FreeLines (pGraph->pLineFirst) ;
      pGraph->pLineFirst = NULL ;
      }

   if (pGraph->pSystemFirst)
      {
      FreeSystems (pGraph->pSystemFirst) ;
      pGraph->pSystemFirst = NULL ;
      }

   pGraph->gKnownValue = -1 ;
   pGraph->gTimeLine.iValidValues = 0 ;
   pGraph->gTimeLine.xLastTime = 0 ;

   // reset visual data
   pGraph->Visual.iColorIndex = 0 ;
   pGraph->Visual.iWidthIndex = 0 ;
   pGraph->Visual.iStyleIndex = 0 ;

//   memset (pGraph->pDataTime, 0, sizeof(SYSTEMTIME) * pGraph->gMaxValues) ;

   SizeGraphComponents (hWndGraph) ;
   InvalidateRect(hWndGraph, NULL, TRUE) ;
   }




BOOL AddChart (HWND hWndParent)
   {
   PLINE pCurrentLine = CurrentGraphLine (hWndGraph) ;

   return (AddLine (hWndParent, 
                    &(pGraphs->pSystemFirst), 
                    &(pGraphs->Visual), 
                    pCurrentLine ? pCurrentLine->lnSystemName : NULL,
                    LineTypeChart)) ;
   }


BOOL EditChart (HWND hWndParent)
   {  // EditChart
   return (EditLine (hWndParent, 
                     &(pGraphs->pSystemFirst), 
                     CurrentGraphLine (hWndGraph),
                     LineTypeChart)) ;
   }


BOOL QuerySaveChart (HWND hWndParent, PGRAPHSTRUCT pGraph)
/*
   Effect:        If the graph pGraph is modified, put up a message
                  box allowing the user to save the current graph.
                  
                  Return whether the caller should proceed to load in
                  a new or otherwise trash the current graph.
*/
   {  // QuerySaveChart
#ifdef KEEP_QUERY
   int            iReturn ;

   if (!pGraph->bModified)
      return (TRUE) ;

   iReturn = MessageBoxResource (hWndParent, 
                                 IDS_SAVECHART, IDS_MODIFIEDCHART,
                                 MB_YESNOCANCEL | MB_ICONASTERISK) ;

   if (iReturn == IDCANCEL)
      return (FALSE) ;

   if (iReturn == IDYES)
      SaveChart (hWndGraph, 0, 0) ;
   return (TRUE) ;
#endif
   return (TRUE) ;  // we don't want to query nor save change

   }  // QuerySaveChart

void GraphAddAction ()
   {
   PGRAPHSTRUCT      pGraph ;

   pGraph = GraphData (hWndGraph) ;

   SizeGraphComponents (hWndGraph) ;
   
   LegendSetSelection (hWndGraphLegend,
      LegendNumItems (hWndGraphLegend) - 1) ;

   }

BOOL OpenChartVer1 (HANDLE hFile,
                    DISKCHART *pDiskChart,
                    PGRAPHSTRUCT pGraph)
   {  // OpenChartVer1
   bDelayAddAction = TRUE ;
   pGraph->Visual = pDiskChart->Visual ;
   pGraph->gOptions = pDiskChart->gOptions ;
   pGraph->gMaxValues = pDiskChart->gMaxValues ;
   pGraph->bManualRefresh = pDiskChart->bManualRefresh ;
   pGraphs->gInterval = (INT) (pGraph->gOptions.eTimeInterval * (FLOAT) 1000.0) ;
   ReadLines (hFile, pDiskChart->dwNumLines,
               &(pGraph->pSystemFirst), &(pGraph->pLineFirst), IDM_VIEWCHART) ;
   
   bDelayAddAction = FALSE ;

   GraphAddAction () ;

   return (TRUE) ;
   }  // OpenChartVer1



BOOL OpenChart (HWND hWndGraph,
                HANDLE hFile,
                DWORD dwMajorVersion,
                DWORD dwMinorVersion,
                BOOL bChartFile)
   {  // OpenChart
   PGRAPHSTRUCT   pGraph ;
   DISKCHART      DiskChart ;
   BOOL           bSuccess = TRUE ;

   pGraph = pGraphs ;
   if (!pGraph)
      {
      bSuccess = FALSE ;
      goto Exit0 ;
      }

   if (!FileRead (hFile, &DiskChart, sizeof (DISKCHART)))
      {
      bSuccess = FALSE ;
      goto Exit0 ;
      }


   switch (dwMajorVersion)
      {
      case (1):

         SetHourglassCursor() ;
         
         ResetGraphView (hWndGraph) ;

         OpenChartVer1 (hFile, &DiskChart, pGraph) ;

         // change to chart view if we are opening a 
         // chart file
         if (bChartFile && iPerfmonView != IDM_VIEWCHART)
            {
            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWCHART, 0L) ;
            }

         if (iPerfmonView == IDM_VIEWCHART)
            {
            SetPerfmonOptions (&DiskChart.perfmonOptions) ;
            }
         
         SetArrowCursor() ;

         break ;
      }  // switch

Exit0:

   if (bChartFile)
      {
      CloseHandle (hFile) ;
      }

   return (bSuccess) ;
   }  // OpenChart

BOOL SaveChart (HWND hWndGraph, HANDLE hInputFile, BOOL bGetFileName)
   {
   PGRAPHSTRUCT   pGraph ;
   PLINE          pLine ;
   HANDLE         hFile ;
   DISKCHART      DiskChart ;
   PERFFILEHEADER FileHeader ;
   TCHAR          szFileName [256] ;
   BOOL           newFileName = FALSE ;

   if (hInputFile)
      {
      // use the input file handle if it is available
      // this is the case for saving workspace data
      hFile = hInputFile ;
      }
   else
      {
      if (pChartFullFileName)
         {
         lstrcpy (szFileName, pChartFullFileName) ;
         }
      if (bGetFileName || pChartFullFileName == NULL)
         {
//         if (!pChartFullFileName)
//            {
//            StringLoad (IDS_GRAPH_FNAME, szFileName) ;
//            }

         if (!FileGetName (hWndGraph, IDS_CHARTFILE, szFileName))
            {
            return (FALSE) ;
            }
         newFileName = TRUE ;
         }

      hFile = FileHandleCreate (szFileName) ;

      if (hFile && hFile != INVALID_HANDLE_VALUE && newFileName)
         {
         ChangeSaveFileName (szFileName, IDM_VIEWCHART) ;
         }
      else if (!hFile || hFile == INVALID_HANDLE_VALUE)
         {
         DlgErrorBox (hWndGraph, ERR_CANT_OPEN, szFileName) ;
         }
      }

   if (!hFile || hFile == INVALID_HANDLE_VALUE)
      return (FALSE) ;

   pGraph = pGraphs ;
   if (!pGraph)
      {
      if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
         {
         CloseHandle (hFile) ;
         }
      return (FALSE) ;
      }

   if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
      {
      // only need to write file header if not workspace 
      memset (&FileHeader, 0, sizeof (FileHeader)) ;
      lstrcpy (FileHeader.szSignature, szPerfChartSignature) ;
      FileHeader.dwMajorVersion = ChartMajorVersion ;
      FileHeader.dwMinorVersion = ChartMinorVersion ;
   
      if (!FileWrite (hFile, &FileHeader, sizeof (PERFFILEHEADER)))
         {
         goto Exit0 ;
         }
      }

   DiskChart.Visual = pGraph->Visual ;
   DiskChart.gOptions = pGraph->gOptions ;
   DiskChart.gMaxValues = pGraph->gMaxValues ;
   DiskChart.dwNumLines = NumLines (pGraph->pLineFirst) ;
   DiskChart.bManualRefresh = pGraph->bManualRefresh ;
   DiskChart.perfmonOptions = Options ;

   if (!FileWrite (hFile, &DiskChart, sizeof (DISKCHART)))
      {
      goto Exit0 ;
      }

   for (pLine = pGraph->pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext)
      {  // for
      if (!WriteLine (pLine, hFile))
         {
         goto Exit0 ;
         }
      }  // for

   if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
      {
      CloseHandle (hFile) ;
      }

   return (TRUE) ;

Exit0:
   if (!hInputFile || hInputFile == INVALID_HANDLE_VALUE)
      {
      CloseHandle (hFile) ;

      // only need to report error if not workspace 
      DlgErrorBox (hWndGraph, ERR_SETTING_FILE, szFileName) ;
      }
   return (FALSE) ;

   }  // SaveChart

#define TIME_TO_WRITE 6

typedef struct CHARTDATAPOINTSTRUCT
   {
   int         iLogIndex ;
   int         xDispDataPoint ;
   } CHARTDATAPOINT, *PCHARTDATAPOINT ;


BOOL ToggleGraphRefresh (HWND hWnd)
   {  // ToggleGraphRefresh
   PGRAPHSTRUCT   pGraph ;
   pGraph = GraphData (hWnd) ;

   pGraph->bManualRefresh = !pGraph->bManualRefresh ;
   return (pGraph->bManualRefresh) ;
   }  // ToggleGraphRefresh

BOOL GraphRefresh (HWND hWnd)
   {  // GraphRefresh
   PGRAPHSTRUCT   pGraph ;

   pGraph = GraphData (hWnd) ;

   return (pGraph->bManualRefresh) ;
   }  // GraphRefresh
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\legend.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            legend.c - legend window routines.

            This file contains code creating the legend window, which is
            a child of the graph windows. The legend window displays a
            legend line for each line in the associated graph. It also
            includes an area called the label, which are headers for those
            lines.


  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include <stdio.h>      // for sprintf
#include "setedit.h"
#include "legend.h"     // external declarations for this file

#include "owndraw.h"
#include "perfmops.h"

#include "grafdata.h"   // for EditChart
#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines
#include "utils.h"
// #include "valuebar.h"   // for StatusTimer

#define eScaleValueSpace       TEXT(">9999999999.0")

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define dwGraphLegendClassStyle     (CS_HREDRAW | CS_VREDRAW)
#define iGraphLegendClassExtra      (0)
#define iGraphLegendWindowExtra     (sizeof (PLEGEND))
#define dwGraphLegendWindowStyle    (WS_CHILD | WS_VISIBLE)

#define xLegendBorderWidth          (xDlgBorderWidth)
#define yLegendBorderHeight         (yDlgBorderHeight)

#define iLabelLen                   30
#define iLegendColMax               1000

#define LEFTORIENTATION             1
#define CENTERORIENTATION           2
#define RIGHTORIENTATION            3

#define LegendColorCol              0
#define LegendScaleCol              1
#define LegendCounterCol            2
#define LegendInstanceCol           3
#define LegendParentCol             4
#define LegendObjectCol             5
#define LegendSystemCol             6

#define iLegendNumCols              7

#define iLegendMaxVisibleItems      8

#define dwGraphLegendItemsWindowClass  TEXT("ListBox")
#define dwGraphLegendItemsWindowStyle           \
   (LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED | \
    WS_VISIBLE | WS_CHILD | WS_VSCROLL)


//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//


typedef struct LEGENDCOLSTRUCT {
    TCHAR          szLabel [iLabelLen] ;
    int            xMinWidth ;
    int            xMaxWidth ;
    int            xWidth ;
    int            xPos ;
    int            iOrientation ;
} LEGENDCOL ;

typedef LEGENDCOL *PLEGENDCOL ;


typedef struct LEGENDTRUCT {
    HWND           hWndItems ;
    HFONT          hFontItems ;
    HFONT          hFontLabels ;
    int            xMinWidth ;
    int            yLabelHeight ;
    int            yItemHeight ;
    int            iNumItemsVisible ;
    LEGENDCOL      aCols [iLegendNumCols] ;
    int            iLineType ;
    PLINE          pCurrentLine ;    // current selected line
}  LEGEND ;

typedef LEGEND *PLEGEND ;


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define LabelTopMargin()      (2)
#define LegendLeftMargin()    (3 + ThreeDPad)

#define LegendItemTopMargin() (yBorderHeight)


#define IsLegendLabelVisible()  (TRUE)

#define ColCanGrow(pCol)                     \
   (pCol->xMaxWidth > pCol->xWidth)


#define LegendHorzMargin()    (3)



//==========================================================================//
//                                Local Data                                //
//==========================================================================//


// LEGEND            Legend ;
PLEGEND     pGraphLegendData ;

#define  LegendData(hWnd)     \
   (pGraphLegendData )

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
void LegendSetCurrentLine (PLEGEND pLegend, INT_PTR iIndex)
{
    pLegend->pCurrentLine =
    (PLINESTRUCT) LBData (pLegend->hWndItems, iIndex) ;

    if (pLegend->pCurrentLine == (PLINESTRUCT) LB_ERR) {
        pLegend->pCurrentLine = NULL ;
    }
}  // LegendSetCurrentLine


PLEGEND AllocateLegendData (HWND hWnd, BOOL bChartLegend)
{
    PLEGEND        pLegend ;

    pLegend = MemoryAllocate (sizeof (LEGEND)) ;
    //   SetWindowLong (hWnd, 0, (LONG) pLegend) ;

    if (bChartLegend) {
        hWndGraphLegend = hWnd ;
        pGraphLegendData = pLegend ;
    }

    return (pLegend) ;
}



void DrawLegendLabel (PLEGEND pLegend,
                      HDC hDC,
                      HWND hWnd)
{  // DrawLegendLabel
    int            i ;
    int            xPos ;
    RECT           rect ;
    RECT           rectLB ;
    INT            LocalThreeDPad = ThreeDPad - 1 ;

    SetBkColor (hDC, crLightGray) ;

    SelectFont (hDC, pLegend->hFontLabels) ;

    GetClientRect (hWnd, &rect) ;
    //   Fill (hDC, crLightGray, &rect) ;
    ExtTextOut (hDC, rect.left, rect.top,
                ETO_OPAQUE, &(rect), NULL, 0, NULL ) ;

    GetWindowRect (pLegend->hWndItems, &rectLB) ;
    ScreenRectToClient (hWnd, &rectLB) ;
    ThreeDConcave1 (hDC,
                    rectLB.left - LocalThreeDPad,
                    rectLB.top - LocalThreeDPad,
                    rectLB.right + LocalThreeDPad,
                    rectLB.bottom + LocalThreeDPad) ;

    for (i = 0 ;
        i < iLegendNumCols ;
        i++) {  // for
        rect.left = pLegend->aCols[i].xPos ;
        rect.top = yBorderHeight ;
        rect.right = rect.left + pLegend->aCols[i].xWidth - LegendHorzMargin () ;
        rect.bottom = pLegend->yLabelHeight ;

        switch (pLegend->aCols[i].iOrientation) {  // switch
            case LEFTORIENTATION:
                SetTextAlign (hDC, TA_LEFT) ;
                xPos = rect.left ;
                break ;

            case CENTERORIENTATION:
                SetTextAlign (hDC, TA_CENTER) ;
                xPos = (rect.left + rect.right) / 2 ;
                break ;

            case RIGHTORIENTATION:
                SetTextAlign (hDC, TA_RIGHT) ;
                xPos = rect.right ;
                break ;

            default:
                xPos = rect.left ;
                break ;
        }  // switch

        ExtTextOut (hDC,
                    xPos, rect.top,
                    ETO_OPAQUE,
                    &rect,
                    pLegend->aCols[i].szLabel,
                    lstrlen (pLegend->aCols[i].szLabel),
                    NULL) ;
    }  // for
}  // DrawLegendLabel



void DrawColorCol (PLEGEND pLegend,
                   PLINE pLine,
                   int iCol,
                   HDC hDC,
                   int yPos)
/*
   Effect:        Draw the "color" column of a legend entry. The color
                  column displays a small sample of the line drawing.

                  For charts, the sample is a line of the correct style,
                  color, and width.  Since we are using wide lines,
                  the round endcaps of the lines will breach the column.
                  Therefore we need to set the clip region. We could
                  remove this clipping if we find a way to change the
                  end cap design.

*/
{  // DrawColorCol
    HBRUSH         hBrush, hBrushPrevious ;
    RECT           rect ;
    int            yMiddle ;
    int            iCircle ;



    rect.left = pLegend->aCols[iCol].xPos - LegendLeftMargin () + 2 ;
    rect.top = yPos + 1 ;
    rect.right = rect.left + pLegend->aCols[iCol].xWidth - LegendHorzMargin () ;
    rect.bottom = yPos + pLegend->yItemHeight - 1 ;

    yMiddle = rect.top + (rect.bottom - rect.top) / 2 ;
    iCircle = rect.bottom - rect.top - 2 ;

    switch (pLegend->iLineType) {  // switch
        case LineTypeChart:

            if (pLine->Visual.iWidth == 1) {
                // simple case with thin pen
                hBrush = SelectBrush (hDC, hbLightGray) ;
                Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom) ;

                HLine (hDC, pLine->hPen,
                       rect.left + 1, rect.right - 1, yMiddle) ;
                SelectBrush (hDC, hBrush) ;
            } else {
                // thicker pen width, have to set ClipRect so
                // it will not draw otherside the rect.
                SaveDC (hDC) ;
                hBrush = SelectBrush (hDC, hbLightGray) ;
                Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom) ;

                IntersectClipRect (hDC,
                                   rect.left + 1,
                                   rect.top + 1,
                                   rect.right - 1,
                                   rect.bottom - 1) ;
                HLine (hDC, pLine->hPen,
                       rect.left + 1, rect.right - 1, yMiddle) ;
                SelectBrush (hDC, hBrush) ;
                RestoreDC (hDC, -1) ;
            }
            break ;

    }  // switch

}  // DrawColorCol


void DrawLegendCol (PLEGEND pLegend,
                    int iCol,
                    HDC hDC,
                    int yPos,
                    LPTSTR lpszValue)
/*
   Effect:        Draw the value lpszValue for the column iCol on hDC.

   Assert:        The foreground and background text colors of hDC are
                  properly set.
*/
{  // DrawLegendCol
    RECT           rect ;
    int            xPos ;

    rect.left = pLegend->aCols[iCol].xPos - LegendLeftMargin () ;
    rect.top = yPos ;
    rect.right = rect.left + pLegend->aCols[iCol].xWidth - LegendHorzMargin () ;
    rect.bottom = yPos + pLegend->yItemHeight ;

    //   SetTextAlign (hDC, TA_TOP) ;
    switch (pLegend->aCols[iCol].iOrientation) {  // switch
        case LEFTORIENTATION:
            SetTextAlign (hDC, TA_LEFT) ;
            xPos = rect.left ;
            break ;

        case CENTERORIENTATION:
            SetTextAlign (hDC, TA_CENTER) ;
            xPos = (rect.left + rect.right) / 2 ;
            break ;

        case RIGHTORIENTATION:
            SetTextAlign (hDC, TA_RIGHT) ;
            xPos = rect.right ;
            break ;

        default:
            xPos = rect.left ;
            break ;
    }  // switch

    ExtTextOut (hDC,
                xPos, rect.top + LegendItemTopMargin (),
                ETO_OPAQUE | ETO_CLIPPED,
                &rect,
                lpszValue,
                lstrlen (lpszValue),
                NULL) ;
}  // DrawLegendCol


void DrawLegendItem (PLEGEND pLegend,
                     PLINESTRUCT pLine,
                     int yPos,
                     HDC hDC)
{
    TCHAR          szValue [256] ;
    TCHAR          szInstance [256] ;
    TCHAR          szParent [256] ;
    TCHAR          szNoName[4] ;

    szNoName[0] = szNoName[1] = szNoName[2] = TEXT('-') ;
    szNoName[3] = TEXT('\0') ;

    //=============================//
    // Determine Instance, Parent  //
    //=============================//

    // It's possible that there will be no instance, therefore
    // the lnInstanceName would be NULL.

    if (pLine->lnObject.NumInstances > 0) {
        // Test for the parent object instance name title index.
        // If there is one, it implies that there will be a valid
        // Parent Object Name and a valid Parent Object Instance Name.

        // If the Parent Object title index is 0 then
        // just display the instance name.

        lstrcpy (szInstance, pLine->lnInstanceName) ;
        if ((pLine->bUserEdit ||
             pLine->lnInstanceDef.ParentObjectTitleIndex) &&
            pLine->lnPINName) {
            // Get the Parent Object Name.
            lstrcpy (szParent, pLine->lnPINName) ;
        } else {
            lstrcpy (szParent, szNoName) ;
        }
    } else {
        lstrcpy (szInstance, szNoName) ;
        lstrcpy (szParent, szNoName) ;
    }

    //=============================//
    // Draw Color                  //
    //=============================//

    DrawColorCol (pLegend, pLine, LegendColorCol, hDC, yPos) ;

    //=============================//
    // Draw Scale/Value            //
    //=============================//

    if (pLegend->iLineType == LineTypeChart) {
        if (pLine->eScale < (FLOAT) 1.0) {
            TSPRINTF (szValue, TEXT("%7.7f"), pLine->eScale) ;
        } else {
            TSPRINTF (szValue, TEXT("%10.3f"), pLine->eScale) ;
        }
        ConvertDecimalPoint (szValue);
    }

    SetTextAlign (hDC, TA_TOP) ;

    DrawLegendCol (pLegend, LegendScaleCol,
                   hDC, yPos, szValue) ;


    //=============================//
    // Draw Counter                //
    //=============================//

    DrawLegendCol (pLegend, LegendCounterCol,
                   hDC, yPos, pLine->lnCounterName) ;


    //=============================//
    // Draw Instance               //
    //=============================//

    DrawLegendCol (pLegend, LegendInstanceCol,
                   hDC, yPos, szInstance) ;

    //=============================//
    // Draw Parent                 //
    //=============================//

    DrawLegendCol (pLegend, LegendParentCol,
                   hDC, yPos, szParent) ;

    //=============================//
    // Draw Object                 //
    //=============================//

    DrawLegendCol (pLegend, LegendObjectCol,
                   hDC, yPos, pLine->lnObjectName) ;

    //=============================//
    // Draw System                 //
    //=============================//

    DrawLegendCol (pLegend, LegendSystemCol,
                   hDC, yPos, pLine->lnSystemName) ;

}


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


BOOL OnLegendCreate (HWND hWnd, LPCREATESTRUCT lpCS)
{
    PLEGEND        pLegend ;
    HDC            hDC ;
    int            iCol ;
    BOOL           bChartLegend ;

    bChartLegend = (lpCS->lpCreateParams) == (LPVOID) TRUE ;

    pLegend = AllocateLegendData (hWnd, bChartLegend) ;

    if (!pLegend)
        return (FALSE) ;

    pLegend->iLineType = LineTypeChart ;

    pLegend->hFontItems = hFontScales ;
    pLegend->hFontLabels = hFontScalesBold ;
    hDC = GetDC (hWnd) ;

    //=============================//
    // Load Labels                 //
    //=============================//

    StringLoad (IDS_LABELCOLOR, pLegend->aCols[LegendColorCol].szLabel) ;
    if (pLegend->iLineType == LineTypeChart)
        StringLoad (IDS_LABELSCALE,
                    pLegend->aCols[LegendScaleCol].szLabel) ;
    else
        StringLoad (IDS_LABELVALUE,
                    pLegend->aCols[LegendScaleCol].szLabel) ;
    StringLoad (IDS_LABELCOUNTER, pLegend->aCols[LegendCounterCol].szLabel) ;
    StringLoad (IDS_LABELINSTANCE, pLegend->aCols[LegendInstanceCol].szLabel) ;
    StringLoad (IDS_LABELPARENT, pLegend->aCols[LegendParentCol].szLabel) ;
    StringLoad (IDS_LABELOBJECT, pLegend->aCols[LegendObjectCol].szLabel) ;
    StringLoad (IDS_LABELSYSTEM, pLegend->aCols[LegendSystemCol].szLabel) ;


    //=============================//
    // Label dimensions            //
    //=============================//

    SelectFont (hDC, pLegend->hFontLabels) ;
    pLegend->yLabelHeight = FontHeight (hDC, TRUE) + 2 * LabelTopMargin () ;

    //=============================//
    // Column dimensions           //
    //=============================//

    for (iCol = 0 ;
        iCol < iLegendNumCols ;
        iCol++) {  // for
        pLegend->aCols[iCol].iOrientation = LEFTORIENTATION ;
        pLegend->aCols[iCol].xMinWidth =
        TextWidth (hDC, pLegend->aCols[iCol].szLabel) + LegendHorzMargin () ;
    }  // for

    SelectFont (hDC, pLegend->hFontItems) ;
    pLegend->yItemHeight = FontHeight (hDC, TRUE) + 2 * LegendItemTopMargin () ;

    pLegend->aCols[LegendColorCol].xMaxWidth = max (3 * xScrollWidth,
                                                    pLegend->aCols[LegendColorCol].xMinWidth) ;

    pLegend->aCols[LegendScaleCol].xMaxWidth = TextWidth (hDC, eScaleValueSpace) ;
    pLegend->aCols[LegendCounterCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendInstanceCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendParentCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendObjectCol].xMaxWidth = iLegendColMax ;
    pLegend->aCols[LegendSystemCol].xMaxWidth = iLegendColMax ;

    pLegend->aCols[LegendColorCol].iOrientation = LEFTORIENTATION ;
    pLegend->aCols[LegendScaleCol].iOrientation = RIGHTORIENTATION ;

    ReleaseDC (hWnd, hDC) ;

    //=============================//
    // Create Legend Items Listbox //
    //=============================//

    pLegend->hWndItems =
    CreateWindow (TEXT("ListBox"),               // window class
                  NULL,                          // window caption
                  dwGraphLegendItemsWindowStyle, // window style
                  0, 0, 0, 0,                    // window size and pos
                  hWnd,                          // parent window
                  NULL,                          // menu
                  hInstance,                     // program instance
                  (LPVOID) TRUE) ;               // user-supplied data

    return TRUE;

}  // OnLegendCreate


void static OnSize (HWND hWnd, int xWidth, int yHeight)
/*
   Effect:        Perform all actions necessary when the legend window is
                  being resized. In particular, set the width and starting
                  position for each column of the legend list and labels.

   Internals:     What we do is determine the amount of space in the
                  width that is greater than the minimum, and allocate
                  that space among each of the columns that is willing to
                  be larger than minimum. If there is not enough room for
                  the minimum, don't bother with calculations.
*/

{  // OnSize
    PLEGEND        pLegend ;
    PLEGENDCOL     pCol ;
    int            xMin ;
    int            xSlack ;
    int            iColsToGrow ;
    int            iCol ;

    pLegend = LegendData (hWnd) ;

    //=============================//
    // Resize Legend Items         //
    //=============================//

    if (IsLegendLabelVisible ())
        MoveWindow (pLegend->hWndItems,
                    LegendLeftMargin (), pLegend->yLabelHeight + ThreeDPad,
                    xWidth - 2 * LegendLeftMargin (),
                    yHeight - pLegend->yLabelHeight - yLegendBorderHeight,
                    TRUE) ;
    else
        MoveWindow (pLegend->hWndItems,
                    0, 0,
                    xWidth, yHeight,
                    TRUE) ;


    //=============================//
    // Allocate width to Columns   //
    //=============================//

    xMin = LegendMinWidth (hWnd) ;
    xSlack = max (xWidth - xMin, 0) ;
    iColsToGrow = 0 ;

    for (iCol = 0 ;
        iCol < iLegendNumCols ;
        iCol++) {  // for
        pCol = &(pLegend->aCols[iCol]) ;

        pCol->xWidth = pCol->xMinWidth ;
        if (ColCanGrow (pCol))
            iColsToGrow++ ;
    }  // for

    for (iCol = 0 ;
        iCol < iLegendNumCols ;
        iCol++) {  // for
        pCol = &(pLegend->aCols[iCol]) ;

        if (ColCanGrow (pCol)) {
            if ((pCol->xWidth + xSlack / iColsToGrow) >
                pCol->xMaxWidth) {  // if
                pCol->xWidth = pCol->xMaxWidth ;
                xSlack -= (pCol->xMaxWidth - pCol->xMinWidth) ;
                iColsToGrow-- ;
            }  // if
        }  // if
    }  // for

    for (iCol = 0 ;
        iCol < iLegendNumCols ;
        iCol++) {  // for
        pCol = &(pLegend->aCols[iCol]) ;

        if (ColCanGrow (pCol))
            pCol->xWidth += xSlack / iColsToGrow ;
    }  // for

    if (pLegend->aCols[LegendCounterCol].xWidth <
        pLegend->aCols[LegendCounterCol].xMaxWidth) {
        // cut some from the other columns and give them to CounterCol
        if (pLegend->aCols[LegendColorCol].xWidth - xScrollWidth >=
            pLegend->aCols[LegendColorCol].xMinWidth) {
            pLegend->aCols[LegendColorCol].xWidth -= xScrollWidth ;
            pLegend->aCols[LegendCounterCol].xWidth += xScrollWidth ;
        }
        if (pLegend->aCols[LegendInstanceCol].xWidth - xScrollWidth >=
            pLegend->aCols[LegendInstanceCol].xMinWidth) {
            pLegend->aCols[LegendInstanceCol].xWidth -= xScrollWidth ;
            pLegend->aCols[LegendCounterCol].xWidth += xScrollWidth ;
        }
        if (pLegend->aCols[LegendParentCol].xWidth - xScrollWidth >=
            pLegend->aCols[LegendParentCol].xMinWidth) {
            pLegend->aCols[LegendParentCol].xWidth -= xScrollWidth ;
            pLegend->aCols[LegendCounterCol].xWidth += xScrollWidth ;
        }
    }


    //=============================//
    // Set Column positions        //
    //=============================//

    pLegend->aCols[0].xPos = LegendLeftMargin () ;
    for (iCol = 1 ;
        iCol < iLegendNumCols ;
        iCol++) {  // for
        pLegend->aCols[iCol].xPos =
        pLegend->aCols[iCol - 1].xPos + pLegend->aCols[iCol - 1].xWidth ;

        if (iCol == LegendCounterCol) {
            // add some space between Scale/Value col & Counter col
            pLegend->aCols[LegendCounterCol].xPos += LegendLeftMargin () ;
        }
    }  // for

}  // OnSize


void static OnPaint (HWND hWnd)
{  // OnPaint
    PLEGEND        pLegend ;
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    hDC = BeginPaint (hWnd, &ps) ;

    if (IsLegendLabelVisible ()) {
        pLegend = LegendData (hWnd) ;
        DrawLegendLabel (pLegend, hDC, hWnd) ;
    }


    EndPaint (hWnd, &ps) ;
}  // OnPaint


void OnDrawLegendItem (HWND hWnd,
                       LPDRAWITEMSTRUCT lpDI)
{  // OnDrawItem
    HFONT          hFontPrevious ;
    HDC            hDC ;
    PLEGEND        pLegend ;
    PLINESTRUCT    pLine ;
    int            iLBIndex ;
    COLORREF       preBkColor ;
    COLORREF       preTextColor ;


    hDC = lpDI->hDC ;
    iLBIndex = DIIndex (lpDI) ;

    pLegend = LegendData (hWnd) ;

    if (iLBIndex == -1)
        pLine = NULL ;
    else
        pLine = (PLINESTRUCT) LBData (pLegend->hWndItems, iLBIndex) ;

    //=============================//
    // Set DC attributes           //
    //=============================//


    if (DISelected (lpDI)) {  // if
        preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ;
        preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ;
    }  // if
    ExtTextOut (hDC, lpDI->rcItem.left, lpDI->rcItem.top,
                ETO_OPAQUE, &(lpDI->rcItem), NULL, 0, NULL ) ;


    //=============================//
    // Draw Legend Item            //
    //=============================//

    hFontPrevious = SelectFont (hDC, pLegend->hFontItems) ;
    if (pLine)
        DrawLegendItem (pLegend, pLine, lpDI->rcItem.top, hDC) ;
    SelectFont (hDC, hFontPrevious) ;

    //=============================//
    // Draw Focus                  //
    //=============================//

    if (DIFocus (lpDI))
        DrawFocusRect (hDC, &(lpDI->rcItem)) ;


    if (DISelected (lpDI)) {  // if
        preTextColor = SetTextColor (hDC, preTextColor) ;
        preBkColor = SetBkColor (hDC, preBkColor) ;
    }  // if
}  // OnDrawItem


void static OnMeasureItem (HWND hWnd,
                           LPMEASUREITEMSTRUCT lpMI)
{  // OnMeasureItem
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    lpMI->itemHeight = pLegend->yItemHeight ;
}  // OnMeasureItem


void static OnDestroy (HWND hWnd)
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    MemoryFree (pLegend) ;
}  // OnDestroy



void static OnDoubleClick (HWND hWnd)
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    if (!pLegend)
        return ;

    switch (pLegend->iLineType) {  // switch
        case LineTypeChart:
            EditChart (hWndMain) ;
            break ;

    }  // switch
}  // OnDoubleClick


void static OnSetFocus (HWND hWnd)
{  // OnSetFocus
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;

    SetFocus (pLegend->hWndItems) ;
}

void static OnSelectionChanged (HWND hWnd)
{  // OnSelectionChanged
    PLEGEND        pLegend ;
    PGRAPHSTRUCT   pGraph ;
    INT_PTR        iIndex ;

    pLegend = LegendData (hWnd) ;

    // set the new selected line
    iIndex = LBSelection (pLegend->hWndItems) ;

    if (iIndex == LB_ERR)
        return ;

    LegendSetCurrentLine (pLegend, iIndex) ;
}  // OnSelectionChanged


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT
APIENTRY
GraphLegendWndProc (
                   HWND hWnd,
                   UINT wMsg,
                   WPARAM wParam,
                   LPARAM lParam
                   )
{  // GraphLegendWndProc
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;


    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {  // switch
        case WM_DELETEITEM:
            break ;

        case WM_COMMAND:
            switch (HIWORD (wParam)) {  // switch
                case LBN_DBLCLK:
                    OnDoubleClick (hWnd) ;
                    break ;

                case LBN_SELCHANGE:
                    OnSelectionChanged (hWnd) ;
                    break ;

                default:
                    break ;
            }  // switch
            break ;

        case WM_CREATE:
            OnLegendCreate (hWnd, (LPCREATESTRUCT) lParam) ;
            break ;

        case WM_DESTROY:
            OnDestroy (hWnd) ;
            break ;

        case WM_DRAWITEM:
            OnDrawLegendItem (hWnd, (LPDRAWITEMSTRUCT) lParam) ;
            break ;

        case WM_MEASUREITEM:
            OnMeasureItem (hWnd, (LPMEASUREITEMSTRUCT) lParam) ;
            break ;

        case WM_PAINT:
            OnPaint (hWnd) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_SETFOCUS:
            OnSetFocus (hWnd) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }  // switch


    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}  // GraphLegendWndProc


int LegendMinWidth (HWND hWnd)
{
    PLEGEND        pLegend ;
    int            iCol ;
    int            xMinWidth ;

    pLegend = LegendData (hWnd) ;
    xMinWidth = 0 ;

    for (iCol = 0 ;
        iCol < iLegendNumCols ;
        iCol++) {  // for
        xMinWidth += pLegend->aCols[iCol].xMinWidth ;
    }  // for

    return (xMinWidth) ;
}


int LegendMinHeight (HWND hWnd)
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;

    if (IsLegendLabelVisible ())
        return (pLegend->yLabelHeight + pLegend->yItemHeight) ;
    else
        return (pLegend->yItemHeight) ;
}


int LegendHeight (HWND hWnd, int yGraphHeight)
/*
   Effect:        Return the best height for the Legend window given the
                  number of items and label visibility of the legend, as
                  well as the overall height of the graph.
*/
{  // LegendHeight
    PLEGEND        pLegend ;
    int            yPreferredHeight ;

    pLegend = LegendData (hWnd) ;

    yPreferredHeight = yLegendBorderHeight +
                       pLegend->yItemHeight *
                       PinInclusive (LBNumItems (pLegend->hWndItems),
                                     1, iLegendMaxVisibleItems) ;
    if (IsLegendLabelVisible ())
        yPreferredHeight += pLegend->yLabelHeight ;

    return (min (yPreferredHeight, yGraphHeight / 2)) ;
}  // LegendHeight



int LegendFullHeight (HWND hWnd, HDC hDC)
/*
   Effect:        Return the best height for the Legend window given the
                  number of items and label visibility of the legend, as
                  well as the overall height of the graph.
*/
{  // LegendHeight
    PLEGEND        pLegend ;
    int            yPreferredHeight ;

    pLegend = LegendData (hWnd) ;

    yPreferredHeight = yLegendBorderHeight +
                       pLegend->yItemHeight *
                       LBNumItems (pLegend->hWndItems) ;
    if (IsLegendLabelVisible ())
        yPreferredHeight += pLegend->yLabelHeight ;

    return (yPreferredHeight) ;
}  // LegendFullHeight




HWND CreateGraphLegendWindow (HWND hWndGraph)
{
    return (CreateWindow (szGraphLegendClass,       // class
                          NULL,                     // caption
                          dwGraphLegendWindowStyle, // window style
                          0, 0,                     // position
                          0, 0,                     // size
                          hWndGraph,                // parent window
                          NULL,                     // menu
                          hInstance,                // program instance
                          (LPVOID) TRUE)) ;         // user-supplied data
}


BOOL GraphLegendInitializeApplication (void)
/*
   Called By:     GraphInitializeApplication only
*/
{
    WNDCLASS       wc ;

    wc.style          = dwGraphLegendClassStyle ;
    wc.lpfnWndProc    = GraphLegendWndProc ;
    wc.hInstance      = hInstance ;
    wc.cbClsExtra     = iGraphLegendClassExtra ;
    wc.cbWndExtra     = iGraphLegendWindowExtra ;
    wc.hIcon          = NULL ;
    wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
    wc.hbrBackground  = hbLightGray ;
    wc.lpszMenuName   = NULL ;
    wc.lpszClassName  = szGraphLegendClass ;

    return (RegisterClass (&wc)) ;
}


BOOL LegendAddItem (HWND hWnd, PLINESTRUCT pLine)
/*
   Effect:        Add a legend entry for the line pLine. Don't select
                  the line as current entry here, because this will cause
                  the scroll bar to unneccesarily appear for a moment.
                  If you want this line to be the current line, resize
                  the legend first, then set as current line.

   See Also:      ChartInsertLine.
*/
{  // LegendAddItem
    PLEGEND        pLegend ;

    pLegend = LegendData (hWnd) ;
    LBAdd (pLegend->hWndItems, pLine) ;

    return (TRUE) ;
}  // LegendAddItem


void LegendDeleteItem (HWND hWndLegend,
                       PLINE pLine)
{  // LegendDeleteItem
    PLEGEND        pLegend ;
    INT_PTR        iIndex ;
    INT_PTR        iNextIndex ;
    INT_PTR        iNumItems ;
    PGRAPHSTRUCT   pGraph ;

    pLegend = LegendData (hWndLegend) ;
    if (!pLegend)
        return ;

    iNumItems = LBNumItems (pLegend->hWndItems) ;

    iIndex = LBFind (pLegend->hWndItems, pLine) ;

    if (iIndex != LB_ERR) {
        LBDelete (pLegend->hWndItems, iIndex) ;
    }

    // no need to do anything if iNumItems is 1 to begin with
    if (iNumItems != LB_ERR && iNumItems > 1) {
        if (iIndex == iNumItems - 1) {
            // deleting the last line, then set selection
            // to the previous legend line
            iNextIndex = iIndex - 1 ;
        } else {
            // set the selection to the next legend line
            iNextIndex = iIndex ;
        }

        LBSetSelection (pLegend->hWndItems, iNextIndex) ;
        LegendSetCurrentLine (pLegend, iNextIndex) ;
    }
}  // LegendDeleteItem


PLINE LegendCurrentLine (HWND hWndLegend)
{  // LegendCurrentLine
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;

    if (!pLegend)
        return (NULL) ;

    return (pLegend->pCurrentLine) ;

}  // LegendCurrentLine



int LegendNumItems (HWND hWndLegend)
{  // LegendNumItems
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;

    return (LBNumItems (pLegend->hWndItems)) ;
}  // LegendNumItems



void LegendSetSelection (HWND hWndLegend, int iIndex)
{  // LegendSetSelection
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;
    LBSetSelection (pLegend->hWndItems, iIndex) ;
    LegendSetCurrentLine (pLegend, iIndex) ;
}  // LegendSetSelection



#ifdef KEEP_PRINT

void PrintLegend (HDC hDC, PGRAPHSTRUCT pGraph, HWND hWndLegend,
                  RECT rectLegend)
{
    PLEGEND        pLegend ;
    int            yItemHeight ;
    HFONT          hFontItems ;
    PLINE          pLine ;
    int            iIndex ;
    int            iIndexNum ;


    pLegend = LegendData (hWndLegend) ;

    yItemHeight = pLegend->yItemHeight ;
    hFontItems = pLegend->hFontItems ;

    pLegend->hFontItems = hFontPrinterScales ;
    SelectFont (hDC, pLegend->hFontItems) ;

    pLegend->yItemHeight = FontHeight (hDC, TRUE) ;

    iIndexNum = LBNumItems (pLegend->hWndItems) ;
    for (iIndex = 0 ;
        iIndex < iIndexNum ;
        iIndex++) {  // for
        pLine = (PLINE) LBData (pLegend->hWndItems, iIndex) ;
        DrawLegendItem (pLegend, pLine, iIndex * pLegend->yItemHeight, hDC) ;
    }  // for

    pLegend->hFontItems = hFontItems ;
    pLegend->yItemHeight = yItemHeight ;


    SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ;
    SelectPen (hDC, GetStockObject (BLACK_PEN)) ;
    Rectangle (hDC, 0, 0,
               rectLegend.right - rectLegend.left,
               rectLegend.bottom - rectLegend.top) ;
}
#endif


void ClearLegend (HWND hWndLegend)
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;
    if (!pLegend)
        return ;

    LBReset (pLegend->hWndItems) ;
    pLegend->pCurrentLine = NULL ;
}

void LegendSetRedraw (HWND hWndLegend, BOOL bRedraw)
{
    PLEGEND        pLegend ;

    pLegend = LegendData (hWndLegend) ;
    if (!pLegend)
        return ;

    LBSetRedraw (pLegend->hWndItems, bRedraw) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\line.h ===
VOID FreeLines (PLINESTRUCT pLineFirst) ;


PLINE LineAllocate (void) ;


void LineFree (PLINE pLine) ;



void LineAppend (PPLINE ppLineFirst, 
                 PLINE pLineNew) ;



BOOL LineRemove (PPLINE ppLineFirst,
                 PLINE pLineRemove) ;


int NumLines (PLINE pLineFirst) ;


LPTSTR LineInstanceName (PLINE pLine) ;


LPTSTR LineParentName (PLINE pLine) ;


void LineCounterAppend (PPLINE ppLineFirst, 
                        PLINE pLineNew) ;


BOOL EquivalentLine (PLINE pLine1,
                     PLINE pLine2) ;


PLINE FindEquivalentLine (PLINE pLineToFind,
                          PLINE pLineFirst) ;


BOOL WriteLine (PLINE pLine,
                HANDLE hFile) ;




void ReadLines (HANDLE hFile,
                DWORD dwNumLines,
                PPPERFSYSTEM ppSystemFirst,
                PPLINE ppLineFirst,
                int LineType) ;


HPEN LineCreatePen (HDC hDC,
                    PLINEVISUAL pVisual,
                    BOOL bForPrint) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\memory.c ===
#include "setedit.h"    // included by all perfmon sources
#include "pmemory.h"     // external declarations for this file


LPMEMORY MemoryAllocate (SIZE_T dwSize)
{  // MemoryAllocate
    HMEMORY        hMemory ;
    LPMEMORY       lpMemory ;

    hMemory = GlobalAlloc (GHND, dwSize) ;
    if (!hMemory)
        return (NULL) ;
    lpMemory = GlobalLock (hMemory) ;
    if (!lpMemory)
        GlobalFree (hMemory) ;
    return (lpMemory) ;
}  // MemoryAllocate


VOID MemoryFree (LPMEMORY lpMemory)
{  // MemoryFree
    HMEMORY        hMemory ;

    if (!lpMemory)
        return ;

    hMemory = GlobalHandle (lpMemory) ;

    if (hMemory) {  // if
        GlobalUnlock (hMemory) ;
        GlobalFree (hMemory) ;
    }  // if
}  // MemoryFree


SIZE_T MemorySize (LPMEMORY lpMemory)
{
    HMEMORY        hMemory ;

    hMemory = GlobalHandle (lpMemory) ;
    if (!hMemory)
        return (0L) ;

    return (GlobalSize (hMemory)) ;
}


LPMEMORY MemoryResize (LPMEMORY lpMemory,
                       SIZE_T dwNewSize)
{
    HMEMORY        hMemory ;
    LPMEMORY       lpNewMemory ;

    hMemory = GlobalHandle (lpMemory) ;
    if (!hMemory)
        return (NULL) ;

    GlobalUnlock (hMemory) ;

    hMemory = GlobalReAlloc (hMemory, dwNewSize, GHND) ;

    if (!hMemory)
        return (NULL) ;


    lpNewMemory = GlobalLock (hMemory) ;

    return (lpNewMemory) ;
}  // MemoryResize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\menuids.h ===
#define MENUIDTOHELPID        4000


#define FILEMENUPOSITION      0
#define EDITMENUPOSITION      1
#define VIEWMENUPOSITION      2
#define OPTIONSMENUPOSITION   3



// Special "view-independent" menu IDs for the toolbar
#define IDM_TOOLBARADD                 4291
#define IDM_TOOLBARMODIFY              4292
#define IDM_TOOLBARDELETE              4294
#define IDM_TOOLBAROPTIONS             4295
#define IDM_TOOLBARREFRESH             4296
#define IDM_TOOLBARBOOKMARK            4297


//=============================//
// "File" Menu IDs             //
//=============================//

#define IDM_FILENEWCHART            4101
#define IDM_FILEOPENCHART           4102
#define IDM_FILESAVECHART           4103
#define IDM_FILESAVEASCHART         4104
#define IDM_FILEEXPORTCHART         4105

#define IDM_FILENEWALERT            4106
#define IDM_FILEOPENALERT           4107
#define IDM_FILESAVEALERT           4108
#define IDM_FILESAVEASALERT         4109
#define IDM_FILEEXPORTALERT         4110

#define IDM_FILENEWLOG              4111
#define IDM_FILEOPENLOG             4112
#define IDM_FILESAVELOG             4113
#define IDM_FILESAVEASLOG           4114
#define IDM_FILEEXPORTLOG           4115

#define IDM_FILENEWREPORT           4116
#define IDM_FILEOPENREPORT          4117
#define IDM_FILESAVEREPORT          4118
#define IDM_FILESAVEASREPORT        4119
#define IDM_FILEEXPORTREPORT        4120

#define IDM_FILESAVEWORKSPACE       4121
#define IDM_FILEPRINTERSETUP        4125
#define IDM_FILEEXIT                4127


//=============================//
// "Edit" Menu IDs             //
//=============================//


#define IDM_EDITADDCHART            4201
#define IDM_EDITMODIFYCHART         4202
#define IDM_EDITCLEARCHART          4203
#define IDM_EDITDELETECHART         4204

#define IDM_EDITADDALERT            4205
#define IDM_EDITMODIFYALERT         4206
#define IDM_EDITCLEARALERT          4207
#define IDM_EDITDELETEALERT         4208

#define IDM_EDITADDLOG              4209
#define IDM_EDITMODIFYLOG           4210
#define IDM_EDITCLEARLOG            4211
#define IDM_EDITDELETELOG           4212

#define IDM_EDITADDREPORT           4213
#define IDM_EDITMODIFYREPORT        4214
#define IDM_EDITCLEARREPORT         4215
#define IDM_EDITDELETEREPORT        4216

#define IDM_EDITTIMEWINDOW          4217


//=============================//
// "View" Menu IDs             //
//=============================//

#define IDM_VIEWCHART               4301
#define IDM_VIEWALERT               4302
#define IDM_VIEWLOG                 4303
#define IDM_VIEWREPORT              4304


//=============================//
// "Options" Menu IDs          //
//=============================//


#define IDM_OPTIONSCHART            4401

#define IDM_OPTIONSALERT            4403

#define IDM_OPTIONSLOG              4405

#define IDM_OPTIONSREPORT           4407

#define IDM_OPTIONSMANUALREFRESH    4409

#define IDM_OPTIONSDISPLAYMENU      4408
#define IDM_OPTIONSDISPLAYTOOL      4409
#define IDM_OPTIONSDISPLAYSTATUS    4410
#define IDM_OPTIONSDISPLAYONTOP     4411

#define IDM_OPTIONSBOOKMARK         4413
#define IDM_OPTIONSDATASOURCE       4415

#define IDM_OPTIONSREFRESHNOWCHART  4416
#define IDM_OPTIONSREFRESHNOWALERT  4417
#define IDM_OPTIONSREFRESHNOWLOG    4418
#define IDM_OPTIONSREFRESHNOWREPORT 4419

//=============================//
// "Help" Menu IDs             //
//=============================//


#define IDM_HELPCONTENTS            4501
#define IDM_HELPSEARCH              4502
#define IDM_HELPHELP                4503
#define IDM_HELPABOUT               4504


//=============================//
// "System" Menu IDs           //
//=============================//

#define IDM_SYSTEMRESTORE           4910
#define IDM_SYSTEMMOVE              4911
#define IDM_SYSTEMSIZE              4912
#define IDM_SYSTEMMINIMIZE          4913
#define IDM_SYSTEMMAXIMIZE          4914
#define IDM_SYSTEMCLOSE             4915
#define IDM_SYSTEMSWITCHTO          4916

#define IDM_FIRSTMENUID             IDM_FILENEWCHART
#define IDM_LASTMENUID              IDM_SYSTEMSWITCHTO


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\graph.c ===
/*****************************************************************************
 *
 *  Graph.c - This module handles the graphing window.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/

/*
   File Contents:

      This file contains the code for creating and manipulating the graph
      window. This window is a child of hWndMain and represents one of the
      three "views" of the program. The other views are log and alert.

      The graph window is actually just a container window, whose surface
      is completely filled by its children: hWndGraphLegend and hWndGraphStatus.
      Therefore much of this file is merely calls to the appropriate
      functions for these children.

      The graph window is responsible for the graph structure itself,
      however. Conceptually this should be instance data for the graph
      window. Right now, however, there is only one window and only one
      graph structure. Nevertheless, we go through the GraphData(hWnd)
      function to get a pointer to the graph structure for the graph window.

*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "setedit.h"
#include "graph.h"
#include "legend.h"
// #include "valuebar.h"
#include "utils.h"   // for WindowShow
#include "grafdata.h"      // for InsertGraph, et al.


//==========================================================================//
//                                  Constants                               //
//==========================================================================//


//=============================//
// Graph Class                 //
//=============================//


TCHAR   szGraphWindowClass[] = TEXT("PerfmonGraphClass") ;
#define dwGraphClassStyle           (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS)
#define iGraphClassExtra            (0)
#define iGraphWindowExtra           (0)
#define dwGraphWindowStyle          (WS_CHILD)



//==========================================================================//
//                              Local Functions                             //
//==========================================================================//


void static OnCreate (HWND hWnd)
{  // OnCreate
    //   hWndGraphDisplay = CreateGraphDisplayWindow (hWnd) ;
    InsertGraph(0) ;
    hWndGraphLegend = CreateGraphLegendWindow (hWnd) ;
    //   hWndGraphStatus = CreateGraphStatusWindow (hWnd) ;
}  // OnCreate


void static OnPaint (HWND hWnd)
{
    HDC            hDC ;
    PAINTSTRUCT    ps ;

    hDC = BeginPaint (hWnd, &ps) ;
    EndPaint (hWnd, &ps) ;
}


void static OnSize (HWND hWnd, int xWidth, int yHeight)
{  // OnSize
    SizeGraphComponents (hWnd) ;
}  // OnSize


//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//



LRESULT
APIENTRY
GraphWndProc (
             HWND hWnd,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam)
{  // GraphWndProc
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;


    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {  // switch
        case WM_CREATE:
            OnCreate (hWnd) ;
            break ;

        case WM_LBUTTONDBLCLK:
            SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ;
            break ;

        case WM_PAINT:
            OnPaint (hWnd) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }  // switch


    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}  // GraphWndProc



BOOL GraphInitializeApplication (void)
/*
   Note:          There is no background brush set for the MainWindow
                  class so that the main window is never erased. The
                  client area of MainWindow is always covered by one
                  of the view windows. If we erase it, it would just
                  flicker needlessly.
*/
{  // GraphInitializeApplication
    BOOL           bSuccess ;
    WNDCLASS       wc ;

    //=============================//
    // Register GraphWindow class  //
    //=============================//


    wc.style         = dwGraphClassStyle ;
    wc.lpfnWndProc   = GraphWndProc ;
    wc.hInstance     = hInstance ;
    wc.cbClsExtra    = iGraphWindowExtra ;
    wc.cbWndExtra    = iGraphClassExtra ;
    wc.hIcon         = NULL ;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
    wc.hbrBackground = NULL ;                          // see note above
    wc.lpszMenuName  = NULL ;
    wc.lpszClassName = szGraphWindowClass ;

    bSuccess = RegisterClass (&wc) ;


    //=============================//
    // Register Child classes      //
    //=============================//

    //   if (bSuccess)
    //      bSuccess = GraphDisplayInitializeApplication () ;

    if (bSuccess)
        bSuccess = GraphLegendInitializeApplication () ;

    //   if (bSuccess)
    //      bSuccess = GraphStatusInitializeApplication () ;

    return (bSuccess) ;
}  // GraphInitializeApplication


HWND CreateGraphWindow (HWND hWndParent)
/*
   Effect:        Create the graph window. This window is a child of
                  hWndMain and is a container for the graph data,
                  graph label, graph legend, and graph status windows.

   Note:          We dont worry about the size here, as this window
                  will be resized whenever the main window is resized.

*/
{
    return (CreateWindow (szGraphWindowClass,       // window class
                          NULL,                     // caption
                          dwGraphWindowStyle,       // style for window
                          0, 0,                     // initial position
                          0, 0,                     // initial size
                          hWndParent,               // parent
                          NULL,                     // menu
                          hInstance,               // program instance
                          NULL)) ;                  // user-supplied data
}


void SizeGraphComponents (HWND hWnd)
/*
   Effect:        Move and show the various components of the graph to
                  fill the size (xWidth x yHeight).

   Called By:     OnSize, any other function that may remove or add one
                  of the graph components.
*/
{  // SizeGraphComponents
    RECT           rectClient ;
    int            xWidth ;
    int            yHeight ;

    GetClientRect (hWnd, &rectClient) ;
    xWidth = rectClient.right - rectClient.left ;
    yHeight = rectClient.bottom - rectClient.top ;

    // if the graph window has no size, neither will its children.
    if (!xWidth || !yHeight)
        return ;

    //=============================//
    // Update the legend window    //
    //=============================//

    MoveWindow (hWndGraphLegend,
                0, 0,
                xWidth, yHeight,
                TRUE) ;
    WindowShow (hWndGraphLegend, TRUE) ;
}  // SizeGraphComponents
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\line.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include "setedit.h"    // included by all source files
#include "line.h"       // external declarations for this file
//#include <tchar.h>      // for _tcsncpy

#include "fileutil.h"   // for FileRead, FileWrite
#include "pmemory.h"     // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"   // for UpdateSystemData, et al
#include "perfmops.h"   // for InsertLine
#include "system.h"     // for SystemAdd
#include "utils.h"
#include "counters.h"   // CounterEntry

#include <string.h>     // for strncpy
#ifdef UNICODE
    #define _tcsncpy        wcsncpy
#else
    #define _tcsncpy        strncpy
#endif

TCHAR LOCAL_SYS_CODE_NAME[] = TEXT("....") ;
#define  sizeofCodeName sizeof(LOCAL_SYS_CODE_NAME) / sizeof(TCHAR) - 1

// Local Function prototype
PLINE ReadLine (PPERFSYSTEM *ppSystem,
                PPPERFSYSTEM ppSystemFirst,
                PPERFDATA *ppPerfData,
                HANDLE hFile,
                int LineType,
                PDISKLINE  *ppDiskLine,
                DWORD *pSizeofDiskLine) ;



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


PLINE LineAllocate (void)
/*
   Effect:        Allocate and initialize a Line data structure. Lines
          are used as the primary elements of both charts and
          alerts.

          Establish any representation invariants for the Line
          type.

          Also alllocate another structure, an array of data
          elements, iNumDataValues long.
*/
{  // LineAllocate
    PLINE          pLine ;

    pLine = MemoryAllocate (sizeof (LINESTRUCT)) ;

    if (pLine) {
        //  don't need to zero these again since MemoryAllocate is using
        //  GMEM_ZEROPOINT
        //      pLine->pLineNext = NULL ;
        //      pLine->pLineCounterNext = NULL ;

        // do want to do this since (FLOAT)0.0 is not 0
        pLine->lnMinValue =
        pLine->lnMaxValue =
        pLine->lnAveValue = (FLOAT) 0.0 ;

        // we want to take 2 samples before plotting the first data
        pLine->bFirstTime = 2 ;
    }  // if

    return (pLine) ;
}  // LineAllocate


void LineFree (PLINE pLine)
{  // LineFree
    // free any memory allocated by this line
    if (pLine->lnSystemName)
        MemoryFree (pLine->lnSystemName) ;

    if (pLine->lnObjectName)
        MemoryFree (pLine->lnObjectName) ;

    if (pLine->lnCounterName)
        MemoryFree (pLine->lnCounterName) ;

    if (pLine->lnInstanceName)
        MemoryFree (pLine->lnInstanceName) ;

    if (pLine->lnParentObjName)
        MemoryFree (pLine->lnParentObjName) ;

    if (pLine->lnPINName)
        MemoryFree (pLine->lnPINName) ;

    if (pLine->lpszAlertProgram)
        MemoryFree (pLine->lpszAlertProgram) ;

    if (pLine->hPen)
        DeletePen(pLine->hPen);

    if (pLine->hBrush)
        DeletePen(pLine->hBrush);

#if 0
    if (pLine->lnValues)
        MemoryFree (pLine->lnValues) ;

    if (pLine->aiLogIndexes)
        MemoryFree (pLine->aiLogIndexes) ;
#endif

    MemoryFree (pLine) ;
}  // LineFree



void LineAppend (PPLINE ppLineFirst,
                 PLINE pLineNew)
{
    PLINE          pLine ;

    if (!*ppLineFirst)
        *ppLineFirst = pLineNew ;
    else {  // else
        for (pLine = *ppLineFirst ;
            pLine->pLineNext ;
            pLine = pLine->pLineNext)
            /* nothing */ ;
        pLine->pLineNext = pLineNew ;
    }  // else
}



BOOL LineRemove (PPLINE ppLineFirst,
                 PLINE pLineRemove)
{
    PLINE          pLine ;

    if (*ppLineFirst == pLineRemove) {
        *ppLineFirst = (*ppLineFirst)->pLineNext ;
        return (TRUE) ;
    }

    for (pLine = *ppLineFirst ;
        pLine->pLineNext ;
        pLine    =    pLine->pLineNext) {   // for
        if (pLine->pLineNext == pLineRemove) {
            pLine->pLineNext = pLineRemove->pLineNext ;
            return (TRUE) ;
        }  // if
    }  // for

    return (FALSE) ;
}  // LineRemove



int NumLines (PLINE pLineFirst)
{  // NumLines
    PLINE          pLine ;
    int            iNumLines ;

    if (!pLineFirst)
        return (0) ;


    iNumLines = 0 ;
    for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {  // for
        iNumLines++ ;
    }  // for


    return (iNumLines) ;
}  // NumLines



LPTSTR LineInstanceName (PLINE pLine)
{
    if (pLine->lnObject.NumInstances <= 0)
        return (NULL) ;
    else
        return (pLine->lnInstanceName) ;
}


LPTSTR LineParentName (PLINE pLine)
{
    if (pLine->lnObject.NumInstances <= 0)
        return (NULL) ;
    else if (pLine->lnInstanceDef.ParentObjectTitleIndex)
        return (pLine->lnPINName) ;
    else
        return (NULL) ;
}



void LineCounterAppend (PPLINE ppLineFirst,
                        PLINE pLineNew)
{
    PLINE          pLine ;

    if (!*ppLineFirst)
        *ppLineFirst = pLineNew ;
    else {  // else
        for (pLine = *ppLineFirst ;
            pLine->pLineCounterNext ;
            pLine = pLine->pLineCounterNext)
            /* nothing */ ;
        pLine->pLineCounterNext = pLineNew ;
    }  // else
}



BOOL EquivalentLine (PLINE pLine1,
                     PLINE pLine2)
{  // LineEquivalent
    return (pstrsame (pLine1->lnCounterName, pLine2->lnCounterName) &&
            pstrsame (pLine1->lnInstanceName, pLine2->lnInstanceName) &&
            pstrsame (pLine1->lnPINName, pLine2->lnPINName) &&
            pstrsame (pLine1->lnObjectName, pLine2->lnObjectName) &&
            pstrsamei (pLine1->lnSystemName, pLine2->lnSystemName)) ;
}  // LineEquivalent


PLINE FindEquivalentLine (PLINE pLineToFind,
                          PLINE pLineFirst)
{
    PLINE          pLine ;

    for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {  // for
        if (EquivalentLine (pLine, pLineToFind))
            return (pLine) ;
    }  // for

    return (NULL) ;
}  // FindEquivalentLine

// This routine is used only to read the system name from a disk string
// It is mainly for performance improvement.
LPTSTR DiskStringReadSys (PDISKSTRING pDS)
{  // DiskStringReadSys
    LPTSTR         lpszText ;
    LPTSTR         pDiskSysName ;
    int            iIndex ;
    BOOL           bLocalSysName = FALSE ;

    if (pDS->dwLength == 0) {
        return (NULL) ;
    }

    if (pDS->dwLength == sizeofCodeName) {
        // check for LOCAL_SYS_CODE_NAME
        bLocalSysName = TRUE ;
        pDiskSysName = (LPTSTR)((PBYTE) pDS + pDS->dwOffset) ;
        for (iIndex = 0 ; iIndex < sizeofCodeName; iIndex++, pDiskSysName++) {
            if (*pDiskSysName != LOCAL_SYS_CODE_NAME[iIndex]) {
                bLocalSysName = FALSE ;
                break ;
            }
        }
    }

    if (bLocalSysName) {
        lpszText =
        MemoryAllocate ((lstrlen(LocalComputerName)+1) * sizeof(TCHAR)) ;
        if (lpszText) {
            lstrcpy (lpszText, LocalComputerName) ;
        }
    } else {
        lpszText = MemoryAllocate (sizeof (TCHAR) * (pDS->dwLength + 1)) ;
        if (lpszText) {
            _tcsncpy ((WCHAR *)lpszText, (WCHAR *)((PBYTE) pDS + pDS->dwOffset),
                      pDS->dwLength) ;
        }
    }

    return (lpszText) ;
}  // DiskStringReadSys



LPTSTR DiskStringRead (PDISKSTRING pDS)
{  // DiskStringRead
    LPTSTR         lpszText ;

    if (pDS->dwLength == 0) {
        return (NULL) ;
    }

    lpszText = MemoryAllocate (sizeof (TCHAR) * (pDS->dwLength + 1)) ;
    if (!lpszText) {
        return (NULL) ;
    }

    _tcsncpy ((WCHAR *)lpszText, (WCHAR *)((PBYTE) pDS + pDS->dwOffset),
              pDS->dwLength) ;

    return (lpszText) ;
}  // DiskStringRead


int DiskStringLength (LPTSTR lpszText)
{
    if (!lpszText)
        return (0) ;
    else
        return (lstrlen (lpszText)) ;
}

PBYTE DiskStringCopy (PDISKSTRING pDS, LPTSTR lpszText, PBYTE pNextFree)
{
    if (!lpszText) {
        pDS->dwOffset = 0 ;
        pDS->dwLength = 0 ;
        return (pNextFree) ;
    } else {
        pDS->dwOffset = (DWORD)(pNextFree - (PBYTE) pDS) ;
        pDS->dwLength = DiskStringLength (lpszText) ;
        _tcsncpy ((WCHAR *)pNextFree, (WCHAR *)lpszText, pDS->dwLength) ;
        return (pNextFree + pDS->dwLength * sizeof(TCHAR)) ;
    }
}  // DiskStringCopy


void CounterName (PPERFSYSTEM pSystem,
                  PPERFCOUNTERDEF pCounter,
                  LPTSTR lpszCounter)
{  // CounterName
    //!!   strclr (lpszCounter) ;
    lpszCounter [0] = TEXT('\0') ;
    QueryPerformanceName (pSystem,
                          pCounter->CounterNameTitleIndex,
                          0, 256,
                          lpszCounter,
                          FALSE) ;
}  // CounterName



PERF_OBJECT_TYPE UNALIGNED *
LineFindObject (PPERFSYSTEM pSystem,
                PPERFDATA pPerfData,
                PLINE pLine)
/*
   Effect:        Set the lnObject field of pLine to the object with the
          name of lnObjectName, and return TRUE. Return FALSE if
          there is no such object.
*/
{  // LineFindObject
    PERF_OBJECT_TYPE UNALIGNED *pObject ;

    pObject = (PERF_OBJECT_TYPE UNALIGNED *)GetObjectDefByName (pSystem, pPerfData, pLine->lnObjectName) ;

    if (pObject) {
        pLine->lnObject = *pObject ;
        return (pObject) ;
    } else
        return (NULL) ;
}  // LineFindObject



PPERFCOUNTERDEF LineFindCounter (PPERFSYSTEM pSystem,
                                 PERF_OBJECT_TYPE  UNALIGNED *pObject,
                                 PPERFDATA pPerfData,
                                 PLINE pLine)
{  // LineFindCounter
    UINT               i ;
    PPERFCOUNTERDEF   pCounter ;
    TCHAR             szCounter [256] ;

    for (i = 0, pCounter = FirstCounter (pObject) ;
        i < pObject->NumCounters ;
        i++, pCounter = NextCounter (pCounter)) {  // for
        CounterName (pSystem, pCounter, szCounter) ;
        if (strsame (szCounter, pLine->lnCounterName)) {
            pLine->lnCounterDef = *pCounter ;
            return (pCounter) ;
        }  // if
    }  // for

    return (NULL) ;
}  // LineFindCounter


PPERFINSTANCEDEF LineFindInstance (PPERFDATA pPerfData,
                                   PERF_OBJECT_TYPE UNALIGNED *pObject,
                                   PLINE pLine)
{  // LineFindInstance


    PPERFINSTANCEDEF  pInstance = NULL ;

    if ((pObject->NumInstances > 0) && pLine->lnInstanceName) {
        // instances exist, find the right one

        if (pLine->lnUniqueID != PERF_NO_UNIQUE_ID) {
            pInstance = GetInstanceByUniqueID(pObject, pLine->lnUniqueID,
                                              pLine->dwInstanceIndex) ;
        } else {
            pInstance = GetInstanceByName(pPerfData, pObject,
                                          pLine->lnInstanceName, pLine->lnPINName,
                                          pLine->dwInstanceIndex) ;
        }
    }

    if (pInstance) {
        pLine->lnInstanceDef = *pInstance ;
    }

    return (pInstance) ;
}  // LineFindInstance




void ReadLines (HANDLE hFile,
                DWORD dwNumLines,
                PPPERFSYSTEM ppSystemFirst,
                PPLINE ppLineFirst,
                int LineType)
{
    DWORD          i ;
    PPERFDATA      pPerfData ;
    PLINE          pLine ;
    PPERFSYSTEM    pSystem ;
    PDISKLINE      pDiskLine = NULL ;
    DWORD          SizeofDiskLine = 0 ;  // bytes in pDiskLine


    pPerfData = AllocatePerfData () ;
    pSystem = *ppSystemFirst ;

#if 0
    if (!pSystem) {
        pSystem = SystemAdd (ppSystemFirst, LocalComputerName, NULL) ;
        pSystem = *ppSystemFirst ; //!!
    }

    UpdateSystemData (pSystem, &pPerfData) ;
#endif
    pDiskLine = MemoryAllocate (FilePathLen) ;
    if (!pDiskLine) {
        // no memory to begin with, forget it
        DlgErrorBox (hWndMain, ERR_NO_MEMORY) ;
        return ;
    }
    SizeofDiskLine = FilePathLen ;

    for (i = 0 ;
        i < dwNumLines ;
        i++) {
        pLine = ReadLine (&pSystem, ppSystemFirst, &pPerfData, hFile,
                          LineType, &pDiskLine, &SizeofDiskLine) ;
        if (pLine)
            InsertLine (pLine)  ;
    }

    if (pDiskLine) {
        MemoryFree (pDiskLine);
    }

    MemoryFree (pPerfData) ;
}  // ReadLines



void LineSetCounter (PLINE pLine,
                     PPERFSYSTEM pSystem,
                     PPERFCOUNTERDEF pCounter,
                     PPERFINSTANCEDEF pInstance)
/*
   Effect:        Set the counter-specific portions of pLine to point to
          the desired counter.

   Called By:     AddLine, ReadLine.
*/
{
}


PLINE ReadLine (PPERFSYSTEM *ppSystem,
                PPPERFSYSTEM ppSystemFirst,
                PPERFDATA *ppPerfData,
                HANDLE hFile,
                int LineType,
                PDISKLINE  *ppDiskLine,
                DWORD *pSizeofDiskLine)


/*
   Effect:        Read in a line from the file hFile, at the current file
          position.

   Internals:     The very first characters are a line signature, then a
          length integer. If the signature is correct, then allocate
          the length amount, and work with that.
*/
{  // ReadLine
    PLINE             pLine ;

    struct {
        DWORD             dwSignature ;
        DWORD             dwLength ;
    } LineHeader ;

    PERF_OBJECT_TYPE  UNALIGNED *pObject ;
    PPERFCOUNTERDEF   pCounter ;
    PDISKLINE         pDiskLine ;    // Local copy of the pointer

#ifdef   KEEP_IT
    int               i ;
    int               iCounterIndex ;
    int               j ;
    PERF_COUNTER_BLOCK *pCounterBlock ;
#endif

    PPERFINSTANCEDEF  pInstance ;
    //   PPERFINSTANCEDEF  pInstanceParent ;
    //   TCHAR          szInstanceParent [256] ;
    //   TCHAR          szObjectParent [PerfObjectLen] ;

    pLine = NULL ;


    //=============================//
    // read and compare signature  //
    //=============================//

    if (!FileRead (hFile, &LineHeader, sizeof (LineHeader)))
        return (NULL) ;


    if (LineHeader.dwSignature != dwLineSignature ||
        LineHeader.dwLength == 0) {
        SetLastError (ERROR_BAD_FORMAT) ;
        return (NULL) ;
    }


    //=============================//
    // read and allocate length    //
    //=============================//


    //   if (!FileRead (hFile, &dwLength, sizeof (dwLength)) || dwLength == 0)
    //      return (NULL) ;


    // check if we need a bigger buffer,
    // normally, it should be the same except the first time...
    if (LineHeader.dwLength > *pSizeofDiskLine) {
        if (*ppDiskLine) {
            // free the previous buffer
            MemoryFree (*ppDiskLine);
            *pSizeofDiskLine = 0 ;
        }

        // re-allocate a new buffer
        *ppDiskLine = (PDISKLINE) MemoryAllocate (LineHeader.dwLength) ;
        if (!(*ppDiskLine)) {
            // no memory, should flag an error...
            return (NULL) ;
        }
        *pSizeofDiskLine = LineHeader.dwLength ;
    }

    pDiskLine = *ppDiskLine ;


    //=============================//
    // copy diskline, alloc line   //
    //=============================//

    if (!FileRead (hFile, pDiskLine, LineHeader.dwLength))
        return (NULL) ;


    pLine = LineAllocate () ;
    if (!pLine) {
        return (NULL) ;
    }

    pLine->iLineType = pDiskLine->iLineType ;


    //=============================//
    // convert system information  //
    //=============================//

    pLine->lnSystemName = DiskStringReadSys (&(pDiskLine->dsSystemName)) ;
    if (!pLine->lnSystemName)
        goto ErrorBadLine ;

    if (!*ppSystem || !strsamei (pLine->lnSystemName, (*ppSystem)->sysName)) {
        *ppSystem = SystemAdd (ppSystemFirst, pLine->lnSystemName, NULL) ;
        if (!*ppSystem) {
            SetLastError (ERROR_BAD_FORMAT) ;
            goto ErrorBadLine ;
        }

        UpdateSystemData (*ppSystem, ppPerfData) ;
    }  // if

    //=============================//
    // convert object information  //
    //=============================//

    pLine->lnObjectName = DiskStringRead (&(pDiskLine->dsObjectName)) ;
    if (!pLine->lnObjectName)
        goto ErrorBadLine ;

    pObject = LineFindObject (*ppSystem, *ppPerfData, pLine) ;
    if (!pObject) {
        SetLastError (ERROR_BAD_FORMAT) ;
        goto ErrorBadLine ;
    }

    //=============================//
    // convert counter information //
    //=============================//

    pLine->lnCounterName = DiskStringRead (&(pDiskLine->dsCounterName)) ;
    if (!pLine->lnCounterName)
        goto ErrorBadLine ;

    pCounter = LineFindCounter (*ppSystem, pObject, *ppPerfData, pLine) ;
    if (!pCounter) {
        SetLastError (ERROR_BAD_FORMAT) ;
        goto ErrorBadLine ;
    }

    //=============================//
    // convert instance info       //
    //=============================//

    pLine->lnUniqueID = pDiskLine->dwUniqueID ;
    pLine->lnInstanceName = DiskStringRead (&(pDiskLine->dsInstanceName)) ;
    pLine->lnPINName = DiskStringRead (&(pDiskLine->dsPINName)) ;

    if (pLine->lnObject.NumInstances > 0 &&
        pLine->lnInstanceName == NULL) {
        goto ErrorBadLine ;
    }

    pInstance = LineFindInstance (*ppPerfData, pObject, pLine) ;

    if (pInstance) {
        pLine->lnParentObjName = DiskStringRead (&(pDiskLine->dsParentObjName)) ;
    } else {
        pLine->bUserEdit = TRUE ;
        pLine->lnParentObjName = DiskStringRead (&(pDiskLine->dsParentObjName)) ;
    }



    //=============================//
    // convert chart information   //
    //=============================//

    if (LineType == IDM_VIEWCHART) {
        pLine->Visual = pDiskLine->Visual ;
        pLine->hPen = CreatePen (pLine->Visual.iStyle,
                                 pLine->Visual.iWidth,
                                 pLine->Visual.crColor) ;
        pLine->iScaleIndex = pDiskLine->iScaleIndex ;
        pLine->eScale = pDiskLine->eScale ;
    }


    //=============================//
    // convert alert information   //
    //=============================//

    if (LineType == IDM_VIEWALERT) {
        pLine->Visual = pDiskLine->Visual ;
        pLine->hBrush = CreateSolidBrush (pLine->Visual.crColor) ;
        pLine->bAlertOver = pDiskLine->bAlertOver ;
        pLine->eAlertValue = pDiskLine->eAlertValue ;
        pLine->lpszAlertProgram = DiskStringRead (&(pDiskLine->dsAlertProgram)) ;
        pLine->bEveryTime = pDiskLine->bEveryTime ;
        pLine->bAlerted = FALSE ;
    }


    //=============================//
    // Convert the nasty stuff     //
    //=============================//


    pLine->lnCounterType = pCounter->CounterType;
    pLine->lnCounterLength = pCounter->CounterSize;


    // we don't need these line info since we will get it
    // from the first couple clock ticks...
    // If we decide to keep these line, just define KEEP_IT
#ifdef   KEEP_IT
    pLine->lnOldTime = (*ppPerfData)->PerfTime ;
    pLine->lnNewTime = (*ppPerfData)->PerfTime ;
    pLine->lnOldTime100Ns = (*ppPerfData)->PerfTime100nSec ;
    pLine->lnNewTime100Ns = (*ppPerfData)->PerfTime100nSec;

    pLine->lnPerfFreq = (*ppPerfData)->PerfFreq ;

    for (j = 0 ; j < 2 ; j++) {
        pLine->lnaCounterValue[j].LowPart = 0 ;
        pLine->lnaCounterValue[j].HighPart = 0 ;
    }


    if (pObject->NumInstances > 0 && pInstance) {
        pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pInstance +
                                                 pInstance->ByteLength);
    } else {
        pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pObject +
                                                 pObject->DefinitionLength);
    }

    if (pLine->lnCounterLength <= 4)
        pLine->lnaOldCounterValue[0].LowPart =
        * ( (DWORD FAR *) ( (PBYTE)pCounterBlock +
                            pCounter[0].CounterOffset));
    else {
        pLine->lnaOldCounterValue[0] =
        * ( (LARGE_INTEGER *) ( (PBYTE)pCounterBlock +
                                pCounter[0].CounterOffset));
    }

    // Get second counter, only if we are not at
    // the end of the counters; some computations
    // require a second counter

    iCounterIndex = CounterIndex (pCounter, pObject) ;
    if ((UINT) iCounterIndex < pObject->NumCounters - 1 &&
        iCounterIndex != -1) {
        if (pLine->lnCounterLength <= 4)
            pLine->lnaOldCounterValue[1].LowPart =
            * ( (DWORD FAR *) ( (PBYTE)pCounterBlock +
                                pCounter[1].CounterOffset));
        else
            pLine->lnaOldCounterValue[1] =
            * ( (LARGE_INTEGER *) ( (PBYTE)pCounterBlock +
                                    pCounter[1].CounterOffset));
    }

    //   pLine->valNext = CounterFuncEntry ;
    pLine->valNext = CounterEntry ;

    pLine->lnaOldCounterValue[0] = pLine->lnaCounterValue[0];
    pLine->lnaOldCounterValue[1] = pLine->lnaCounterValue[1];
#endif   // KEEP_IT


    //   pLine->valNext = CounterFuncEntry ;
    pLine->valNext = CounterEntry ;

    return (pLine) ;


    ErrorBadLine:
    if (!pLine) {
        LineFree (pLine) ;
    }
    return (NULL) ;
}  // ReadLine




BOOL WriteLine (PLINE pLine,
                HANDLE hFile)
{  // WriteLine
    PDISKLINE      pDiskLine ;
    DWORD          dwSignature ;
    DWORD          dwLength ;
    PBYTE          pNextFree ;
    BOOL           bConvertName ;

    //=============================//
    // write signature             //
    //=============================//

    dwSignature = dwLineSignature ;
    if (!FileWrite (hFile, &dwSignature, sizeof (dwSignature)))
        return (FALSE) ;

    if (IsLocalComputer(pLine->lnSystemName)) {
        bConvertName = TRUE ;
    } else {
        bConvertName = FALSE ;
    }

    //=============================//
    // compute and allocate length //
    //=============================//


    dwLength = sizeof (DISKLINE) ;
    if (bConvertName) {
        dwLength += DiskStringLength (LOCAL_SYS_CODE_NAME) * sizeof (TCHAR) ;
    } else {
        dwLength += DiskStringLength (pLine->lnSystemName) * sizeof (TCHAR) ;
    }
    dwLength += DiskStringLength (pLine->lnObjectName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnCounterName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnInstanceName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnPINName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lnParentObjName) * sizeof (TCHAR) ;
    dwLength += DiskStringLength (pLine->lpszAlertProgram) * sizeof (TCHAR) ;


    if (!FileWrite (hFile, &dwLength, sizeof (dwLength)))
        return (FALSE) ;

    pDiskLine = (PDISKLINE) MemoryAllocate (dwLength) ;
    if (!pDiskLine)
        return (FALSE) ;

    pNextFree = (PBYTE) pDiskLine + sizeof (DISKLINE) ;


    //=============================//
    // convert fixed size fields   //
    //=============================//

    pDiskLine->iLineType = pLine->iLineType ;
    pDiskLine->dwUniqueID = pLine->lnUniqueID ;
    pDiskLine->Visual = pLine->Visual ;
    pDiskLine->iScaleIndex = pLine->iScaleIndex ;
    pDiskLine->eScale = pLine->eScale ;
    pDiskLine->bAlertOver = pLine->bAlertOver ;
    pDiskLine->eAlertValue = pLine->eAlertValue ;
    pDiskLine->bEveryTime = pLine->bEveryTime ;


    //=============================//
    // copy disk string fields     //
    //=============================//

    if (bConvertName) {
        pNextFree = DiskStringCopy (&pDiskLine->dsSystemName,
                                    LOCAL_SYS_CODE_NAME,
                                    pNextFree) ;
    } else {
        pNextFree = DiskStringCopy (&pDiskLine->dsSystemName,
                                    pLine->lnSystemName,
                                    pNextFree) ;
    }

    pNextFree = DiskStringCopy (&pDiskLine->dsObjectName,
                                pLine->lnObjectName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsCounterName,
                                pLine->lnCounterName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsParentObjName,
                                pLine->lnParentObjName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsInstanceName,
                                pLine->lnInstanceName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsPINName,
                                pLine->lnPINName,
                                pNextFree) ;

    pNextFree = DiskStringCopy (&pDiskLine->dsAlertProgram,
                                pLine->lpszAlertProgram,
                                pNextFree) ;



    FileWrite (hFile, pDiskLine, dwLength) ;
    MemoryFree (pDiskLine) ;
    return (TRUE) ;

    //ErrorBadLine:
    MemoryFree (pDiskLine) ;
    return (FALSE) ;
}  // WriteLine


// we are not doing printing.  In case we need this
// later, then define DO_PRINTING
#ifdef DO_PRINTING
int aiPrinterLineStyles [] =
{
    PS_SOLID,
    PS_DASH,
    PS_DOT,
    PS_DASHDOT,
    PS_DASHDOTDOT
} ;
    #define NumPrinterLineStyles()   \
   (sizeof (aiPrinterLineStyles) / sizeof (aiPrinterLineStyles [0]))


COLORREF acrPrinterLineColors [] =
{
    RGB (192, 192, 192),
    RGB (128, 128, 128),
    RGB (64, 64, 64),
    RGB (0, 0, 0)
}  ;


    #define NumPrinterLineColors()   \
   (sizeof (acrPrinterLineColors) / sizeof (acrPrinterLineColors [0]))
#endif      // DO_PRINTING


HPEN LineCreatePen (HDC hDC,
                    PLINEVISUAL pVisual,
                    BOOL bForPrint)
{  // LineCreatePen
    HPEN        hPen ;

    hPen = CreatePen (pVisual->iStyle,
                      pVisual->iWidth,
                      pVisual->crColor) ;

    return (hPen) ;
}  // LineCreatePen



VOID FreeLines (PLINESTRUCT pLineFirst)
{  // FreeLines
    PLINESTRUCT    pLine,next_line;


    for (pLine = pLineFirst; pLine; pLine = next_line) {
        next_line = pLine->pLineNext;
        LineFree (pLine) ;
    }
}  // FreeLines
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\owndraw.h ===
#define DIWindow(lpDI)              \
   (lpDI->hwndItem)

#define DIIndex(lpDI)               \
   (lpDI->itemID)

#define DIEntire(lpDI)              \
   (lpDI->itemAction & ODA_DRAWENTIRE)

#define DIFocusChanged(lpDI)        \
   (lpDI->itemAction & ODA_FOCUS)

#define DISelectionChanged(lpDI)    \
   (lpDI->itemAction & ODA_SELECT)

#define DISelected(lpDI)            \
   (lpDI->itemState & ODS_SELECTED)

#define DIDisabled(lpDI)            \
   (lpDI->itemState & ODS_DISABLED)

#define DIFocus(lpDI)               \
   (lpDI->itemState & ODS_FOCUS)




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\legend.h ===
//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szGraphLegendClass          TEXT("PerfmonGraphLegendClass")
#define szGraphLegendClassA         "PerfmonGraphLegendClass"


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



void ClearLegend (HWND hWndLegend) ;

BOOL GraphLegendInitializeApplication (void) ;

HWND CreateGraphLegendWindow (HWND hWndGraph) ;

int LegendMinHeight (HWND hWnd) ;

int LegendMinWidth (HWND hWnd) ;


void LegendDeleteItem (HWND hWndLegend, 
                       PLINE pLine) ;


int LegendHeight (HWND hWnd, int yGraphHeight) ;


BOOL LegendAddItem (HWND hWndGraph,
                    PLINESTRUCT pLine) ;


PLINE LegendCurrentLine (HWND hWndLegend) ;


int LegendNumItems (HWND hWndLegend) ;


void LegendSetSelection (HWND hWndLegend, int iIndex) ;


int LegendFullHeight (HWND hWnd, HDC hDC) ;


void PrintLegend (HDC hDC, PGRAPHSTRUCT pGraph, HWND hWndLegend,
                  RECT rectLegend) ;

void LegendSetRedraw (HWND hWndLegend, BOOL bRedraw) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\perfmrc.h ===
//=============================//
// ID Macro Definition         //
//=============================//


#ifdef RC_INVOKED
   #define ID(id) id
#else
   #define ID(id) MAKEINTRESOURCE (id)
#endif


//=============================//
// Resource IDs                //
//=============================//


#define idMenuChart                 ID (2001)
#define idMenuAlert                 ID (2002)
#define idMenuLog                   ID (2003)
#define idMenuReport                ID (2004)


#define idAccelerators              ID (4001)


#define idDlgLogDisplay             ID (4002)
#define idDlgLogOptions             ID (4003)
#define idDlgAddLog                 ID (4004)
#define idDlgAbort                  ID (4005)
#define idDlgTimeframe              ID (4006)
#define idDlgAlertDisplay           ID (4007)
#define idDlgAddLine                ID (4008)
#define idDlgChartOptions           ID (4009)
#define idDlgAlertOptions           ID (4010)
#define idDlgAddBookmark            ID (4011)
#define idDlgReportOptions          ID (4012)
#define idDlgDisplayOptions         ID (4013)
#define idDlgDataSource             ID (4014)
#define idDlgAbout                  ID (4015)
#define idDlgExportOptions          ID (4016)
#define idDlgChooseComputer         ID (4017)


#define idIcon                      ID (5001)

#define idBitmapToolbar             101
#define idBitmapAlertStatus         ID (6002)
#define idBitmapLogStatus           ID (6003)


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\init.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#include <string.h>     // strupr
#include <stdio.h>      // for sprintf.


#include "setedit.h"
#include "init.h"       // external declarations for this file

#include "command.h"    // for ViewChart
#include "grafdata.h"   // for QuerySaveChart
#include "graph.h"      // for GraphInitializeApplication
#include "legend.h"     // for LegendInitializeApplication
#include "perfdata.h"   // for PerfDataInitializeInstance
#include "perfmops.h"   // for OpenFileHandler, for now
#include "status.h"     // for StatusInitializeApplication
#include "registry.h"   // for Load/SaveMainWindowPlacement
#include "toolbar.h"    // for ToolbarInitializeApplication
#include "utils.h"
#include "fileopen.h"   // for FileOpen
#include "pmemory.h"    // for MemoryFree

extern   TCHAR          DefaultLangId[] ;
extern   TCHAR          EnglishLangId[] ;

static  LPSTR           lpszCommandLine;

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define szPerfmonMainClass TEXT("PerfmonMainClass")

HHOOK   lpMsgFilterProc ;


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//
static
LONG
EnablePrivilege (
	IN	LPTSTR	szPrivName
)
{
    LUID SePrivNameValue;
    TOKEN_PRIVILEGES tkp;

    HANDLE hToken = NULL;

    /* Retrieve a handle of the access token. */

    if (!OpenProcessToken(GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken)) {
		goto Exit_Point;
    }

    /*
     * Enable the privilege by name and get the ID
     */

    if (!LookupPrivilegeValue((LPTSTR) NULL,
            szPrivName,
            &SePrivNameValue)) {
		goto Exit_Point;
    }

    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = SePrivNameValue;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(hToken,
        FALSE,
        &tkp,
        sizeof(TOKEN_PRIVILEGES),
        (PTOKEN_PRIVILEGES) NULL,
        (PDWORD) NULL);

    /* The return value of AdjustTokenPrivileges be texted. */

Exit_Point:

	if (hToken != NULL) CloseHandle (hToken);
    return GetLastError();

}


void GetScalesFonts (void)
   {
   LOGFONT        lf ;

   memset (&lf, 0, sizeof (lf)) ;

   lstrcpy (lf.lfFaceName, szScalesFontFace) ;
   lf.lfHeight = iScalesFontHeight ;
   lf.lfWeight = FW_REGULAR ;

   hFontScales = CreateFontIndirect (&lf) ;

   lf.lfWeight = FW_BOLD ;
   hFontScalesBold = CreateFontIndirect (&lf) ;
   }


BOOL InitializeSystemValues (void)
/*
   Effect:        Read and store in variables the various system values,
                  such as the width and height of the screen and icons,
                  the width of scroll bars, etc.

   Called By:     PerfmonInitialize only.

   Returns:       Whether this function was successful in getting all
                  needed system values.
*/
   {  // InitializeSystemValues
   xScreenWidth =  GetSystemMetrics (SM_CXSCREEN) ;
   yScreenHeight = GetSystemMetrics (SM_CYSCREEN) ;

   xBorderWidth = GetSystemMetrics (SM_CXBORDER) ;
   yBorderHeight = GetSystemMetrics (SM_CYBORDER) ;

   xScrollWidth = GetSystemMetrics (SM_CXVSCROLL) ;
   yScrollHeight = GetSystemMetrics (SM_CYHSCROLL) ;

   xScrollThumbWidth = GetSystemMetrics (SM_CXHTHUMB) ;
   yScrollThumbHeight = GetSystemMetrics (SM_CYVTHUMB) ;

   xDlgBorderWidth = GetSystemMetrics (SM_CXDLGFRAME) ;
   yDlgBorderHeight = GetSystemMetrics (SM_CYDLGFRAME) ;

   MinimumSize = yScrollHeight +
                 GetSystemMetrics (SM_CYMENU) +
                 GetSystemMetrics (SM_CYCAPTION) ;

   //================================================================//
   // create all the brushes and pens for performance improvement    //
   //================================================================//
   CreatePerfmonSystemObjects () ;
   hWhitePen = CreatePen (PS_SOLID, 3, crWhite) ;

   return (TRUE) ;
   }  // InitializeSystemValues


BOOL InitializeApplication (void)
/*
   Effect:        Perform all initializations required for the FIRST
                  instance of the Perfmon application. In particular,
                  register all of Perfmon's window classes.

   Note:          There is no background brush set for the MainWindow
                  class so that the main window is never erased. The
                  client area of MainWindow is always covered by one
                  of the view windows. If we erase it, it would just
                  flicker needlessly.

   Called By:     PerfmonInitialize only.

   Returns:       Whether this function was successful in initializing.
*/
   {  // InitializeApplication
   BOOL           bSuccess ;
   WNDCLASS       wc ;
   TCHAR          LocalHelpFileName [ShortTextLen] ;
   LPTSTR         pFileName ;

   hIcon = LoadIcon (hInstance, idIcon) ;

   //=============================//
   // Register Main window class  //
   //=============================//

   wc.style         = CS_DBLCLKS | CS_BYTEALIGNCLIENT;
   wc.lpfnWndProc   = (WNDPROC) MainWndProc;
   wc.hInstance     = hInstance;
   wc.cbClsExtra    = 0 ;
   wc.cbWndExtra    = 0;
   wc.hIcon         = hIcon ;
   wc.hCursor       = LoadCursor(NULL, IDI_APPLICATION);
   wc.hbrBackground = NULL ;                             // see note above
   wc.lpszMenuName  = idMenuChart ;
   wc.lpszClassName = szPerfmonMainClass ;

   bSuccess = RegisterClass (&wc) ;

   //=============================//
   // Register Abstract "Systems" //
   //=============================//
   hbLightGray = GetStockObject (LTGRAY_BRUSH) ;

   if (bSuccess)
      bSuccess = StatusInitializeApplication () ;

   if (bSuccess)
      bSuccess = GraphInitializeApplication () ;

   return (bSuccess) ;
   }  // InitializeApplication



BOOL InitializeInstance (int nCmdShow, LPCSTR lpszCmdLine)
/*
   Effect:        Perform all initializations required for EACH instance
                  of the Perfmon application. In particular, create all
                  of Perfmon's initial windows, and perform any other
                  initializations except registering classes (done in
                  InitializeApplication).

   Called By:     PerfmonInitialize only.

   Note:          This function has multiple return points.

   Returns:       Whether this function was successful in initalizing.
*/
   {  // InitializeInstance
   DWORD          ComputerNameLength;
   TCHAR          szApplication [WindowCaptionLen] ;

   // enable privileges needed to profile system
   // if this fails, that's ok for now.

   EnablePrivilege (SE_SYSTEM_PROFILE_NAME);    // to access perfdata
   EnablePrivilege (SE_INC_BASE_PRIORITY_NAME); // to raise priority

   //=============================//
   // Set Priority high           //
   //=============================//

   SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS) ;
   SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST) ;

   //=============================//
   // Load Resources              //
   //=============================//

   GetScalesFonts () ;

   hMenuChart = LoadMenu (hInstance, idMenuChart) ;

   hAccelerators = LoadAccelerators (hInstance, idAccelerators) ;


   //=============================//
   // Initialize Systems          //
   //=============================//

   iLanguage = GetUserDefaultLangID() ;
   iEnglishLanguage = MAKELANGID (LANG_ENGLISH, LANG_NEUTRAL) ;
   TSPRINTF (DefaultLangId, TEXT("%03x"), iLanguage) ;
   TSPRINTF (EnglishLangId, TEXT("%03x"), iEnglishLanguage) ;

   // GetComputerName returns the name without the "\\" prefix. We add
   // the prefix before even calling the routine. This is so that all our
   // computer names have the prefix and are therefore compatible with
   // I_SetSystemFocus (see perfmops.c).

   ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
   lstrcpy (LocalComputerName, szComputerPrefix) ;
   GetComputerName (LocalComputerName + lstrlen (szComputerPrefix),
                    &ComputerNameLength);

   PerfDataInitializeInstance () ;

   //=============================//
   // Create Window               //
   //=============================//

   StringLoad (IDS_APPNAME, szApplication) ;
   hWndMain = CreateWindow (szPerfmonMainClass,
                            szApplication,
  	                    	    WS_OVERLAPPEDWINDOW | WS_BORDER,
                     		 CW_USEDEFAULT, CW_USEDEFAULT,
                     		 CW_USEDEFAULT, CW_USEDEFAULT,
		                      NULL,
                            NULL,
                            NULL,
                            NULL);

   if (!hWndMain)
      return (FALSE) ;

   ViewChart (hWndMain) ;

   LoadMainWindowPlacement (hWndMain) ;

   return (TRUE) ;
   }  // InitializeInstance


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


BOOL PerfmonInitialize (HINSTANCE hCurrentInstance,
                        HINSTANCE hPrevInstance,
                        LPCSTR lpszCmdLine,
                        int nCmdShow)
/*
   Effect:        Performa all initializations required when Perfmon is
                  started. In particular, initialize all "systems", register
                  all window classes, create needed windows, read in and
                  process font and Perfmon lists.

   Called By:     WinMain only, at the start of the application.

   Assert:        There are no other instances of Perfmon currently
                  executing.

   Returns:       Whether initialization was successful. If this function
                  returns FALSE, Perfmon should exit immediately.

   Internals:     The bSuccess variable is used to conditionalize each
                  successive initialization step.
*/
   {  // PerfmonInitialize
   BOOL           bSuccess ;
   TCHAR          szFilePath [FilePathLen + 1] ;
   LPTSTR         pFileNameStart ;
   HANDLE         hFindFile ;
   WIN32_FIND_DATA FindFileInfo ;
   CHAR           QuoteChar ;
   LPSTR          pCmdLine ;
   int            NameOffset ;


   hInstance = hCurrentInstance ;
   bSuccess = InitializeSystemValues () ;

   if (bSuccess && !hPrevInstance)
      bSuccess = InitializeApplication () ;

   if (bSuccess)
      bSuccess = InitializeInstance (nCmdShow, lpszCmdLine) ;

   if (bSuccess)
      {

      if (strempty (lpszCmdLine))
         StringLoad (IDS_DEFAULTPATH, szFilePath) ;
      else
         {
         // check for single or double quote
         QuoteChar = *lpszCmdLine ;
         if (QuoteChar == '\'' || QuoteChar == '\"')
            {
            lpszCmdLine++ ;

            // remove the matching QuoteChar if found
            pCmdLine = (LPSTR) lpszCmdLine ;
            while (*pCmdLine != '\0')
               {
               if (*pCmdLine == QuoteChar)
                  {
                  *pCmdLine = '\0' ;
                  break ;
                  }
               else
                  {
                  pCmdLine++ ;
                  }
               }
            }

         // convert the LPSTR to LPTSTR

         mbstowcs (szFilePath, lpszCmdLine, strlen(lpszCmdLine) + 1) ;

         pFileNameStart = ExtractFileName (szFilePath) ;
         NameOffset = (int)(pFileNameStart - szFilePath) ;

         // convert short filename to long NTFS filename if necessary
         hFindFile = FindFirstFile (szFilePath, &FindFileInfo) ;
         if (hFindFile && hFindFile != INVALID_HANDLE_VALUE)
            {
            // append the file name back to the path name
            lstrcpy (&szFilePath[NameOffset], FindFileInfo.cFileName) ;
            FindClose (hFindFile) ;
            }
         }

//      OpenFileHandler (hWndMain, szFilePath) ;
      FileOpen (hWndMain, (int)0, (LPTSTR)szFilePath) ;
      PrepareMenu (GetMenu (hWndMain));
      }

   return (bSuccess) ;
   }  // PerfmonInitialize



void PerfmonClose (HWND hWndMain)
   {

   // reset all views - will free all systems as well
   ResetGraphView (hWndGraph) ;

   // close the local machine
   if (bCloseLocalMachine)
      {
      RegCloseKey (HKEY_PERFORMANCE_DATA) ;
      }


   // free all the filenames
   if (pChartFullFileName)
      {
      MemoryFree (pChartFullFileName) ;
      pChartFullFileName = NULL ;
      }

   // free all the GDI resources
   DeletePen (hWhitePen) ;
   DeletePerfmonSystemObjects () ;

//   SaveMainWindowPlacement (hWndMain) ;
   DestroyWindow (hWndMain) ;
   }  // PerfmonClose


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\pmhelpid.h ===
/*****************************************************************************
 *
 *  PMHelpID.h -  This file contains meun and dialogs ids for context-sensitive
 *                help for Performance Monitor.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992 Microsoft Corporation
 *
 *  Author: Hon-Wah Chan
 *
 *          [5-Oct-1992]
 *
 *
 ****************************************************************************/



//=============================//
// "File" Menu IDs             //
//=============================//


#define HC_PM_MENU_FILENEWCHART            101
#define HC_PM_MENU_FILEOPENCHART           102
#define HC_PM_MENU_FILESAVECHART           103
#define HC_PM_MENU_FILESAVEASCHART         104
#define HC_PM_MENU_FILEEXPORTCHART         105

#define HC_PM_MENU_FILENEWALERT            106
#define HC_PM_MENU_FILEOPENALERT           107
#define HC_PM_MENU_FILESAVEALERT           108
#define HC_PM_MENU_FILESAVEASALERT         109
#define HC_PM_MENU_FILEEXPORTALERT         110

#define HC_PM_MENU_FILENEWLOG              111
#define HC_PM_MENU_FILEOPENLOG             112
#define HC_PM_MENU_FILESAVELOG             113
#define HC_PM_MENU_FILESAVEASLOG           114
#define HC_PM_MENU_FILEEXPORTLOG           115

#define HC_PM_MENU_FILENEWREPORT           116
#define HC_PM_MENU_FILEOPENREPORT          117
#define HC_PM_MENU_FILESAVEREPORT          118
#define HC_PM_MENU_FILESAVEASREPORT        119
#define HC_PM_MENU_FILEEXPORTREPORT        120

#define HC_PM_MENU_FILESAVEWORKSPACE       121
#define HC_PM_MENU_FILEEXIT                127
#define HC_NTPM_MENU_FILEEXIT              128

//=============================//
// "Edit" Menu IDs             //
//=============================//


#define HC_PM_MENU_EDITADDCHART            201
#define HC_PM_MENU_EDITMODIFYCHART         202
#define HC_PM_MENU_EDITCLEARCHART          203
#define HC_PM_MENU_EDITDELETECHART         204

#define HC_PM_MENU_EDITADDALERT            205
#define HC_PM_MENU_EDITMODIFYALERT         206
#define HC_PM_MENU_EDITCLEARALERT          207
#define HC_PM_MENU_EDITDELETEALERT         208

#define HC_PM_MENU_EDITADDLOG              209
#define HC_PM_MENU_EDITCLEARLOG            211
#define HC_PM_MENU_EDITDELETELOG           212

#define HC_PM_MENU_EDITADDREPORT           213
#define HC_PM_MENU_EDITCLEARREPORT         215
#define HC_PM_MENU_EDITDELETEREPORT        216

#define HC_PM_MENU_EDITTIMEWINDOW          217


//=============================//
// "View" Menu IDs             //
//=============================//

#define HC_PM_MENU_VIEWCHART               301
#define HC_PM_MENU_VIEWALERT               302
#define HC_PM_MENU_VIEWLOG                 303
#define HC_PM_MENU_VIEWREPORT              304


//=============================//
// "Options" Menu IDs          //
//=============================//


#define HC_PM_MENU_OPTIONSCHART            401

#define HC_PM_MENU_OPTIONSALERT            403

#define HC_PM_MENU_OPTIONSLOG              405

#define HC_PM_MENU_OPTIONSREPORT           407


#define HC_PM_MENU_OPTIONSDISPLAYMENU      408
#define HC_PM_MENU_OPTIONSDISPLAYTOOLBAR   409
#define HC_PM_MENU_OPTIONSDISPLAYSTATUS    410
#define HC_PM_MENU_OPTIONSDISPLAYONTOP     411

#define HC_PM_MENU_OPTIONSREFRESHNOW       412

#define HC_PM_MENU_OPTIONSBOOKMARK         413


#define HC_PM_MENU_OPTIONSDATASOURCE       415


//=============================//
// "Help" Menu IDs             //
//=============================//


#define HC_PM_MENU_HELPCONTENTS            501
#define HC_PM_MENU_HELPSEARCH              502
#define HC_PM_MENU_HELPHELP                503
#define HC_PM_MENU_HELPABOUT               504
#define HC_NTPM_MENU_HELPABOUT             505

//=============================//
// "System" Menu IDs           //
//=============================//
#define HC_PM_MENU_SYSTEMMENU_RESTORE      910
#define HC_PM_MENU_SYSTEMMENU_MOVE         911
#define HC_PM_MENU_SYSTEMMENU_SIZE         912
#define HC_PM_MENU_SYSTEMMENU_MINIMIZE     913
#define HC_PM_MENU_SYSTEMMENU_MAXMIZE      914
#define HC_PM_MENU_SYSTEMMENU_CLOSE        915
#define HC_PM_MENU_SYSTEMMENU_SWITCHTO     916



//=============================//
// "File" Menu Dialog IDs      //
//=============================//
#define HC_PM_idDlgFileOpen                1000
#define HC_PM_idDlgFileSaveAs              1001
#define HC_PM_idDlgFileSaveWorkSpace       1002
#define HC_PM_idDlgFileExport              1003

//=============================//
// "EditFile" Menu Dialog IDs  //
//=============================//
#define HC_PM_idDlgEditAddToChart          1010
#define HC_PM_idDlgEditAddToAlert          1011
#define HC_PM_idDlgEditAddToLog            1012
#define HC_PM_idDlgEditAddToReport         1013
#define HC_PM_idDlgEditChartLine           1014
#define HC_PM_idDlgEditAlertEntry          1015
#define HC_PM_idDlgEditTimeFrame           1016

//=============================//
// "Option" Menu Dialog IDs    //
//=============================//
#define HC_PM_idDlgOptionChart             1020
#define HC_PM_idDlgOptionAlert             1021
#define HC_PM_idDlgOptionLog               1022
#define HC_PM_idDlgOptionReport            1023
#define HC_PM_idDlgOptionDataFrom          1024
#define HC_PM_idDlgOptionBookMark          1025
#define HC_PM_idDlgOptionOpenLogFile       1026

//==============================//
// "Computer list" Dailog ID    //
// replace NetworkComputerList  //
// when playing back log file   //
//==============================//
#define HC_PM_idDlgLogComputerList         1030
#define HC_PM_idDlgSelectNetworkComputer   1031


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\pmemory.h ===
LPMEMORY MemoryAllocate (SIZE_T dwSize) ;

VOID MemoryFree (LPMEMORY lpMemory) ;

SIZE_T MemorySize (LPMEMORY lpMemory) ;

LPMEMORY MemoryResize (LPMEMORY lpMemory, SIZE_T dwNewSize) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\perfmops.h ===
HWND PerfmonViewWindow (void) ;

BOOL ChooseComputer (HWND hWndParent, LPTSTR lpszComputer) ;


BOOL CurrentComputerName (LPTSTR lpszComputer) ;

void GetDateTimeFormats (void) ;

void SystemTimeDateString (SYSTEMTIME *pSystemTime,
                           LPTSTR lpszDate) ;


void SystemTimeTimeString (SYSTEMTIME *pSystemTime,
                           LPTSTR lpszTime,
                           BOOL bOutputMsec) ;


VOID dlg_error_box (HANDLE hDlg, UINT id) ;


void ShowPerfmonMenu (BOOL bMenu) ;


void SmallFileSizeString (int iFileSize,
                          LPTSTR lpszFileText) ;


BOOL DoWindowDrag (HWND hWnd, LPARAM lParam) ;


int SystemTimeDifference (SYSTEMTIME *pst1, SYSTEMTIME *pst2) ;


BOOL OpenFileHandler(HWND hWnd, LPTSTR lpszFilePath) ;


BOOL InsertLine (PLINE pLine)  ;

BOOL OpenWorkspace (HANDLE hFile, DWORD dwMajorVersion, DWORD dwMinorVersion) ;

BOOL SaveWorkspace (void) ;

INT ExportFileOpen (HWND hWnd, HANDLE *phFile, int IntervalSecs, LPTSTR *ppFileName) ;

void SetPerfmonOptions (OPTIONS *pOptions) ;

void ChangeSaveFileName (LPTSTR szFileName, int iPMView) ;

BOOL AppendObjectToValueList ( DWORD   dwObjectId, LPTSTR   pwszValueList );

BOOL RemoveObjectsFromSystem (PPERFSYSTEM pSystem);

BOOL BuildValueListForSystems (PPERFSYSTEM, PLINE);

BOOL SetSystemValueNameToGlobal (PPERFSYSTEM);

void CreatePerfmonSystemObjects () ;

void DeletePerfmonSystemObjects () ;

void ConvertDecimalPoint (LPTSTR lpFloatPointStr) ;

void ReconvertDecimalPoint (LPTSTR lpFloatPointStr) ;

void ShowPerfmonWindowText (void) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\options.h ===
BOOL DisplayDisplayOptions (HWND hWndParent) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\registry.h ===
/*****************************************************************************
 *
 *  Registry.h - This is the include file for the user config code.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/

// default values for .INI files

#define DEFAULT_TIMER_INTERVAL	  2000	    // sampling interval

// LINEGRAPH
// first three are general default values. The others are specific
#define DEFAULT_VAL_BOTTOM        0
#define DEFAULT_DVAL_AXISHEIGHT   100
#define DEFAULT_MAX_VALUES        100


// LINEGRAPH DISP
#define DEFAULT_F_DISPLAY_LEGEND  TRUE
#define DEFAULT_F_DISPLAY_CALIBRATION TRUE



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//



BOOL LoadMainWindowPlacement (HWND hWnd) ;

BOOL SaveMainWindowPlacement (HWND hWnd) ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\perfdata.h ===
#define dwPerfDataIncrease       0x1000

#define AllocatePerfData()      (MemoryAllocate (STARTING_SYSINFO_SIZE))

// Messages for the perf data collection thread
#define WM_GET_PERF_DATA (WM_USER + 102)
#define WM_FREE_SYSTEM   (WM_USER + 103)

// State for perf data collection
#define WAIT_FOR_PERF_DATA    0x0010
#define PERF_DATA_READY       0x0011
#define PERF_DATA_FAIL        0x0012
#define IDLE_STATE            0x0013


//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define IsLocalComputer(a) (!lstrcmp(a,LocalComputerName))
#define IsRemoteComputer(a) (!IsLocalComputer(a))


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

#if 0
PPERFOBJECT FirstObject (PPERFDATA pPerfData) ;

PPERFOBJECT NextObject (PPERFOBJECT pObject) ;

PERF_COUNTER_DEFINITION *
FirstCounter(
    PERF_OBJECT_TYPE *pObjectDef) ;

PERF_COUNTER_DEFINITION *
NextCounter(
    PERF_COUNTER_DEFINITION *pCounterDef) ;
#endif

#define FirstObject(pPerfData)         \
   ((PPERFOBJECT) ((PBYTE) pPerfData + pPerfData->HeaderLength))

#define NextObject(pObject)            \
   ((PPERFOBJECT) ((PBYTE) pObject + pObject->TotalByteLength))

#define FirstCounter(pObjectDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pObjectDef + pObjectDef->HeaderLength))

#define NextCounter(pCounterDef)       \
   ((PERF_COUNTER_DEFINITION *) ((PCHAR)pCounterDef + pCounterDef->ByteLength))

void
GetInstanceNameStr (PPERFINSTANCEDEF pInstance,
                    LPTSTR lpszInstance);

LPTSTR
GetInstanceName (PPERFINSTANCEDEF pInstance) ;

void
GetPerfComputerName(PPERFDATA pPerfData,
                    LPTSTR szComputerName) ;

PERF_INSTANCE_DEFINITION *GetInstanceByName(
    PERF_DATA_BLOCK *pDataBlock,
    PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
    LPTSTR pInstanceName,
    LPTSTR pParentName,
    DWORD   dwIndex) ;


PERF_INSTANCE_DEFINITION *GetInstanceByUniqueID(
    PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
    LONG UniqueID,
    DWORD   dwIndex) ;



HKEY OpenSystemPerfData (IN LPCTSTR lpszSystem) ;



LONG GetSystemPerfData (
    IN HKEY hKeySystem,
    IN LPTSTR lpszValue,
    OUT PPERFDATA pPerfData,
    OUT SIZE_T * pdwPerfDataLen
);


BOOL CloseSystemPerfData (HKEY hKeySystem) ;



int CBLoadObjects (HWND hWndCB,
                   PPERFDATA pPerfData,
                   PPERFSYSTEM pSysInfo,
                   DWORD dwDetailLevel,
                   LPTSTR lpszDefaultObject,
                   BOOL bIncludeAll) ;

int LBLoadObjects (HWND hWndCB,
                   PPERFDATA pPerfData,
                   PPERFSYSTEM pSysInfo,
                   DWORD dwDetailLevel,
                   LPTSTR lpszDefaultObject,
                   BOOL bIncludeAll) ;


BOOL UpdateSystemData (PPERFSYSTEM pSystem,
                       PPERFDATA *ppPerfData) ;


BOOL UpdateLinesForSystem (LPTSTR lpszSystem,
                           PPERFDATA pPerfData,
                           PLINE pLineFirst,
                           PPERFSYSTEM pSystem) ;

BOOL FailedLinesForSystem (LPTSTR lpszSystem,
                           PPERFDATA pPerfData,
                           PLINE pLineFirst) ;


BOOL UpdateLines (PPPERFSYSTEM ppSystemFirst,
                  PLINE pLineFirst) ;


BOOL PerfDataInitializeInstance (void) ;


DWORD
QueryPerformanceName(
    PPERFSYSTEM pSysInfo,
    DWORD dwTitleIndex,
    LANGID LangID,
    DWORD cbTitle,
    LPTSTR lpTitle,
    BOOL Help
    );

PERF_INSTANCE_DEFINITION *
FirstInstance(
    PERF_OBJECT_TYPE UNALIGNED *pObjectDef) ;



PERF_INSTANCE_DEFINITION *
NextInstance(
    PERF_INSTANCE_DEFINITION *pInstDef) ;



int CounterIndex (PPERFCOUNTERDEF pCounterToFind,
                  PERF_OBJECT_TYPE UNALIGNED *pObject) ;


DWORD GetSystemNames(PPERFSYSTEM pSysInfo) ;



PERF_OBJECT_TYPE *GetObjectDefByTitleIndex(
    PERF_DATA_BLOCK *pDataBlock,
    DWORD ObjectTypeTitleIndex) ;


PERF_OBJECT_TYPE *GetObjectDefByName(
    PPERFSYSTEM pSystem,
    PERF_DATA_BLOCK *pDataBlock,
    LPTSTR pObjectName) ;

DWORD GetObjectIdByName(
    PPERFSYSTEM pSystem,
    PERF_DATA_BLOCK *pDataBlock,
    LPTSTR pObjectName) ;

LPTSTR
InstanceName(
PERF_INSTANCE_DEFINITION *pInstDef) ;

void PerfDataThread (PPERFSYSTEM pSystem) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\sizes.h ===
#define FilePathLen                256


//==========================================================================//
//                                 Other                                    //
//==========================================================================//


#define ControlStringLen           160
#define MenuStringLen               80
#define MessageLen                 160
#define ProfileValueLen            120
#define ProfileKeyLen               80
#define WindowCaptionLen            40
#define ResourceStringLen           40

#define MiscTextLen                 80
#define ShortTextLen                25
#define LongTextLen                256
#define FileExtLen                   8
#define TEMP_BUF_LEN               256


//==========================================================================//
//                         Perfmon-Related Sizes                            //
//==========================================================================//


#define PerfObjectLen               80

#define MAX_SYSTEM_NAME_LENGTH      128
#define DEFAULT_COUNTER_NAME_SIZE   (2 * 4096)
#define DEFAULT_COUNTER_HELP_SIZE   (24 * 4096)
#define SMALL_BUF_LEN   16  // For numeric strings done in ASCII or whatever
#define STARTING_SYSINFO_SIZE   (48L * 1024L)
#define NM_BUF_SIZE         64

// the min and max of time interval in sec
#define MAX_INTERVALSEC    (FLOAT)2000000.0
#define MIN_INTERVALSEC    (FLOAT)0.0

// the min and max for the Graph Vertical max.
#define MAX_VERTICAL        2000000000
#define MIN_VERTICAL        1


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\status.h ===
HWND CreatePMStatusWindow (HWND hWnd) ;


BOOL StatusInitializeApplication (void) ;


int StatusHeight (HWND hWnd) ;


BOOL _cdecl StatusLine (HWND hWnd,
                        WORD wStringID, ...) ;


void StatusLineReady (HWND hWnd) ;


void StatusUpdateIcons (HWND hWndStatus) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\perfdata.c ===
//==========================================================================//
//                                  Includes                                //
//==========================================================================//


#include <string.h>     // strupr
#include <stdio.h>   // for sprintf.
#include "setedit.h"
#include "utils.h"

#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines
#include "perfdata.h"   // external declarations for this file
#include "system.h"     // for DeleteUnusedSystems

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

TCHAR NamesKey[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
TCHAR Counters[] = L"Counters";
TCHAR Help[] = L"Help";
TCHAR LastHelp[] = L"Last Help";
TCHAR LastCounter[] = L"Last Counter";
TCHAR SysVersion[] = L"Version";
TCHAR CounterNameStr[] = L"Counter ";
TCHAR ExplainNameStr[] = L"Explain ";

#define szPerfSubkey      (NULL)
TCHAR   NULL_NAME[] = L" ";
#define RESERVED    0L

TCHAR          DefaultLangId[4] ;
TCHAR          EnglishLangId[4] ;

static   HANDLE            *lpHandles ;
static   int               NumberOfHandles = 0 ;

//==========================================================================//
//                                   Macros                                 //
//==========================================================================//



//==========================================================================//
//                                Local Data                                //
//==========================================================================//


// When the conversion of this code is complete, this will be the *only*
// allocated copy of the performance data.  It will monotonically grow
// to hold the largest of the system's performance data.

// PPERFDATA      pGlobalPerfData ;

//==========================================================================//
//                              Local Functions                             //
//==========================================================================//

NTSTATUS
AddNamesToArray (
                LPTSTR pNames,
                DWORD    dwLastID,
                LPWSTR   *lpCounterId
                ) ;

//======================================//
// Object Accessors                     //
//======================================//

void
ObjectName (
           PPERFSYSTEM pSystem,
           PPERFOBJECT pObject,
           LPTSTR lpszName,
           int iLen
           )
{  // ObjectName
    strclr (lpszName) ;
    QueryPerformanceName (pSystem,
                          pObject->ObjectNameTitleIndex,
                          0, iLen, lpszName, FALSE) ;
}  // ObjectName



//======================================//
// Counter Accessors                    //
//======================================//


PERF_INSTANCE_DEFINITION *
FirstInstance(
             PERF_OBJECT_TYPE UNALIGNED *pObjectDef
             )
{
    return (PERF_INSTANCE_DEFINITION *)
    ((PCHAR) pObjectDef + pObjectDef->DefinitionLength);
}


PERF_INSTANCE_DEFINITION *
NextInstance(
            PERF_INSTANCE_DEFINITION *pInstDef
            )
{
    PERF_COUNTER_BLOCK *pCounterBlock;

    pCounterBlock = (PERF_COUNTER_BLOCK *)
                    ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION *)
    ((PCHAR) pCounterBlock + pCounterBlock->ByteLength);
}



LPTSTR
GetInstanceName(
               PPERFINSTANCEDEF  pInstDef)
{
    return (LPTSTR) ((PCHAR) pInstDef + pInstDef->NameOffset);
}


void
GetInstanceNameStr (
                   PPERFINSTANCEDEF pInstance,
                   LPTSTR lpszInstance
                   )
{
    // This function used to test for ansi names, but
    // instance names should ALWAYS be wide character
    // strings so this is removed (especially since
    // looking for a null byte is a bogus test in the
    // first place)

    LPTSTR pSource;

    pSource = (LPTSTR) GetInstanceName(pInstance) ;

    wcsncpy (lpszInstance,
             (LPTSTR)pSource,
             pInstance->NameLength);
}

void
GetPerfComputerName(
                   PPERFDATA pPerfData,
                   LPTSTR lpszComputerName
                   )
{
    lstrcpy(lpszComputerName, szComputerPrefix) ;
    if (pPerfData) {
        wcsncpy (&lpszComputerName[2],
                 (LPWSTR)((PBYTE) pPerfData + pPerfData->SystemNameOffset),
                 pPerfData->SystemNameLength/sizeof(WCHAR)) ;
    } else {
        lpszComputerName[0] = TEXT('\0') ;
    }
}


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


int CounterIndex (PPERFCOUNTERDEF pCounterToFind,
                  PERF_OBJECT_TYPE UNALIGNED *pObject)
/*
   Effect:        Return the index ("counter number") of pCounterToFind
          within pObject. If the counter doesnt belong to pObject,
          return -1.
*/
{  // CounterIndex
    PPERFCOUNTERDEF   pCounter ;
    UINT              iCounter ;

    for (iCounter = 0, pCounter = FirstCounter (pObject) ;
        iCounter < pObject->NumCounters ;
        iCounter++, pCounter = NextCounter (pCounter)) {  // for
        if (pCounter->CounterNameTitleIndex ==
            pCounterToFind->CounterNameTitleIndex)
            return (iCounter) ;
    }  // for

    return (-1) ;
}  // CounterIndex


HKEY
OpenSystemPerfData (
                   IN LPCTSTR lpszSystem
                   )
{  // OpenSystemPerfData

    HKEY    hKey = NULL;
    LONG    lStatus;

    lStatus = ERROR_CANTOPEN;   // default error if none is returned

    if (IsLocalComputer(lpszSystem)) {
        bCloseLocalMachine = TRUE ;
        SetLastError (ERROR_SUCCESS);
        return HKEY_PERFORMANCE_DATA;
    } else if (lstrlen (lpszSystem) < MAX_COMPUTERNAME_LENGTH+3) {
        // Must be a remote system
        try {
            lStatus = RegConnectRegistry (
                                         (LPTSTR)lpszSystem,
                                         HKEY_PERFORMANCE_DATA,
                                         &hKey);
        }finally {
            if (lStatus != ERROR_SUCCESS) {
                SetLastError (lStatus);
                hKey = NULL;
            }
        }
    }
    return (hKey);

}  // OpenSystemPerfData



LPWSTR
*AddNewName(
           HKEY    hKeyNames,
           PCOUNTERTEXT  pCounterInfo,
           LPWSTR  CounterBuffer,
           LPWSTR  HelpBuffer,
           DWORD   dwLastId,
           DWORD   dwCounterSize,
           DWORD   dwHelpSize,
           LANGID  LangIdUsed
           )
{
    LPWSTR  *lpReturnValue;
    LPWSTR  *lpCounterId;
    LPWSTR  lpCounterNames;
    LPWSTR  lpHelpText;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwValueType;
    LONG    lWin32Status;
    NTSTATUS    Status;
    DWORD   dwLastError;

    dwArraySize = (dwLastId + 1 ) * sizeof(LPWSTR);
    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize);

    if (!lpReturnValue) {
        lWin32Status = ERROR_NOT_ENOUGH_MEMORY;
        goto ERROR_EXIT;
    }

    // initialize pointers into buffer

    lpCounterId = lpReturnValue;
    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize);
    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize);

    // read counters into memory

    dwBufferSize = dwCounterSize;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   CounterBuffer,
                                   RESERVED,
                                   &dwValueType,
                                   (LPVOID)lpCounterNames,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;

    if (bExplainTextButtonHit) {
        dwBufferSize = dwHelpSize;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       HelpBuffer,
                                       RESERVED,
                                       &dwValueType,
                                       (LPVOID)lpHelpText,
                                       &dwBufferSize);

        if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;
    }

    // load counter array items
    Status = AddNamesToArray (lpCounterNames, dwLastId, lpCounterId);
    if (Status != ERROR_SUCCESS) goto ERROR_EXIT;

    if (bExplainTextButtonHit) {
        Status = AddNamesToArray (lpHelpText, dwLastId, lpCounterId);
    }

    if (Status != ERROR_SUCCESS) goto ERROR_EXIT;

    if (pCounterInfo) {
        pCounterInfo->dwLastId = dwLastId;
        pCounterInfo->dwLangId = LangIdUsed;
        pCounterInfo->dwHelpSize = dwHelpSize;
        pCounterInfo->dwCounterSize = dwCounterSize;
    }

    return lpReturnValue;

    ERROR_EXIT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
    }

    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    return NULL;
}


LPWSTR
*BuildNewNameTable(
                  PPERFSYSTEM   pSystem,
                  LPWSTR        lpszLangId,     // unicode value of Language subkey
                  PCOUNTERTEXT  pCounterInfo,
                  LANGID        iLangId,         // lang ID of the lpszLangId
                  DWORD         dwLastId
                  )
/*++

BuildNewNameTable

Arguments:

    lpszLangId
        The unicode id of the language to look up. (English is 0x409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwLastError;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    HKEY    hKeyNames;
    TCHAR   CounterBuffer [MiscTextLen] ;
    TCHAR   ExplainBuffer [MiscTextLen] ;
    TCHAR   subLangId [ShortTextLen] ;
    LANGID  LangIdUsed = iLangId;


    //initialize local variables
    hKeyNames = pSystem->sysDataKey;


    // check for null arguments and insert defaults if necessary
    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
        LangIdUsed = iLanguage ;
    }

    // get size of counter names and add that to the arrays
    lstrcpy (CounterBuffer, CounterNameStr);
    lstrcat (CounterBuffer, lpszLangId);

    lstrcpy (ExplainBuffer, ExplainNameStr);
    lstrcat (ExplainBuffer, lpszLangId);

    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   CounterBuffer,
                                   RESERVED,
                                   &dwValueType,
                                   NULL,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) {
        // check for ACCESS_DENIED error first since if it's here
        // it will be returned on all subsequent calls, we might as well
        // bail out now.

        if (lWin32Status == ERROR_ACCESS_DENIED) {
            goto BNT_BAILOUT;
        }

        // try take out the country ID
        LangIdUsed = MAKELANGID (LangIdUsed & 0x0ff, LANG_NEUTRAL);
        TSPRINTF (subLangId, TEXT("%03x"), LangIdUsed);
        lstrcpy (CounterBuffer, CounterNameStr);
        lstrcat (CounterBuffer, subLangId);

        lstrcpy (ExplainBuffer, ExplainNameStr);
        lstrcpy (ExplainBuffer, subLangId);

        dwBufferSize = 0;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       CounterBuffer,
                                       RESERVED,
                                       &dwValueType,
                                       NULL,
                                       &dwBufferSize);
    }

    if (lWin32Status != ERROR_SUCCESS) {
        // try the EnglishLangId
        if (!strsame(EnglishLangId, subLangId)) {

            lstrcpy (CounterBuffer, CounterNameStr);
            lstrcat (CounterBuffer, EnglishLangId);

            lstrcpy (ExplainBuffer, ExplainNameStr);
            lstrcpy (ExplainBuffer, EnglishLangId);

            LangIdUsed = iEnglishLanguage ;

            dwBufferSize = 0;
            lWin32Status = RegQueryValueEx (
                                           hKeyNames,
                                           CounterBuffer,
                                           RESERVED,
                                           &dwValueType,
                                           NULL,
                                           &dwBufferSize);
        }
    }

    // Fail, too bad...
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    dwCounterSize = dwBufferSize;

    // If ExplainText is needed, then
    // get size of help text and add that to the arrays

    if (bExplainTextButtonHit) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       ExplainBuffer,
                                       RESERVED,
                                       &dwValueType,
                                       NULL,
                                       &dwBufferSize);

        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

        dwHelpSize = dwBufferSize;
    } else {
        dwHelpSize = 0;
    }

    return (AddNewName(
                      hKeyNames,
                      pCounterInfo,
                      CounterBuffer,
                      ExplainBuffer,
                      dwLastId,
                      dwCounterSize,
                      dwHelpSize,
                      LangIdUsed));


    BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        // set the LastError value since a null pointer will
        // be returned which doesn't tell much to the caller
        SetLastError (lWin32Status);
    }

    return NULL;
}


LPWSTR
*BuildOldNameTable(
                  HKEY          hKeyRegistry,   // handle to registry db with counter names
                  LPWSTR        lpszLangId,     // unicode value of Language subkey
                  PCOUNTERTEXT  pCounterInfo,
                  LANGID        iLangId,         // lang ID of the lpszLangId
                  DWORD         dwLastId
                  )
/*++

BuildOldNameTable

Arguments:

    hKeyRegistry
        Handle to an open registry (this can be local or remote.) and
        is the value returned by RegConnectRegistry or a default key.

    lpszLangId
        The unicode id of the language to look up. (English is 0x409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{
    LPWSTR  *lpReturnValue = NULL;

    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwLastError;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    HKEY    hKeyNames;
    TCHAR   tempBuffer [MiscTextLen] ;
    TCHAR   subLangId [ShortTextLen] ;
    LPWSTR  lpValueNameString;
    LANGID  LangIdUsed = iLangId;
    TCHAR   Slash[2];

    //initialize local variables
    hKeyNames = NULL;
    Slash[0] = L'\\';
    Slash[1] = L'\0';

    // check for null arguments and insert defaults if necessary
    if (!lpszLangId) {
        lpszLangId = DefaultLangId;
        LangIdUsed = iLanguage ;
    }

    // get size of string buffer
    lpValueNameString = tempBuffer ;

    lstrcpy (lpValueNameString, NamesKey);
    lstrcat (lpValueNameString, Slash);
    lstrcat (lpValueNameString, lpszLangId);

    lWin32Status = RegOpenKeyEx (
                                hKeyRegistry,
                                lpValueNameString,
                                RESERVED,
                                KEY_READ,
                                &hKeyNames);

    if (lWin32Status != ERROR_SUCCESS) {
        // check for ACCESS_DENIED error first since if it's here
        // it will be returned on all subsequent calls, we might as well
        // bail out now.

        if (lWin32Status == ERROR_ACCESS_DENIED) {
            goto BNT_BAILOUT;
        }

        // try take out the country ID
        LangIdUsed = MAKELANGID (LangIdUsed & 0x0ff, LANG_NEUTRAL);
        TSPRINTF (subLangId, TEXT("%03x"), LangIdUsed);
        lstrcpy (lpValueNameString, NamesKey);
        lstrcat (lpValueNameString, Slash);
        lstrcat (lpValueNameString, subLangId);

        lWin32Status = RegOpenKeyEx (
                                    hKeyRegistry,
                                    lpValueNameString,
                                    RESERVED,
                                    KEY_READ,
                                    &hKeyNames);
    }

    if (lWin32Status != ERROR_SUCCESS) {
        // try the EnglishLangId
        if (!strsame(EnglishLangId, subLangId)) {

            lstrcpy (lpValueNameString, NamesKey);
            lstrcat (lpValueNameString, Slash);
            lstrcat (lpValueNameString, EnglishLangId);

            LangIdUsed = iEnglishLanguage ;

            lWin32Status = RegOpenKeyEx (
                                        hKeyRegistry,
                                        lpValueNameString,
                                        RESERVED,
                                        KEY_READ,
                                        &hKeyNames);
        }
    }

    // Fail, too bad...
    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get size of counter names and add that to the arrays


    dwBufferSize = 0;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   Counters,
                                   RESERVED,
                                   &dwValueType,
                                   NULL,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

    dwCounterSize = dwBufferSize;

    // If ExplainText is needed, then
    // get size of help text and add that to the arrays

    if (bExplainTextButtonHit) {
        dwBufferSize = 0;
        lWin32Status = RegQueryValueEx (
                                       hKeyNames,
                                       Help,
                                       RESERVED,
                                       &dwValueType,
                                       NULL,
                                       &dwBufferSize);

        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT;

        dwHelpSize = dwBufferSize;
    } else {
        dwHelpSize = 0;
    }

    lpReturnValue = AddNewName(
                              hKeyNames,
                              pCounterInfo,
                              Counters,
                              Help,
                              dwLastId,
                              dwCounterSize,
                              dwHelpSize,
                              LangIdUsed);

    RegCloseKey (hKeyNames);

    return lpReturnValue;

    BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        // set the LastError value since a null pointer will
        // be returned which doesn't tell much to the caller
        SetLastError (lWin32Status);
    }

    if (lpReturnValue) {
        MemoryFree ((LPVOID)lpReturnValue);
    }

    if (hKeyNames) RegCloseKey (hKeyNames);

    return NULL;
}


LPWSTR
*BuildNameTable(
               PPERFSYSTEM   pSysInfo,
               HKEY          hKeyRegistry,   // handle to registry db with counter names
               LPWSTR        lpszLangId,     // unicode value of Language subkey
               PCOUNTERTEXT  pCounterInfo,
               LANGID        iLangId         // lang ID of the lpszLangId
               )
/*++

BuildNameTable

Arguments:

    hKeyRegistry
        Handle to an open registry (this can be local or remote.) and
        is the value returned by RegConnectRegistry or a default key.

    lpszLangId
        The unicode id of the language to look up. (English is 0x409)

Return Value:

    pointer to an allocated table. (the caller must free it when finished!)
    the table is an array of pointers to zero terminated strings. NULL is
    returned if an error occured.

--*/
{

    LPWSTR  *lpReturnValue;
    LONG    lWin32Status;
    DWORD   dwLastError;
    DWORD   dwValueType;
    DWORD   dwLastHelp;
    DWORD   dwLastCounter;
    DWORD   dwLastId;
    DWORD   dwBufferSize;
    HKEY    hKeyValue;
    DWORD   dwSystemVersion;


    //initialize local variables
    lpReturnValue = NULL;
    hKeyValue = NULL;


    // open registry to get number of items for computing array size

    lWin32Status = RegOpenKeyEx (
                                hKeyRegistry,
                                NamesKey,
                                RESERVED,
                                KEY_READ,
                                &hKeyValue);

    if (lWin32Status != ERROR_SUCCESS) {
        goto BNT_BAILOUT;
    }

    // get number of items

    dwBufferSize = sizeof (dwLastHelp);
    lWin32Status = RegQueryValueEx (
                                   hKeyValue,
                                   LastHelp,
                                   RESERVED,
                                   &dwValueType,
                                   (LPBYTE)&dwLastHelp,
                                   &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    dwBufferSize = sizeof (dwLastCounter);
    lWin32Status = RegQueryValueEx (
                                   hKeyValue,
                                   LastCounter,
                                   RESERVED,
                                   &dwValueType,
                                   (LPBYTE)&dwLastCounter,
                                   &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        goto BNT_BAILOUT;
    }

    if (dwLastCounter >= dwLastHelp) {
        dwLastId = dwLastCounter;
    } else {
        dwLastId = dwLastHelp;
    }

    // get system version
    dwBufferSize = sizeof (dwSystemVersion);
    lWin32Status = RegQueryValueEx (
                                   hKeyValue,
                                   SysVersion,
                                   RESERVED,
                                   &dwValueType,
                                   (LPBYTE)&dwSystemVersion,
                                   &dwBufferSize);

    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) {
        pSysInfo->SysVersion = 0x10000;
    } else {
        pSysInfo->SysVersion = dwSystemVersion;
    }

    if (pSysInfo->SysVersion <= 0x10000) {
        lpReturnValue = BuildOldNameTable (
                                          hKeyRegistry,
                                          lpszLangId,
                                          pCounterInfo,
                                          iLangId,
                                          dwLastId) ;
    } else {
        lpReturnValue = BuildNewNameTable (
                                          pSysInfo,
                                          lpszLangId,
                                          pCounterInfo,
                                          iLangId,
                                          dwLastId) ;
    }

    RegCloseKey (hKeyValue);
    return lpReturnValue;

    BNT_BAILOUT:
    if (lWin32Status != ERROR_SUCCESS) {
        dwLastError = GetLastError();
        // set the LastError value since a null pointer will
        // be returned which doesn't tell much to the caller
        SetLastError (lWin32Status);
    }
    if (hKeyValue) RegCloseKey (hKeyValue);
    return NULL;
}

DWORD
GetSystemKey (
             PPERFSYSTEM pSysInfo,
             HKEY *phKeyMachine
             )
{
    DWORD   dwStatus;
    *phKeyMachine = HKEY_LOCAL_MACHINE;

    // connect to system registry

    if (IsLocalComputer(pSysInfo->sysName)) {
        *phKeyMachine = HKEY_LOCAL_MACHINE;
    } else if (lstrlen(pSysInfo->sysName) < MAX_COMPUTERNAME_LENGTH+3) {
        try {
            dwStatus = RegConnectRegistry (
                                          pSysInfo->sysName,
                                          HKEY_LOCAL_MACHINE,
                                          phKeyMachine);

            if (dwStatus != ERROR_SUCCESS) {
                //                return dwStatus;
                // comnputer name not found, use the local system's registry
                *phKeyMachine = HKEY_LOCAL_MACHINE;
                return 0;
            }
        }finally {
            ; // nothing
        }
    }
    return 0;
}


DWORD
GetSystemNames(
              PPERFSYSTEM pSysInfo
              )
{
    HKEY    hKeyMachine = 0;
    DWORD   dwStatus;

    if (dwStatus = GetSystemKey (pSysInfo, &hKeyMachine)) {
        return dwStatus;
    }

    // if here, then hKeyMachine is an open key to the system's
    //  HKEY_LOCAL_MACHINE registry database

    // only one language is supported by this approach.
    // multiple language support would:
    //  1.  enumerate language keys
    //       and for each key:
    //  2.  allocate memory for structures
    //  3.  call BuildNameTable for each lang key.

    pSysInfo->CounterInfo.pNextTable = NULL;
    pSysInfo->CounterInfo.dwLangId = iLanguage ;   // default Lang ID

    pSysInfo->CounterInfo.TextString = BuildNameTable (
                                                      pSysInfo,
                                                      hKeyMachine,
                                                      NULL,                               // use default
                                                      &pSysInfo->CounterInfo,
                                                      0);

    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    if (pSysInfo->CounterInfo.TextString == NULL) {
        return GetLastError();
    } else {
        return ERROR_SUCCESS;
    }
}

BOOL
GetHelpText(
           PPERFSYSTEM pSysInfo
           )
{
    LPWSTR  *lpCounterId;
    LPWSTR  lpHelpText;
    LONG    lWin32Status;
    DWORD   dwValueType;
    DWORD   dwArraySize;
    DWORD   dwBufferSize;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    NTSTATUS    Status;
    DWORD   dwLastId;
    TCHAR   Slash[2];

    HKEY    hKeyNames;

    TCHAR   SysLangId [ShortTextLen] ;
    TCHAR   ValueNameString [MiscTextLen] ;
    HKEY    hKeyMachine = 0;
    DWORD   dwStatus;

    SetHourglassCursor() ;

    //initialize local variables
    lpHelpText = NULL;
    hKeyNames = hKeyMachine = NULL;
    Slash[0] = L'\\';
    Slash[1] = L'\0';

    dwBufferSize = 0;

    TSPRINTF (SysLangId, TEXT("%03x"), pSysInfo->CounterInfo.dwLangId) ;

    if (pSysInfo->SysVersion <= 0x10000) {
        // old version, get help from registry
        if (dwStatus = GetSystemKey (pSysInfo, &hKeyMachine)) {
            goto ERROR_EXIT;
        }

        lstrcpy (ValueNameString, NamesKey);
        lstrcat (ValueNameString, Slash);
        lstrcat (ValueNameString, SysLangId);

        lWin32Status = RegOpenKeyEx (
                                    hKeyMachine,
                                    ValueNameString,
                                    RESERVED,
                                    KEY_READ,
                                    &hKeyNames);

        if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;
    } else {
        // new system version, get it from the HKEY_PERFORMANCE
        hKeyNames = pSysInfo->sysDataKey;
        lstrcpy (ValueNameString, ExplainNameStr);
        lstrcat (ValueNameString, SysLangId);
    }

    dwHelpSize = 0;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   pSysInfo->SysVersion <= 0x010000 ? Help : ValueNameString,
                                   RESERVED,
                                   &dwValueType,
                                   NULL,
                                   &dwHelpSize);

    if (lWin32Status != ERROR_SUCCESS || dwHelpSize == 0) goto ERROR_EXIT;

    dwLastId = pSysInfo->CounterInfo.dwLastId;
    dwArraySize = (dwLastId + 1) * sizeof (LPWSTR);
    dwCounterSize = pSysInfo->CounterInfo.dwCounterSize;

    // allocate another memory to get the help text
    lpHelpText = MemoryAllocate (dwHelpSize);
    if (!lpHelpText) goto ERROR_EXIT;

    dwBufferSize = dwHelpSize;
    lWin32Status = RegQueryValueEx (
                                   hKeyNames,
                                   pSysInfo->SysVersion <= 0x010000 ? Help : ValueNameString,
                                   RESERVED,
                                   &dwValueType,
                                   (LPVOID)lpHelpText,
                                   &dwBufferSize);

    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT;

    // setup the help text pointers
    lpCounterId = pSysInfo->CounterInfo.TextString;
    Status = AddNamesToArray (lpHelpText, dwLastId, lpCounterId) ;
    if (Status != ERROR_SUCCESS) goto ERROR_EXIT;

    pSysInfo->CounterInfo.dwHelpSize = dwHelpSize;

    if (pSysInfo->SysVersion <= 0x010000)
        RegCloseKey (hKeyNames);

    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    pSysInfo->CounterInfo.HelpTextString = lpHelpText;

    SetArrowCursor() ;

    return TRUE;

    ERROR_EXIT:

    SetArrowCursor() ;

    if (lpHelpText) {
        MemoryFree ((LPVOID)lpHelpText);
    }

    if (hKeyNames) {
        RegCloseKey (hKeyNames);
    }
    if (hKeyMachine && hKeyMachine != HKEY_LOCAL_MACHINE) {
        RegCloseKey (hKeyMachine) ;
    }

    return FALSE;
}

//
//  QueryPerformanceName -      Get a title, given an index
//
//      Inputs:
//
//          pSysInfo        -   Pointer to sysinfo struct for the
//                              system in question
//
//          dwTitleIndex    -   Index of Title entry
//
//          LangID          -   language in which title should be displayed
//
//          cbTitle         -   # of char in the lpTitle buffer
//
//          lpTitle         -   pointer to a buffer to receive the
//                              Title
//
//          Help            -   TRUE is help is desired, else counter or
//                              object is assumed
DWORD
QueryPerformanceName(
                    PPERFSYSTEM pSysInfo,
                    DWORD dwTitleIndex,
                    LANGID LangID,
                    DWORD cbTitle,
                    LPTSTR lpTitle,
                    BOOL Help
                    )
{
    LPWSTR  lpTitleFound;
    NTSTATUS    Status;
    BOOL    bGetTextSuccess = TRUE ;

    DBG_UNREFERENCED_PARAMETER(LangID);

    if (Help && pSysInfo->CounterInfo.dwHelpSize == 0) {
        // we have not get the help text yet, go get it
        bGetTextSuccess = GetHelpText (pSysInfo);
    }

    if (!bGetTextSuccess) {
        Status = ERROR_INVALID_NAME;
        goto ErrorExit;
    }

    if ((dwTitleIndex > 0) && (dwTitleIndex <= pSysInfo->CounterInfo.dwLastId)) {
        // then title should be found in the array
        lpTitleFound = pSysInfo->CounterInfo.TextString[dwTitleIndex];
        if (!lpTitleFound) {
            // no entry for this index
            Status = ERROR_INVALID_NAME;
        } else if ((DWORD)lstrlen(lpTitleFound) < cbTitle) {
            lstrcpy (lpTitle, lpTitleFound);
            return (ERROR_SUCCESS);
        } else {
            Status = ERROR_MORE_DATA;
        }
    } else {

        Status = ERROR_INVALID_NAME;
    }

    ErrorExit:
    // if here, then an error occured, so return a blank

    if ((DWORD)lstrlen (NULL_NAME) < cbTitle) {
        lstrcpy (lpTitle, NULL_NAME);
    }

    return Status;   // title not returned

}


LONG
GetSystemPerfData (
                  IN HKEY hKeySystem,
                  IN LPTSTR lpszValue,
                  OUT PPERFDATA pPerfData,
                  OUT SIZE_T * pdwPerfDataLen
                  )
{  // GetSystemPerfData
    LONG     lError ;
    DWORD    Type ;

    // have to pass in a Type to RegQueryValueEx(W) or else it
    // will crash
    lError = RegQueryValueEx (hKeySystem, lpszValue, NULL, &Type,
                              (LPSTR) pPerfData, (DWORD *)pdwPerfDataLen) ;
    return (lError) ;
}  // GetSystemPerfData


BOOL
CloseSystemPerfData (
                    HKEY hKeySystem
                    )
{  // CloseSystemPerfData
    return (TRUE) ;
}  // CloseSystemPerfData



int
CBLoadObjects (
              HWND hWndCB,
              PPERFDATA pPerfData,
              PPERFSYSTEM pSysInfo,
              DWORD dwDetailLevel,
              LPTSTR lpszDefaultObject,
              BOOL bIncludeAll
              )
/*
   Effect:        Load into the combo box CB one item for each Object in
          pPerfData. For each item, look up the object's name in
          the registry strings associated with pSysInfo, and
          attach the object to the data field of the CB item.

          Dont add those objects that are more detailed than
          dwDetailLevel.

          Set the current selected CB item to the object named
          lpszDefaultObject, or to the default object specified in
          pPerfData if lpszDefaultObject is NULL.
*/
{  // CBLoadObjects
    UINT           i ;
    INT_PTR        iIndex ;
    PPERFOBJECT    pObject ;
    TCHAR          szObject [PerfObjectLen + 1] ;
    TCHAR          szDefaultObject [PerfObjectLen + 1] ;

    CBReset (hWndCB) ;
    strclr (szDefaultObject) ;

    pObject = FirstObject (pPerfData) ;

    for (i = 0, pObject = FirstObject (pPerfData) ;
        i < pPerfData->NumObjectTypes ;
        i++, pObject = NextObject (pObject)) {  // for
        if (pObject->DetailLevel <= dwDetailLevel) {  // if
            strclr (szObject) ;
            QueryPerformanceName (pSysInfo, pObject->ObjectNameTitleIndex,
                                  0, PerfObjectLen, szObject, FALSE) ;

            // if szObject not empty, add it to the Combo-box
            if (!strsame(szObject, NULL_NAME)) {
                iIndex = CBAdd (hWndCB, szObject) ;
                CBSetData (hWndCB, iIndex, (DWORD_PTR) pObject) ;

                if ((LONG)pObject->ObjectNameTitleIndex == pPerfData->DefaultObject)
                    lstrcpy (szDefaultObject, szObject) ;
            } // if szObject not empty
        }  // if
    }  // for


    if (bIncludeAll) {
        StringLoad (IDS_ALLOBJECTS, szObject) ;
        CBInsert (hWndCB, 0, szObject) ;
        // assume "ALL" is default unless overridden
        lstrcpy (szDefaultObject, szObject) ;
    }

    if (lpszDefaultObject)
        lstrcpy (szDefaultObject, lpszDefaultObject) ;

    iIndex = CBFind (hWndCB, szDefaultObject) ;
    CBSetSelection (hWndCB, (iIndex != CB_ERR) ? iIndex : 0) ;

    return (i) ;
}  // CBLoadObjects


int
LBLoadObjects (
              HWND hWndLB,
              PPERFDATA pPerfData,
              PPERFSYSTEM pSysInfo,
              DWORD dwDetailLevel,
              LPTSTR lpszDefaultObject,
              BOOL bIncludeAll
              )
/*
   Effect:        Load into the list box LB one item for each Object in
          pPerfData. For each item, look up the object's name in
          the registry strings associated with pSysInfo, and
          attach the object to the data field of the LB item.

          Dont add those objects that are more detailed than
          dwDetailLevel.

          Set the current selected LB item to the object named
          lpszDefaultObject, or to the default object specified in
          pPerfData if lpszDefaultObject is NULL.
*/
{  // LBLoadObjects
    UINT           i ;
    INT_PTR        iIndex ;
    PPERFOBJECT    pObject ;
    TCHAR          szObject [PerfObjectLen + 1] ;
    TCHAR          szDefaultObject [PerfObjectLen + 1] ;

    LBReset (hWndLB) ;
    strclr (szDefaultObject) ;

    pObject = FirstObject (pPerfData) ;

    for (i = 0, pObject = FirstObject (pPerfData) ;
        i < pPerfData->NumObjectTypes ;
        i++, pObject = NextObject (pObject)) {  // for
        if (pObject->DetailLevel <= dwDetailLevel) {  // if
            strclr (szObject) ;
            QueryPerformanceName (pSysInfo, pObject->ObjectNameTitleIndex,
                                  0, PerfObjectLen, szObject, FALSE) ;

            // if szObject is not empty, add it to the listbox
            if (!strsame(szObject, NULL_NAME)) {
                iIndex = LBAdd (hWndLB, szObject) ;
                LBSetData (hWndLB, iIndex, (DWORD_PTR) pObject) ;

                if ((LONG)pObject->ObjectNameTitleIndex == pPerfData->DefaultObject)
                    lstrcpy (szDefaultObject, szObject) ;
            } // if szObject is not empty
        }
    }  // for


    if (bIncludeAll) {
        StringLoad (IDS_ALLOBJECTS, szObject) ;
        LBInsert (hWndLB, 0, szObject) ;
        LBSetData (hWndLB, iIndex, 0) ;
        // assume "ALL" is default unless overridden
        lstrcpy (szDefaultObject, szObject) ;
    }

    if (lpszDefaultObject)
        lstrcpy (szDefaultObject, lpszDefaultObject) ;

    iIndex = LBFind (hWndLB, szDefaultObject) ;
    LBSetSelection (hWndLB, (iIndex != LB_ERR) ? iIndex : 0) ;

    return (i) ;
}  // LBLoadObjects


/***************************************************************************\
* GetObjectDef()
*
* Entry: pointer to data block and the number of the object type
* Exit:  returns a pointer to the specified object type definition
*
\***************************************************************************/

PERF_OBJECT_TYPE *
GetObjectDef(
            PERF_DATA_BLOCK *pDataBlock,
            DWORD NumObjectType
            )
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef;

    pObjectDef = FirstObject(pDataBlock);

    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        if ( NumTypeDef == NumObjectType ) {

            return pObjectDef;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

/***************************************************************************\
* GetObjectDefByTitleIndex()
*
* Entry: pointer to data block and the title index of the object type
* Exit:  returns a pointer to the specified object type definition
*
\***************************************************************************/

PERF_OBJECT_TYPE *
GetObjectDefByTitleIndex(
                        PERF_DATA_BLOCK *pDataBlock,
                        DWORD ObjectTypeTitleIndex
                        )
{
    DWORD NumTypeDef;

    PERF_OBJECT_TYPE *pObjectDef;

    pObjectDef = FirstObject(pDataBlock);

    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        if ( pObjectDef->ObjectNameTitleIndex == ObjectTypeTitleIndex ) {

            return pObjectDef;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

/***************************************************************************\
* GetObjectDefByName()
*
* Entry: pointer to data block and the name of the object type
* Exit:  returns a pointer to the specified object type definition
*
\***************************************************************************/

PERF_OBJECT_TYPE *
GetObjectDefByName(
                  PPERFSYSTEM pSystem,
                  PERF_DATA_BLOCK *pDataBlock,
                  LPTSTR pObjectName
                  )
{
    DWORD NumTypeDef;
    TCHAR szObjectName [PerfObjectLen + 1] ;

    PERF_OBJECT_TYPE *pObjectDef;

    pObjectDef = FirstObject(pDataBlock);
    for ( NumTypeDef = 0;
        NumTypeDef < pDataBlock->NumObjectTypes;
        NumTypeDef++ ) {

        ObjectName (pSystem, pObjectDef, szObjectName, PerfObjectLen) ;
        if (strsame (szObjectName, pObjectName) ) {

            return pObjectDef;
        }
        pObjectDef = NextObject(pObjectDef);
    }
    return 0;
}

/***************************************************************************\
* GetCounterDef()
*
* Entry: pointer to object type definition the number of the Counter
*        definition
* Exit:  returns a pointer to the specified Counter definition
*
\***************************************************************************/

PERF_COUNTER_DEFINITION *
GetCounterDef(
             PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
             DWORD NumCounter
             )
{
    DWORD NumCtrDef;

    PERF_COUNTER_DEFINITION *pCounterDef;

    pCounterDef = FirstCounter(pObjectDef);

    for ( NumCtrDef = 0;
        NumCtrDef < pObjectDef->NumCounters;
        NumCtrDef++ ) {

        if ( NumCtrDef == NumCounter ) {

            return pCounterDef;
        }
        pCounterDef = NextCounter(pCounterDef);
    }
    return 0;
}

/***************************************************************************\
* GetCounterNumByTitleIndex()
*
* Entry: pointer to object type definition and the title index of
*        the name of the Counter definition
* Exit:  returns the number of the specified Counter definition
*
\***************************************************************************/

LONG
GetCounterNumByTitleIndex(
                         PERF_OBJECT_TYPE *pObjectDef,
                         DWORD CounterTitleIndex
                         )
{
    DWORD NumCtrDef;

    PERF_COUNTER_DEFINITION *pCounterDef;

    pCounterDef = FirstCounter(pObjectDef);

    for ( NumCtrDef = 0;
        NumCtrDef < pObjectDef->NumCounters;
        NumCtrDef++ ) {

        if ( pCounterDef->CounterNameTitleIndex == CounterTitleIndex ) {

            return NumCtrDef;
        }
        pCounterDef = NextCounter(pCounterDef);
    }
    return 0;
}

/***************************************************************************\
* GetCounterData()
*
* Entry: pointer to object definition and number of counter, must be
*        an object with no instances
* Exit:  returns a pointer to the data
*
\***************************************************************************/

PVOID
GetCounterData(
              PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
              PERF_COUNTER_DEFINITION *pCounterDef
              )
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pObjectDef +
                                       pObjectDef->DefinitionLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}

/***************************************************************************\
* GetInstanceCounterData()
*
* Entry: pointer to object definition and number of counter, and a pointer
*        to the instance for which the data is to be retrieved
* Exit:  returns a pointer to the data
*
\***************************************************************************/

PVOID
GetInstanceCounterData(
                      PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
                      PERF_INSTANCE_DEFINITION *pInstanceDef,
                      PERF_COUNTER_DEFINITION *pCounterDef
                      )
{

    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pInstanceDef +
                                       pInstanceDef->ByteLength);

    return (PVOID)((PCHAR)pCtrBlock + pCounterDef->CounterOffset);
}

/***************************************************************************\
* GetNextInstance()
*
* Entry: pointer to instance definition
* Exit:  returns a pointer to the next instance definition.  If none,
*        points to byte past this instance
*
\***************************************************************************/

PERF_INSTANCE_DEFINITION *
GetNextInstance(
               PERF_INSTANCE_DEFINITION *pInstDef
               )
{
    PERF_COUNTER_BLOCK *pCtrBlock;

    pCtrBlock = (PERF_COUNTER_BLOCK *)
                ((PCHAR) pInstDef + pInstDef->ByteLength);

    return (PERF_INSTANCE_DEFINITION *)
    ((PCHAR) pCtrBlock + pCtrBlock->ByteLength);
}

/***************************************************************************\
* GetInstance()
*
* Entry: pointer to object type definition, the name of the instance,
*        the name of the parent object type, and the parent instance index.
*        The name of the parent object type is NULL if no parent.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PERF_INSTANCE_DEFINITION *
GetInstance(
           PERF_OBJECT_TYPE *pObjectDef,
           LONG InstanceNumber
           )
{

    PERF_INSTANCE_DEFINITION *pInstanceDef;
    LONG NumInstance;

    if (!pObjectDef) {
        return 0;
    }

    pInstanceDef = FirstInstance(pObjectDef);

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {
        if ( InstanceNumber == NumInstance ) {
            return pInstanceDef;
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }

    return 0;
}

/***************************************************************************\
* GetInstanceByUniqueID()
*
* Entry: pointer to object type definition, and
*        the unique ID of the instance.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PERF_INSTANCE_DEFINITION *
GetInstanceByUniqueID(
                     PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
                     LONG UniqueID,
                     DWORD dwIndex
                     )
{

    PERF_INSTANCE_DEFINITION *pInstanceDef;
    DWORD   dwLocalIndex;

    LONG NumInstance;

    pInstanceDef = FirstInstance(pObjectDef);
    dwLocalIndex = dwIndex;

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {

        if ( pInstanceDef->UniqueID == UniqueID ) {
            if (dwLocalIndex == 0) {
                return pInstanceDef;
            } else {
                --dwLocalIndex;
            }
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }
    return 0;
}


/***************************************************************************\
* GetInstanceByNameUsingParentTitleIndex()
*
* Entry: pointer to object type definition, the name of the instance,
*        and the name of the parent instance.
*        The name of the parent instance is NULL if no parent.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PERF_INSTANCE_DEFINITION *
GetInstanceByNameUsingParentTitleIndex(
                                      PERF_DATA_BLOCK *pDataBlock,
                                      PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
                                      LPTSTR pInstanceName,
                                      LPTSTR pParentName,
                                      DWORD   dwIndex
                                      )
{
    BOOL fHaveParent;
    PERF_OBJECT_TYPE *pParentObj;

    PERF_INSTANCE_DEFINITION  *pParentInst,
    *pInstanceDef;

    LONG   NumInstance;
    TCHAR  InstanceName[256];
    DWORD    dwLocalIndex;


    fHaveParent = FALSE;
    pInstanceDef = FirstInstance(pObjectDef);
    dwLocalIndex = dwIndex;

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {

        GetInstanceNameStr(pInstanceDef,InstanceName);
        if ( lstrcmpi(InstanceName, pInstanceName) == 0 ) {

            // Instance name matches

            if ( pParentName == NULL ) {

                // No parent, we're done if this is the right "copy"

                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }

            } else {

                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                                                     pDataBlock,
                                                     pInstanceDef->ParentObjectTitleIndex);

                if (!pParentObj) {
                    // can't locate the parent, forget it
                    break ;
                }

                // Object type of parent found; now find parent
                // instance

                pParentInst = GetInstance(pParentObj,
                                          pInstanceDef->ParentObjectInstance);

                if (!pParentInst) {
                    // can't locate the parent instance, forget it
                    break ;
                }

                GetInstanceNameStr(pParentInst,InstanceName);
                if ( lstrcmpi(InstanceName, pParentName) == 0 ) {

                    // Parent Instance Name matches that passed in
                    if (dwLocalIndex == 0) {
                        return pInstanceDef;
                    } else {
                        --dwLocalIndex;
                    }
                }
            }
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }
    return 0;
}

/***************************************************************************\
* GetInstanceByName()
*
* Entry: pointer to object type definition, the name of the instance,
*        and the name of the parent instance.
*        The name of the parent instance is NULL if no parent.
* Exit:  returns a pointer to the specified instance definition
*
\***************************************************************************/

PERF_INSTANCE_DEFINITION *
GetInstanceByName(
                 PERF_DATA_BLOCK *pDataBlock,
                 PERF_OBJECT_TYPE UNALIGNED *pObjectDef,
                 LPTSTR pInstanceName,
                 LPTSTR pParentName,
                 DWORD   dwIndex
                 )
{
    BOOL fHaveParent;

    PERF_OBJECT_TYPE *pParentObj;

    PERF_INSTANCE_DEFINITION *pParentInst,
    *pInstanceDef;

    LONG  NumInstance;
    TCHAR  InstanceName[256];
    DWORD  dwLocalIndex;

    fHaveParent = FALSE;
    pInstanceDef = FirstInstance(pObjectDef);
    dwLocalIndex = dwIndex;

    for ( NumInstance = 0;
        NumInstance < pObjectDef->NumInstances;
        NumInstance++ ) {

        GetInstanceNameStr(pInstanceDef,InstanceName);
        if ( lstrcmpi(InstanceName, pInstanceName) == 0 ) {

            // Instance name matches

            if ( !pInstanceDef->ParentObjectTitleIndex ) {

                // No parent, we're done

                if (dwLocalIndex == 0) {
                    return pInstanceDef;
                } else {
                    --dwLocalIndex;
                }

            } else {

                // Must match parent as well

                pParentObj = GetObjectDefByTitleIndex(
                                                     pDataBlock,
                                                     pInstanceDef->ParentObjectTitleIndex);

                // Object type of parent found; now find parent
                // instance
                if (pParentObj == NULL)
                    break;

                pParentInst = GetInstance(pParentObj,
                                          pInstanceDef->ParentObjectInstance);

                if (pParentInst == NULL)
                    break;
                GetInstanceNameStr(pParentInst,InstanceName);
                if ( lstrcmpi(InstanceName, pParentName) == 0 ) {
                    // Parent Instance Name matches that passed in

                    if (dwLocalIndex == 0) {
                        return pInstanceDef;
                    } else {
                        --dwLocalIndex;
                    }
                }
            }
        }
        pInstanceDef = GetNextInstance(pInstanceDef);
    }
    return 0;
}  // GetInstanceByName


BOOL
FailedLineData (
               PPERFDATA pPerfData,
               PLINE pLine
               )
/*
    This routine handles the case where there is no data for a
    system.
*/

{  // FailedLineData
    LARGE_INTEGER     liDummy ;

    // System no longer exists.
    liDummy.LowPart = liDummy.HighPart = 0;
    if (pLine->lnCounterType == PERF_COUNTER_TIMER_INV) {
        // Timer inverse with Performance Counter as timer
        pLine->lnaOldCounterValue[0] = pLine->lnOldTime ;
        pLine->lnaCounterValue[0] = pLine->lnNewTime ;
    } else if (pLine->lnCounterType == PERF_100NSEC_TIMER_INV ||
               pLine->lnCounterType == PERF_100NSEC_MULTI_TIMER_INV) {
        // Timer inverse with System Time as timer
        pLine->lnaOldCounterValue[0] = pLine->lnOldTime100Ns ;
        pLine->lnaCounterValue[0] = pLine->lnNewTime100Ns ;
    } else {
        // Normal timer
        pLine->lnaOldCounterValue[0] =
        pLine->lnaCounterValue[0] =
        pLine->lnaOldCounterValue[1] =
        pLine->lnaCounterValue[1] = liDummy ;
    }
    return TRUE ;

}  // FailedLineData


BOOL
UpdateLineData (
               PPERFDATA pPerfData,
               PLINE pLine,
               PPERFSYSTEM pSystem
               )
/*
   Assert:        pPerfData holds the performance data for the same
          system as pLine.
*/
{  // UpdateLineData
    PERF_OBJECT_TYPE UNALIGNED *pObject ;
    PPERFINSTANCEDEF  pInstanceDef ;
    PPERFCOUNTERDEF   pCounterDef ;
    PPERFCOUNTERDEF   pCounterDef2 ;
    PDWORD            pCounterValue ;
    PDWORD            pCounterValue2 ;
    UINT              iCounterIndex ;
    LARGE_INTEGER     liDummy[2] ;

    // Use Object time units if available, otherwise use system
    // performance timer

    pLine->lnOldTime = pLine->lnNewTime;

    pLine->lnOldTime100Ns = pLine->lnNewTime100Ns;
    pLine->lnNewTime100Ns = pPerfData->PerfTime100nSec;

    pLine->lnPerfFreq = pPerfData->PerfFreq ;

    pObject = GetObjectDefByTitleIndex(
                                      pPerfData,
                                      pLine->lnObject.ObjectNameTitleIndex);

    if (!pObject) {
        // Object Type no longer exists.  This is possible if we are
        // looking at a log file which has not always collected all
        // the same data, such as appending measurements of different
        // object types.

        pCounterValue =
        pCounterValue2 = (PDWORD) liDummy;
        liDummy[0].LowPart = liDummy[0].HighPart = 0;


        pLine->lnNewTime = pPerfData->PerfTime;

        if (pLine->lnCounterType == PERF_COUNTER_TIMER_INV) {
            // Timer inverse with Performance Counter as timer
            pLine->lnaOldCounterValue[0] = pLine->lnOldTime ;
            pLine->lnaCounterValue[0] = pLine->lnNewTime ;
        } else if (pLine->lnCounterType == PERF_100NSEC_TIMER_INV ||
                   pLine->lnCounterType == PERF_100NSEC_MULTI_TIMER_INV) {
            // Timer inverse with System Time as timer
            pLine->lnaOldCounterValue[0] = pLine->lnOldTime100Ns ;
            pLine->lnaCounterValue[0] = pLine->lnNewTime100Ns ;
        } else {
            // Normal timer or counter
            pLine->lnaOldCounterValue[0] =
            pLine->lnaCounterValue[0] =
            pLine->lnaOldCounterValue[1] =
            pLine->lnaCounterValue[1] = liDummy[0] ;
        }
        return TRUE ;
    } else {
        pCounterDef = &pLine->lnCounterDef ;

        //      if (pObject->PerfFreq.QuadPart > 0 ) {
        if (pCounterDef->CounterType & PERF_OBJECT_TIMER) {
            pLine->lnNewTime = pObject->PerfTime;
        } else {
            pLine->lnNewTime = pPerfData->PerfTime;
        }

        iCounterIndex = CounterIndex (pCounterDef, pObject) ;

        // Get second counter, only if we are not at
        // the end of the counters; some computations
        // require a second counter

        if (iCounterIndex < pObject->NumCounters-1 && iCounterIndex != -1) {
            pCounterDef2 = GetCounterDef(pObject, iCounterIndex+1);
        } else {
            pCounterDef2 = NULL;
        }

        if (pObject->NumInstances > 0) {

            if ( pLine->lnUniqueID != PERF_NO_UNIQUE_ID ) {
                pInstanceDef = GetInstanceByUniqueID(pObject,
                                                     pLine->lnUniqueID,
                                                     pLine->dwInstanceIndex);
            } else {

                pInstanceDef =
                GetInstanceByNameUsingParentTitleIndex(
                                                      pPerfData,
                                                      pObject,
                                                      pLine->lnInstanceName,
                                                      pLine->lnPINName,
                                                      pLine->dwInstanceIndex);
            }

            if (pInstanceDef) {
                pLine->lnInstanceDef = *pInstanceDef;
                pCounterValue = GetInstanceCounterData(pObject,
                                                       pInstanceDef,
                                                       pCounterDef);
                if ( pCounterDef2 ) {
                    pCounterValue2 = GetInstanceCounterData(pObject,
                                                            pInstanceDef,
                                                            pCounterDef2);
                }
            } else {
                pCounterValue =
                pCounterValue2 = (PDWORD) liDummy;
                liDummy[0].LowPart = liDummy[0].HighPart = 0;
                liDummy[1].LowPart = liDummy[1].HighPart = 0;
            }

            // Got everything...

        } // instances exist, look at them for counter blocks

        else {
            pCounterValue = GetCounterData(pObject, pCounterDef);
            if (pCounterDef2) {
                pCounterValue2 = GetCounterData(pObject, pCounterDef2);
            }

        } // counter def search when no instances
    }

    pLine->lnaOldCounterValue[0] = pLine->lnaCounterValue[0] ;

    if (pLine->lnCounterLength <= 4) {
        // HighPart was initialize to 0
        pLine->lnaCounterValue[0].LowPart = *pCounterValue;
    } else {
        pLine->lnaCounterValue[0] = *(LARGE_INTEGER UNALIGNED *) pCounterValue;
    }

    // Get second counter, only if we are not at
    // the end of the counters; some computations
    // require a second counter

    if ( pCounterDef2 ) {
        pLine->lnaOldCounterValue[1] =
        pLine->lnaCounterValue[1] ;
        if (pCounterDef2->CounterSize <= 4) {
            // HighPart was initialize to 0
            pLine->lnaCounterValue[1].LowPart = *pCounterValue2;
        } else
            pLine->lnaCounterValue[1] =
            *((LARGE_INTEGER UNALIGNED *) pCounterValue2);
    }
    return (TRUE) ;
}  // UpdateLineData



BOOL
UpdateSystemData (
                 PPERFSYSTEM pSystem,
                 PPERFDATA *ppPerfData
                 )
{  // UpdateSystemData
#define        PERF_SYSTEM_TIMEOUT (60L * 1000L)
    long       lError ;
    DWORD      Status ;
    SIZE_T     Size;

    if (!ppPerfData)
        return (FALSE) ;

    while (TRUE) {
        if (pSystem->FailureTime) {
            if (GetTickCount() > pSystem->FailureTime + PERF_SYSTEM_TIMEOUT) {
                // free any memory hanging off this system
                SystemFree (pSystem, FALSE) ;

                // get the registry info
                pSystem->sysDataKey = OpenSystemPerfData(pSystem->sysName) ;

                Status = !ERROR_SUCCESS ;
                if (pSystem->sysDataKey) {
                    Status = GetSystemNames(pSystem);
                }

                if (Status != ERROR_SUCCESS) {
                    // something wrong in getting the registry info,
                    // remote system must be still down (??)
                    pSystem->FailureTime = GetTickCount();

                    // Free any memory that may have created
                    SystemFree (pSystem, FALSE) ;

                    return (FALSE) ;
                }

                // time to check again
                pSystem->FailureTime = 0 ;
            } else {
                // not time to check again
                return (FALSE) ;
            }
        }

        if (pSystem->FailureTime == 0 ) {
            Size = MemorySize (*ppPerfData);
            lError = GetSystemPerfData (pSystem->sysDataKey,
                                        pSystem->lpszValue,
                                        *ppPerfData,
                                        &Size) ;
            if ((!lError) &&
                (Size > 0) &&
                (*ppPerfData)->Signature[0] == (WCHAR)'P' &&
                (*ppPerfData)->Signature[1] == (WCHAR)'E' &&
                (*ppPerfData)->Signature[2] == (WCHAR)'R' &&
                (*ppPerfData)->Signature[3] == (WCHAR)'F' )
                return (TRUE) ;

            if (lError == ERROR_MORE_DATA) {
                *ppPerfData = MemoryResize (*ppPerfData,
                                            MemorySize (*ppPerfData) +
                                            dwPerfDataIncrease) ;
                if (!*ppPerfData) {
                    pSystem->FailureTime = GetTickCount();
                    return (FALSE) ;
                }
            } else {
                pSystem->FailureTime = GetTickCount();
                return (FALSE) ;
            }  // else
        } // if
    }  // while
}  // UpdateSystemData



BOOL
FailedLinesForSystem (
                     LPTSTR lpszSystem,
                     PPERFDATA pPerfData,
                     PLINE pLineFirst
                     )
{  // FailedLinesForSystem
    PLINE          pLine ;
    BOOL           bMatchFound = FALSE ;   // no line from this system

    for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {  // for pLine
        if (strsamei (lpszSystem, pLine->lnSystemName)) {
            FailedLineData (pPerfData, pLine) ;
            if (pLine->bFirstTime) {
                pLine->bFirstTime-- ;
            }
            bMatchFound = TRUE ; // one or more lines from this system
        }
    }  // for pLine

    return (bMatchFound) ;
}


BOOL
UpdateLinesForSystem (
                     LPTSTR lpszSystem,
                     PPERFDATA pPerfData,
                     PLINE pLineFirst,
                     PPERFSYSTEM pSystem
                     )
{  // UpdateLinesForSystem
    PLINE          pLine ;
    BOOL           bMatchFound = FALSE ;   // no line from this system

    for (pLine = pLineFirst ;
        pLine ;
        pLine = pLine->pLineNext) {  // for pLine
        if (strsamei (lpszSystem, pLine->lnSystemName)) {
            UpdateLineData (pPerfData, pLine, pSystem) ;
            if (pLine->bFirstTime) {
                pLine->bFirstTime-- ;
            }
            bMatchFound = TRUE ; // one or more lines from this system
        }
    }  // for pLine

    return (bMatchFound) ;
}


BOOL
PerfDataInitializeInstance (void)
{
    //   pPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ;
    //   return (pPerfData != NULL) ;
    return (TRUE);
}

NTSTATUS
AddNamesToArray (
                LPTSTR lpNames,
                DWORD    dwLastId,
                LPWSTR   *lpCounterId
                )
{
    LPWSTR      lpThisName;
    LPWSTR      lpStopString;
    DWORD       dwThisCounter;
    NTSTATUS    Status = ERROR_SUCCESS;

    for (lpThisName = lpNames;
        *lpThisName;
        lpThisName += (lstrlen(lpThisName)+1) ) {

        // first string should be an integer (in decimal unicode digits)
        dwThisCounter = wcstoul(lpThisName, &lpStopString, 10);

        if ((dwThisCounter == 0) || (dwThisCounter == ULONG_MAX)) {
            Status += 1;
            goto ADD_BAILOUT;  // bad entry
        }

        // point to corresponding counter name

        lpThisName += (lstrlen(lpThisName)+1);

        if (dwThisCounter <= dwLastId) {

            // and load array element;

            lpCounterId[dwThisCounter] = lpThisName;

        }
    }

    ADD_BAILOUT:
    return (Status) ;
}

// try the new way of getting data...

BOOL
UpdateLines (
            PPPERFSYSTEM ppSystemFirst,
            PLINE pLineFirst
            )
{
    PPERFSYSTEM       pSystem ;
    int               iNoUseSystemDetected = 0 ;
    int               NumberOfSystems = 0 ;
    DWORD             WaitStatus ;
    HANDLE            *lpPacketHandles ;

    // allocate the handle array for multiple wait
    if (NumberOfHandles == 0) {
        NumberOfHandles = MAXIMUM_WAIT_OBJECTS ;
        lpHandles = (HANDLE *) MemoryAllocate (NumberOfHandles * sizeof (HANDLE)) ;
        if (!lpHandles) {
            // out of memory, can't go on
            NumberOfHandles = 0 ;
            return FALSE ;
        }
    }


    for (pSystem = *ppSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {  // for

        // lock the state data mutex, should be quick unless this thread
        // is still getting data from last time
        if (pSystem->hStateDataMutex == 0)
            continue ;

        WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 100L);
        if (WaitStatus == WAIT_OBJECT_0) {
            ResetEvent (pSystem->hPerfDataEvent) ;
            pSystem->StateData = WAIT_FOR_PERF_DATA ;

            // add this to the wait
            if (NumberOfSystems >= NumberOfHandles) {
                NumberOfHandles += MAXIMUM_WAIT_OBJECTS ;
                lpHandles = (HANDLE *) MemoryResize (
                                                    lpHandles,
                                                    NumberOfHandles * sizeof (HANDLE)) ;
                if (!lpHandles) {
                    // out of memory, can't go on
                    NumberOfHandles = 0 ;
                    return FALSE ;
                }
            }

            lpHandles [NumberOfSystems] = pSystem->hPerfDataEvent ;
            NumberOfSystems++ ;

            // Send Message to thread to take a data sample
            PostThreadMessage (
                              pSystem->dwThreadID,
                              WM_GET_PERF_DATA,
                              (WPARAM)0,
                              (LPARAM)0) ;

            ReleaseMutex(pSystem->hStateDataMutex);
        }
    }

    // wait for all the data
    if (NumberOfSystems) {
        // increase timeout if we are monitoring lots of systems
        // For every additional 5 systems, add 5 more seconds
        lpPacketHandles = lpHandles ;
        do {
            WaitStatus = WaitForMultipleObjects (
                                                min (NumberOfSystems, MAXIMUM_WAIT_OBJECTS),
                                                lpPacketHandles,
                                                TRUE,       // wait for all objects
                                                DataTimeOut + (NumberOfSystems / 5) * DEFAULT_DATA_TIMEOUT);

            if (WaitStatus == WAIT_TIMEOUT ||
                NumberOfSystems <= MAXIMUM_WAIT_OBJECTS) {
                //if (WaitStatus == WAIT_TIMEOUT)
                //   mike2(TEXT("WaitTimeOut for %ld systems\n"), NumberOfSystems) ;

                break ;
            }

            // more systems --> more to wait
            NumberOfSystems -= MAXIMUM_WAIT_OBJECTS ;
            lpPacketHandles += MAXIMUM_WAIT_OBJECTS ;
        } while (TRUE) ;

        for (pSystem = *ppSystemFirst ;
            pSystem ;
            pSystem = pSystem->pSystemNext) {  // for

            if (pSystem->hStateDataMutex == 0)
                continue ;

            // lock the state data mutex
            WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 100L);
            if (WaitStatus == WAIT_OBJECT_0) {
                if (pSystem->StateData != PERF_DATA_READY) {
                    if (!FailedLinesForSystem (pSystem->sysName,
                                               pSystem->pSystemPerfData,
                                               pLineFirst)) {
                        if (!bAddLineInProgress) {
                            // mark this system as no-longer-needed
                            iNoUseSystemDetected++ ;
                            pSystem->bSystemNoLongerNeeded = TRUE ;
                        }
                    }
                } else {
                    if (!UpdateLinesForSystem (pSystem->sysName,
                                               pSystem->pSystemPerfData,
                                               pLineFirst,
                                               pSystem)) {
                        if (!bAddLineInProgress) {
                            // mark this system as no-longer-needed
                            iNoUseSystemDetected++ ;
                            pSystem->bSystemNoLongerNeeded = TRUE ;
                        }
                    }
                }
                pSystem->StateData = IDLE_STATE ;
                ReleaseMutex(pSystem->hStateDataMutex);
            } else {
                if (!FailedLinesForSystem (pSystem->sysName,
                                           pSystem->pSystemPerfData,
                                           pLineFirst)) {
                    if (!bAddLineInProgress) {
                        // mark this system as no-longer-needed
                        iNoUseSystemDetected++ ;
                        pSystem->bSystemNoLongerNeeded = TRUE ;
                    }
                }
            }
        }

        // check for un-used systems
        if (iNoUseSystemDetected) {
            // some unused system(s) detected.
            DeleteUnusedSystems (ppSystemFirst, iNoUseSystemDetected) ;
        }
    }

    return (TRUE) ;
}  // UpdateLines

void
PerfDataThread (
               PPERFSYSTEM pSystem
               )
{
    MSG      msg ;
    BOOL     bGetPerfData ;
    DWORD    WaitStatus ;

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (LOWORD(msg.message) == WM_GET_PERF_DATA) {

            // this system has been marked as no long used,
            // forget about getting data and continue until
            // we get to the WM_FREE_SYSTEM msg
            if (pSystem->bSystemNoLongerNeeded)
                continue ;

            bGetPerfData = FALSE ;

            if (!bAddLineInProgress ||
                (pSystem->lpszValue &&
                 !strsame (pSystem->lpszValue, L"Global"))) {
                bGetPerfData = UpdateSystemData (pSystem, &(pSystem->pSystemPerfData)) ;
            }

            WaitStatus = WaitForSingleObject(pSystem->hStateDataMutex, 1000L);
            if (WaitStatus == WAIT_OBJECT_0) {
                if (pSystem->StateData == WAIT_FOR_PERF_DATA) {
                    pSystem->StateData = bGetPerfData ?
                                         PERF_DATA_READY : PERF_DATA_FAIL ;
                } else {
                    //mike2(TEXT("Thread - System = %s, WaitStatus = %d\n"),
                    //pSystem->sysName, WaitStatus) ;
                }
                ReleaseMutex(pSystem->hStateDataMutex);
                SetEvent (pSystem->hPerfDataEvent) ;
            }
        }  // WM_GET_PERF_DATA MSG

        else if (LOWORD(msg.message) == WM_FREE_SYSTEM) {
            //mike2(TEXT("Thread - System = %s closing\n"),
            //pSystem->sysName) ;
            // do the memory cleanup during SystemFree stage
            // cleanup all the data collection variables
            if (pSystem->hPerfDataEvent)
                CloseHandle (pSystem->hPerfDataEvent) ;

            if (pSystem->hStateDataMutex)
                CloseHandle (pSystem->hStateDataMutex) ;

            if (pSystem->pSystemPerfData)
                MemoryFree (pSystem->pSystemPerfData);

            if (pSystem->lpszValue) {
                MemoryFree (pSystem->lpszValue);
                pSystem->lpszValue = NULL ;
            }

            CloseHandle (pSystem->hThread);

            MemoryFree (pSystem) ;
            break ;  // get out of message loop
        }  // WM_FREE_SYSTEM MSG
    }  // GetMessage Loop

    ExitThread (TRUE) ;
}  // PerfDataThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\perfmops.c ===
#include "setedit.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <uiexport.h>
#include <stdio.h>         // for sprintf
#include <locale.h>        // for setlocale
#include "utils.h"

#include "perfdata.h"      // for OpenSystemPerfData
#include "grafdata.h"      // for GraphInsertLine
#include "fileopen.h"      // for FileGetName
#include "fileutil.h"      // for FileRead etc
#include "command.h"       // for PrepareMenu
#include "system.h"
#include "globals.h"
#include "pmemory.h"       // for MemoryFree
#include "status.h"        // for StatusLineReady
#include "pmhelpid.h"

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

// globals used for International Date and Time formats
enum DATE_STYLE {
    YEAR_FIRST,       // YYMMDD
    DAY_FIRST,        // DDMMYY
    MONTH_FIRST       // MMDDYY
} DateStyle ;

TCHAR szInternational[] = TEXT("Intl") ;
TCHAR sz1159[6] ;       // AM String
TCHAR sz2359[6] ;       // PM String
int   iTime ;           // = 0 for 12-hour format,  <> 0 for 24-hour format
int   YearCharCount ;   // = 4 for 1990, = 2 for 90

TCHAR szDateFormat[ResourceStringLen] ;
TCHAR szTimeFormat[ResourceStringLen] ;   // time format including msec
TCHAR szTimeFormat1[ResourceStringLen] ;  // time format without msec

TCHAR LeadingZeroStr [] = TEXT("%02d") ;
TCHAR NoLeadingZeroStr [] = TEXT("%d") ;

TCHAR szDecimal [2] ;
TCHAR szCurrentDecimal [2] ;

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define SIZE_OF_BIGGEST_INTEGER  16
// #define SIZE_OF_BIGGEST_INTEGER (16*sizeof(WCHAR))


//==========================================================================//
//                                  Typedefs                                //
//==========================================================================//

BOOL AddObjectToSystem ( PLINE , PPERFSYSTEM );


HWND
PerfmonViewWindow (void)
/*
   Effect:        Return the current data window, i.e. the window currently
                  visible as the client area of Perfmon.  This is either a
                  chart window.
*/
{
    return (hWndGraph) ;
}




#define szChooseComputerLibrary     TEXT("ntlanman.dll")
#define szChooseComputerFunction    "I_SystemFocusDialog"


BOOL
ChooseComputer (
               HWND hWndParent,
               LPTSTR lpszComputer
               )
/*
   Effect:        Display the choose Domain/Computer dialog provided by
                  network services.  If the user selects a computer,
                  copy the computer name to lpszComputer and return
                  nonnull. If the user cancels, return FALSE.

   Internals:     This dialog and code is currently not an exported
                  routine regularly found on any user's system. Right
                  now, we dynamically load and call the routine.

                  This is definitely temporary code that will be
                  rewritten when NT stabilizes. The callers of this
                  routine, however, will not need to be modified.

                  Also, the Domain/Computer dialog currently allows
                  a domain to be selected, which we cannot use. We
                  therefore loop until the user cancels or selects
                  a computer, putting up a message if the user selects
                  a domain.

   Assert:        lpszComputer is at least MAX_SYSTEM_NAME_LENGTH + 1
                  characters.
*/
{
    BOOL                     bSuccess ;
    WCHAR                    wszWideComputer[MAX_COMPUTERNAME_LENGTH + 3] ;
    HLIBRARY                 hLibrary ;
    LPFNI_SYSTEMFOCUSDIALOG  lpfnChooseComputer ;
    LONG                     lError ;

    // bring up the select network computer dialog
    hLibrary = LoadLibrary (szChooseComputerLibrary) ;
    if (!hLibrary || hLibrary == INVALID_HANDLE_VALUE) {
        return (FALSE) ;
    }

    lpfnChooseComputer = (LPFNI_SYSTEMFOCUSDIALOG)
                         GetProcAddress (hLibrary, szChooseComputerFunction) ;
    if (!lpfnChooseComputer) {
        FreeLibrary (hLibrary) ;
        return (FALSE) ;
    }

    lError = (*lpfnChooseComputer) (hWndParent,
                                    FOCUSDLG_SERVERS_ONLY | FOCUSDLG_BROWSE_ALL_DOMAINS,
                                    wszWideComputer,
                                    sizeof(wszWideComputer) / sizeof(WCHAR),
                                    &bSuccess,
                                    pszHelpFile,
                                    HC_PM_idDlgSelectNetworkComputer) ;

    if (bSuccess) {
        lstrcpy (lpszComputer, wszWideComputer) ;
    }

    FreeLibrary (hLibrary) ;
    return (bSuccess) ;
}


void
SystemTimeDateString (
                     SYSTEMTIME *pSystemTime,
                     LPTSTR lpszDate
                     )
{
    int      wYear ;

    wYear = pSystemTime->wYear ;
    if (YearCharCount == 2) {
        wYear %= 100 ;
    }

    switch (DateStyle) {
        case YEAR_FIRST:
            TSPRINTF (lpszDate, szDateFormat,
                      wYear, pSystemTime->wMonth, pSystemTime->wDay) ;
            break ;

        case DAY_FIRST:
            TSPRINTF (lpszDate, szDateFormat,
                      pSystemTime->wDay, pSystemTime->wMonth, wYear) ;
            break ;

        case MONTH_FIRST:
            default:
            TSPRINTF (lpszDate, szDateFormat,
                      pSystemTime->wMonth, pSystemTime->wDay, wYear) ;
            break ;
    }
}


void
SystemTimeTimeString (
                     SYSTEMTIME *pSystemTime,
                     LPTSTR lpszTime,
                     BOOL   bOutputMsec
                     )
{
    int            iHour ;
    BOOL           bPM ;

    if (iTime) {
        // 24 hor format
        if (bOutputMsec) {
            TSPRINTF (lpszTime, szTimeFormat,
                      pSystemTime->wHour,
                      pSystemTime->wMinute,
                      (FLOAT)pSystemTime->wSecond +
                      (FLOAT)pSystemTime->wMilliseconds / (FLOAT) 1000.0) ;
        } else {
            TSPRINTF (lpszTime, szTimeFormat1,
                      pSystemTime->wHour,
                      pSystemTime->wMinute,
                      pSystemTime->wSecond) ;

        }
    } else {
        // 12 hour format
        iHour = pSystemTime->wHour ;
        bPM = (iHour >= 12) ;

        if (iHour > 12)
            iHour -= 12 ;
        else if (!iHour)
            iHour = 12 ;

        if (bOutputMsec) {
            TSPRINTF (lpszTime, szTimeFormat,
                      iHour, pSystemTime->wMinute,
                      (FLOAT)pSystemTime->wSecond +
                      (FLOAT)pSystemTime->wMilliseconds / (FLOAT) 1000.0 ,
                      bPM ? sz2359 : sz1159) ;
        } else {
            TSPRINTF (lpszTime, szTimeFormat1,
                      iHour, pSystemTime->wMinute,
                      pSystemTime->wSecond,
                      bPM ? sz2359 : sz1159) ;
        }
    }
}


void
ShowPerfmonMenu (
                BOOL bMenu
                )
{
    if (!bMenu) {
        WindowEnableTitle (hWndMain, FALSE) ;
        //      SetMenu(hWndMain, NULL) ;
    } else {
        WindowEnableTitle (hWndMain, TRUE) ;
        switch (iPerfmonView) {
            case IDM_VIEWCHART:
                SetMenu (hWndMain, hMenuChart) ;
                break ;

        }
    }

    if (bMenu != Options.bMenubar) {
        PrepareMenu (GetMenu (hWndMain)) ;
    }

    Options.bMenubar = bMenu ;
}



void
SmallFileSizeString (
                    int iFileSize,
                    LPTSTR lpszFileText
                    )
{
    if (iFileSize < 1000000)
        TSPRINTF (lpszFileText, TEXT(" %1.1fK "), ((FLOAT) iFileSize) / 1000.0f) ;
    else
        TSPRINTF (lpszFileText, TEXT(" %1.1fM "), ((FLOAT) iFileSize) / 1000000.0f) ;
}



BOOL
DoWindowDrag (
             HWND hWnd,
             LPARAM lParam
             )
{
    POINT    lPoint ;

    if (!Options.bMenubar && !IsZoomed (hWndMain)) {
        // convert lParam from client to screen
        lPoint.x = LOWORD (lParam) ;
        lPoint.y = HIWORD (lParam) ;
        ClientToScreen (hWnd, &lPoint) ;
        lParam = MAKELONG (lPoint.x, lPoint.y) ;
        SendMessage (hWndMain, WM_NCLBUTTONDOWN, HTCAPTION, lParam) ;
        return (TRUE) ;
    } else
        return (FALSE) ;
}



// Filetimes are in 100NS units
#define FILETIMES_PER_SECOND     10000000


int
SystemTimeDifference (
                     SYSTEMTIME *pst1,
                     SYSTEMTIME *pst2
                     )
{
    LARGE_INTEGER  li1, li2 ;
    LARGE_INTEGER  liDifference, liDifferenceSeconds ;
    DWORD          uRemainder ;
    int            RetInteger;
    BOOL           bNegative;

    li1.HighPart = li1.LowPart = 0 ;
    li2.HighPart = li2.LowPart = 0 ;

    SystemTimeToFileTime (pst1, (FILETIME *) &li1) ;
    SystemTimeToFileTime (pst2, (FILETIME *) &li2) ;

    // check for special cases when the time can be 0
    if (li2.HighPart == 0 && li2.LowPart == 0) {
        if (li1.HighPart == 0 && li1.LowPart == 0) {
            return 0 ;
        } else {
            return -INT_MAX ;
        }
    } else if (li1.HighPart == 0 && li1.LowPart == 0) {
        return INT_MAX ;
    }

    liDifference.QuadPart = li2.QuadPart - li1.QuadPart ;
    bNegative = liDifference.QuadPart < 0 ;

    // add the round-off factor before doing the division
    if (bNegative) {
        liDifferenceSeconds.QuadPart = (LONGLONG)(- FILETIMES_PER_SECOND / 2) ;
    } else {
        liDifferenceSeconds.QuadPart = (LONGLONG)(FILETIMES_PER_SECOND / 2) ;
    }


    liDifferenceSeconds.QuadPart = liDifferenceSeconds.QuadPart +
                                   liDifference.QuadPart ;

    liDifferenceSeconds.QuadPart = liDifferenceSeconds.QuadPart /
                                   FILETIMES_PER_SECOND;

    RetInteger = liDifferenceSeconds.LowPart;

    if (bNegative) {
        return (-RetInteger) ;
    } else {
        return (RetInteger) ;
    }
}


BOOL
InsertLine (
           PLINE pLine
           )
{

    BOOL bReturn;

    bReturn = ChartInsertLine (pGraphs, pLine) ;

    return bReturn;

}


void
SetPerfmonOptions (
                  OPTIONS *pOptions
                  )
{
    Options = *pOptions ;
    ShowPerfmonMenu (Options.bMenubar) ;
    SizePerfmonComponents () ;
    //   WindowSetTopmost (hWndMain, Options.bAlwaysOnTop) ;
}


void
ChangeSaveFileName (
                   LPTSTR szFileName,
                   int iPMView
                   )
{
    LPTSTR   *ppFullName ;
    LPTSTR   *ppFileName ;
    BOOL     errorInput = FALSE ;


    switch (iPMView) {
        case IDM_VIEWCHART:
            ppFileName = &pChartFileName ;
            ppFullName = &pChartFullFileName ;
            break ;


        default:
            errorInput = TRUE ;
            break ;
    }

    if (errorInput) {
        return ;
    }

    // release last filename
    if (*ppFullName) {
        MemoryFree (*ppFullName) ;
        *ppFileName = NULL ;
        *ppFullName = NULL ;
    }

    // allocate new file name and display it
    if (szFileName && (*ppFullName = StringAllocate (szFileName))) {
        *ppFileName = ExtractFileName (*ppFullName) ;
    }

    StatusLineReady (hWndStatus) ;

}


// define in Addline.c
extern   PLINESTRUCT       pLineEdit ;
#define  bEditLine (pLineEdit != NULL)


BOOL
RemoveObjectsFromSystem (
                        PPERFSYSTEM pSystem
                        )
{
    SIZE_T dwBufferSize = 0;

    if (ARGUMENT_PRESENT (pSystem)) {
        if (pSystem->lpszValue) {
            dwBufferSize = MemorySize (pSystem->lpszValue);
            memset (pSystem->lpszValue, 0, (size_t)dwBufferSize);
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }


}

BOOL
SetSystemValueNameToGlobal (
                           PPERFSYSTEM pSystem
                           )
{

    if (!bEditLine && ARGUMENT_PRESENT(pSystem)) {
        if (pSystem->lpszValue && RemoveObjectsFromSystem(pSystem)) {
            lstrcpy (
                    pSystem->lpszValue,
                    TEXT("Global ")) ;
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        return FALSE;
    }
}

void
CreatePerfmonSystemObjects ()
{
    ColorBtnFace = GetSysColor (COLOR_BTNFACE) ;
    hBrushFace = CreateSolidBrush (ColorBtnFace) ;
    hPenHighlight = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_BTNHIGHLIGHT)) ;
    hPenShadow = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_BTNSHADOW)) ;
}

void
DeletePerfmonSystemObjects ()
{
    if (hBrushFace) {
        DeleteBrush (hBrushFace) ;
        hBrushFace = 0 ;
    }
    if (hPenHighlight) {
        DeletePen (hPenHighlight) ;
        hPenHighlight = 0 ;
    }
    if (hPenShadow) {
        DeletePen (hPenShadow) ;
        hPenShadow = 0 ;
    }
}

// This routine count the number of the same charatcer in the input string
int
SameCharCount (
              LPTSTR pInputString
              )
{
    int      Count = 0 ;
    TCHAR    InputChar = *pInputString ;

    if (InputChar) {
        while (InputChar == *pInputString) {
            Count ++ ;
            pInputString ++ ;
        }
    }
    return (Count) ;
}

// create the format to be used in SystemTimeDateString()
BOOL
CreateDateFormat (
                 LPTSTR pShortDate
                 )
{
    int   iIndex ;
    int   iDayCount ;
    int   iMonthCount ;
    int   DateSeparatorCount ;
    TCHAR szDateSeparator [10] ;
    BOOL  bFirstLeading, bSecondLeading, bThirdLeading ;

    // get the date format based on the first char
    if (*pShortDate == TEXT('M') || *pShortDate == TEXT('m')) {
        DateStyle = MONTH_FIRST ;
    } else if (*pShortDate == TEXT('D') || *pShortDate == TEXT('d')) {
        DateStyle = DAY_FIRST ;
    } else if (*pShortDate == TEXT('Y') || *pShortDate == TEXT('y')) {
        DateStyle = YEAR_FIRST ;
    } else {
        // bad format
        return FALSE ;
    }

    bFirstLeading = bSecondLeading = bThirdLeading = FALSE ;

    switch (DateStyle) {
        case YEAR_FIRST:
            // YYYY-MM-DD
            YearCharCount = SameCharCount (pShortDate) ;
            pShortDate += YearCharCount ;
            DateSeparatorCount = SameCharCount (pShortDate) ;

            // get the separator string
            for (iIndex = 0; iIndex < DateSeparatorCount; iIndex ++) {
                szDateSeparator [iIndex] = *pShortDate++ ;
            }
            szDateSeparator [iIndex] = TEXT('\0') ;

            iMonthCount = SameCharCount (pShortDate) ;
            pShortDate += iMonthCount + DateSeparatorCount ;
            iDayCount = SameCharCount (pShortDate) ;

            if (YearCharCount == 2) {
                bFirstLeading = TRUE ;
            }

            if (iMonthCount == 2) {
                bSecondLeading = TRUE ;
            }

            if (iDayCount == 2) {
                bThirdLeading = TRUE ;
            }

            break ;

        case MONTH_FIRST:
            // MM-DD-YYYY
            iMonthCount = SameCharCount (pShortDate) ;
            pShortDate += iMonthCount ;
            DateSeparatorCount = SameCharCount (pShortDate) ;

            // get the separator string
            for (iIndex = 0; iIndex < DateSeparatorCount; iIndex ++) {
                szDateSeparator [iIndex] = *pShortDate++ ;
            }
            szDateSeparator [iIndex] = TEXT('\0') ;

            iDayCount = SameCharCount (pShortDate) ;
            pShortDate += iMonthCount + DateSeparatorCount ;
            YearCharCount = SameCharCount (pShortDate) ;


            if (iMonthCount == 2) {
                bFirstLeading = TRUE ;
            }

            if (iDayCount == 2) {
                bSecondLeading = TRUE ;
            }

            if (YearCharCount == 2) {
                bThirdLeading = TRUE ;
            }

            break ;

        case DAY_FIRST:
            // DD-MM-YYYY
            iDayCount = SameCharCount (pShortDate) ;
            pShortDate += iDayCount ;
            DateSeparatorCount = SameCharCount (pShortDate) ;

            // get the separator string
            for (iIndex = 0; iIndex < DateSeparatorCount; iIndex ++) {
                szDateSeparator [iIndex] = *pShortDate++ ;
            }
            szDateSeparator [iIndex] = TEXT('\0') ;

            iMonthCount = SameCharCount (pShortDate) ;
            pShortDate += iMonthCount + DateSeparatorCount ;
            YearCharCount = SameCharCount (pShortDate) ;

            if (iDayCount == 2) {
                bFirstLeading = TRUE ;
            }

            if (iMonthCount == 2) {
                bSecondLeading = TRUE ;
            }

            if (YearCharCount == 2) {
                bThirdLeading = TRUE ;
            }

            break ;
    }

    // now generate the date format
    lstrcpy (szDateFormat, bFirstLeading ? LeadingZeroStr : NoLeadingZeroStr) ;
    lstrcat (szDateFormat, szDateSeparator) ;
    lstrcat (szDateFormat, bSecondLeading ? LeadingZeroStr : NoLeadingZeroStr) ;
    lstrcat (szDateFormat, szDateSeparator) ;
    lstrcat (szDateFormat, bThirdLeading ? LeadingZeroStr : NoLeadingZeroStr) ;

    return TRUE ;
}

BOOL
CreateTimeFormat (
                 LPTSTR pTimeSeparator,
                 int iLeadingZero
                 )
{
    // create the format to be used in SystemTimeTimeString
    if (iLeadingZero) {
        lstrcpy (szTimeFormat, LeadingZeroStr) ;
    } else {
        lstrcpy (szTimeFormat, NoLeadingZeroStr) ;
    }

    lstrcat (szTimeFormat, pTimeSeparator) ;
    lstrcat (szTimeFormat, LeadingZeroStr) ;
    lstrcat (szTimeFormat, pTimeSeparator) ;
    //   lstrcat (szTimeFormat, LeadingZeroStr) ;

    // for the msec
    lstrcat (szTimeFormat, TEXT("%02.1f")) ;
    if (iTime == 0) {
        lstrcat (szTimeFormat, TEXT(" %s ")) ;
    }

    return TRUE ;
}

BOOL
GetInternational()
{
    TCHAR szShortDate[40] ;
    TCHAR szTime[40] ;   // time separator
    DWORD RetCode ;
    int   iTLZero = 0 ;      // = 0 for no leading zero, <> 0 for leading zero
    CHAR  aLanguageStr [2] ;
    LPSTR pRetStr ;

    // read the data from the win.ini (which i smapped to registry)
    RetCode = GetProfileString(szInternational,
                               TEXT("sShortDate"), szShortDate, szShortDate, sizeof(szShortDate)/sizeof(TCHAR));

    if (RetCode) {
        RetCode = GetProfileString(szInternational,
                                   TEXT("sTime"), szTime, szTime, sizeof(szTime)/sizeof(TCHAR));
    }


    if (RetCode) {
        iTime   = GetProfileInt(szInternational, TEXT("iTime"), iTime);
        iTLZero = GetProfileInt(szInternational, TEXT("iTLZero"), iTLZero);

        if (iTime == 0) {
            // get the AM PM strings for 12-hour format.
            // These two strings could be NULL.
            sz1159[0] = sz2359[0] = TEXT('\0') ;
            GetProfileString(szInternational,
                             TEXT("s1159"), sz1159, sz1159, sizeof(sz1159)/sizeof(TCHAR));

            GetProfileString(szInternational,
                             TEXT("s2359"), sz2359, sz2359, sizeof(sz2359)/sizeof(TCHAR));
        }
    }

    // create the two formats
    if (RetCode) {
        RetCode = (DWORD) CreateDateFormat (szShortDate) ;
    }

    if (RetCode) {
        RetCode = (DWORD) CreateTimeFormat (szTime, iTLZero) ;
    }

    // use the system default language numeric
    aLanguageStr[0] = '\0' ;
    pRetStr = setlocale(LC_NUMERIC, aLanguageStr);

    return (RetCode != 0) ;
}


// this routine is called to get the date/time formats either
// for the resource or from the registry.
void
GetDateTimeFormats ()
{
    if (!GetInternational()) {
        // GetInternational failed, then get default formats from resource
        iTime = 0 ;
        DateStyle = MONTH_FIRST ;
        YearCharCount = 4 ;
        StringLoad (IDS_S1159, sz1159) ;
        StringLoad (IDS_S2359, sz2359) ;
        StringLoad (IDS_TIME_FORMAT, szTimeFormat) ;
        StringLoad (IDS_SHORT_DATE_FORMAT, szDateFormat) ;
    }
    WindowInvalidate (PerfmonViewWindow()) ;

    // reset all the field taht may be affected by the
    // language numberic changes

}

void
ConvertDecimalPoint (
                    LPTSTR lpFloatPointStr
                    )
{
    if (szCurrentDecimal[0] == szDecimal[0]) {
        // no need to convert anything
        return ;
    }

    while (*lpFloatPointStr) {
        if (*lpFloatPointStr == szCurrentDecimal[0]) {
            *lpFloatPointStr = szDecimal[0] ;
            break ;
        }
        ++lpFloatPointStr ;
    }
}

void
ReconvertDecimalPoint (
                      LPTSTR lpFloatPointStr
                      )
{
    if (szCurrentDecimal[0] == szDecimal[0]) {
        // no need to convert anything
        return ;
    }

    while (*lpFloatPointStr) {
        if (*lpFloatPointStr == szDecimal[0]) {
            *lpFloatPointStr = szCurrentDecimal[0] ;
            break ;
        }
        ++lpFloatPointStr ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\registry.c ===
/*****************************************************************************
 *
 *  Registry.c - This module handles requests for registry data, and
 *               reading/writing of window placement data
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *
 ****************************************************************************/

#include <stdio.h>

#include "setedit.h"
#include "registry.h"
#include "utils.h"      // for StringToWindowPlacement

static TCHAR PerfmonNamesKey[] = TEXT("SOFTWARE\\Microsoft\\PerfMon") ;
static TCHAR WindowKeyName[] = TEXT("WindowPos") ;
static TCHAR TimeOutKeyName[] = TEXT("DataTimeOut") ;
static TCHAR DupInstanceKeyName[] = TEXT("MonitorDuplicateInstances") ;

VOID LoadLineGraphSettings(PGRAPHSTRUCT lgraph)
{
    lgraph->gMaxValues = DEFAULT_MAX_VALUES;
    lgraph->gOptions.bLegendChecked = DEFAULT_F_DISPLAY_LEGEND;
    lgraph->gOptions.bLabelsChecked = DEFAULT_F_DISPLAY_CALIBRATION;

    return;
}

VOID LoadRefreshSettings(PGRAPHSTRUCT lgraph)
{
    lgraph->gInterval = DEF_GRAPH_INTERVAL;
    lgraph->gOptions.eTimeInterval = (FLOAT) lgraph->gInterval / (FLOAT) 1000.0 ;
    return;
}


BOOL LoadMainWindowPlacement (HWND hWnd)
{
    WINDOWPLACEMENT   WindowPlacement ;
    TCHAR             szWindowPlacement [TEMP_BUF_LEN] ;
    HKEY              hKeyNames ;
    DWORD             Size;
    DWORD             Type;
    DWORD             Status;
    DWORD             localDataTimeOut;
    DWORD             localFlag;
    STARTUPINFO       StartupInfo ;


    GetStartupInfo (&StartupInfo) ;

    DataTimeOut = DEFAULT_DATA_TIMEOUT ;

    Status = RegOpenKeyEx(HKEY_CURRENT_USER, PerfmonNamesKey,
                          0L, KEY_READ | KEY_WRITE, &hKeyNames) ;

    if (Status == ERROR_SUCCESS) {
        // get the data timeout  value
        Size = sizeof(localDataTimeOut) ;

        Status = RegQueryValueEx(hKeyNames, TimeOutKeyName, NULL,
                                 &Type, (LPBYTE)&localDataTimeOut, &Size) ;
        if (Status == ERROR_SUCCESS && Type == REG_DWORD) {
            DataTimeOut = localDataTimeOut ;
        }

        // check the duplicate entry value
        Size = sizeof (localFlag);
        Status = RegQueryValueEx (hKeyNames, DupInstanceKeyName, NULL,
                                  &Type, (LPBYTE)&localFlag, &Size);
        if ((Status == ERROR_SUCCESS) && (Type == REG_DWORD)) {
            bMonitorDuplicateInstances = (BOOL)(localFlag == 1);
        } else {
            // value not found or not correct so set to default value
            bMonitorDuplicateInstances = TRUE;
            // and try to save it back in the registry
            localFlag = 1;
            Status = RegSetValueEx(hKeyNames, DupInstanceKeyName, 0,
                                   REG_DWORD, (LPBYTE)&localFlag, sizeof(localFlag));

        }

        // get the window placement data
        Size = sizeof(szWindowPlacement) ;

        Status = RegQueryValueEx(hKeyNames, WindowKeyName, NULL,
                                 &Type, (LPBYTE)szWindowPlacement, &Size) ;
        RegCloseKey (hKeyNames) ;

        if (Status == ERROR_SUCCESS) {
            int            iNumScanned ;

            iNumScanned = swscanf (szWindowPlacement,
                                   TEXT("%d %d %d %d %d %d %d %d %d"),
                                   &WindowPlacement.showCmd,
                                   &WindowPlacement.ptMinPosition.x,
                                   &WindowPlacement.ptMinPosition.y,
                                   &WindowPlacement.ptMaxPosition.x,
                                   &WindowPlacement.ptMaxPosition.y,
                                   &WindowPlacement.rcNormalPosition.left,
                                   &WindowPlacement.rcNormalPosition.top,
                                   &WindowPlacement.rcNormalPosition.right,
                                   &WindowPlacement.rcNormalPosition.bottom) ;

            if (StartupInfo.dwFlags == STARTF_USESHOWWINDOW) {
                WindowPlacement.showCmd = StartupInfo.wShowWindow ;
            }
            WindowPlacement.length = sizeof(WINDOWPLACEMENT);
            WindowPlacement.flags = WPF_SETMINPOSITION;
            if (!SetWindowPlacement (hWnd, &WindowPlacement)) {
                return (FALSE);
            }
            bPerfmonIconic = IsIconic(hWnd) ;
            return (TRUE) ;
        }
    }

    if (Status != ERROR_SUCCESS) {
        // open registry failed, use Max as default
        ShowWindow (hWnd, SW_SHOWMAXIMIZED) ;
        return (FALSE) ;
    }
    return TRUE;
}



BOOL SaveMainWindowPlacement (HWND hWnd)
{
    WINDOWPLACEMENT   WindowPlacement ;
    TCHAR             ObjectType [2] ;
    TCHAR             szWindowPlacement [TEMP_BUF_LEN] ;
    HKEY              hKeyNames = 0 ;
    DWORD             Size ;
    DWORD             Status ;
    DWORD             dwDisposition ;

    ObjectType [0] = TEXT(' ') ;
    ObjectType [1] = TEXT('\0') ;

    WindowPlacement.length = sizeof(WINDOWPLACEMENT);
    if (!GetWindowPlacement (hWnd, &WindowPlacement)) {
        return FALSE;
    }
    TSPRINTF (szWindowPlacement, TEXT("%d %d %d %d %d %d %d %d %d"),
              WindowPlacement.showCmd,
              WindowPlacement.ptMinPosition.x,
              WindowPlacement.ptMinPosition.y,
              WindowPlacement.ptMaxPosition.x,
              WindowPlacement.ptMaxPosition.y,
              WindowPlacement.rcNormalPosition.left,
              WindowPlacement.rcNormalPosition.top,
              WindowPlacement.rcNormalPosition.right,
              WindowPlacement.rcNormalPosition.bottom) ;

    // try to create it first
    Status = RegCreateKeyEx(HKEY_CURRENT_USER, PerfmonNamesKey, 0L,
                            ObjectType, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS | KEY_WRITE,
                            NULL, &hKeyNames, &dwDisposition) ;

    // if it has been created before, then open it
    if (dwDisposition == REG_OPENED_EXISTING_KEY) {
        Status = RegOpenKeyEx(HKEY_CURRENT_USER, PerfmonNamesKey, 0L,
                              KEY_WRITE, &hKeyNames) ;
    }

    // we got the handle, now store the window placement data
    if (Status == ERROR_SUCCESS) {
        Size = (lstrlen (szWindowPlacement) + 1) * sizeof (TCHAR) ;

        Status = RegSetValueEx(hKeyNames, WindowKeyName, 0,
                               REG_SZ, (LPBYTE)szWindowPlacement, Size) ;

        RegCloseKey (hKeyNames) ;

    }

    if (dwDisposition != REG_OPENED_EXISTING_KEY && Status == ERROR_SUCCESS) {
        // now add the DataTimeOut key for the first time
        Status = RegSetValueEx(hKeyNames, TimeOutKeyName, 0,
                               REG_DWORD, (LPBYTE)&DataTimeOut, sizeof(DataTimeOut)) ;

    }

    return (Status == ERROR_SUCCESS) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\setedit.h ===
/*****************************************************************************
 *
 *  Perfmon.h - This is the main include file. It contains all major data
 *              structures and general defines.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *  Author: Mike Moskowicz
 *
 *          [1-May-1992]
 *
 ****************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <limits.h>
#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdlib.h>
#include <string.h>
#include <winperf.h>

#include "perfmrc.h"
#include "strids.h"
#include "menuids.h"
#include "dlgids.h"

#include "sizes.h"
#include "typedefs.h"
#include "winhelpr.h"


// VOID ErrorExit(LPTSTR pszError,HWND hwnd) ;

// extern VOID ErrorExit(LPTSTR,HWND);
extern VOID LoadLineGraphSettings(PGRAPHSTRUCT);
extern VOID LoadRefreshSettings(PGRAPHSTRUCT);
extern VOID SetGraphTimer(PGRAPHSTRUCT lgraph) ;
extern BOOL QueryTitleEntry(HKEY,DWORD,DWORD,DWORD,LPTSTR);
extern VOID ResetGraphTimer(PGRAPHSTRUCT lgraph);


//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define VERSION_NUMBER      1
#define SAVED_LOG           4
#define SAVED_ALERT         2
#define SAVED_GRAPH         1
#define SAVED_WORKSPACE     (SAVED_GRAPH | SAVED_ALERT | SAVED_LOG)
#define FNAMLEN             128


#define szScalesFontFace         TEXT("Helv")
#define iScalesFontHeight        8
#define szScalesPrinterFontFace  TEXT("Helvetica")
#define iScalesPrinterFontHeight 12
#define iTitlePrinterFontHeight  18


#define crLightGray              RGB (0xC0, 0xC0, 0xC0)
#define crDarkGray               RGB (0x40, 0x40, 0x40)
#define crGray                   RGB (0x80, 0x80, 0x80)
#define crRed                    RGB (0xFF, 0x00, 0x00)
#define crGreen                  RGB (0x00, 0xFF, 0x00)
#define crBlue                   RGB (0x00, 0x00, 0xFF)
#define crBlack                  RGB (0x00, 0x00, 0x00)
#define crWhite                  RGB (0xFF, 0xFF, 0xFF)


#define LogTimerID               100
#define AlertTimerID             200
#define ChartTimerID             300
#define ReportTimerID            400


#define ChartTool                IDM_VIEWCHART
#define AlertTool                IDM_VIEWALERT
#define LogTool                  IDM_VIEWLOG
#define ReportTool               IDM_VIEWREPORT
#define AddTool                  IDM_TOOLBARADD
#define EditTool                 IDM_TOOLBARMODIFY
#define DeleteTool               IDM_TOOLBARDELETE
#define RefreshTool              IDM_TOOLBARREFRESH
#define BookmarkTool             IDM_OPTIONSBOOKMARK
#define OptionsTool              IDM_TOOLBAROPTIONS


#define szComputerPrefix         TEXT("\\\\")      // two backslashes


#define WIDESTYLES               FALSE       // Don't allow wide styled lines


//==========================================================================//
//                                Global Data                               //
//==========================================================================//


#include "globals.h"


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


LRESULT
APIENTRY
MainWndProc (
             HWND hwnd,
             UINT message,
             WPARAM wParam,
             LPARAM lParam
             ) ;


void SizePerfmonComponents (void) ;

#ifdef UNICODE
#define TSPRINTF swprintf
#else
#define TSPRINTF sprintf
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\status.c ===
#include "setedit.h"
#include "status.h"  // External declarations for this file
#include <stdio.h>   // for sprintf.
#include <stdarg.h>  // For ANSI variable args. Dont use UNIX <varargs.h>

#include "perfmops.h"   // for SmallFileSizeString
#include "utils.h"

//================================//
// Options for PaintStatusBar     //
//================================//
#define     PaintText         1
#define     PaintIcons        2
#define     PaintBoundary     4
#define     PaintAll          (PaintText + PaintIcons + PaintBoundary)

//==========================================================================//
//                                  Constants                               //
//==========================================================================//

#define szStatusClass          TEXT("PerfmonStatusClass")
#define dwStatusClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_OWNDC)
#define iStatusClassExtra      (0)
#define iStatusWindowExtra     (0)
#define dwStatusWindowStyle    (WS_CHILD | WS_VISIBLE)


//==========================================================================//
//                                Local Data                                //
//==========================================================================//


HDC            hStatusDC ;                   // for OWN_DC

int            yStatusHeight ;

int            szStatusLineLen ;             // no. of char. in szStatusLine
TCHAR          szStatusLine [MessageLen+ResourceStringLen] ;
// TCHAR          szCurrentActivity [ResourceStringLen] ;
// TCHAR          szStatusFormat  [ResourceStringLen] ;
TCHAR          szStatusFormat2 [ResourceStringLen] ;




//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define StatusTopMargin()     (2)
#define StatusLeftMargin()    (2)


//==========================================================================//
//                              Local Functions                             //
//==========================================================================//





//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//


void static OnCreate (HWND hWnd)
/*
   Effect:        Perform any actions needed when a status window is created.
                  In particular, set the instance data to initial values,
                  determine the size and placement of the various elements
                  of the status display.

   Called By:     StatusWndProc only, in response to a WM_CREATE message.
*/
{  // OnCreate
    HDC            hDC ;



    hDC = hStatusDC = GetDC (hWnd) ;
    SelectFont (hDC, hFontScales) ;
    SetBkColor (hDC, ColorBtnFace) ;
    SetTextAlign (hDC, TA_LEFT) ;
    SetBkMode (hDC, OPAQUE) ;

    yStatusHeight = 2 * StatusTopMargin () +
                    FontHeight (hDC, TRUE) +
                    2 * ThreeDPad ;

    //   StringLoad (IDS_CURRENTACTIVITY, szCurrentActivity) ;
    //    StringLoad (IDS_STATUSFORMAT, szStatusFormat) ;
    StringLoad (IDS_STATUSFORMAT2, szStatusFormat2) ;

    StatusLineReady (hWnd) ;
}  // OnCreate

void static OnDestroy (HWND hWnd)
{
    ReleaseDC (hWnd, hStatusDC) ;

}  // OnDestroy

void static PaintStatusBar (HWND hWnd, HDC hDC, int PaintOptions)
/*
   Effect:        Paint the invalid surface of hWnd. Draw each label, each
                  recessed value box, and each value.

   Called By:     StatusWndProc only, in response to a WM_PAINT message.
*/
{
    RECT           rectClient ;

    if (bPerfmonIconic) {
        // no need to draw anything if iconic
        return ;
    }

    GetClientRect (hWnd, &rectClient) ;

    RectContract (&rectClient, StatusTopMargin (), StatusLeftMargin ()) ;

    if (PaintOptions == PaintAll) {
        ThreeDConcave1 (hDC,
                        rectClient.left, rectClient.top,
                        rectClient.right, rectClient.bottom) ;
    }

    rectClient.left += StatusLeftMargin () ;


    if (PaintOptions & PaintText) {
        rectClient.left += 1 ;
        rectClient.top += 1 ;
        rectClient.right -= 1 ;
        rectClient.bottom -= 1 ;
        ExtTextOut (hDC, rectClient.left, rectClient.top, ETO_CLIPPED | ETO_OPAQUE,
                    &rectClient, szStatusLine, szStatusLineLen, NULL) ;
    }

}  // PaintStatusBar




LRESULT
APIENTRY
StatusWndProc (
              HWND hWnd,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{  // StatusWndProc
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;
    HDC            hDC ;
    PAINTSTRUCT    ps ;


    bCallDefProc = FALSE ;
    lReturnValue = 0L ;

    switch (wMsg) {  // switch
        case WM_PAINT:
            hDC = BeginPaint (hWnd, &ps) ;
            PaintStatusBar (hWnd, hDC, PaintAll) ;
            EndPaint (hWnd, &ps) ;
            break ;

        case WM_CREATE:
            OnCreate (hWnd) ;
            break ;

        case WM_DESTROY:
            OnDestroy (hWnd) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }  // switch


    if (bCallDefProc)
        lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}  // StatusWndProc


int StatusHeight (HWND hWnd)
/*
   Effect:        A status window has a preferred height, based on the font
                  used in its display. Return the preferred height, determined
                  when the window was created.

   Assert:        OnCreate has already been called, and it set
                  StatusData.yHeight.
*/
{
    return (yStatusHeight) ;
}




HWND CreatePMStatusWindow (HWND hWnd)
{
    return (CreateWindow (szStatusClass,       // class
                          NULL,                // caption
                          dwStatusWindowStyle, // window style
                          0, 0,                // position
                          0, 0,                // size
                          hWnd,                // parent window
                          NULL,                // menu
                          hInstance,           // program instance
                          NULL)) ;             // user-supplied data
}  // CreateStatusWindow




BOOL StatusInitializeApplication (void)
/*
   Called By:     InitializeApplication only
*/
{
    WNDCLASS       wc ;

    wc.style          = dwStatusClassStyle ;
    wc.lpfnWndProc    = StatusWndProc ;
    wc.hInstance      = hInstance ;
    wc.cbClsExtra     = iStatusClassExtra ;
    wc.cbWndExtra     = iStatusWindowExtra ;
    wc.hIcon          = NULL ;
    wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ;
    wc.hbrBackground  = hbLightGray ;
    wc.lpszMenuName   = NULL ;
    wc.lpszClassName  = szStatusClass ;

    return (RegisterClass (&wc)) ;
}

BOOL _cdecl StatusLine (HWND hWnd,
                        WORD wStringID, ...)
{
    TCHAR          szFormat [MessageLen] ;
    va_list        vaList ;

    if (wStringID == 0) {
        return (TRUE) ;
    }

    strclr (szStatusLine) ;

    if (LoadString (hInstance, wStringID, szFormat, MessageLen)) {
        va_start (vaList, wStringID) ;
        wvsprintf (szStatusLine, szFormat, vaList) ;
        va_end (vaList) ;
        dwCurrentMenuID = MenuIDToHelpID (wStringID) ;
        szStatusLineLen = lstrlen (szStatusLine) ;
    } else {
        dwCurrentMenuID = 0 ;
        szStatusLineLen = 0 ;
    }
    PaintStatusBar (hWndStatus, hStatusDC, PaintText + PaintIcons) ;

    return (TRUE) ;
}  // StatusLine



void StatusLineReady (HWND hWnd)
{
    LPTSTR      pFileName = NULL ;


    pFileName = pChartFileName ;

    if (pFileName) {
        TSPRINTF (szStatusLine, szStatusFormat2, pFileName) ;
    } else {
        szStatusLine[0] = TEXT('\0') ;
    }

    szStatusLineLen = lstrlen (szStatusLine) ;

    PaintStatusBar (hWndStatus, hStatusDC, PaintText + PaintIcons) ;
}


void StatusUpdateIcons (HWND hWndStatus)
{
    PaintStatusBar (hWndStatus, hStatusDC, PaintIcons) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\strids.h ===
// File open related strings
#define IDS_CHARTFILE        700
#define IDS_CHARTFILEEXT     701
#define IDS_DEF_CHART_EXT    702

#define IDS_ALERTFILE        710
#define IDS_ALERTFILEEXT     711
#define IDS_DEF_ALERT_EXT    712

#define IDS_LOGFILE          720
#define IDS_LOGFILEEXT       721
#define IDS_DEF_LOG_EXT      722

#define IDS_REPORTFILE       730
#define IDS_REPORTFILEEXT    731
#define IDS_DEF_REPORT_EXT   732

#define IDS_ALLFILES         740
#define IDS_ALLFILESEXT      741
#define IDS_DEF_ALLFILE_EXT  742

#define IDS_SAVELOGFILE      750
#define IDS_SAVELOGFILEEXT   751
#define IDS_DEF_LOGFILE_EXT  752

#define IDS_WORKSPACEFILE    760
#define IDS_WORKSPACEFILEEXT 761
#define IDS_DEF_WORKSPACE_EXT 762

#define IDS_EXPORTFILE       770
#define IDS_EXPORTFILECSVEXT 771
#define IDS_DEF_EXPORT_CSV   772

#define IDS_EXPORTFILETSV    780
#define IDS_EXPORTFILETSVEXT 781
#define IDS_DEF_EXPORT_TSV   782

#define IDS_FILEOPEN_TITLE   799
/*	STRING ID'S                */

#define IDS_APPNAME	       800
#define IDS_NONAME          801
#define IDS_LEGENDNAME      803
#define IDS_SYSNAME         804
#define IDS_OBJNAME         805
#define IDS_COUNTERNAME     806
#define IDS_INSTNAME        807
#define IDS_SCALENAME       808
#define IDS_PARENT          809
#define IDS_CURRENT         810
#define IDS_SYSTEM_PROBLEM  811

// ERROR MESSAGES
#define IDS_NONNUMERIC	     817     // number input is nonnumeric
#define IDS_MANYCLOCKS	     818     // too many clocks
#define IDS_CANTDOTIMER      819     // can't allocate timer
#define IDS_BADTIMERMSG      820     // window receives bad mesage
#define IDS_BADERROR         821     // bad error message
#define IDS_NO_MEMORY        822     // out of memory
#define IDS_BADHMOD          823     // received bad module handle
#define IDS_BADBRUSH         824     // NULL brush created
#define IDS_CANT_REALLOC     825     // can't realloc graph
#define IDS_COUNTER_NOT_IMP  826     // counter not implemented yet
#define IDS_SAVEAS_TITLE     827
#define IDS_SAVEASW_TITLE    828
#define IDS_GRAPH_FNAME      829
#define IDS_LOG_FNAME        830
#define IDS_ALERT_FNAME      831
#define IDS_REPORT_FNAME     832
#define IDS_WORK_FNAME       833
#define IDS_EXPORTAS_TITLE   834

#define IDS_FILE_ERROR       850     // file error

#define IDS_STATUSTIME       901 
#define IDS_STATUSLAST       902
#define IDS_STATUSAVG        903
#define IDS_STATUSMIN        904
#define IDS_STATUSMAX        905


#define IDS_LABELCOLOR       906
#define IDS_LABELSCALE       907
#define IDS_LABELCOUNTER     908
#define IDS_LABELINSTANCE    909
#define IDS_LABELPARENT      910
#define IDS_LABELOBJECT      911
#define IDS_LABELSYSTEM      912

#define IDS_CLOSED           913
#define IDS_PAUSED           914
#define IDS_COLLECTING       915

#define IDS_LOGOPTIONS       916

#define IDS_STOP             917
#define IDS_RESUME           918

#define IDS_EDIT             919
#define IDS_OPTIONS          920


#define IDS_START            921
#define IDS_PAUSE            922
#define IDS_DONE             923

#define IDS_OPENLOG          925
#define IDS_NEEDALERTVALUE   926

#define IDS_LABELVALUE       927

#define IDS_ADDTOCHART       928
#define IDS_ADDTOALERT       929
#define IDS_ADDTOREPORT      930

#define IDS_SYSTEMFORMAT     931
#define IDS_OBJECTFORMAT     932

#define IDS_STATUSFORMAT     934
#define IDS_CURRENTACTIVITY  935


#define IDS_EDITCHART        936
#define IDS_EDITALERT        937
#define IDS_EDITREPORT       938

#define IDS_OK               939
#define IDS_SAVECHART        940
#define IDS_MODIFIEDCHART    941

#define IDS_COMPUTERNOTFOUND 942
#define IDS_ALLOBJECTS       943
#define IDS_DEFAULTPATH      944
#define IDS_CREATELOGFILE    945

#define IDS_SAVEREPORT       946
#define IDS_MODIFIEDREPORT   947

#define IDS_STOPBEFORESTART  948
#define IDS_TIMEFRAME        949
#define IDS_STATUSFORMAT2    950

// the folowing strings are used by Export***
#define IDS_REPORT_HEADER    970
#define IDS_REPORT_LOGFILE   971
#define IDS_INTERVAL_FORMAT  972
#define IDS_CHARTINT_FORMAT  973

#define IDS_START_TEXT       974
#define IDS_STOP_TEXT        975
#define IDS_ALERT_TRIGGER    976
#define IDS_EXPORT_DATE      977
#define IDS_EXPORT_TIME      978

#define IDS_HELPFILE_NAME    979
#define IDS_NEWDATA_BOOKMARK 980


// default strings used in Date/Time
#define IDS_SHORT_DATE_FORMAT 1101
#define IDS_TIME_FORMAT       1102
#define IDS_S1159             1103
#define IDS_S2359             1104

// string id for default scale factor
#define IDS_DEFAULT           1120

// string id for Alert msg when system down
#define IDS_SYSTEM_DOWN       1121
#define IDS_SYSTEM_UP         1122
 

// the following are error strings
// error relating to files
#define ERR_LOG_FILE          2000
#define ERR_EXPORT_FILE       2001
#define ERR_SETTING_FILE      2002
#define ERR_BAD_LOG_FILE      2003
#define ERR_BAD_SETTING_FILE  2004
#define ERR_CORRUPT_LOG       2005
#define ERR_CANT_OPEN         2006
#define ERR_CANT_RELOG_DATA   2007

// system errors
#define ERR_NO_MEMORY         2100

// error relating to dialogs
#define ERR_COUNTER_NOT_IMP   2200
#define ERR_NEEDALERTVALUE    2201
#define ERR_STOPBEFORESTART   2202
#define ERR_COMPUTERNOTFOUND  2203
#define ERR_BADVERTMAX        2204
#define ERR_BADTIMEINTERVAL   2205

// error in computer name specified on command line
#define ERR_BADCOMPUTERNAME	2300
// unable to access perf data
#define ERR_ACCESS_DENIED   2301


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\system.c ===
//
//  Foreign computer support needs more work (a-robw)
//
#ifdef FOREIGN_COMPUTER_SUPPORT
#undef FOREIGN_COMPUTER_SUPPORT
#endif

#include "setedit.h"
#include "system.h"     // external declarations for this file

#include "perfdata.h"
#include "perfmops.h"
#include "pmemory.h"
#include "utils.h"      // for strsame, et al
#include "sizes.h"

DWORD
SystemCount(
           PPERFSYSTEM pSystemFirst
           )
{
    PPERFSYSTEM       pSystem ;
    DWORD           iNumSystems ;

    iNumSystems = 0 ;

    for (pSystem = pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {
        iNumSystems++ ;
    }

    return iNumSystems ;
}

BOOL
SystemSetupThread (
                  PPERFSYSTEM pSystem
                  )
{
    DWORD           dwThreadID ;
    HANDLE          hThread ;
    HANDLE          hStateDataMutex ;
    HANDLE          hPerfDataEvent ;
    SECURITY_ATTRIBUTES  SecAttr ;
    PPERFDATA       pSystemPerfData ;


    SecAttr.nLength = sizeof (SecAttr) ;
    SecAttr.bInheritHandle = TRUE ;
    SecAttr.lpSecurityDescriptor = NULL ;

    hThread = CreateThread (&SecAttr, 1024L,
                            (LPTHREAD_START_ROUTINE)PerfDataThread, (LPVOID)(pSystem), 0L, &dwThreadID);

    if (!hThread) {
        SystemFree (pSystem, TRUE);
        return (FALSE) ;
    }

    // create a State Data Lock mutex
    hStateDataMutex = CreateMutex (&SecAttr, FALSE, NULL);
    if (!hStateDataMutex) {
        CloseHandle (hThread) ;
        SystemFree (pSystem, TRUE);
        return (FALSE);
    }
    hPerfDataEvent = CreateEvent (&SecAttr, TRUE, 0L, NULL) ;
    if (!hPerfDataEvent) {
        CloseHandle (hStateDataMutex) ;
        CloseHandle (hThread) ;
        SystemFree (pSystem, TRUE);
        return (FALSE);
    }

    // allocate Perfdata
    pSystemPerfData = (PPERFDATA) MemoryAllocate (4096L) ;
    if (!pSystemPerfData) {
        CloseHandle (hPerfDataEvent) ;
        CloseHandle (hStateDataMutex) ;
        CloseHandle (hThread) ;
        SystemFree (pSystem, TRUE);
        return (FALSE);
    }
    // now setup the pSystem..
    pSystem->dwThreadID = dwThreadID ;
    pSystem->hThread = hThread ;
    pSystem->hPerfDataEvent = hPerfDataEvent ;
    pSystem->pSystemPerfData = pSystemPerfData ;
    pSystem->hStateDataMutex = hStateDataMutex ;

    return (TRUE) ;
}


PPERFSYSTEM
SystemCreate (
             LPCTSTR lpszSystemName
             )
{
    PPERFSYSTEM     pSystem ;
    PPERFDATA       pLocalPerfData;
    DWORD           Status ;
    SIZE_T          dwMemSize;
    TCHAR           GlobalValueBuffer[] = L"Global" ;
    TCHAR           ForeignValueBuffer[8+MAX_SYSTEM_NAME_LENGTH+1] =
    L"Foreign " ;

    // attempt to allocate system data structure

    pSystem = MemoryAllocate (sizeof (PERFSYSTEM)) ;
    if (!pSystem) {
        SetLastError (ERROR_OUTOFMEMORY);
        return (NULL) ;
    }

    // initialize name and help table pointers

    pSystem->CounterInfo.pNextTable = NULL;
    pSystem->CounterInfo.dwLangId = 0;
    pSystem->CounterInfo.dwLastId = 0;
    pSystem->CounterInfo.TextString = NULL;

    lstrcpy (pSystem->sysName, lpszSystemName) ;

    // try to open key to registry, error code is in GetLastError()

    pSystem->sysDataKey = OpenSystemPerfData(lpszSystemName);

    // if a Null Key was returned then:
    //  a) there's no such computer
    //  b) the system is a foreign computer
    //
    //  before giving up, then see if it's a foreign computer

    if (!pSystem->sysDataKey) {

        // build foreign computer string

        lstrcat(ForeignValueBuffer, lpszSystemName) ;

        // assign System value name pointer to the local variable for trial

        pSystem->lpszValue = ForeignValueBuffer;

        // try to get data from the computer to see if it's for real
        // otherwise, give up and return NULL

        pLocalPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE);
        if (pLocalPerfData == NULL) {
            SystemFree (pSystem, TRUE);
            SetLastError (ERROR_OUTOFMEMORY);
            return (NULL);
        } else {
            pSystem->sysDataKey = HKEY_PERFORMANCE_DATA; // local machine
            bCloseLocalMachine = TRUE ;

            dwMemSize = STARTING_SYSINFO_SIZE;
            Status = GetSystemPerfData (
                                       pSystem->sysDataKey,
                                       pSystem->lpszValue,
                                       pLocalPerfData,
                                       &dwMemSize);

            // success means a valid buffer came back
            // more data means someone tried (so it's probably good (?)

            if (!((Status == ERROR_MORE_DATA) || (Status == ERROR_SUCCESS)) ||
                !((pLocalPerfData->Signature[0] == (WCHAR)'P') &&
                  (pLocalPerfData->Signature[1] == (WCHAR)'E') &&
                  (pLocalPerfData->Signature[2] == (WCHAR)'R') &&
                  (pLocalPerfData->Signature[3] == (WCHAR)'F'))) {
                SetLastError (ERROR_BAD_NET_NAME); // unable to find name
                SystemFree (pSystem, TRUE);
                MemoryFree (pLocalPerfData);    // don't really need anything from it
                return NULL;
            }

            MemoryFree (pLocalPerfData);    // don't really need anything from it

            // ok, so we've established that a foreign data provider
            // exists, now to finish the initialization.

            // change system name in structure to get counter names

            lstrcpy (pSystem->sysName, LocalComputerName);

            Status = GetSystemNames(pSystem);   // get counter names & explain text
            if (Status != ERROR_SUCCESS) {
                // unable to get names so bail out
                SystemFree (pSystem, TRUE);
                SetLastError (Status);
                return (NULL) ;
            }

            // restore computer name for displays, etc.

            lstrcpy (pSystem->sysName, lpszSystemName);

            // allocate value string buffer
            pSystem->lpszValue = MemoryAllocate (TEMP_BUF_LEN*sizeof(WCHAR));
            if (!pSystem->lpszValue) {
                // unable to allocate memory
                SystemFree (pSystem, TRUE);
                SetLastError (ERROR_OUTOFMEMORY);
                return (NULL) ;
            } else {
                lstrcpy (pSystem->lpszValue, ForeignValueBuffer);
            }
        }
    } else {
        // if here, then a connection to the system's registry was established
        // so continue with the system data structure initialization

        // get counter names & explain text from local computer

        Status = GetSystemNames(pSystem);
        if (Status != ERROR_SUCCESS) {
            // unable to get names so bail out
            SystemFree (pSystem, TRUE);
            SetLastError (Status);
            return (NULL) ;
        }

        // allocate value string buffer
        pSystem->lpszValue = MemoryAllocate(TEMP_BUF_LEN*sizeof(WCHAR));

        if (!pSystem->lpszValue) {
            // unable to allocate memory
            SystemFree (pSystem, TRUE);
            SetLastError (ERROR_OUTOFMEMORY);
            return (NULL) ;
        } else {
            SetSystemValueNameToGlobal (pSystem);
        }
    }

    // initialize remaining system pointers

    pSystem->pSystemNext = NULL ;
    pSystem->FailureTime = 0;

    SetLastError (ERROR_SUCCESS);

    return (pSystem) ;
}


PPERFSYSTEM
SystemGet (
          PPERFSYSTEM pSystemFirst,
          LPCTSTR lpszSystemName
          )
{
    PPERFSYSTEM       pSystem ;

    if (!pSystemFirst) {
        return (NULL) ;
    }

    for (pSystem = pSystemFirst ;
        pSystem ;
        pSystem = pSystem->pSystemNext) {
        if (strsamei (pSystem->sysName, lpszSystemName)) {
            return (pSystem) ;
        }
    }

    return (NULL) ;
}


PPERFSYSTEM
SystemAdd (
          PPPERFSYSTEM ppSystemFirst,
          LPCTSTR lpszSystemName,
          HWND    hDlg
          )
{
    PPERFSYSTEM       pSystem ;
    PPERFSYSTEM       pSystemPrev ;
    TCHAR             szMessage[256];
    DWORD             dwLastError;


    if (!*ppSystemFirst) {
        *ppSystemFirst = SystemCreate (lpszSystemName) ;
        dwLastError = GetLastError();
        // save return value
        return (*ppSystemFirst) ;
    } else {
        for (pSystem = *ppSystemFirst ;
            pSystem ;
            pSystem = pSystem->pSystemNext) {
            pSystemPrev = pSystem ;
            if (strsamei (pSystem->sysName, lpszSystemName)) {
                return (pSystem) ;
            }
        }
    }
    // display message box here if an error occured trying to add
    // this system

    if (pSystem == NULL) {
        dwLastError = GetLastError();
        if (dwLastError == ERROR_ACCESS_DENIED) {
            DlgErrorBox (hDlg, ERR_ACCESS_DENIED);
            SetLastError (dwLastError); // to propogate up to caller
        }
    }

    return (pSystem);
}


void
SystemFree (
           PPERFSYSTEM pSystem,
           BOOL        bDeleteTheSystem
           )
{

    PCOUNTERTEXT pCounter, pNextCounter;

    if (!pSystem) {
        // can't proceed
        return ;
    }

    if (pSystem->sysDataKey && pSystem->sysDataKey != HKEY_PERFORMANCE_DATA) {
        // close the remote computer key
        RegCloseKey (pSystem->sysDataKey);
        pSystem->sysDataKey = 0 ;
    }

    for (pCounter = pSystem->CounterInfo.pNextTable, pNextCounter = NULL;
        pCounter;
        pCounter = pNextCounter) {
        pNextCounter = pCounter->pNextTable;
        MemoryFree (pCounter);
    }
    pSystem->CounterInfo.pNextTable = NULL ;

    if (pSystem->CounterInfo.TextString) {
        MemoryFree (pSystem->CounterInfo.TextString);
        pSystem->CounterInfo.TextString = NULL ;
    }

    if (pSystem->CounterInfo.HelpTextString) {
        MemoryFree (pSystem->CounterInfo.HelpTextString);
        pSystem->CounterInfo.HelpTextString = NULL ;
    }
    pSystem->CounterInfo.dwLastId = 0 ;
    pSystem->CounterInfo.dwHelpSize = 0 ;
    pSystem->CounterInfo.dwCounterSize = 0 ;

    if (bDeleteTheSystem) {
        if (pSystem->lpszValue) {
            MemoryFree (pSystem->lpszValue);
            pSystem->lpszValue = NULL ;
        }
        MemoryFree (pSystem) ;
    }
}


void
DeleteUnusedSystems (
                    PPPERFSYSTEM  ppSystemFirst ,
                    int           iNoUseSystems
                    )
{
    PPERFSYSTEM   pPrevSys, pCurrentSys, pNextSys ;

    // delete all the marked system from the list header until
    // we hit one that is not marked
    while ((*ppSystemFirst)->bSystemNoLongerNeeded) {
        // delect from the list header
        pCurrentSys = *ppSystemFirst ;
        *ppSystemFirst = pCurrentSys->pSystemNext ;
        SystemFree (pCurrentSys, TRUE) ;
        iNoUseSystems-- ;
        if (iNoUseSystems <= 0 || !(*ppSystemFirst)) {
            // done
            break ;
        }
    }

    if (iNoUseSystems <= 0 || !(*ppSystemFirst)) {
        return ;
    }

    // now walk the list and delete each marked system
    for (pPrevSys = *ppSystemFirst, pCurrentSys = pPrevSys->pSystemNext ;
        pCurrentSys && iNoUseSystems > 0 ;
        pCurrentSys = pNextSys, iNoUseSystems--) {

        if (pCurrentSys->bSystemNoLongerNeeded) {
            // the current system is marked, updated the list and free
            // this system.  No need to change pPrevSys here
            pNextSys = pPrevSys->pSystemNext = pCurrentSys->pSystemNext ;
            SystemFree (pCurrentSys, TRUE) ;
        } else {
            // pCurrentSys is OK, update the 2 list pointers and
            // carry on looping
            pPrevSys = pCurrentSys ;
            pNextSys = pCurrentSys->pSystemNext ;
        }
    }
}


void
FreeSystems (
            PPERFSYSTEM pSystemFirst
            )
{
    PPERFSYSTEM    pSystem, pSystemNext ;


    for (pSystem = pSystemFirst;
        pSystem;
        pSystem = pSystemNext) {
        pSystemNext = pSystem->pSystemNext ;
        SystemFree (pSystem, TRUE) ;
    }
}


PPERFSYSTEM
GetComputer (
            HDLG hDlg,
            WORD wControlID,
            BOOL bWarn,
            PPERFDATA *ppPerfData,
            PPERFSYSTEM *ppSystemFirst
            )
/*
   Effect:        Attempt to set the current computer to the one in the
                  hWndComputers dialog edit box. If this computer system
                  can be found, load the objects, etc. for the computer
                  and set pSystem and ppPerfdata to the values for this
                  system.
*/
{
    TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;
    PPERFSYSTEM    pSystem;
    TCHAR          tempBuffer [LongTextLen] ;
    DWORD          dwBufferSize ;
    LPTSTR         pBuffer = NULL ;

    DialogText (hDlg, wControlID, szComputer) ;

    // If necessary, add the system to the lists for this view.
    pSystem = SystemGet (*ppSystemFirst, szComputer) ;
    if (!pSystem) {
        pSystem = SystemAdd (ppSystemFirst, szComputer, hDlg) ;
    }

    if (!pSystem && bWarn) {
        DialogSetString (hDlg, wControlID, LocalComputerName) ;

        // Note: this will succeed since the local computer is always
        // available
        EditSetModified (GetDlgItem(hDlg, wControlID), FALSE) ;

        pSystem = SystemGet (*ppSystemFirst, LocalComputerName) ;
        if (!pSystem) {
            pSystem = SystemAdd (ppSystemFirst, LocalComputerName, hDlg) ;
        }

        //        MessageBoxResource (hDlg, IDS_COMPUTERNOTFOUND, IDS_APPNAME, MB_OK) ;
        DlgErrorBox (hDlg, ERR_COMPUTERNOTFOUND) ;

        SetFocus (DialogControl(hDlg, wControlID)) ;
    }

    if (pSystem) {

        if (pSystem->lpszValue) {
            // save the previous lpszValue string before
            // SetSystemValueNameToGlobal mess it up
            dwBufferSize = (DWORD)MemorySize (pSystem->lpszValue) ;
            if (dwBufferSize <= sizeof(tempBuffer)) {
                pBuffer = tempBuffer ;
            } else {
                pBuffer = MemoryAllocate (dwBufferSize) ;
            }
            memcpy (pBuffer, pSystem->lpszValue, dwBufferSize) ;
        }

        SetSystemValueNameToGlobal (pSystem);
        UpdateSystemData (pSystem, ppPerfData) ;

        if (pSystem->lpszValue) {
            // retore the previous lpszValue string
            memcpy (pSystem->lpszValue, pBuffer, dwBufferSize) ;
            if (pBuffer != tempBuffer) {
                MemoryFree (pBuffer) ;
            }
        }
    }
    return (pSystem) ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\toolbar.c ===
//
//                                 Includes                                 
//


#include "setedit.h"
#include "commctrl.h"
#include "toolbar.h"
#include "status.h"     // for StatusLine & StatusLineReady

TBBUTTON tbButtons[] = {
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 4, IDM_TOOLBARADD,       TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 5, IDM_TOOLBARMODIFY,    TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 6, IDM_TOOLBARDELETE,    TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 0, 0,                    TBSTATE_ENABLED,   TBSTYLE_SEP,      0 },
   { 9, IDM_TOOLBAROPTIONS,   TBSTATE_ENABLED,   TBSTYLE_BUTTON,   0 },
} ;

#define TB_ENTRIES sizeof(tbButtons)/sizeof(tbButtons[0])

BOOL CreateToolbarWnd (HWND hWnd)
{

   hWndToolbar = CreateToolbarEx (hWnd,
      WS_CHILD | WS_BORDER | WS_VISIBLE,
      IDM_TOOLBARID,
      10,                  // number of tools inside the bitmap
      hInstance,
      idBitmapToolbar,     // bitmap resource ID (can't use MAKEINTRESOURCE)
      tbButtons,
      TB_ENTRIES,0,0,0,0,sizeof(TBBUTTON)) ;

   return (hWndToolbar ? TRUE : FALSE) ;

}  // ToolbarInitializeApplication

void ToolbarEnableButton (HWND hWndTB, int iButtonNum, BOOL bEnable)
{
   SendMessage (hWndTB, TB_ENABLEBUTTON, iButtonNum, (LONG)bEnable) ;
}  // ToolbarEnableButton

void ToolbarDepressButton (HWND hWndTB, int iButtonNum, BOOL bDepress)
{
   if (iButtonNum >= IDM_TOOLBARADD && iButtonNum <= IDM_TOOLBARBOOKMARK)
      {
      // these buttons are push button and will not stay down after
      // each hit
      SendMessage (hWndTB, TB_PRESSBUTTON, iButtonNum, (LONG)bDepress) ;
      }
   else
      {
      // for the four view buttons, have to use CHECKBUTTON so they
      // will stay down after selected.
      SendMessage (hWndTB, TB_CHECKBUTTON, iButtonNum, (LONG)bDepress) ;
      }
}  // ToolbarDepressButton

void OnToolbarHit (WPARAM wParam, LPARAM lParam)
{

   WORD  ToolbarHit ;

   if (HIWORD(wParam) == TBN_ENDDRAG)
      {
      StatusLineReady (hWndStatus) ;
      }
   else if (HIWORD(wParam) == TBN_BEGINDRAG)
      {
      ToolbarHit = LOWORD (lParam) ;

      if (ToolbarHit >= IDM_TOOLBARADD &&
          ToolbarHit <= IDM_TOOLBARDELETE)
         {
         ToolbarHit -= IDM_TOOLBARADD ;
         ToolbarHit += IDM_EDITADDCHART ;
         }
      else if (ToolbarHit == IDM_TOOLBAROPTIONS)
         {
         ToolbarHit = IDM_OPTIONSCHART ;
         }

      StatusLine (hWndStatus, ToolbarHit) ;
      }
}  // OnToolBarHit



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\toolbar.h ===
//
//                            Exported Functions                            
//

BOOL CreateToolbarWnd (HWND hWnd) ;

void ToolbarEnableButton (HWND hWndTB,
                          int iButtonNum,
                          BOOL bEnable) ;


void ToolbarDepressButton (HWND hWndTB,
                           int iButtonNum,
                           BOOL bDepress) ;

void OnToolbarHit (WPARAM wParam, 
                   LPARAM lParam) ;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\system.h ===
void SystemFree (PPERFSYSTEM pSystem, BOOL bDeleteTheSystem);


void FreeSystems (PPERFSYSTEM pSystemFirst) ;

void DeleteUnusedSystems (PPPERFSYSTEM ppSystemFirst, int iNoUsedSystem) ;

PPERFSYSTEM SystemGet (PPERFSYSTEM pSystemFirst,
                       LPCTSTR lpszSystemName) ;


PPERFSYSTEM  SystemAdd (PPPERFSYSTEM ppSystemFirst,
                        LPCTSTR lpszSystemName,
                        HWND    hDlg);


DWORD SystemCount (PPERFSYSTEM pSystemFirst) ;


PPERFSYSTEM GetComputer (HDLG hDlg,
                         WORD wControlID,
                         BOOL bWarn,
                         PPERFDATA *pPerfData,
                         PPERFSYSTEM *ppSystemFirst) ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\setedit.c ===
/*****************************************************************************
 *
 *  SetEdit.c - This is the WinMain module. It creates the main window and
 *              the threads, and contains the main MainWndProc.
 *
 *  Microsoft Confidential
 *  Copyright (c) 1992-1993 Microsoft Corporation
 *
 *  Authors -
 *
 *       Russ Blake
 *       Hon-Wah Chan
 *
 ****************************************************************************/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//
#undef NOSYSCOMMANDS

// DEFINE_GLOBALS will define all the globals listed in globals.h
#define DEFINE_GLOBALS

#include "setedit.h"

#include "command.h"

#include "graph.h"
#include "grafdata.h"   // for QuerySaveChart
#include "legend.h"
#include "init.h"
#include "perfmops.h"
#include "toolbar.h"    // for CreateToolbar
#include "status.h"     // for CreatePMStatusWindow
#include "utils.h"

#include "fileopen.h"   // for FileOpen
#ifdef DEBUGDUMP
    #include "debug.h"
#endif



#define dwToolbarStyle     (WS_CHILD | WS_VISIBLE | TBS_NOCAPTION)

extern TCHAR szInternational[] ;

//==========================================================================//
//                              Message Handlers                            //
//==========================================================================//

void static OnSize (HWND hWnd,
                    WORD xWidth,
                    WORD yHeight)
/*
   Effect:        Perform any actions needed when the main window is
                  resized. In particular, size the four data windows,
                  only one of which is visible right now.
*/
{  // OnSize
    SizePerfmonComponents () ;
}


void static OnCreate (HWND hWnd)
/*
   Effect:        Perform all actions needed when the main window is
                  created. In particular, create the three data windows,
                  and show one of them.

   To Do:         Check for proper creation. If not possible, we will
                  need to abort creation of the program.

   Called By:     MainWndProc only, in response to a WM_CREATE message.
*/
{  // OnCreate
    hWndGraph = CreateGraphWindow (hWnd) ;

    hWndStatus = CreatePMStatusWindow (hWnd) ;

    CreateToolbarWnd (hWnd) ;
    MinimumSize += WindowHeight (hWndToolbar) ;

    Options.bMenubar = TRUE ;
    Options.bToolbar = TRUE ;
    Options.bStatusbar = TRUE;
    Options.bAlwaysOnTop = FALSE ;

    // initialize to chart view - HWC
    iPerfmonView = IDM_VIEWCHART;


    ShowWindow (PerfmonViewWindow (), SW_SHOWNORMAL) ;
}  // OnCreate



//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

void MenuBarHit (WPARAM wParam)
{
    if (wParam == MENUCLOSING) {
        StatusLineReady (hWndStatus) ;
        dwCurrentMenuID = 0 ;
    } else if (HIWORD(wParam) & MF_SYSMENU) {
        WORD   SystemMenuItem = 0 ;
        switch (LOWORD (wParam)) {
            case SC_RESTORE:
                SystemMenuItem = IDM_SYSTEMRESTORE ;
                break ;

            case SC_SIZE:
                SystemMenuItem = IDM_SYSTEMSIZE ;
                break ;

            case SC_MOVE:
                SystemMenuItem = IDM_SYSTEMMOVE ;
                break ;

            case SC_MINIMIZE:
                SystemMenuItem = IDM_SYSTEMMINIMIZE ;
                break ;

            case SC_MAXIMIZE:
                SystemMenuItem = IDM_SYSTEMMAXIMIZE ;
                break ;

            case SC_CLOSE:
                SystemMenuItem = IDM_SYSTEMCLOSE ;
                break ;

            case SC_TASKLIST:
                SystemMenuItem = IDM_SYSTEMSWITCHTO ;
                break ;
        }

        if (SystemMenuItem) {
            StatusLine (hWndStatus, SystemMenuItem) ;
            dwCurrentMenuID = MenuIDToHelpID (SystemMenuItem) ;
        }
    } else {
        StatusLine (hWndStatus, LOWORD (wParam)) ;
    }
}

void OnDropFile (WPARAM wParam)
{
    TCHAR FileName [FilePathLen + 1] ;
    LPTSTR         pFileNameStart ;
    HANDLE         hFindFile ;
    WIN32_FIND_DATA FindFileInfo ;
    int            NameOffset ;
    int            NumOfFiles = 0 ;

    NumOfFiles = DragQueryFile ((HDROP) wParam, 0xffffffff, NULL, 0) ;
    if (NumOfFiles > 0) {
        // we only open the first file for now
        DragQueryFile((HDROP) wParam, 0, FileName, FilePathLen) ;

        pFileNameStart = ExtractFileName (FileName) ;
        NameOffset = (int)(pFileNameStart - FileName) ;

        // convert short filename to long NTFS filename if necessary
        hFindFile = FindFirstFile (FileName, &FindFileInfo) ;
        if (hFindFile && hFindFile != INVALID_HANDLE_VALUE) {
            // append the file name back to the path name
            lstrcpy (&FileName[NameOffset], FindFileInfo.cFileName) ;
            FindClose (hFindFile) ;
        }

        FileOpen (hWndMain, (int)0, (LPTSTR)FileName) ;
        PrepareMenu (GetMenu (hWndMain));
    }

    DragFinish ((HDROP) wParam) ;
}

LRESULT
APIENTRY
MainWndProc (
            HWND hWnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
            )
{
    LRESULT  lRetCode = 0L ;
    BOOL     bCallDefWinProc = FALSE ;

    switch (LOWORD (message)) {  // switch
        case WM_COMMAND:
            if (PerfmonCommand (hWnd,wParam,lParam))
                return(0);
            else
                bCallDefWinProc = TRUE ;
            break;

        case WM_MENUSELECT:
            MenuBarHit (wParam) ;
            break ;

        case WM_SHOWWINDOW:
            PrepareMenu (GetMenu (hWnd)) ;
            break ;

        case WM_SIZE:
            OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ;
            break ;

        case WM_GETMINMAXINFO:
            {
                MINMAXINFO   *pMinMax ;

                pMinMax = (MINMAXINFO *) lParam ;
                pMinMax->ptMinTrackSize.x = MinimumSize ;
                pMinMax->ptMinTrackSize.y = MinimumSize ;
            }
            break ;

        case WM_CREATE:
            OnCreate (hWnd) ;
            ViewChart (hWnd) ;
            PrepareMenu (GetMenu (hWnd)) ;
            break ;

        case WM_DESTROY:
            WinHelp (hWndMain, pszHelpFile, HELP_QUIT, 0) ;
            PostQuitMessage (0);
            break ;

        case WM_QUERYENDSESSION:
            // please shut it down
            return (1) ;
            break ;

        case WM_ENDSESSION:
            if (wParam == TRUE) {
                // close any log file before closing down
                PerfmonClose (hWnd) ;
                return (1) ;
            } else
                bCallDefWinProc = TRUE ;
            break ;

        case WM_CLOSE:
            if (QuerySaveChart (hWnd, pGraphs)) {
                PerfmonClose (hWnd) ;
            }
            break ;

        case WM_ACTIVATE:
            {
                int   fActivate = LOWORD (wParam) ;

                bPerfmonIconic = (BOOL) HIWORD (wParam) ;
                if (bPerfmonIconic == 0 && fActivate != WA_INACTIVE) {
                    // set focus on the Legend window
                    SetFocus (hWndGraphLegend) ;
                }
            }
            break ;

        case WM_SYSCOLORCHANGE:
            DeletePerfmonSystemObjects () ;
            CreatePerfmonSystemObjects () ;
            WindowInvalidate (PerfmonViewWindow()) ;
            break ;

        case WM_DROPFILES:
            OnDropFile (wParam) ;
            return (0) ;
            break ;

        default:
            bCallDefWinProc = TRUE ;
            break;

    }  // switch

    if (bCallDefWinProc) {
        lRetCode = DefWindowProc (hWnd, message, wParam, lParam) ;
    }
    return (lRetCode);
}  // MainWndProc


int
PASCAL
WinMain (
        HINSTANCE hCurrentInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpszCmdLine,
        int nCmdShow
        )
{  // WinMain
    MSG      msg;

    if (!PerfmonInitialize (hCurrentInstance, hPrevInstance,
                            lpszCmdLine, nCmdShow))
        return (FALSE) ;

    DragAcceptFiles (hWndMain, TRUE) ;

    while (GetMessage (&msg, NULL, 0, 0)) {
        if (//FIXFIX !ModelessDispatch (hWndLog, &msg) &&
            // doesnt work
            !TranslateAccelerator(hWndMain, hAccelerators, &msg)) {
            TranslateMessage (&msg) ;
            DispatchMessage (&msg) ;
        }
    }  // while

    return((int)msg.wParam);
}


void
SizePerfmonComponents (void)
{
    RECT           rectClient ;
    int            xWidth, yHeight ;
    int            yToolbarHeight ;
    int            yStatusHeight ;
    int            yViewHeight ;

    GetClientRect (hWndMain, &rectClient) ;
    xWidth = rectClient.right - rectClient.left ;
    yHeight = rectClient.bottom - rectClient.top ;

    if (Options.bToolbar) {
        SendMessage (hWndToolbar, WM_SIZE, 0, 0L) ;
    }

    yToolbarHeight = Options.bToolbar ? (WindowHeight (hWndToolbar) - 1) : 0 ;
    yStatusHeight = Options.bStatusbar ? StatusHeight (hWndStatus) : 0 ;

    if (Options.bStatusbar) {
        if (yToolbarHeight + yStatusHeight > yHeight) {
            // too small to display both toolbar and status bar
            // just display part of the status bar
            yStatusHeight = yHeight - yToolbarHeight ;
        }

        MoveWindow (hWndStatus,
                    0, yHeight - yStatusHeight, xWidth, yStatusHeight, TRUE) ;
        //WindowInvalidate (hWndStatus) ;
    }
    //WindowInvalidate (hWndMain) ;
    WindowShow (hWndStatus, Options.bStatusbar) ;
    WindowShow (hWndToolbar, Options.bToolbar) ;

    yViewHeight = yHeight - yStatusHeight - yToolbarHeight ;

    MoveWindow (hWndGraph,
                0, yToolbarHeight,
                xWidth, yViewHeight,
                TRUE) ;
}  // SizePerfmonComponents
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\typedefs.h ===
//======================================//
// Options Data Type                    //
//======================================//


typedef struct OPTIONSSTRUCT
   {  
   BOOL           bMenubar ;
   BOOL           bToolbar ;
   BOOL           bStatusbar ;
   BOOL           bAlwaysOnTop ;
   } OPTIONS ;


//======================================//
// Basic "Derived" Types                //
//======================================//


typedef HANDLE HLIBRARY ;
typedef HANDLE HMEMORY ;
typedef HWND HDLG ;
typedef HWND HCONTROL ;
typedef VOID *LPMEMORY ;


//======================================//
// Perfmon-Specific Types               //
//======================================//


typedef PERF_DATA_BLOCK *PPERFDATA ;
typedef PERF_OBJECT_TYPE *PPERFOBJECT ;
typedef PERF_COUNTER_DEFINITION *PPERFCOUNTERDEF ;
typedef PERF_INSTANCE_DEFINITION *PPERFINSTANCEDEF ;



#define TEMP_BUF_LEN    256


    // This structure links together the Performance data for multiple
    // systems, each of which has some counter instance which the user
    // is interested in.

typedef struct _COUNTERTEXT {
    struct  _COUNTERTEXT  *pNextTable;
    DWORD   dwLangId;
    DWORD   dwLastId;
    DWORD   dwCounterSize;
    DWORD   dwHelpSize;
    LPWSTR  *TextString;
    LPWSTR  HelpTextString;
} COUNTERTEXT;

typedef COUNTERTEXT *PCOUNTERTEXT;


typedef struct PERFSYSTEMSTRUCT
   {
   struct  PERFSYSTEMSTRUCT *pSystemNext;
   TCHAR   sysName[MAX_SYSTEM_NAME_LENGTH+1];
   HKEY    sysDataKey;
   COUNTERTEXT CounterInfo;
   DWORD   FailureTime;
   LPTSTR  lpszValue;
   BOOL    bSystemNoLongerNeeded;
   BOOL    bSystemCounterNameSaved;
   // the following used by perf data thread
   DWORD           dwThreadID ;
   HANDLE          hThread ;
   DWORD           StateData ;
   HANDLE          hStateDataMutex ;
   HANDLE          hPerfDataEvent ;
   PPERFDATA       pSystemPerfData ;

   // mainly used by Alert to report system up/down   
   DWORD           dwSystemState ;

   // system version
   DWORD           SysVersion ;

   } PERFSYSTEM, *PPERFSYSTEM, **PPPERFSYSTEM ;


typedef struct _graph_options {
    BOOL    bLegendChecked ;
    BOOL    bMenuChecked ;
    BOOL    bLabelsChecked;
    BOOL    bVertGridChecked ;
    BOOL    bHorzGridChecked ;
    BOOL    bStatusBarChecked ;
    INT     iVertMax ;
    FLOAT   eTimeInterval ;
    INT     iGraphOrHistogram ;
    INT     GraphVGrid,
            GraphHGrid,
            HistVGrid,
            HistHGrid ;

} GRAPH_OPTIONS ;



//======================================//
// Line Data Type                       //
//======================================//


#define LineTypeChart            1
#define LineTypeAlert            2
#define LineTypeReport           3



typedef struct LINEVISUALSTRUCT
   {
   COLORREF       crColor ;
   int            iColorIndex ;    
   
   int            iStyle ;
   int            iStyleIndex ;

   int            iWidth ;
   int            iWidthIndex ;
   } LINEVISUAL ;

typedef LINEVISUAL *PLINEVISUAL ;


typedef struct _LINESTRUCT
   {
   struct  _LINESTRUCT             *pLineNext;
   int                             bFirstTime;
   int                             iLineType ;
   LPTSTR                          lnSystemName;

   struct _PERF_OBJECT_TYPE        lnObject;
   LPTSTR                          lnObjectName;

   struct _PERF_COUNTER_DEFINITION lnCounterDef;
   LPTSTR                          lnCounterName;

   struct _PERF_INSTANCE_DEFINITION lnInstanceDef;
   LPTSTR                          lnInstanceName;
   DWORD                           dwInstanceIndex;

   LPTSTR                          lnPINName;
   LPTSTR                          lnParentObjName;
   DWORD                           lnUniqueID;     // Of instance, if any

   LARGE_INTEGER                   lnNewTime;
   LARGE_INTEGER                   lnOldTime;

   LARGE_INTEGER                   lnOldTime100Ns ;
   LARGE_INTEGER                   lnNewTime100Ns ;

   LARGE_INTEGER                   lnaCounterValue[2];
   LARGE_INTEGER                   lnaOldCounterValue[2];

   DWORD                           lnCounterType;
   DWORD                           lnCounterLength;
   LARGE_INTEGER                   lnPerfFreq ;

   FLOAT                           (*valNext)(struct _LINESTRUCT *lnParam);

   LINEVISUAL                      Visual ;

   // bUserEdit = TRUE --> user added the Instance/Parent names
   BOOL                            bUserEdit ;

   //=============================//
   // Chart-related fields        //
   //=============================//

                     
   // iScaleIndex field is also used as column number in report view
   // I don't see anypoint of increasing this struct for something
   // just need by Report Export feature...
   HPEN                            hPen ;
   int                             iScaleIndex ; 
   FLOAT	                          eScale;
   FLOAT                           FAR *lnValues;
   int                             *aiLogIndexes ;
   FLOAT                           lnMaxValue ;
   FLOAT                           lnMinValue ;
   FLOAT                           lnAveValue ;
   INT                             lnValidValues;

   //=============================//
   // Alert-related fields        //
   //=============================//

   HBRUSH                  hBrush ;
   BOOL                    bAlertOver ;         // over or under?
   FLOAT                   eAlertValue ;        // value to compare
   LPTSTR                  lpszAlertProgram ;   // program to run
   BOOL                    bEveryTime ;         // run every time or once?
   BOOL                    bAlerted ;           // alert happened on line?


   //=============================//
   // Report-related fields       //
   //=============================//

   struct  _LINESTRUCT    *pLineCounterNext;
   int                     xReportPos ;
   int                     yReportPos ;
   }LINESTRUCT ;


typedef LINESTRUCT *PLINESTRUCT ;
typedef PLINESTRUCT PLINE ;
typedef PLINE *PPLINE ;


//======================================//
// DISKLINE data type                   //
//======================================//

#define dwLineSignature    (MAKELONG ('L', 'i'))

typedef struct DISKSTRINGSTRUCT
   {  
   DWORD          dwLength ;
   DWORD          dwOffset ;
   } DISKSTRING ;
typedef DISKSTRING *PDISKSTRING ;


typedef struct DISKLINESTRUCT
   {
   int            iLineType ;
   DISKSTRING     dsSystemName ;
   DISKSTRING     dsObjectName ;
   DISKSTRING     dsCounterName ;
   DISKSTRING     dsInstanceName ;
   DISKSTRING     dsPINName ;
   DISKSTRING     dsParentObjName ;
   DWORD          dwUniqueID ;
   LINEVISUAL     Visual ;
   int            iScaleIndex ;
   FLOAT          eScale ;
   BOOL           bAlertOver ;
   FLOAT          eAlertValue ;
   DISKSTRING     dsAlertProgram ;
   BOOL           bEveryTime ;
   } DISKLINE ;

typedef DISKLINE *PDISKLINE ;



typedef FLOAT DFN (PLINESTRUCT);
typedef DFN   *PDFN;

typedef struct _TIMELINESTRUCT
{
    INT ppd ;                           // Pixels Per DataPoint
    INT rppd ;                          // Remaining Pixels Per DataPoint
    INT xLastTime ;                     // X coordinate of last time line.
    INT iValidValues ;                  // High water mark for valid data.
}TIMELINESTRUCT;




//======================================//
// Graph Data Type                      //
//======================================//


#define iGraphMaxTics   26



// This structure describes the characteristics of one visual
// graph. It is linked for the day when multiple graphs are
// displayed within one instance of the application.

typedef struct _GRAPHSTRUCT
   {
   BOOL           bManualRefresh ;
   HWND           hWnd ;
   BOOL           bModified ;

   PPERFSYSTEM       pSystemFirst;
   PLINESTRUCT    pLineFirst;

   int            xNumTics ;
   int            yNumTics ;
   int            axTics [iGraphMaxTics] ;
   int            ayTics [iGraphMaxTics] ;

   RECT           rectHorzScale ;
   RECT           rectVertScale ;
   RECT           rectData ;
   HRGN           hGraphRgn ;

   INT            gMaxValues;
   INT            gKnownValue;

   LINEVISUAL     Visual ;

   DWORD          gInterval;
   GRAPH_OPTIONS  gOptions;
   TIMELINESTRUCT gTimeLine;

   PPOINT         pptDataPoints ;
   SYSTEMTIME     *pDataTime ;

   HPEN           hGridPen ;
   HANDLE         hbRed ;
   BOOL           HighLightOnOff ;
   TCHAR          gszBuf[TEMP_BUF_LEN] ;  // general space or loading space
   } GRAPHSTRUCT ;
typedef GRAPHSTRUCT *PGRAPHSTRUCT;
// minor version 3 to support alert, report, log intervals in msec
#define ChartMajorVersion    1
#define ChartMinorVersion    3


typedef struct DISKCHARTSTRUCT
   {
   DWORD          dwNumLines ;
   INT            gMaxValues;
   LINEVISUAL     Visual ;
   GRAPH_OPTIONS  gOptions ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   } DISKCHART ;


typedef struct _SAVESTRUCT
{
    INT version;
    INT type;
    INT iPerfmonView ;
    INT graph_offset;
    INT alert_offset;
    INT log_offset;
}SAVESTRUCT;
typedef SAVESTRUCT *PSAVESTRUCT;

typedef struct _GRAPH_COUNTERS
{
    INT sys_name_len;
    INT sys_name_offset;
    INT obj_name_len;
    INT obj_name_offset;
    INT cnt_name_len;
    INT cnt_name_offset;
    INT inst_name_len;
    INT inst_name_offset;
    INT PIN_name_len;
    INT PIN_name_offset;
    INT POB_name_len;
    INT POB_name_offset;
    DWORD inst_unique_id;
    DWORD counter_type;
    DWORD counter_length;
    int   iScaleIndex ;
    FLOAT eScale;
    LINEVISUAL    Visual ;
    INT updated;
}GRAPH_COUNTERS;

typedef struct _SAVGRAFSTRUCT
{
    INT preference;
    INT MaxValues;
    RECT GraphArea;
    GRAPH_OPTIONS options;
    INT num_counters;
    GRAPH_COUNTERS counters[1];
}SAVGRAFSTRUCT;
typedef SAVGRAFSTRUCT *PSAVGRAFSTRUCT;


typedef struct _SAVLOGSTRUCT
{
    DWORD	logInterval;
    BOOL        logActive;
    LPTSTR	logFileName;
    DWORD	logFileSize;
}SAVLOGSTRUCT;
typedef SAVLOGSTRUCT *PSAVLOGSTRUCT;


#define DEF_GRAPH_INTERVAL  1000        // milliseconds
#define LINE_GRAPH          1
#define BAR_GRAPH           2
#define DEF_GRAPH_VMAX      100
#define SUCCESS             0
#define MIN_TIMER_INTERVAL 50
#define GRAPH_TIMER_ID      1


#define NO_VALUES_YET            -1
        // initial value for index to known and drawn values
#define MIN_NMAXVALUES           10
        // minimum number of values that a graph needs to be displayed ( >1 )
#define DX_CALIBRATION_LEFT      1
        // space between calibration value and left window edge
#define DX_LEGEND_RIGHT          1
        // space between right window edge and legend
#define DY_AXIS_TOP              0
        // space to allow at top of graph
#define DY_AXIS_BOTTOM           0
        // space to allow at bottom of graph
#define LG_TO_CALIBRATION_RATIO  5
        // width of calibration values * this number can't exceed screen width
#define LG_TO_LEGEND_RATIO       2
        // width of legend * this number can't exceed screen width


// LINEGRAPH
#define DEFAULT_VAL_BOTTOM        0
#define DEFAULT_DVAL_AXISHEIGHT   100
#define DEFAULT_MAX_VALUES        100
#define GRAPH_INWARD_EDGE           5
#define GRAPH_LEFT_PAD              5
#define GRAPH_DOWNWARD_EDGE         5
#define ROOM_FOR_LEGEND            40

// LINEGRAPH DISP
#define DEFAULT_F_DISPLAY_LEGEND  TRUE
#define DEFAULT_F_DISPLAY_CALIBRATION TRUE



// This define is used to avoid problems which have arisen in the memory
// manager. Obviously, it's better application behaviour to use
// discardable memory whenever possible, but some versions of the
// system don't do too well with MOVEABLE memory in the realm of
// multiple threads. The threads themselves don't step on this
// memory, the system or some other process does. At any rate,
// until things are looking more reliable in the memory department,
// we're sticking with FIXED allocations. This is NOT a criticism of
// the hard-working people who write the memory code, just a practical
// development strategy. OK ?
#if 0
#define MEM_SEL_DU_JOUR     GMEM_MOVEABLE | GMEM_DISCARDABLE | GMEM_ZEROINIT
#else
    // This will not be used until it is bug-free.
#define MEM_SEL_DU_JOUR     GMEM_FIXED | GMEM_ZEROINIT
#endif

#define NONE_LEN            MAX_SYSTEM_NAME_LENGTH + 1



//======================================//
// Log/Playback/Alert Status IDs        //
//======================================//


#define iPMStatusClosed      100
#define iPMStatusPaused      200
#define iPMStatusCollecting  300
#define iPMStatusPlaying     400


//======================================//
// Log Data Type                        //
//======================================//


typedef struct _LOGENTRYSTRUCT
   {
   DWORD          ObjectTitleIndex ;
   TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ;
   TCHAR          szObject [PerfObjectLen + 1] ;
   BOOL           bSaveCurrentName ;
   struct  _LOGENTRYSTRUCT *pNextLogEntry ;
   } LOGENTRY ;

typedef LOGENTRY *PLOGENTRY ;


typedef struct LOGSTRUCT
   {
   int            iStatus ;
   BOOL           bManualRefresh ;
   BOOL           bModified ;

   PPERFSYSTEM    pSystemFirst;
   TCHAR          szFilePath [FilePathLen + 1] ;
   HANDLE         hFile ;
   long           lIndexBlockOffset ;
   int            iIndex ;
   PPERFDATA      pPerfData ;
   PPERFDATA      pLogData ;
   DWORD          dwDetailLevel ;
   long           lFileSize ;
   DWORD          iIntervalMSecs ;
   int            xCol1Width ;
   PLOGENTRY      pLogEntryFirst ;

   // the following is used for saving system counter names into a 
   // log file.  They are reset every the user changes log files.
   BOOL           bSaveCounterName ;
   LPTSTR         pBaseCounterName ;
   long           lBaseCounterNameSize ;
   long           lBaseCounterNameOffset ;

   // this is used for checking system time when re-logging.
   // this is to avoid log data not in chronological order.
   SYSTEMTIME     LastLogTime ;
   } LOG ;

typedef LOG *PLOG ;


//======================================//
// Log File Data Types                  //
//======================================//


#define LogFileSignatureLen      6
#define LogFileBlockMaxIndexes   100


#define LogFileSignature         TEXT("Loges")
#define LogFileVersion           2
#define LogFileRevision          0


#define LogFileIndexData         0x01
#define LogFileIndexBookmark     0x02
#define LogFileIndexNextBlock    0x04
#define LogFileIndexEOF          0x08
#define LogFileIndexCounterName  0x010


typedef struct LOGHEADERSTRUCT
   {  // LOGHEADER
   TCHAR          szSignature [LogFileSignatureLen] ;
   int            iLength ;
   WORD           wVersion ;
   WORD           wRevision ;
   long           lBaseCounterNameOffset ;
   }  LOGHEADER ;

typedef LOGHEADER *PLOGHEADER ;


typedef struct LOGINDEXSTRUCT
   {  // LOGINDEX
   UINT           uFlags ;
   SYSTEMTIME     SystemTime ;
   long           lDataOffset ;
   int            iSystemsLogged ;
   } LOGINDEX ;

typedef LOGINDEX *PLOGINDEX ;


#define LogIndexSignatureLen  7
#define LogIndexSignature     TEXT("Index ")
#define LogIndexSignature1    "Perfmon Index"

typedef struct LOGFILEINDEXBLOCKSTRUCT
   {
   TCHAR          szSignature [LogIndexSignatureLen] ;
   int            iNumIndexes ;
   LOGINDEX       aIndexes [LogFileBlockMaxIndexes] ;
   DWORD          lNextBlockOffset ;
   } LOGINDEXBLOCK ;

typedef LOGINDEXBLOCK *PLOGINDEXBLOCK ;


typedef struct LOGPOSITIONSTRUCT
   {
   PLOGINDEXBLOCK pIndexBlock ;
   int            iIndex ;
   int            iPosition ;
   } LOGPOSITION ;

typedef LOGPOSITION *PLOGPOSITION ;


//======================================//
// Bookmark Data Type                   //
//======================================//


#define BookmarkCommentLen    256

typedef struct BOOKMARKSTRUCT
   {
   struct BOOKMARKSTRUCT *pBookmarkNext;
   SYSTEMTIME     SystemTime ;
   TCHAR          szComment [BookmarkCommentLen] ;
   int            iTic ;
   } BOOKMARK, *PBOOKMARK, **PPBOOKMARK ;

typedef struct _LOGFILECOUNTERNAME
   {
   TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH] ;
   DWORD          dwLastCounterId ;
   DWORD          dwLangId;
   long           lBaseCounterNameOffset ;
   long           lCurrentCounterNameOffset ;
   long           lMatchLength ;
   long           lUnmatchCounterNames ;
   } LOGFILECOUNTERNAME, *PLOGFILECOUNTERNAME, **PPLOGFILECOUNTERNAME ;

typedef struct COUNTERNAMESTRUCT
   {
   struct COUNTERNAMESTRUCT *pCounterNameNext ;
   LOGFILECOUNTERNAME       CounterName ;
   LPTSTR                   pRemainNames ;
   } LOGCOUNTERNAME, *PLOGCOUNTERNAME ;

typedef struct PLAYBACKLOGSTRUCT
   {
   LPTSTR         szFilePath ;
   LPTSTR         szFileTitle ;
//   TCHAR          szFilePath [FilePathLen + 1] ;
//   TCHAR          szFileTitle [FilePathLen + 1] ;
   int            iStatus ;
   HANDLE         hFile ;
   PLOGHEADER     pHeader ;
   HANDLE         hMapHandle ;
   int            iTotalTics ;
   int            iSelectedTics ;
   LOGPOSITION    BeginIndexPos ;
   LOGPOSITION    EndIndexPos ;
   LOGPOSITION    StartIndexPos ;
   LOGPOSITION    StopIndexPos ;
   PBOOKMARK      pBookmarkFirst ;
   LPTSTR         pBaseCounterNames ;
   long           lBaseCounterNameSize ;
   long           lBaseCounterNameOffset ;
   PLOGCOUNTERNAME   pLogCounterNameFirst ;
   } PLAYBACKLOG ;

//=====================================//
// Log File Counter Name data type     //
//=====================================//


// minor version 3 to support alert, report, log intervals in msec
// minor version 5 to support storing Log file name in setting
//  and start logging after reading the file.
#define LogMajorVersion    1
#define LogMinorVersion    5


typedef struct DISKLOGSTRUCT
   {
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   TCHAR          LogFileName[260] ;
   } DISKLOG ;




//======================================//
// Alert Data Type                      //
//======================================//


typedef struct ALERTSTRUCT
   {
   HWND           hWnd ;
   HWND           hAlertListBox ;
   int            iStatus ;
   BOOL           bManualRefresh ;
   BOOL           bModified ;


   PPERFSYSTEM    pSystemFirst ;
   PLINESTRUCT    pLineFirst ;

   DWORD          iIntervalMSecs ;

   LINEVISUAL     Visual ;

   HFONT          hFontItems ;
   int            yItemHeight ;

   int            xColorWidth ;
   int            xDateWidth ;
   int            xTimeWidth ;
   int            xNumberWidth ;
   int            xConditionWidth ;

   // used in controlling the horz scrollbar
   int            xTextExtent ;     
   
   BOOL           bSwitchToAlert ;
   BOOL           bNetworkAlert ;
   TCHAR          MessageName [16] ;

   // used for the network alert thread
   HANDLE         hNetAlertThread ;
   DWORD          dwNetAlertThreadID ;
   } ALERT ;

typedef ALERT *PALERT ;



#define AlertMajorVersion    1

// minor version 2 to support Alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert event logging
// minor version 6 to support alert misc options
#define AlertMinorVersion    6


typedef struct DISKALERTSTRUCT
   {
   LINEVISUAL     Visual ;
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   BOOL           bSwitchToAlert ;
   BOOL           bNetworkAlert ;
   TCHAR          MessageName [16] ;
   OPTIONS        perfmonOptions ;
   DWORD          MiscOptions ;
   } DISKALERT ;


//======================================//
// Report Data Type                     //
//======================================//


typedef struct COLUMNGROUPSTRUCT
   {
   struct COLUMNGROUPSTRUCT *pColumnGroupNext ;
   struct COLUMNGROUPSTRUCT  *pColumnGroupPrevious ;
   struct OBJECTGROUPSTRUCT  *pParentObject ;
   LPTSTR         lpszParentName ;
   LPTSTR         lpszInstanceName ;
   int            ParentNameTextWidth ;
   int            InstanceNameTextWidth ;
   int            xPos ;
   int            xWidth ;
   int            yFirstLine ;
   int            ColumnNumber ;  // start from 0
   DWORD          dwInstanceIndex;
   } COLUMNGROUP ;


typedef COLUMNGROUP *PCOLUMNGROUP ;


typedef struct COUNTERGROUPSTRUCT
   {
   struct COUNTERGROUPSTRUCT *pCounterGroupNext ;
   struct COUNTERGROUPSTRUCT *pCounterGroupPrevious ;
   struct OBJECTGROUPSTRUCT  *pParentObject ;
   DWORD          dwCounterIndex ;
   PLINE          pLineFirst ;
   int            yLine ;
   int            xWidth ;
   } COUNTERGROUP ;

typedef COUNTERGROUP *PCOUNTERGROUP ;


typedef struct OBJECTGROUPSTRUCT
   {
   struct OBJECTGROUPSTRUCT  *pObjectGroupNext ;
   struct OBJECTGROUPSTRUCT  *pObjectGroupPrevious ;
   struct SYSTEMGROUPSTRUCT  *pParentSystem ;
   LPTSTR         lpszObjectName ;
   PCOUNTERGROUP  pCounterGroupFirst ;
   PCOLUMNGROUP   pColumnGroupFirst ;
   int            yFirstLine ;
   int            yLastLine ;
   int            xWidth ;
   } OBJECTGROUP ;

typedef OBJECTGROUP *POBJECTGROUP ;


typedef struct SYSTEMGROUPSTRUCT
   {  // SystemGroup
   struct SYSTEMGROUPSTRUCT *pSystemGroupNext ;
   struct SYSTEMGROUPSTRUCT *pSystemGroupPrevious ;
   LPTSTR         lpszSystemName ;
   POBJECTGROUP   pObjectGroupFirst ;
   int            yFirstLine ;
   int            yLastLine ;
   int            xWidth ;
   } SYSTEMGROUP ;

typedef  SYSTEMGROUP   *PSYSTEMGROUP ;


typedef struct REPORTSTRUCT
   {  // REPORT
   HWND           hWnd ;
   int            iStatus ;
   BOOL           bManualRefresh ;
   BOOL           bModified ;

   TCHAR          szTitle [120] ;
   SYSTEMTIME     SystemTime ;

   PPERFSYSTEM    pSystemFirst ;
   PLINE          pLineFirst ;

   PSYSTEMGROUP   pSystemGroupFirst ;
   PLINE          pLineCurrent ;

   LINEVISUAL     Visual ;


   DWORD          iIntervalMSecs ;
   FLOAT          eTimeInterval ;
   HFONT          hFont ;
   HFONT          hFontHeaders ;
   int            yLineHeight ;

   int            xMaxCounterWidth ;
   int            xValueWidth ;

   int            xWidth ;
   int            yHeight ;
   } REPORT ;

typedef REPORT *PREPORT ; 

// minor version 3 to support alert, report, log intervals in msec
#define ReportMajorVersion    1
#define ReportMinorVersion    3


typedef struct DISKREPORTSTRUCT
   {
   LINEVISUAL     Visual ;
   DWORD          dwNumLines ;
   DWORD          dwIntervalSecs ;
   BOOL           bManualRefresh ;
   OPTIONS        perfmonOptions ;
   } DISKREPORT ;


//======================================//
// File Header Type                     //
//======================================//


#define PerfSignatureLen  20

#define szPerfChartSignature     TEXT("PERF CHART")
#define szPerfAlertSignature     TEXT("PERF ALERT")
#define szPerfLogSignature       TEXT("PERF LOG")
#define szPerfReportSignature    TEXT("PERF REPORT")
#define szPerfWorkspaceSignature TEXT("PERF WORKSPACE")


typedef struct PERFFILEHEADERSTRUCT
   {  // PERFFILEHEADER
   TCHAR          szSignature [PerfSignatureLen] ;
   DWORD          dwMajorVersion ;
   DWORD          dwMinorVersion ;
   BYTE           abyUnused [100] ;
   } PERFFILEHEADER ;

#define WorkspaceMajorVersion    1

// minor version 1 to support window placement data
// minor version 2 to support alert msg name
// minor version 3 to support alert, report, log intervals in msec
// minor version 4 to support alert eventlog
// minor version 5 to support log file name in log setting
// minor version 6 to support alert misc options
#define WorkspaceMinorVersion    6

typedef struct DISKWORKSPACESTRUCT
   {
   INT               iPerfmonView ;
   DWORD             ChartOffset ;
   DWORD             AlertOffset ;
   DWORD             LogOffset ;
   DWORD             ReportOffset ;
   WINDOWPLACEMENT   WindowPlacement ;   
   } DISKWORKSPACE ;




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\utils.c ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            utils.c -- miscellaneous utility routines.

            This file contains miscellaneous utiltity routines, mostly
            low-level windows helpers. These routines are not specific
            to the perfmon utillity.

  Copyright 1992, Microsoft Corporation. All Rights Reserved.
  Microsoft Confidential.
==============================================================================
*/


//==========================================================================//
//                                  Includes                                //
//==========================================================================//



#include <stdarg.h>  // For ANSI variable args. Dont use UNIX <varargs.h>
#include <stdlib.h>  // For itoa
#include <stdio.h>   // for vsprintf.
#include <string.h>  // for strtok
#include <wchar.h>   // for swscanf

#include "setedit.h"
#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines
#include "utils.h"
#include "pmhelpid.h"       // IDs for WinHelp
#include "perfmops.h"

//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define DOS_FILES                0x0000   // Ordinary files
#define DOS_READONLY             0x0001   // Read-only files
#define DOS_HIDDEN               0x0002   // Hidden files
#define DOS_SYSTEM               0x0004   // System files
#define DOS_SUBDIRECTORIES       0x0010   // Subdirectories
#define DOS_ARCHIVES             0x0020   // Archives
#define DOS_LIB_DIR              0x2000   // LB_DIR flag
#define DOS_DRIVES               0x4000   // Drives
#define DOS_EXCLUSIVE            0x8000   // Exclusive bit
#define DOS_DRIVES_DIRECTORIES   0xC010   // Find drives and directories only


#define WILD_ONE                 '?'
#define WILD_ANY                 '*'




//==========================================================================//
//                              Local Functions                             //
//==========================================================================//



void ClientRectToScreen (HWND hWnd,
                         LPRECT lpRect)
/*
   Effect:        Remaps lpRect from client coordinates to screen
                  coordinates. Analogous to ClientToScreen for rectangles.

   Note:          To convert a rectangle from the client coordinates of
                  Wnd1 to the client coordinates of Wnd2, call:

                        ClientRectToScreen (hWnd1, &rect) ;
                        ScreenRectToClient (hWnd2, &rect) ;

   See Also:      ClientToScreen (windows), ScreenRectToClient.

   Internals:     Since a rectangle is really only two points, let
                  windows do the work with ClientToScreen.
*/
{  /* ClientRectToScreen */
    POINT    pt1, pt2 ;

    pt1.x = lpRect->left ;
    pt1.y = lpRect->top ;

    pt2.x = lpRect->right ;
    pt2.y = lpRect->bottom ;

    ClientToScreen (hWnd, &pt1) ;
    ClientToScreen (hWnd, &pt2) ;

    lpRect->left = pt1.x ;
    lpRect->top = pt1.y ;

    lpRect->right = pt2.x ;
    lpRect->bottom = pt2.y ;
}  // ClientRectToScreen


void ScreenRectToClient (HWND hWnd, LPRECT lpRect)
/*
   Effect:        Remaps lpRect from screen coordinates to client
                  coordinates. Analogous to ScreenToClient for rectangles.

   Note:          To convert a rectangle from the client coordinates of
                  Wnd1 to the client coordinates of Wnd2, call:

                        ClientRectToScreen (hWnd1, &rect) ;
                        ScreenRectToClient (hWnd2, &rect) ;

   See Also:      ScreenToClient (windows), ClientRectToScreen.

   Internals:     Since a rectangle is really only two points, let
                  windows do the work with ScreenToClient.
*/
{  // ScreenRectToClient
    POINT    pt1, pt2 ;

    pt1.x = lpRect->left ;
    pt1.y = lpRect->top ;

    pt2.x = lpRect->right ;
    pt2.y = lpRect->bottom ;

    ScreenToClient (hWnd, &pt1) ;
    ScreenToClient (hWnd, &pt2) ;

    lpRect->left = pt1.x ;
    lpRect->top = pt1.y ;

    lpRect->right = pt2.x ;
    lpRect->bottom = pt2.y ;
}  // ScreenRectToClient


//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//


void Line (HDC hDC,
           HPEN hPen,
           int x1, int y1,
           int x2, int y2)
{  // Line
    HPEN           hPenPrevious ;

    if (hPen)
        hPenPrevious = SelectPen (hDC, hPen) ;
    MoveToEx (hDC, x1, y1, NULL) ;
    LineTo (hDC, x2, y2) ;
    if (hPen)
        SelectObject (hDC, hPenPrevious) ;
}  // Line

#if 0
void HLine (HDC hDC,
            HPEN hPen,
            int x1,
            int x2,
            int y)
{  // HLine
    Line (hDC, hPen, x1, y, x2, y) ;
}


void VLine (HDC hDC,
            HPEN hPen,
            int x,
            int y1,
            int y2)
{  // VLine
    Line (hDC, hPen, x, y1, x, y2) ;
}  // VLine
#endif

#ifdef  KEEP_UTIL
void Fill (HDC hDC,
           DWORD rgbColor,
           LPRECT lpRect)
{  // Fill
    HBRUSH         hBrush ;

    hBrush = CreateSolidBrush (rgbColor) ;
    if (hBrush) {
        FillRect (hDC, lpRect, hBrush) ;
        DeleteBrush (hBrush) ;
    }
}  // Fill

void ThreeDConvex (HDC hDC,
                   int x1, int y1,
                   int x2, int y2)
{  // ThreeDConvex
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [8] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious ;


    //
    // Draw Face                  
    //

    hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
    PatBlt (hDC,
            x1 + ThreeDPad, y1 + ThreeDPad,
            x2 - x1 - ThreeDPad, y2 - y1 - ThreeDPad,
            PATCOPY) ;
    SelectBrush (hDC, hBrushPrevious) ;

    //
    // Draw Highlight             
    //

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;   // this works slightly diff. than Line ??
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    aPoints [3].x = x1 + 1 ;
    aPoints [3].y = y2 - 1 ;
    aPoints [4].x = x1 + 1 ;
    aPoints [4].y = y1 + 1 ;
    aPoints [5].x = x2 - 1 ;
    aPoints [5].y = y1 + 1 ;

    aCounts [0] = 3 ;
    aCounts [1] = 3 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;


    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

    //   HLine (hDC, hPenHighlight, x1, x2, y1) ;              // outside top line
    //   HLine (hDC, hPenHighlight, x1 + 1, x2 - 1, y1 + 1) ;  // inside top line
    //   VLine (hDC, hPenHighlight, x1, y1, y2) ;              // outside left line
    //   VLine (hDC, hPenHighlight, x1 + 1, y1 + 1, y2 - 1) ;  // inside left line

    //
    // Draw Shadow                
    //

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y2 - 2 ;
    aPoints [3].x = x1 + 2 ;
    aPoints [3].y = y2 - 2 ;

    aPoints [4].x = x2 - 1 ;
    aPoints [4].y = y1 ;
    aPoints [5].x = x2 - 1 ;
    aPoints [5].y = y2 - 1;
    aPoints [6].x = x2 - 2 ;
    aPoints [6].y = y2 - 1 ;
    aPoints [7].x = x2 - 2 ;
    aPoints [7].y = y1 ;

    aCounts [0] = 4 ;
    aCounts [1] = 4 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;


    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

    //   HLine (hDC, hPenShadow, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    //   HLine (hDC, hPenShadow, x1 + 2, x2, y2 - 2) ;   // inside bottom line
    //   VLine (hDC, hPenShadow, x2 - 1, y1 + 1, y2) ;   // outside right line
    //   VLine (hDC, hPenShadow, x2 - 2, y1 + 2, y2) ;   // inside right line

}  // ThreeDConvex



void ThreeDConcave (HDC hDC,
                    int x1, int y1,
                    int x2, int y2,
                    BOOL bFace)
{  // ThreeDConcave
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [6] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious ;


    //
    // Draw Face                  
    //

    if (bFace) {
        hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
        PatBlt (hDC,
                x1 + ThreeDPad, y1 + ThreeDPad,
                x2 - x1 - ThreeDPad, y2 - y1 - ThreeDPad,
                PATCOPY) ;
        SelectBrush (hDC, hBrushPrevious) ;
    }

    //
    // Draw Shadow                
    //

    #if 1
    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    aPoints [3].x = x1 + 1 ;
    aPoints [3].y = y2 - 1 ;
    aPoints [4].x = x1 + 1 ;
    aPoints [4].y = y1 + 1 ;
    aPoints [5].x = x2 - 1 ;
    aPoints [5].y = y1 + 1 ;

    aCounts [0] = 3 ;
    aCounts [1] = 3 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

    #else
    HLine (hDC, hPenShadow, x1, x2, y1) ;              // outside top line
    HLine (hDC, hPenShadow, x1 + 1, x2 - 1, y1 + 1) ;  // inside top line
    VLine (hDC, hPenShadow, x1, y1, y2) ;              // outside left line
    VLine (hDC, hPenShadow, x1 + 1, y1 + 1, y2 - 1) ;  // inside left line
    #endif

    //
    // Draw Highlight             
    //

    #if 1
    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;

    aPoints [2].x = x2 - 1 ;
    aPoints [2].y = y2 - 1 ;
    aPoints [3].x = x2 - 1 ;
    aPoints [3].y = y1 ;

    aCounts [0] = 2 ;
    aCounts [1] = 2 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

    #else
    HLine (hDC, hPenHighlight, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    VLine (hDC, hPenHighlight, x2 - 1, y1 + 1, y2) ;   // outside right line
    #endif
}  // ThreeDConcave
#endif // KEEP_UTIL


void ThreeDConvex1 (HDC hDC,
                    int x1, int y1,
                    int x2, int y2)
{  // ThreeDConvex1
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [6] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious ;


    //
    // Draw Face                  
    //
#if 1
    hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
    PatBlt (hDC,
            x1 + 1, y1 + 1,
            x2 - x1 - 1, y2 - y1 - 1,
            PATCOPY) ;
    SelectBrush (hDC, hBrushPrevious) ;

    //
    // Draw Highlight             
    //

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    Polyline (hDC, aPoints, 3) ;

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;

#else
    HLine (hDC, hPenHighlight, x1, x2, y1) ;              // outside top line
    VLine (hDC, hPenHighlight, x1, y1, y2) ;              // outside left line
#endif

    //
    // Draw Shadow                
    //

#if 1
    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;

    aPoints [2].x = x2 - 1 ;
    aPoints [2].y = y2 - 1 ;
    aPoints [3].x = x2 - 1 ;
    aPoints [3].y = y1 ;

    aCounts [0] = 2 ;
    aCounts [1] = 2 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;
#else
    HLine (hDC, hPenShadow, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    VLine (hDC, hPenShadow, x2 - 1, y1 + 1, y2) ;   // outside right line
#endif

}  // ThreeDConvex1



void
ThreeDConcave1 (
               HDC hDC,
               int x1,
               int y1,
               int x2,
               int y2
               )
{  // ThreeDConcave1
    HBRUSH         hBrushPrevious ;
    POINT          aPoints [6] ;
    DWORD          aCounts [2] ;
    HPEN           hPenPrevious ;


    //
    // Draw Face                  
    //

    hBrushPrevious = SelectBrush (hDC, hBrushFace) ;
    PatBlt (hDC,
            x1 + 1, y1 + 1,
            x2 - x1 - 1, y2 - y1 - 1,
            PATCOPY) ;
    SelectBrush (hDC, hBrushPrevious) ;

    //
    // Draw Shadow                
    //

#if 1
    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenShadow) ;

    aPoints [0].x = x1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x1 ;
    aPoints [1].y = y1 ;
    aPoints [2].x = x2 ;
    aPoints [2].y = y1 ;

    Polyline (hDC, aPoints, 3) ;

    if (hPenShadow)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;
#else
    HLine (hDC, hPenShadow, x1, x2, y1) ;              // outside top line
    VLine (hDC, hPenShadow, x1, y1, y2) ;              // outside left line
#endif

    //
    // Draw Highlight             
    //
#if 1
    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenHighlight) ;

    aPoints [0].x = x1 + 1 ;
    aPoints [0].y = y2 - 1 ;
    aPoints [1].x = x2 ;
    aPoints [1].y = y2 - 1 ;

    aPoints [2].x = x2 - 1 ;
    aPoints [2].y = y2 - 2 ;
    aPoints [3].x = x2 - 1 ;
    aPoints [3].y = y1 ;

    aCounts [0] = 2 ;
    aCounts [1] = 2 ;

    PolyPolyline (hDC, aPoints, aCounts, 2) ;

    if (hPenHighlight)
        hPenPrevious = SelectPen (hDC, hPenPrevious) ;
#else
    HLine (hDC, hPenHighlight, x1 + 1, x2, y2 - 1) ;   // outside bottom line
    VLine (hDC, hPenHighlight, x2 - 1, y1 + 1, y2) ;   // outside right line
#endif

}  // ThreeDConcave1


int
TextWidth (
          HDC hDC,
          LPTSTR lpszText
          )
{
    SIZE           size ;

    if (!lpszText)
        return (0) ;

    GetTextExtentPoint (hDC, lpszText, lstrlen (lpszText), &size) ;
    return  (size.cx) ;
}


int
_cdecl
DlgErrorBox (
            HWND hDlg,
            UINT id,
            ...
            )
{
    TCHAR          szMessageFmt [FilePathLen + 1] ;
    TCHAR          szBuffer [FilePathLen * 2] ;
    va_list        vaList ;
    int            NumOfChar ;
    TCHAR          szApplication [WindowCaptionLen] ;

    NumOfChar = StringLoad (id, szMessageFmt) ;

    if (NumOfChar) {
        va_start (vaList, id) ;
        wvsprintf (szBuffer, szMessageFmt, vaList) ;
        va_end (vaList) ;

        StringLoad (IDS_APPNAME, szApplication) ;

        MessageBox (hDlg, szBuffer, szApplication,
                    MB_OK | MB_ICONSTOP | MB_TASKMODAL) ;
    }

    return (0) ;
}






int
FontHeight (
           HDC hDC,
           BOOL bIncludeLeading
           )
{  // FontHeight
    TEXTMETRIC     tm ;

    GetTextMetrics (hDC, &tm) ;
    if (bIncludeLeading)
        return (tm.tmHeight + tm.tmExternalLeading) ;
    else
        return (tm.tmHeight) ;
}  // FontHeight



int
TextAvgWidth (
             HDC hDC,
             int iNumChars
             )
{
    TEXTMETRIC     tm ;
    int            xAvgWidth ;

    GetTextMetrics (hDC, &tm) ;

    xAvgWidth = iNumChars * tm.tmAveCharWidth ;

    // add 10% slop
    return (MulDiv (xAvgWidth, 11, 10)) ;
}


void
WindowCenter (
             HWND hWnd
             )
/*
   Effect:        Center the window hWnd in the center of the screen.
                  Physically update the windows appearance as well.

   Globals:       xScreenWidth, yScreenHeight.
*/
{  // WindowCenter
    RECT           rectWindow ;
    int            xWindowWidth, yWindowHeight ;

    GetWindowRect (hWnd, &rectWindow) ;
    xWindowWidth = rectWindow.right - rectWindow.left ;
    yWindowHeight = rectWindow.bottom - rectWindow.top ;

    MoveWindow (hWnd,
                (xScreenWidth - xWindowWidth) / 2,
                (yScreenHeight - yWindowHeight) / 2,
                xWindowWidth,
                yWindowHeight,
                TRUE) ;
}  // WindowCenter



BOOL
DialogMove (
           HDLG hDlg,
           WORD wControlID,
           int xPos,
           int yPos,
           int xWidth,
           int yHeight
           )
/*
   Effect:        Move the control identified by wControlID in the dialog
                  hDlg to the new position (xPos, yPos), and resize to
                  (xWidth, yHeight). If any of these values are NOCHANGE, retain
                  the current value.

   Examples:      DialogMove (hDlg, IDD_FOO, 10, 20, NOCHANGE, NOCHANGE)
                     moves control but does not resize it

                  DialogMove (hDlg, IDD_FOO, NOCHANGE, NOCHANGE, 100, NOCHANGE)
                     sets width of control to 100
*/
{  // DialogMove
    HWND        hWndControl ;
    RECT        rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (FALSE) ;
    GetWindowRect (hWndControl, &rectControl) ;
    ScreenRectToClient (hDlg, &rectControl) ;

    MoveWindow (hWndControl,
                (xPos == NOCHANGE) ? rectControl.left : xPos,
                (yPos == NOCHANGE) ? rectControl.top : yPos,
                (xWidth == NOCHANGE) ? rectControl.right - rectControl.left : xWidth,
                (yHeight == NOCHANGE) ? rectControl.bottom - rectControl.top : yHeight,
                TRUE) ;

    return (TRUE) ;
}  // DialogMove


int
DialogWidth (
            HDLG hDlg,
            WORD wControlID
            )
{
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    return (rectControl.right - rectControl.left) ;
}


int
DialogHeight (
             HDLG hDlg,
             WORD wControlID
             )
{
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    return (rectControl.bottom - rectControl.top) ;
}


int
DialogXPos (
           HDLG hDlg,
           WORD wControlID
           )
{  // DialogXPos
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    ScreenRectToClient (hDlg, &rectControl) ;

    return  (rectControl.left) ;
}  // DialogXPos


int
DialogYPos (
           HDLG hDlg,
           WORD wControlID
           )
{  // DialogYPos
    HWND           hWndControl ;
    RECT           rectControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (0) ;

    GetWindowRect (hWndControl, &rectControl) ;
    ScreenRectToClient (hDlg, &rectControl) ;

    return  (rectControl.top) ;
}  // DialogYPos


void
DialogEnable (
             HDLG hDlg,
             WORD wID,
             BOOL bEnable
             )
/*
   Effect:        Enable or disable (based on bEnable) the control
                  identified by wID in dialog hDlg.

   See Also:      DialogShow.
*/
{  // DialogEnable
    HCONTROL       hControl ;

    hControl = GetDlgItem (hDlg, wID) ;
    if (hControl)
        EnableWindow (hControl, bEnable) ;
}  // DialogEnable


void
DialogShow (
           HDLG hDlg,
           WORD wID,
           BOOL bShow
           )
{  // DialogShow
    HCONTROL       hControl ;

    hControl = GetDlgItem (hDlg, wID) ;
    if (hControl)
        ShowWindow (hControl, bShow ? SW_SHOW : SW_HIDE) ;
}  // DialogShow






BOOL
_cdecl
DialogSetText (
              HDLG hDlg,
              WORD wControlID,
              WORD wStringID,
              ...
              )
{  // DialogSetText
    TCHAR           szFormat [ControlStringLen] ;
    TCHAR           szText [ControlStringLen] ;
    va_list         vaList ;

    if (LoadString (hInstance, wStringID,
                    szFormat, ControlStringLen - 1)) {
        va_start (vaList, wStringID) ;
        wvsprintf (szText, szFormat, vaList) ;
        va_end (vaList) ;

        SetDlgItemText (hDlg, wControlID, szText) ;
        return (TRUE) ;
    }  // if
    else
        return (FALSE) ;
}  // DialogSetText


BOOL
_cdecl
DialogSetString (
                HDLG hDlg,
                WORD wControlID,
                LPTSTR lpszFormat,
                ...
                )
{  // DialogSetString
    TCHAR          szText [ControlStringLen] ;
    va_list        vaList ;

    va_start (vaList, lpszFormat) ;
    wvsprintf (szText, lpszFormat, vaList) ;
    va_end (vaList) ;

    SetDlgItemText (hDlg, wControlID, szText) ;
    return (TRUE) ;
}  // DialogSetString



LPTSTR
LongToCommaString (
                  LONG lNumber,
                  LPTSTR lpszText
                  )
{  // LongToCommaString
    BOOL           bNegative ;
    TCHAR          szTemp1 [40] ;
    TCHAR          szTemp2 [40] ;
    LPTSTR         lpsz1 ;
    LPTSTR         lpsz2 ;
    int            i ;
    int            iDigit ;

    // 1. Convert the number to a reversed string.
    lpsz1 = szTemp1 ;
    bNegative = (lNumber < 0) ;
    lNumber = labs (lNumber) ;

    if (lNumber)
        while (lNumber) {
            iDigit = (int) (lNumber % 10L) ;
            lNumber /= 10L ;
            *lpsz1++ = (TCHAR) (TEXT('0') + iDigit) ;
        } else
        *lpsz1++ = TEXT('0') ;
    *lpsz1++ = TEXT('\0') ;


    // 2. reverse the string and add commas
    lpsz1 = szTemp1 + lstrlen (szTemp1) - 1 ;
    lpsz2 = szTemp2 ;

    if (bNegative)
        *lpsz2++ = TEXT('-') ;

    for (i = lstrlen (szTemp1) - 1;
        i >= 0 ;
        i--) {  // for
        *lpsz2++ = *lpsz1-- ;
        if (i && !(i % 3))
            *lpsz2++ = TEXT(',') ;
    }  // for
    *lpsz2++ = TEXT('\0') ;

    return (lstrcpy (lpszText, szTemp2)) ;
}  // LongToCommaString



BOOL
MenuSetPopup (
             HWND hWnd,
             int iPosition,
             WORD  wControlID,
             LPTSTR lpszResourceID
             )
{
    HMENU          hMenuMain ;
    HMENU          hMenuPopup ;
    TCHAR          szTopChoice [MenuStringLen + 1] ;

    hMenuMain = GetMenu (hWnd) ;
    if (!hMenuMain)
        return (FALSE);
    hMenuPopup = LoadMenu (hInstance, lpszResourceID) ;

    if (!hMenuPopup) {
        DestroyMenu(hMenuMain);
        return (FALSE) ;
    }

    StringLoad (wControlID, szTopChoice) ;
    return (ModifyMenu (hMenuMain, iPosition, MF_BYPOSITION | MF_POPUP,
                        (UINT_PTR) hMenuPopup, szTopChoice)) ;
}



LPTSTR
FileCombine (
            LPTSTR lpszFileSpec,
            LPTSTR lpszFileDirectory,
            LPTSTR lpszFileName
            )
{  // FileCombine

    int      stringLen ;
    TCHAR    DIRECTORY_DELIMITER[2] ;

    DIRECTORY_DELIMITER[0] = TEXT('\\') ;
    DIRECTORY_DELIMITER[1] = TEXT('\0') ;

    lstrcpy (lpszFileSpec, lpszFileDirectory) ;

    stringLen = lstrlen (lpszFileSpec) ;
    if (stringLen > 0 &&
        lpszFileSpec [stringLen - 1] != DIRECTORY_DELIMITER [0])
        lstrcat (lpszFileSpec, DIRECTORY_DELIMITER) ;

    lstrcat (lpszFileSpec, lpszFileName) ;

    return (lpszFileSpec) ;
}  // FileCombine

// This routine extract the filename portion from a given full-path filename
LPTSTR
ExtractFileName (
                LPTSTR pFileSpec
                )
{
    LPTSTR   pFileName = NULL ;
    TCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ;
    TCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ;

    if (pFileSpec) {
        pFileName = pFileSpec + lstrlen (pFileSpec) ;

        while (*pFileName != DIRECTORY_DELIMITER1 &&
               *pFileName != DIRECTORY_DELIMITER2) {
            if (pFileName == pFileSpec) {
                // done when no directory delimiter is found
                break ;
            }
            pFileName-- ;
        }

        if (*pFileName == DIRECTORY_DELIMITER1 ||
            *pFileName == DIRECTORY_DELIMITER2) {
            // directory delimiter found, point the
            // filename right after it
            pFileName++ ;
        }
    }
    return pFileName ;
}  // ExtractFileName

int
CBAddInt (
         HWND hWndCB,
         int iValue
         )
{  // CBAddInt
    TCHAR       szValue [ShortTextLen + 1] ;
    CHAR        szCharValue [ShortTextLen + 1] ;

    _itoa (iValue, (LPSTR)szCharValue, 10) ;
#ifdef UNICODE
    mbstowcs (szValue, (LPSTR)szCharValue, strlen((LPSTR)szCharValue)+1) ;
    return (CBAdd (hWndCB, szValue)) ;
#else
    return (CBAdd (hWndCB, szCharValue)) ;
#endif

}  // CBAddInt

void
DialogSetInterval (
                  HDLG hDlg,
                  WORD wControlID,
                  int  IntervalMSec
                  )
{
    TCHAR          szValue [MiscTextLen] ;

    TSPRINTF (szValue, TEXT("%3.3f"),
              (FLOAT)(IntervalMSec) / (FLOAT)1000.0) ;

    ConvertDecimalPoint (szValue);
    SetDlgItemText (hDlg, wControlID, szValue) ;
}

void
DialogSetFloat (
               HDLG hDlg,
               WORD wControlID,
               FLOAT eValue
               )
{
    TCHAR          szValue [40] ;
    FLOAT          tempValue = eValue ;

    if (tempValue < (FLOAT) 0.0) {
        tempValue = - tempValue ;
    }

    if (tempValue < (FLOAT) 1.0E+8) {
        TSPRINTF (szValue, TEXT("%1.4f"), eValue) ;
    } else {
        TSPRINTF (szValue, TEXT("%14.6e"), eValue) ;
    }

    ConvertDecimalPoint (szValue);
    SetDlgItemText (hDlg, wControlID, szValue) ;
}


FLOAT DialogFloat (HDLG hDlg,
                   WORD wControlID,
                   BOOL *pbOK)
/*
   Effect:        Return a floating point representation of the string
                  value found in the control wControlID of hDlg.

   Internals:     We use sscanf instead of atof becuase atof returns a
                  double. This may or may not be the right thing to do.
*/
{  // DialogFloat
    TCHAR          szValue [ShortTextLen+1] ;
    FLOAT          eValue ;
    int            iNumScanned ;

    DialogText (hDlg, wControlID, szValue) ;
    ReconvertDecimalPoint (szValue);
    iNumScanned = swscanf (szValue, TEXT("%e"), &eValue) ;

    if (pbOK)
        *pbOK = (iNumScanned == 1) ;

    return (eValue) ;
}  // DialogFloat



LPTSTR StringAllocate (LPTSTR lpszText1)
{  // StringAllocate
    LPTSTR         lpszText2 ;

    if (!lpszText1)
        return (NULL) ;

    if (lstrlen (lpszText1) == 0)
        return (NULL) ;

    lpszText2 = MemoryAllocate ((lstrlen (lpszText1)+1) * sizeof (TCHAR)) ;
    if (lpszText2)
        lstrcpy (lpszText2, lpszText1) ;

    return  (lpszText2) ;
}  // StringAllocate



int DivRound (int iNumerator, int iDenominator)
/*
   Effect:        Return the quotient (iNumerator / iDenominator).
                  Round the quotient to the nearest integer.
                  This function is similar to normal integer division (/),
                  but normal division always rounds down.

   Note:          Surely there must already be a runtime version of this,
                  but I couldn't find it.

   Note:          This function originally used the runtime div function
                  instead of (/ and %), but the div runtime function is
                  now broken (build 265).
*/
{  // DivRound
    int            iQuotient ;
    int            iRemainder ;


    iQuotient = iNumerator / iDenominator ;
    iRemainder = iNumerator % iDenominator ;

    if (iRemainder >= (iDenominator / 2))
        iQuotient++ ;

    return (iQuotient) ;
}


BOOL MenuEnableItem (HMENU hMenu,
                     WORD wID,
                     BOOL bEnable)
/*
   Effect:        Enable or disable, depending on bEnable, the menu item
                  associated with id wID in the menu hMenu.

                  Any disabled menu items are displayed grayed out.

   See Also:      EnableMenuItem (windows).
*/
{  // MenuEnableItem
    return (EnableMenuItem (hMenu, wID,
                            bEnable ?
                            (MF_ENABLED | MF_BYCOMMAND) :
                            (MF_GRAYED | MF_BYCOMMAND))) ;
}  // MenuEnableItem


int BitmapWidth (HBITMAP hBitmap)
{  // BitmapWidth
    BITMAP  bm ;

    GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &bm) ;
    return (bm.bmWidth) ;
}  // BitmapWidth


int BitmapHeight (HBITMAP hBitmap)
{  // BitmapHeight
    BITMAP  bm ;

    GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &bm) ;
    return (bm.bmHeight) ;
}  // BitmapHeight



int WindowHeight (HWND hWnd)
{  // WindowHeight
    RECT           rectWindow ;

    GetWindowRect (hWnd, &rectWindow) ;
    return (rectWindow.bottom - rectWindow.top) ;
}  // WindowHeight



int WindowWidth (HWND hWnd)
{  // WindowWidth
    RECT           rectWindow ;

    GetWindowRect (hWnd, &rectWindow) ;
    return (rectWindow.right - rectWindow.left) ;
}  // WindowWidth



void WindowResize (HWND hWnd,
                   int xWidth,
                   int yHeight)
/*
   Effect:        Change the size of the window hWnd, leaving the
                  starting position intact.  Redraw the window.

                  If either xWidth or yHeight is NULL, keep the
                  corresponding dimension unchanged.

   Internals:     Since hWnd may be a child of another parent, we need
                  to scale the MoveWindow arguments to be in the client
                  coordinates of the parent.

*/
{  // WindowResize
    RECT           rectWindow ;
    HWND           hWndParent ;

    GetWindowRect (hWnd, &rectWindow) ;
    hWndParent = WindowParent (hWnd) ;

    if (hWndParent)
        ScreenRectToClient (hWndParent, &rectWindow) ;

    MoveWindow (hWnd,
                rectWindow.left,
                rectWindow.top,
                xWidth ? xWidth : rectWindow.right - rectWindow.left,
                yHeight ? yHeight : rectWindow.bottom - rectWindow.top,
                TRUE) ;
}  // WindowResize




void WindowSetTopmost (HWND hWnd, BOOL bTopmost)
/*
   Effect:        Set or clear the "topmost" attribute of hWnd. If a window
                  is "topmost", it remains ontop of other windows, even ones
                  that have the focus.
*/
{
    SetWindowPos (hWnd, bTopmost ? HWND_TOPMOST : HWND_NOTOPMOST,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE) ;
}


void WindowEnableTitle (HWND hWnd, BOOL bTitle)
{
    DWORD          dwStyle ;


    dwStyle = WindowStyle (hWnd) ;

    if (bTitle)
        dwStyle = WS_TILEDWINDOW | dwStyle ;
    else
        dwStyle =
        dwStyle &
        ~ (WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX) ;

    if (!bTitle)
        SetMenu (hWnd, NULL) ;

    WindowSetStyle (hWnd, dwStyle) ;
    SetWindowPos (hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE |
                  SWP_NOZORDER | SWP_FRAMECHANGED );
}

// removing the following routines since LINK32 is not doing that for us
#ifdef  KEEP_UTIL
int MessageBoxResource (HWND hWndParent,
                        WORD wTextID,
                        WORD wTitleID,
                        UINT uiStyle)
/*
   Effect:        Just like MessageBox, but takes the title and format
                  strings from the resoure. In addition, the format string
                  is used as a printf style format, combined with the
                  additional arguments.
*/
{  // MessageBoxResource
    TCHAR          szText [MessageLen + 1] ;
    TCHAR          szCaption [WindowCaptionLen + 1] ;

    StringLoad (wTextID, szText) ;
    StringLoad (wTitleID, szCaption) ;

    return (MessageBox (hWndParent, szText, szCaption, uiStyle)) ;
}  // MessageBoxResource


    #define WndProcKey   TEXT("OLDWNDPROC")

FARPROC WindowSetWndProc (HWND hWnd,
                          HANDLE hInstance,
                          FARPROC lpfnNewWndProc)
/*
   Effect:     Replace the window procedure of hWnd with lpfnNewWndProc.
               Return the existing window procedure.

   Note:       For proper subclassing, NewWndProc should pass all
               unhandled messages to the original wndproc.

   Called By:  WindowSubclass, WindowUnsubclass.
*/
{  // WindowSetWndProc
    FARPROC     lpfnNewProcInstance ;
    FARPROC     lpfnOldProc ;

    lpfnOldProc = (FARPROC) GetWindowLongPtr (hWnd, GWLP_WNDPROC) ;
    lpfnNewProcInstance = MakeProcInstance (lpfnNewWndProc, hInstance) ;
    SetWindowLongPtr (hWnd, GWLP_WNDPROC, (LONG_PTR) lpfnNewProcInstance) ;

    return (lpfnOldProc) ;
}  // WindowSetWndProc

WNDPROC WindowGetOriginalWndProc (HWND hWnd)
/*
   Effect:        Return a far pointer to the "original" wndproc for
                  hWnd.

   Assert:        WindowSetOriginalProc was already called on this hWnd.

   See Also:      WindowSetOriginalWndProc.
*/
{  // WindowGetOriginalWndProc
    return (WNDPROC) GetProp (hWnd, WndProcKey) ;
}  // WindowGetOriginalWndProc


void WindowSetOriginalWndProc (HWND hWnd,
                               FARPROC lpfnWndProc)
/*
   Effect:        Save away a far pointer to the "original" wndproc for
                  hWnd.

   See Also:      WindowGetOriginalProc.
*/
{  // WindowSetOriginalProc
    SetProp (hWnd, WndProcKey, (LPSTR) lpfnWndProc) ;
}  // WindowSetOriginalProc


void WindowSubclass (HWND hWnd,
                     HANDLE hInstance,
                     FARPROC lpfnNewWndProc)
/*
   Effect:        Replace the wndproc for hWnd with lpfnNewWndProc.
                  Save away a pointer to the original procedure.

   See Also:      WindowUnsubclass.
*/
{  // WindowSubclass
    FARPROC     lpfnOldWndProc ;

    lpfnOldWndProc = WindowSetWndProc (hWnd, hInstance, lpfnNewWndProc) ;
    WindowSetOriginalWndProc (hWnd, lpfnOldWndProc) ;
}  // WindowSubclass


LONG
WindowCallOriginalWndProc (
                          HWND hWnd,
                          UINT msg,
                          WPARAM wParam,
                          LPARAM lParam
                          )
{
    WNDPROC        lpfnOriginalWndProc ;

    lpfnOriginalWndProc = WindowGetOriginalWndProc (hWnd) ;
    if (lpfnOriginalWndProc)
        return ((LONG) CallWindowProc (lpfnOriginalWndProc,
                                       hWnd, msg, wParam, lParam)) ;
    else return (FALSE) ;
}



LRESULT
APIENTRY
FocusCtlWndProc (
                HWND hWnd,
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{  // FocusCtlWndProc
    BOOL           bCallDefProc ;
    LRESULT        lReturnValue ;


    bCallDefProc = TRUE ;
    lReturnValue = 0L ;

    switch (wMsg) {  // switch
        case WM_SETFOCUS:
            SendMessage (WindowParent (hWnd),
                         WM_DLGSETFOCUS, WindowID (hWnd), 0) ;
            break ;


        case WM_KILLFOCUS:
            SendMessage (WindowParent (hWnd),
                         WM_DLGKILLFOCUS, WindowID (hWnd), 0) ;
            break ;

        default:
            bCallDefProc = TRUE ;
    }  // switch


    if (bCallDefProc)
        lReturnValue = WindowCallOriginalWndProc (hWnd, wMsg, wParam, lParam) ;

    return (lReturnValue);
}  // FocusWndProc



BOOL DlgFocus (HDLG hDlg, WORD wControlID)
{  // DlgFocus
    HWND           hWndControl ;

    hWndControl = DialogControl (hDlg, wControlID) ;
    if (!hWndControl)
        return (FALSE) ;

    WindowSubclass (hWndControl, hInstance, (FARPROC) FocusCtlWndProc) ;
    return (TRUE) ;
}  // DlgFocus


BOOL DeviceNumColors (HDC hDC)
{  // DeviceNumColors
    int            nPlanes ;
    int            nBitsPixel ;

    nPlanes = GetDeviceCaps (hDC, PLANES) ;
    nBitsPixel = GetDeviceCaps (hDC, BITSPIXEL) ;

    return (1 << (nPlanes * nBitsPixel)) ;
}  // DeviceNumColors


void DrawBitmap (HDC hDC,
                 HBITMAP hBitmap,
                 int xPos,
                 int yPos,
                 LONG  lROPCode)
{  // DrawBitmap
    BITMAP  bm ;
    HDC     hDCMemory ;

    hDCMemory = CreateCompatibleDC (hDC) ;
    if (hDCMemory) {
        SelectObject (hDCMemory, hBitmap) ;
    
        GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &bm) ;
    
        BitBlt (hDC,                     // DC for Destination surface
                xPos, yPos,              // location in destination surface
                bm.bmWidth, bm.bmHeight, // dimension of bitmap
                hDCMemory,               // DC for Source surface
                0, 0,                    // location in source surface
                lROPCode) ;              // ROP code
    
        DeleteDC (hDCMemory) ;
    }
}  // DrawBitmap


#endif  // KEEP_UTIL

#ifdef PERFMON_DEBUG

    #define MikeBufferSize         256


int _cdecl mike (TCHAR *szFormat, ...)
/*
   Note:          This function returns a value so that it can more easily
                  be used in conditional expressions.
*/
{  // mike
    TCHAR          szBuffer [MikeBufferSize] ;
    va_list        vaList ;

    va_start (vaList, szFormat) ;
    wvsprintf (szBuffer, szFormat, vaList) ;
    va_end (vaList) ;

    MessageBox (NULL, szBuffer, TEXT("Debug"), MB_OK | MB_TASKMODAL) ;
    return (0) ;
}  // mike



int _cdecl mike1 (TCHAR *szFormat, ...)
/*
   Note:          This function returns a value so that it can more easily
                  be used in conditional expressions.
*/
{  //  mike1
    TCHAR           szBuffer [MikeBufferSize] ;
    va_list        vaList ;
    HDC            hDC ;
    RECT           rect ;

    va_start (vaList, szFormat) ;
    wvsprintf (szBuffer, szFormat, vaList) ;
    va_end (vaList) ;

    rect.left = 0 ;
    rect.right = xScreenWidth ;
    rect.top = 0 ;
    rect.bottom = 20 ;

    hDC = CreateScreenDC () ;
    ExtTextOut (hDC, 0, 0, ETO_OPAQUE, &rect,
                szBuffer, lstrlen (szBuffer), NULL) ;
    DeleteDC (hDC) ;

    return (0) ;
}  // mike1

int _cdecl mike2 (TCHAR *szFormat, ...)
/*
   Note:          This function returns a value so that it can more easily
                  be used in conditional expressions.
*/
{  //  mike2
    TCHAR           szBuffer [MikeBufferSize] ;
    va_list        vaList ;

    va_start (vaList, szFormat) ;
    wvsprintf (szBuffer, szFormat, vaList) ;
    va_end (vaList) ;

    OutputDebugString (szBuffer) ;

    return (0) ;
}  // mike2
#endif      // PERFMON_DEBUG



int inttok (LPSTR lpszText, LPSTR lpszDelimiters)
{  // inttok

    // Inttok only works with LPSTRs because of the atoi & strtok

    LPSTR   lpszToken ;

    lpszToken = strtok (lpszText, lpszDelimiters) ;

    if (lpszToken)
        return (atoi (lpszToken)) ;
    else
        return (0) ;
}  // inttok


void WindowPlacementToString (PWINDOWPLACEMENT pWP,
                              LPTSTR lpszText)
{
    TSPRINTF (lpszText, TEXT("%d %d %d %d %d %d %d %d %d"),
              pWP->showCmd,
              pWP->ptMinPosition.x,
              pWP->ptMinPosition.y,
              pWP->ptMaxPosition.x,
              pWP->ptMaxPosition.y,
              pWP->rcNormalPosition.left,
              pWP->rcNormalPosition.top,
              pWP->rcNormalPosition.right,
              pWP->rcNormalPosition.bottom) ;
}


void StringToWindowPlacement (LPTSTR lpszText,
                              PWINDOWPLACEMENT pWP)
{  // StringToWindowPlacement
    CHAR  SpaceStr[2];
    CHAR  LocalText[TEMP_BUF_LEN];


    SpaceStr[0] = ' ' ;
    SpaceStr[1] = '\0' ;

#ifdef UNICODE
    // convert the unicode string to char string
    // so we could use inttok
    wcstombs (LocalText, lpszText, sizeof(LocalText)) ;
#else
    strcpy (LocalText, lpszText) ;
#endif

    pWP->length = sizeof (WINDOWPLACEMENT) ;
    pWP->flags = 0 ;
    pWP->showCmd = inttok (LocalText, SpaceStr) ;
    pWP->ptMinPosition.x = inttok (NULL, SpaceStr) ;
    pWP->ptMinPosition.y = inttok (NULL, SpaceStr) ;
    pWP->ptMaxPosition.x = inttok (NULL, SpaceStr) ;
    pWP->ptMaxPosition.y = inttok (NULL, SpaceStr) ;
    pWP->rcNormalPosition.left = inttok (NULL, SpaceStr) ;
    pWP->rcNormalPosition.top = inttok (NULL, SpaceStr) ;
    pWP->rcNormalPosition.right = inttok (NULL, SpaceStr) ;
    pWP->rcNormalPosition.bottom = inttok (NULL, SpaceStr) ;
}  // StringToWindowPlacement



int LogFontHeight (HDC hDC,
                   int iPointSize)
/*
   Effect:        Return the appropriate pixel height for the lfHeight
                  field of the LOGFONT structure for the requested point
                  size. This size depends on the number of pixels per
                  logical inch of the current display context, hDC.

   Called By:     Any function which wants to create a particular
                  point-height font.
*/
{  // LogFontHeight
    return (-MulDiv (iPointSize, GetDeviceCaps (hDC, LOGPIXELSY), 72)) ;
}  // LogFontHeight


// this routine converts the input menu id into help id.
DWORD MenuIDToHelpID (DWORD MenuID)
{
    DWORD HelpID = 0 ;

    if (MenuID >= IDM_FIRSTMENUID && MenuID <= IDM_LASTMENUID) {
        // only special cases...
        if (MenuID >= IDM_OPTIONSREFRESHNOWCHART &&
            MenuID <= IDM_OPTIONSREFRESHNOWREPORT) {
            HelpID = HC_PM_MENU_OPTIONSREFRESHNOW ;
        } else {
            HelpID = MenuID - MENUIDTOHELPID ;
        }
#ifndef ADVANCED_PERFMON
        // need to convert these 2 IDs for Perf. Meter
        if (HelpID == HC_PM_MENU_HELPABOUT) {
            HelpID = HC_NTPM_MENU_HELPABOUT ;
        } else if (HelpID == HC_PM_MENU_FILEEXIT) {
            HelpID = HC_NTPM_MENU_FILEEXIT ;
        }
#endif
    }

    return (HelpID) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\winhelpr.h ===
/*
==============================================================================

  Application:

            Microsoft Windows NT (TM) Performance Monitor

  File:
            wincrack.h - Windows helper macros.

            This file contains macros for more easily dealing with windows
            messages and objects. Think of it as an extension to windows.h.

   Written by:

            Mike Moskowitz 8 Apr 92.

  Copyright 1992, Microsoft Corporation. All Rights Reserved.
==============================================================================
*/



//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define SetFont(hWnd, hFont)                          \
   (SendMessage ((hWnd), WM_SETFONT, (WPARAM) hFont, 0))


//======================================//
// Object-differentiation routines      //
//======================================//


// Windows APIs deal with all GDI objects the same. There's a SelectObject,
// no SelectBitmap, SelectFont, etc. We use these instead to make the code
// easier to read. Also, you can redefine one of these to check the 
// validity of a particular GDI object type.


#define SelectBitmap(hDC, hBitmap)                    \
   (SelectObject (hDC, hBitmap))

#define SelectFont(hDC, hFont)                        \
   (SelectObject (hDC, hFont))

#define SelectBrush(hDC, hBrush)                      \
   (SelectObject (hDC, hBrush))

#define DeleteBrush(hBrush)                           \
   (DeleteObject (hBrush))

#define SelectPen(hDC, hPen)                          \
   (SelectObject (hDC, hPen))

#define DeletePen(hPen)                               \
   (DeleteObject (hPen))


//======================================//
//                                      //
//======================================//


#define CBData(hWndCB, iIndex)                        \
   (SendMessage (hWndCB, CB_GETITEMDATA, iIndex, 0L))


#define CBSetData(hWndCB, iIndex, lData)              \
   (SendMessage (hWndCB, CB_SETITEMDATA, iIndex, (LONG) lData))


#define CBAdd(hWndCB, lpszText)                       \
   ((int)(DWORD)SendMessage((hWndCB), CB_ADDSTRING,   \
    0, (LPARAM)(LPCSTR)(lpszText)))


#define CBFind(hWndCB, lpszText)                      \
   (SendMessage (hWndCB, CB_FINDSTRING, 0xFFFFFFFF, (LPARAM) lpszText))


#define CBInsert(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_INSERTSTRING, (WPARAM) iIndex, (LPARAM) lpszText))


#define CBReset(hWndCB)                               \
   ((int)(DWORD)SendMessage((hWndCB), CB_RESETCONTENT,\
    0, (LPARAM)0))


#define CBSelection(hWndCB)                           \
   (SendMessage (hWndCB, CB_GETCURSEL, 0, 0L))


#define CBSetSelection(hWndCB, iIndex)                \
   (SendMessage (hWndCB, CB_SETCURSEL, iIndex, 0L))


#define CBString(hWndCB, iIndex, lpszText)            \
   (SendMessage (hWndCB, CB_GETLBTEXT, iIndex, (LPARAM) lpszText))


#define CBStringLen(hWndCB, iIndex)                   \
   (SendMessage (hWndCB, CB_GETLBTEXTLEN, iIndex, 0L))



//======================================//
// Listbox helpers                      //
//======================================//


#define LBAdd(hWndLB, lpszText)                       \
   (SendMessage (hWndLB, LB_ADDSTRING, 0, (LPARAM) lpszText))


#define LBData(hWndLB, iIndex)                        \
   (SendMessage (hWndLB, LB_GETITEMDATA, iIndex, 0L))


#define LBDelete(hWndLB, iIndex)                      \
   (SendMessage (hWndLB, LB_DELETESTRING, iIndex, 0L))


#define LBFind(hWndLB, lpszText)                      \
   (SendMessage (hWndLB, LB_FINDSTRING, (WPARAM) -1, (LPARAM) lpszText))


#define LBFocus(hWndLB)                               \
   (SendMessage (hWndLB, LB_GETCARETINDEX, 0, 0))


#define LBInsert(hWndLB, iIndex, lpszText)            \
   (SendMessage (hWndLB, LB_INSERTSTRING, (WPARAM) iIndex, (LPARAM) lpszText))


#define LBNumItems(hWndLB)                            \
   ((int) SendMessage (hWndLB, LB_GETCOUNT, 0, 0))


#define LBReset(hWndLB)                               \
   ((int)(DWORD)SendMessage((hWndLB), LB_RESETCONTENT,\
    0, (LPARAM)0))


#define LBSelected(hwndLB, index)                     \
   ((int)(DWORD)SendMessage((hwndLB), LB_GETSEL,      \
    (WPARAM)(int)(index), 0L))


#define LBSelection(hWndLB)                           \
   (SendMessage (hWndLB, LB_GETCURSEL, 0, 0L))


#define LBSetData(hWndLB, iIndex, lData)              \
   (SendMessage (hWndLB, LB_SETITEMDATA, iIndex, (LONG) lData))


#define LBSetSelection(hWndLB, iIndex)                \
   (SendMessage (hWndLB, LB_SETCURSEL, iIndex, 0L))


#define LBString(hwndLB, iIndex, lpszText)            \
   ((int)(DWORD)SendMessage((hwndLB), LB_GETTEXT,     \
    (WPARAM)(int)(iIndex), (LPARAM)(LPCSTR)(lpszText)))


#define MLBSetSelection(hWndMLB, iIndex, bSet)        \
   (SendMessage (hWndMLB, LB_SETSEL, (WPARAM) bSet, (LPARAM) iIndex))

#define LBSetVisible(hWndLB, iIndex)                  \
   (SendMessage (hWndLB, LB_SETCARETINDEX, (WPARAM) iIndex, 0L))

 
#define LBSetRedraw(hWndLB, bDrawOnOff)               \
   (SendMessage (hWndLB, WM_SETREDRAW, (WPARAM) bDrawOnOff, 0L))


#define LBSetHorzExtent(hWndLB, wExtent)              \
   (SendMessage (hWndLB, LB_SETHORIZONTALEXTENT, (WPARAM)wExtent, 0L))

//======================================//
// Edit helpers                         //
//======================================//


#define EditModified(hWndEdit)                        \
   (SendMessage ((hWndEdit), EM_GETMODIFY, (WPARAM) 0, (LPARAM) 0))


#define EditSetModified(hWndEdit, bModified)                     \
   (SendMessage ((hWndEdit), EM_SETMODIFY, (WPARAM) bModified, 0))


#define EditSetLimit(hWndEdit, iLimit)                \
   (SendMessage ((hWndEdit), EM_LIMITTEXT, (WPARAM) iLimit, 0))
#define EditSetTextPos(hWnd, idControl, iStartPos, iEndPos)    \
   (SendMessage (GetDlgItem(hWnd, idControl), EM_SETSEL, (WPARAM) iStartPos, (LPARAM) iEndPos))

#define EditSetTextEndPos(hWnd, idControl)    \
   EditSetTextPos(hWnd, idControl, 0, 32767)

//======================================//
// Cursor helpers                       //
//======================================//

#define SetHourglassCursor() \
    (SetCursor(LoadCursor(NULL, IDC_WAIT)))

#define SetArrowCursor() \
    (SetCursor(LoadCursor(NULL, IDC_ARROW)))



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setedit\utils.h ===
//==========================================================================//
//                                  Constants                               //
//==========================================================================//


#define ThreeDPad          2
#define NOCHANGE           -1

#define MENUCLOSING        (0xFFFF0000)

#define WM_DLGSETFOCUS     (WM_USER + 0x201)
#define WM_DLGKILLFOCUS    (WM_USER + 0x202)



//==========================================================================//
//                                   Macros                                 //
//==========================================================================//


#define PinInclusive(x, lo, hi)                       \
   (max (lo, min (x, hi)))


#define PinExclusive(x, lo, hi)                       \
   (max ((lo) + 1, min (x, (hi) - 1)))


#define BoolEqual(a, b)                               \
   ((a == 0) == (b == 0))


//=============================//
// Window Instance Accessors   //
//=============================//

#define WindowParent(hWnd)                            \
   ((HWND) GetWindowLongPtr (hWnd, GWLP_HWNDPARENT))

#define WindowID(hWnd)                                \
   GetWindowLong (hWnd, GWL_ID)

#define WindowInstance(hWnd)                          \
   GetWindowWord (hWnd, GWW_HINSTANCE)

#define WindowStyle(hWnd)                             \
   GetWindowLong (hWnd, GWL_STYLE)

#define WindowSetStyle(hWnd, lStyle)                  \
   SetWindowLong (hWnd, GWL_STYLE, lStyle)

#define WindowExStyle(hWnd)                           \
   GetWindowLong (hWnd, GWL_EXSTYLE)

#define WindowSetID(hWnd, wID)                        \
   SetWindowLong (hWnd, GWL_ID, wID)


// All modeless dialogs need to be dispatched separately in the WinMain
// message loop, but only if the dialog exists.


#define ModelessDispatch(hDlg, lpMsg)                 \
   (hDlg ? IsDialogMessage (hDlg, lpMsg) : FALSE)


#define strclr(szString)                              \
   (szString [0] = TEXT('\0'))


#define strempty(lpszString)                          \
   (!(lpszString) || !(lpszString[0]))

#define pstrsame(lpsz1, lpsz2)                        \
   ((!lpsz1 && !lpsz2) || (lpsz1 && lpsz2 && strsame (lpsz1, lpsz2)))

#define pstrsamei(lpsz1, lpsz2)                        \
   ((!lpsz1 && !lpsz2) || (lpsz1 && lpsz2 && strsamei (lpsz1, lpsz2)))

#define StringLoad(wID, szText)                       \
   (LoadString (hInstance, wID,                       \
    szText, (sizeof (szText) / sizeof(TCHAR)) - 1))


#define WindowInvalidate(hWnd)                        \
   (InvalidateRect (hWnd, NULL, TRUE))


#define WindowShow(hWnd, bShow)                       \
   (ShowWindow (hWnd, (bShow) ? SW_SHOW : SW_HIDE))


#define MenuCheck(hMenu, wID, bCheck)                 \
   (CheckMenuItem (hMenu, wID, (bCheck) ?             \
     (MF_BYCOMMAND | MF_CHECKED) : (MF_BYCOMMAND | MF_UNCHECKED)))

#define DeleteFont(hFont)                             \
   (DeleteObject (hFont))

#define DeleteBitmap(hBitmap)                         \
   (DeleteObject (hBitmap))

#define DialogControl(hDlg, wControlID)               \
   GetDlgItem (hDlg, wControlID)


#define DialogSetInt(hDlg, wControlID, iValue)        \
   (SetDlgItemInt (hDlg, wControlID, iValue, TRUE))


#define DialogText(hDlg, wControlID, szText)          \
   (GetDlgItemText (hDlg, wControlID, szText, sizeof (szText) / sizeof(TCHAR) - 1))

#define DialogInt(hDlg, wControlID)                   \
   (GetDlgItemInt (hDlg, wControlID, NULL, TRUE))

#define strsame(szText1, szText2)                     \
   (!lstrcmp (szText1, szText2))

#define strsamei(szText1, szText2)                     \
   (!lstrcmpi (szText1, szText2))

#define strnsame(szText1, szText2, iLen)              \
   (!lstrncmp (szText1, szText2, iLen))


#define CreateScreenDC()                              \
   CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL)



#define RectContract(lpRect, xAmt, yAmt)              \
   {                                                  \
   (lpRect)->left += (xAmt) ;                         \
   (lpRect)->top += (yAmt) ;                          \
   (lpRect)->right -= (xAmt) ;                        \
   (lpRect)->bottom -= (yAmt) ;                       \
   }

#define IsBW(hDC)                                     \
   (DeviceNumColors (hDC) <= 2)

#ifdef KEEP_PRINT
#define IsPrinterDC(hDC)                              \
   (GetDeviceCaps (hDC, TECHNOLOGY) != DT_RASDISPLAY)
#else
#define IsPrinterDC(hDC)                              \
   (FALSE)
#endif

#define VertInchPixels(hDC, iNumerator, iDenominator) \
   ((iNumerator * GetDeviceCaps (hDC, LOGPIXELSY)) / iDenominator)


#define HorzInchPixels(hDC, iNumerator, iDenominator) \
   ((iNumerator * GetDeviceCaps (hDC, LOGPIXELSX)) / iDenominator)


#define VertPointPixels(hDC, iPoints)                 \
   ((iPoints * GetDeviceCaps (hDC, LOGPIXELSY)) / 72)



#define SimulateButtonPush(hDlg, wControlID)          \
   (PostMessage (hDlg, WM_COMMAND,                    \
                 (WPARAM) MAKELONG (wControlID, BN_CLICKED),  \
                 (LPARAM) DialogControl (hDlg, wControlID)))


// convert an unicode string to ASCII string
#define ConvertUnicodeStr(pOemStr, pUnicodeStr)   \
   CharToOemBuff(pUnicodeStr, pOemStr, lstrlen(pUnicodeStr) + 1)

#define CallWinHelp(ContextID)   \
   WinHelp(hWndMain, pszHelpFile, HELP_CONTEXT, ContextID) ;

//==========================================================================//
//                             Exported Functions                           //
//==========================================================================//

void Fill (HDC hDC,
           DWORD rgbColor,
           LPRECT lpRect) ;

void ScreenRectToClient (HWND hWnd,
                         LPRECT lpRect) ;

int TextWidth (HDC hDC, LPTSTR lpszText) ;


void ThreeDConcave (HDC hDC,
                    int x1, int y1,
                    int x2, int y2,
                    BOOL bFace) ;


void ThreeDConvex (HDC hDC,
                   int x1, int y1,
                   int x2, int y2) ;


void ThreeDConcave1 (HDC hDC,
                     int x1, int y1,
                     int x2, int y2) ;


void ThreeDConvex1 (HDC hDC,
                   int x1, int y1,
                   int x2, int y2) ;


int _cdecl mike (TCHAR *szFormat, ...) ;

int _cdecl DlgErrorBox (HWND hDlg, UINT id, ...) ;

int _cdecl mike1 (TCHAR *szFormat, ...) ;
int _cdecl mike2 (TCHAR *szFormat, ...) ;

int FontHeight (HDC hDC,
                 BOOL bIncludeLeading) ;


int TextAvgWidth (HDC hDC,
                  int iNumChars) ;



void WindowCenter (HWND hWnd) ;



BOOL DialogMove (HDLG hDlg,
                 WORD wControlID,
                 int xPos,
                 int yPos,
                 int xWidth,
                 int yHeight) ;


int DialogWidth (HDLG hDlg,
                 WORD wControlID) ;


int DialogXPos (HDLG hDlg,
                WORD wControlID) ;

int DialogYPos (HDLG hDlg,
                WORD wControlID) ;


void DialogShow (HDLG hDlg,
                 WORD wID,
                 BOOL bShow) ;


BOOL _cdecl DialogSetText (HDLG hDlg,
                           WORD wControlID,
                           WORD wStringID,
                           ...) ;

BOOL _cdecl DialogSetString (HDLG hDlg,
                             WORD wControlID,
                             LPTSTR lpszFormat,
                             ...) ;


LPTSTR LongToCommaString (LONG lNumber,
                         LPTSTR lpszText) ;


BOOL MenuSetPopup (HWND hWnd,
                   int iPosition,
                   WORD  wControlID,
                   LPTSTR lpszResourceID) ;

void DialogEnable (HDLG hDlg,
                   WORD wID,
                   BOOL bEnable) ;


LPTSTR FileCombine (LPTSTR lpszFileSpec,
                   LPTSTR lpszFileDirectory,
                   LPTSTR lpszFileName) ;

LPTSTR ExtractFileName (LPTSTR pFileSpec) ;

int CBAddInt (HWND hWndCB,
              int iValue) ;

FLOAT DialogFloat (HDLG hDlg,
                   WORD wControlID,
                   BOOL *pbOK) ;


LPTSTR StringAllocate (LPTSTR lpszText1) ;


int DivRound (int iNumerator, int iDenominator) ;



BOOL MenuEnableItem (HMENU hMenu,
                     WORD wID,
                     BOOL bEnable) ;



void DrawBitmap (HDC hDC,
                 HBITMAP hBitmap,
                 int xPos,
                 int yPos,
                 LONG  lROPCode) ;


int BitmapWidth (HBITMAP hBitmap) ;



int BitmapHeight (HBITMAP hBitmap) ;


void WindowResize (HWND hWnd,
                   int xWidth,
                   int yHeight) ;


int WindowWidth (HWND hWnd) ;


int WindowHeight (HWND hWnd) ;



void WindowSetTopmost (HWND hWnd, BOOL bTopmost) ;


void WindowEnableTitle (HWND hWnd, BOOL bTitle) ;


void Line (HDC hDC,
           HPEN hPen,
           int x1, int y1,
           int x2, int y2) ;



#define HLine(hDC, hPen, x1, x2, y)          \
   Line (hDC, hPen, x1, y, x2, y) ;


#define VLine(hDC, hPen, x, y1, y2)          \
   Line (hDC, hPen, x, y1, x, y2) ;


int DialogHeight (HDLG hDlg,
                  WORD wControlID) ;



void DialogSetFloat (HDLG hDlg,
                     WORD wControlID,
                     FLOAT eValue) ;

void DialogSetInterval (HDLG hDlg,
                        WORD wControlID,
                        int  IntervalMSec ) ;

int MessageBoxResource (HWND hWndParent,
                        WORD wTextID,
                        WORD wTitleID,
                        UINT uiStyle) ;



BOOL DlgFocus (HDLG hDlg, WORD wControlID) ;


BOOL DeviceNumColors (HDC hDC) ;



void WindowPlacementToString (PWINDOWPLACEMENT pWP,
                              LPTSTR lpszText) ;

void StringToWindowPlacement (LPTSTR lpszText,
                              PWINDOWPLACEMENT pWP) ;

DWORD MenuIDToHelpID (DWORD MenuID) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setlink\setlink.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    setlink.c

Abstract:

    Utility to display or change the value of a symbolic link.

Author:

    Darryl E. Havens    (DarrylH)   9-Nov-1990

Revision History:


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <tools.h>

BOOLEAN
__cdecl main(
    IN ULONG argc,
    IN PCHAR argv[]
    )
{
    NTSTATUS Status;
    STRING AnsiString;
    UNICODE_STRING LinkName;
    UNICODE_STRING LinkValue;
    HANDLE Handle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR Buffer[256];
    PWSTR s;
    ULONG ReturnedLength;

    //
    // Check to see whether or not this utility was invoked with the correct
    // number of parameters.  If not, bail out now.
    //

    ConvertAppToOem( argc, argv );
    if (argc < 2 || argc > 3) {
        printf( "Useage:  setlink symbolic-link-name [symbolic-link-value]\n" );
        return FALSE;
    }

    //
    // Begin by attempting to open the existing symbolic link name specified.
    //

    RtlInitString( &AnsiString, argv[1] );
    Status = RtlAnsiStringToUnicodeString( &LinkName,
                                           &AnsiString,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );
    InitializeObjectAttributes( &ObjectAttributes,
                                &LinkName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );
    Status = NtOpenSymbolicLinkObject( &Handle,
                                       argc == 2 ? SYMBOLIC_LINK_QUERY :
                                                   SYMBOLIC_LINK_ALL_ACCESS,
                                       &ObjectAttributes );

    //
    // Determine what should be done based on the number of parameters that
    // were given to the program.
    //

    if (argc == 2) {

        //
        // Only one parameter was specified, so display the value of the
        // symbolic link if it exists.
        //

        if (!NT_SUCCESS( Status )) {
            printf( "Symbolic link %wZ does not exist\n", &LinkName );
            return FALSE;
        } else {
            LinkValue.Length = 0;
            LinkValue.MaximumLength = sizeof( Buffer );
            LinkValue.Buffer = Buffer;
            ReturnedLength = 0;
            Status = NtQuerySymbolicLinkObject( Handle,
                                                &LinkValue,
                                                &ReturnedLength
                                              );
            NtClose( Handle );
            if (!NT_SUCCESS( Status )) {
                printf( "Error reading symbolic link %wZ\n", &LinkName );
                printf( "Error status was:  %X\n", Status );
                return FALSE;
            } else {
                printf( "Value of %wZ => %wZ", &LinkName, &LinkValue );
                s = LinkValue.Buffer + ((LinkValue.Length / sizeof( WCHAR )) + 1);
                while (ReturnedLength > LinkValue.MaximumLength) {
                    printf( " ; %ws", s );
                    while (*s++) {
                        ReturnedLength -= 2;
                        }
                    ReturnedLength -= 2;
                    }
                printf( "\n", s );
                return TRUE;
            }
        }

    } else {

        //
        // Three parameters were supplied, so assign a new value to the
        // symbolic link if it exists by first deleting the existing link
        // (mark it temporary and close the handle).  If it doesn't exist
        // yet, then it will simply be created.
        //

        if (NT_SUCCESS( Status )) {
            Status = NtMakeTemporaryObject( Handle );
            if (NT_SUCCESS( Status )) {
                NtClose( Handle );
            }
        }
    }

    //
    // Create a new value for the link.
    //

    ObjectAttributes.Attributes |= OBJ_PERMANENT;
    RtlInitString( &AnsiString, argv[2] );
    Status = RtlAnsiStringToUnicodeString( &LinkValue,
                                           &AnsiString,
                                           TRUE );
    Status = NtCreateSymbolicLinkObject( &Handle,
                                         SYMBOLIC_LINK_ALL_ACCESS,
                                         &ObjectAttributes,
                                         &LinkValue );
    if (!NT_SUCCESS( Status )) {
        printf( "Error creating symbolic link %wZ => %wZ\n",
                 &LinkName,
                 &LinkValue );
        printf( "Error status was:  %X\n", Status );
    } else {
        NtClose( Handle );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\seterror\seterror.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

__cdecl main (int argc, LPSTR argv[])
{
  int i;

  if (argc<=1) {
    printf( "Set errorlevel to user-specified integer value.\n" );
    printf( "Usage: %s <errorlevel>\n", argv[0]);
    printf( "   ex: %s 1\n", argv[0]);
    return 1;
  }

  i = atoi( argv[1] );
  return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\dll\main.c ===
#include <windows.h>

BOOL APIENTRY LibMain(HANDLE hModule, int nAttach, PCONTEXT pContext)
{
   OSVERSIONINFO osVer;
   osVer.dwOSVersionInfoSize= sizeof( osVer );
   GetVersionEx( &osVer );

   switch (nAttach)
    {
      // Only load on NT 5 or later.
      case  DLL_PROCESS_ATTACH:
          if (osVer.dwPlatformId != VER_PLATFORM_WIN32_NT || osVer.dwMajorVersion <= 4)
          {
             return FALSE;
          }

          break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\exe\servers.c ===
/*++

   Filename :  servers.c

   Description: This file will be for testing the servers access.


   Created by:  Wally Ho

   History:     Created on 03/29/99.


   Contains these functions:

   1. IsServerOnline       (IN LPTSTR szMachineName)
   2. ServerOnlineThread   (IN LPTSTR szServerFile)


--*/
#include "setuplogEXE.h"

BOOL
IsServerOnline(IN LPTSTR szMachineName, IN LPTSTR szSpecifyShare)
/*++

Routine Description:
   This will go through the list of servers specified in setuplogEXE.h
   It will return the first in it sees and reset the global server share
   name.

Arguments:
   The machineName (Filename with build etc) so the test file will get overwritten.
   Manual Server Name: NULL will give default behaviour.

Return Value:
	TRUE for success.
   FALSE for no name.
--*/

{
   DWORD    dw;
   HANDLE   hThrd;
   INT      i;
   TCHAR    szServerFile[ MAX_PATH ];
   DWORD    dwTimeOutInterval;
   i = 0;

   //
   // This should allow for a 
   // manually specified server.
   //
   if (NULL != szSpecifyShare){
       _tcscpy(g_szServerShare,szSpecifyShare);
      return TRUE;

   }
   //
   // Initialize the Server.
   // Variable. Since we are using a single thread
   // to do a time out we don't care about mutexes and
   // sychronization.
   //
   g_bServerOnline = FALSE;

   while ( i < NUM_SERVERS){

      
      _stprintf (szServerFile, TEXT("%s\\%s"),s[i].szSvr,szMachineName );
      //
      // Spawn the thread
      //
      hThrd  = CreateThread(NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) ServerOnlineThread,
                        (LPTSTR) szServerFile,
                        0,
                        &dw);
      //
      // This is in milli seconds so the time out is secs.
      //
      dwTimeOutInterval = TIME_TIMEOUT * 1000;

      s[i].dwTimeOut = WaitForSingleObject (hThrd, dwTimeOutInterval);
      CloseHandle (hThrd);

      //
      // This means the server passed the timeout.
      //
      if (s[i].dwTimeOut != WAIT_TIMEOUT &&
          g_bServerOnline == TRUE){
         //
         // Copy the Share to the glowbal var.
         //
         _tcscpy(g_szServerShare,s[i].szSvr);
         return TRUE;
      }
      i++;
   }
   return FALSE;
}


BOOL
ServerOnlineThread(IN LPTSTR szServerFile)
/*++

Routine Description:
   This create a thread and then time it out to see if we can get to
   a server faster. 

Arguments:
   The machineName so the test file will get overwritten.
Return Value:

--*/
{

   BOOL     bCopy = FALSE;
   TCHAR    szFileSrc [MAX_PATH];
   TCHAR    szServerTestFile [MAX_PATH];

   //
   // Use this to get the location
   // setuplog.exe is run from. this tool
   //
   GetModuleFileName (NULL, szFileSrc, MAX_PATH);
   
   //
   // Make a unique test file. 
   //
   _stprintf(szServerTestFile,TEXT("%s.SERVERTEST"),szServerFile);


   bCopy = CopyFile( szFileSrc,szServerTestFile, FALSE);
   if (bCopy != FALSE){
      //
      // If Succeeded Delete the test file.
      //
      DeleteFile(szServerTestFile);
      g_bServerOnline = TRUE;      
      return TRUE;
   }
   else{
      g_bServerOnline = FALSE;
      return FALSE;
   }
}


/*

   INT         i;
   NETRESOURCE NetResource ;


   i = 0;
   while ( i < NUM_SERVERS){
      //
      // Prep the struct.
      //
      ZeroMemory( &NetResource, sizeof( NetResource ) );
      NetResource.dwType = RESOURCETYPE_DISK ;
      NetResource.lpLocalName = "" ;
      NetResource.lpRemoteName = s[i].szSvr;
      NetResource.lpProvider = "" ;

      //
      // Try with default password and user.
      // This should work as its open to everyone.
      //
      s[i].dwNetStatus = WNetAddConnection2( &NetResource,NULL,NULL, 0 );
      //
      // Try default PW / USERID from setuplog.h
      //
      if (s[i].dwNetStatus != 0)
         s[i].dwNetStatus = WNetAddConnection2( &NetResource,LOGSHARE_PW,LOGSHARE_USER,0 );
      WNetCancelConnection2( g_szServerShare, 0, TRUE );

      if (s[i].dwNetStatus == NO_ERROR){
         //
         // Copy the Share to the glowbal var.
         //
         _tcscpy(g_szServerShare,s[i].szSvr);
         return TRUE;
      }
      i++;
   }

   //
   // No Valid name.
   // Return false so we won't write.
   return FALSE;


*/


BOOL IsMSI(VOID)
/*++

Routine Description:

	This will check if its an MSI install.
   It will check for the running process
   and then check for the path.

Arguments:


Return Value:

    BOOL - True if link is good. False otherwise.
--*/
{

	DWORD		   numTasks = 0;
	TASK_LIST	tlist[ MAX_PATH ];
   UINT        i;
   BOOL        bFound = FALSE;
   //
	//	Get the Running Tasks.
	//
	numTasks = GetTaskList(tlist, MAX_PATH);
   //
   // If the MSI process exists log it as such.
   //
   for(i = 1; i <= numTasks; i++){
      if(_tcsstr(tlist[i].ProcessName, TEXT("msiexec.exe"))){
         MessageBox(NULL,tlist[i].ProcessName, TEXT("Caption"),MB_OK);
           lpCmdFrom.b_MsiInstall = TRUE;
         return FALSE;
      }else{
           lpCmdFrom.b_MsiInstall = TRUE;
         return TRUE;
	   }
   }

   return TRUE;
}



DWORD
GetTaskList(
    PTASK_LIST  pTask,
    DWORD       dwNumTasks
    )

/*++

// Borrowed with modifications from tlist a wesw invention.

  Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses the registry performance data to get the
    task list and is therefor straight WIN32 calls that anyone can call.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/

{
    DWORD                        rc;
    HKEY                         hKeyNames;
    DWORD                        dwType;
    DWORD                        dwSize;
    LPBYTE                       buf = NULL;
    CHAR                         szSubKey[1024];
    LANGID                       lid;
    LPSTR                        p;
    LPSTR                        p2;
    PPERF_DATA_BLOCK             pPerf;
    PPERF_OBJECT_TYPE            pObj;
    PPERF_INSTANCE_DEFINITION    pInst;
    PPERF_COUNTER_BLOCK          pCounter;
    PPERF_COUNTER_DEFINITION     pCounterDef;
    DWORD                        i;
    DWORD                        dwProcessIdTitle;
    DWORD                        dwProcessIdCounter;
    CHAR                         szProcessName[MAX_PATH];
    DWORD                        dwLimit = dwNumTasks - 1;



    //
    // Look for the list of counters.  Always use the neutral
    // English version, regardless of the local language.  We
    // are looking for some particular keys, and we are always
    // going to do our looking in English.  We are not going
    // to show the user the counter names, so there is no need
    // to go find the corresponding name in the local language.
    //
    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL );
    sprintf( szSubKey, "%s\\%03x", REGKEY_PERF, lid );
    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       szSubKey,
                       0,
                       KEY_READ,
                       &hKeyNames
                     );
    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // get the buffer size for the counter names
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // allocate the counter names buffer
    //
    buf = (LPBYTE) malloc( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );

    //
    // read the counter names from the registry
    //
    rc = RegQueryValueEx( hKeyNames,
                          REGSUBKEY_COUNTERS,
                          NULL,
                          &dwType,
                          buf,
                          &dwSize
                        );

    if (rc != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // now loop thru the counter names looking for the following counters:
    //
    //      1.  "Process"           process name
    //      2.  "ID Process"        process id
    //
    // the buffer contains multiple null terminated strings and then
    // finally null terminated at the end.  the strings are in pairs of
    // counter number and counter name.
    //
    p = buf;
    while (*p) {
        if (p > buf) {
            for( p2=p-2; isdigit(*p2); p2--) ;
        }
        if (_stricmp(p, PROCESS_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) ;
            strcpy( szSubKey, p2+1 );
        }
        else
        if (_stricmp(p, PROCESSID_COUNTER) == 0) {
            //
            // look backwards for the counter number
            //
            for( p2=p-2; isdigit(*p2); p2--) ;
            dwProcessIdTitle = atol( p2+1 );
        }
        //
        // next string
        //
        p += (strlen(p) + 1);
    }

    //
    // free the counter names buffer
    //
    free( buf );
    //
    // allocate the initial buffer for the performance data
    //
    dwSize = INITIAL_SIZE;
    buf = malloc( dwSize );
    if (buf == NULL) {
        goto exit;
    }
    memset( buf, 0, dwSize );


    while (TRUE) {

        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA,
                              szSubKey,
                              NULL,
                              &dwType,
                              buf,
                              &dwSize
                            );

        pPerf = (PPERF_DATA_BLOCK) buf;

        //
        // check for success and valid perf data block signature
        //
        if ((rc == ERROR_SUCCESS) &&
            (dwSize > 0) &&
            (pPerf)->Signature[0] == (WCHAR)'P' &&
            (pPerf)->Signature[1] == (WCHAR)'E' &&
            (pPerf)->Signature[2] == (WCHAR)'R' &&
            (pPerf)->Signature[3] == (WCHAR)'F' ) {
            break;
        }

        //
        // if buffer is not big enough, reallocate and try again
        //
        if (rc == ERROR_MORE_DATA) {
            dwSize += EXTEND_SIZE;
            buf = realloc( buf, dwSize );
            memset( buf, 0, dwSize );
        }
        else {
            goto exit;
        }
    }

    //
    // set the perf_object_type pointer
    //
    pObj = (PPERF_OBJECT_TYPE) ((DWORD*)pPerf + pPerf->HeaderLength);

    //
    // loop thru the performance counter definition records looking
    // for the process id counter and then save its offset
    //
    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD *)pObj + pObj->HeaderLength);
    for (i=0; i<(DWORD)pObj->NumCounters; i++) {
        if (pCounterDef->CounterNameTitleIndex == dwProcessIdTitle) {
            dwProcessIdCounter = pCounterDef->CounterOffset;
            break;
        }
        pCounterDef++;
    }

    dwNumTasks = min( dwLimit, (DWORD)pObj->NumInstances );

    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD*)pObj + pObj->DefinitionLength);

    //
    // loop thru the performance instance data extracting each process name
    // and process id
    //
    for (i=0; i<dwNumTasks; i++) {
        //
        // pointer to the process name
        //
        p = (LPSTR) ((DWORD*)pInst + pInst->NameOffset);

        //
        // convert it to ascii
        //
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  (LPCWSTR)p,
                                  -1,
                                  szProcessName,
                                  sizeof(szProcessName),
                                  NULL,
                                  NULL
                                );

        if (!rc) {
            //
            // if we cant convert the string then use a bogus value
            //
            strcpy( pTask->ProcessName, UNKNOWN_TASK );
        }

        if (strlen(szProcessName)+4 <= sizeof(pTask->ProcessName)) {
            strcpy( pTask->ProcessName, szProcessName );
            strcat( pTask->ProcessName, ".exe" );
        }

        //
        // get the process id
        //
        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD*)pInst + pInst->ByteLength);
        pTask->flags = 0;
        pTask->dwProcessId = *((LPDWORD) ((DWORD*)pCounter + dwProcessIdCounter));
        if (pTask->dwProcessId == 0) {
            pTask->dwProcessId = (DWORD)-2;
        }

        //
        // next process
        //
        pTask++;
        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD*)pCounter + pCounter->ByteLength);
    }

exit:
    if (buf) {
        free( buf );
    }

    RegCloseKey( hKeyNames );
    RegCloseKey( HKEY_PERFORMANCE_DATA );
	//
	//	W.Ho added a minus 1 to get it to reflect the
	//	tasks properly.
	//
    return dwNumTasks -1;
}





























/*
typedef struct _SERVERS {
   TCHAR szSvr [ MAX_PATH ];
   BOOL  bCFTest;
   DWORD dwNetStatus;
} *LPSERVERS, SERVERS;

typedef struct _ERRMSG {
   TCHAR szMsg[ MAX_PATH ];
   DWORD dwErr;
} *LPERRMSG, ERRMSG;


BOOL
IsServerOnline(VOID)
/*++

Routine Description:


Arguments:

Return Value:
	NONE.
--
{
#define NUM_SERVERS 6

   INT   i;
   TCHAR    sz[ MAX_PATH ];
   ERRMSG e[12] = {
      {TEXT("Access is denied."), ERROR_ACCESS_DENIED},
      {TEXT("The device specified in the lpLocalName parameter is already connected."), ERROR_ALREADY_ASSIGNED  },
      {TEXT("The device type and the resource type do not match."), ERROR_BAD_DEV_TYPE},
      {TEXT("The value specified in lpLocalName is invalid."), ERROR_BAD_DEVICE},
      {TEXT("The value specified in the lpRemoteName parameter is not valid or cannot be located."), ERROR_BAD_NET_NAME},
      {TEXT("The user profile is in an incorrect format."), ERROR_BAD_PROFILE},
      {TEXT("The system is unable to open the user profile to process persistent connections."),ERROR_CANNOT_OPEN_PROFILE },
      {TEXT("An entry for the device specified in lpLocalName is already in the user profile."), ERROR_DEVICE_ALREADY_REMEMBERED},
      {TEXT("A network-specific error occurred. To get a description of the error, use the WNetGetLastError function."), ERROR_EXTENDED_ERROR},
      {TEXT("The specified password is invalid."), ERROR_INVALID_PASSWORD},
      {TEXT("The operation cannot be performed because either a network component is not started or the specified name cannot be used."),ERROR_NO_NET_OR_BAD_PATH },
      {TEXT("The network is not present."),ERROR_NO_NETWORK}
   };

   SERVERS  s[NUM_SERVERS] ={
      {TEXT("\\\\donkeykongjr\\public"), -1, -1},
      {TEXT("\\\\popcorn\\public"), -1, -1},
      {TEXT("\\\\NotExists\\idwlog"), -1, -1},
      {TEXT("\\\\Paddy\\idwlog"), -1, -1},
      {TEXT("\\\\Bear\\idwlog"), -1, -1},
      {TEXT("\\\\JustTesting\\idwlog"), -1, -1}

   };


   for (i = 0; i < 12; i++) {
      _tprintf(TEXT("Error %s  %lu\n"),e[i].szMsg, e[i].dwErr);
   }

   for (i = 0; i < NUM_SERVERS; i++){
     s[i].dwNetStatus = WNetAddConnection(TEXT("donkeykongjr\\public\0"),NULL,NULL);


     _stprintf(sz,TEXT("%s%s"),s[i].szSvr,TEXT("\\test") );
     s[i].bCFTest = CopyFile(TEXT("c:\\test"),sz,FALSE);
     _tprintf(TEXT("Did this work for %s %s %lu\n"),
         sz,
         s[i].bCFTest? TEXT("WORKED"): TEXT("FAILED"),
         s[i].dwNetStatus
         );
   }

   return FALSE;
}
*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\inc\setuplib.h ===
#define MY_MAX_CNLEN    64
#define MY_MAX_UNLEN    1024
#define USERNAME        "USERNAME"

#define UNKNOWN         "UNKNOWN"
#define BUILD_NUMBER_KEY "SOFTWARE\\MICROSOFT\\WINDOWS NT\\CURRENTVERSION"
#define BUILD_NUMBER_BUFFER_LENGTH 80

VOID GetBuildNumber( LPTSTR BuildNumber );
BOOL GetPnPDisplayInfo( LPTSTR pOutputData );
VOID ConnectAndWrite (LPTSTR MachineName, LPTSTR Buffer);
VOID WriteDataToFile (IN LPTSTR  szFileName, IN LPTSTR  szFrom, IN LPNT32_CMD_PARAMS lpCmdL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\exe\setuplog.c ===
/*++

   Filename :  setuplog.c

   Description: This is the main file for the setuplog.c
                  
   Created by:  Wally Ho

   History:     Created on 03/30/99.


   Contains these functions:

   1. GetTargetFile     (LPTSTR szOutPath, LPTSTR szBld)
   2. GetNTSoundInfo    (VOID)
   3. ConnectAndWrite   (LPTSTR MachineName, LPTSTR Buffer)
   4. GetBuildNumber    (LPTSTR szBld)
   5. RandomMachineID   (VOID)
   6. WriteMinimalData  (LPTSTR szFileName)
   7. DeleteDatafile    (LPTSTR szDatafile)
   8. GlobalInit        (VOID)


--*/
#include "setuplogEXE.h"

VOID 
GetTargetFile (LPTSTR szOutPath, LPTSTR szBld)
/*++

   Routine Description:
      The file name is generated based on the calling machine's name
      and the build number being installed. In the "before" case, the generated
      name is saved to c:\setuplog.ini, and this name is in turn read in
      "after" case.

   Arguments:
      Where to write the file.
      The build.

   Return Value:
      NONE
--*/
{
   HANDLE      hFile;
   DWORD       dwLen = MAX_PATH;
   TCHAR       szParam [ MAX_PATH ];
   TCHAR       szComputerName [20];
   TCHAR       szComputerNameBld[30];
   g_pfnWriteDataToFile = (fnWriteData)GetProcAddress (LoadLibrary ("setuplog.dll"),
                                                       "WriteDataToFile");

   GetComputerName (szComputerName, &dwLen);
   //
   // Build the new filename.Consisting of
   // 1. The Computername
   // 2. The build number.
   //

   _stprintf (szOutPath,TEXT("%s"), szComputerName);
   _tcscat (szOutPath, szBld);
   _tcscat (szOutPath, TEXT(".1"));
   //
   //   Combine Computername and the build
   //   To keep DavidShi code from breaking.
   //
   _stprintf(szComputerNameBld,TEXT("%s%s"),szComputerName,szBld);

   if (!lpCmdFrom.b_Cancel ){
      hFile = CreateFile (SAVE_FILE,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_HIDDEN,
                          NULL );
      if (hFile == INVALID_HANDLE_VALUE){
         OutputDebugString ("Unable to write setuplog.ini\n");
         return;
      }

      // Check for Upgrade.
      _stprintf (szParam, TEXT("%s"),   lpCmdFrom.b_Upgrade? TEXT("U"): TEXT("I"));
      WriteFile (hFile, (LPCVOID) szParam, 1, &dwLen, NULL);

      // Check for CD install.
      _stprintf (szParam, TEXT("%s\""),   lpCmdFrom.b_CDrom? TEXT("C"): TEXT("N"));
      WriteFile (hFile, (LPCVOID) szParam, 2, &dwLen, NULL);

      // Write out the platform.
      // I think this get ignored so i may delete it. Its DavidShi code.
      WriteFile (hFile, (LPCVOID)   szPlatform, _tcsclen(szPlatform), &dwLen, NULL);

      // Write out the drive.
      WriteFile (hFile, (LPCVOID)   "\"C:", 3, &dwLen, NULL);
      
      // Write out the computer name and build
      WriteFile (hFile, (LPCVOID)   szComputerNameBld, _tcsclen(szComputerNameBld)+1, &dwLen, NULL);

      // Write the RandomID.
      _stprintf (szParam, TEXT("\r\nMachineID %lu"),   lpCmdFrom.dwRandomID);
      WriteFile (hFile, (LPCVOID)   szParam,_tcsclen(szParam)+1 , &dwLen, NULL);

      // Check for MSI install
      _stprintf (szParam, TEXT("\r\nMSI %s"),   lpCmdFrom.b_MsiInstall? TEXT("Y"): TEXT("N"));
      WriteFile (hFile, (LPCVOID)   szParam,_tcsclen(szParam)+1 , &dwLen, NULL);
      CloseHandle (hFile);
   }
}


VOID 
GetNTSoundInfo()
{
   HKEY    hKey;
   DWORD   dwCbData;
   ULONG   ulType;
   LPTSTR  sSubKey=TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
   INT     i;
   TCHAR   szSubKeyName[ MAX_PATH ];
   TCHAR   szTempString[ MAX_PATH ];

   
   // Get Sound Card Info
   m.nNumWaveOutDevices = 0;
   hKey = 0;
   if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
      // Loop through the key to see how many wave devices we have, but skip mmdrv.dll.
      for (i = 0; i <= 1; i++){
         if (i != 0)
            _stprintf(szSubKeyName, TEXT("wave%d"),i);
         else
            _tcscpy(szSubKeyName, TEXT("wave"));
 
         dwCbData = sizeof (szTempString);
         if (RegQueryValueEx(hKey, szSubKeyName, 0, &ulType, (LPBYTE)szTempString, &dwCbData))
            break;
         else{
            // We want to skip mmdrv.dll - not relevant.
            if (szTempString[0] && 
                _tcscmp(szTempString, TEXT("mmdrv.dll")))  {
               
               _tcscpy(&m.szWaveDriverName[m.nNumWaveOutDevices][0], szTempString);
               m.nNumWaveOutDevices++;
            }
         }
      }
   }

   if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
   }


   sSubKey = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");
   hKey = 0;
   if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){

      // Now grab the sound device string for each wave device
      for (i = 0; i < m.nNumWaveOutDevices; i++){
         dwCbData = sizeof szTempString;
         if (RegQueryValueEx(hKey, m.szWaveDriverName[i], 0, &ulType, (LPBYTE)szTempString, &dwCbData))
            _tcscpy(m.szWaveOutDesc[i], TEXT("Unknown"));
         else
            _tcscpy(m.szWaveOutDesc[i], szTempString);
      }
   }
   if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
   }
   return;
}

VOID
ConnectAndWrite(LPTSTR MachineName,
                LPTSTR Buffer)
/*++

   Routine Description:
      Cconnect to the data share and write the buffer to a file
      named MachineNamebuild.1

   Arguments:
      The MachineName
      The buffer with the data to put in.

   Return Value:
      NONE
--*/
{
   TCHAR      szLogName[ MAX_PATH ];
   HANDLE     hWrite ;
   DWORD      Size, Actual ;
   TCHAR      szWriteFile[2000];

   _tcscpy(szWriteFile,Buffer);

   //
   // Blow through the list of servers.
   // and change the g_szServerShare to match.
   //

   if (TRUE == IsServerOnline(MachineName, NULL)){
      //
      // Set the server name now as we now have it
      // into the outputbuffer
      //
      _stprintf (Buffer+_tcsclen(Buffer),
             TEXT("IdwlogServer:%s\r\n"), g_szServerShare);
    
      _stprintf (szLogName, TEXT("%s\\%s"),g_szServerShare,MachineName );
      
      hWrite = CreateFile( szLogName,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                        NULL );
     if ( hWrite != INVALID_HANDLE_VALUE ){
         SetFilePointer( hWrite, 0, NULL, FILE_END );

         Size = _tcsclen( Buffer );
         WriteFile( hWrite, szWriteFile, Size, &Actual, NULL );
         CloseHandle( hWrite );
     }
   }
}


VOID 
GetBuildNumber (LPTSTR szBld)
/*++
    
Routine Description:

   Acquires the Build number from imagehlp.dll

Arguments:

 
Return Value:

  True upon sucessful completion.
  

--*/

{

   VS_FIXEDFILEINFO* pvsFileInfo;
   WIN32_FIND_DATA fd;
   HANDLE   hFind;

   TCHAR    szCurDir [MAX_PATH];
   TCHAR    szFullPath[ MAX_PATH ];
   LPTSTR   ptstr;
   DWORD   dwTemp;
   DWORD   dwLen;
   INT     iBuild;
   LPVOID  lpData;

   _tcscpy (szBld, TEXT("latest"));
   //
   // Use this to get the location
   // setuplog.exe is run from. this tool
   // will always assume imagehlp.dll is in its
   // current path or one up.
   //
   GetModuleFileName (NULL, szCurDir, MAX_PATH);

   //
   // This will cull off the setuplog.exe part
   // leaving us with the full path to where
   // setuplog.exe was on the CD or netshare.
   //

   ptstr = szCurDir + strlen(szCurDir);
   while (*ptstr-- != TEXT('\\'));
   ptstr++;
   *ptstr = ('\0');
   _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);
   //
   // On a network share the Imagehlp.dll is one up from where
   // setuplog.exe is located. We will look in both places.
   //

   hFind = FindFirstFile (szFullPath, &fd);

   if (INVALID_HANDLE_VALUE == hFind){
      //
      // Now we know the file in not in the
      // immediate directory. Move up one by
      // culling off one more directory.
      //
      ptstr = szCurDir + _tcsclen(szCurDir);
      while (*ptstr-- != '\\');
      ptstr++;
      *ptstr = '\0';

      _stprintf (szFullPath, TEXT("%s\\imagehlp.dll"),szCurDir);

      hFind = FindFirstFile (szFullPath,&fd);
      if (INVALID_HANDLE_VALUE == hFind){
         //
         // In case we cannot find it we will exit.
         //
         _tcscpy (szBld, TEXT("latest"));
         return;
      }
   }

   //
   // Get the buffer info size
   //
   dwLen = GetFileVersionInfoSize (szFullPath, &dwTemp);
   if ( 0 == dwLen ) {
      //
      // We have a problem.
      //
      _tcscpy (szBld, TEXT("latest"));
      return;
   }

   lpData = LocalAlloc (LPTR, dwLen);
   if ( lpData == NULL ) {
     //
     // We have a problem.
     //
     _tcscpy (szBld, TEXT("latest"));
     return;
   }
     //
     // Get the File Version Info
     //
   if(0 == GetFileVersionInfo(szFullPath,0,MAX_PATH,lpData)){
      //
      // We have a problem.
      //
      _tcscpy (szBld, TEXT("latest"));
      return;
   }

   if (0 == VerQueryValue (lpData, "\\", &pvsFileInfo, &dwTemp)) {
      //
      // We have a problem.
      //
      _tcscpy (szBld, TEXT("latest"));
      return;
    }

   //
   // The HIWORD() of this is the build
   // The LOWORD() of this is some garbage? :-)
   //
   iBuild = HIWORD(pvsFileInfo->dwFileVersionLS);


   LocalFree (lpData);
   //
   // Write it back to the buffer.
   //
   _stprintf(szBld, TEXT("%d"),iBuild);
}


DWORD
RandomMachineID(VOID)
/*++

Author: Wallyho.
    
Routine Description:

   Generates a DWORD Random MachineID for each machine

Arguments:
   NONE
 
Return Value:

  The DWORD random ID.
  

--*/

{
   INT i;
   TCHAR    szComputerName[MAX_COMPUTERNAME_LENGTH+1];
   DWORD    dwSize;
   INT      iLenCName;
   INT      iNameTotal = 0;

   DWORD    dwMachineID;    
   CHAR     szRandomID[ 4 ]; // need 4 bytes to contain the DWORD.
   struct _timeb tm;


   //
   // This will get us the milliseconds
   //
   _ftime(&tm);
   //
   // Seed the random number generator.
   // We will seed with the seconds + milliseconds at
   // at that time. I was getting the same number 
   // if I pressed the keyboard too fast in testing this.
   // The milli seconds should decrease the expectancy of
   // duplication.
   //
   srand (  (unsigned) time (NULL) + tm.millitm);
   //
   // This will guarantee a mostly random identifier.
   // Even with no computer name. We will tally the
   // ascii decimal value of the computer name and
   // add that to the randomly generated number.
   // The possibility of a dup is greatly decreased
   // since we switched to a dword system.
   // This computername tweak should be unnecessary.
   //
   dwSize = sizeof(szComputerName);
   if (0 == GetComputerName(szComputerName,&dwSize) ){
      //
      // This algorithm will limit the random number to 
      // uppercase ascii alphabet.
      //
      szComputerName[0] = 65 + (rand() % 25);
      szComputerName[1] = 65 + (rand() % 25);
      szComputerName[2] = 65 + (rand() % 25);
      szComputerName[3] = 65 + (rand() % 25);
      szComputerName[4] = 65 + (rand() % 25);
      szComputerName[5] = 65 + (rand() % 25);
      szComputerName[6] = 65 + (rand() % 25);
      szComputerName[7] = TEXT('\0');
   }
   iLenCName = _tcslen (szComputerName);
   //
   // Tally up the individual elements in the file
   //
   for (i = 0; i < iLenCName; i++)
      iNameTotal += szComputerName[i];
   //
   //   Generate four 8 bit numbers.
   //   Add the some random number based on the
   //   computername mod'ed to 0-100.
   //   Limit the 8 bit number to 0-155 to make room
   //   for the 100 from the computer name tweak.
   //   Total per 8 bit is 256.
   //   Do this tweak to only 2.
   //   We will then cast and shift to combine it
   //   into a DWORD.
   //
   szRandomID[0] = (rand() % 155) + (iNameTotal % 100);
   szRandomID[1] =  rand() % 255;
   szRandomID[2] = (rand() % 155) + (iNameTotal % 100);
   szRandomID[3] =  rand() % 255;

   //
   //   This will combine the 4 8bit CHAR into one DWORD 
   //
   dwMachineID  =   (DWORD)szRandomID[0] * 0x00000001 + 
                    (DWORD)szRandomID[1] * 0x00000100 +
                    (DWORD)szRandomID[2] * 0x00010000 +
                    (DWORD)szRandomID[3] * 0x01000000;

   return dwMachineID;
}




VOID 
WriteMinimalData (LPTSTR szFileName)
/*++


   For machines on which setuplog.dll fails to load, just write
   the platform,a time stamp, upgrade, and cpu count.

--*/
{

   TCHAR szOutBuffer[4096];

   _tcscpy (szCPU ,TEXT("1"));


   _stprintf (szOutBuffer,
      TEXT("MachineID:%lu\r\n")  
      TEXT("Source Media:%s\r\n")
      TEXT("Type:%s\r\n")
      TEXT("FromBld:%s\r\n")
      TEXT("Arch:%s\r\n")
      TEXT("Sound:%s\r\n")
      TEXT("NumProcs:%s\r\n")
      TEXT("MSI:%s\r\n"),
           lpCmdFrom.dwRandomID,
           lpCmdFrom.b_CDrom?   TEXT("C"): TEXT("N"),
           lpCmdFrom.b_Upgrade? TEXT("U"): TEXT("I"),
         szPlatform,
         szArch,
         m.nNumWaveOutDevices? m.szWaveDriverName[m.nNumWaveOutDevices-1]: TEXT("None"),
         szCPU,
         lpCmdFrom.b_MsiInstall? TEXT("Y"): TEXT("N")
         );
   ConnectAndWrite (szFileName, szOutBuffer);
}


VOID
DeleteDatafile (LPTSTR szDatafile)
/*++

   Author: 
    
   Routine Description:

      Deletes the file from the server if the user cancels it.

   Arguments:
      The name of the datafile.

 
   Return Value:
      
      NONE
--*/
{
   TCHAR    szPath[MAX_PATH];
   
   _stprintf (szPath,TEXT("%s\\%s"), g_szServerShare,szDatafile);
   DeleteFile (szPath);
}




INT WINAPI
WinMain(HINSTANCE hInst,
        HINSTANCE h,
        LPTSTR     szCmdLine,
        INT       nCmdShow)
{
   
   BOOL  bAfter = FALSE;
   TCHAR szBld[10];
   TCHAR szFileToSave[MAX_PATH];
   OSVERSIONINFO osVer;

   //
   // Initialize Global Variables.
   //
   //   GlobalInit();

   // Spray up a simple help screen for /?
   if ( 0 == _tcscmp(szCmdLine, TEXT("/?")) ||
        0 == _tcscmp(szCmdLine, TEXT("-?")) ){
      
      MessageBox(NULL,TEXT("setuplog upgrade cancel cdrom MSI "),TEXT("Help!"),MB_ICONQUESTION | MB_OK);
      return FALSE;
   }


   SetErrorMode (SEM_FAILCRITICALERRORS);
   //
   // See if Drive C is a HD.
   //
   if (DRIVE_FIXED != GetDriveType (TEXT("C:\\")) ){
       return 0;
   }

   osVer.dwOSVersionInfoSize= sizeof( osVer );
   GetVersionEx( &osVer );
      switch (osVer.dwPlatformId){

      case VER_PLATFORM_WIN32_NT:
            szPlatform = TEXT("Windows NT");

            switch (osVer.dwMajorVersion){
               case 3:
                  szPlatform = TEXT("Windows NT 3.51");
               break;
               case 4:
                  szPlatform = TEXT("Windows NT 4.0");
               break;
               case 5: 
                  szPlatform = szCurBld;
               break;
            }
            GetEnvironmentVariable ( TEXT("NUMBER_OF_PROCESSORS"),   szCPU, 6);
            GetEnvironmentVariable ( TEXT("PROCESSOR_ARCHITECTURE"), szArch, 20);
         break;
      case VER_PLATFORM_WIN32_WINDOWS:
            szPlatform = TEXT("Windows 9x");
            _tcscpy (szArch, "X86");
         break;
      default:
            szPlatform = TEXT("Unknown");
            _tcscpy (szArch, TEXT("Unknown"));
         break;
      }
   
   //
   // This is a very primitive command line processor
   // I'll add to it now to get this working soon.
   // I'll flesh this out to a full parser soon.
   // Wallyho.
   //

   lpCmdFrom.b_Upgrade   = _tcsstr (szCmdLine, TEXT("upgrade")) ? TRUE : FALSE;
   lpCmdFrom.b_Cancel    = _tcsstr (szCmdLine, TEXT("cancel")) ?  TRUE : FALSE;
   lpCmdFrom.b_CDrom     = _tcsstr (szCmdLine, TEXT("cdrom")) ?   TRUE : FALSE;
   lpCmdFrom.b_MsiInstall= _tcsstr (szCmdLine, TEXT("MSI")) ?     TRUE : FALSE;

   if (osVer.dwMajorVersion >= 5){
      _itoa (osVer.dwBuildNumber, szCurBld, sizeof(szCurBld));
   }
    
   //
   // Load the build number in the szBld 
   // Variable.
   //
   GetBuildNumber (szBld);


   //
   // Generate a MachineID upfront to use later.
   //
   lpCmdFrom.dwRandomID = RandomMachineID();


   GetTargetFile (szFileToSave, szBld);
   if (!lpCmdFrom.b_Cancel){

      GetNTSoundInfo ();
      
      if (g_pfnWriteDataToFile)
		  g_pfnWriteDataToFile(szFileToSave, NULL, &lpCmdFrom);
      else 
         WriteMinimalData (szFileToSave);
   }
   else
      DeleteDatafile (szFileToSave);
   return 0;
}



VOID 
GlobalInit(VOID)
/*++

Author: Wallyho.
    
Routine Description:

   Initializes global Values.

Arguments:
   NONE
 
Return Value:

   NONE

--*/

{

//
// Do some global initializations.
//

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\lib\netinfo.c ===
#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <tchar.h>
#include <stdlib.h>
#include <string.h>
#include <regstr.h>
#include <cfgmgr32.h>
#include "pnpstuff.h"






//
// Globals
//

DEV_INFO *g_pdiDevList;          // Head of device list



/*++

Routine Description: (21) GetDevNodeInfoAndCreateNewDevInfoNode

   Creates new list node, then gets registry and resource information for
   a specific device and copies it into that node. Finally, adds new node
   to beginning of linked list

Arguments:

    dnDevNode:    the device to find information about
    szDevNodeID:  the registry path name of the device
    szEnumBuffer: name of enumerator this device is under

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL GetDevNodeInfoAndCreateNewDevInfoNode(IN DEVNODE dnDevNode,
                                           IN PTCHAR  szDevNodeID,
                                           IN PTCHAR  szEnumBuffer)
{
   LOG_CONF  lcLogConf = 0, lcLogConfNew;
   CONFIGRET cmret, cmret2;
   BOOL      boolForced;
   PDEV_INFO pdiDevInfo=(PDEV_INFO)malloc(sizeof(DEV_INFO));
   int       i;
   BOOL      boolForcedFound = FALSE, boolAllocFound = FALSE;
   USHORT    ushLogConfType[4] = {BOOT_LOG_CONF,
                                  ALLOC_LOG_CONF,
                                  BASIC_LOG_CONF,
                                  FORCED_LOG_CONF};

   if (pdiDevInfo == NULL)
   {

      goto RetFALSE;
   }

   //
   // If this is not a PnP device, skip it
   //
   if (!lstrcmpi(szEnumBuffer, TEXT("Root")))
   {
      free(pdiDevInfo);
      goto RetTRUE;

   }

   //
   // Initialize fields inside the node
   //
   if (!InitializeInfoNode(pdiDevInfo, szDevNodeID, dnDevNode))
   {
      //
      // This is a device we don't want to list. Skip it
      //
      free(pdiDevInfo);
      goto RetTRUE;
   }

   for (i = 0; i < NUM_LOG_CONF_TYPES; i++)
   {
      //
      // Get logical configuration information
      //
      cmret = CM_Get_First_Log_Conf(&lcLogConfNew,
                                    dnDevNode,
                                    ushLogConfType[i]);

      while (CR_SUCCESS == cmret)
      {
         lcLogConf = lcLogConfNew;

         if (ALLOC_LOG_CONF == ushLogConfType[i])
         {
            boolAllocFound = TRUE;
         }

         if (!(GetResDesList(pdiDevInfo, lcLogConf, ushLogConfType[i])))
         {
            goto RetFALSE;
         }

         cmret = CM_Get_Next_Log_Conf(&lcLogConfNew,
                                      lcLogConf,
                                      0);

         cmret2 = CM_Free_Log_Conf_Handle(lcLogConf);

      }
   }

   //
   // If device has no Alloc configurations, skip
   // to the next device
   //
   if (!boolAllocFound)
   {



      //free(pdiDevInfo);
      //goto RetTRUE;
   }

   //
   // Insert new pdiDevInfo into Linked List of DevNodes
   //
   if (g_pdiDevList == NULL)
   {
      //
      // DevList is empty
      //
      g_pdiDevList = pdiDevInfo;
   }
   else
   {
      //
      // Add new pdiDevInfo to beginning of linked list
      //
      pdiDevInfo->Next = g_pdiDevList;
      g_pdiDevList->Prev = pdiDevInfo;

      g_pdiDevList = pdiDevInfo;
   }

   RetTRUE:
   return TRUE;

   RetFALSE:
   return FALSE;

} /* GetDevNodeInfoAndCreateNewDevInfoNode */




/*++

Routine Description: (20) ParseEnumerator

   Gets devices listed under enumerator name in registry

Arguments:

    szEnumBuffer: the enumerator name

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL ParseEnumerator(IN PTCHAR szEnumBuffer)
{

  PTCHAR    szDevIDBuffer = NULL;
  PTCHAR    szDevNodeID = NULL;
  ULONG     ulDevIDBufferLen = 0, ulCount = 0, ulStart = 0;
  CONFIGRET cmret = CR_SUCCESS;
  DEVNODE   dnDevNode;

  //
  // Get buffer length
  //
  cmret = CM_Get_Device_ID_List_Size(&ulDevIDBufferLen,
                                     szEnumBuffer,
                                     CM_GETIDLIST_FILTER_ENUMERATOR);

  if (CR_SUCCESS != cmret)
  {
     //ErrorLog(20, TEXT("CM_Get_Device_ID_List_Size"), cmret, NULL);
     goto RetFALSE;
  }

  if ((szDevIDBuffer = malloc(sizeof(TCHAR) * ulDevIDBufferLen)) == NULL ||
      (szDevNodeID   = malloc(sizeof(TCHAR) * ulDevIDBufferLen)) == NULL)
  {
     goto RetFALSE;
  }

  //
  // Get the Device ID List
  //
  cmret = CM_Get_Device_ID_List(szEnumBuffer,
                                szDevIDBuffer,
                                ulDevIDBufferLen,
                                CM_GETIDLIST_FILTER_ENUMERATOR);

  if (CR_SUCCESS != cmret)
  {
     //ErrorLog(20, TEXT("CM_Get_Device_ID_List"), cmret, NULL);
     goto RetFALSE;
  }

  //
  // Note that ulDevIDBufferLen is a loose upper bound. The API may have
  // returned a size greater than the actual size of the list of strings.
  //
  for (ulCount = 0; ulCount < ulDevIDBufferLen; ulCount++)
  {
     ulStart = ulCount;

     if (szDevIDBuffer[ulCount] != '\0')
     {
        cmret = CM_Locate_DevNode(&dnDevNode,
                                  szDevIDBuffer + ulCount,
                                  CM_LOCATE_DEVNODE_NORMAL);

        //
        // Go to the next substring
        //
        while (szDevIDBuffer[ulCount] != TEXT('\0'))
        {
           ulCount++;
        
        }
        // Stop when we reach the double-NULL terminator
        
        if (szDevIDBuffer[ulCount+1] == TEXT('\0'))
        {
            ulCount=ulDevIDBufferLen;
            continue;
        }

        if (cmret == CR_SUCCESS)
        {
           wsprintf(szDevNodeID, TEXT("%s"), szDevIDBuffer + ulStart);

           //
           // Found the DevNode, so add its information to the device list
           //
           if (!(GetDevNodeInfoAndCreateNewDevInfoNode(dnDevNode,
                                                       szDevNodeID,
                                                       szEnumBuffer)))
           {
             goto RetFALSE;
           }
        }
     }
  }

  return TRUE;

  RetFALSE:

  return FALSE;

} /* Parse Enumerator */




void CollectDevData()
{
   CONFIGRET cmret = CR_SUCCESS;
   ULONG     ulIndexNum = 0;
   ULONG     ulEnumBufferLen = 0;
   PTCHAR    szEnumBuffer;

   szEnumBuffer = malloc(sizeof(TCHAR) * MAX_DEVNODE_ID_LEN);

   for (ulIndexNum = 0; cmret == CR_SUCCESS; ulIndexNum++)
   {
      ulEnumBufferLen = MAX_DEVNODE_ID_LEN;
      cmret = CM_Enumerate_Enumerators(ulIndexNum,
                                       szEnumBuffer,
                                       &ulEnumBufferLen,
                                       0);

      if (cmret == CR_SUCCESS)
      {
         ParseEnumerator(szEnumBuffer);
      }
   }

} /* CollectDevData */



/*++

Routine Description: (22) CopyRegistryLine

   Copies one specific string of registry data to new list node

Arguments:

    dnDevNode:      the device to get information about
    ulpropertyType: which registry string to get
    pdiDevInfo:     the new list node

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL CopyRegistryLine(IN DEVNODE   dnDevNode,
                      IN ULONG     ulPropertyType,
                      IN PDEV_INFO pdiDevInfo)
{
   ULONG     ulRegDataLen = 0, ulRegDataType = 0;
   CONFIGRET cmret = CR_SUCCESS;
   PTCHAR    szRegData = NULL;

   //
   // Get the length of the buffer  don't bother checking return value
   // If RegProperty doesn't exist, we'll just move on
   //
   CM_Get_DevNode_Registry_Property(dnDevNode,
                                    ulPropertyType,
                                    NULL,
                                    NULL,
                                    &ulRegDataLen,
                                    0);

   if (!ulRegDataLen ||
       (szRegData = malloc(sizeof(TCHAR) * ulRegDataLen)) == NULL)
   {
      goto RetFALSE;
   }

   //
   // Now get the registry information
   //
   cmret = CM_Get_DevNode_Registry_Property(dnDevNode,
                                            ulPropertyType,
                                            &ulRegDataType,
                                            szRegData,
                                            &ulRegDataLen,
                                            0);

   if (CR_SUCCESS == cmret)
   {
      if (!(CopyRegDataToDevInfoNode(pdiDevInfo,
                                     ulPropertyType,
                                     szRegData)))
      {
         goto RetFALSE;
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyRegistryLine */




/*++

Routine Description: (23) CopyRegDataToDevInfoNode

   Copies a registry string to a list node

Arguments:

    pdiDevInfo:     the new list node
    ulPropertyType: which registry string to copy
    szRegData:      the data to be copied

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL CopyRegDataToDevInfoNode(IN OUT PDEV_INFO pdiDevInfo,
                              IN     ULONG     ulPropertyType,
                              IN     PTCHAR    szRegData)
{
   if (pdiDevInfo == NULL)
   {
      goto RetFALSE;
   }

   switch (ulPropertyType)
   {
      case CM_DRP_DEVICEDESC:

         wsprintf(pdiDevInfo->szDescription, TEXT("%s"), szRegData);
         break;

      case CM_DRP_HARDWAREID:

         wsprintf(pdiDevInfo->szHardwareID, TEXT("%s"), szRegData);
         break;

      case CM_DRP_SERVICE:

         wsprintf(pdiDevInfo->szService, TEXT("%s"), szRegData);
         break;

      case CM_DRP_CLASS:

         wsprintf(pdiDevInfo->szClass, TEXT("%s"), szRegData);
         break;

      case CM_DRP_MFG:

         wsprintf(pdiDevInfo->szManufacturer, TEXT("%s"), szRegData);
         break;

      case CM_DRP_CONFIGFLAGS:

         wsprintf(pdiDevInfo->szConfigFlags, TEXT("%s"), szRegData);
         break;



//         Log(23, SEV2, TEXT("Invalid property type"));
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyRegDataToDevInfoNode */




/*++

Routine Description: (58) InitializeInfoNode

   Initialized fields inside the new node

Arguments:

    pdiDevInfo:  the node
    szDevNodeID: used to find the dnDevNode in the future
    dnDevNode:   the device we're storing information about

Return Value:

    BOOL: TRUE if we should keep this node, FALSE if we should throw it away

--*/
BOOL InitializeInfoNode(IN PDEV_INFO pdiDevInfo,
                        IN PTCHAR    szDevNodeID,
                        IN DEVNODE   dnDevNode)
{
   if (pdiDevInfo)
   {
      pdiDevInfo->Next = NULL;
      pdiDevInfo->Prev = NULL;

      pdiDevInfo->szDevNodeID[0]    = '\0';
      pdiDevInfo->szDescription[0]  = '\0';
      pdiDevInfo->szHardwareID[0]   = '\0';
      pdiDevInfo->szService[0]      = '\0';
      pdiDevInfo->szClass[0]        = '\0';
      pdiDevInfo->szManufacturer[0] = '\0';
      pdiDevInfo->szConfigFlags[0]  = '\0';
      pdiDevInfo->szFriendlyName[0] = '\0';

      pdiDevInfo->boolSavedOrigConfiguration = FALSE;
      pdiDevInfo->boolDisabled = FALSE;

      pdiDevInfo->prddForcedResDesData = NULL;
      pdiDevInfo->prddAllocResDesData  = NULL;
      pdiDevInfo->prddBasicResDesData  = NULL;
      pdiDevInfo->prddBootResDesData   = NULL;

      //
      // Store devNodeID in pdiDevInfo to get handles to devnode in future
      //
      wsprintf(pdiDevInfo->szDevNodeID, TEXT("%s"), szDevNodeID);

      //
      // Extract information from the registry about this DevNode
      //
      CopyRegistryLine(dnDevNode, CM_DRP_DEVICEDESC,  pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_HARDWAREID,  pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_SERVICE,     pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_CLASS,       pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_MFG,         pdiDevInfo);
      CopyRegistryLine(dnDevNode, CM_DRP_CONFIGFLAGS, pdiDevInfo);

      RecordFriendlyName(pdiDevInfo);
   }

   //
   // Check the friendly name to see if we want to throw this node away
   //
   if (strcmp(pdiDevInfo->szFriendlyName, "STORAGE/Volume") == 0 ||
       strcmp(pdiDevInfo->szFriendlyName, "Unknown Device") == 0)

   {
      return FALSE;
   }

   return TRUE;

} /* InitializeInfoNode */




/*++

Routine Description: (57) RecordFriendlyName

   Finds the best user friendly name for this device

Arguments:

    pdiDevInfo: node containing all possible names

Return Value:

    void

--*/
void RecordFriendlyName(IN PDEV_INFO pdiDevInfo)
{
   if (pdiDevInfo)
   {
      if (pdiDevInfo->szDescription &&
          pdiDevInfo->szDescription[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szDescription);
      }
      else if (pdiDevInfo->szHardwareID &&
               pdiDevInfo->szHardwareID[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szHardwareID);
      }
      else if (pdiDevInfo->szManufacturer &&
               pdiDevInfo->szManufacturer[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szHardwareID);
      }
      else if (pdiDevInfo->szService &&
               pdiDevInfo->szService[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szService);
      }
      else if (pdiDevInfo->szClass &&
               pdiDevInfo->szClass[0] != '\0')
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("%s"),
                   pdiDevInfo->szClass);
      }
      else
      {
         wsprintf(pdiDevInfo->szFriendlyName, TEXT("Unknown Device"));
      }
   }

} /* RecordFriendlyName */





/*++

Routine Description: (24) GetResDesList

   Creates new resource data node and copies resource information to that node

Arguments:

    pdiDevInfo:    the list node which will contain the new resource node
    lcLogConf:     the logical configuration information
    ulLogConfType: FORCED, ALLOC, BOOT, or BASIC logical configuration

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL GetResDesList(IN OUT PDEV_INFO pdiDevInfo,
                   IN     LOG_CONF  lcLogConf,
                   IN     ULONG     ulLogConfType)
{
   CONFIGRET     cmret, cmret2;
   RES_DES       rdResDes = 0, rdResDesNew;
   RESOURCEID    ridResourceID = 0;
   PRES_DES_DATA prddResDesData;

   prddResDesData = (PRES_DES_DATA)malloc(sizeof(RES_DES_DATA));

   if (prddResDesData == NULL)
   {
//      Log(24, SEV2, TEXT("ResDesData malloc failed."));
      goto RetFALSE;
   }

   prddResDesData->Next = NULL;
   prddResDesData->Prev = NULL;

   prddResDesData->pmresMEMResource = NULL;
   prddResDesData->piresIOResource = NULL;
   prddResDesData->pdresDMAResource = NULL;
   prddResDesData->pqresIRQResource = NULL;


   cmret = CM_Get_Next_Res_Des(&rdResDesNew,
                               lcLogConf,
                               ResType_All,
                               &ridResourceID,
                               0);

   //
   // Go through each resource type and copy data to new node
   //
   while (CR_SUCCESS == cmret)
   {
      rdResDes = rdResDesNew;

      if (ridResourceID >= ResType_Mem && ridResourceID <= ResType_IRQ)
      {
         if (!(ProcessResDesInfo(prddResDesData,
                                 rdResDes,
                                 ridResourceID)))
         {
            goto RetFALSE;
         }
      }

      cmret = CM_Get_Next_Res_Des(&rdResDesNew,
                                  rdResDes,
                                  ResType_All,
                                  &ridResourceID,
                                  0);

      cmret2 = CM_Free_Res_Des_Handle(rdResDes);

      if (cmret2 != CR_SUCCESS)
      {
         //ErrorLog(24, TEXT("CM_Free_Res_Des_Handle"), cmret2, NULL);
      }
   }

   //
   // **** change this by making resDesData = pdiDevInfo->----ResDesDAta
   //      and merging into one code
   //

   //
   // Add the new node to the linked list
   //
   switch (ulLogConfType)
   {
      case FORCED_LOG_CONF:

         if (!pdiDevInfo->prddForcedResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddForcedResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddForcedResDesData;
            pdiDevInfo->prddForcedResDesData->Prev = prddResDesData;

            pdiDevInfo->prddForcedResDesData = prddResDesData;
         }
         break;

      case ALLOC_LOG_CONF:

         if (!pdiDevInfo->prddAllocResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddAllocResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddAllocResDesData;
            pdiDevInfo->prddAllocResDesData->Prev = prddResDesData;

            pdiDevInfo->prddAllocResDesData = prddResDesData;
         }
         break;

      case BASIC_LOG_CONF:

         if (!pdiDevInfo->prddBasicResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddBasicResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddBasicResDesData;
            pdiDevInfo->prddBasicResDesData->Prev = prddResDesData;

            pdiDevInfo->prddBasicResDesData = prddResDesData;
         }
         break;

      case BOOT_LOG_CONF:

         if (!pdiDevInfo->prddBootResDesData)
         {
            //
            // This is the first entry into the linked list
            //
            pdiDevInfo->prddBootResDesData = prddResDesData;
         }
         else
         {
            //
            // Add new node to beginning of linked list
            //
            prddResDesData->Next = pdiDevInfo->prddBootResDesData;
            pdiDevInfo->prddBootResDesData->Prev = prddResDesData;

            pdiDevInfo->prddBootResDesData = prddResDesData;
         }
         break;

      default:

//         Log(24, SEV2, TEXT("Illegal LogConfType\n - %ul"), ulLogConfType);
         goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* GetResDestList */




/*++

Routine Description: (25) ProcessResDesInfo

   Gets information for one resource descriptor

Arguments:

    prddResDesData: the new resource data node receiving the info
    rdResDes:       the resource descriptor containing the info
    ridResourceID:  tells the resource type (DMA, IO, MEM, IRQ, or CS)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL ProcessResDesInfo(IN OUT PRES_DES_DATA prddResDesData,
                       IN     RES_DES       rdResDes,
                       IN     RESOURCEID    ridResourceID)
{
   PVOID     pvResDesDataBuffer = NULL;
   ULONG     ulResDesDataBufferLen;
   CONFIGRET cmret;

   cmret = CM_Get_Res_Des_Data_Size(&ulResDesDataBufferLen,
                                    rdResDes,
                                    0);

   if (CR_SUCCESS != cmret)
   {
      //ErrorLog(25, TEXT("CM_Get_Res_Des_Data_Size"), cmret, NULL);
      goto RetFALSE;
   }

   if ((pvResDesDataBuffer = malloc(sizeof(PVOID) * ulResDesDataBufferLen))
        == NULL)
   {
//      Log(25, SEV2, TEXT("resDesDataBuffer malloc size of %d failed."),
  //                  ulResDesDataBufferLen);
      goto RetFALSE;
   }

   //
   // Get the data
   //
   cmret = CM_Get_Res_Des_Data(rdResDes,
                               pvResDesDataBuffer,
                               ulResDesDataBufferLen,
                               0);

   if (CR_SUCCESS != cmret)
   {
      //ErrorLog(25, TEXT("CM_Get_Res_Des_Data"), cmret, NULL);
      goto RetFALSE;
   }

   //
   // Copy data into ResDesData node
   //
   switch (ridResourceID)
   {
      case ResType_Mem:

         prddResDesData->pmresMEMResource = (PMEM_RESOURCE)pvResDesDataBuffer;
         break;

      case ResType_IO:

         prddResDesData->piresIOResource = (PIO_RESOURCE)pvResDesDataBuffer;
         break;

      case ResType_DMA:

         prddResDesData->pdresDMAResource = (PDMA_RESOURCE)pvResDesDataBuffer;
         break;

      case ResType_IRQ:

         prddResDesData->pqresIRQResource = (PIRQ_RESOURCE)pvResDesDataBuffer;
         break;

      default:

//         Log(25, SEV2, TEXT("Illegal ResourceID - %ul"), ridResourceID);
         goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* ProcessResDesInfo */




/*++

Routine Description: (26) UpdateDeviceList

    Frees resource information for all devices and then collects the
    information again

Arguments:

    none (g_pdiDevList is global head of device list)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL UpdateDeviceList()
{
   PDEV_INFO pdiTmpDevInfo;

   pdiTmpDevInfo = g_pdiDevList;

   //
   // Go through linked list and delete each node's ResDes lists
   //
   while (pdiTmpDevInfo)
   {
      if (pdiTmpDevInfo->prddForcedResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddForcedResDesData);
         pdiTmpDevInfo->prddForcedResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddAllocResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddAllocResDesData);
         pdiTmpDevInfo->prddAllocResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddBasicResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddBasicResDesData);
         pdiTmpDevInfo->prddBasicResDesData = NULL;
      }

      if (pdiTmpDevInfo->prddBootResDesData)
      {
         DeleteResDesDataNode(pdiTmpDevInfo->prddBootResDesData);
         pdiTmpDevInfo->prddBootResDesData = NULL;
      }

      pdiTmpDevInfo = pdiTmpDevInfo->Next;
   }

   pdiTmpDevInfo = g_pdiDevList;

   //
   // Recreate the ResDesLists for each node
   //
   while (pdiTmpDevInfo)
   {
      if (!(RecreateResDesList(pdiTmpDevInfo, FORCED_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, ALLOC_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, BASIC_LOG_CONF)))
         goto RetFALSE;

      if (!(RecreateResDesList(pdiTmpDevInfo, BOOT_LOG_CONF)))
         goto RetFALSE;

      pdiTmpDevInfo = pdiTmpDevInfo->Next;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* UpdateDeviceList */




/*++

Routine Description: (27) DeleteResDesDataNode

    Deletes a string of RES_DES_DATA structures

Arguments:

    prddTmpResDes: the head of the linked list

Return Value:

    void

--*/
void DeleteResDesDataNode(IN PRES_DES_DATA prddTmpResDes)
{
   PRES_DES_DATA prddNextResDes;

   while (prddTmpResDes)
   {
      prddNextResDes = prddTmpResDes->Next;

      free (prddTmpResDes);

      prddTmpResDes = prddNextResDes;
   }

} /* DeleteResDesDataNode */



/*++

Routine Description: (56) CopyDataToLogConf

   Calls CM_Add_Res_Des to add a resDes to a lcLogConf

Arguments:

    lcLogConf:     the lcLogConf receiving the resDes
    ridResType:    ResType_Mem, IO, DMA or IRQ
    pvResData:     the new data
    ulResourceLen: size of the data

Return Value:

    BOOL: TRUE if the CM call succeeds, FALSE if not

--*/
BOOL CopyDataToLogConf(IN LOG_CONF   lcLogConf,
                       IN RESOURCEID ridResType,
                       IN PVOID      pvResData,
                       IN ULONG      ulResourceLen)
{
   CONFIGRET cmret;
   RES_DES   rdResDes;

   //
   // Copy the data to the logConf
   //
   cmret = CM_Add_Res_Des(&rdResDes,
                          lcLogConf,
                          ridResType,
                          pvResData,
                          ulResourceLen,
                          0);

   if (CR_SUCCESS != cmret)
   {

      goto RetFALSE;
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* CopyDataToLogConf */



/*++

Routine Description: (28) RecreateResDesList

    Uses CM calls to find ResDes information and creates linked list
    of this information inside of given DEV_INFO

Arguments:

    pdiTmpDevInfo: the node receiving the information
    ulLogConfType: the LogConf type (FORCED_LOG_CONF,
                                     ALLOC_LOG_CONF,
                                     BASIC_LOG_CONF,
                                     BOOT_LOG_CONF)

Return Value:

    BOOL: TRUE if function succeeds, FALSE if not

--*/
BOOL RecreateResDesList(IN OUT PDEV_INFO pdiTmpDevInfo,
                        IN     ULONG     ulLogConfType)
{
   CONFIGRET cmret, cmret2;
   DEVNODE   dnDevNode;
   LOG_CONF  lcLogConf, lcLogConfNew;

   //
   // Get handle to the devnode
   //
   cmret = CM_Locate_DevNode(&dnDevNode,
                             pdiTmpDevInfo->szDevNodeID,
                             CM_LOCATE_DEVNODE_NORMAL);

   if (CR_SUCCESS != cmret)
   {
      //ErrorLog(28, TEXT("CM_Locate_DevNode"), cmret, NULL);
      goto RetFALSE;
   }

   //
   // Get logical configuration information
   //
   cmret = CM_Get_First_Log_Conf(&lcLogConfNew,
                                 dnDevNode,
                                 ulLogConfType);

   while (CR_SUCCESS == cmret)
   {
      lcLogConf = lcLogConfNew;

      if (!(GetResDesList(pdiTmpDevInfo, lcLogConf, ulLogConfType)))
      {
         goto RetFALSE;
      }

      cmret = CM_Get_Next_Log_Conf(&lcLogConfNew,
                                   lcLogConf,
                                   0);

      cmret2 = CM_Free_Log_Conf_Handle(lcLogConf);

      if (CR_SUCCESS != cmret2)
      {
         //ErrorLog(28, TEXT("CM_Free_Log_Conf"), cmret2, NULL);
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} /* RecreateResDesList */





void Cleanup()
{
   PDEV_INFO pdiDevInfo = g_pdiDevList;
   PDEV_INFO pdiNextInfoNode;



   while (pdiDevInfo)
   {

      pdiNextInfoNode = pdiDevInfo->Next;

      DeleteResDesDataNode(pdiDevInfo->prddForcedResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddAllocResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddBasicResDesData);
      DeleteResDesDataNode(pdiDevInfo->prddBootResDesData);

      free(pdiDevInfo);

      pdiDevInfo = pdiNextInfoNode;
   }

} /* Cleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\exe\setuplogexe.h ===
/*++

   File:    setuplogEXE.h

   Purpose: To be inclusive of all header files
           without duplication.
  
   Revision History

   Created     Nov 15th, 1998    WallyHo
      Modified    Mar 31st, 1999    WallyHo  for MSI installs.

--*/
#ifndef SETUPLOG_H
#define SETUPLOG_H

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys\timeb.h>
#include <tchar.h>
#include <time.h>
#include <winperf.h>
//******togther for net_api_status ****
//
//*************************************
#include "setuplog.h" // save for DLL and XE

//
// Defines
//

#define DEBUG 0
#define SAVE_FILE "c:\\setuplog.ini"
#define MAX_WAVEOUT_DEVICES 2



//
// Struct Declarations
//

typedef struct _MULTIMEDIA{
   INT nNumWaveOutDevices;                            // # WaveOut Devices ie. # sound cards.
   TCHAR szWaveOutDesc[MAX_WAVEOUT_DEVICES][128];     // WaveOut description
   TCHAR szWaveDriverName[MAX_WAVEOUT_DEVICES][128];  // Wave Driver name
 } *LPMULTIMEDIA, MULTIMEDIA;

//
// GlowBall Variables.
//

#if DEBUG
   TCHAR       szMsgBox [ MAX_PATH ];
#endif
   MULTIMEDIA     m;
   TCHAR          szArch[ 20 ];
   TCHAR          szCPU[ 6 ];
   OSVERSIONINFO  osVer;


//
// GlowBall Statics to prevent multiple inclusions. W.HO
//

static   TCHAR szCurBld[10]   = {TEXT('\0')};
static   fnWriteData g_pfnWriteDataToFile = NULL;
static   LPTSTR szPlatform     = TEXT("Windows NT 5.0");
   



/*********** For GetTaskList *****************/

//
// manafest constants
//
#define TITLE_SIZE          64
#define PROCESS_SIZE        16

#define INITIAL_SIZE        51200
#define EXTEND_SIZE         25600
#define REGKEY_PERF         "software\\microsoft\\windows nt\\currentversion\\perflib"
#define REGSUBKEY_COUNTERS  "Counters"
#define PROCESS_COUNTER     "process"
#define PROCESSID_COUNTER   "id process"
#define UNKNOWN_TASK        "unknown"

//
// task list structure
//

typedef struct _THREAD_INFO {
    ULONG ThreadState;
    HANDLE UniqueThread;
} THREAD_INFO, *PTHREAD_INFO;

typedef struct _TASK_LIST {
    DWORD       dwProcessId;
    DWORD       dwInheritedFromProcessId;
    ULARGE_INTEGER CreateTime;
    BOOL        flags;
    HANDLE      hwnd;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    CHAR        ProcessName[PROCESS_SIZE];
    CHAR        WindowTitle[TITLE_SIZE];

    ULONG       PeakVirtualSize;
    ULONG       VirtualSize;
    ULONG       PageFaultCount;
    ULONG       PeakWorkingSetSize;
    ULONG       WorkingSetSize;
    ULONG       NumberOfThreads;
    PTHREAD_INFO pThreadInfo;

} TASK_LIST, *PTASK_LIST;


typedef struct _TASK_LIST_ENUM {
    PTASK_LIST  tlist;
    DWORD       numtasks;
    LPSTR       lpWinsta;
    LPSTR       lpDesk;
    BOOL        bFirstLoop;
} TASK_LIST_ENUM, *PTASK_LIST_ENUM;


//
// Prototypes.
//

VOID     GetTargetFile (LPTSTR szOutPath, LPTSTR szBld);
VOID     GetNTSoundInfo(VOID);
VOID     ConnectAndWrite(LPTSTR MachineName, LPTSTR Buffer);
VOID     GetBuildNumber (LPTSTR szBld);
VOID     WriteMinimalData (LPTSTR szFileName);

VOID     DeleteDatafile (LPTSTR szDatafile);
DWORD    RandomMachineID(VOID);
VOID     GlobalInit(VOID);



// MSI stuff for Joehol
BOOL     IsMSI(VOID);
DWORD    GetTaskList( PTASK_LIST pTask,DWORD dwNumTasks);

#endif SETUPLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sfp\sfp.c ===
#include <windows.h>

#include <stdio.h>
#include <tchar.h>

#define WINLOGON_KEY_NAME   TEXT("Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SFP_VALUE_NAME      TEXT("SFCDisable")
#define SFP_TEMP_KEY_NAME   TEXT("SFPLoadedAHiveHere")

#define SFP_ENABLED         	0
#define SFP_DISABLED_ALWAYS 	1
#define SFP_DISABLED_ONCE       2
#define SFP_ENABLED_NO_POPUPS	4

VOID PrintSfpState(DWORD State, BOOL fDisplayNotes) {

   switch(State) {
       case SFP_ENABLED: {
           printf("on");
           break;
       }
       case SFP_DISABLED_ALWAYS: {
           printf("off");
	   if(fDisplayNotes) {
               printf("\nNOTE: A kernel debugger MUST be attached for this setting to work");
	   }
           break;
       }
       case SFP_DISABLED_ONCE: {
           printf("off only for next boot");
	   if(fDisplayNotes) {
               printf("\nNOTE: A kernel debugger MUST be attached for this setting to work");
	   }
           break;
       }
       case SFP_ENABLED_NO_POPUPS: {
           printf("on - popups disabled");
           break;
       }
       default: {
           printf("unknown value %#x", State);
           break;
       }
   }
   printf("\n");
}

LONG SetCurrentSfpState(HKEY Key, DWORD State) {

    DWORD length = sizeof(DWORD);

    return RegSetValueEx(Key,
                         SFP_VALUE_NAME,
                         0L,
                         REG_DWORD,
                         (LPBYTE) &State,
                         length);
}

LONG GetCurrentSfpState(HKEY Key, DWORD *State) {

    LONG status;
    DWORD type;
    DWORD value;
    PBYTE buffer = (PBYTE) &value;
    DWORD length = sizeof(DWORD);

    status = RegQueryValueEx(Key,
                             SFP_VALUE_NAME,
                             NULL,
                             &type,
                             buffer,
                             &length);

    if(status != ERROR_SUCCESS) {
        printf("Error %d opening key %s\n", status, SFP_VALUE_NAME);
        return status;

    } else if((type != REG_DWORD) || (length != sizeof(DWORD))) {
        printf("Key %s is wrong type (%d)\n", SFP_VALUE_NAME, type);
        return ERROR_INVALID_DATA;
    }

    *State = value;

    return ERROR_SUCCESS;
}

LONG OpenSfpKey(HKEY RootKey, HKEY *Key) {

    return RegOpenKeyEx(RootKey,
                        WINLOGON_KEY_NAME,
                        0L,
                        KEY_ALL_ACCESS,
                        Key);
}

LONG GetPrivileges(void) {
    
    HANDLE tokenHandle;
    TOKEN_PRIVILEGES tp;
    LUID luid;

    if(!LookupPrivilegeValue(NULL, SE_RESTORE_NAME, &luid)) {
        return GetLastError();
    }

    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if(!OpenProcessToken(GetCurrentProcess(), 
                         TOKEN_ADJUST_PRIVILEGES,
                         &tokenHandle)) {
        return GetLastError();
    }

    if(!AdjustTokenPrivileges(tokenHandle, 
                              FALSE, 
                              &tp,
                              sizeof(TOKEN_PRIVILEGES),
                              NULL,
                              NULL)) {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

LONG LoadSystemHive(PTCHAR HivePath, HKEY *Key) {

    TCHAR buffer[512];

    LONG status;

    status = GetPrivileges();

    if(status != ERROR_SUCCESS) {
        return status;
    }

    _stprintf(buffer, "%s\\System32\\Config\\Software", HivePath);

    //
    // First load the hive into the registry.
    //

    status = RegLoadKey(HKEY_LOCAL_MACHINE, SFP_TEMP_KEY_NAME, buffer);

    if(status != ERROR_SUCCESS) {
        return status;
    }

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                          SFP_TEMP_KEY_NAME,
                          0L,
                          KEY_ALL_ACCESS,
                          Key);

    if(status != ERROR_SUCCESS) {
        RegUnLoadKey(HKEY_LOCAL_MACHINE, SFP_TEMP_KEY_NAME);
    }

    return status;
}

void UnloadSystemHive(void) {
    RegUnLoadKey(HKEY_LOCAL_MACHINE, SFP_TEMP_KEY_NAME);
    return;
}

void PrintUsage(void) {
    printf("sfp [-p installation root] [on | off | offonce | onnopopup]\n");
    printf("\ton        - SFP is on at the next boot\n");
    printf("\toff       - SFP is off at the next boot\n");
    printf("\toffonce   - SFP will be turned off for the next boot and\n");
    printf("\t            will automatically turn back on for subsequent boots\n");
    printf("\tonnopopup - SFP is on at the next boot, with popups disabled\n");
    return;
}

int __cdecl main(int argc, char *argv[]) {

    HKEY rootKey;
    HKEY sfpKey = NULL;

    PTCHAR installationPath = NULL;

    DWORD currentState;
    DWORD stateArgNum = -1;
    DWORD newState = -1;

    LONG status;

    if(argc == 1) {

        //
        // Nothing to do.
        //

    } else if(argc == 2) {
        // can only be changing state.
        stateArgNum = 1;
    } else if(argc == 3) {
        // two args - only valid choice is "-p path"
        if(_tcsicmp(argv[1], "-p") == 0) {
            installationPath = argv[2];
        } else {
            PrintUsage();
            return -1;
        }
    } else if(argc == 4) {
        if(_tcsicmp(argv[1], "-p") != 0) {
            PrintUsage();
            return -1;
        }
        installationPath = argv[2];
        stateArgNum = 3;
    }

    if(stateArgNum != -1) {
        PCHAR arg = argv[stateArgNum];

        if(_tcsicmp(arg, "on") == 0) {
            newState = SFP_ENABLED;
        } else if(_tcsicmp(arg, "off") == 0) {
            newState = SFP_DISABLED_ALWAYS;
        } else if(_tcsicmp(arg, "offonce") == 0) {
            newState = SFP_DISABLED_ONCE;
        } else if(_tcsicmp(arg, "onnopopup") == 0) {
            newState = SFP_ENABLED_NO_POPUPS;
        } else {
            PrintUsage();
            return -1;
        }
    }

    if(installationPath != NULL) {
        status = LoadSystemHive(installationPath, &rootKey);
        if(status != ERROR_SUCCESS) {
            printf("Error %d loading hive at %s\n", status, installationPath);
            return status;
        }
    } else {
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SOFTWARE"),
                              0L,
                              KEY_ALL_ACCESS,
                              &rootKey);
        if(status != ERROR_SUCCESS) {
            printf("Error %d opening software key\n", status);
            return status;
        }
    }

    try {
        status = OpenSfpKey(rootKey, &sfpKey);
    
        if(status != ERROR_SUCCESS) {
            printf("Error %d opening %s\n", status, WINLOGON_KEY_NAME);
            leave;
        }
    
        status = GetCurrentSfpState(sfpKey, &currentState);

        if(status == ERROR_FILE_NOT_FOUND) {
            status = ERROR_SUCCESS;
            currentState = SFP_ENABLED;
        }
    
        if(status == ERROR_SUCCESS) {
            printf("Current SFP state is ");
            PrintSfpState(currentState, (stateArgNum == -1) ? TRUE : FALSE);

            if(stateArgNum != -1) {
                status = SetCurrentSfpState(sfpKey, newState);
                if(status == ERROR_SUCCESS) {
                    status = GetCurrentSfpState(sfpKey, &currentState);

                    if(status == ERROR_SUCCESS) {
                        printf("New SFP state is ");
                        PrintSfpState(currentState,TRUE);
                        printf("This change will not take effect until you "
                               "reboot your system\n");
                    }
                } else {
                    printf("Error %d setting SFP state to %d\n", 
                           status, newState);
                }
            }
        } else {
            printf("Error %d getting current SFP state\n", status);
        }
    } finally {
        if(sfpKey != NULL) {
            RegCloseKey(sfpKey);
        }

        UnloadSystemHive();
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\lib\pnpstuff.h ===
#define BUFFER_LEN         200
#define REG_STR_LEN        100
#define NUM_LOG_CONF_TYPES 4
#define MAX_STR_LEN        300

typedef DWORD NEXTRET;

#define NR_SUCCESS 0x00000000
#define NR_DONE    0x00000001  // no more configurations
#define NR_INVALID 0x00000002  // invalid previous configuration

//
// Structures
//

//
// Stores information about a device's resource descriptors
//
typedef struct _RES_DES_DATA
{
   struct _RES_DES_DATA *Next;
   struct _RES_DES_DATA *Prev;

   PMEM_RESOURCE pmresMEMResource;
   PIO_RESOURCE  piresIOResource;
   PDMA_RESOURCE pdresDMAResource;
   PIRQ_RESOURCE pqresIRQResource;
} RES_DES_DATA, *PRES_DES_DATA;


//
// Stores registry and resource information about a device
//
typedef struct _DEV_INFO
{
   struct _DEV_INFO *Next;
   struct _DEV_INFO *Prev;

   TCHAR szDevNodeID[100];

   TCHAR szDescription[100];
   TCHAR szHardwareID[100];
   TCHAR szService[100];
   TCHAR szClass[100];
   TCHAR szManufacturer[100];
   TCHAR szConfigFlags[100];

   TCHAR szFriendlyName[100];

   PRES_DES_DATA prddForcedResDesData;
   PRES_DES_DATA prddAllocResDesData;
   PRES_DES_DATA prddBasicResDesData;
   PRES_DES_DATA prddBootResDesData;

   DEVNODE dnParent;

   RES_DES_DATA rddOrigConfiguration;
   BOOL boolSavedOrigConfiguration;

   BOOL boolConfigurable;
   BOOL boolDisabled;

} DEV_INFO, *PDEV_INFO;
void CollectDevData();

BOOL ParseEnumerator(IN PTCHAR szEnumBuffer);

BOOL GetDevNodeInfoAndCreateNewDevInfoNode(IN DEVNODE dnDevNode,
                                           IN PTCHAR  szDevNodeID,
                                           IN PTCHAR  szEnumBuffer);

BOOL CopyRegistryLine(IN DEVNODE   dnDevNode,
                      IN ULONG     ulPropertyType,
                      IN PDEV_INFO pdiDevInfo);

BOOL CopyRegDataToDevInfoNode(IN OUT PDEV_INFO pdiDevInfo,
                              IN     ULONG     ulPropertyType,
                              IN     PTCHAR    szRegData);


BOOL InitializeInfoNode(IN PDEV_INFO pdiDevInfo,
                        IN PTCHAR    szDevNodeID,
                        IN DEVNODE   dnDevNode);

void RecordFriendlyName(IN PDEV_INFO pdiDevInfo);

BOOL SaveAndDeletePreviousForcedLogConf(IN  LOG_CONF  lcLogConf,
                                        OUT PDEV_INFO pdiDevInfo);

BOOL GetResDesList(IN OUT PDEV_INFO pdiDevInfo,
                   IN     LOG_CONF  lcLogConf,
                   IN     ULONG     ulLogConfType);

BOOL ProcessResDesInfo(IN OUT PRES_DES_DATA prddResDesData,
                       IN     RES_DES       rdResDes,
                       IN     RESOURCEID    ridResourceID);

BOOL UpdateDeviceList();

void DeleteResDesDataNode(IN PRES_DES_DATA prddTmpResDes);

BOOL RecreateResDesList(IN OUT PDEV_INFO pdiTmpDevInfo,
                        IN     ULONG     ulLogConfType);

void Cleanup();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\inc\setuplog.h ===
// Definition of constants that the exe and the dll both use.
#define COMPUTERNAME    "COMPUTERNAME"
#define LOGSHARE_USER   "idwuser"
#define LOGSHARE_PW     "idwuser"

extern char * Days[];
extern char * Months[];


//
// GlowBalls
//
   TCHAR          g_szServerShare[ MAX_PATH ];
   BOOL           g_bServerOnline;

#define NUM_SERVERS 6

//
// Struct Declarations
//
typedef struct _SERVERS {
   TCHAR szSvr [ MAX_PATH ];
   BOOL  bOnline;
   DWORD dwTimeOut;
   DWORD dwNetStatus;
} *LPSERVERS, SERVERS;


//
// For the DLL's WriteDataToFile
//
typedef struct _NT32_CMD_PARAMS {
   BOOL    b_Upgrade; 
   BOOL    b_Cancel; 
   BOOL    b_CDrom; 
   BOOL    b_MsiInstall;
   DWORD   dwRandomID;
} *LPNT32_CMD_PARAMS, NT32_CMD_PARAMS;


typedef void 
(*fnWriteData)
(IN LPTSTR szFileName,
 IN LPTSTR szFrom, 
 IN LPNT32_CMD_PARAMS lpCmdL
 );


   //
   // List of servers to search.
   //
static NT32_CMD_PARAMS lpCmdFrom = {FALSE,FALSE,FALSE,FALSE,0};  

#define TIME_TIMEOUT 10

static   SERVERS s[NUM_SERVERS] = {
      {TEXT("\\\\ntcore2\\idwlog"),        FALSE, -1,-1},
      {TEXT("\\\\hctpro\\idwlog"),         FALSE, -1,-1},
      {TEXT("\\\\donkeykongjr\\idwlog"),   FALSE, -1,-1},
      {TEXT("\\\\nothing\\idwlog"),        FALSE, -1,-1},
      {TEXT("\\\\nothing\\idwlog"),        FALSE, -1,-1},
      {TEXT("\\\\nothing\\idwlog"),        FALSE, -1,-1},
   };
//
// Prototypes
//
BOOL  ServerOnlineThread(IN LPTSTR szServerFile);
BOOL  IsServerOnline(IN LPTSTR szMachineName, IN LPTSTR szSpecifyShare);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\setuplog\lib\setuplib.c ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include <windows.h>
#include <lm.h>
#include <stdio.h>
#include <time.h>
#include <winuserp.h>
#include <shlobj.h>
#include <shlwapi.h>

// For PnP Stuff

#include <devguid.h>
#include <initguid.h>
#include <setupapi.h>
#include <syssetup.h>
#include <regstr.h>
#include <setupbat.h>
#include <cfgmgr32.h>



#include "tchar.h"
#include "string.h"
#include "setuplog.h"
#include "setuplib.h"
#include "pnpstuff.h"

char * Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
char * Months[] = { "", "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

extern   DEV_INFO *g_pdiDevList;          // Head of device list
char     OutputBuffer[ 8192 ];
#define  MAX_WAVEOUT_DEVICES 2

struct {
// Sound Card
  int  nNumWaveOutDevices;                     // Number of WaveOut Devices (~ number of sound cards)
  char szWaveOutDesc[MAX_WAVEOUT_DEVICES][128];// WaveOut description
  char szWaveDriverName[MAX_WAVEOUT_DEVICES][128]; // Wave Driver name
} m;

#define SHORTCUT "IDW Logging Tool.lnk"

char szValidHandle[]    = "\r\nValid Handle\r\n";
char szInvalidHandle[]  = "\r\nInvalid handle. Err: %d\r\n";
char szBadWrite[]       = "WriteFile failed. Err: %d\r\n";
char szGoodWrite[]      = "WriteFile succeeded\r\n";



// From warndoc.cpp:
VOID  
GetNTSoundInfo()
{
    HKEY                hKey;
    DWORD               cbData;
    ULONG               ulType;
    LPTSTR              sSubKey=TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32");
    INT                 i;
    TCHAR               szSubKeyName[256];
    TCHAR               szTempString[256];


    // Get Sound Card Info
    hKey = 0;
    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
       m.nNumWaveOutDevices = 0;
       // Loop through the key to see how many wave devices we have, but skip mmdrv.dll.
       for (i = 0; i <= 1; i++){
          if (i)
             _stprintf(szSubKeyName, TEXT("wave%d"),i);
          else
             _tcscpy(szSubKeyName, TEXT("wave"));

          cbData = sizeof szTempString;
          if (RegQueryValueEx(hKey, szSubKeyName, 0, &ulType, (LPBYTE)szTempString, &cbData))
              break;
          else{
             if (szTempString[0] // We want to skip mmdrv.dll - not relevant.
                 && _tcscmp(szTempString, TEXT("mmdrv.dll"))){
                strcpy(&m.szWaveDriverName[m.nNumWaveOutDevices][0], szTempString);
                m.nNumWaveOutDevices++;
             }
          }
       }
    }

    if (hKey){
       RegCloseKey(hKey);
       hKey = 0;
    }

    sSubKey = (LPTSTR)TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\drivers.desc");
    hKey = 0;

    if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, sSubKey, 0, KEY_READ, &hKey)){
       // Now grab the sound device string for each wave device
       for (i = 0; i < m.nNumWaveOutDevices; i++){
          cbData = sizeof szTempString;
          if (RegQueryValueEx(hKey, m.szWaveDriverName[i], 0, &ulType, (LPBYTE)szTempString, &cbData))
             _tcscpy(m.szWaveOutDesc[i], TEXT("Unknown"));
          else
             _tcscpy(m.szWaveOutDesc[i], szTempString);
       }
    }

    if (hKey){
      RegCloseKey(hKey);
      hKey = 0;
    }
    return;
}

//
// GetVidInfo reads registry information about the installed
// video cards and produces one string
//
#define HWKEY TEXT("SYSTEM\\CurrentControlSet\\Hardware Profiles\\Current\\System\\CurrentControlSet\\Services")
#define SERVICEKEY TEXT("SYSTEM\\CurrentControlSet\\Services")

#define DESCVAL TEXT("Device Description")
#define TYPEVAL TEXT("HardwareInformation.ChipType")
#define DACVAL  TEXT("HardwareInformation.DacType")
#define MEMVAL  TEXT("HardwareInformation.MemorySize")


VOID 
GetVidInfo (LPTSTR vidinfo)
{

   HKEY     hkHardware;
   HKEY     hkCard;
   DWORD    dwSize;
   TCHAR    szBuf[256];
   WCHAR    szWideBuf[128];
   TCHAR    szSubKey[128];
   DWORD    dwIndex=0;
   DWORD    dwMem;

   *vidinfo = '\0';
   //
   // Look in HWKEY to find out what services are used.
   //
   if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, HWKEY, 0, KEY_READ, &hkHardware))
      return;

   dwSize=128;
   while (ERROR_SUCCESS == RegEnumKeyEx (hkHardware, dwIndex++,szSubKey, &dwSize,NULL,NULL,NULL,NULL)){
      //
      // Append the subkey name to SERVICEKEY. Look up only Device0 for this card
      //
      _stprintf (szBuf, ("%s\\%s\\Device0"), SERVICEKEY, szSubKey);
      RegOpenKeyEx (HKEY_LOCAL_MACHINE, szBuf, 0, KEY_READ, &hkCard);
      //
      // First get the description
      //
      dwSize=256;
      if (ERROR_SUCCESS == RegQueryValueEx (hkCard, DESCVAL, NULL, NULL, szBuf, &dwSize)){
         if (_tcsclen(vidinfo)+dwSize < 254){
            _tcscat (vidinfo, szBuf);
            _tcscat (vidinfo, TEXT(" "));
         }
      }

      //
      // Read the chip type. This is a UNICODE string stored in REG_BINARY format
      //
      dwSize=256;
      lstrcpyW (szWideBuf, L"ChipType:");
      if (ERROR_SUCCESS == RegQueryValueEx (hkCard,TYPEVAL,NULL, NULL, (LPBYTE)(szWideBuf+9), &dwSize)){
         if ((dwSize=lstrlen(vidinfo))+lstrlenW(szWideBuf)<254)         {
            WideCharToMultiByte (CP_ACP, 0,
                              szWideBuf, -1,
                              vidinfo+dwSize, 256-dwSize, NULL,NULL);
            lstrcat (vidinfo, " ");
         }
      }

    //
    // Read the DAC. Another UNICODE string
    //
    dwSize=256;
    lstrcpyW (szWideBuf, L"DACType:");
    if (ERROR_SUCCESS == RegQueryValueEx (hkCard,DACVAL,NULL, NULL, (LPBYTE)(szWideBuf+8), &dwSize)){
        if ((dwSize=lstrlen(vidinfo))+lstrlenW(szWideBuf)<254){
            WideCharToMultiByte (CP_ACP, 0,
                              szWideBuf, -1,
                              vidinfo+dwSize, 256-dwSize, NULL,NULL);
        lstrcat (vidinfo, " ");
        }
    }
    //
    // Read the memory size. This is a binary value.
    //
    dwSize=sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueEx (hkCard, MEMVAL, NULL,NULL,(LPBYTE)&dwMem, &dwSize)){
        _stprintf (szBuf, TEXT("Memory:0x%x ;"), dwMem);
        if (_tcsclen(vidinfo)+lstrlen(szBuf)<255)
            _tcscat (vidinfo, szBuf);
    }
    RegCloseKey (hkCard);
    dwSize=128;
   }
   RegCloseKey (hkHardware);
}


//
// Hydra is denoted by "Terminal Server" in the ProductOptions key
//
BOOL 
IsHydra ()
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    Rslt = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPTSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueEx( hKey, TEXT("ProductSuite"), NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
    if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p) {
        if (_tcscmp( p, TEXT("Terminal Server") ) == 0) {
            rVal = TRUE;
            break;
        }
        p += (_tcslen( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


VOID
GetBuildNumber( LPTSTR BuildNumber )
{

    OSVERSIONINFO osVer;

    osVer.dwOSVersionInfoSize= sizeof( osVer );

    if (GetVersionEx( &osVer )&&osVer.dwMajorVersion >= 5) {
        wsprintf( BuildNumber, TEXT("%d"), osVer.dwBuildNumber );
    } else {
        lstrcpy( BuildNumber, TEXT("") );  // return 0 if unknown
    }


} // GetBuildNumber


/*
BOOL
GetPnPDisplayInfo(
    LPTSTR pOutputData
    )
{
    BOOL            bRet = FALSE;
    HDEVINFO        hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD           index = 0;
    TCHAR           RegistryProperty[256];
    ULONG           BufferSize;

    //
    // Let's find all the video drivers that are installed in the system
    //

    hDevInfo = SetupDiGetClassDevs((LPGUID) &GUID_DEVCLASS_DISPLAY,
                                   NULL,
                                   NULL,
                                   0);

    while (hDevInfo != INVALID_HANDLE_VALUE){
        if (bRet) 
            strcat(pOutputData, TEXT(",") );
 
        ZeroMemory(&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiEnumDeviceInfo(hDevInfo,
                                   index++,
                                   &DeviceInfoData))
            break;
        BufferSize = sizeof(RegistryProperty);
        if (CR_SUCCESS ==
                CM_Get_Device_ID(DeviceInfoData.DevInst,
                                 RegistryProperty,
                                 sizeof(RegistryProperty),
                                 0)){
            bRet = TRUE;
            strcat(pOutputData, RegistryProperty);
        }
    }
    return (bRet);
}
*/


VOID 
ConnectAndWrite(LPTSTR MachineName,
                LPTSTR Buffer
    )
{
   NETRESOURCE   NetResource ;
   TCHAR         szLogFile[ MAX_PATH ];
   TCHAR          szBinPath[MAX_PATH];
   TCHAR          szExePath[MAX_PATH];
   TCHAR          szErr[100];

   HANDLE        hWrite = INVALID_HANDLE_VALUE;
   HANDLE        hDebug = INVALID_HANDLE_VALUE;
   BOOL          bRet;
   DWORD         dwError;
   DWORD         Size, Actual ;


   //
   // Blow through the list of servers.
   // and change the g_szServerShare to match.
   //

   if (TRUE == IsServerOnline(MachineName, NULL)){
      
      //
      // Set the server name now as we now have it
      // into the outputbuffer
      //
    _stprintf (Buffer+_tcsclen(Buffer),
             TEXT("IdwlogServer:%s\r\n"), g_szServerShare);
      
      ZeroMemory( &NetResource, sizeof( NetResource ) );
      NetResource.dwType = RESOURCETYPE_DISK ;
      NetResource.lpLocalName = "" ;
      NetResource.lpRemoteName = g_szServerShare;
      NetResource.lpProvider = "" ;

      GetModuleFileName (NULL, szExePath, MAX_PATH);
      // First, try to connect with the current user ID

      dwError = WNetAddConnection2( &NetResource,NULL,NULL,0 );
      if (dwError)
         dwError = WNetAddConnection2( &NetResource,LOGSHARE_PW,LOGSHARE_USER,0 );
      dwError = 0; // Hard reset.

      if ( dwError == 0 ){
         _stprintf (szLogFile,  TEXT("%s\\%s"),g_szServerShare, MachineName );
         hDebug = CreateFile(TEXT("C:\\setuplog.dbg"),
                             GENERIC_WRITE,
                             0, NULL, CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_WRITE_THROUGH,
                             NULL);
         if (hDebug != INVALID_HANDLE_VALUE)
            WriteFile (hDebug, szExePath, _tcsclen(szExePath), &Actual, NULL);
        
         hWrite = CreateFile( szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                           NULL );

         if ( hWrite != INVALID_HANDLE_VALUE ){
            SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;
            SECURITY_DESCRIPTOR sd;
            if (hDebug != INVALID_HANDLE_VALUE)
                WriteFile (hDebug, szValidHandle, sizeof(szValidHandle), &Actual, NULL);

            Size = _tcsclen( Buffer );
            bRet = WriteFile( hWrite, Buffer, Size, &Actual, NULL );

            if (!bRet){
                if (hDebug != INVALID_HANDLE_VALUE){
                   _stprintf (szErr, szBadWrite, GetLastError());
                   WriteFile (hDebug, szErr, lstrlen(szErr), &Actual, NULL);
                }
            }
            else{
                if (hDebug != INVALID_HANDLE_VALUE)
                   WriteFile (hDebug, szGoodWrite, sizeof(szGoodWrite), &Actual, NULL);
            }
            CloseHandle( hWrite );
            //
            // We should delete the shortcut to idwlog from startup group.
            //
            SHGetFolderPath (NULL, CSIDL_COMMON_STARTUP, NULL,0,szBinPath);
            PathAppend (szBinPath, SHORTCUT);
            DeleteFile (szBinPath);

            //
            // If this is idwlog.exe, delete the program.
            //  We only need to write once.
            //
            if (strstr (CharLower(szExePath), "idwlog.exe"))
               MoveFileEx ((LPCTSTR)szExePath, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }
        else{
            if (hDebug != INVALID_HANDLE_VALUE){
                _stprintf (szErr, szInvalidHandle, GetLastError());
                WriteFile (hDebug, szErr, _tcsclen(szErr), &Actual, NULL);
            }
        }
        WNetCancelConnection2( g_szServerShare, 0, TRUE );
        if (hDebug != INVALID_HANDLE_VALUE)
           CloseHandle (hDebug);
      }
   }
}


VOID
WriteDataToFile (IN LPTSTR  szFileName, 
                 IN LPTSTR  szFrom,
                 IN LPNT32_CMD_PARAMS lpCmdL)
{

    TCHAR          username[MY_MAX_UNLEN + 1];
    TCHAR          userdomain[ DNLEN+2 ];
    TCHAR          architecture[ 16 ];
    SYSTEM_INFO    SysInfo ;

    TCHAR          build_number[256];
    TCHAR          time[ 32 ];
    DWORD          Size;
    DISPLAY_DEVICE displayDevice;
    DWORD          iLoop;
    DEVMODE        dmCurrent;
    TCHAR          displayname[MY_MAX_UNLEN + 1];

    LPTSTR         pch;
    TCHAR          localename[4];   // locale abbreviation
    TCHAR          netcards[256]    = "\0";
    TCHAR          vidinfo[256]     = "\0";
    TCHAR          modem[256]       = "\0";
    TCHAR          scsi[256]        = "\0";
    BOOL           bUSB             = FALSE;
    BOOL           bPCCard          = FALSE;
    BOOL           bACPI            = FALSE;
    BOOL           bIR              = FALSE;
    BOOL           bHydra           = FALSE;
    INT            iNumDisplays     = GetSystemMetrics(SM_CMONITORS); 

    MEMORYSTATUS   msRAM;

    DEV_INFO *pdi;
    strcpy(username, UNKNOWN);
    strcpy(displayname, UNKNOWN);


    if (!GetEnvironmentVariable (USERNAME, username, MY_MAX_UNLEN))
       lstrcpy (username, "Unknown");

    // Get the build number
    if (!szFrom)
       GetBuildNumber (build_number);
    else 
       _tcscpy (build_number, szFrom);

    GetSystemInfo( &SysInfo );

    if ( !GetEnvironmentVariable( "USERDOMAIN", userdomain, sizeof( userdomain) ) )
        _tcscpy (userdomain, "Unknown");
    if ( !GetEnvironmentVariable( "PROCESSOR_ARCHITECTURE", architecture, sizeof( architecture ) ) )
        _tcscpy (architecture, "Unknown");




    // Video Information for ChrisW

    displayDevice.cb = sizeof(DISPLAY_DEVICE);
    iLoop = 0;

    while (EnumDisplayDevices(NULL, iLoop, &displayDevice, 0)) {

        ZeroMemory( &dmCurrent, sizeof(dmCurrent) );
        dmCurrent.dmSize= sizeof(dmCurrent);
        if( EnumDisplaySettings( displayDevice.DeviceName, ENUM_CURRENT_SETTINGS, &dmCurrent ) ){
            if (iLoop == 0) 
                *displayname = 0;
            else
               _tcscat( displayname, TEXT(",") );
            _tcscat( displayname, dmCurrent.dmDeviceName );
        }
        iLoop++;
    }


    // replace spaces so we don't break the perl script the build lab is using
    pch = displayname;
    while (*pch) {
        if (*pch == ' ') *pch = '.';
        pch++;
    }

    GetVidInfo (vidinfo);

        // Get locale abbreviation so we know about language pack usage

    if( GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SABBREVLANGNAME, localename, sizeof( localename)) == 0 )
        _tcscpy(localename,"unk");

    msRAM.dwLength = sizeof (msRAM);
    GlobalMemoryStatus (&msRAM);
    //
    // Get PNP net card info
    //
    *netcards='\0';
    *scsi='\0';
    CollectDevData ();
    pdi=g_pdiDevList;
    while (pdi){
       if (!lstrcmpi (pdi->szClass, "Net")){
           if (_tcsclen(netcards) + lstrlen(pdi->szDescription) + lstrlen(pdi->szService) < 250){
               _tcscat (netcards, pdi->szDescription);
               _tcscat (netcards, "(");
               _tcscat (netcards, pdi->szService);
               _tcscat (netcards, TEXT(") "));
           }
       }
       else if (!lstrcmpi (pdi->szClass, "SCSIAdapter")){
           if (_tcsclen(scsi) + lstrlen(pdi->szService) < 250){
               _tcscat (scsi, pdi->szService);
               _tcscat (scsi, TEXT(","));
           }
       }
       else if (!lstrcmpi (pdi->szClass, "Modem")){
           if (_tcsclen(modem) + lstrlen(pdi->szDescription) < 250){
               _tcscat (modem, pdi->szDescription);
               _tcscat (modem, TEXT(","));
           }
       }
       else if (!lstrcmpi (pdi->szClass, "USB"))
           bUSB = TRUE;
       else if (!lstrcmpi (pdi->szClass, "Infrared"))
           bIR = TRUE;
       else if (!lstrcmpi (pdi->szClass, "PCMCIA") || !lstrcmpi (pdi->szService, "PCMCIA"))
          bPCCard = TRUE;
       else if (strstr (pdi->szClass, "ACPI") || strstr (pdi->szService, "ACPI"))
          bACPI = TRUE;
      pdi=pdi->Next;
    }

    Cleanup(); //free all the pnp data and restore configuration
    if (!(*netcards))
       _tcscpy (netcards, TEXT("Unknown"));
    //
    // Get Sound info
    GetNTSoundInfo ();
    // format all our data

    bHydra= IsHydra ();

    // fix the number of displays for non Windows 2000 systems
    if (!iNumDisplays)
        iNumDisplays = 1;

    //wsprintf only accepts 1k buffers.
    //  Break these up into more calls to
    // wsprintf to eliminate chance of overflow
    _stprintf (OutputBuffer,
             TEXT("MachineID:%lu\r\n")
             TEXT("Source Media:%s\r\n")
             TEXT("Type:%s\r\nUsername:%s\r\n")
             TEXT("RAM:%d\r\n")
             TEXT("FromBld:%s\r\n")
             TEXT("Arch:%s\r\nNumProcs:%d\r\n")
             TEXT("Vidinfo:%s\r\n"),
                   lpCmdL->dwRandomID,
                   lpCmdL->b_CDrom?  TEXT("C"): TEXT("N"),
                   lpCmdL->b_Upgrade?TEXT("U"):TEXT("I"),
                    username,
                    msRAM.dwTotalPhys/(1024*1024),
                    szFrom?szFrom:build_number,
                    architecture,
                    SysInfo.dwNumberOfProcessors,
                    vidinfo
             );

    _stprintf (OutputBuffer+_tcsclen(OutputBuffer),
             TEXT("VidDriver:%s\r\n")
             TEXT("Locale:%s\r\nSound:%s\r\nNetCards:%s\r\n")
             TEXT("ACPI:%d\r\n")
             TEXT("PCMCIA:%d\r\n")
             TEXT("CPU:%d\r\n")
             TEXT("SCSI:%s\r\n")
             TEXT("USB:%d\r\n")
             TEXT("Infrared:%d\r\n"),
                 displayname,
                 localename,
                 m.nNumWaveOutDevices?m.szWaveDriverName[0]:TEXT("None"),
                 netcards,
                 bACPI,
                 bPCCard,
                 (DWORD)SysInfo.wProcessorLevel,
                 scsi,
                 bUSB,
                 bIR
             );
    _stprintf (OutputBuffer+_tcsclen(OutputBuffer),
             TEXT("Modem:%s\r\n")
             TEXT("Hydra:%d\r\n")
             TEXT("Displays:%d\r\n")
             TEXT("MSI:%s\r\n"),
                    modem,
                    bHydra,
                    iNumDisplays,
                    lpCmdL->b_MsiInstall? TEXT("Y"):TEXT("N")
                    );

   ConnectAndWrite( szFileName, OutputBuffer );
}


BOOL
IsServerOnline(IN LPTSTR szMachineName, IN LPTSTR szSpecifyShare)
/*++

Routine Description:
   This will go through the list of servers specified in setuplogEXE.h
   It will return the first in it sees and reset the global server share
   name.

Arguments:
   The machineName (Filename with build etc) so the test file will get overwritten.
   Manual Server Name: NULL will give default behaviour.

Return Value:
	TRUE for success.
   FALSE for no name.
--*/

{
   DWORD    dw;
   HANDLE   hThrd;
   INT      i;
   TCHAR    szServerFile[ MAX_PATH ];
   DWORD    dwTimeOutInterval;
   i = 0;

   //
   // This should allow for a 
   // manually specified server.
   //
   if (NULL != szSpecifyShare){
       _tcscpy(g_szServerShare,szSpecifyShare);
      return TRUE;

   }
   //
   // Initialize the Server.
   // Variable. Since we are using a single thread
   // to do a time out we don't care about mutexes and
   // sychronization.
   //
   g_bServerOnline = FALSE;

   while ( i < NUM_SERVERS){

      
      _stprintf (szServerFile, TEXT("%s\\%s"),s[i].szSvr,szMachineName );
      //
      // Spawn the thread
      //
      hThrd  = CreateThread(NULL,
                        0,
                        (LPTHREAD_START_ROUTINE) ServerOnlineThread,
                        (LPTSTR) szServerFile,
                        0,
                        &dw);
      //
      // This is in milli seconds so the time out is secs.
      //
      dwTimeOutInterval = TIME_TIMEOUT * 1000;

      s[i].dwTimeOut = WaitForSingleObject (hThrd, dwTimeOutInterval);
      CloseHandle (hThrd);

      //
      // This means the server passed the timeout.
      //
      if (s[i].dwTimeOut != WAIT_TIMEOUT &&
          g_bServerOnline == TRUE){
         //
         // Copy the Share to the glowbal var.
         //
         _tcscpy(g_szServerShare,s[i].szSvr);
         return TRUE;
      }
      i++;
   }
   return FALSE;
}



BOOL
ServerOnlineThread(IN LPTSTR szServerFile)
/*++

Routine Description:
   This create a thread and then time it out to see if we can get to
   a server faster. 

Arguments:
   The machineName so the test file will get overwritten.
Return Value:

--*/
{

   BOOL     bCopy = FALSE;
   TCHAR    szFileSrc [MAX_PATH];
   TCHAR    szServerTestFile [MAX_PATH];
   //
   // Use this to get the location
   // setuplog.exe is run from. this tool
   //
   GetModuleFileName (NULL, szFileSrc, MAX_PATH);
   
   //
   // Make a unique test file. 
   //
   _stprintf(szServerTestFile,TEXT("%s.SERVERTEST"),szServerFile);
   bCopy = CopyFile( szFileSrc,szServerTestFile, FALSE);
   if (bCopy != FALSE){
      //
      // If Succeeded Delete the test file.
      //
      DeleteFile(szServerTestFile);
      g_bServerOnline = TRUE;      
      return TRUE;
   }
   else{
      g_bServerOnline = FALSE;
      return FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sleep\beep.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    beep.c

Abstract:

    User mode beep program.  This program simply calls the beep function

Author:

    Steve Wood (stevewo) 8-23-94

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

//
// Local definitions
//
VOID
DisplayUsage( VOID );

DWORD
AsciiToInteger(
    char *Number
    );


int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    char *s;
    DWORD dwFreq = 0;
    DWORD dwDuration = 0;

    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            DisplayUsage();
            exit( 1 );
            }
        else
        if (dwFreq == 0) {
            dwFreq = AsciiToInteger( s );
            if (dwFreq == 0xFFFFFFFF) {
                DisplayUsage();
                exit( 1 );
                }
            }
        else
        if (dwDuration == 0) {
            dwDuration = AsciiToInteger( s );
            if (dwDuration == 0xFFFFFFFF) {
                DisplayUsage();
                exit( 1 );
                }
            }
        }

    //
    // No bounds checking here.  Live with it.
    //

    if (dwFreq == 0) {
        dwFreq = 800;
        }

    if (dwDuration == 0) {
        dwDuration = 200;
        }

    Beep( dwFreq, dwDuration );
    return 0;
}


VOID
DisplayUsage( VOID )
{
    printf( "Usage: BEEP frequency(in Hertz) duration(in milliseconds)\n" );
}


DWORD
AsciiToInteger(
    char *Number
    )
{
    int total = 0;

    while ( *Number != '\0' ) {
        if ( *Number >= '0' && *Number <= '9' ) {
            total = total * 10 + *Number - '0';
            Number++;
        } else {
            total = -1;
            break;
        }
    }

    return total;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\cmdhelp\cmdhelpp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sptlibp.h

Abstract:

    private header for SPTLIB.DLL

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#include <stdio.h>  // required for sscanf() function
#include <windows.h>
#include <cmdhelp.h>

#if 0
#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif
#endif // 0

BOOL
CmdHelpValidateString(
    IN PCHAR String,
    IN DWORD ValidChars
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\cdburn\burn.h ===
/*
*/

//#include "sptlib.h"

#include <windows.h>  // sdk
#include <devioctl.h> // sdk
#include <ntddscsi.h> // sdk
#include <ntddcdrm.h>
#include <ntddmmc.h>
#include <ntddcdvd.h>


typedef struct _HACK_FLAGS {
    ULONG TestBurn             :  1;
    ULONG IgnoreModePageErrors :  1;
    ULONG Reserved             : 30;
} HACK_FLAGS, *PHACK_FLAGS;

// just don't want to pass more than this as a flag.
// if this ever fires, make the above a pointer....
C_ASSERT(sizeof(HACK_FLAGS) == sizeof(ULONG));



#define CDROM_CUE_SHEET_ADDRESS_START_TIME   0x01
#define CDROM_CUE_SHEET_ADDRESS_CATALOG_CODE 0x02
#define CDROM_CUE_SHEET_ADDRESS_ISRC_CODE    0x03

#define CDROM_CUE_SHEET_DATA_FORM_AUDIO 0x00 // 2352 bytes per sector
// 0x01 - audio w/zero data bytes?
#define CDROM_CUE_SHEET_DATA_FORM_MODE1 0x01 // 2048 bytes per sector


typedef struct _CDVD_BUFFER_CAPACITY {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR TotalLength[4];
    UCHAR BlankLength[4];
} CDVD_BUFFER_CAPACITY, *PCDVD_BUFFER_CAPACITY;

typedef struct _CDVD_WRITE_PARAMETERS_PAGE {
    UCHAR PageCode : 6; // 0x05
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;   // 0x32
    UCHAR WriteType : 4;
    UCHAR TestWrite : 1;
    UCHAR LinkSizeValid : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2 : 1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR FixedPacket : 1;
    UCHAR MultiSession :2;
    UCHAR DataBlockType : 4;
    UCHAR Reserved3 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode : 7;
    UCHAR Reserved5           : 1;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7               : 7;
    UCHAR MediaCatalogNumberValid : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8 : 7;
    UCHAR ISRCValid : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
    UCHAR Data[0];
} CDVD_WRITE_PARAMETERS_PAGE, *PCDVD_WRITE_PARAMETERS_PAGE;



DWORD
BurnCommand(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN HACK_FLAGS HackFlags
    );

BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN LONG NumberOfBlocks,
    IN LONG FirstLba
    );

BOOLEAN
CloseSession(
    IN HANDLE  CdromHandle
    );

BOOLEAN
CloseTrack(
    IN HANDLE CdromHandle,
    IN LONG   Track
    );

BOOLEAN
GetNextWritableAddress(
    IN HANDLE CdromHandle,
    IN UCHAR Track,
    OUT PLONG NextWritableAddress,
    OUT PLONG AvailableBlocks
    );

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    );

BOOLEAN
SendOptimumPowerCalibration(
    IN HANDLE CdromHandle
    );

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    );

BOOLEAN
SetRecordingSpeed(
    IN HANDLE CdromHandle,
    IN DWORD Speed
    );

BOOLEAN
SetWriteModePage(
    IN HANDLE CdromHandle,
    IN BOOLEAN TestBurn,
    IN UCHAR WriteType,
    IN UCHAR MultiSession,
    IN UCHAR DataBlockType,
    IN UCHAR SessionFormat
    );

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    );

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PLONG NumberOfBlocks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\sleep\sleep.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntsleep.c

Abstract:

    User mode sleep program.  This program simply sleeps for the time
    specified on the command line (in seconds).

Author:

    Manny Weiser (mannyw)   2-8-91

Revision History:

--*/

#include <stdio.h>
#include <windows.h>

//
// Local definitions
//
VOID
DisplayUsage(
    char *ProgramName
    );

int
AsciiToInteger(
    char *Number
    );


int
__cdecl main(
    int argc,
    char *argv[]
    )
{
    int time;

    if (argc != 2) {
        DisplayUsage( argv[0] );
        return 1;
    }

    time = AsciiToInteger( argv[1] );

    if (time == -1) {
        DisplayUsage( argv[0] );
        return 1;
    }

    //
    // No bounds checking here.  Live with it.
    //

    Sleep( time * 1000 );
    return 0;
}


VOID
DisplayUsage(
    char *ProgramName
    )
{
    printf( "Usage:  %s time-to-sleep-in-seconds\n", ProgramName );
}


int
AsciiToInteger(
    char *Number
    )
{
    int total = 0;

    while ( *Number != '\0' ) {
        if ( *Number >= '0' && *Number <= '9' ) {
            total = total * 10 + *Number - '0';
            Number++;
        } else {
            total = -1;
            break;
        }
    }

    return total;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\cmdhelp\cmdhelp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spt.c

Abstract:

    A user mode library that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#include "CmdHelpP.h"

static char ValidCharArray[] = {
    ' ',
    '0', '1', '2', '3',
    '4', '5', '6', '7',
    '8', '9', 'a', 'b',
    'c', 'd', 'e', 'f',
    'A', 'B', 'C', 'D',
    'E', 'F'
};
#define MaxValidOctalChars      ( 9) // space + 8 digits
#define MaxValidDecimalHexChars (11) // + 2 digits
#define MaxValidHexChars        (23) // + 12 letters (upper and lower case)
#define MaxValidCharacters      (23) // number of safe chars to access


/*++

Routine Description:

    Validates a string has valid characters
    valid chars are stored in a global static array

--*/
BOOL
PrivateValidateString(
    IN PCHAR String,
    IN DWORD ValidChars
    )
{
    if (ValidChars > MaxValidCharacters) {
        return FALSE;
    }

    if (*String == '\0') {
        return TRUE; // a NULL string is valid
    }

    while (*String != '\0') {
        
        DWORD i;
        BOOL pass = FALSE;

        for (i=0; i<ValidChars; i++) {
            if (*String == ValidCharArray[i]) {
                pass = TRUE;
                break;
            }
        }
        
        if (!pass) {
            return FALSE;
        }
        String++; // look at next character

    }
    return TRUE;
}

BOOL
CmdHelpValidateStringHex(
    IN PCHAR String
    )
{
    return PrivateValidateString(String, MaxValidHexChars);
}

BOOL
CmdHelpValidateStringDecimal(
    IN PCHAR String
    )
{
    return PrivateValidateString(String, MaxValidDecimalHexChars);
}

BOOL
CmdHelpValidateStringOctal(
    IN PCHAR String
    )
{
    return PrivateValidateString(String, MaxValidOctalChars);
}         

BOOL
CmdHelpValidateStringHexQuoted(
    IN PCHAR String
    )
{
    DWORD i;

    if (!PrivateValidateString(String, MaxValidHexChars)) return FALSE;
    
    i=1;
    while (*String != '\0') {
        
        if ((*String == ' ') &&  (i%3)) return FALSE;
        if ((*String != ' ') && !(i%3)) return FALSE;
        i++;      // use next index
        String++; // go to next character

    }
    return TRUE;
}

BOOLEAN
CmdHelpScanQuotedHexString(
    IN  PUCHAR QuotedHexString,
    OUT PUCHAR Data,
    OUT PDWORD DataSize
    )
{
    PUCHAR temp;
    DWORD  availableSize;
    DWORD  requiredSize;
    DWORD  index;

    availableSize = *DataSize;
    *DataSize = 0;

    if (!CmdHelpValidateStringHexQuoted(QuotedHexString)) {
        return FALSE;
    }

    //
    // the number format is (number)(number)(space) repeated,
    // ending with (number)(number)(null)
    // size = 3(n-1) + 2 chars
    //

    requiredSize = strlen(QuotedHexString);
    if (requiredSize % 3 != 2) {
        return FALSE;
    }
        
    requiredSize /= 3;
    requiredSize ++;

    //
    // cannot set zero bytes of data
    //

    if (requiredSize == 0) {
        return FALSE;
    }

    //
    // validate that we have enough space
    //

    if (requiredSize > availableSize) {
        *DataSize = requiredSize;
        return FALSE;
    }

    //
    // the number format is (number)(number)(space) repeated,
    // ending with (number)(number)(null)
    //

    for (index = 0; index < requiredSize; index ++) {

        temp = QuotedHexString + (3*index);

        if (sscanf(temp, "%x", Data+index) != 1) {
            return FALSE;
        }

        if ((*(temp+0) == '\0') || (*(temp+1) == '\0')) {
            // string too short
            return FALSE;
        }

    }
    
    *DataSize = requiredSize;
    return TRUE;
}

VOID
CmdHelpUpdatePercentageDisplay(
    IN ULONG Numerator,
    IN ULONG Denominator
    )
{
    ULONG percent;
    ULONG i;

    if (Numerator > Denominator) {
        return;
    }

    // NOTE: Overflow possibility exists for large numerators.

    percent = (Numerator * 100) / Denominator;

    for (i=0;i<80;i++) {
        putchar('\b');
    }
    printf("Complete: ");
    
    // each block is 2%
    // ----=----1----=----2----=----3----=----4----=----5----=----6----=----7----=----8
    // Complete: .....................

    for (i=1; i<100; i+=2) {
        if (i < percent) {
            putchar(178);
        } else if (i == percent) {
            putchar(177);
        } else {
            putchar(176);
        }
    }

    printf(" %d%% (%x/%x)", percent, Numerator, Denominator);
}

VOID
CmdHelpPrintBuffer(
    IN  PUCHAR Buffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;

    while (Size > 0x10) {
        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "\n",
                offset,
                *(Buffer +  0), *(Buffer +  1), *(Buffer +  2), *(Buffer +  3),
                *(Buffer +  4), *(Buffer +  5), *(Buffer +  6), *(Buffer +  7),
                *(Buffer +  8), *(Buffer +  9), *(Buffer + 10), *(Buffer + 11),
                *(Buffer + 12), *(Buffer + 13), *(Buffer + 14), *(Buffer + 15)
                );
        Size -= 0x10;
        offset += 0x10;
        Buffer += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *Buffer);
            spaceIt++;
            Buffer++;
        }
        printf("\n");

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\cdp\cdp.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cdp.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

//
// this module may be compiled at warning level 4 with the following
// warnings disabled:
//

#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int


#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#include <assert.h>

#include <windows.h>
#include <devioctl.h>

#include <ntddscsi.h>

#include <ntddstor.h>
#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddcdvd.h>
#include <ntddmmc.h>

#define _NTSRB_     // to keep srb.h from being included
#include <scsi.h>
#include "sptlib.h"
#include "cmdhelp.h"

#define MAX_IOCTL_INPUT_SIZE  0x040
#define MAX_IOCTL_OUTPUT_SIZE 0x930  // IOCTL_CDROM_RAW_READ is this large
#define MAX_IOCTL_BUFFER_SIZE (max(MAX_IOCTL_INPUT_SIZE, MAX_IOCTL_OUTPUT_SIZE))
// read no more than 64k at a time -- lots of things just don't support it.
#define MAX_READ_SIZE (64 * 1024)



#ifdef DBG
#define dbg(x) x
#define HELP_ME() fprintf(stderr, "Reached line %4d\n", __LINE__)
#else
#define dbg(x)    /* x */
#define HELP_ME() /* printf("Reached line %4d\n", __LINE__) */
#endif

#define ARGUMENT_USED(x)    (x == NULL)

typedef struct {
    char *Name;
    char *Description;
    DWORD (*Function)(HANDLE device, int argc, char *argv[]);
} COMMAND;

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    char                SenseInfoBuffer[18];
    char                DataBuffer[0];          // Allocate buffer space
                                                // after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;

////////////////////////////////////////////////////////////////////////////////
#pragma pack(push, 1)
#define MODE_PAGE_MRW          0x2C // cdrom
typedef struct _MRW_MODE_PAGE {
    UCHAR PageCode : 6;     // 0x2C
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // 0x06         // offset 1
    UCHAR Reserved1;                        // offset 2
    
    UCHAR UseGAA    : 1;
    UCHAR Reserved2 : 7;                    // offset 3

    UCHAR Reserved3[4];                     // offset 4-7
} MRW_MODE_PAGE, *PMRW_MODE_PAGE;
C_ASSERT(sizeof(MRW_MODE_PAGE) == 8);
#pragma pack(pop)
////////////////////////////////////////////////////////////////////////////////

#define LBA_TO_MSF(Lba,Minutes,Seconds,Frames)               \
{                                                            \
    (Minutes) = (UCHAR)(Lba  / (60 * 75));                   \
    (Seconds) = (UCHAR)((Lba % (60 * 75)) / 75);             \
    (Frames)  = (UCHAR)((Lba % (60 * 75)) % 75);             \
}

DWORD ShowMrwProgressCommand(HANDLE device, int argc, char *argv[]);
DWORD FormatMrwCommand(HANDLE device, int argc, char *argv[]);
DWORD DvdReadStructure(HANDLE device, int argc, char *argv[]);
DWORD StartStopCommand(HANDLE device, int argc, char *argv[]);
DWORD TestCommand(HANDLE device, int argc, char *argv[]);
DWORD ReadTOCCommand(HANDLE device, int argc, char *argv[]);
DWORD ReadTOCExCommand(HANDLE device, int argc, char *argv[]);
DWORD ReadCdTextCommand(HANDLE device, int argc, char *argv[]);
DWORD PlayCommand(HANDLE device, int argc, char *argv[]);
DWORD PauseResumeCommand(HANDLE device, int argc, char *argv[]);
DWORD SendCommand(HANDLE device, int argc, char *argv[]);
DWORD IoctlCommand(HANDLE device, int argc, char *argv[]);
DWORD ListCommand(HANDLE device, int argc, char *argv[]);
DWORD DiskGetPartitionInfo( HANDLE device, int argc, char *argv[]);
DWORD FormatErrorCommand(HANDLE device, int argc, char *argv[]);
DWORD ImageDiskCommand(HANDLE device, int argc, char *argv[]);
DWORD MrwInitTestPatternCommand(HANDLE device, int argc, char *argv[]);

//
// List of commands
// all command names are case sensitive
// arguments are passed into command routines
// list must be terminated with NULL command
// command will not be listed in help if description == NULL
//

COMMAND CommandArray[] = {
    {"cdtext", "read cd text info", ReadCdTextCommand},
    {"dvdstruct", "Reads a dvd structure from the drive", DvdReadStructure},
    {"eject", "spins down and ejects the specified drive", StartStopCommand},
    {"error", "provides the error text for a winerror",  FormatErrorCommand},
    {"help", "help for all commands", ListCommand},
    {"ioctl", "ioctl [quoted hex input] [output] sends an arbitrary ioctl", IoctlCommand},
    {"image", "<file>  images the storage device into the file", ImageDiskCommand},
    {"load", "loads the specified drive", StartStopCommand},
    {"mrwformat", NULL, FormatMrwCommand},
    {"mrwprogress", NULL, ShowMrwProgressCommand},
    {"mrwtest", NULL, MrwInitTestPatternCommand},
    {"partition", "reads partition information", DiskGetPartitionInfo},
    {"pause", "pauses audio playback", PauseResumeCommand},
    {"play", "[start track [end track]] plays audio tracks [", PlayCommand},
    {"resume", "resumes paused audio playback", PauseResumeCommand},
    {"send", NULL, SendCommand},
    {"start", "spins up the drive", StartStopCommand},
    {"stop", "spinds down the drive", StartStopCommand},
    {"test", NULL, TestCommand},
    {"toc", "prints the table of contents", ReadTOCCommand},
    {"tocex", NULL, ReadTOCExCommand},
//    {"tocex", "[Format [Session/Track [MSF]]] Read toc/cdtext/atip/etc.", ReadTOCExCommand},
    {NULL, NULL, NULL}
    };

#define STATUS_SUCCESS 0

VOID PrintChar( IN UCHAR Char ) {

    if ( (Char >= 0x21) && (Char <= 0x7E) ) {
        printf("%c", Char);
    } else {
        printf("%c", '.');
    }

}

VOID UpdatePercentageDisplay(IN ULONG Numerator, IN ULONG Denominator) {

    ULONG percent;
    ULONG i;

    if (Numerator > Denominator) {
        return;
    }

    // NOTE: Overflow possibility exists for large numerators.
    
    percent = (Numerator * 100) / Denominator;

    for (i=0;i<80;i++) {
        putchar('\b');
    }
    printf("Complete: ");
    
    // each block is 2%
    // ----=----1----=----2----=----3----=----4----=----5----=----6----=----7----=----8
    // Complete: .....................

    for (i=1; i<100; i+=2) {
        if (i < percent) {
            putchar(178);
        } else if (i == percent) {
            putchar(177);
        } else {
            putchar(176);
        }
    }

    printf(" %d%% (%x/%x)", percent, Numerator, Denominator);
}

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE h;
    char buffer[32];

    if(argc < 3) {
        printf("Usage: cdp <drive> <command> [parameters]\n");
        printf("possible commands: \n");
        ListCommand(NULL, argc, argv);
        printf("\n");
        return -1;
    }

    sprintf(buffer, "\\\\.\\%s", argv[1]);
    dbg(printf("Sending command %s to drive %s\n", argv[2], buffer));

    h = CreateFile(buffer,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_ATTRIBUTE_NORMAL,
                   NULL);

    if(h == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    //
    // Iterate through the command array and find the correct function to
    // call.
    //

    while(CommandArray[i].Name != NULL) {

        if(strcmp(argv[2], CommandArray[i].Name) == 0) {

            (CommandArray[i].Function)(h, (argc - 2), &(argv[2]));

            break;
        }

        i++;
    }

    if(CommandArray[i].Name == NULL) {
        printf("Unknown command %s\n", argv[2]);
    }

    CloseHandle(h);

    return 0;
}

//
// take a PVOID as input -- it's cleaner throughout
//
VOID
PrintBuffer(
    IN  PVOID  InputBuffer,
    IN  SIZE_T Size
    )
{
    DWORD offset = 0;
    PUCHAR buffer = InputBuffer;

    while (Size >= 0x10) {
        
        DWORD i;

        printf( "%08x:"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  %02x %02x %02x %02x %02x %02x %02x %02x"
                "  ",
                offset,
                *(buffer +  0), *(buffer +  1), *(buffer +  2), *(buffer +  3),
                *(buffer +  4), *(buffer +  5), *(buffer +  6), *(buffer +  7),
                *(buffer +  8), *(buffer +  9), *(buffer + 10), *(buffer + 11),
                *(buffer + 12), *(buffer + 13), *(buffer + 14), *(buffer + 15)
                );

        for (i=0; i < 0x10; i++) {
            PrintChar(*(buffer+i));
        }
        printf("\n");


        Size -= 0x10;
        offset += 0x10;
        buffer += 0x10;
    }

    if (Size != 0) {

        DWORD i;

        printf("%08x:", offset);

        //
        // print the hex values
        //
        for (i=0; i<Size; i++) {

            if ((i%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *(buffer+i));

        }
        //
        // fill in the blanks
        //
        for (; i < 0x10; i++) {
            printf("   ");
        }
        printf("  ");
        //
        // print the ascii
        //
        for (i=0; i<Size; i++) {
            PrintChar(*(buffer+i));
        }
        printf("\n");
    }
    return;
}

DWORD StartStopCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a startstop command.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv[0] - "eject", "load", "start" or "stop"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;
    DWORD bufferSize;
    CDB cdb;

    UCHAR loadEject = 0;
    UCHAR start = 0;

    UNREFERENCED_PARAMETER(argc);

    if(strcmp("eject", argv[0]) == 0)  {
        loadEject = 1;
        start = 0;
    } else if(strcmp("load", argv[0]) == 0) {
        loadEject = 1;
        start = 1;
    } else if(strcmp("start", argv[0]) == 0) {
        loadEject = 0;
        start = 1;
    } else if(strcmp("stop", argv[0]) == 0) {
        loadEject = 0;
        start = 0;
    } else {
        assert(0);
    }

    memset(&cdb, 0, sizeof(CDB));
    cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb.START_STOP.Immediate     = 0;
    cdb.START_STOP.Start         = start;
    cdb.START_STOP.LoadEject     = loadEject;

    bufferSize = 0;


    if (!SptSendCdbToDevice(device, &cdb, 6, NULL, &bufferSize, FALSE)) {
        errorValue = GetLastError();
        printf("Eject - error sending IOCTL (%d)\n", errorValue);
    }
    return errorValue;
}

DWORD ReadCdTextCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents,
    ATIP, PMA, or CDTEXT data

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  (1-4 is valid)

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD returned;
    LONG bufferSize = 4; // to get the header
    DWORD i;

    CDROM_READ_TOC_EX params;
    BOOLEAN isText = TRUE;
    PUCHAR buffer = NULL;

    UNREFERENCED_PARAMETER(argv);

    if (argc > 3) {
        printf("Too many args\n");
        return 1;
    }

    //
    // set defaults - FORMAT_TOC, 0, 0
    //

    RtlZeroMemory(&params, sizeof(CDROM_READ_TOC_EX));

    params.Msf = 0;
    params.SessionTrack = 1;
    params.Format = 5;

    if(argc > 1) params.SessionTrack = (char)atoi(argv[1]);

    printf("Session = 0x%x\n", params.SessionTrack);

    for (i = 0; i < 2; i++) {

        if (i != 0) {
            LocalFree(buffer);
        }
        buffer = LocalAlloc(LPTR, bufferSize);

        if (buffer == NULL) {
            printf("No Memory %d\n", __LINE__);
            return 1;
        }

        returned = 0;
        if (!DeviceIoControl(device,
                             IOCTL_CDROM_READ_TOC_EX,
                             &params,
                             sizeof(CDROM_READ_TOC_EX),
                             buffer,
                             bufferSize,
                             &returned,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            LocalFree(buffer);
            printf("Eject - error sending IOCTL (%d)\n", errorValue);
            return errorValue;
        }
        bufferSize = (buffer[0] << 8) | (buffer[1]);
        bufferSize += 2;
    }

    if (argc > 2) {
        //
        // this block is for debugging the various idiosynchracies found
        // in CD-TEXT discs. Many discs encode multiple tracks in a single
        // block.  ie. if one song is called "ABBA", the second "Baby", and
        // the third "Longer Name", the Text portion would be encoded as:
        //     Track 1  'ABBA\0Baby\0Lo'
        //     Track 3  'nger Name\0'
        // This effectively "skips" the name available for Track 2 ?!
        // How to work around this....
        //

        {
            HANDLE h;
            DWORD temp;
            h = CreateFile("OUTPUT.TXT",
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_NEW,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);

            if(h == INVALID_HANDLE_VALUE) {
                printf("Error %d creating new file \"OUTPUT.TXT\"\n",
                       GetLastError());
                LocalFree(buffer);
                return GetLastError();
            }
            if (!WriteFile(h, buffer, bufferSize, &temp, NULL)) {
                printf("Error %d writing file to disk\n", GetLastError());
                LocalFree(buffer);
                return GetLastError();
            }
            // continue to output to screen....
        }

        for (i=0;
             FIELD_OFFSET(CDROM_TOC_CD_TEXT_DATA, Descriptors[i+1]) < bufferSize;
             i++) {

            PCDROM_TOC_CD_TEXT_DATA_BLOCK block;
            PCDROM_TOC_CD_TEXT_DATA_BLOCK prevBlock;
            DWORD j;

            block = (PCDROM_TOC_CD_TEXT_DATA_BLOCK)(buffer + 4);
            block += i;
            prevBlock = block - 1;

            if (block->Unicode) {
                continue; // ignore unicode -- this is examplary only
            }

            for (j=0;j<12;j++) {
                // replace NULLs with *, Tabs with hashes
                if (block->Text[j] == 0) block->Text[j] = '*';
                if (block->Text[j] == 9) block->Text[j] = '#';
            }

            if (block->SequenceNumber > 0x2b &&
                block->SequenceNumber < 0x32) {

                UCHAR text[13];
                RtlZeroMemory(text, 13);
                RtlCopyMemory(text, block->Text, 12);

                printf("PackType %02x  TrackNo %02x  ExtensionFlag %d\n"
                       "Sequence Number %02x       CharacterPosition %02x\n"
                       "Text: \"%s\"\n\n",
                       block->PackType,
                       block->TrackNumber,
                       block->ExtensionFlag,
                       block->SequenceNumber,
                       block->CharacterPosition,
                       text
                       );

            }
        }
        printf("\n");

    } else {

        for (i=0;
             FIELD_OFFSET(CDROM_TOC_CD_TEXT_DATA, Descriptors[i+1]) < bufferSize;
             i++) {

            PCDROM_TOC_CD_TEXT_DATA_BLOCK block;
            PCDROM_TOC_CD_TEXT_DATA_BLOCK prevBlock;
            DWORD j;

            block = (PCDROM_TOC_CD_TEXT_DATA_BLOCK)(buffer + 4);
            block += i;
            prevBlock = block - 1;

            if (block->Unicode) {
                continue; // ignore unicode -- this is examplary only
            }

            //
            // set the CRC's to zero so we can hack the data inside to more
            // easily handle wierd cases....
            //

            block->CRC[0] = block->CRC[1] = 0;

            //
            // set the tab characters to '*' for now.
            // i have not yet seen one using this "feature" of cd-text
            //

            for (j=0;j<12;j++) {
                if (block->Text[j] == 9) {
                    block->Text[j] = '*';
                }
            }


            if ((i != 0) &&
                (prevBlock->PackType    == block->PackType) &&
                (prevBlock->TrackNumber == block->TrackNumber)
                ) {

                // continuation of previous setting.

            } else
            if ((!(block->ExtensionFlag)) &&
                (block->TrackNumber != 0) &&
                (block->TrackNumber == (prevBlock->TrackNumber + 2)) &&
                (block->PackType    == prevBlock->PackType)
                ) {

                UCHAR *goodText;
                UCHAR *midText;
//                printf("\"\n\"HACK DETECTED! (seq %x & %x)",
//                       prevBlock->SequenceNumber, block->SequenceNumber);

                // hack for when prevBlock has two names encoded....
                // the TrackNumber/PackType are already equal, just
                // move the middle string to the start.

                midText = prevBlock->Text;
                while (*midText != '\0') {
                    midText++;
                }
                midText++;

                goodText = prevBlock->Text;
                while (*midText != '\0') {
                    *goodText++ = *midText++;
                }
                *goodText = '\0';
//                printf(" %s", prevBlock->Text);

                prevBlock->CharacterPosition = 0;
                prevBlock->TrackNumber++;
                prevBlock->ExtensionFlag = 1;
                i-= 2;
                continue; // re-run the previous, modified block

            } else {

                printf("\"\n");
                switch (block->PackType) {
                case CDROM_CD_TEXT_PACK_ALBUM_NAME: {
                    if (block->TrackNumber == 0) {
                        printf("%-12s", "Album Name");
                        printf("    : \"");
                    } else {
                        printf("%-12s", "Track Name");
                        printf("(%02d): \"", block->TrackNumber);
                    }
                    break;
                }
                case CDROM_CD_TEXT_PACK_PERFORMER: {
                    printf("%-12s", "Performer");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_SONGWRITER: {
                    printf("%-12s", "Songwriter");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_COMPOSER: {
                    printf("%-12s", "Composer");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_ARRANGER: {
                    printf("%-12s", "Arranger");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_MESSAGES: {
                    printf("%-12s", "Messages");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_DISC_ID: {
                    printf("%-12s", "Disc ID");
                    printf("    : \"");
                    break;
                }
                case CDROM_CD_TEXT_PACK_GENRE: {
                    printf("%-12s", "Genre");
                    printf("(%02d): \"", block->TrackNumber);
                    break;
                }
                case CDROM_CD_TEXT_PACK_UPC_EAN: {
                    if (block->TrackNumber == 0) {
                        printf("%-12s", "UPC/EAN");
                        printf("    : \"");
                    } else {
                        printf("%-12s", "ISRC");
                        printf("(%02d): \"", block->TrackNumber);
                    }
                    break;
                }
                case CDROM_CD_TEXT_PACK_TOC_INFO:
                case CDROM_CD_TEXT_PACK_TOC_INFO2:
                case CDROM_CD_TEXT_PACK_SIZE_INFO:
                default: {
                    isText = FALSE;
                    printf("Unknown type 0x%x: \"", block->PackType);
                }
                } // end switch

                //
                // have to print previous block's info, if available
                //

                if (isText && block->CharacterPosition != 0) {
                    UCHAR text[13];
                    RtlZeroMemory(text, sizeof(text));
                    RtlCopyMemory(text,
                                  prevBlock->Text + 12 - block->CharacterPosition,
                                  block->CharacterPosition * sizeof(UCHAR));
                    printf("%s", text);
                }


            } // end continuation case

            if (isText) {
                UCHAR text[13];
                RtlZeroMemory(text, sizeof(text));
                RtlCopyMemory(text, block->Text, 12);
                printf("%s", text);
            }

        } // end loop through all blocks
        printf("\n");

    } // end normal printout case

    return 0;
}

DWORD ReadTOCExCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents,
    ATIP, PMA, or CDTEXT data

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  (1-4 is valid)

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD returned;
    DWORD bufferSize = 4; // to get the header
    DWORD i;

    CDROM_READ_TOC_EX params;

    UNREFERENCED_PARAMETER(argv);

    if (argc > 4) {
        printf("Too many args\n");
        return 1;
    }

    //
    // set defaults - FORMAT_TOC, 0, 0
    //

    RtlZeroMemory(&params, sizeof(CDROM_READ_TOC_EX));

    if(argc > 3) params.Msf          = (char)atoi(argv[3]);
    if(argc > 2) params.SessionTrack = (char)atoi(argv[2]);
    if(argc > 1) params.Format       = (char)atoi(argv[1]);

    printf("Params.Format       = 0x%x\n", params.Format);
    printf("Params.SessionTrack = 0x%x\n", params.SessionTrack);
    printf("Params.MSF          = 0x%x\n", params.Msf);

    for (i = 0; i < 2; i++) {

        PUCHAR buffer = LocalAlloc(LPTR, bufferSize);

        if (buffer == NULL) {
            printf("No Memory %d\n", __LINE__);
            return 1;
        }

        returned = 0;
        if (!DeviceIoControl(device,
                             IOCTL_CDROM_READ_TOC_EX,
                             &params,
                             sizeof(CDROM_READ_TOC_EX),
                             buffer,
                             bufferSize,
                             &returned,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            LocalFree(buffer);
            printf("Eject - error sending IOCTL (%d)\n", errorValue);
            return errorValue;
        }

        printf("Successfully got %x bytes:\n", returned);
        PrintBuffer(buffer, returned);

        bufferSize = (buffer[0] << 8) | (buffer[1]);
        LocalFree(buffer);
        bufferSize += 2;
        printf("Now getting %x bytes:\n", bufferSize);

    }
    return 0;
}

DWORD ReadTOCCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Reads and prints out the cdrom's table of contents

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;
    DWORD returned = 0;
    CDB cdb;
    CDROM_TOC toc;

    int numTracks, i;
    PTRACK_DATA track;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    printf("Reading Table of Contents\n");

    //
    // Get the 4 byte TOC header
    //

    returned = FIELD_OFFSET(CDROM_TOC, TrackData[0]);
    memset(&cdb, 0, sizeof(CDB));
    cdb.READ_TOC.OperationCode = SCSIOP_READ_TOC;
    cdb.READ_TOC.Msf = 0;
    cdb.READ_TOC.StartingTrack = 0;
    cdb.READ_TOC.AllocationLength[0] = (UCHAR)(returned >> 8);
    cdb.READ_TOC.AllocationLength[1] = (UCHAR)(returned & 0xff);


    if (!SptSendCdbToDevice(device, &cdb, 10, (PUCHAR)&toc, &returned, TRUE)) {
        errorValue = GetLastError();
        printf("Error %d sending READ_TOC pass through\n", errorValue);
        return errorValue;
    }

    dbg(printf("READ_TOC pass through returned %d bytes\n", returned));
    numTracks = toc.LastTrack - toc.FirstTrack + 1;
    dbg(printf("Getting %d tracks\n", numTracks));


    returned =
        FIELD_OFFSET(CDROM_TOC, TrackData[0]) +
        (numTracks * sizeof(TRACK_DATA));

    memset(&cdb, 0, sizeof(CDB));
    cdb.READ_TOC.OperationCode = SCSIOP_READ_TOC;
    cdb.READ_TOC.Msf = 0;
    cdb.READ_TOC.StartingTrack = 1;
    cdb.READ_TOC.AllocationLength[0] = (UCHAR)(returned >> 8);
    cdb.READ_TOC.AllocationLength[1] = (UCHAR)(returned & 0xff);

    if (!SptSendCdbToDevice(device, &cdb, 10, (PUCHAR)&toc, &returned, TRUE)) {
        errorValue = GetLastError();
        printf("Error %d sending READ_TOC pass through\n", errorValue);
        return errorValue;
    }

    dbg(printf("READ_TOC pass through returned %d bytes\n", returned));

    printf("TOC Data Length: %d\n", (toc.Length[0] << 16) | (toc.Length[1]));

    printf("First Track Number: %d\n", toc.FirstTrack);
    printf("Last Track Number: %d\n", toc.LastTrack);


    track = &(toc.TrackData[0]);

    printf("Number    ADR  Control    Address (LBA)\n");
    printf("------    ---  -------    -------------\n");

    for(i = 0; i < numTracks; i++) {

        DWORD lba =
            (track->Address[0] << 24) |
            (track->Address[1] << 16) |
            (track->Address[2] <<  8) |
            (track->Address[3] <<  0);
        UCHAR m,s,f;
        LBA_TO_MSF(lba, m, s, f);

        printf("%6d    %3d  %7d      %3d:%02d:%02d\n",
               track->TrackNumber, track->Adr, track->Control,
               m,s,f);

        track++;
    }
    return errorValue;
}

DWORD PlayCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Plays an audio track

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[1] - the starting track.  Starts at zero if this is not here
    argv[2] - the ending track.  Let track if not specified

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(device);
    printf("This command is not implemented\n");
    return 1;
}

DWORD PauseResumeCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    pauses or resumes audio playback

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.

    argv[0] - "pause" or "resume"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;
    CDB cdb;

    char resume;

    UNREFERENCED_PARAMETER(argc);

    if(strcmp("pause", argv[0]) == 0) {
        resume = 0;
    } else {
        resume = 1;
    }

    printf("%s cdrom playback\n", (resume ? "Resuming" : "Pausing"));

    //
    // Unfortunately no one defined the PLAY_INDEX command for us so
    // cheat and use MSF
    //

    memset(&cdb, 0, sizeof(CDB));
    cdb.PAUSE_RESUME.OperationCode = SCSIOP_PAUSE_RESUME;
    cdb.PAUSE_RESUME.Action = resume;

    if (!SptSendCdbToDevice(device, &cdb, 10, NULL, 0, FALSE)) {
        errorValue = GetLastError();
        printf("Error %d sending PAUSE_RESUME pass through\n", errorValue);
        return errorValue;
    }

//    dbg(printf("PAUSE_RESUME pass through returned %d bytes\n", returned));

    return errorValue;
}
DWORD ImageDiskCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    creates an image of the device by reading from sector 0 to N.

Arguments:
    
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be 2.

    argv[1] - the file to output to

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{

    HANDLE file;
    PUCHAR buffer;
    READ_CAPACITY_DATA capacityData;
    ULONG   dataSize;    
    CDB    cdb;

    ULONG   sectorsPerMaxRead;
    ULONG   currentSector;



    if(argc < 2) {
        printf("not correct number of args\n");
        return -1;
    }

    printf("Opening file %s\n", argv[1]);

    file = CreateFile(argv[1],
                      GENERIC_WRITE,
                      0,
                      NULL,
                      CREATE_NEW,
                      FILE_FLAG_SEQUENTIAL_SCAN,
                      NULL);

    if (file == INVALID_HANDLE_VALUE) {
        printf("Error %d creating file %s\n", GetLastError(), argv[1]);
        return -2;
    }

    // read the sector size from the device
    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&capacityData, sizeof(READ_CAPACITY_DATA));
    cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;
    dataSize = sizeof(READ_CAPACITY_DATA);

    if (!SptSendCdbToDevice(device, &cdb, 10, (PUCHAR)&capacityData, &dataSize, TRUE)) {
        printf("Error %d getting capacity info\n", GetLastError());
        return -3;
    }
    // convert the numbers
    PrintBuffer(&capacityData, sizeof(READ_CAPACITY_DATA));
    REVERSE_LONG(&capacityData.BytesPerBlock);
    REVERSE_LONG(&capacityData.LogicalBlockAddress);
    if ( (MAX_READ_SIZE % capacityData.BytesPerBlock) != 0 ) {
        printf("Sector size of %x is not power of 2?!\n", capacityData.BytesPerBlock);
        // capacityData.BytesPerBlock = 512;
        return -5;
    }

    buffer = (PUCHAR)malloc(MAX_READ_SIZE);
    if (!buffer) {
        printf("Unable to alloc %x bytes\n", MAX_READ_SIZE);
        return -4;
    }
    sectorsPerMaxRead = MAX_READ_SIZE / capacityData.BytesPerBlock;


    // read the data from disk and dump to file
    for (currentSector = 0; currentSector < capacityData.LogicalBlockAddress; currentSector += sectorsPerMaxRead) {

        ULONG sectorsThisRead = sectorsPerMaxRead;

        UpdatePercentageDisplay(currentSector, capacityData.LogicalBlockAddress);
        if (currentSector > capacityData.LogicalBlockAddress - sectorsPerMaxRead) {
            sectorsThisRead = capacityData.LogicalBlockAddress - sectorsPerMaxRead;
        }

        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(buffer, MAX_READ_SIZE);

        cdb.CDB10.OperationCode     = SCSIOP_READ;
        cdb.CDB10.LogicalBlockByte0 = (UCHAR)(currentSector   >> (8*3));
        cdb.CDB10.LogicalBlockByte1 = (UCHAR)(currentSector   >> (8*2));
        cdb.CDB10.LogicalBlockByte2 = (UCHAR)(currentSector   >> (8*1));
        cdb.CDB10.LogicalBlockByte3 = (UCHAR)(currentSector   >> (8*0));
        cdb.CDB10.TransferBlocksMsb = (UCHAR)(sectorsThisRead >> (8*1));
        cdb.CDB10.TransferBlocksLsb = (UCHAR)(sectorsThisRead >> (8*0));

        dataSize = sectorsThisRead * capacityData.BytesPerBlock;
        if (!SptSendCdbToDevice(device, &cdb, 10, buffer, &dataSize, TRUE)) {
            printf("Error %d reading %x sectors starting at %x\n",
                   GetLastError(), sectorsThisRead, currentSector);
            free(buffer);
            return -6;
        }
        if (dataSize != sectorsThisRead * capacityData.BytesPerBlock) {
            printf("Only got %x of %x bytes reading %x sectors starting at %x\n",
                   dataSize, sectorsThisRead * capacityData.BytesPerBlock,
                   sectorsThisRead, currentSector);
            free(buffer);
            return -7;
        }
        
        dataSize = sectorsThisRead * capacityData.BytesPerBlock;
        if (!WriteFile(file, buffer, dataSize, &dataSize, NULL)) {
            printf("Error %d writing %x bytes starting at sector %x\n",
                   GetLastError(), dataSize, currentSector);
            free(buffer);
            return -8;
        }

        if (dataSize != sectorsThisRead * capacityData.BytesPerBlock) {
            printf("Only wrote %x of %x bytes writing %x sectors starting at %x\n",
                   dataSize, sectorsThisRead * capacityData.BytesPerBlock,
                   sectorsThisRead, currentSector);
            free(buffer);
            return -9;
        }
    }
    UpdatePercentageDisplay(currentSector, currentSector);
    free(buffer);
    printf("\nSuccess!\n");
    return 0;
}

DWORD SendCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Parses a hex byte string and creates a cdb to send down.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be 2 or 4

    argv[1] - The CDB to send in a quoted hex byte string
              "47 00 00 00 01 00 00 ff 00 00"

    argv[2] - "SET" or "GET"

    argv[3] - for GET commands: the number of bytes (decimal) to
              expect from the target
              for SET commands: a quoted hex byte string to send to
              the target

NOTE:
    Due to the potentially damaging nature of making sending an
    arbitrary SCSI command to an arbitrary device, this command should
    not be documented outside of this source code.

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DWORD errorValue = STATUS_SUCCESS;

    UCHAR cdbSize;
    CDB   cdb;
    
    DWORD setData = FALSE;
    PUCHAR returnedData = NULL;

    DWORD i;

    DWORD dataSize = 0;

////////////////////////////////////////////////////////////////////////////////
// verify the arguments
////////////////////////////////////////////////////////////////////////////////

    if ( argc == 4 ) {
        if (strcmp(argv[2], "get") != 0 &&
            strcmp(argv[2], "set") != 0 &&
            strcmp(argv[2], "GET") != 0 &&
            strcmp(argv[2], "SET") != 0 ) {
            printf("argv2 == %s\n", argv[2]);
            argc = 0; // this will cause help to print
        }
        if (strcmp(argv[2], "set") == 0 ||
            strcmp(argv[2], "SET") == 0 ) {
            setData = TRUE;
        }
    }


    if ( argc != 2 && argc != 4 ) {
        printf("requires one or three args:\n"
               "1)\tquoted hex string for cdb\n"
               "2)\t(optional) GET or SET\n"
               "3)\t(optional) GET: number of bytes to expect\n"
                 "\t(optional) SET: quoted hex string for cdb\n");

        printf("\n");
        printf("Example commands:\n"
               "Send STOP_UNIT to eject drive q:\n"
               "\tcdp q: send \"1b 00 00 00 02 00\"\n"
               "Get CDVD_CAPABILITIES_PAGE from drive q:\n"
               "\tcdp q: send \"5a 40 2a 00 00 00 00 00 1a 00\" get 21\n"
               );


        return 1;
    }

////////////////////////////////////////////////////////////////////////////////
// parse the arguments
////////////////////////////////////////////////////////////////////////////////


    if (!CmdHelpValidateStringHex(argv[1])) {
        printf("Hex string must be two (0-9,a-f) then one space (repeated)\n");
        return 1;
    }

    //
    // Determine the length of the CDB first
    // sscanf returns the number of things read in (ie. cdb size)
    //

    cdbSize = (UCHAR)sscanf(argv[1],
                            "%x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x",
                            cdb.AsByte +  0, cdb.AsByte +  1,
                            cdb.AsByte +  2, cdb.AsByte +  3,
                            cdb.AsByte +  4, cdb.AsByte +  5,
                            cdb.AsByte +  6, cdb.AsByte +  7,
                            cdb.AsByte +  8, cdb.AsByte +  9,
                            cdb.AsByte + 10, cdb.AsByte + 11,
                            cdb.AsByte + 12, cdb.AsByte + 13,
                            cdb.AsByte + 14, cdb.AsByte + 15
                            );

    //
    // now figure out how much memory we need to allocate
    //

    if (argc == 4) {

        if (setData) {

            if (!CmdHelpValidateStringHexQuoted(argv[3])) {
                printf("Hex string must be two (0-9,a-f) then one space (repeated)\n");
                return 1;
            }

            dataSize = strlen(argv[3]);

            if (dataSize % 3) {
                dataSize /= 3;
                dataSize ++;
            } else {
                dataSize /= 3;
            }

            if (dataSize == 0) {
                printf("Cannot set zero bytes of data\n");
                return 1;
            }

        } else {

            i = sscanf(argv[3], "%x", &dataSize);

            if (i != 1) {
                printf("Error scanning second argument\n");
                return 1;
            }

        }
    }

    //
    // allocate the memory we may need
    //

    if (dataSize != 0) {
        returnedData = (PUCHAR)malloc(dataSize);
        if (returnedData == NULL) {
            printf("Unable to allocate %x bytes for data\n", dataSize);
            return 1;
        }
        memset(returnedData, 0, dataSize);
    }

    //
    // now scan in the data to set, if that's what the user wants.
    // note that since it's already been validated, we can presume
    // the format is (number)(number)(space) repeated
    //

    if (setData) {
        ULONG index;
        PCHAR location = argv[3];

        for (index = 0; index < dataSize; index++) {

            if (sscanf(location, "%x", returnedData + index) != 1) {
                printf("sscanf did not return 1 for index %i\n", index);
                return 1;
            }

            if ((*location + 0 == '\0') ||
                (*location + 1 == '\0')) {
                printf("string too short!\n");
                return 1;
            }
            location += 3;

        }
    }



#if DBG
////////////////////////////////////////////////////////////////////////////////
// provide some user feedback
////////////////////////////////////////////////////////////////////////////////
    //
    // it is the amount of data expected back from the command
    //

    printf("\nSending %x byte Command:\n", cdbSize);
    PrintBuffer(cdb.AsByte, cdbSize);
    if (setData) {
        printf("Setting Buffer:\n");
        PrintBuffer(returnedData, dataSize);
    } else {
        printf("Expecting %#x bytes of data\n", dataSize);
    }
#endif // DBG

////////////////////////////////////////////////////////////////////////////////
// send the command
////////////////////////////////////////////////////////////////////////////////

    while (1) {

        UCHAR senseSize = sizeof(SENSE_DATA);
        SENSE_DATA senseData;
        BOOLEAN retry = FALSE;
        DWORD retryDelay = 0;

        if (!SptSendCdbToDeviceEx(device,
                                  &cdb,
                                  cdbSize,
                                  returnedData, &dataSize,
                                  &senseData, senseSize,
                                  (BOOLEAN)(setData ? FALSE : TRUE),
                                  SPT_DEFAULT_TIMEOUT)
            ) {

            errorValue = 0;
            if (senseSize == 0) {
                errorValue = GetLastError();
                if (errorValue == ERROR_SUCCESS) {
                    errorValue = ERROR_IO_DEVICE;
                }
            } else {
                printf("Sense Data: (%x bytes) Sense %x  ASC %x  ASCQ %x\n",
                       senseSize,
                       senseData.SenseKey & 0xf,
                       senseData.AdditionalSenseCode,
                       senseData.AdditionalSenseCodeQualifier);
                PrintBuffer(&senseData, senseSize);
                SptUtilInterpretSenseInfo(&senseData,
                                          senseSize,
                                          &errorValue,
                                          &retry,
                                          &retryDelay);
            }
            
            if (retry) {
                printf("Command should be retried in %d.%d seconds\n",
                       (retryDelay / 10), (retryDelay % 10));
                Sleep(retryDelay*10);
            } else {
                printf("Error %d sending command via pass through\n", errorValue);
                break;
            }
    
        }


        if (!setData) {
            printf("(%x bytes returned)\n",dataSize);
            PrintBuffer(returnedData, dataSize);
        } else {
            printf("Successfully sent the command\n");
        }

        break; // out of for loop
    
    }

    return errorValue;

}

DWORD TestCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Tests the command "parsing"

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv - the additional arguments

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{
    int i;

    UNREFERENCED_PARAMETER(device);

    printf("Test - %d additional arguments\n", argc);

    for(i = 0; i < argc; i++) {
        printf("arg %d: %s\n", i, argv[i]);
    }

    return STATUS_SUCCESS;
}

DWORD ListCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Prints out the command list

Arguments:
    device - unused

    argc - unused

    argv - unused

Return Value:

    STATUS_SUCCESS

--*/

{
    int i = 0;

    UNREFERENCED_PARAMETER(device);
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    while(CommandArray[i].Name != NULL) {

        if(CommandArray[i].Description != NULL) {

            printf("\t%s - %s\n",
                   CommandArray[i].Name,
                   CommandArray[i].Description);
        }

        i++;
    }

    return STATUS_SUCCESS;
}

DWORD DvdReadStructure(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a startstop command.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv[0] - "eject", "load", "start" or "stop"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    DVD_READ_STRUCTURE readStructure;
    PUCHAR buffer;
    PDVD_DESCRIPTOR_HEADER header;

    DWORD returned;
    DWORD errorValue = STATUS_SUCCESS;

    printf("argument count is %d\n", argc);

    if(argc <= 1) {
        printf("\tValid structure types are Physical, Copyright, DiskKey, "
               "BCA or Manufacturer\n");
        return STATUS_SUCCESS;
    }

    printf("Argv[1] = %s\n", argv[1]);

    buffer = malloc(sizeof(DVD_DISK_KEY_DESCRIPTOR) +
                    sizeof(DVD_DESCRIPTOR_HEADER));
    
    if (buffer == NULL) {
        printf("Insufficient memory\n");
        return STATUS_SUCCESS;
    }

    header = (PDVD_DESCRIPTOR_HEADER) buffer;

    if(_stricmp("physical", argv[1]) == 0)  {

        if(argc < 1) {

            printf("reading physical descriptor requires layer number\n");
            return STATUS_SUCCESS;
        }

        readStructure.Format = DvdPhysicalDescriptor;
        readStructure.LayerNumber = (UCHAR)atoi(argv[1]);

    } else if(_stricmp("copyright", argv[1]) == 0) {
        readStructure.Format = DvdCopyrightDescriptor;

    } else if(_stricmp("diskkey", argv[1]) == 0) {
        if(argc < 1) {

            printf("reading physical descriptor requires a session ID\n");
            return STATUS_SUCCESS;
        }

        readStructure.Format = DvdPhysicalDescriptor;
        readStructure.SessionId = atoi(argv[1]);

    } else if(_stricmp("bca", argv[1]) == 0) {
        readStructure.Format = DvdBCADescriptor;

    } else if(_stricmp("manufacturer", argv[1]) == 0) {
        readStructure.Format = DvdManufacturerDescriptor;

    } else {
        printf("\tValid structure types are Physical, Copyright, DiskKey, "
               "BCA or Manufacturer\n");
        return STATUS_SUCCESS;
    }

    returned = 0;

    if(!DeviceIoControl(device,
                        IOCTL_DVD_READ_STRUCTURE,
                        &readStructure,
                        sizeof(DVD_READ_STRUCTURE),
                        buffer,
                        sizeof(DVD_DISK_KEY_DESCRIPTOR),
                        &returned,
                        FALSE)) {

        errorValue = GetLastError();
        printf("Eject - error sending IOCTL (%d)\n", errorValue);
        return errorValue;
    }

    printf("DvdReadStructure returned %d bytes\n", returned);

    printf("Header Length is %#08lx\n", header->Length);

    printf("Header @ %p\n", header);

    printf("Data @ %p\n", &(header->Data[0]));

    if(_stricmp("physical", argv[1]) == 0)  {

        PDVD_LAYER_DESCRIPTOR layer = (PDVD_LAYER_DESCRIPTOR) ((PUCHAR) &(header->Data[0]));
        int i;

        printf("\tBook Version: %d\n", layer->BookVersion);
        printf("\tBook Type: %d\n", layer->BookType);
        printf("\tMinimumRate: %d\n", layer->MinimumRate);
        printf("\tDiskSize: %d\n", layer->DiskSize);
        printf("\tLayerType: %d\n", layer->LayerType);
        printf("\tTrackPath: %d\n", layer->TrackPath);
        printf("\tNumberOfLayers: %d\n", layer->NumberOfLayers);
        printf("\tTrackDensity: %d\n", layer->TrackDensity);
        printf("\tLinearDensity: %d\n", layer->LinearDensity);
        printf("\tStartingDataSector: %#08lx\n", layer->StartingDataSector);
        printf("\tEndDataSector: %#08lx\n", layer->EndDataSector);
        printf("\tEndLayerZeroSector: %#08lx\n", layer->EndLayerZeroSector);
        printf("\tBCAFlag: %d\n", layer->BCAFlag);

        printf("\n");

        for(i = 0; i < sizeof(DVD_LAYER_DESCRIPTOR); i++) {
            printf("byte %d: %#x\n", i, header->Data[i]);
        }

    } else if(_stricmp("copyright", argv[1]) == 0) {

    } else if(_stricmp("diskkey", argv[1]) == 0) {

    } else if(_stricmp("bca", argv[1]) == 0) {

    } else if(_stricmp("manufacturer", argv[1]) == 0) {

    }

    printf("final status %d\n", errorValue);

    return errorValue;
}

DWORD DiskGetPartitionInfo(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a startstop command.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be zero

    argv[0] - "eject", "load", "start" or "stop"

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    PARTITION_INFORMATION partitionInformation;

    DWORD returned;
    DWORD errorValue = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    returned = 0;

    if(!DeviceIoControl(device,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL,
                        0L,
                        &partitionInformation,
                        sizeof(PARTITION_INFORMATION),
                        &returned,
                        FALSE)) {

        errorValue = GetLastError();
        printf("Eject - error sending IOCTL (%d)\n", errorValue);
        return errorValue;
    }

    printf("IOCTL_DISK_GET_PARTITION_INFO returned %d bytes\n", returned);

    printf("Starting Offset = %#016I64x\n", partitionInformation.StartingOffset.QuadPart);
    printf("Partition Length = %#016I64x\n", partitionInformation.PartitionLength.QuadPart);
    printf("Hidden Sectors = %#08lx\n", partitionInformation.HiddenSectors);
    printf("PartitionNumber = %#08lx\n", partitionInformation.PartitionNumber);
    printf("PartitionType = %#08lx\n", partitionInformation.PartitionType);
    printf("BootIndicator = %s\n", partitionInformation.BootIndicator ? "TRUE" : "FALSE");
    printf("RecognizedPartition = %s\n", partitionInformation.RecognizedPartition ? "TRUE" : "FALSE");
    printf("RewritePartition = %s\n", partitionInformation.RewritePartition ? "TRUE" : "FALSE");

    return errorValue;
}

DWORD IoctlCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Sends down a specified ioctl.

Arguments:
    device - a file handle to send the ioctl to

    argc - the number of additional arguments.  should be two

    argv[0] - ioctl code in hexadecimal
    argv[1] - quoted string, bytes to send, "" if none
    argv[2] - number of bytes to get back [optional]

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/

{

    ULONG ctlCode = 0;
    ULONG returned;
    ULONG inputSize = 0;
    ULONG outputSize = 0;
    UCHAR buffer[MAX_IOCTL_BUFFER_SIZE];
    BOOLEAN get;


    if (argc < 3) { // n+1 -- require two args, accept three

        ctlCode = 0;

    } else if (!CmdHelpValidateStringHexQuoted(argv[2])) {

        printf("input hex string invalid\n");
        ctlCode = 0;

    } else {
        
        //
        // retrieve the ioctl
        //

        (void)sscanf(argv[1], "%x", &ctlCode);

    }
    
    if (argc > 3) { // n+1 -- require three args.
        (void)sscanf(argv[3], "%x", &outputSize);
        printf("output size: %x\n", outputSize);
    } else {
        outputSize = 0;
    }
    
    if (outputSize > MAX_IOCTL_OUTPUT_SIZE) {

        printf("output size too large\n");
        ctlCode = 0;

    }
    
    if (ctlCode == 0) {
        printf("args:\n"
               "1)\tioctl in hex\n"
               "2)\tquoted string of bytes to send, \"\" if none\n"
               "3)\tnumber of bytes to expect\n");
        return -1;
    }

    //////////////////////////////////////////////////////////////////////////
    // ioctl and args are valid.
    //

    RtlZeroMemory(buffer, sizeof(UCHAR)*MAX_IOCTL_BUFFER_SIZE);

    if (strlen(argv[2])) {
        inputSize = MAX_IOCTL_INPUT_SIZE;
        if (!CmdHelpScanQuotedHexString(argv[2], buffer, &inputSize)) {
            printf("Error scanning hex string\n");
            return -1;
        }
    } else {
        inputSize = 0;
    }

    // inputSize of zero is valid as input

    printf("Sending ioctl %x to device %p\n"
           "using input buffer %p of size %x\n"
           "and output buffer %p of size %x\n",
           ctlCode, device,
           ((inputSize == 0) ? NULL : buffer),
           inputSize,
           ((outputSize == 0) ? NULL : buffer),
           outputSize);


    if (!DeviceIoControl(device,
                         ctlCode,
                         ((inputSize == 0) ? NULL : buffer),
                         inputSize,
                         ((outputSize == 0) ? NULL : buffer),
                         outputSize,
                         &returned,
                         FALSE)) {
        printf("Failed with %d\n", GetLastError());
        return GetLastError();
    }

    if (returned != 0) {
        printf("Returned data (%x of %x bytes):\n", returned, outputSize);
        PrintBuffer(buffer, returned);    
    } else {
        printf("Command completed successfully\n");
    }

    return 0;
}

DWORD FormatErrorCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Gets and displays the message string associated with an error code.

Arguments:
    device - not used, but required :P

    argc - the number of additional arguments.  should be one

    argv[0] - error code in hexadecimal

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    LPVOID stringBuffer = NULL;
    DWORD errorCode = 0x80030306;
    DWORD numOfChars = 0;
    DWORD flags;

    flags = 0;
    flags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;
    flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    flags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    
    numOfChars = FormatMessageA(flags,
                                NULL,
                                errorCode,
                                0, // language indifferent
                                (LPSTR)&stringBuffer, // double pointer
                                0,
                                NULL
                                );

    if (stringBuffer == NULL) {
        printf("No buffer returned?\n");
        return -1;
    }

    if (numOfChars == 0) {
        printf("Size zero buffer returned?\n");
        return -1;
    }

    printf("ERROR MESSAGE RETURNED:\n");
    printf("%s\n", stringBuffer);

    LocalFree(stringBuffer);
    return 0;
}

DWORD FormatMrwCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Formats an MRW-Compliant drive and shows percentage complete

Arguments:
    
    device - drive to format media as MRW in

    argc - the number of additional arguments.  should be zero

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{

#define MRW_FORMAT_BUFFER_SIZE 0xc
    
    CDB cdb;
    ULONG size = MRW_FORMAT_BUFFER_SIZE;
    UCHAR formatBuffer[MRW_FORMAT_BUFFER_SIZE];

    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(formatBuffer, size);
    
    cdb.CDB6FORMAT.OperationCode = SCSIOP_FORMAT_UNIT;
    cdb.CDB6FORMAT.FormatControl = 0x11;

    //formatBuffer[0x0] = 0x00;
    formatBuffer[0x1] = 0x82;
    //formatBuffer[0x2] = 0x00;
    formatBuffer[0x3] = 0x08;
    formatBuffer[0x4] = 0xff; //---vvv
    formatBuffer[0x5] = 0xff; //   NumberOfBlocks must be set to 0xffffffff
    formatBuffer[0x6] = 0xff; //
    formatBuffer[0x7] = 0xff; //--^^^^
    formatBuffer[0x8] = 0x90;
    //formatBuffer[0x9] = 0x00;
    //formatBuffer[0xa] = 0x00;
    //formatBuffer[0xb] = 0x00;

    if (!SptSendCdbToDevice(device,
                            &cdb,
                            6,
                            formatBuffer,
                            &size,
                            FALSE)) {
        printf("Unable to format, %x\n", GetLastError());
        return -1;
    }
    
    return ShowMrwProgressCommand(device, argc, argv);
}

DWORD ShowMrwProgressCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Formats an MRW-Compliant drive and shows percentage complete

Arguments:
    
    device - drive to format media as MRW in

    argc - the number of additional arguments.  should be zero

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{    
    CDB cdb;
    SENSE_DATA sense;
    ULONG size;
    ULONG ignoredLoopCount = 0;

    //
    // loop, displaying percentage done.
    //

    ignoredLoopCount = 0;
    while (1) {

        Sleep(100);
        
        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(&sense, sizeof(SENSE_DATA));

        size = sizeof(SENSE_DATA);

        cdb.AsByte[0] = SCSIOP_REQUEST_SENSE;
        cdb.AsByte[4] = (UCHAR)(sizeof(SENSE_DATA));

        if (!SptSendCdbToDevice(device,
                                &cdb,
                                6,
                                (PUCHAR)&sense,
                                &size,
                                TRUE)) {
            printf("\nUnable to get percentage done! %x\n", GetLastError());
            return -1;
        }

        if (sense.AdditionalSenseCode == SCSI_ADSENSE_LUN_NOT_READY &&
            sense.AdditionalSenseCodeQualifier == SCSI_SENSEQ_FORMAT_IN_PROGRESS &&
            (sense.SenseKeySpecific[0] & 0x80)
            ) {
            
            ULONG done;
            done =
                ((sense.SenseKeySpecific[0] & 0x7f) << (8*2)) |
                ((sense.SenseKeySpecific[1] & 0xff) << (8*1)) |
                ((sense.SenseKeySpecific[2] & 0xff) << (8*0)) ;
            UpdatePercentageDisplay(done, 0x10000);

        } else {
            
            ignoredLoopCount++;
            if (ignoredLoopCount > 12) {
                printf("\nSenseData not as expected.  Format may have completed?\n");
                return -1;
            }
            // else let it go on
        }

    }

}


BOOLEAN
ModeSelect(
    HANDLE Device,
    PVOID  ModePage,
    ULONG  ModePageSize
    )
{
    CDB cdb;
    ULONG tmp;
    ULONG size;
    PMODE_PARAMETER_HEADER10 header;

    tmp = sizeof(MODE_PARAMETER_HEADER10) + ModePageSize;

    header = malloc(tmp);
    if (header == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    RtlCopyMemory(header+1, // pointer math
                  ModePage,
                  ModePageSize);


    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
    cdb.MODE_SELECT10.PFBit = 1;
    cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR)(tmp >> (8*1));
    cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR)(tmp >> (8*0));
    size = tmp;

    if (!SptSendCdbToDevice(Device,
                            &cdb,
                            10,
                            (PUCHAR)header,
                            &size,
                            FALSE)) {
        printf("Unable to set mode page %x\n", GetLastError());
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
FillDisk(
    HANDLE Device,
    ULONG  Signature
    )
{
    READ_CAPACITY_DATA capacity;
    ULONG currentLba;
    PULONGLONG data;

    //
    // do a READ_CAPACITY to find the drive's sector size
    // and number of LBAs
    //
    {
        CDB cdb;
        ULONG size;
        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(&capacity, sizeof(READ_CAPACITY_DATA));

        cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;
        size = sizeof(READ_CAPACITY_DATA);

        if (!SptSendCdbToDevice(Device,
                                &cdb,
                                10,
                                (PUCHAR)&capacity,
                                &size,
                                TRUE)) {
            printf("Unable to get capacity %x\n", GetLastError());
            return FALSE;
        }
        //
        // convert the numbers
        //

        REVERSE_LONG(&capacity.BytesPerBlock);
        REVERSE_LONG(&capacity.LogicalBlockAddress);

        if ( (capacity.BytesPerBlock % 512) != 0 ) {
            printf("Sector size of %x is not a multiple of 512?!\n", capacity.BytesPerBlock);
            // capacity.BytesPerBlock = 512;
            return FALSE;
        }
    }

    //
    // print for kicks...
    //

    printf("  Bytes Per Block %10d (%8x)\n"
           "Number Of Sectors %10d (%8x)\n",
           capacity.BytesPerBlock,
           capacity.BytesPerBlock,
           capacity.LogicalBlockAddress,
           capacity.LogicalBlockAddress
           );

    //
    // allocate a sector's worth of data
    //

    data = (PLONGLONG)malloc( capacity.BytesPerBlock );
    if (data == NULL) {
        printf("Not enough memory to allocate data\n");
        return FALSE;
    }

    for (currentLba = 0; currentLba <= capacity.LogicalBlockAddress; currentLba++) {

        CDB cdb;
        PULONGLONG t = data;
        ULONG size;
        ULONG iterate = capacity.BytesPerBlock / sizeof(ULONGLONG);
        ULONG j;
        
        if ((currentLba % 100) == 0) {
            UpdatePercentageDisplay(currentLba, capacity.LogicalBlockAddress);
        }

        // RtlZeroMemory(data, capacity.BytesPerBlock);
        for (j=0; j < iterate ; j++, t++) {
            *t  = ((ULONGLONG)Signature) << 32; // signature
            *t += currentLba;                // etc.
        }

        //
        // prepare the "write" operation for this sector
        //

        RtlZeroMemory(&cdb, sizeof(CDB));
        cdb.CDB10.OperationCode     = SCSIOP_WRITE;
        cdb.CDB10.LogicalBlockByte0 = (UCHAR)(currentLba   >> (8*3));
        cdb.CDB10.LogicalBlockByte1 = (UCHAR)(currentLba   >> (8*2));
        cdb.CDB10.LogicalBlockByte2 = (UCHAR)(currentLba   >> (8*1));
        cdb.CDB10.LogicalBlockByte3 = (UCHAR)(currentLba   >> (8*0));
        cdb.CDB10.TransferBlocksMsb = 0;
        cdb.CDB10.TransferBlocksLsb = 1;

        size = capacity.BytesPerBlock;

        if (!SptSendCdbToDevice(Device, &cdb, 10, (PUCHAR)data, &size, FALSE)) {
            printf("Error %d writing sectors at %x\n",
                   GetLastError(), currentLba);
            free(data);
            return FALSE;
        }
    }
    UpdatePercentageDisplay(capacity.LogicalBlockAddress, capacity.LogicalBlockAddress);
    free(data);
    data = NULL;
    return TRUE;
}

DWORD MrwInitTestPatternCommand(HANDLE device, int argc, char *argv[])
/*++

Routine Description:

    Initializes a disk to contain 64-bit numbers that equate to
    the sector's LBA.

Arguments:
    
    device - drive to write to...

    argc - the number of additional arguments.  should be zero

Return Value:

    STATUS_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
{
    MRW_MODE_PAGE savedModePage;

    RtlZeroMemory(&savedModePage, sizeof(MRW_MODE_PAGE));
    savedModePage.PageCode = 0x3f; // illegal value for MODE_SELECT10

    //
    // first use GET_CONFIGURATION to verify that we're
    // actually on an MRW capable device
    //
    {
        #define MRW_FEATURE_DATA_SIZE (sizeof(GET_CONFIGURATION_HEADER)+sizeof(FEATURE_DATA_MRW))
        GET_CONFIGURATION_IOCTL_INPUT input;
        PGET_CONFIGURATION_HEADER header;
        PFEATURE_DATA_MRW mrwFeature;
        UCHAR data[ MRW_FEATURE_DATA_SIZE ];
        DWORD dataSize;
        DWORD expectedSize;
        DWORD feature;
        ULONG size;

        RtlZeroMemory(&input, sizeof(GET_CONFIGURATION_IOCTL_INPUT));
        RtlZeroMemory(&data, MRW_FEATURE_DATA_SIZE);

        input.Feature = FeatureMrw;
        input.RequestType = SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE;
        size = 0;

        if (!DeviceIoControl(device,
                             IOCTL_CDROM_GET_CONFIGURATION,
                             &input,
                             sizeof(GET_CONFIGURATION_IOCTL_INPUT),
                             data,
                             MRW_FEATURE_DATA_SIZE,
                             &size,
                             FALSE)) {
            DWORD errorValue = GetLastError();
            printf("error requesting GET_CONFIG data for MRW feature (%d)\n", errorValue);
            return errorValue;
        }

        header     = (PGET_CONFIGURATION_HEADER)data;
        mrwFeature = (PFEATURE_DATA_MRW)header->Data;
        
        expectedSize = 
            MRW_FEATURE_DATA_SIZE -
            RTL_SIZEOF_THROUGH_FIELD(GET_CONFIGURATION_HEADER, DataLength);
        dataSize =
            (header->DataLength[0] << (8 * 3)) |
            (header->DataLength[1] << (8 * 2)) |
            (header->DataLength[2] << (8 * 1)) |
            (header->DataLength[3] << (8 * 0));

        if ( dataSize < expectedSize ) {
            printf("data size too small -- drive may not support MRW? (%x)\n", expectedSize);
            return -1;
        }

        feature =
            (mrwFeature->Header.FeatureCode[0] << (8 * 1)) |
            (mrwFeature->Header.FeatureCode[1] << (8 * 0));

        if (feature != FeatureMrw) {
            printf("data size too small -- drive may not support MRW? (%x)\n", feature);
            return -1;
        }

        if (!mrwFeature->Write) {
            printf("Drive supports MRW, but as Read-Only\n");
            return -1;
        }
        if (!mrwFeature->Header.Current) {
            printf("Drive supports MRW, but not with the current medium (may need to be formatted MRW first\n");
            return -1;
        }

    } // end verification

    //
    // ensure we're in the correct mode (data area vs. GAA)
    //

    {
        #define MRW_MODE_PAGE_DATA_SIZE (sizeof(MODE_PARAMETER_HEADER10) + sizeof(MRW_MODE_PAGE))
        PMODE_PARAMETER_HEADER10 header;
        PMRW_MODE_PAGE page;
        PUCHAR data [ MRW_MODE_PAGE_DATA_SIZE ];
        CDB cdb;
        ULONG size;
        ULONG t1, t2;

        RtlZeroMemory(&cdb, sizeof(CDB));
        RtlZeroMemory(data, MRW_MODE_PAGE_DATA_SIZE);
        
        size = MRW_MODE_PAGE_DATA_SIZE;
        cdb.MODE_SENSE10.OperationCode       = SCSIOP_MODE_SENSE10;
        cdb.MODE_SENSE10.Dbd                 = 1;
        cdb.MODE_SENSE10.PageCode            = MODE_PAGE_MRW;
        cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(MRW_MODE_PAGE_DATA_SIZE >> 8);
        cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(MRW_MODE_PAGE_DATA_SIZE & 0xff);

        PrintBuffer(&cdb, 10);

        if (!SptSendCdbToDevice(device,
                                &cdb,
                                10,
                                (PUCHAR)&data,
                                &size,
                                TRUE)) {
            printf("Unable to get MRW mode page %x\n", GetLastError());
            
            // FAKE IT FOR NOW... BUGBUG
            header = (PMODE_PARAMETER_HEADER10)data;
            RtlZeroMemory(data, MRW_MODE_PAGE_DATA_SIZE);
            header->ModeDataLength[0] = 0;
            header->ModeDataLength[1] = 0xE;
            page = (PMRW_MODE_PAGE)(header+1);
            page->PageCode = MODE_PAGE_MRW;
            page->PageLength = 0x6;
            page->UseGAA = 0;
        }
        HELP_ME();
        
        header = (PMODE_PARAMETER_HEADER10)data;
        t1 = (header->ModeDataLength[0] << (8*1)) |
             (header->ModeDataLength[1] << (8*0)) ;
        t2 = MRW_MODE_PAGE_DATA_SIZE -
             RTL_SIZEOF_THROUGH_FIELD(MODE_PARAMETER_HEADER10, ModeDataLength);
        
        if (t1 != t2) {
            // size is wrong
            printf("MRW mode page wrong size, %x != %x\n", t1, t2);
            return -1;
        }
        if ((header->BlockDescriptorLength[0] != 0) ||
            (header->BlockDescriptorLength[1] != 0) ) {
            printf("MRW drive force a block descriptor %x %x\n",
                   header->BlockDescriptorLength[0],
                   header->BlockDescriptorLength[1]);
            return -1;
        }
        
        page = (PMRW_MODE_PAGE)(header+1); // pointer arithmetic
        if (page->PageCode != MODE_PAGE_MRW) {
            printf("MRW mode page has wrong page code, %x != %x\n",
                   page->PageCode, MODE_PAGE_MRW);
            return -1;
        }
        if (page->UseGAA) {
            printf("MRW mode page is set to GAA\n",
                   page->PageCode, MODE_PAGE_MRW);
            // ModeSelect()...
            return -1;
        }

        RtlCopyMemory(&savedModePage, page, sizeof(MRW_MODE_PAGE));
    }

    savedModePage.UseGAA = 1;
    if (!ModeSelect(device, &savedModePage, sizeof(MRW_MODE_PAGE))) {
        printf("Unable to set MRW mode page to use GAA (%x)\n", GetLastError());
        return -1;
    }

    if (!FillDisk(device, '\0wrm')) {
        printf("Unable to fill the GAA (%x)\n", GetLastError());
    }
    printf("\nFinished Writing General Application Area!\n");
    
    savedModePage.UseGAA = 0;
    if (!ModeSelect(device, &savedModePage, sizeof(MRW_MODE_PAGE))) {
        printf("Unable to revert from GAA space -- disc may be unusable! (%x)\n",
               GetLastError());
        return -1;
    }

    if (!FillDisk(device, '\0WRM')) {
        printf("Unable to fill the disc (%x)\n", GetLastError());
        return -1;
    }
    printf("\nFinished Writing Defect-managed Area!\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\cdburn\burn.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    burn.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/


#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "burn.h"
#include "sptlib.h"

#define MAX_CD_IMAGE_SIZE  (700 * 1024 * 1024)
#define MAX_DVD_IMAGE_SIZE (4700 * 1000 * 1000)
#define POST_GAP_SIZE 150
#define IS_TEST_BURN       FALSE


typedef struct _SENSE_STUFF {
    UCHAR Sense;
    UCHAR Asc;
    UCHAR Ascq;
    UCHAR Reserved;
} SENSE_STUFF, *PSENSE_STUFF;

SENSE_STUFF AllowedBurnSense[] = {
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0},
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0}
};
#define AllowedBurnSenseEntries (sizeof(AllowedBurnSense)/sizeof(SENSE_STUFF))

SENSE_STUFF AllowedReadDiscInfo[] = {
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_FORMAT_IN_PROGRESS,     0 },
    { SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK,     0, 0                },
    { SCSI_SENSE_UNIT_ATTENTION,  SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION, 0, 0                }
};
#define AllowedReadDiscInfoEntries (sizeof(AllowedReadDiscInfo)/sizeof(SENSE_STUFF))

BOOLEAN
IsSenseDataInTable(
    IN PSENSE_STUFF Table,
    IN LONG         Entries, // in table
    IN PSENSE_DATA  SenseData
    )
{
    LONG i;
    UCHAR sense = SenseData->SenseKey & 0xf;
    UCHAR asc   = SenseData->AdditionalSenseCode;
    UCHAR ascq  = SenseData->AdditionalSenseCodeQualifier;

    for (i = 0; i < Entries; i++ ) {
        if ((Table[i].Sense = sense) &&
            (Table[i].Ascq  = ascq ) &&
            (Table[i].Asc   = asc  )
            ) {
            return TRUE;
        }
    }
    return FALSE;
}


__inline
DWORD
MakeCdSpeed(
    IN DWORD Speed
    )
{
    Speed *= (75 * 2352); // this makes it the proper speed
    Speed +=  500;        // rounding...
    Speed /= 1000;        // yes, this is by 1000, not 1024!
    return Speed;
}



#if DBG
    #define OUTPUT stderr
    #define FPRINTF(x) fprintf x
#else
    #define OUTPUT stdout
    #define FPRINTF(x)
#endif

int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE cdromHandle;
    HANDLE isoImageHandle;
    HACK_FLAGS hackFlags;
    char buffer[32];

    if(argc < 3) {
        printf("Usage: burn <drive> <image>\n");
        return -1;
    }

    sprintf(buffer, "\\\\.\\%s", argv[1]);

    cdromHandle = CreateFile(buffer,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if(cdromHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    isoImageHandle = CreateFile(argv[2],
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);
    if (isoImageHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening image file %s\n",
                GetLastError(), argv[2]);
        CloseHandle(cdromHandle);
        return -2;
    }
    
    RtlZeroMemory(&hackFlags, sizeof(HACK_FLAGS));
    
    hackFlags.TestBurn             = 0;
    hackFlags.IgnoreModePageErrors = 1;

    BurnCommand(cdromHandle, isoImageHandle, hackFlags);
    
    CloseHandle(isoImageHandle);
    CloseHandle(cdromHandle);

    return 0;
}

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    )
{
    DWORD offset = 0;
    PUCHAR buf = Buffer;

    while (Size > 0x10) {
        printf("%08x:"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "\n",
               offset,
               *(buf +  0), *(buf +  1), *(buf +  2), *(buf +  3),
               *(buf +  4), *(buf +  5), *(buf +  6), *(buf +  7),
               *(buf +  8), *(buf +  9), *(buf + 10), *(buf + 11),
               *(buf + 12), *(buf + 13), *(buf + 14), *(buf + 15)
               );
        Size -= 0x10;
        offset += 0x10;
        buf += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *buf);
            spaceIt++;
            buf++;
        }
        printf("\n");

    }
    return;


}

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PLONG NumberOfBlocks
    )
{
    BY_HANDLE_FILE_INFORMATION isoImageInfo;
    
    if (!GetFileInformationByHandle(IsoImageHandle, &isoImageInfo)) {
        FPRINTF((OUTPUT, "Error %d getting file info for iso image\n",
                 GetLastError()));
        return FALSE;
    }
    
    if (isoImageInfo.nFileSizeHigh != 0) {
        FPRINTF((OUTPUT, "Error: File too large\n"));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }
    
    if ((isoImageInfo.nFileSizeLow % 2048) != 0) {
        FPRINTF((OUTPUT, "Error: The file size is not a multiple of 2048 (%I64d)\n",
                 isoImageInfo.nFileSizeLow));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }
    
    FPRINTF((OUTPUT, "File size is %d bytes (%d blocks)\n",
             isoImageInfo.nFileSizeLow,
             isoImageInfo.nFileSizeLow / 2048
             ));
    
    *NumberOfBlocks = isoImageInfo.nFileSizeLow / 2048;
    return TRUE;

}

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    PDISK_INFORMATION diskInfo;
    DWORD maxSize = sizeof(DISK_INFORMATION);
    DWORD size;

    FPRINTF((OUTPUT, "Verifying blank disc... "));

    diskInfo = LocalAlloc(LPTR, maxSize);
    if (diskInfo == NULL) {
        FPRINTF((OUTPUT, "\nError allocating diskinfo\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    RtlZeroMemory(diskInfo, sizeof(DISK_INFORMATION));
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
    cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(maxSize >> 8);
    cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(maxSize & 0xff);

    size = maxSize;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)diskInfo, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting disk info\n",
                 GetLastError()));
        LocalFree(diskInfo);
        return FALSE;
    }

    if (diskInfo->LastSessionStatus != 0x00) {
        FPRINTF((OUTPUT, "disc is not blank!\n"));
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        LocalFree(diskInfo);
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    LocalFree(diskInfo);
    return TRUE;
}

BOOLEAN
SetWriteModePage(
    IN HANDLE CdromHandle,
    IN BOOLEAN TestBurn,
    IN UCHAR WriteType,
    IN UCHAR MultiSession,
    IN UCHAR DataBlockType,
    IN UCHAR SessionFormat
    )
{
    PCDVD_WRITE_PARAMETERS_PAGE params = NULL;
    MODE_PARAMETER_HEADER10 header;
    PMODE_PARAMETER_HEADER10 buffer;

    UCHAR mediumTypeCode;


    CDB cdb;
    DWORD bufferSize;
    DWORD maxSize;

    FPRINTF((OUTPUT, "Setting WriteParameters mode page... "));
    
    bufferSize = sizeof(MODE_PARAMETER_HEADER10);

    RtlZeroMemory(&header, sizeof(MODE_PARAMETER_HEADER10));
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode = 0x5;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)&header, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting mode page 0x05 from device(1)\n",
                 GetLastError()));
        return FALSE;    
    }
    
    bufferSize =
        (header.ModeDataLength[0] << 8) +
        (header.ModeDataLength[1] & 0xff);
    bufferSize += 2; // sizeof area that tells the remaining size

    maxSize = bufferSize;
    
    buffer = LocalAlloc(LPTR, bufferSize);
    if (!buffer) {
        FPRINTF((OUTPUT, "\nError -- unable to alloc %d bytes for mode parameters page\n",
                 bufferSize));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode = 0x5;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)buffer, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting mode page 0x05 from device(2)\n",
                 GetLastError()));
        LocalFree(buffer);
        return FALSE;
    }

    mediumTypeCode = buffer->MediumType;
    
    //
    // bufferSize now holds the amount of data returned
    // this should be enough...
    //

    {
        
        DWORD t =
            (buffer->BlockDescriptorLength[0] >> 8) +
            (buffer->BlockDescriptorLength[1] & 0xff);

        if (t != 0) {
            fprintf(stderr, "BlockDescriptor non-zero! (%x)\n", t);
            SetLastError(1);
            return FALSE;
        }
    }
        
    //
    // pointer arithmetic here.  (buffer+1) points just past the
    // end of the mode_parameter_header10.
    //

    params = (PCDVD_WRITE_PARAMETERS_PAGE)(buffer + 1);
    FPRINTF((OUTPUT, "buffer = %p  params = %p\n", buffer, params));

    //
    // zero the header, but don't modify any settings that don't
    // need to be modified!
    //

    RtlZeroMemory(buffer, FIELD_OFFSET(MODE_PARAMETER_HEADER10,
                                       BlockDescriptorLength[0]));
    buffer->ModeDataLength[0] = (UCHAR)((bufferSize-2) >> 8);
    buffer->ModeDataLength[1] = (UCHAR)((bufferSize-2) & 0xff);
    buffer->MediumType = mediumTypeCode;
    
    params->WriteType     = WriteType;
    params->TestWrite     = (TestBurn ? 0x01 : 0x00);
    params->Copy          = 0x00; // original disc
    //params->TrackMode     = 0x04; // control nibble in Q subchannel
    params->MultiSession  = MultiSession;
    params->DataBlockType = DataBlockType;
    params->SessionFormat = SessionFormat;
    params->MediaCatalogNumberValid = 0x00;
    params->ISRCValid = 0x00;

    RtlZeroMemory(&cdb, sizeof(CDB));
        
    cdb.MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
    cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR)(bufferSize & 0xff);
    cdb.MODE_SELECT10.PFBit = 1;
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)buffer, &bufferSize, FALSE)) {
        FPRINTF((OUTPUT, "\nError %d sending mode page 0x05 to device\n",
                 GetLastError()));
        LocalFree(buffer);
        return FALSE;
    }
    LocalFree(buffer);
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
GetNextWritableAddress(
    IN HANDLE CdromHandle,
    IN UCHAR Track,
    OUT PLONG NextWritableAddress,
    OUT PLONG AvailableBlocks
    )
{
    CDB cdb;
    TRACK_INFORMATION trackInfo;
    DWORD size = sizeof(TRACK_INFORMATION);
    LONG nwa, available;

    *NextWritableAddress = (LONG)-1;
    *AvailableBlocks = (LONG)0;

    FPRINTF((OUTPUT, "Verifying track info... "));

    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&trackInfo, sizeof(TRACK_INFORMATION));


    cdb.READ_TRACK_INFORMATION.OperationCode = SCSIOP_READ_TRACK_INFORMATION;
    cdb.READ_TRACK_INFORMATION.Track = 0x01;
    cdb.READ_TRACK_INFORMATION.BlockAddress[3] = Track;
    cdb.READ_TRACK_INFORMATION.AllocationLength[0] = (UCHAR)(size >> 8);
    cdb.READ_TRACK_INFORMATION.AllocationLength[1] = (UCHAR)(size & 0xff);


    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)&trackInfo, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting track info\n",
                 GetLastError()));
        return FALSE;
    }

    if (!trackInfo.NWA_V) {
        FPRINTF((OUTPUT, "invalid NextWritableAddress -- may be invalid media?\n"));
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return FALSE;
    }
    
    nwa = (trackInfo.NextWritableAddress[0] << 24) |
          (trackInfo.NextWritableAddress[1] << 16) |
          (trackInfo.NextWritableAddress[2] <<  8) |
          (trackInfo.NextWritableAddress[3] <<  0);

    available = (trackInfo.FreeBlocks[0] << 24) |
                (trackInfo.FreeBlocks[1] << 16) |
                (trackInfo.FreeBlocks[2] <<  8) |
                (trackInfo.FreeBlocks[3] <<  0);
    
    FPRINTF((OUTPUT, "pass.\n"));

    *NextWritableAddress = nwa;
    *AvailableBlocks = available;
    return TRUE;
}

BOOLEAN
SendOptimumPowerCalibration(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    FPRINTF((OUTPUT, "Setting OPC_INFORMATION..."));

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.SEND_OPC_INFORMATION.OperationCode = SCSIOP_SEND_OPC_INFORMATION;
    cdb.SEND_OPC_INFORMATION.DoOpc = 1;
    size = 0;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nFailed to send SET_OPC_INFORMATION (%d)\n",
                 GetLastError()));
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
SetRecordingSpeed(
    IN HANDLE CdromHandle,
    IN DWORD Speed
    )
{
    CDB cdb;
    DWORD size;
    DWORD kbSpeed;
    
    FPRINTF((OUTPUT, "Setting CD Speed..."));
    
    kbSpeed = MakeCdSpeed(Speed);

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.SET_CD_SPEED.OperationCode = SCSIOP_SET_CD_SPEED;
    cdb.SET_CD_SPEED.ReadSpeed[0] = 0xff;
    cdb.SET_CD_SPEED.ReadSpeed[1] = 0xff;
    cdb.SET_CD_SPEED.WriteSpeed[0] = (UCHAR)(kbSpeed >> 8);
    cdb.SET_CD_SPEED.WriteSpeed[1] = (UCHAR)(kbSpeed & 0xff);
    size = 0;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 12,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nFailed to send SET_CD_SPEED (%d)\n",
                 GetLastError()));
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

VOID
WaitForReadDiscInfoToWork(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    DISK_INFORMATION diskInfo;
    DWORD i;

    //
    // loop using SCSIOP_READ_DISK_INFORMATION (0x51) since
    // that seems to fail for *ALL* drives until the drive is ready
    //

    for (i=0; ; i++) {
        
        size = sizeof(DISK_INFORMATION);
        RtlZeroMemory(&diskInfo, sizeof(DISK_INFORMATION));
        RtlZeroMemory(&cdb, sizeof(CDB));
        
        cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
        cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(size >> 8);
        cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(size & 0xff);
        
        if (SptSendCdbToDevice(CdromHandle, &cdb, 10,
                               (PUCHAR)&diskInfo, &size, TRUE)) {
            FPRINTF((OUTPUT, "ReadDiscInfo Succeeded! (%d seconds)\n", i));
            return;
        }
        // should verify the errors are valid errors (AllowedReadDiscInfo[])?

        // need to sleep here so we don't overload the unit!
        Sleep(1000); // one second
    }
    return;
}


BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN LONG NumberOfBlocks,
    IN LONG FirstLba
    )
{
    DWORD bufferSize = 0x800 * 0x10;
    PUCHAR buffer = NULL;
    LONG currentBlock;

    FPRINTF((OUTPUT, "Starting write: "));

    buffer = LocalAlloc(LPTR, bufferSize);
    if (buffer == NULL) {
        FPRINTF((OUTPUT, "unable to allocate write buffer\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    FPRINTF((OUTPUT, "............."));

    for (currentBlock = 0; currentBlock < NumberOfBlocks + POST_GAP_SIZE; ) {

        CDB cdb;
        DWORD readSize;
        DWORD readBytes;

        {
            static CHAR progress[4] =  { '|', '/', '-', '\\' };
            DWORD percent;
            percent = (currentBlock*1000) / (NumberOfBlocks+POST_GAP_SIZE);
            //                # # # . # % _ d o n e _ *  
            printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
            printf("%c %3d.%d%% done",
                   progress[(currentBlock%0x40)/0x10],
                   percent / 10, percent % 10
                   );
            fflush(stdout);
        }

        if (NumberOfBlocks - currentBlock >= 0x10) {
            readSize = 0x800 * 0x10;
        } else if (NumberOfBlocks - currentBlock > 0) {
            readSize = (NumberOfBlocks - currentBlock) * 0x800;
            RtlZeroMemory(buffer, bufferSize);
        } else {
            readSize = 0;
            readBytes = 0;
            RtlZeroMemory(buffer, bufferSize);
        }

        if (readSize &&
            !ReadFile(IsoImageHandle, buffer, readSize, &readBytes, NULL)
            ) {
            FPRINTF((OUTPUT, "error reading from file %d\n", GetLastError()));
            LocalFree(buffer);
            return FALSE;
        }

        if (readBytes != readSize) {
            FPRINTF((OUTPUT, "error only read %d of %d bytes from file\n",
                    readBytes, readSize));
            LocalFree(buffer);
            return FALSE;
        }

        
        {
            BOOL writeCompleted = FALSE;
            
            while (!writeCompleted) {
                
                BOOLEAN ignoreError;
                SENSE_DATA senseData;
                RtlZeroMemory(&senseData, sizeof(senseData));
                RtlZeroMemory(&cdb, sizeof(CDB));

                cdb.CDB10.OperationCode = SCSIOP_WRITE;
                cdb.CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&currentBlock)->Byte3;
                cdb.CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&currentBlock)->Byte2;
                cdb.CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&currentBlock)->Byte1;
                cdb.CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&currentBlock)->Byte0;
        
                if ((currentBlock + 0x10) <= (NumberOfBlocks + POST_GAP_SIZE)) {
                    cdb.CDB10.TransferBlocksLsb = 0x10;
                } else {
                    cdb.CDB10.TransferBlocksLsb =
                        (UCHAR)(NumberOfBlocks + POST_GAP_SIZE - currentBlock);
                }

                writeCompleted = SptSendCdbToDeviceEx(CdromHandle,
                                                      &cdb,
                                                      10,
                                                      buffer,
                                                      &bufferSize,
                                                      &senseData,
                                                      sizeof(SENSE_DATA),
                                                      FALSE,
                                                      50 // timeout seconds
                                                      );
                ignoreError = IsSenseDataInTable(AllowedBurnSense,
                                                 AllowedBurnSenseEntries,
                                                 &senseData);
                if ((!writeCompleted) && ignoreError) {
                    printf("Continuing on %x/%x/%x\n",
                           senseData.SenseKey & 0xf,
                           senseData.AdditionalSenseCode,
                           senseData.AdditionalSenseCodeQualifier
                           );
                    Sleep(100); // 100ms == .1 seconds
                }

                if (!writeCompleted && !ignoreError) {
                    FPRINTF((OUTPUT, "\nError %d in writing LBA 0x%x\n",
                    GetLastError(), currentBlock));
                    LocalFree(buffer);
                    return FALSE;
                }

            } // while(!writeCompleted) loop

        } // random block to have local variable writeCompleted

        // write completed success, so continue.
        currentBlock += 0x10;

    }




    printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
    LocalFree(buffer);

    printf("Finished Writing\nSynchronizing Cache: ");
    fflush(stdout);
    
    //
    // do the FLUSH_CACHE immediate
    //
    {
        DWORD size;
        CDB cdb;
        RtlZeroMemory(&cdb, sizeof(CDB));        
        cdb.SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;
        cdb.SYNCHRONIZE_CACHE10.Immediate = 1;
        size = 0;

        if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                                NULL, &size, TRUE)) {
            FPRINTF((OUTPUT, "\nError %d Synchronizing Cache\n",
                    GetLastError()));
            return FALSE;
        }
    }

    WaitForReadDiscInfoToWork(CdromHandle);
    return TRUE;
}

BOOLEAN
CloseTrack(
    IN HANDLE CdromHandle,
    IN LONG   Track
    )
{
    CDB cdb;
    DWORD size;
    FPRINTF((OUTPUT, "Closing the track..."));

    if (Track > 0xffff) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
    cdb.CLOSE_TRACK.Immediate = 0;
    cdb.CLOSE_TRACK.Track   = 1;
    cdb.CLOSE_TRACK.Session = 0;    
    cdb.CLOSE_TRACK.TrackNumber[0] = (UCHAR)(Track >> 8);
    cdb.CLOSE_TRACK.TrackNumber[1] = (UCHAR)(Track & 0xff);
    
    size = 0;

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d Closing Track\n",
                GetLastError()));
        return FALSE;
    }
    
    WaitForReadDiscInfoToWork(CdromHandle);

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;


}

BOOLEAN
CloseSession(
    IN HANDLE  CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    FPRINTF((OUTPUT, "Closing the disc..."));

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.CLOSE_TRACK.OperationCode = SCSIOP_CLOSE_TRACK_SESSION;
    cdb.CLOSE_TRACK.Immediate = 1;
    cdb.CLOSE_TRACK.Track   = 0;
    cdb.CLOSE_TRACK.Session = 1;    
    size = 0;

    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              10,
                              NULL,
                              &size,
                              NULL,
                              0,
                              TRUE,
                              240)) { // four minutes to close session
        FPRINTF((OUTPUT, "\nError %d Synchronizing Cache\n",
                GetLastError()));
        return FALSE;
    }
    
    WaitForReadDiscInfoToWork(CdromHandle);

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    )
{
    CDB cdb;
    DWORD size;

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb.START_STOP.LoadEject = Eject;
    cdb.START_STOP.Start     = Start;

    size = 0;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 6,
                            NULL, &size, TRUE)) {
        return FALSE;
    }

    return TRUE;
}

/*
ERROR_BAD_COMMAND
ERROR_INVALID_DATA
ERROR_INVALID_PARAMETER
ERROR_MEDIA_INCOMPATIBLE
ERROR_NOT_ENOUGH_MEMORY

ERROR_OUTOFMEMORY

*/

/*++

Routine Description:

    burns an ISO image to cdrom

Arguments:
    CdromHandle - a file handle to send the ioctl to

    argc - the number of additional arguments (2)

Return Value:

    ERROR_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
DWORD
BurnCommand(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    HACK_FLAGS HackFlags
    )
{
    LONG numberOfBlocks;
    LONG availableBlocks;
    LONG firstLba;
    LONG i;


////////////////////////////////////////////////////////////////////////////////
// verify the iso image file looks correct
////////////////////////////////////////////////////////////////////////////////
    if (!VerifyIsoImage(IsoImageHandle, &numberOfBlocks)) {
        printf("Error verifying ISO image\n");
        return GetLastError();
    }
////////////////////////////////////////////////////////////////////////////////
// verify (as best as possible) that it's blank media
////////////////////////////////////////////////////////////////////////////////

    if (!VerifyBlankMedia(CdromHandle)) {
        printf("Error verifying blank media\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// Setup the write mode page
////////////////////////////////////////////////////////////////////////////////
    if (!SetWriteModePage(CdromHandle,
                          (BOOLEAN)HackFlags.TestBurn,
                          0x01, // track-at-once
                          0x03, // we close the session/disc ourselves
                          0x08, // 0x08 == Mode 1 (ISO/IEC 10149 == 2048 bytes)
                                // 0x0a == Mode 2 (CDROM XA, Form 1, 2048 bytes)
                          0x00  // 0x00 == CD-DA, CD-ROM, or other data disc
                                // 0x20 == CDROM XA
                          )) {
        printf("Error setting write mode page\n");
        if (!HackFlags.IgnoreModePageErrors) {
            return GetLastError();
        } else {
            printf("Ignoring error and attempting to continue...\n");
        }

    }

////////////////////////////////////////////////////////////////////////////////
// get next writable address
////////////////////////////////////////////////////////////////////////////////
    if (!GetNextWritableAddress(CdromHandle, 0x01, &firstLba, &availableBlocks)) {
        printf("Error verifying next writable address\n");
        return GetLastError();
    }
    
    if (availableBlocks < numberOfBlocks) {
        printf("Error verifying free blocks on media (%d needed, %d available)\n",
               numberOfBlocks, availableBlocks);
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return GetLastError();
    }
    if (firstLba != 0) {
        printf("Error verifying next writable address is zero\n");
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// set the cd speed to four for now, can later make a cmd-line switch
////////////////////////////////////////////////////////////////////////////////
    if (!SetRecordingSpeed(CdromHandle, 4)) {
        printf("Error setting the cd speed to %d\n", 4);
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// calibrate the drive's power -- this is optional, so let it fail!
////////////////////////////////////////////////////////////////////////////////

    if (!SendOptimumPowerCalibration(CdromHandle)) {
        printf("WARNING: setting optimum power calibration failed\n");
        //return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// start writing
////////////////////////////////////////////////////////////////////////////////

    if (!BurnThisSession(CdromHandle, IsoImageHandle, numberOfBlocks, firstLba)) {
        printf("Error burning ISO image\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// close the track -- ignore failures
////////////////////////////////////////////////////////////////////////////////

    if (!CloseTrack(CdromHandle, 0)) {
        printf("WARNING: error closing the track -- may be ignored?\n");
        //return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// close the session
////////////////////////////////////////////////////////////////////////////////

    if (!CloseSession(CdromHandle)) {
        printf("Error closing session\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// eject the newly burned cd!
////////////////////////////////////////////////////////////////////////////////


    if (!SendStartStopUnit(CdromHandle, FALSE, TRUE) ||
        !SendStartStopUnit(CdromHandle, TRUE,  TRUE)) {
        printf("Error ejecting/reinserting disc\n");
        return GetLastError();
    }

    printf("burn successful!\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\dvdburn\burn.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    burn.c

Abstract:

    A user mode app that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:

    03-26-96 : Created

--*/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <sptlib.h>
#include "burn.h"
#include <winioctl.h>

#define MIN_WRITE_SECTORS (0x10)

#if DBG
    #define OUTPUT stdout
    #define FPRINTF(x) fprintf x
    #define PRINTBUFFER(x) PrintBuffer x
#else
    #define OUTPUT stdout
    #define FPRINTF(x)
    #define PRINTBUFFER(x)
#endif


typedef struct _SENSE_STUFF {
    UCHAR Sense;
    UCHAR Asc;
    UCHAR Ascq;
    UCHAR Reserved;
} SENSE_STUFF, *PSENSE_STUFF;

SENSE_STUFF AllowedBurnSense[] = {
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0},
    {SCSI_SENSE_NOT_READY, SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0}
};
#define AllowedBurnSenseEntries (sizeof(AllowedBurnSense)/sizeof(SENSE_STUFF))

SENSE_STUFF AllowedReadDiscInfo[] = {
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_OPERATION_IN_PROGRESS,  0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS, 0 },
    { SCSI_SENSE_NOT_READY,       SCSI_ADSENSE_LUN_NOT_READY, SCSI_SENSEQ_FORMAT_IN_PROGRESS,     0 },
    { SCSI_SENSE_ILLEGAL_REQUEST, SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK,     0, 0                },
    { SCSI_SENSE_UNIT_ATTENTION,  SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION, 0, 0                }
};
#define AllowedReadDiscInfoEntries (sizeof(AllowedReadDiscInfo)/sizeof(SENSE_STUFF))


BOOLEAN
IsSenseDataInTable(
    IN PSENSE_STUFF Table,
    IN LONG         Entries, // in table
    IN PSENSE_DATA  SenseData
    )
{
    LONG i;
    UCHAR sense = SenseData->SenseKey & 0xf;
    UCHAR asc   = SenseData->AdditionalSenseCode;
    UCHAR ascq  = SenseData->AdditionalSenseCodeQualifier;

    for (i = 0; i < Entries; i++ ) {
        if ((Table[i].Sense = sense) &&
            (Table[i].Ascq  = ascq ) &&
            (Table[i].Asc   = asc  )
            ) {
            return TRUE;
        }
    }
    return FALSE;
}



int __cdecl main(int argc, char *argv[])
{
    int i = 0;
    HANDLE cdromHandle;
    HANDLE isoImageHandle;
    char buffer[32];
    DWORD Foo;
    BOOLEAN Erase = FALSE;

    if(argc < 3) {
        printf("Usage: burn <drive> <image> [/Erase]\n");
        return -1;
    }

    if (argc == 4)  {

        if (!strncmp( "/E", argv[3], 2))  {

            Erase = TRUE;
        }
        else {
        
            printf("Unrecognized switch\n");
            return -1;
        }
    }
    
    sprintf(buffer, "\\\\.\\%s", argv[1]);

    cdromHandle = CreateFile(buffer,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

    if(cdromHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening device %s\n", GetLastError(), buffer);
        return -2;
    }

    if (!DeviceIoControl( cdromHandle,
                     FSCTL_LOCK_VOLUME,
                     NULL, 0,
                     NULL, 0,
                     &Foo,
                     NULL))  {

        printf("Error %d locking volume\n", GetLastError());
    }
    else {
    
        printf("Locked volume for burn\n");
    }

    isoImageHandle = CreateFile(argv[2],
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);
    if (isoImageHandle == INVALID_HANDLE_VALUE) {
        printf("Error %d opening image file %s\n",
                GetLastError(), argv[2]);
        CloseHandle(cdromHandle);
        return -2;
    }

    BurnCommand(cdromHandle, isoImageHandle, Erase);
    
    CloseHandle(isoImageHandle);
    CloseHandle(cdromHandle);

    return 0;
}

/*++

Routine Description:

    burns an ISO image to cdrom

Arguments:
    CdromHandle - a file handle to send the ioctl to

    argc - the number of additional arguments (2)

Return Value:

    ERROR_SUCCESS if successful
    The value of GetLastError() from the point of failure

--*/
DWORD
BurnCommand(
    HANDLE CdromHandle,
    HANDLE IsoImageHandle,
    BOOLEAN Erase
    )
{
    DWORD numberOfBlocks;
    DWORD availableBlocks;
    DWORD nwa;
    LONG i;


////////////////////////////////////////////////////////////////////////////////
// verify the iso image file looks correct
////////////////////////////////////////////////////////////////////////////////
    if (!VerifyIsoImage(IsoImageHandle, &numberOfBlocks)) {
        printf("Error verifying ISO image\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// verify (as best as possible) that it's blank media
////////////////////////////////////////////////////////////////////////////////

    if (Erase && !EraseMedia(CdromHandle))  {
        printf("Error erasing media\n");
        return GetLastError();
    }

    if (!VerifyBlankMedia(CdromHandle)) {
        printf("Error verifying blank media\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// verify media capacity
////////////////////////////////////////////////////////////////////////////////
    if (!VerifyMediaCapacity(CdromHandle, numberOfBlocks)) {
        printf("Error verifying media capacity\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// DVD-R does not require mode page changes,  -RW does,  try anyway.
////////////////////////////////////////////////////////////////////////////////

    if (!SetWriteModePageDao(CdromHandle))  {
        printf("Error setting DAO (Required for -RW only) - ignoring.\n");
    }
    
////////////////////////////////////////////////////////////////////////////////
// send the time stamp
////////////////////////////////////////////////////////////////////////////////
    if (!SendTimeStamp(CdromHandle, "20010614000000")) { // YYYYMMDDHHMMSS format
        printf("Error setting timestamp - ignoring\n");
    }

////////////////////////////////////////////////////////////////////////////////
// optionally, send the User Specific Data
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Reserve the RZone for this burn
////////////////////////////////////////////////////////////////////////////////

    if (!ReserveRZone(CdromHandle, numberOfBlocks)) {
        printf("Error reserving zone for burn\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// get NWA via Read RZone Informationcommand, specifying RZone 1 for blank disk
////////////////////////////////////////////////////////////////////////////////

    // Special case -- blank disc is always zero
    nwa = 0;

////////////////////////////////////////////////////////////////////////////////
// start writing
////////////////////////////////////////////////////////////////////////////////
    
    if (!BurnThisSession(CdromHandle, IsoImageHandle, numberOfBlocks, nwa)) {
        printf("Error burning ISO image\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// wait for it to finish
////////////////////////////////////////////////////////////////////////////////

    if (!WaitForBurnToComplete(CdromHandle)) {
        printf("Error waiting for burn to complete\n");
        return GetLastError();
    }

////////////////////////////////////////////////////////////////////////////////
// eject the newly burned dvd!
////////////////////////////////////////////////////////////////////////////////


    if (!SendStartStopUnit(CdromHandle, FALSE, TRUE) ||
        !SendStartStopUnit(CdromHandle, TRUE,  TRUE)) {
        printf("Error ejecting/reinserting disc\n");
        return GetLastError();
    }

    printf("burn successful!\n");
    return 0;
}

BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN DWORD NumberOfBlocks,
    IN DWORD FirstLba
    )
{
    DWORD bufferSize = 0x800 * MIN_WRITE_SECTORS;  // sixteen blocks per...
    PUCHAR buffer = NULL;
    DWORD i;

    FPRINTF((OUTPUT, "Starting write: "));

    buffer = LocalAlloc(LPTR, bufferSize);
    if (buffer == NULL) {
        FPRINTF((OUTPUT, "unable to allocate write buffer\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    FPRINTF((OUTPUT, "............."));

    for (i = 0; i < NumberOfBlocks; i += MIN_WRITE_SECTORS) {

        CDB cdb;
        DWORD currentSize;
        DWORD readBytes;
        DWORD j;
        SENSE_DATA senseData;

        {
            static CHAR progress[4] =  { '|', '/', '-', '\\' };
            DWORD percent;
            percent = (i*1000) / NumberOfBlocks;
            //                # # # . # % _ d o n e _ *  
            printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
            printf("%c %3d.%d%% done",
                   progress[(i%0x40)/0x10],
                   percent / 10, percent % 10
                   );
            fflush(stdout);
        }

        RtlZeroMemory(buffer, bufferSize);

        if (NumberOfBlocks - i >= MIN_WRITE_SECTORS) {
            currentSize = 0x800 * 0x10;
        } else if (NumberOfBlocks - i > 0) {
            // end of file case -- zero memory first!
            RtlZeroMemory(buffer, bufferSize);
            currentSize = (NumberOfBlocks - i) * 0x800;
        } else {
            FPRINTF((OUTPUT, "INTERNAL ERROR line %d\n", __LINE__));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            LocalFree(buffer);
            return FALSE;
        }

        if (!ReadFile(IsoImageHandle, buffer, currentSize, &readBytes, NULL)) {
            FPRINTF((OUTPUT, "error reading from file %d\n", GetLastError()));
            LocalFree(buffer);
            return FALSE;
        }
        if (readBytes != currentSize) {
            FPRINTF((OUTPUT, "error only read %d of %d bytes\n",
                    readBytes, currentSize));
            LocalFree(buffer);
            return FALSE;
        }

        //
        // must write the full buffer each time for DVD-R,
        // since it's a RESTRICTED_OVERWRITE medium and seems
        // to choke otherwise
        //

        j = 0;
    retryThisWrite:
        RtlZeroMemory(&senseData, sizeof(SENSE_DATA));
        RtlZeroMemory(&cdb, sizeof(CDB));
        cdb.CDB10.OperationCode = SCSIOP_WRITE;
        cdb.CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&i)->Byte3;
        cdb.CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&i)->Byte2;
        cdb.CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&i)->Byte1;
        cdb.CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&i)->Byte0;

        cdb.CDB10.TransferBlocksLsb = MIN_WRITE_SECTORS;

        //
        // NOTE: we always send full buffer size to ensure 32k alignment
        //
        if (!SptSendCdbToDeviceEx(CdromHandle,
                                  &cdb,
                                  10,
                                  buffer,
                                  &bufferSize,
                                  &senseData,
                                  sizeof(SENSE_DATA),
                                  FALSE,
                                  10)) {
            
            Sleep(100); // 100ms == .1 seconds
            
            if (IsSenseDataInTable(AllowedBurnSense,
                                   AllowedBurnSenseEntries,
                                   &senseData)
                ) {
                
                // just sleep a bit...
                goto retryThisWrite;
            
            } else if (j<4) {

                j++;
                FPRINTF((OUTPUT, "Retrying write to LBA 0x%x\n", i));
                goto retryThisWrite;

            }

            FPRINTF((OUTPUT, "\nError %d in writing LBA 0x%x (%x times)\n",
                     GetLastError(), i, j));
            LocalFree(buffer);
            return FALSE;
        }
        

    }
    printf("\b\b\b\b\b\b\b\b\b\b\b\b\b");
    printf("Finished Writing\n");
    fflush(stdout);
    LocalFree(buffer);
    return TRUE;
}

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    )
{
    DWORD offset = 0;
    PUCHAR buf = Buffer;

    while (Size > 0x10) {
        printf("%08x:"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "  %02x %02x %02x %02x %02x %02x %02x %02x"
               "\n",
               offset,
               *(buf +  0), *(buf +  1), *(buf +  2), *(buf +  3),
               *(buf +  4), *(buf +  5), *(buf +  6), *(buf +  7),
               *(buf +  8), *(buf +  9), *(buf + 10), *(buf + 11),
               *(buf + 12), *(buf + 13), *(buf + 14), *(buf + 15)
               );
        Size -= 0x10;
        offset += 0x10;
        buf += 0x10;
    }

    if (Size != 0) {

        DWORD spaceIt;

        printf("%08x:", offset);
        for (spaceIt = 0; Size != 0; Size--) {

            if ((spaceIt%8)==0) {
                printf(" "); // extra space every eight chars
            }
            printf(" %02x", *buf);
            spaceIt++;
            buf++;
        }
        printf("\n");

    }
    return;


}

BOOLEAN
EraseMedia(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD bufferSize;

    printf( "Attempting to blank media...\n");
    
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.AsByte[0] = 0xa1;
    cdb.AsByte[1] = 0x01; // minimal blank
    bufferSize = 0;
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 12,
                            NULL, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d blanking media\n",
                 GetLastError()));
        return FALSE;
    }
    return TRUE;
}


BOOLEAN
SetWriteModePageDao(
    IN HANDLE CdromHandle
    )
{
    PCDVD_WRITE_PARAMETERS_PAGE params = NULL;
    MODE_PARAMETER_HEADER10 header;
    PMODE_PARAMETER_HEADER10 buffer;

    UCHAR mediumTypeCode;

    CDB cdb;
    DWORD bufferSize;
    DWORD maxSize;

    FPRINTF((OUTPUT, "Setting DAO mode in WriteParameters mode page... "));
    
    bufferSize = sizeof(MODE_PARAMETER_HEADER10);

    RtlZeroMemory(&header, sizeof(MODE_PARAMETER_HEADER10));
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode = 0x5;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)&header, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting mode page 0x05 from device(1)\n",
                 GetLastError()));
        return FALSE;    
    }
    
    bufferSize =
        (header.ModeDataLength[0] << 8) +
        (header.ModeDataLength[1] & 0xff);
    bufferSize += 2; // sizeof area that tells the remaining size

    maxSize = bufferSize;
    
    buffer = LocalAlloc(LPTR, bufferSize);
    if (!buffer) {
        FPRINTF((OUTPUT, "\nError -- unable to alloc %d bytes for mode parameters page\n",
                 bufferSize));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode = 0x5;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufferSize & 0xff);
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)buffer, &bufferSize, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting mode page 0x05 from device(2)\n",
                 GetLastError()));
        LocalFree(buffer);
        return FALSE;
    }

    mediumTypeCode = buffer->MediumType;
    
    //
    // bufferSize now holds the amount of data returned
    // this should be enough...
    //

    {
        
        DWORD t =
            (buffer->BlockDescriptorLength[0] >> 8) +
            (buffer->BlockDescriptorLength[1] & 0xff);

        if (t != 0) {
            fprintf(stderr, "BlockDescriptor non-zero! (%x)\n", t);
            SetLastError(1);
            return FALSE;
        }
    }
        
    //
    // pointer arithmetic here.  (buffer+1) points just past the
    // end of the mode_parameter_header10.
    //

    params = (PCDVD_WRITE_PARAMETERS_PAGE)(buffer + 1);
    FPRINTF((OUTPUT, "buffer = %p  params = %p\n", buffer, params));

    //
    // zero the header, but don't modify any settings that don't
    // need to be modified!
    //

    RtlZeroMemory(buffer, FIELD_OFFSET(MODE_PARAMETER_HEADER10,
                                       BlockDescriptorLength[0]));
    buffer->ModeDataLength[0] = (UCHAR)((bufferSize-2) >> 8);
    buffer->ModeDataLength[1] = (UCHAR)((bufferSize-2) & 0xff);
    buffer->MediumType = mediumTypeCode;
    
    params->WriteType     = 2;      // DAO
    params->TestWrite     = 0x00;
    params->Copy          = 0x00; // original disc
    params->MultiSession  = 0;
    params->BufferUnderrunFree = 1;

    RtlZeroMemory(&cdb, sizeof(CDB));
        
    cdb.MODE_SELECT10.OperationCode = SCSIOP_MODE_SELECT10;
    cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR)(bufferSize >> 8);
    cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR)(bufferSize & 0xff);
    cdb.MODE_SELECT10.PFBit = 1;
    
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)buffer, &bufferSize, FALSE)) {
        FPRINTF((OUTPUT, "\nError %d sending mode page 0x05 to device - ignoring\n",
                 GetLastError()));
        LocalFree(buffer);
        return TRUE;
    }
    LocalFree(buffer);
    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;
}


BOOLEAN
ReserveRZone(
    IN HANDLE CdromHandle,
    IN DWORD numberOfBlocks
    )
{
    CDB cdb;
    DWORD size = 0;
    
    FPRINTF((OUTPUT, "Reserving RZone... "));
    
    if (numberOfBlocks % MIN_WRITE_SECTORS) {
        FPRINTF((OUTPUT, "increasing size by 0x%x blocks... ",
                 MIN_WRITE_SECTORS - (numberOfBlocks % MIN_WRITE_SECTORS)));
        numberOfBlocks /= MIN_WRITE_SECTORS;
        numberOfBlocks *= MIN_WRITE_SECTORS;
        numberOfBlocks += MIN_WRITE_SECTORS;
    }
    
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.RESERVE_TRACK_RZONE.OperationCode = SCSIOP_RESERVE_TRACK_RZONE;
    cdb.RESERVE_TRACK_RZONE.ReservationSize[0] = (UCHAR)(numberOfBlocks >> 24);
    cdb.RESERVE_TRACK_RZONE.ReservationSize[1] = (UCHAR)(numberOfBlocks >> 16);
    cdb.RESERVE_TRACK_RZONE.ReservationSize[2] = (UCHAR)(numberOfBlocks >>  8);
    cdb.RESERVE_TRACK_RZONE.ReservationSize[3] = (UCHAR)(numberOfBlocks >>  0);

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "Error reserving RZone\n"));
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));

    return TRUE;
}

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    )
{
    CDB cdb;
    DWORD size = 0;

    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
    cdb.START_STOP.LoadEject = Eject;
    cdb.START_STOP.Start     = Start;

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 6,
                            NULL, &size, TRUE)) {
        FPRINTF((OUTPUT, "Error sending Start/Stop unit\n"));
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
SendTimeStamp(
    IN HANDLE CdromHandle,
    IN PUCHAR DateString
    )
{
    CDB cdb;
    SEND_DVD_STRUCTURE_TIMESTAMP timeStamp;
    DWORD size;

    size = sizeof(SEND_DVD_STRUCTURE_TIMESTAMP);

    FPRINTF((OUTPUT, "Sending Timestamp... "));


    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.AsByte[0] = 0xbf;
    cdb.AsByte[7] = 0x0f; // format == time stamp
    cdb.AsByte[8] = (UCHAR)(size >> 8);
    cdb.AsByte[9] = (UCHAR)(size &  0xff);
    
    RtlZeroMemory(&timeStamp, sizeof(SEND_DVD_STRUCTURE_TIMESTAMP));
    if (strlen(DateString) != 14) {
        FPRINTF((OUTPUT, "Incorrect string length for date\n"));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    RtlCopyMemory(timeStamp.Year,   DateString+0x00, 4);
    RtlCopyMemory(timeStamp.Month,  DateString+0x04, 2);
    RtlCopyMemory(timeStamp.Day,    DateString+0x06, 2);
    RtlCopyMemory(timeStamp.Hour,   DateString+0x08, 2);
    RtlCopyMemory(timeStamp.Minute, DateString+0x0a, 2);
    RtlCopyMemory(timeStamp.Second, DateString+0x0c, 2);

    if (!SptSendCdbToDevice(CdromHandle, &cdb, 12,
                            (PUCHAR)&timeStamp, &size, TRUE)) {
        FPRINTF((OUTPUT, "Error sending dvd timestamp\n"));
        return FALSE;
    }

    FPRINTF((OUTPUT, "pass.\n"));
    return TRUE;   
}

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    PDISK_INFORMATION diskInfo;
    DWORD maxSize = sizeof(DISK_INFORMATION);
    DWORD size;

    FPRINTF((OUTPUT, "Verifying blank disc... "));

    diskInfo = LocalAlloc(LPTR, maxSize);
    if (diskInfo == NULL) {
        FPRINTF((OUTPUT, "\nError allocating diskinfo\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    RtlZeroMemory(diskInfo, sizeof(DISK_INFORMATION));
    RtlZeroMemory(&cdb, sizeof(CDB));
    cdb.READ_DISK_INFORMATION.OperationCode = SCSIOP_READ_DISK_INFORMATION;
    cdb.READ_DISK_INFORMATION.AllocationLength[0] = (UCHAR)(maxSize >> 8);
    cdb.READ_DISK_INFORMATION.AllocationLength[1] = (UCHAR)(maxSize & 0xff);

    size = maxSize;
    if (!SptSendCdbToDevice(CdromHandle, &cdb, 10,
                            (PUCHAR)diskInfo, &size, TRUE)) {
        FPRINTF((OUTPUT, "\nError %d getting disk info\n",
                 GetLastError()));
        LocalFree(diskInfo);
        return FALSE;
    }

    if (diskInfo->LastSessionStatus != 0x00) {
        FPRINTF((OUTPUT, "disc is not blank!\n"));
        SetLastError(ERROR_MEDIA_INCOMPATIBLE);
        LocalFree(diskInfo);
        return FALSE;
    }
    FPRINTF((OUTPUT, "pass.\n"));
    LocalFree(diskInfo);
    return TRUE;
}

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PDWORD NumberOfBlocks
    )
{
    BY_HANDLE_FILE_INFORMATION isoImageInfo;
    LONGLONG size;
    
    if (!GetFileInformationByHandle(IsoImageHandle, &isoImageInfo)) {
        FPRINTF((OUTPUT, "Error %d getting file info for iso image\n",
                 GetLastError()));
        return FALSE;
    }

    size  = ((LONGLONG)isoImageInfo.nFileSizeHigh) << 32;
    size |= (LONGLONG)isoImageInfo.nFileSizeLow;

    if ((isoImageInfo.nFileSizeLow % 2048) != 0) {
        FPRINTF((OUTPUT, "Error: The file size is not a multiple of 2048 (%I64d)\n",
                 size));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    FPRINTF((OUTPUT, "File size is %I64d bytes (%d blocks)\n",
             size, size / 2048));
    
    if ((LONGLONG)((size / 2048) >> 32) != 0) {
        FPRINTF((OUTPUT, "Error: The file is too large (%I64d)\n",
                 size));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    
    *NumberOfBlocks = (DWORD)(size / 2048);
    return TRUE;

}

BOOLEAN
VerifyMediaCapacity(
    IN HANDLE CdromHandle,
    IN DWORD  RequiredBlocks
    )
{
    printf("NOT VERIFYING MEDIA CAPACITY!\n");
    return TRUE;   
}

BOOLEAN
WaitForBurnToComplete(
    IN HANDLE CdromHandle
    )
{
    CDB cdb;
    DWORD size;
    DWORD i = 0;

    FPRINTF((OUTPUT, "Waiting for write to finish (long)... "));

    //
    // send flush_cache to synchronize the media and the drive's cache
    //

    RtlZeroMemory(&cdb, sizeof(cdb));
    cdb.SYNCHRONIZE_CACHE10.OperationCode = SCSIOP_SYNCHRONIZE_CACHE;
    size = 0;

    //
    // wait up to ten minutes (600 seconds) for burn to complete
    //

    if (!SptSendCdbToDeviceEx(CdromHandle,
                              &cdb,
                              10,
                              NULL,
                              &size,
                              NULL,
                              0,
                              TRUE,
                              600)) {
        FPRINTF((OUTPUT, "Error %d sending SYNCHRONIZE_CACHE\n",
                 GetLastError()));
        return FALSE;
    }
    
    FPRINTF((OUTPUT, "success\n"));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\strings\strings.c ===
/* STRINGS.C:
 *  This program dumps all the ascii strings in a
 *  file.
 *
 * History:
 * 05-Jan-1992 IanJa obtained from \\toolsvr\contrib\petes\slm\src\TOOLS
 * 05-Jan-1992 IanJa use buffered reads for small efficiency gain
 * 22-Feb-1992 IanJa Unicode strings too if -U used.
 * 17-Feb-1997 RajeevD added -a option
 */
#include                <stdio.h>       /* Standard I/O definitions */
#include                <stdlib.h>      /* Standard atoi types */
#include                <process.h>

#define EOL             "\n"
#define RDBIN           "rb"
#define isascii(c)      ((c) >= ' ' && (c) <= '~')
                                        /* True if char is printable ascii */
#define isswitch(s)     (((s)[0] == '-') || ((s)[0] == '/'))
                                        /* True if string is switch */
#define swchar(s)       ((s)[1])        /* Switch character */
#define MAXLEN          128             /* Max. minimum "string" length */

char                    prognam[] = "strings";
#define USAGE_FMT       "usage: %s [-a][-U][-O][-l <length>]<file list>\n"

#define BUFSZ           512
char inBuf[BUFSZ];

void
__cdecl main(argc,argv)
int                     argc;
char                    **argv;
  {
    FILE                *fi;
    char                save[MAXLEN];
    int                 strlen;
    char                *p;
    int                 nRead;
    int                 i;
    int                 argi;
    long                offset = 0L;
    int                 threshold = 4;
    int                 foffset = 0;
    int                 fUnicode = 0;
    int                 fAnnotate = 0;

    if(argc == 1)
      {
        fprintf(stderr,USAGE_FMT,argv[0]);
        fprintf(stderr,"  -a\tannotates each match with filename\n");
        exit(1);
      }
    for(argi = 1,i = 1; argi < argc; ++argi)
      {
        if(isswitch(argv[argi]))
          {
            switch(swchar(argv[argi]))
              {
                case 'U':
                  fUnicode = 1;
                  break;

                case 'O':
                  foffset = 1;
                  break;

                case 'l':
                  if (argv[argi][2])
                    {
                      threshold = atoi(&argv[argi][2]);
                    }
                  else if(++argi == argc)
                    {
                      fprintf(stderr,"%s: missing length\n",argv[0]);
                      exit(1);
                    }
                  else
                    {
                      threshold = atoi(argv[argi]);
                    }

                  if(threshold > MAXLEN)
                    {
                      fprintf(stderr, "%s: length %d should be <= %d\n",
                        argv[0], threshold, MAXLEN);
                      exit(1);
                    }
                  break;

                case 'a':
                case 'A':
                    fAnnotate = 1;
                    break;

                case '?':
                  fprintf(stderr,USAGE_FMT,argv[0]);
                  fprintf(stderr,"  -a\tannotates each match with filename\n");
                  exit(1);

                default:
                  fprintf(stderr,"%s: unknown switch \"%s\"\n",
                    argv[0],argv[argi]);
                  exit(1);
              }
          }
        else argv[i++] = argv[argi];
      }
    argc = i;
    for(i = 1; i < argc; ++i)
      {
        if((fi = fopen(argv[i],RDBIN)) == NULL)
          {
            fprintf(stderr,"%s: cannot open \"%s\"\n",argv[0],argv[i]);
            continue;
          }
        if (!fAnnotate)
            fprintf(stdout,"%s:\n",argv[i]);
        strlen = 0;
        save[threshold - 1] = '\0';
        while((nRead = fread(inBuf, 1, BUFSZ, fi)) > 0)
          {
          for (p = inBuf; p < &inBuf[nRead]; p++)
            {
              if(isascii(*p))
                {
                  if(strlen < threshold - 1) save[strlen++] = *p;
                  else
                    {
                      if(strlen++ == threshold - 1)
                        {
                          if (fAnnotate)
                              fprintf (stdout, "%s: ", argv[i]);
                          if(foffset) fprintf(stdout,"%06lx: ",
                            offset - threshold + 1);
                                 fputs(save,stdout);
                        }
                      putc(*p,stdout);
                    }
                }
              else
                {
                  if(strlen >= threshold) fputs(EOL,stdout);
                  strlen = 0;
                }
              ++offset;
            }
          if (fUnicode)
            {
            for (p = inBuf; p < &inBuf[nRead-1]; p++)
              {
                if(isascii(*p) && (p[1] == 0x00))
                  {
                    if(strlen < threshold - 1) save[strlen++] = *p;
                    else
                      {
                        if(strlen++ == threshold - 1)
                          {
                            if (fAnnotate)
                                fprintf (stdout, "%s: ", argv[i]);
                            fprintf(stdout, "U: ");
                            if(foffset) fprintf(stdout,"%06lx: ",
                              offset - threshold + 1);
                                   fputs(save,stdout);
                          }
                        putc(*p,stdout);
                      }
                    ++p;
                  }
                else
                  {
                    if(strlen >= threshold) fputs(EOL,stdout);
                    strlen = 0;
                  }
                ++offset;
              }
            }
          }
        if(strlen >= threshold) fputs(EOL,stdout);
        if (!feof(fi))
          {
            fprintf(stderr,"%s: error reading \"%s\"\n",argv[0],argv[i]);
            continue;
          }
        fclose(fi);
      }
    exit(0);
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\lib\sptlibp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sptlibp.h

Abstract:

    private header for SPTLIB.DLL

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#ifndef __SPTLIBP_H__
#define __SPTLIBP_H__
#pragma warning(push)
#pragma warning(disable:4200) // array[0] is not a warning for this file

#include "sptlib.h"

#include <stdio.h>  // required for sscanf() function

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif

typedef struct  {
    SCSI_PASS_THROUGH   Spt;
    char                SenseInfoBuffer[18];
    char                DataBuffer[0];
    // Allocate buffer space after this
} SPT_WITH_BUFFERS, *PSPT_WITH_BUFFERS;

typedef enum _SPT_MODE_PAGE_SIZE {
    SptModePageSizeUndefined   = 0x00,
    SptModePageSizeModeSense6  = 0x06,
    SptModePageSizeModeSense10 = 0x0A
} SPT_MODE_PAGE_SIZE, *PSPT_MODE_PAGE_SIZE;

#define SPT_MODE_PAGE_INFO_SIGNATURE ((ULONGLONG)0x6567615165646f4d) // 'ModePage'

struct _SPT_MODE_PAGE_INFO {
    ULONGLONG Signature;
    ULONG IsInitialized;
    SPT_MODE_PAGE_SIZE ModePageSize;
    union {
        UCHAR                   AsChar;
        MODE_PARAMETER_HEADER   Header6;
        MODE_PARAMETER_HEADER10 Header10;
    } H;
};
    

#pragma warning(pop)
#endif // __SPTLIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\dvdburn\burn.h ===
/*
*/

#include <ntddcdrm.h>
#include <ntddmmc.h>
#include <ntddcdvd.h>

typedef struct _CDVD_WRITE_PARAMETERS_PAGE {
    UCHAR PageCode : 6; // 0x05
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;   // 0x32
    UCHAR WriteType : 4;
    UCHAR TestWrite : 1;
    UCHAR LinkSizeValid : 1;
    UCHAR BufferUnderrunFree : 1;
    UCHAR Reserved2 : 1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR FixedPacket : 1;
    UCHAR MultiSession :2;
    UCHAR DataBlockType : 4;
    UCHAR Reserved3 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode : 7;
    UCHAR Reserved5           : 1;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7               : 7;
    UCHAR MediaCatalogNumberValid : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8                               : 7;
    UCHAR ISRCValid : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
    UCHAR Data[0];
} CDVD_WRITE_PARAMETERS_PAGE, *PCDVD_WRITE_PARAMETERS_PAGE;

typedef struct _SEND_DVD_STRUCTURE_TIMESTAMP {
    UCHAR DataLength[2];
    UCHAR Reserved1[2];
    UCHAR Reserved2[4];
    UCHAR Year[4];
    UCHAR Month[2];
    UCHAR Day[2];
    UCHAR Hour[2];
    UCHAR Minute[2];
    UCHAR Second[2];
} SEND_DVD_STRUCTURE_TIMESTAMP, *PSEND_DVD_STRUCTURE_TIMESTAMP;


DWORD
BurnCommand(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN BOOLEAN Erase
    );

BOOLEAN
BurnThisSession(
    IN HANDLE CdromHandle,
    IN HANDLE IsoImageHandle,
    IN DWORD  NumberOfBlocks,
    IN DWORD  FirstLba
    );

VOID
PrintBuffer(
    IN  PVOID Buffer,
    IN  DWORD  Size
    );

BOOLEAN
ReserveRZone(
    IN HANDLE CdromHandle,
    IN DWORD numberOfBlocks
    );

BOOLEAN
SendStartStopUnit(
    IN HANDLE CdromHandle,
    IN BOOLEAN Start,
    IN BOOLEAN Eject
    );

BOOLEAN
SendTimeStamp(
    IN HANDLE CdromHandle,
    IN PUCHAR DateString
    );

BOOLEAN
SetWriteModePage(
    IN HANDLE CdromHandle,
    IN BOOLEAN TestBurn,
    IN UCHAR WriteType,
    IN UCHAR MultiSession,
    IN UCHAR DataBlockType,
    IN UCHAR SessionFormat
    );

BOOLEAN
VerifyBlankMedia(
    IN HANDLE CdromHandle
    );

BOOLEAN
VerifyIsoImage(
    IN HANDLE IsoImageHandle,
    OUT PDWORD NumberOfBlocks
    );

BOOLEAN
VerifyMediaCapacity(
    IN HANDLE CdromHandle,
    IN DWORD  RequiredBlocks
    );

BOOLEAN
WaitForBurnToComplete(
    IN HANDLE CdromHandle
    );

BOOLEAN
SetWriteModePageDao(
    IN HANDLE CdromHandle
    );

BOOLEAN
EraseMedia(
    IN HANDLE CdromHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\srvname\srvname.cxx ===
/*
 * This program is used to edit the names that the NT LM server is using
 *   on the network (while the LM server is running).
 *
 * Type 'srvname -?' for usage
 *
 *   IsaacHe 3/24/94
 *   
 *   Revision Histroy:
 *   JeffJuny 3/20/97: Fix ANSI/Unicode CRT conversion problem
 *   Mmccr    12/7/98: Added -m option, added param to err
 */

extern "C" {
#include    <nt.h>
#include    <ntrtl.h>
#include    <nturtl.h>
#include    <windows.h>
#include    <stdlib.h>
#include    <stdio.h>
#include    <lm.h>
#include    <string.h>
#include    <locale.h>
}

/*
 * print out an error message and return
 */
static void
err( char *text, WCHAR *name, ULONG code )
{
    int i;
    char msg[ 100 ];

    i = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM | sizeof( msg ),
               NULL,
               code,
               0,
               msg,
               sizeof(msg),
               NULL );
            
    if( i )
        fprintf( stderr, "%s%ws%ws%s %s\n", text?text:"", name?L" - ":L"", name?name:L"", text?" :":"", msg );
    else
        fprintf( stderr, "%s%ws%ws%s error %X\n", text?text:"", name?L" - ":L"", name?name:L"", text?" :":"", code );
}

/*
 * Print out a handy usage message
 */
void
Usage( char *name )
{
    fprintf( stderr, "Usage: %s [ options ] [ name ]\n", name );
    fprintf( stderr, "  Options:\n" );
    fprintf( stderr, "          -s server   point to 'server'\n" );
    fprintf( stderr, "          -d          delete 'name' from the server's list\n" );
    fprintf( stderr, "                        'name' is added by default if -d not present\n" );
    fprintf( stderr, "          -D domain   have 'name' act as if it is in 'domain'\n" );
    fprintf( stderr, "          -m multiple Append numbers from 1 to 'multiple' to 'name'\n" );
    fprintf( stderr, "                        results in machine having multiple + 1 names added\n" );
}

__cdecl
main( int argc, char *argv[] )
{
    DWORD retval;
    DWORD NameMultiple = 0;
    DWORD NumberLength = 0;
    LPWSTR TargetServerName = NULL;
    WCHAR serverNameBuf[ 100 ];
    LPWSTR DomainName = NULL;
    WCHAR domainNameBuf[ 100 ];
    WCHAR newServerNameBuf[ 100 ];
    WCHAR safenewServerNameBuf[ 100 ];	
    LPWSTR NewServerName = NULL;
    CHAR *NewName = NULL;
    CHAR ComputerNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwbuflen =sizeof( ComputerNameBuf );
    BOOLEAN DeleteTheName = FALSE;
    PSERVER_INFO_100 si100;
    DWORD j;
    int i;
    WCHAR wtempbuf[5];
    
    char buf[ 500 ];


    setlocale(LC_ALL, "");
    for( i=1; i < argc; i++ ) {
        if( argv[i][0] == '-' || argv[i][0] == '/' ) {
            switch( argv[i][1] ) {
            case 's':
                if( i == argc-1 ) {
                    fprintf( stderr, "Must supply a server name with -s option\n" );
                    return 1;
                }
                mbstowcs( serverNameBuf, argv[ ++i ], sizeof( serverNameBuf ) );
                TargetServerName = serverNameBuf;
                break;

            case 'D':
                if( DeleteTheName == TRUE ) {
                    fprintf( stderr, "-d and -D can not be used together\n" );
                    return 1;
                }

                if( i == argc-1 ) {
                    fprintf( stderr, "Must supply a domain name with -D option\n" );
                    return 1;
                }
                mbstowcs( domainNameBuf, argv[ ++i ], sizeof( domainNameBuf ) );
                DomainName = domainNameBuf;
                break;

            case 'm':
                if( i == argc-1 ) {
                    fprintf( stderr, "Must supply an integer multiple\n" );
                    return 1;
                }

                NameMultiple = atoi(argv[++i]);

                if( NameMultiple <= 0 ) {
                    fprintf( stderr, "Multiple value is not a valid value\n" );
                    return 1;
                }
                if( NameMultiple > 1024 ) {
                    fprintf( stderr, "Multiple value must not be larger than 1024\n" );
                    return 1;
                }
                NumberLength = strlen(argv[i]);
                break;

            case 'd':
                DeleteTheName = TRUE;
                break;

            default:
                fprintf( stderr, "%s : invalid option\n", argv[i] );
            case '?':
                Usage( argv[0] );
                return 1;
            }
        } else if( NewName == NULL ) {
            NewName = argv[i];
            mbstowcs( newServerNameBuf, NewName, sizeof( newServerNameBuf ) );
            NewServerName = newServerNameBuf;

        } else {
            Usage( argv[0] );
            return 1;
        }
    }

    if( DeleteTheName == TRUE && NewName == NULL ) {
        fprintf( stderr, "You must supply the name to delete\n" );
        return 1;
    }

    if ((NewName == NULL)&&(NameMultiple == 0)) {
        //
        // Print the current list of transports
        //
        DWORD entriesread = 0, totalentries = 0, resumehandle = 0;
        DWORD entriesread1 = 0;
        PSERVER_TRANSPORT_INFO_0 psti0;
        PSERVER_TRANSPORT_INFO_1 psti1;
        DWORD total;

        retval = NetServerTransportEnum ( TargetServerName,
                                          1,
                                          (LPBYTE *)&psti1,
                                          (DWORD)-1,
                                          &entriesread1,
                                          &totalentries,
                                          &resumehandle );

        if( retval != NERR_Success ) {
            entriesread1 = 0;
        }

        resumehandle = 0;
        totalentries = 0;
        retval = NetServerTransportEnum ( TargetServerName,
                                          0,
                                          (LPBYTE *)&psti0,
                                          (DWORD)-1,
                                          &entriesread,
                                          &totalentries,
                                          &resumehandle );

        if( retval != NERR_Success ) {
            err( "Could not get server transports", NULL, retval );
            return retval;
        }

        if( entriesread != totalentries ) {
            fprintf( stderr, "entries read = %d, total entries = %d\n", entriesread, totalentries );
            fprintf( stderr, "Unable to read all the transport names!\n" );
            return 1;
        }

        for( total=i=0; i < (int)entriesread; i++ ) {

            printf( "%-16.16s", psti0[i].svti0_transportaddress );

            if( entriesread1 > (DWORD)i ) {
                printf( "%-16.16ws", psti1[i].svti1_domain);
            }

            printf( " %-58.58ws", psti0[i].svti0_transportname );

            printf( "%4u workstation%s\n", 
                     psti0[i].svti0_numberofvcs,
                     psti0[i].svti0_numberofvcs != 1 ? "s" : "" );

            total += psti0[i].svti0_numberofvcs;
        }
        if( total ) {
            printf( "                                            %s-----\n",
                   entriesread1?"                 ":"" );
            printf( "                                          %s%7u\n",
                   entriesread1?"                 ":"", total );
        }
        return 0;
    }
    else if (NewName == NULL) {
        if (TargetServerName == NULL)
            GetComputerName(newServerNameBuf, &dwbuflen);
        else
            wcscpy(newServerNameBuf, TargetServerName);

        NewServerName = newServerNameBuf;
        wcstombs(ComputerNameBuf, NewServerName, sizeof(ComputerNameBuf));
        NewName = ComputerNameBuf;
    }

    if (strlen(NewName) > MAX_COMPUTERNAME_LENGTH) {
        fprintf( stderr, "The new name you have chosen exceeds the maximum computername length.\n" );
        fprintf( stderr, "Please select a different name.\n" );
        return 1;
    }
    
    if (NameMultiple > 0) {
        if ((NumberLength + strlen(NewName)) > MAX_COMPUTERNAME_LENGTH) {
            i = MAX_COMPUTERNAME_LENGTH - strlen(NewName);
            i = NumberLength - i;
            fprintf( stderr, "The Multiple you have chosen when concatinated with the servername\n" );
            fprintf( stderr, "exceeds the maximum computername length.  Try reducing your\n" );
            if ((DWORD) i == NumberLength) {
                fprintf( stderr, "chosen servernames length.\n");
            }
            else
                fprintf( stderr, "multiple by %d orders of magnitude\n", i );
            return 1;
         }
    }

    wcscpy(safenewServerNameBuf, NewServerName);

    if( DeleteTheName == FALSE ) {
        for (j = 0; j <= NameMultiple; j++)
        {
            if (j) {
                wcscpy(NewServerName, safenewServerNameBuf);
                _itow(j, wtempbuf, 10);
                wcscat(NewServerName, wtempbuf);
            }
            //
            // Add the new name to all of the transports
            //
            retval = NetServerComputerNameAdd( TargetServerName, DomainName, NewServerName );

            if( retval != NERR_Success ) {
                    err( "NetServerComputerNameAdd", NewServerName, retval );
            }
            else {
                printf("Added Name: %ws on Server: %ws%ws%ws\n", 
                           NewServerName, 
                           TargetServerName, 
                           DomainName?L", Domain: ":L"", 
                           DomainName?DomainName:L"");
            }
        }
        return retval;
    }

    //
    // Must be wanting to delete the name from all the networks.
    //

    //
    //  Make sure we don't delete the 'real name' that the server is known by.  Pre 3.51
    //   servers did not ACL protect this api!
    //
    retval = NetServerGetInfo( TargetServerName, 100, (LPBYTE *)&si100 );
    if( retval != STATUS_SUCCESS ) {
        err( "Can not get target server name", NULL, retval );
        return retval;
    }

    if( si100 == NULL ) {
        fprintf( stderr, "NetServerGetInfo returned a NULL ptr, but no error!\n" );
        return 1;
    }

    for (j = 0; j <= NameMultiple; j++)
    {
        if (j) {
            wcscpy(NewServerName, safenewServerNameBuf);
            _itow(j, wtempbuf, 10);
            wcscat(NewServerName, wtempbuf);
        }

        if( !_wcsicmp( si100->sv100_name, NewServerName ) ) {
            fprintf( stderr, "The primary name of %ws is %ws.\n",
                    TargetServerName ? TargetServerName : L"this server",
                    NewServerName );
            fprintf( stderr, "\tYou can not delete the primary name of the server\n" );   
        }
        else {
            retval = NetServerComputerNameDel( TargetServerName, NewServerName );
            if( retval != STATUS_SUCCESS ) {
               err( "NetServerComputerNameDelete", NewServerName, retval );
            }
            else {
                printf("Deleted Name: %ws on Server: %ws%ws%ws\n", 
                           NewServerName, 
                           TargetServerName, 
                           DomainName?L", Domain: ":L"", 
                           DomainName?DomainName:L"");
            }
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\startpgm\startpgm.c ===
/*
 * startpgm.c
 *
 *  Copyright (c) 1990,  Microsoft Corporation
 *
 *  DESCRIPTION
 *
 *  MODIFICATION HISTORY
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <winuserp.h>

HWND
GetWindowHandleOfConsole( void );

HANDLE
PassArgsAndEnvironmentToEditor(
    int argc,
    char *argv[],
    char *envp[],
    HWND hwndSelf
    );

void
Usage( void )
{
    printf( "Usage: STARTPGM [-z] [-s] -j \"Title string\"\n" );
    printf( "where: -j specifies the title string of the window to jump to\n" );
    printf( "          The match done against the title is a case insensitive prefix match\n" );
    printf( "       -s specifies the match can be anywhere in the title.\n" );
    printf( "       -z specifies destination window is an editor and the remaining command line\n" );
    printf( "          arguments and the current environment variable settings are passed to the editor via shared memory\n" );
    exit( 1 );
}




int
__cdecl main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOL JumpToEditor;
    BOOL WaitForEditor;
    BOOL VerboseOutput;
    BOOL SubstringOkay;
    HANDLE EditorStopEvent;
    LPSTR TitleToJumpTo;
    int n;
    HWND hwnd, hwndSelf;
    UINT ShowCmd;
    WINDOWPLACEMENT WindowPlacement;
    wchar_t uszTitle[ 256 ];
    char *s, szTitle[ 256 ];
    int EditorArgc;
    char **EditorArgv;

    JumpToEditor = FALSE;
    WaitForEditor = FALSE;
    VerboseOutput = FALSE;
    SubstringOkay = FALSE;
    TitleToJumpTo = NULL;
    while (--argc) {
        s = *++argv;
        if (*s == '/' || *s == '-') {
            while (*++s) {
                switch( tolower( *s ) ) {
                    case 'z':
                        JumpToEditor = TRUE;
                        if (*s == 'Z') {
                            WaitForEditor = TRUE;
                            }
                        break;

                    case 'v':
                        VerboseOutput = TRUE;
                        break;

                    case 's':
                        SubstringOkay = TRUE;
                        break;

                    case 'j':
                        if (!--argc) {
                            fprintf( stderr, "STARTPGM: Missing title string argument to -j switch\n" );
                            Usage();
                            }
                        TitleToJumpTo = *++argv;
                        _strupr( TitleToJumpTo );        // Case insensitive compares
                        n = strlen( TitleToJumpTo );
                        break;

                    default:
                        fprintf( stderr, "STARTPGM: Invalid switch - /%c\n", *s );
                        Usage();
                    }
                }
            }
        else {
            break;
            }
        }

    if (TitleToJumpTo == NULL) {
        fprintf( stderr, "STARTPGM: -j switch missing.\n" );
        Usage();
        }

    if (JumpToEditor) {
        EditorArgc = argc;
        EditorArgv = argv;
        }

    /*
     * Search the window list for enabled top level windows.
     */
    hwnd = GetWindow( GetDesktopWindow(), GW_CHILD );
    while (hwnd) {
        /*
         * Only look at visible, non-owned, Top Level Windows.
         */
        if (IsWindowVisible( hwnd ) && !GetWindow( hwnd, GW_OWNER )) {
            //
            // Use internal call to get current Window title that does NOT
            // use SendMessage to query the title from the window procedure
            // but instead returns the most recent title displayed.
            //

            InternalGetWindowText( hwnd,
                                   (LPWSTR)uszTitle,
                                   sizeof( szTitle )
                                 );
            wcstombs( szTitle, uszTitle, sizeof( uszTitle ) );
            _strupr( szTitle );        // Case insensitive compares

            if (strlen( szTitle )) {
                if (VerboseOutput) {
                    printf( "Looking at window title: '%s'\n", szTitle );
                    }

                if (SubstringOkay) {
                    if (strstr( szTitle, "STARTPGM" )) {
                        // Ignore window with ourselve running
                        }
                    else
                    if (strstr( szTitle, TitleToJumpTo )) {
                        break;
                        }
                    }
                else
                if (!_strnicmp( TitleToJumpTo, szTitle, n )) {
                    break;
                    }
                }
            }

        hwnd = GetWindow( hwnd, GW_HWNDNEXT );
        }

    if (hwnd == NULL) {
        printf( "Unable to find window with '%s' title\n", TitleToJumpTo );
        exit( 1 );
        }
    else
    if (IsWindow( hwnd )) {
        if (JumpToEditor) {
            hwndSelf = GetWindowHandleOfConsole();
            if (VerboseOutput) {
                printf( "Calling editor with: '" );
                while (argc--) {
                    printf( "%s%s", *argv++, !argc ? "" : " " );
                    }
                printf( "'\n" );
                }

            EditorStopEvent = PassArgsAndEnvironmentToEditor( EditorArgc,
                                                              EditorArgv,
                                                              envp,
                                                              hwndSelf
                                                            );
            }

        SetForegroundWindow( hwnd );

        ShowCmd = SW_SHOW;
        WindowPlacement.length = sizeof( WindowPlacement );
        if (GetWindowPlacement( hwnd, &WindowPlacement )) {
            if (WindowPlacement.showCmd == SW_SHOWMINIMIZED) {
                ShowCmd = SW_RESTORE;
                }
            }
        ShowWindow( hwnd, ShowCmd );

        if (WaitForEditor && EditorStopEvent != NULL) {
            WaitForSingleObject( EditorStopEvent, (DWORD)-1 );
            CloseHandle( EditorStopEvent );
            }
        }

    exit( 0 );
    return( 0 );
}


HANDLE
PassArgsAndEnvironmentToEditor(
    int argc,
    char *argv[],
    char *envp[],
    HWND hwndSelf
    )
{
    HANDLE EditorStartEvent;
    HANDLE EditorStopEvent;
    HANDLE EditorSharedMemory;
    char *s;
    char *p;

    EditorStartEvent = OpenEvent( EVENT_ALL_ACCESS, FALSE, "EditorStartEvent" );
    if (!EditorStartEvent) {
        printf( "Unable to pass parameters to editor (can't open EditorStartEvent).\n" );
        return NULL;
        }

    EditorStopEvent = OpenEvent( EVENT_ALL_ACCESS, FALSE, "EditorStopEvent" );
    if (!EditorStopEvent) {
        printf( "Unable to pass parameters to editor (can't open EditorStopEvent).\n" );
        CloseHandle( EditorStartEvent );
        return NULL;
        }

    EditorSharedMemory = OpenFileMapping( FILE_MAP_ALL_ACCESS, FALSE, "EditorSharedMemory" );
    if (!EditorSharedMemory) {
        printf( "Unable to pass parameters to editor (can't open EditorSharedMemory).\n" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        return NULL;
        }

    p = (char *)MapViewOfFile( EditorSharedMemory,
                               FILE_MAP_WRITE | FILE_MAP_READ,
                               0,
                               0,
                               0
                             );
    if (p == NULL) {
        printf( "Unable to pass parameters to editor (can't mapped EditorSharedMemory).\n" );
        CloseHandle( EditorStopEvent );
        CloseHandle( EditorStartEvent );
        CloseHandle( EditorSharedMemory );
        return NULL;
        }

    *(HWND *)p = hwndSelf;
    p += sizeof( hwndSelf );

    p += GetCurrentDirectory( MAX_PATH, p );
    *p++ = '\0';

    while (argc--) {
        s = *argv++;
        while (*p++ = *s++) {
            }

        if (argc) {
            p[-1] = ' ';
            }
        else {
            p--;
            }
        }
    *p++ = '\0';

    while (s = *envp++) {
        while (*p++ = *s++) {
            }
        }
    *p++ = '\0';

    CloseHandle( EditorSharedMemory );

    SetEvent( EditorStartEvent );
    CloseHandle( EditorStartEvent );

    ResetEvent( EditorStopEvent );
    return EditorStopEvent;
}


HWND
GetWindowHandleOfConsole( void )
{
    #define MY_BUFSIZE 1024                 // buffer size for console window titles
    HWND hwndFound;                         // this is what we return to the caller
    char pszNewWindowTitle[ MY_BUFSIZE ];   // contains fabricated WindowTitle
    char pszOldWindowTitle[ MY_BUFSIZE ];   // contains original WindowTitle

    // fetch current window title

    GetConsoleTitle( pszOldWindowTitle, MY_BUFSIZE );

    // format a "unique" NewWindowTitle

    wsprintf( pszNewWindowTitle, "%d/%d", GetTickCount(), GetCurrentProcessId() );

    // change current window title

    SetConsoleTitle( pszNewWindowTitle );

    // insure window title has been updated

    Sleep(40);

    // look for NewWindowTitle

    hwndFound = FindWindow( NULL, pszNewWindowTitle );

    // restore original window title

    SetConsoleTitle( pszOldWindowTitle );

    return( hwndFound );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\socode.c ===
/****************************** Module Header ******************************\
* Module Name: socode.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* What a hack!
* This should be provided as a library, DLL or as C file to be included
*  by anyone using this.
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

#define T1 "\t"
#define T2 "\t\t"
#define T3 "\t\t\t"
#define L01(sz1) #sz1,
#define L11(sz1) T1 #sz1,
#define L21(sz1) T2 #sz1,
#define L31(sz1) T3 #sz1,
#define L02(sz1, sz2) #sz1 ", " #sz2,
#define L12(sz1, sz2) T1 #sz1 ", " #sz2,

char * gpszHeader [] = {

L01(typedef struct tagSTRUCTUREOFFSETSTABLE {)
L11(    char * pszField;)
L11(    unsigned long dwOffset;)
L02(} STRUCTUREOFFSETSTABLE, *PSTRUCTUREOFFSETSTABLE;\r\n)

L01(typedef struct tagSTRUCTURESTABLE {)
L11(    char * pszName;)
L11(    unsigned long dwSize;)
L11(    PSTRUCTUREOFFSETSTABLE psot;)
L02(} STRUCTURESTABLE, *PSTRUCTURESTABLE;\r\n)

NULL
} ;

char * gpszTail [] = {
L01(#include "dsocode.c")
NULL
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\spt\lib\sptlib.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spt.c

Abstract:

    A user mode library that allows simple commands to be sent to a
    selected scsi device.

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#include "sptlibp.h"


BOOL
SptUtilValidateCdbLength(
    IN PCDB Cdb,
    IN UCHAR CdbSize
    )
{
    UCHAR commandGroup = (Cdb->AsByte[0] >> 5) & 0x7;
    
    switch (commandGroup) {
    case 0:
        return (CdbSize ==  6);
    case 1:
    case 2:
        return (CdbSize == 10);
    case 5:
        return (CdbSize == 12);
    default:
        return TRUE;
    }
}

BOOL
SptSendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PUCHAR  Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN GetDataFromDevice
    )
{
    return SptSendCdbToDeviceEx(DeviceHandle,
                             Cdb,
                             CdbSize,
                             Buffer,
                             BufferSize,
                             NULL,
                             0,
                             GetDataFromDevice,
                             SPT_DEFAULT_TIMEOUT
                             );
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
BOOL
SptSendCdbToDeviceEx(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN OUT  PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
       OUT  PSENSE_DATA SenseData OPTIONAL,
    IN      UCHAR       SenseDataSize,
    IN      BOOLEAN     GetDataFromDevice,
    IN      DWORD       TimeOut                    // in seconds
    )
{
    PSPT_WITH_BUFFERS p;
    DWORD packetSize;
    DWORD returnedBytes;
    BOOL returnValue;
    PSENSE_DATA senseBuffer;
    BOOL copyData;
    
    if ((SenseDataSize == 0) && (SenseData != NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if ((SenseDataSize != 0) && (SenseData == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if (SenseData && SenseDataSize) {
        RtlZeroMemory(SenseData, SenseDataSize);
    }

    if (Cdb == NULL) {
        // cannot send NULL cdb
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (CdbSize < 1 || CdbSize > 16) {
        // Cdb size too large or too small for this library currently
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!SptUtilValidateCdbLength(Cdb, CdbSize)) {
        // OpCode Cdb->AsByte[0] is not size CdbSize
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    if (BufferSize == NULL) {
        // BufferSize pointer cannot be NULL
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if ((*BufferSize != 0) && (Buffer == NULL)) {
        // buffer cannot be NULL if *BufferSize is non-zero
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize == 0) && (Buffer != NULL)) {
        // buffer must be NULL if *BufferSize is zero
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((*BufferSize) && GetDataFromDevice) {

        //
        // pre-zero output buffer (not input buffer)
        //

        memset(Buffer, 0, (*BufferSize));
    }

    packetSize = sizeof(SPT_WITH_BUFFERS) + (*BufferSize);
    p = (PSPT_WITH_BUFFERS)LocalAlloc(LPTR, packetSize);
    if (p == NULL) {
        // could not allocate memory for pass-through
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // this has the side effect of pre-zeroing the output buffer 
    // if DataIn is TRUE, the SenseData (always), etc.
    //

    memset(p, 0, packetSize);
    memcpy(p->Spt.Cdb, Cdb, CdbSize);

    p->Spt.Length             = sizeof(SCSI_PASS_THROUGH);
    p->Spt.CdbLength          = CdbSize;
    p->Spt.SenseInfoLength    = SENSE_BUFFER_SIZE;
    p->Spt.DataIn             = (GetDataFromDevice ? 1 : 0);
    p->Spt.DataTransferLength = (*BufferSize);
    p->Spt.TimeOutValue       = TimeOut;
    p->Spt.SenseInfoOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, SenseInfoBuffer[0]);
    p->Spt.DataBufferOffset =
        FIELD_OFFSET(SPT_WITH_BUFFERS, DataBuffer[0]);

    if ((*BufferSize != 0) && (!GetDataFromDevice)) {
        
        //
        // if we're sending the device data, copy the user's buffer
        //

        RtlCopyMemory(&(p->DataBuffer[0]), Buffer, *BufferSize);

    }

    returnedBytes = 0;
    
    returnValue = DeviceIoControl(DeviceHandle,
                                  IOCTL_SCSI_PASS_THROUGH,
                                  p,
                                  packetSize,
                                  p,
                                  packetSize,
                                  &returnedBytes,
                                  FALSE);

    senseBuffer = (PSENSE_DATA)p->SenseInfoBuffer;
    
    copyData = FALSE;

    if (senseBuffer->SenseKey & 0xf) {

        UCHAR length;
        
        // determine appropriate length to return
        length = senseBuffer->AdditionalSenseLength;
        length += RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
        if (length > SENSE_BUFFER_SIZE) {
            length = SENSE_BUFFER_SIZE;
        }
        length = min(length, SenseDataSize);

        // copy the sense data back to the user regardless
        RtlCopyMemory(SenseData, senseBuffer, length);

        returnValue = FALSE;     // some error (possibly recovered) occurred
        copyData = TRUE;         // copy data anyways


    } else if (p->Spt.ScsiStatus != 0) {  // scsi protocol error
    
        returnValue = FALSE;     // command failed

    } else if (!returnValue) {
        
        // returnValue = returnValue;
    
    } else {

        copyData = TRUE;

    }
    
    if (copyData && GetDataFromDevice) {

        //
        // upon successful completion of a command getting data from the
        // device, copy the returned data back to the user.
        //

        if (*BufferSize > p->Spt.DataTransferLength) {
            *BufferSize = p->Spt.DataTransferLength;
        }
        memcpy(Buffer, p->DataBuffer, *BufferSize);

    }

    //
    // free our memory and return
    //

    LocalFree(p);
    return returnValue;
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
VOID
SptDeleteModePageInfo(
    IN PSPT_MODE_PAGE_INFO ModePageInfo
    )
{
//    ASSERT(ModePageInfo != NULL); BUGBUG
//    ASSERT(ModePageInfo->Signature == SPT_MODE_PAGE_INFO_SIGNATURE); BUGBUG
    LocalFree(ModePageInfo);
    return;
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
BOOL
SptUpdateModePageInfo(
    IN HANDLE              DeviceHandle,
    IN PSPT_MODE_PAGE_INFO ModePageInfo
    )
{
    SENSE_DATA senseData;
    BOOLEAN retry = FALSE;
    DWORD error;
    DWORD delay;

    CDB cdb;
    DWORD attemptNumber = 0;
    BOOL success;

    if ((DeviceHandle == INVALID_HANDLE_VALUE) ||
        (ModePageInfo == NULL) ||
        (!ModePageInfo->IsInitialized) ||
        (ModePageInfo->Signature != SPT_MODE_PAGE_INFO_SIGNATURE)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if ((ModePageInfo->ModePageSize != SptModePageSizeModeSense6) &&
        (ModePageInfo->ModePageSize != SptModePageSizeModeSense10)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

RetryUpdateModePage:

    attemptNumber ++;
    
    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&senseData, sizeof(SENSE_DATA));
    
    if (ModePageInfo->ModePageSize == SptModePageSizeModeSense6) {

        DWORD sizeToGet = sizeof(MODE_PARAMETER_HEADER);

        cdb.MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb.MODE_SENSE.PageCode = 0x3f;
        cdb.MODE_SENSE.AllocationLength = sizeof(MODE_PARAMETER_HEADER);

        success = SptSendCdbToDeviceEx(DeviceHandle,
                                       &cdb,
                                       6,
                                       &(ModePageInfo->H.AsChar),
                                       &sizeToGet,
                                       &senseData,
                                       sizeof(SENSE_DATA),
                                       TRUE,
                                       SPT_MODE_SENSE_TIMEOUT);
            
    } else {

        DWORD sizeToGet = sizeof(MODE_PARAMETER_HEADER10);

        cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
        cdb.MODE_SENSE10.PageCode = 0x3f;
        cdb.MODE_SENSE10.AllocationLength[0] = sizeof(MODE_PARAMETER_HEADER10);
    
        success = SptSendCdbToDeviceEx(DeviceHandle,
                                       &cdb,
                                       10,
                                       &(ModePageInfo->H.AsChar),
                                       &sizeToGet,
                                       &senseData,
                                       sizeof(SENSE_DATA),
                                       TRUE,
                                       SPT_MODE_SENSE_TIMEOUT);
    }
    
    if (!success) {
        return FALSE;
    }

    //
    // if the pass-through succeeded, we need to still determine if the
    // actual CDB succeeded.  use the InterpretSenseInfo() routine.
    //

    SptUtilInterpretSenseInfo(&senseData,
                              sizeof(SENSE_DATA),
                              &error,
                              &retry,
                              &delay);

    if (error != ERROR_SUCCESS) {

        if (retry && (attemptNumber < MAXIMUM_DEFAULT_RETRIES)) {

            if (delay != 0) {
                // sleep?
            }
            
            goto RetryUpdateModePage;
        }
        
        // else the error was not worth retrying, or we've retried too often.
        SetLastError(error);
        return FALSE;

    }

    //
    // the command succeeded.
    //
    
    if (ModePageInfo->ModePageSize == SptModePageSizeModeSense6) {
        ModePageInfo->H.Header6.ModeDataLength = 0;
    } else {
        ModePageInfo->H.Header10.ModeDataLength[0] = 0;
        ModePageInfo->H.Header10.ModeDataLength[1] = 0;
    }

    return TRUE;
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
PSPT_MODE_PAGE_INFO
SptInitializeModePageInfo(
    IN     HANDLE                DeviceHandle
    )
{
    PSPT_MODE_PAGE_INFO localInfo;
    DWORD i;

    localInfo = LocalAlloc(LPTR, sizeof(SPT_MODE_PAGE_INFO));
    if (localInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // try both 10 and 6 byte mode sense commands
    //          

    for (i = 0; i < 2; i++) {

        RtlZeroMemory(localInfo, sizeof(SPT_MODE_PAGE_INFO));
        localInfo->IsInitialized = TRUE;
        localInfo->Signature = SPT_MODE_PAGE_INFO_SIGNATURE;

        if ( i == 0 ) {
            localInfo->ModePageSize = SptModePageSizeModeSense10;
        } else {
            localInfo->ModePageSize = SptModePageSizeModeSense6;
        }

        if (SptUpdateModePageInfo(DeviceHandle, localInfo)) {
            return localInfo;
        }        
    }
    LocalFree(localInfo);
    
    return NULL;
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
BOOL
SptGetModePage(
    IN     HANDLE              DeviceHandle,
    IN     PSPT_MODE_PAGE_INFO ModePageInfo,
    IN     UCHAR               ModePage,
       OUT PUCHAR              Buffer,
    IN OUT PDWORD              BufferSize,
       OUT PDWORD              AvailableModePageData OPTIONAL
    )
{
    PUCHAR localBuffer = NULL;
    DWORD localBufferSize = 0;
    SENSE_DATA senseData;
    CDB cdb;
    DWORD thisAttempt = 0;
    BOOL success;

    DWORD  finalPageSize;
    PUCHAR finalPageStart;


    if ((DeviceHandle == INVALID_HANDLE_VALUE) ||
        (ModePageInfo == NULL) ||
        (!ModePageInfo->IsInitialized) ||
        (ModePageInfo->Signature != SPT_MODE_PAGE_INFO_SIGNATURE) ||
        (ModePageInfo->ModePageSize == SptModePageSizeUndefined) ||
        (ModePage & 0xC0)) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        
    }
    if (((BufferSize == 0) && (Buffer != NULL)) ||
        ((BufferSize != 0) && (Buffer == NULL))) {
        
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    }

    if ((ModePageInfo->ModePageSize != SptModePageSizeModeSense6) &&
        (ModePageInfo->ModePageSize != SptModePageSizeModeSense10)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    localBufferSize = 0;
    
    if (BufferSize != NULL) {
        localBufferSize += *BufferSize;
    }

    if (ModePageInfo->ModePageSize == SptModePageSizeModeSense6) {

        localBufferSize += sizeof(MODE_PARAMETER_HEADER);
        localBufferSize += ModePageInfo->H.Header6.BlockDescriptorLength;
        if (localBufferSize > 0xff) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

    } else {

        localBufferSize += sizeof(MODE_PARAMETER_HEADER);
        localBufferSize += ModePageInfo->H.Header10.BlockDescriptorLength[0] * 256;
        localBufferSize += ModePageInfo->H.Header10.BlockDescriptorLength[1];
        if (localBufferSize > 0xffff) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        
    }    

    localBuffer = LocalAlloc(LPTR, localBufferSize);
    if (localBuffer == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

RetryGetModePage:

    thisAttempt ++;

    RtlZeroMemory(&cdb, sizeof(CDB));
    RtlZeroMemory(&senseData, sizeof(SENSE_DATA));
    RtlZeroMemory(localBuffer, localBufferSize);

    if (ModePageInfo->ModePageSize == SptModePageSizeModeSense6) {

        DWORD sizeToGet = localBufferSize;
        cdb.MODE_SENSE.OperationCode = SCSIOP_MODE_SENSE;
        cdb.MODE_SENSE.PageCode = ModePage;
        cdb.MODE_SENSE.AllocationLength = (UCHAR)localBufferSize;

        success = SptSendCdbToDeviceEx(DeviceHandle,
                                       &cdb,
                                       6,
                                       localBuffer,
                                       &sizeToGet,
                                       &senseData,
                                       sizeof(SENSE_DATA),
                                       TRUE,
                                       SPT_MODE_SENSE_TIMEOUT);

    } else {

        DWORD sizeToGet = localBufferSize;
        cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
        cdb.MODE_SENSE10.PageCode = ModePage;
        cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(localBufferSize >> 8);
        cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(localBufferSize & 0xff);
    
        success = SptSendCdbToDeviceEx(DeviceHandle,
                                       &cdb,
                                       10,
                                       localBuffer,
                                       &sizeToGet,
                                       &senseData,
                                       sizeof(SENSE_DATA),
                                       TRUE,
                                       SPT_MODE_SENSE_TIMEOUT);
    }

    //
    // if the pass-through failed, we need to still determine if the
    // actual CDB succeeded.  use the InterpretSenseInfo() routine.
    //
    
    if (!success) {
        LocalFree( localBuffer );
        return FALSE;
    }

    {
        DWORD interpretedError;
        BOOLEAN retry;
        DWORD delay;

        SptUtilInterpretSenseInfo(&senseData,
                                  sizeof(SENSE_DATA),
                                  &interpretedError,
                                  &retry,
                                  &delay);

        if (interpretedError != ERROR_SUCCESS) {
            if ((retry == FALSE) || (thisAttempt > MAXIMUM_DEFAULT_RETRIES)){
                SetLastError(interpretedError);
                LocalFree( localBuffer );
                return FALSE;
            }

            // BUGBUG - sleep?
            goto RetryGetModePage;
        }
    }

    //
    // the transfer succeeded.  now to transfer the info back to
    // the caller.
    //
    
    if (ModePageInfo->ModePageSize == SptModePageSizeModeSense6) {

        PMODE_PARAMETER_HEADER header6 = (PMODE_PARAMETER_HEADER)localBuffer;
        finalPageSize  = header6->ModeDataLength + 1; // length field itself.   

        finalPageStart = localBuffer;        
        finalPageStart += sizeof(MODE_PARAMETER_HEADER);
        finalPageSize  -= sizeof(MODE_PARAMETER_HEADER);
        finalPageStart += header6->BlockDescriptorLength;
        finalPageSize  -= header6->BlockDescriptorLength;

    } else {

        PMODE_PARAMETER_HEADER10 header10 = (PMODE_PARAMETER_HEADER10)localBuffer;
        finalPageSize  = header10->ModeDataLength[0] * 256;
        finalPageSize += header10->ModeDataLength[1];
        finalPageSize += 2; // length field itself.

        finalPageStart = localBuffer;        
        finalPageStart += sizeof(MODE_PARAMETER_HEADER10);
        finalPageSize  -= sizeof(MODE_PARAMETER_HEADER10);
        finalPageStart += header10->BlockDescriptorLength[0] * 256;
        finalPageStart += header10->BlockDescriptorLength[1];
        finalPageSize  -= header10->BlockDescriptorLength[0] * 256;
        finalPageSize  -= header10->BlockDescriptorLength[1];
        
    }

    //
    // finalPageStart now points to the page start
    // finalPageSize  says how much of the data is valid
    //

    //
    // allow the user to distinguish between available data
    // and the amount we actually returned that was usable.
    //
    
    if (AvailableModePageData != NULL) {
        *AvailableModePageData = finalPageSize;
    }

    //
    // if the expected buffer size is greater than the device
    // returned, update the user's available size info
    //
    
    if (*BufferSize > finalPageSize) {
        *BufferSize = finalPageSize;
    }

    //
    // finally, copy whatever data is available to the user's buffer.
    //
    
    if (*BufferSize != 0) {
        RtlCopyMemory(Buffer, localBuffer, *BufferSize);
    }

    return TRUE;
}

/*++

Routine Description:

Arguments:

Return Value:

--*/
BOOL
SptSetModePage(
    IN     HANDLE              DeviceHandle,
    IN     PSPT_MODE_PAGE_INFO ModePageSize,
    IN     SPT_MODE_PAGE_TYPE  ModePageType,
    IN     UCHAR               ModePage,
       OUT PUCHAR              Buffer,
    IN OUT PDWORD              BufferSize
    )
{
    SetLastError(ERROR_INVALID_FUNCTION);
    return FALSE;
}

/*++

Routine Description:

    NOTE: we default to RETRY==TRUE except for known error classes

Arguments:

Return Value:


--*/
VOID
SptUtilInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL
    )
{
    DWORD   error;
    DWORD   retryDelay;
    BOOLEAN retry;
    UCHAR   senseKey;
    UCHAR   asc;
    UCHAR   ascq;

    if (SenseDataSize == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_IO_DEVICE;
        goto SetAndExit;

    }

    //
    // default to suggesting a retry in 1/10 of a second,
    // with a status of ERROR_IO_DEVICE.
    //
    retry = TRUE;
    retryDelay = 1;
    error = ERROR_IO_DEVICE;

    //
    // if the device didn't provide any sense this time, return.
    //

    if ((SenseData->SenseKey & 0xf) == 0) {
        retry = FALSE;
        retryDelay = 0;
        error = ERROR_SUCCESS;
        goto SetAndExit;
    }


    //
    // if we can't even see the sense key, just return.
    // can't use bitfields in these macros, so use next field.
    //

    if (SenseDataSize < FIELD_OFFSET(SENSE_DATA, Information)) {
        goto SetAndExit;
    }
    
    senseKey = SenseData->SenseKey;


    { // set the size to what's actually useful.
        UCHAR validLength;
        // figure out what we could have gotten with a large sense buffer
        if (SenseDataSize <
            RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength)) {
            validLength = SenseDataSize;
        } else {
            validLength =
                RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseLength);
            validLength += SenseData->AdditionalSenseLength;
        }
        // use the smaller of the two values.
        SenseDataSize = min(SenseDataSize, validLength);
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCode)) {
        asc = SCSI_ADSENSE_NO_SENSE;
    } else {
        asc = SenseData->AdditionalSenseCode;
    }

    if (SenseDataSize <
        RTL_SIZEOF_THROUGH_FIELD(SENSE_DATA, AdditionalSenseCodeQualifier)) {
        ascq = SCSI_SENSEQ_CAUSE_NOT_REPORTABLE; // 0x00
    } else {
        ascq = SenseData->AdditionalSenseCodeQualifier;
    }

    //
    // interpret :P
    //

    switch (senseKey & 0xf) {
    
    case SCSI_SENSE_RECOVERED_ERROR: {  // 0x01
        if (SenseData->IncorrectLength) {
            error = ERROR_INVALID_BLOCK_LENGTH;
        } else {
            error = ERROR_SUCCESS;
        }
        retry = FALSE;
        break;
    } // end SCSI_SENSE_RECOVERED_ERROR

    case SCSI_SENSE_NOT_READY: { // 0x02
        error = ERROR_NOT_READY;

        switch (asc) {

        case SCSI_ADSENSE_LUN_NOT_READY: {
            
            switch (ascq) {

            case SCSI_SENSEQ_BECOMING_READY:
            case SCSI_SENSEQ_OPERATION_IN_PROGRESS: {
                retryDelay = SPT_NOT_READY_RETRY_INTERVAL;
                break;
            }

            case SCSI_SENSEQ_CAUSE_NOT_REPORTABLE:
            case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
            case SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS: {
                retry = FALSE;
                break;
            }

            case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED: {
                retry = FALSE;
                break;
            }
            
            } // end switch (senseBuffer->AdditionalSenseCodeQualifier)
            break;
        }

        case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE: {
            error = ERROR_NOT_READY;
            retry = FALSE;
            break;
        }
        } // end switch (senseBuffer->AdditionalSenseCode)

        break;
    } // end SCSI_SENSE_NOT_READY
    
    case SCSI_SENSE_MEDIUM_ERROR: { // 0x03
        error = ERROR_CRC;
        retry = FALSE;

        //
        // Check if this error is due to unknown format
        //
        if (asc == SCSI_ADSENSE_INVALID_MEDIA) {
            
            switch (ascq) {

            case SCSI_SENSEQ_UNKNOWN_FORMAT: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                break;
            }

            case SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED: {
                error = ERROR_UNRECOGNIZED_MEDIA;
                //error = ERROR_CLEANER_CARTRIDGE_INSTALLED;
                break;
            }
            
            } // end switch AdditionalSenseCodeQualifier

        } // end SCSI_ADSENSE_INVALID_MEDIA
        break;
    } // end SCSI_SENSE_MEDIUM_ERROR

    case SCSI_SENSE_ILLEGAL_REQUEST: { // 0x05
        error = ERROR_INVALID_FUNCTION;
        retry = FALSE;
        
        switch (asc) {

        case SCSI_ADSENSE_ILLEGAL_BLOCK: {
            error = ERROR_SECTOR_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_INVALID_LUN: {
            error = ERROR_FILE_NOT_FOUND;
            break;
        }

        case SCSI_ADSENSE_COPY_PROTECTION_FAILURE: {
            error = ERROR_FILE_ENCRYPTED;
            //error = ERROR_SPT_LIB_COPY_PROTECTION_FAILURE;
            switch (ascq) {
                case SCSI_SENSEQ_AUTHENTICATION_FAILURE:
                    //error = ERROR_SPT_LIB_AUTHENTICATION_FAILURE;
                    break;
                case SCSI_SENSEQ_KEY_NOT_PRESENT:
                    //error = ERROR_SPT_LIB_KEY_NOT_PRESENT;
                    break;
                case SCSI_SENSEQ_KEY_NOT_ESTABLISHED:
                    //error = ERROR_SPT_LIB_KEY_NOT_ESTABLISHED;
                    break;
                case SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION:
                    //error = ERROR_SPT_LIB_SCRAMBLED_SECTOR;
                    break;
                case SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT:
                    //error = ERROR_SPT_LIB_REGION_MISMATCH;
                    break;
                case SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR:
                    //error = ERROR_SPT_LIB_RESETS_EXHAUSTED;
                    break;
            } // end switch of ASCQ for COPY_PROTECTION_FAILURE
            break;
        }

        } // end switch (senseBuffer->AdditionalSenseCode)
        break;
        
    } // end SCSI_SENSE_ILLEGAL_REQUEST

    case SCSI_SENSE_DATA_PROTECT: { // 0x07
        error = ERROR_WRITE_PROTECT;
        retry = FALSE;
        break;
    } // end SCSI_SENSE_DATA_PROTECT

    case SCSI_SENSE_BLANK_CHECK: { // 0x08
        error = ERROR_NO_DATA_DETECTED;
        break;
    } // end SCSI_SENSE_BLANK_CHECK

    case SCSI_SENSE_NO_SENSE: { // 0x00
        if (SenseData->IncorrectLength) {    
            error = ERROR_INVALID_BLOCK_LENGTH;
            retry   = FALSE;    
        } else {
            error = ERROR_IO_DEVICE;
        }
        break;
    } // end SCSI_SENSE_NO_SENSE

    case SCSI_SENSE_HARDWARE_ERROR:  // 0x04
    case SCSI_SENSE_UNIT_ATTENTION: // 0x06
    case SCSI_SENSE_UNIQUE:          // 0x09
    case SCSI_SENSE_COPY_ABORTED:    // 0x0A
    case SCSI_SENSE_ABORTED_COMMAND: // 0x0B
    case SCSI_SENSE_EQUAL:           // 0x0C
    case SCSI_SENSE_VOL_OVERFLOW:    // 0x0D
    case SCSI_SENSE_MISCOMPARE:      // 0x0E
    case SCSI_SENSE_RESERVED:        // 0x0F
    default: {
        error = ERROR_IO_DEVICE;
        break;
    }

    } // end switch(SenseKey)

SetAndExit:

    if (ARGUMENT_PRESENT(SuggestRetry)) {
        *SuggestRetry = retry;
    }
    if (ARGUMENT_PRESENT(SuggestRetryDelay)) {
        *SuggestRetryDelay = retryDelay;
    }
    *ErrorValue = error;

    return;


}

/*++

Routine Description:

Arguments:

Return Value:

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\soglobal.c ===
/****************************** Module Header ******************************\
* Module Name: soglobal.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* Globals
\***************************************************************************/

char gszStructTag [] = "typedef struct";

char gszPrecomph [] = "#include \"precomp.h\"\r\n#pragma hdrstop\r\n\r\n";
char gszIncInput [] = "#include \"%s\"\r\n\r\n";

char gszStructDef [] = "static STRUCTUREOFFSETSTABLE gsot";
char gszStructDefFmt [] = "%s%s%s";
char gszStructBegin [] = " [] = {\r\n";
char gszStructEnd [] = ")}\r\n};\r\n\r\n";
char gszStructFieldOffsetFmt [] = "    {\"%s\", FIELD_OFFSET(%s, %s)},\r\n";
char gszStructAbsoluteOffsetFmt [] = "    {\"%s\", %#lx},\r\n";
char gszStructLastRecord [] = "    {NULL, sizeof(";

/*
 * Setting the high order bit signals an offset relative to the
 *  previous field offset.
 */
char gszStructRelativeOffsetFmt [] = "    {\"%s\", 0x80000000 + sizeof(%s)},\r\n";
char gszStructArrayRelativeOffsetFmt [] = "    {\"%s\", 0x80000000 + (sizeof(%s) * %s)},\r\n";


char gszTableDef [] = "STRUCTURESTABLE gst [] = {\r\n";
char gszTableEntryFmt [] = "    {\"%s\", sizeof(%s), gsot%s},\r\n";
char gszTableEnd [] = "    {NULL, 0, NULL}\r\n};\r\n\r\n";


#define SOSL(ps) {sizeof(ps) - 1, ps, 0}
STRUCTLIST gpslEmbeddedStructs [] = {
    SOSL("OEMINFO"),
    SOSL("POINT"),
    SOSL("RECT"),
    {0, NULL, 0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\structo.c ===
/****************************** Module Header ******************************\
* Module Name: structo.c
*
* Structure parser - struct field name-offset tabel generator.
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* soProcessParameters
*
\***************************************************************************/
UINT soProcessParameters(int argc, LPSTR argv[], PWORKINGFILES pwf)
{
    char c, *p;
    int  argcParm = argc;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p) {
                switch (toupper(c)) {
                    case 'I':
                        if (pwf->pszIncInputFileExt != NULL) {
                            soLogMsg(SOLM_ERROR, "Invalid -i parameter");
                            goto PrintHelp;
                        }
                        pwf->dwOptions |= SOWF_INCLUDEINPUTFILE;
                        argc--, argv++;
                        pwf->pszIncInputFileExt = *argv;
                        break;

                    case 'L':
                        pwf->dwOptions |= SOWF_LISTONLY;
                        break;

                    case 'O':
                        if (pwf->pszOutputFile != NULL) {
                            soLogMsg(SOLM_ERROR, "Invalid -o parameter");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        pwf->pszOutputFile = *argv;
                        break;

                    case 'P':
                        pwf->dwOptions |= SOWF_INLCLUDEPRECOMPH;
                        break;

                    case 'S':
                        if (pwf->pszStructsFile != NULL) {
                            soLogMsg(SOLM_ERROR, "Invalid -s parameter");
                            goto PrintHelp;
                        }
                        argc--, argv++;
                        pwf->pszStructsFile = *argv;
                        break;

                    default:
                        soLogMsg(SOLM_ERROR, "Invalid parameter: %c", c);
                        // Fall through

                    case '?':
                        goto PrintHelp;
                }
            } /* while (c = *++p) */
        } else { /* if switch */
            pwf->pszInputFile = *argv;
            break;
        }
    } /* while (--argc) */

    if ((pwf->pszInputFile == NULL) || (pwf->pszOutputFile == NULL)) {
        goto PrintHelp;
    }

    if ((pwf->dwOptions & SOWF_LISTONLY) && (pwf->pszStructsFile != NULL)) {
        soLogMsg(SOLM_ERROR, "Cannot use -s and -l together ");
        goto PrintHelp;
    }

    return argcParm - argc;

PrintHelp:
    soLogMsg(SOLM_DEFAULT, "Structure Field Name-Offset Table Generator");
    soLogMsg(SOLM_NOLABEL, "Usage: structo [options] <-o OutputFile> InputFile1 ...");
    soLogMsg(SOLM_NOLABEL, "\tInputFile - Preprocessed C header file");
    soLogMsg(SOLM_NOLABEL, "\t[-i ext] #include input file name using extension ext");
    soLogMsg(SOLM_NOLABEL, "\t[-l] Build structure list only");
    soLogMsg(SOLM_NOLABEL, "\t<-o OutputFile> required");
    soLogMsg(SOLM_NOLABEL, "\t[-p] #include \"precomp.h\" and #pragma hdrstop  in output file");
    soLogMsg(SOLM_NOLABEL, "\t[-s StructFile] Struct names text file.");
    return 0;
}
/*********************************************************************
* soGenerateTable
*
\***************************************************************************/
BOOL soGenerateTable (PWORKINGFILES pwf)
{
    char * pTag;
    UINT uLoops;



    if (!soOpenWorkingFiles(pwf)) {
        return FALSE;
    }

    soLogMsg (SOLM_NOEOL, "Processing %s ...", pwf->pszInputFile);

    uLoops = 0;
    while (pTag = soFindTag(pwf->pmap, pwf->pmapEnd, gszStructTag)) {
        pwf->pmap = pTag;
        pTag = soParseStruct (pwf);
        if (pTag == NULL) {
            break;
        }
        pwf->pmap = pTag;
        if (++uLoops == 50) {
            soLogMsg (SOLM_APPEND, ".");
            uLoops = 0;
        }
    }

    soLogMsg (SOLM_NOLABEL, ".");

    soCloseWorkingFiles(pwf, SOCWF_DEFAULT);
    return TRUE;
}
/*********************************************************************
* InitWF
\***************************************************************************/
BOOL InitWF (PWORKINGFILES pwf)
{
    ZeroMemory (pwf, sizeof(WORKINGFILES));
    pwf->hfileInput = INVALID_HANDLE_VALUE ;
    pwf->hfileOutput = INVALID_HANDLE_VALUE ;
    pwf->hfileTemp = INVALID_HANDLE_VALUE ;

    return TRUE;
}
/*********************************************************************
* main
*
\***************************************************************************/
int __cdecl main (int argc, char *argv[])
{
    BOOL fGenerated = TRUE;
    int argcProcessed;
    WORKINGFILES wf;

    InitWF(&wf);

    do {
        argcProcessed = soProcessParameters(argc, argv, &wf);
        if (argcProcessed == 0) {
            break;
        }
        argc -= argcProcessed;
        argv += argcProcessed;

        if (!soGenerateTable(&wf)) {
            fGenerated = FALSE;
            break;
        }

        wf.dwOptions |= SOWF_APPENDOUTPUT;

    } while (argc > 1);

    if (fGenerated && (wf.hfileTemp != INVALID_HANDLE_VALUE)) {
        fGenerated = soCopyStructuresTable (&wf);
        if (fGenerated) {
            soLogMsg (SOLM_DEFAULT, "%s has been succesfully generated.", wf.pszOutputFile);
        }
    }

    soCloseWorkingFiles (&wf, SOCWF_CLEANUP);
    return !fGenerated;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\soparse.c ===
/****************************** Module Header ******************************\
* Module Name: soparse.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* Function Prototypes
\***************************************************************************/

/*********************************************************************
* soFindChar
\***************************************************************************/
char * soFindChar (char * pmap, char * pmapEnd, char c)
{
    while (pmap < pmapEnd) {
        if (*pmap != c) {
            pmap++;
        } else {
            return pmap;
        }
    }

    return NULL;
}
/*********************************************************************
* soFindTag
\***************************************************************************/
char * soFindTag (char * pmap, char * pmapEnd, char * pszTag)
{
    char * pszNext;
    char * pmapTag;


    do {
        /*
         * Find first char
         */
        pmapTag = soFindChar (pmap, pmapEnd, *pszTag);
        if (pmapTag == NULL) {
            return NULL;
        }
        pmap = pmapTag + 1;
        pszNext = pszTag + 1;

        /*
         * First found, compare the rest
         */
        while (pmap < pmapEnd) {
            if (*pmap != *pszNext) {
                break;
            } else {
                pmap++;
                pszNext++;
                if (*pszNext == '\0') {
                    return pmapTag;
                }
            }
        }

    } while (pmap < pmapEnd);

   return NULL;
}
/*********************************************************************
* soFindFirstCharInTag
*
* Finds the first occurrence of any character in pszTag
\***************************************************************************/
char * soFindFirstCharInTag (char * pmap, char * pmapEnd, char * pszTag)
{
    char * pszNext;

    while (pmap < pmapEnd) {
        /*
         * Compare current char to all chars in pszTag
         */
        pszNext = pszTag;
        do {
            if (*pmap == *pszNext++) {
                return pmap;
            }
        } while (*pszNext != '\0');

        pmap++;
    }

    return NULL;
}
/*********************************************************************
* soFindBlockEnd
*
* Finds the end of a {} () etc block
\***************************************************************************/
char * soFindBlockEnd (char * pmap, char * pmapEnd, char * pszBlockChars)
{
    if (*pmap != *pszBlockChars) {
        soLogMsg(SOLM_ERROR, "Not at the beginning of block");
        return NULL;
    }

    do {
        /*
         * Find next block char (i.e, { or })
         */
        pmap++;
        pmap = soFindFirstCharInTag (pmap, pmapEnd, pszBlockChars);
        if (pmap == NULL) {
            break;
        }

        /*
         * If at the end of the block, done
         */
        if (*pmap == *(pszBlockChars + 1)) {
            return pmap;
        }

        /*
         * Nested block, recurse.
         */
        pmap = soFindBlockEnd (pmap, pmapEnd, pszBlockChars);
    } while (pmap != NULL);

    soLogMsg(SOLM_ERROR, "Failed to find block end");
    return NULL;

}
/*********************************************************************
* soIsIdentifierChar
\***************************************************************************/
BOOL soIsIdentifierChar (char c)
{
    return (   ((c >= 'a') && (c <= 'z'))
            || ((c >= 'A') && (c <= 'Z'))
            || ((c >= '0') && (c <= '9'))
            ||  (c == '_'));
}
/*********************************************************************
* soSkipBlanks
\***************************************************************************/
char * soSkipBlanks(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        switch (*pmap) {
            case ' ':
            case '\r':
            case '\n':
                pmap++;
                break;

            default:
                return pmap;
        }
    }

    return NULL;
}
/*********************************************************************
* soSkipToIdentifier
*
* Finds the beginning of the next identifier or return pmap if
*  already on an indetifier
\***************************************************************************/
char * soSkipToIdentifier(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        if (soIsIdentifierChar(*pmap)) {
            return pmap;
        } else {
            pmap++;
        }
    }

    return NULL;
}
/*********************************************************************
* soSkipIdentifier
*
* Finds the end of the current identifier
\***************************************************************************/
char * soSkipIdentifier(char * pmap, char * pmapEnd)
{
    while (pmap < pmapEnd) {
        if (soIsIdentifierChar(*pmap)) {
            pmap++;
        } else {
            return pmap;
        }
    }

    return pmapEnd;
}
/*********************************************************************
* soGetIdentifier
*
* Returns the beginning of the current or next identifier and its size
\***************************************************************************/
char * soGetIdentifier (char * pmap, char * pmapEnd, UINT * puSize)
{
    char * pTag, * pTagEnd;

    pTag = soSkipToIdentifier(pmap, pmapEnd);
    if (pTag == NULL) {
        return NULL;
    }

    pTagEnd = soSkipIdentifier(pTag, pmapEnd);

    *puSize = (UINT)(pTagEnd - pTag);
    return pTag;

}
/*********************************************************************
* soCopyTagName
\***************************************************************************/
char * soCopyTagName (char * pTagName, UINT uTagSize)
{
    char * pszName;

    pszName = (char *) LocalAlloc(LPTR, uTagSize+1);
    if (pszName == NULL) {
        soLogMsg(SOLM_APIERROR, "LocalAlloc");
        soLogMsg(SOLM_ERROR, "soCopytagName allocation failed. Size:%d", uTagSize);
        return NULL;
    }
    strncpy(pszName, pTagName, uTagSize);
    return pszName;
}
/*********************************************************************
* soFindBlock
\***************************************************************************/
BOOL soFindBlock (char * pmap, char *pmapEnd, char * pszBlockChars, PBLOCK pb)
{
    static char gszBlockBeginChar [] = " ;";

    /*
     * Find the beginning of the block or a ;
     */
    *gszBlockBeginChar = *pszBlockChars;
    pb->pBegin = soFindFirstCharInTag (pmap, pmapEnd, gszBlockBeginChar);
    if (pb->pBegin == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to find beginning of block");
        return FALSE;
    }

    /*
     * If no block found, done
     */
    if (*(pb->pBegin) == ';') {
        /*
         * Make pb->pBegin point to whatever follows
         */
        (pb->pBegin)++;
        pb->pEnd = pb->pBegin;
        return TRUE;
    }

    /*
     * Find the end of block
     */
    pb->pEnd = soFindBlockEnd(pb->pBegin, pmapEnd, pszBlockChars);
    if (pb->pEnd == NULL) {
        return FALSE;
    }

    return TRUE;
}
/*********************************************************************
* soGetStructListEntry
\***************************************************************************/
PSTRUCTLIST soGetStructListEntry (char * pTag, UINT uTagSize, PSTRUCTLIST psl)
{

    while (psl->uSize != 0) {
        if ((psl->uSize == uTagSize) && !strncmp(pTag, psl->pszName, uTagSize)) {
            (psl->uCount)++;
            return psl;
        }
        psl++;
    }

    return NULL;
}
/*********************************************************************
* soGetBlockName
*
* Finds the beginning, end, name and name size of a structure or union.
*  if any after pmap.
*
\***************************************************************************/
BOOL soGetBlockName (char * pmap, char * pmapEnd, PBLOCK pb)
{
    char * pNextTag;

    if (!soFindBlock (pmap, pmapEnd, "{}", pb)) {
        return FALSE;
    }

    /*
     * If there was no block (the structure body is not here), done
     */
    if (pb->pBegin == pb->pEnd) {
        pb->pName = NULL;
        return TRUE;
    }

    pNextTag = soSkipBlanks(pb->pEnd + 1, pmapEnd);
    if (pNextTag == NULL) {
        /*
         * It might be at the end of the file..... but it was expecting
         *  a name or a ;
         */
        soLogMsg(SOLM_ERROR, "Failed to find union terminator or name");
        return FALSE;
    }

    /*
     * If it's unamed, done
     */
    if (*pNextTag == ';') {
        pb->pName = NULL;
        return TRUE;
    }

    pb->pName = soGetIdentifier(pNextTag, pmapEnd, &(pb->uNameSize));
    if (pb->pName == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to get block name");
        return FALSE;
    }

    return TRUE;
}
/*********************************************************************
* soFreepfiPointers
*
\***************************************************************************/
void soFreepfiPointers (PFIELDINFO pfi)
{
    if (pfi->dwFlags & SOFI_ALLOCATED) {
        LocalFree(pfi->pType);
    }
    if (pfi->dwFlags & SOFI_ARRAYALLOCATED) {
        LocalFree(pfi->pArray);
    }
}
/*********************************************************************
* soParseField
*
\***************************************************************************/
char * soParseField (PWORKINGFILES pwf, PFIELDINFO pfi, char * pTag, char * pTagEnd)
{
    static char gszpvoid [] = "void *";
    static char gszdword [] = "DWORD";

    BOOL fUseFieldOffset, fBitField, fTypeFound, fArray;
    BLOCK block;
    char * pTagName, * pszFieldName;
    char * pNextTag, * pType;
    UINT uTags, uTagSize, uTagsToName, uTypeSize;


    fUseFieldOffset = TRUE;
    uTags = 0;
    uTagsToName = 1;
    fTypeFound = FALSE;
    do {
        /*
         * Find next indetifier, move past it and get the following char
         */
        uTags++;
        pTagName = soGetIdentifier(pTag+1, pwf->pmapEnd, &uTagSize);
        if (pTagName == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to get field name");
            return NULL;
        }

        pTag = pTagName + uTagSize;
        if (pTag >= pTagEnd) {
            break;
        }

        pNextTag = soSkipBlanks(pTag, pTagEnd);
        if (pNextTag == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to get field termination");
            return NULL;
        }

        /*
         * Type check.
         * (LATER: Let's see how long we can get away with assuming that the type
         *  is the first tag....)
         * Remember where the type is
         */
        if (!fTypeFound) {
            pType = pTagName;
            uTypeSize = uTagSize;
            fTypeFound = TRUE;
        }

        if (uTags == 1) {
            if (!strncmp(pTagName, "union", uTagSize)) {
                /*
                 * Get the union name
                 */
                if (!soGetBlockName(pTagName, pwf->pmapEnd, &block)) {
                    return NULL;
                }
                if (block.pName != NULL) {
                    /*
                     * Named union. Add this name to the table
                     */
                    pTagName = block.pName;
                    uTagSize = block.uNameSize;
                    fUseFieldOffset = FALSE;
                    fTypeFound = FALSE;
                    break;
                } else {
                    /*
                     * Parse and add the fields in this union
                     */
                    fTypeFound = FALSE;
                }


            } else if (!strncmp(pTagName, "struct", uTagSize)) {
                /*
                 * Get the structure name
                 */
                if (!soGetBlockName(pTagName, pwf->pmapEnd, &block)) {
                    return NULL;
                }
                if (block.pBegin == block.pEnd) {
                    /*
                     * The structure body is not here. We need one more
                     *  identifier to get to the field name. Also, this
                     *  field must (?) be a pointer to the struct we're
                     *  parsing
                     */
                    uTagsToName++;
                    pType = gszpvoid;
                    uTypeSize = sizeof(gszpvoid) - 1;

                } else if (block.pName != NULL) {
                    /*
                     * Named structure. Add this name to the table
                     */
                    pTagName = block.pName;
                    uTagSize = block.uNameSize;
                    fUseFieldOffset = FALSE;
                    fTypeFound = FALSE;
                    break;
                } else {
                    /*
                     * Parse and add the fields in this struct
                     */
                    fTypeFound = FALSE;
                }

            } else {

                /*
                 * Cannot get the offset of strucutres like RECT, POINT, etc.
                 */
                 fUseFieldOffset = (NULL == soGetStructListEntry(pTagName, uTagSize, gpslEmbeddedStructs));
            }
        } else { /* if (uTags == 1) */
            /*
             * Does this look like a function prototype?
             */
            if (*pTagName == '(') {
                pTag = soFindChar (pTagName + 1, pwf->pmapEnd, ')');
                if (pTag == NULL) {
                    soLogMsg(SOLM_ERROR, "Failed to find closing paren");
                    return NULL;
                }
                pTag++;
                uTagSize = (UINT)(pTag - pTagName);
                fUseFieldOffset = FALSE;
                break;
            }
        }  /* if (uTags == 1) */


        /*
         * If this is followed by a terminator, this must be the field name
         */
    } while (   (*pNextTag != ';') && (*pNextTag != '[')
             && (*pNextTag != '}') && (*pNextTag != ':'));


    if (pTag >= pTagEnd) {
        return pTag;
    }

    fBitField = (*pNextTag == ':');
    fArray = (*pNextTag == '[');

    /*
     * Cannot use FIELD_OFFSET on bit fields or unamed structs
     */
    fUseFieldOffset &= (!fBitField && (uTags > uTagsToName));

    /*
     * If this is a bit field, make the size be part of the name
     */
    if (fBitField) {
        pNextTag = soSkipBlanks(pNextTag + 1, pTagEnd);
        if (pNextTag == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to get bit field size");
            return NULL;
        }
        pNextTag = soSkipIdentifier(pNextTag + 1, pTagEnd);
        if (pNextTag == NULL) {
            soLogMsg(SOLM_ERROR, "Failed to skip bit field size");
            return NULL;
        }
        uTagSize = (UINT)(pNextTag - pTagName);
    }

    /*
     * Copy field name
     */
    pszFieldName = soCopyTagName (pTagName, uTagSize);
    if (pszFieldName == NULL) {
        return NULL;
    }

    if (fUseFieldOffset) {
        /*
         * Use FIELD_OFFSET macro
         */
        if (!soWriteFile(pwf->hfileOutput, gszStructFieldOffsetFmt, pszFieldName, pfi->pszStructName, pszFieldName)) {
            return NULL;
        }

    } else {
        /*
         * If this is the first field or if this is a bit field
         *  preceded by another bit field
         */
        if ((pfi->pType == NULL)
                || (fBitField && (pfi->dwFlags & SOFI_BIT))) {
            /*
             * Write 0 or the mask to signal a 0 relative offset from
             *  the previous field
             */
            if (!soWriteFile(pwf->hfileOutput, gszStructAbsoluteOffsetFmt, pszFieldName,
                    ((pfi->dwFlags & SOFI_BIT) ?  0x80000000 : 0))) {

                return NULL;
            }

        } else {
            /*
             * Write a relative offset from the previous field
             * Copy type name if not done already
             */
            if (!(pfi->dwFlags & SOFI_ALLOCATED)) {
                pfi->pType = soCopyTagName (pfi->pType, pfi->uTypeSize);
                if (pfi->pType == NULL) {
                    return NULL;
                }
                pfi->dwFlags |= SOFI_ALLOCATED;
            }

             /*
              * If the last field was NOT an array
              */
             if (!(pfi->dwFlags & SOFI_ARRAY)) {
                if (!soWriteFile(pwf->hfileOutput, gszStructRelativeOffsetFmt, pszFieldName, pfi->pType)) {
                    return NULL;
                }
             } else {
                /*
                 * Copy the array size if not done already
                 */
                 if (!(pfi->dwFlags & SOFI_ARRAYALLOCATED)) {
                    pfi->pArray = soCopyTagName (pfi->pArray, pfi->uArraySize);
                    if (pfi->pArray == NULL) {
                        return NULL;
                    }
                    pfi->dwFlags |= SOFI_ARRAYALLOCATED;
                 }

                 if (!soWriteFile(pwf->hfileOutput, gszStructArrayRelativeOffsetFmt, pszFieldName, pfi->pType, pfi->pArray)) {
                    return NULL;
                 }
            } /* if ((pfi->pType == NULL) || (pfi->dwFlags & SOFI_BIT)) */
        }

    } /* if (fUseFieldOffset) */

    /*
     * Save the field info wich migth be needed to calculate the offset
     *  to following fields. See gszStruct*RelativeOffsetFmt.
     */
    soFreepfiPointers(pfi);
    pfi->dwFlags = 0;
    if (fBitField) {
        /*
         * LATER: Let's see how long we can get away with assuming that
         *  bit fields take a DWORD. This only matters when a !fUseFieldOffset
         *  is preceded by a bit field.
         */
        pfi->dwFlags = SOFI_BIT;
        pfi->pType = gszdword;
        pfi->uTypeSize = sizeof(gszdword) - 1;
    } else {
        pfi->pType = pType;
        pfi->uTypeSize = uTypeSize;

        if (fArray) {
            pfi->dwFlags = SOFI_ARRAY;
            if (!soFindBlock (pNextTag, pwf->pmapEnd, "[]", &block)) {
                return NULL;
            }
            if (block.pBegin + 1 >= block.pEnd) {
                soLogMsg(SOLM_ERROR, "Missing array size", pfi->pszStructName, pszFieldName);
                return NULL;
            }
            pfi->pArray = pNextTag + 1;
            pfi->uArraySize = (UINT)(block.pEnd - block.pBegin - 1);
        }
    } /* if (fBitField) */

    LocalFree(pszFieldName);

    /*
     * Move past the end of this field
     */
    pTag = soFindChar (pTagName + 1, pwf->pmapEnd, ';');
    if (pTag == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to find ';' after field name");
        return NULL;
    }
    pTag++;

    return pTag;

    soLogMsg(SOLM_ERROR, ". Struct:%s Field:%s", pfi->pszStructName, pszFieldName);

}
/*********************************************************************
* soParseStruct
\***************************************************************************/
char * soParseStruct (PWORKINGFILES pwf)
{

    BLOCK block;
    char * pTag, ** ppszStruct;
    FIELDINFO fi;
    PSTRUCTLIST psl;

    if (!soGetBlockName(pwf->pmap, pwf->pmapEnd, &block)) {
        return NULL;
    }

    /*
     * If there was no block (the structure body is not here), done
     */
    if (block.pBegin == block.pEnd) {
        return block.pBegin;
    }

    /*
     * Fail if no name.
     */
    if (block.pName == NULL) {
        soLogMsg(SOLM_ERROR, "Failed to get structure name");
        return NULL;
    }

    /*
     * If there is a struct list, check if in the list
     * If in the list, check that we haven't found it already.
     * If not in the list, done.
     */
     if (pwf->psl != NULL) {
        psl = soGetStructListEntry(block.pName, block.uNameSize, pwf->psl);
        if (psl != NULL) {
            if (psl->uCount > 1) {
                soLogMsg(SOLM_ERROR, "Struct %s already defined", psl->pszName);
                return NULL;
            }
        } else {
            return block.pEnd;
        }
     }

    /*
     * Make a null terminated string for the name.
     */
    ZeroMemory(&fi, sizeof(fi));
    fi.pszStructName = soCopyTagName (block.pName, block.uNameSize);
    if (fi.pszStructName == NULL) {
        return NULL;
    }


    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        if (!soWriteFile(pwf->hfileOutput, "%s\r\n", fi.pszStructName)) {
            goto CleanupAndFail;
        }
        goto DoneWithThisOne;
    }

    /*
     * Write structure offsets table definition and entry in strucutres table
     */
    if (!soWriteFile(pwf->hfileOutput, gszStructDefFmt, gszStructDef, fi.pszStructName, gszStructBegin)) {
        goto CleanupAndFail;
    }

    if (!soWriteFile(pwf->hfileTemp, gszTableEntryFmt, fi.pszStructName, fi.pszStructName, fi.pszStructName)) {
        goto CleanupAndFail;
    }

    /*
     * Parse the fields
     */
    pTag = block.pBegin + 1;
    while (pTag < block.pEnd) {
        pTag = soParseField (pwf, &fi, pTag, block.pEnd);
        if (pTag == NULL) {
            goto CleanupAndFail;
        }
    }

    /*
     * Write structure last record and end
     */
    if (!soWriteFile(pwf->hfileOutput, "%s%s%s", gszStructLastRecord, fi.pszStructName, gszStructEnd)) {
        goto CleanupAndFail;
    }


DoneWithThisOne:
    (pwf->uTablesCount)++;

    LocalFree(fi.pszStructName);
    soFreepfiPointers(&fi);

    /*
     * Move past the end of the structure
     */
    pTag = soFindChar(block.pName + block.uNameSize, pwf->pmapEnd, ';');
    return (pTag != NULL ? pTag + 1 : NULL);

CleanupAndFail:
    LocalFree(fi.pszStructName);
    soFreepfiPointers(&fi);
    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\structo.h ===
/****************************** Module Header ******************************\
* Module Name: structo.h
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include <stdio.h>
#include <stddef.h>
#include <windows.h>

/***************************************************************************\
 * Defines
\***************************************************************************/
// Working files
#define SOWF_APPENDOUTPUT       0x0001
#define SOWF_INCLUDEINPUTFILE   0x0002
#define SOWF_INLCLUDEPRECOMPH   0x0004
#define SOWF_LISTONLY           0x0008

// soCloseWorkingFiles
#define SOCWF_DEFAULT      0x0
#define SOCWF_CLEANUP      0x1

// soLogMsg
#define SOLM_DEFAULT      0x0000
#define SOLM_NOLABEL      0x0001
#define SOLM_ERROR        0x0002
#define SOLM_WARNING      0x0004
#define SOLM_API          0x0008
#define SOLM_APIERROR     (SOLM_API | SOLM_ERROR)
#define SOLM_NOEOL        0x0010
#define SOLM_APPEND       (SOLM_NOLABEL | SOLM_NOEOL)

// Field info
#define SOFI_ALLOCATED          0x0001
#define SOFI_ARRAY              0x0002
#define SOFI_ARRAYALLOCATED     0x0004
#define SOFI_BIT                0x0008

/***************************************************************************\
 * Structures
\***************************************************************************/
typedef struct _FILEMAP
{
    /*
     * hfileInput is assumed to be the first field of this structure
     */
    union {
        HANDLE hfileInput;
        HANDLE hfile;
    };
    HANDLE hmap;
    char * pmapStart;
    char * pmap;
    char * pmapEnd;
} FILEMAP, * PFILEMAP;

typedef struct _STRUCTLIST
{
    UINT uSize;
    char * pszName;
    UINT uCount;
} STRUCTLIST, * PSTRUCTLIST;

typedef struct _WORKINGFILES
{
    DWORD dwOptions;
    char * pszInputFile;
    FILEMAP;
    char * pszOutputFile;
    HANDLE hfileOutput;
    HANDLE hfileTemp;
    char * pszStructsFile;
    PSTRUCTLIST psl;
    DWORD uTablesCount;
    char * pszIncInputFileExt;
} WORKINGFILES, * PWORKINGFILES;

typedef struct _BLOCK
{
    char * pBegin;
    char * pEnd;
    char * pName;
    UINT   uNameSize;
} BLOCK, * PBLOCK;

typedef struct _FIELDINFO
{
    char * pszStructName;
    char * pType;
    DWORD dwFlags;
    UINT uTypeSize;
    char * pArray;
    UINT uArraySize;
} FIELDINFO, * PFIELDINFO;

/***************************************************************************\
 * Globals
\***************************************************************************/
// socode.c
extern char * gpszHeader [];
extern char * gpszTail [];

// soglobal.c
extern char gszPrecomph [];
extern char gszIncInput [];

extern char gszStructTag [];
extern char gszStructDef [];
extern char gszStructDefFmt [];
extern char gszStructBegin [];
extern char gszStructEnd [];
extern char gszStructFieldOffsetFmt [];
extern char gszStructAbsoluteOffsetFmt [];
extern char gszStructLastRecord [];
extern char gszStructRelativeOffsetFmt [];
extern char gszStructArrayRelativeOffsetFmt [];

extern char gszTableDef [];
extern char gszTableEntryFmt [];
extern char gszTableEnd [];
extern STRUCTLIST gpslEmbeddedStructs [];

/***************************************************************************\
 * Funtion Prototypes
\***************************************************************************/
// sofile.c
BOOL soCopyStructuresTable (PWORKINGFILES pwf);
BOOL soCloseWorkingFiles (PWORKINGFILES pwf, DWORD dwFlags);
BOOL soOpenWorkingFiles (PWORKINGFILES pwf);
BOOL __cdecl soWriteFile(HANDLE hfile, char *pszfmt, ...);

// soparse.c
char * soCopyTagName (char * pTagName, UINT uTagSize);
char * soFindChar (char * pmap, char * pmapEnd, char c);
char * soFindTag (char * pmap, char * pmapEnd, char * pszTag);
char * soGetIdentifier (char * pmap, char * pmapEnd, UINT * puSize);
BOOL soIsIdentifierChar (char c);
char * soParseStruct (PWORKINGFILES pwf);

// soutil.c
void __cdecl soLogMsg(DWORD dwFlags, char *pszfmt, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\suck\suck.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// #define SEE_EM 1

#define MAX_FILENAME_LENGTH       127

#define MAX_TIMEANDSIZE           50        /* mm-dd-yyyy hh-mm-ss */

#define MAX_FILENAME_PER_BLOCK  1000
#define MAX_MEMBLOCKS            100

#define MAX_THREADS               29

#define MAX_COMMAND_LINE        1024
#define MAX_ARGS                  20

// kenhia 15-Mar-1996: add support for -#:<share>
//
// splante 15-Oct-1996: changed support to the "ntbuilds" server
#if defined(_ALPHA_) || defined(_X86_)
    #define PLATFORM_SPECIFIC_SHARES { "ntbuilds", "ntbuilds", "ntbuilds", "ntbuilds", "ntbuilds", NULL }
#endif
#ifndef PLATFORM_SPECIFIC_SHARES
    #pragma message( "WARNING: Platform Specific shares disabled" )
    #define PLATFORM_SPECIFIC_SHARES {NULL}
#endif


typedef struct _filename FILENAME;

typedef union _virtual_pointer {
    FILENAME    *mem_ptr;
    DWORD       disk_ptr;
} VIRTPTR;

struct _filename {
    DWORD       dwStatus;
    DWORD       dwCopy;
    VIRTPTR     fnParent;
    VIRTPTR     fnChild;
    VIRTPTR     fnSibling;
    DWORD       dwFileSizeLow;
    DWORD       dwFileSizeHigh;
    FILETIME    ftFileTime;
    DWORD       dwDATFileSizeLow;
    DWORD       dwDATFileSizeHigh;
    FILETIME    ftDATFileTime;
    DWORD       dwFileNameLen;
    CHAR        cFileName[MAX_FILENAME_LENGTH+1];
};

typedef struct _memblock MEMBLOCK;
struct _memblock {
    HANDLE      hMem;
    LPSTR       lpBase;
};

typedef struct _fileheader {
    VIRTPTR     fnRoot;             // Pointer to root node
} FILEHEADER;


#define SUCK_INI_FILE           ".\\suck.ini"
#define SUCK_DAT_FILE           ".\\suck.dat"

#define DIRECTORY   (DWORD)0x80000000
#define STARTED     (DWORD)0x40000000
#define COPIED      (DWORD)0x20000000

CRITICAL_SECTION cs;
CRITICAL_SECTION pcs;

INT cAvailable = 0;
FILENAME *lpBaseCurrent = NULL;
INT nMemBlocks = 0;
FILENAME *fnRoot = NULL;

LONG nFiles       = 0;
LONG nDirectories = 0;
LONG nDuplicates  = 0;
LONG nStraglers   = 0;

BOOL fCopying            = FALSE;
BOOL fScriptMode         = FALSE;
BOOL fLogTreeDifferences = FALSE;
BOOL fUpdateINIBase      = FALSE;
BOOL fDestroy            = FALSE;
BOOL fUseDAT             = TRUE;

// DavidP 23-Jan-1998: BEGIN Allow multiple levels of quiet
BOOL fQuietMode      = FALSE;
BOOL fProgressMode   = FALSE;
INT  nConsoleWidth   = 0;
CHAR chLineEnd       = '\n';
// DavidP 23-Jan-1998: END Allow multiple levels of quiet

FILE *SuckDATFile = NULL;
#define MAX_EXCLUDES 1024
CHAR gExcludes[MAX_EXCLUDES+1] = { '\0'};

FILETIME ftZero = { 0, 0};


MEMBLOCK mbBlocks[MAX_MEMBLOCKS];

DWORD dwMasks[] = {
    0x00000001,
    0x00000002,
    0x00000004,
    0x00000008,
    0x00000010,
    0x00000020,
    0x00000040,
    0x00000080,
    0x00000100,
    0x00000200,
    0x00000400,
    0x00000800,
    0x00001000,
    0x00002000,
    0x00004000,
    0x00008000,
    0x00010000,
    0x00020000,
    0x00040000,
    0x00080000,
    0x00100000,
    0x00200000,
    0x00400000,
    0x00800000,
    0x01000000,
    0x02000000,
    0x04000000,
    0x08000000,
    0x10000000,
};

CHAR chPath[MAX_THREADS][MAX_PATH];
DWORD dwTotalSizes[MAX_THREADS];

BOOL EverybodyBailOut = FALSE;

BOOL fProblems[MAX_THREADS];

FILENAME *AllocateFileName()
{
    FILENAME    *lpResult;

    /*
    ** Allocate a new FILENAME
    */
    if ( cAvailable == 0 ) {

        mbBlocks[nMemBlocks].hMem = GlobalAlloc( GMEM_FIXED | GMEM_ZEROINIT,
                                                 MAX_FILENAME_PER_BLOCK * sizeof(FILENAME) );
        if ( mbBlocks[nMemBlocks].hMem == (HANDLE)0 ) {
            fprintf(stderr,"Memory Allocation Failed in AllocateFileName\n");
            exit(1);
        }
        mbBlocks[nMemBlocks].lpBase = GlobalLock( mbBlocks[nMemBlocks].hMem );

        lpBaseCurrent = (FILENAME *)mbBlocks[nMemBlocks].lpBase;

        cAvailable = MAX_FILENAME_PER_BLOCK;

        nMemBlocks++;
    }

    lpResult = lpBaseCurrent;

    --cAvailable;

    lpBaseCurrent++;

    return( lpResult );
}

VOID FreeFileNames()
{
    while ( nMemBlocks ) {
        --nMemBlocks;
        GlobalUnlock( mbBlocks[nMemBlocks].hMem );
        GlobalFree( mbBlocks[nMemBlocks].hMem );
    }
}

VOID
AddFile(
       FILENAME            *fn,
       LPWIN32_FIND_DATA   lpwfd,
       DWORD               mask
       )
{
    CHAR        *pdest;
    CHAR        *psrc;
    INT         count;
    INT         maximum;
    FILENAME    *fnCurrent;
    FILENAME    *fnChild;
    DWORD       dwFileNameLen;
    CHAR        NewName[MAX_FILENAME_LENGTH+1];
    FILENAME    *fnChildOriginally;

    if ( *lpwfd->cFileName == '.' ) {
        return;
    }

    dwFileNameLen = strlen(lpwfd->cFileName);
    if (dwFileNameLen > MAX_FILENAME_LENGTH) {
        fprintf(stderr, "File name %s too long (%u > %u), complain to BobDay\n",
                lpwfd->cFileName, dwFileNameLen, MAX_FILENAME_LENGTH);
        return;
    }

    strcpy( NewName, lpwfd->cFileName );

    fnChild = fn->fnChild.mem_ptr;
    fnChildOriginally = fnChild;

    while ( fnChild ) {
        if ( fnChild->dwFileNameLen == dwFileNameLen &&
             !strcmp(NewName, fnChild->cFileName)
           ) {
            fnChild->dwStatus |= mask;           // Atomic instruction
            if ( fnChild->ftFileTime.dwLowDateTime == ftZero.dwLowDateTime
                 && fnChild->ftFileTime.dwHighDateTime == ftZero.dwHighDateTime ) {
                EnterCriticalSection( &cs );
                fnChild->dwFileSizeLow     = lpwfd->nFileSizeLow;
                fnChild->dwFileSizeHigh    = lpwfd->nFileSizeHigh;
                fnChild->ftFileTime        = lpwfd->ftLastWriteTime;
                LeaveCriticalSection( &cs );
            }
            nDuplicates++;
            return;
        }

        fnChild = fnChild->fnSibling.mem_ptr;
    }

    // Probably not there...  Enter the critical section now to prove it

    EnterCriticalSection( &cs );

    // Most common case, nobody has changed this directory at all.

    if ( fn->fnChild.mem_ptr != fnChildOriginally ) {

        // Otherwise, make another scan inside the critical section.

        fnChild = fn->fnChild.mem_ptr;

        while ( fnChild ) {
            if ( fnChild->dwFileNameLen == dwFileNameLen &&
                 !strcmp(NewName, fnChild->cFileName)
               ) {
                fnChild->dwStatus |= mask;           // Atomic instruction
                nDuplicates++;
                LeaveCriticalSection( &cs );
                return;
            }

            fnChild = fnChild->fnSibling.mem_ptr;
        }

    }

    fnCurrent = AllocateFileName();

    strcpy( fnCurrent->cFileName, NewName );
    fnCurrent->dwFileNameLen     = dwFileNameLen;
    fnCurrent->dwFileSizeLow     = lpwfd->nFileSizeLow;
    fnCurrent->dwFileSizeHigh    = lpwfd->nFileSizeHigh;
    fnCurrent->ftFileTime        = lpwfd->ftLastWriteTime;
    fnCurrent->dwDATFileSizeLow  = 0;
    fnCurrent->dwDATFileSizeHigh = 0;
    fnCurrent->ftDATFileTime     = ftZero;

    fnCurrent->dwCopy         = 0;

    fnCurrent->fnParent.mem_ptr  = fn;
    fnCurrent->fnChild.mem_ptr   = NULL;

    fnCurrent->fnSibling.mem_ptr = fn->fnChild.mem_ptr;
    fn->fnChild.mem_ptr = fnCurrent;

    if ( lpwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
        fnCurrent->dwStatus = DIRECTORY;
        nDirectories++;
    } else {
        fnCurrent->dwStatus = 0;
        nFiles++;
    }
    fnCurrent->dwStatus |= mask;

#ifdef SEE_EM
    { char text[MAX_FILENAME_LENGTH+1];
        memcpy( text, fnCurrent->cFileName, MAX_FILENAME_LENGTH );
        text[MAX_FILENAME_LENGTH] = '\0';

        if ( fnCurrent->dwStatus & DIRECTORY ) {
            printf("Munged  DirName = %08lX:[%s]\n", fnCurrent, text );
        } else {
            printf("Munged FileName = %08lX:[%s]\n", fnCurrent, text );
        }
    }
#endif
    LeaveCriticalSection( &cs );

}

BOOL
Excluded(
        WIN32_FIND_DATA *pwfd
        )
{
    CHAR *pszScan = gExcludes;
    while (*pszScan) {
        if ((pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            _stricmp(pszScan, pwfd->cFileName) == 0) {
            return(TRUE);
        }
        pszScan = strchr(pszScan, 0) + 1;
    }
    return(FALSE);
}

VOID
EnumFiles(
         LPSTR           lpSearch,
         FILENAME        *fnParent,
         DWORD           mask,
         UINT            iThread
         )
{
    WIN32_FIND_DATA wfd;
    HANDLE          hFind;
    CHAR            NewName[MAX_PATH];
    CHAR            *pch;
    CHAR            *pchSpot;
    BOOL            f;
    FILENAME        *fnChild;
    DWORD           rc;

#ifdef SEE_EM
    printf("Enuming <%s>\n", lpSearch );
#endif

    strcpy( NewName, lpSearch );
    pch = NewName + strlen(NewName) - 1;

    if ( *pch != '\\' && *pch != '/' && *pch != ':' ) {
        *++pch = '\\';
    }
    strcpy( ++pch, "*.*" );
    pchSpot = pch;


    do {
        hFind = FindFirstFile( NewName, &wfd );

        if ( hFind != INVALID_HANDLE_VALUE ) {
            break;
        }

        rc = GetLastError();
        switch ( rc ) {
            default:
                printf("%s: Error: GetLastError = %08ld  What does it mean?\n", NewName, rc );
            case ERROR_SHARING_PAUSED:
            case ERROR_BAD_NETPATH:
            case ERROR_BAD_NET_NAME:
            case ERROR_NO_LOGON_SERVERS:
            case ERROR_VC_DISCONNECTED:
            case ERROR_UNEXP_NET_ERR:
                if ( !fProblems[iThread] ) {
                    printf("Error accesing %s, switching to silent retry\n", lpSearch );
                    fProblems[iThread] = TRUE;
                }
                if (EverybodyBailOut) {
                    return;
                }
                Sleep( 10000 );      // Wait for 10 seconds
                break;
                break;
        }

    } while ( TRUE );

    if ( hFind != NULL ) {
        do {
            if (!Excluded(&wfd))
                AddFile( fnParent, &wfd, mask );
            f = FindNextFile( hFind, &wfd );
        } while ( f );
    }

    FindClose( hFind );

    fnChild = fnParent->fnChild.mem_ptr;
    while ( fnChild ) {

        /*
        ** If its a directory and it was one of "our" directories, then enum it
        */
        if ( (fnChild->dwStatus & DIRECTORY) == DIRECTORY
             && (fnChild->dwStatus & mask) == mask ) {
            pch = pchSpot;

            strcpy( pch, fnChild->cFileName );
#ifdef SEE_EM
            printf("NewName = <%s>\n", NewName );
#endif
            EnumFiles( NewName, fnChild, mask, iThread );
        }
        fnChild = fnChild->fnSibling.mem_ptr;
    }

}

BOOL
CopyCheck(
         CHAR        *pchPath,
         FILENAME    *fnCurrent
         )
{
    WORD        wFatDate;
    WORD        wFatTime;
    WORD        wDATFatDate;
    WORD        wDATFatTime;
    BOOL        b;

    if ( fnCurrent->dwDATFileSizeLow != fnCurrent->dwFileSizeLow ) {
        return( TRUE );
    }
    if ( fnCurrent->dwDATFileSizeHigh != fnCurrent->dwFileSizeHigh ) {
        return( TRUE );
    }
    b = FileTimeToDosDateTime( &fnCurrent->ftDATFileTime, &wDATFatDate, &wDATFatTime );
    if ( !b ) {
        return( TRUE );
    }
    b = FileTimeToDosDateTime( &fnCurrent->ftFileTime, &wFatDate, &wFatTime );
    if ( !b ) {
        return( TRUE );
    }

    if ( wDATFatTime != wFatTime ) {
        return( TRUE );
    }
    if ( wDATFatDate != wFatDate ) {
        return( TRUE );
    }
    return( FALSE );
}

DWORD
CopyThem(
        FILENAME    *fnDir,
        CHAR        *chDest,
        CHAR        *chSrc,
        DWORD       nThread,
        DWORD       mask,
        BOOL        f1stPass
        )
{
    CHAR        *pch;
    CHAR        *pchSpotDest;
    CHAR        *pchSpotSrc;
    CHAR        chTemp[MAX_PATH];
    CHAR        chTempName[20];
    BOOL        fCopyIt;
    FILENAME    *fnChild;
    BOOL        fCopy;
    BOOL        fCopied;
    BOOL        fRenamed;
    BOOL        fDeleted;
    BOOL        fAttrib;
    DWORD       dwCount;
    DWORD       dwAttribs;
    DWORD       dw;

    fnChild = fnDir->fnChild.mem_ptr;

    pchSpotDest = chDest + strlen(chDest);
    pchSpotSrc  = chSrc  + strlen(chSrc);

    dwCount = 0;

    while ( fnChild && !EverybodyBailOut) {

        fCopyIt = TRUE;

        if ( f1stPass ) {
            if ( (fnChild->dwStatus & STARTED) == STARTED ) {
                fCopyIt = FALSE;
            }
        } else {
            if ( (fnChild->dwStatus & COPIED) == COPIED ) {
                fCopyIt = FALSE;
            }
        }

        //
        // If the file doesn't exist on this thread's source location, then
        // don't try to copy it.
        //
        if ( (fnChild->dwStatus & mask) != mask ) {
            fCopyIt = FALSE;
        }

        if ( fCopyIt ) {
            //            if ( f1stPass && (fnChild->dwStatus & STARTED) == STARTED ) {
            //                fCopyIt = FALSE;
            //            } else {
            //                fnChild->dwStatus |= STARTED;
            //            }
            //            LeaveCriticalSection( &pcs );
        }

        if ( fCopyIt ) {
            pch = pchSpotDest;

            strcpy( pch, fnChild->cFileName );
            strcpy( pchSpotSrc, pchSpotDest );

            if ( (fnChild->dwStatus & DIRECTORY) == DIRECTORY ) {
                CreateDirectory( chDest, NULL );
                strcat( pchSpotDest, "\\" );
                strcat( pchSpotSrc, "\\" );
                dwCount += CopyThem( fnChild, chDest, chSrc, nThread, mask, f1stPass );
            } else {
                fnChild->dwStatus |= STARTED;

                strcpy( chTemp, chDest );
                *(chTemp+(pchSpotDest-chDest)) = '\0';

                sprintf( chTempName, "suck%02lX.tmp", mask );
                strcat( chTemp, chTempName );

                //
                // Check if we need to copy this file
                //
                fCopy = CopyCheck( chDest, fnChild );

                if ( fScriptMode ) {
                    dwCount++;
                    EnterCriticalSection( &pcs );
                    fnChild->dwStatus |= COPIED;
                    if ( fCopy ) {
                        if ( !fQuietMode ) {
                            printf("copy %s %s\n", chSrc, chDest );
                        }
                        dwTotalSizes[nThread-1] += fnChild->dwFileSizeLow;
                    } else {
                        if ( !fQuietMode ) {
                            printf("rem copy %s %s\n", chSrc, chDest );
                        }
                    }
                    LeaveCriticalSection( &pcs );
                } else {
                    dwCount++;

                    if ( fCopy ) {

                        dwAttribs = GetFileAttributes( chTemp );
                        if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                            dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                            fAttrib = SetFileAttributes( chTemp, dwAttribs );
                        }
                        fCopied = CopyFile( chSrc, chTemp, FALSE );

                        if ( !fCopying ) {
                            EnterCriticalSection( &pcs );
                            if ( !fCopying ) {
                                fCopying = TRUE;
                                printf("Copying files...\n" );
                            }
                            LeaveCriticalSection( &pcs );
                        }

                        if ( !fCopied ) {
                            dw = GetLastError();
                            printf("%s => %s\t[COPY ERROR %08lX]\n", chSrc, chTemp, dw );

                            dwAttribs = GetFileAttributes( chTemp );
                            if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                fAttrib = SetFileAttributes( chTemp, dwAttribs );
                            }
                            DeleteFile( chTemp );

                            switch ( dw ) {
                                case ERROR_BAD_NETPATH:
                                case ERROR_BAD_NET_NAME:
                                    if ( !fProblems[nThread-1] ) {
                                        printf("Error accesing %s, switching to silent attempts\n", chSrc );
                                        fProblems[nThread-1] = TRUE;
                                    }
                                    Sleep( 10000 );      // Wait for 10 seconds
                                    break;
                                default:
                                    break;
                            }

                        } else {

                            EnterCriticalSection( &pcs );

                            if ( (fnChild->dwStatus & COPIED) == COPIED ) {
                                //
                                // Copy was done by somebody else
                                //
                                dwAttribs = GetFileAttributes( chTemp );
                                if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                    dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                    fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                }
                                fDeleted = DeleteFile( chTemp );

                            } else {
                                //
                                // Copy was done by us, attempt rename
                                //
                                fAttrib = TRUE;
                                if ( fDestroy ) {
                                    dwAttribs = GetFileAttributes( chDest );
                                    if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                        dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                        fAttrib = SetFileAttributes( chDest, dwAttribs );
                                    }
                                }
                                if ( !fAttrib ) {
                                    dw = GetLastError();
                                    printf("%s => %s\t[ATTRIBUTE CHANGE ERROR %08lX(%s)\n", chSrc, chDest, dw, chDest );
                                    dwAttribs = GetFileAttributes( chTemp );
                                    if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                        dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                        fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                    }
                                    fDeleted = DeleteFile( chTemp );
                                } else {
                                    fDeleted = DeleteFile( chDest );
                                    if ( !fDeleted ) {
                                        dw = GetLastError();
                                        fnChild->dwStatus |= COPIED;
                                    }

                                    if ( fDeleted || dw == ERROR_FILE_NOT_FOUND ) {

                                        fRenamed = MoveFile( chTemp, chDest );

                                        if ( fRenamed ) {
                                            fnChild->dwStatus |= COPIED;
                                            if ( !fQuietMode ) {
                                                // DavidP 23-Jan-1998: Allow multiple levels of quiet
                                                printf("%*s\r%s => %s\t[OK]%c", nConsoleWidth, "", chSrc, chDest, chLineEnd );
                                            }
                                            dwTotalSizes[nThread-1] += fnChild->dwFileSizeLow;
                                        } else {
                                            dw = GetLastError();
                                            printf("%s => %s\t[RENAME ERROR %08lX (%s)]\n", chSrc, chDest, dw, chTemp );
                                            dwAttribs = GetFileAttributes( chTemp );
                                            if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                                dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                                fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                            }
                                            fDeleted = DeleteFile( chTemp );
                                        }
                                    } else {
                                        dw = GetLastError();
                                        printf("%s => %s\t[DELETE ERROR %08lX (%s)]\n", chSrc, chDest, dw, chDest );
                                        dwAttribs = GetFileAttributes( chTemp );
                                        if ( dwAttribs & FILE_ATTRIBUTE_READONLY && dwAttribs != 0xFFFFFFFF ) {
                                            dwAttribs &= ~FILE_ATTRIBUTE_READONLY;
                                            fAttrib = SetFileAttributes( chTemp, dwAttribs );
                                        }
                                        fDeleted = DeleteFile( chTemp );
                                    }
                                }
                            }
                            LeaveCriticalSection( &pcs );
                        }
                    } else {
                        EnterCriticalSection( &pcs );
                        if ( !fCopying ) {
                            fCopying = TRUE;
                            printf("Copying files...\n" );
                        }
                        fnChild->dwStatus |= COPIED;
                        if ( !fQuietMode ) {
                            // DavidP 23-Jan-1998: Allow multiple levels of quiet
                            // printf("%*s\r%s => %s\t[OK]%c", nConsoleWidth, "", chSrc, chDest, chLineEnd );
                        }
                        LeaveCriticalSection( &pcs );
                    }
                }
            }

            *pchSpotDest = '\0';
            *pchSpotSrc  = '\0';
        }

        fnChild = fnChild->fnSibling.mem_ptr;
    }
    return( dwCount );
}

DWORD
WINAPI
ThreadFunction(
              LPVOID  lpParameter
              )
{
    LPSTR           lpSearch;
    DWORD           mask;
    DWORD           dw;
    CHAR            chDest[MAX_PATH];
    CHAR            chSrc[MAX_PATH];
    DWORD           dwCount;

    dw = (DWORD)(DWORD_PTR)lpParameter;

    lpSearch = chPath[dw];
    mask = dwMasks[dw-1];

    EnumFiles( lpSearch, fnRoot, mask, dw-1 );

    strcpy( chDest, chPath[0] );
    strcpy( chSrc, chPath[dw] );

    CopyThem( fnRoot, chDest, chSrc, dw, mask, TRUE );

    strcpy( chDest, chPath[0] );
    strcpy( chSrc, chPath[dw] );

    do {
        dwCount = CopyThem( fnRoot, chDest, chSrc, dw, mask, FALSE );
    } while ( dwCount != 0 && !EverybodyBailOut);

    EverybodyBailOut = TRUE;
    return( 0 );
}


VOID
EnumStraglers(
             LPSTR       lpPath,
             FILENAME    *fn,
             DWORD       dwTotalMask
             )
{
    FILENAME    *fnChild;
    CHAR        NewName[MAX_PATH];
    CHAR        *pch;
    CHAR        *pchSpot;

    pchSpot = lpPath + strlen(lpPath);

    fnChild = fn->fnChild.mem_ptr;
    while ( fnChild ) {

        pch = pchSpot;

        strcpy( pch, fnChild->cFileName );
        if ( (fnChild->dwStatus & dwTotalMask) != dwTotalMask ) {
            if ( fLogTreeDifferences ) {
                printf( "File %s is not on all source locations\n", lpPath );
            }
            nStraglers++;
        }
        if ( (fnChild->dwStatus & DIRECTORY) == DIRECTORY ) {
            strcat( pch, "\\" );
            EnumStraglers( lpPath, fnChild, dwTotalMask );
        }
        fnChild = fnChild->fnSibling.mem_ptr;
    }
}

VOID
DumpStraglers(
             DWORD       dwTotalMask
             )
{
    CHAR        cPath[MAX_PATH];

    strcpy( cPath, "<SRC>\\" );

    EnumStraglers( cPath, fnRoot, dwTotalMask );

    if ( nStraglers != 0 ) {
        printf("Files found on some source locations, but not on others\n");
        printf("Run SUCK with -x option to enumerate differences.\n");
    }
}

void
EnumDATFileData(
               FILENAME    *fnParent,
               DWORD       dwDiskPtr
               )
{
    FILENAME    fnDiskName;
    FILENAME    *fnChild = &fnDiskName;
    FILENAME    *fnCurrent;
    int         iSeek;
    int         iCount;

    //
    // Read in this level from the DAT file
    //
    while ( dwDiskPtr != 0 ) {

        // Seek to this entry

        iSeek = fseek( SuckDATFile, dwDiskPtr, SEEK_SET );

        if ( iSeek != 0 ) {
            printf("SUCK.DAT seek error, remove and restart\n");
            exit(3);
        }

        // Read in this entry

        iCount = fread( (void *)fnChild, sizeof(FILENAME), 1, SuckDATFile );
        if ( iCount != 1 ) {
            printf("SUCK.DAT read error, remove and restart\n");
            exit(4);
        }

#ifdef SEE_EM
        printf("Reading record [%s], at %08lX Child %08lX Sib %08lX\n", fnChild->cFileName, dwDiskPtr, fnChild->fnChild.disk_ptr, fnChild->fnSibling.disk_ptr );
        printf("Size = %d\n", fnChild->dwFileSizeLow );
#endif

        //
        // Add this file node to the tree
        //

        fnCurrent = AllocateFileName();


        fnCurrent->dwStatus          = fnChild->dwStatus;
        fnCurrent->dwCopy            = 0;

        fnCurrent->fnParent.mem_ptr  = fnParent;
        fnCurrent->fnChild.mem_ptr   = NULL;

        fnCurrent->fnSibling.mem_ptr = fnParent->fnChild.mem_ptr;

        fnCurrent->dwFileSizeLow     = 0;
        fnCurrent->dwFileSizeHigh    = 0;
        fnCurrent->ftFileTime        = ftZero;
        fnCurrent->dwDATFileSizeLow  = fnChild->dwFileSizeLow;
        fnCurrent->dwDATFileSizeHigh = fnChild->dwFileSizeHigh;
        fnCurrent->ftDATFileTime     = fnChild->ftFileTime;

        fnCurrent->dwFileNameLen     = fnChild->dwFileNameLen;
        strcpy( fnCurrent->cFileName, fnChild->cFileName );

        fnParent->fnChild.mem_ptr = fnCurrent;

        if ( (fnCurrent->dwStatus & DIRECTORY) == DIRECTORY ) {
            nDirectories++;
            //
            // Load this directories children
            //
            EnumDATFileData( fnCurrent, fnChild->fnChild.disk_ptr );
        } else {
            fnCurrent->dwStatus = 0;
            nFiles++;
        }

        // Move to next sibling at this level

        dwDiskPtr = fnChild->fnSibling.disk_ptr;
    }
}

void
LoadFileTimesAndSizes(
                     BOOL        fUseSuckDATFile
                     )
{
    CHAR        cPath[MAX_PATH];
    FILEHEADER  fileheader;
    int         iCount;

    //
    // Initialize the tree root
    //
    fnRoot = AllocateFileName();

    fnRoot->fnParent.mem_ptr  = NULL;
    fnRoot->fnChild.mem_ptr   = NULL;
    fnRoot->fnSibling.mem_ptr = NULL;
    strcpy( fnRoot->cFileName, "<ROOT>" );

    // Look for SUCK.DAT

    if ( fUseSuckDATFile ) {
        SuckDATFile = fopen( SUCK_DAT_FILE, "rb" );
    } else {
        SuckDATFile = NULL;
    }

    if ( SuckDATFile != NULL ) {
        //
        // If file exists, then load the data from it.
        //
        printf("Loading Previous Statistics...\n");

        iCount = fread( &fileheader, sizeof(fileheader), 1, SuckDATFile );

        if ( iCount != 1 ) {
            printf("Error reading SUCK.DAT file, remove and restart\n");
            exit(1);
        }

        EnumDATFileData( fnRoot, fileheader.fnRoot.disk_ptr );

        fclose( SuckDATFile );

    }
}

int
EnumFileTimesAndSizes(
                     DWORD       dwDiskPtr,
                     FILENAME    *fn
                     )
{
    FILENAME    fnDiskName;
    FILENAME    *fnChild = &fnDiskName;
    FILENAME    *fnCurrent;
    VIRTPTR     fnChildPtr;
    VIRTPTR     fnSiblingPtr;
    int         nRecords;
    int         nChildren;
    int         iCount;

    //
    // The 1st guy in the list will be at the end of the list
    //
    fnSiblingPtr.disk_ptr = 0;
    nRecords = 0;

    fnCurrent = fn->fnChild.mem_ptr;
    while ( fnCurrent ) {

        *fnChild = *fnCurrent;

        if ( (fnCurrent->dwStatus & DIRECTORY) == DIRECTORY ) {
            nChildren = EnumFileTimesAndSizes( dwDiskPtr, fnCurrent );
            nRecords += nChildren;
            dwDiskPtr += nChildren * sizeof(FILENAME);
            if ( nRecords == 0 ) {
                fnChildPtr.disk_ptr = 0;
            } else {
                // Point to previous one, it was our child
                fnChildPtr.disk_ptr = dwDiskPtr - sizeof(FILENAME);
            }
        } else {
            fnChildPtr.disk_ptr = 0;
        }
        fnChild->fnChild.disk_ptr = fnChildPtr.disk_ptr;

        fnChild->fnSibling.disk_ptr = fnSiblingPtr.disk_ptr;
        fnSiblingPtr.disk_ptr = dwDiskPtr;

#ifdef SEE_EM
        printf("Writing record [%s], at %08lX Child %08lX Sib %08lX\n", fnChild->cFileName, dwDiskPtr, fnChild->fnChild.disk_ptr, fnChild->fnSibling.disk_ptr );
        printf("Size = %d\n", fnChild->dwFileSizeLow );
#endif

        iCount = fwrite( fnChild, sizeof(FILENAME), 1, SuckDATFile );
        if ( iCount != 1 ) {
            printf("SUCK.DAT error writing data\n");
            exit(1);

        }
        dwDiskPtr += sizeof(FILENAME);
        nRecords++;

        fnCurrent = fnCurrent->fnSibling.mem_ptr;
    }
    return( nRecords );
}

VOID
UpdateFileTimesAndSizes(
                       VOID
                       )
{
    CHAR        cPath[MAX_PATH];
    FILEHEADER  fileheader;
    int         iSeek;
    int         iCount;
    DWORD       dwDiskPtr;
    int         nChildren;

    printf("Updating Statistics...\n");

    SuckDATFile = fopen( SUCK_DAT_FILE, "wb+" );
    if ( SuckDATFile == NULL ) {
        printf( "Error creating file '%s', update aborted\n", SUCK_DAT_FILE );
        return;
    }

    fileheader.fnRoot.disk_ptr = 0;             // Temporary...

    iCount = fwrite( &fileheader, sizeof(fileheader), 1, SuckDATFile );
    if ( iCount != 1 ) {
        printf("SUCK.DAT error writing header\n");
        exit(1);
    }

    dwDiskPtr = sizeof(fileheader);

    nChildren = EnumFileTimesAndSizes( dwDiskPtr, fnRoot );
    dwDiskPtr += nChildren * sizeof(FILENAME);

    if ( nChildren == 0 ) {
        dwDiskPtr = 0;
    } else {
        dwDiskPtr -= sizeof(FILENAME);
    }

    fileheader.fnRoot.disk_ptr = dwDiskPtr;     // Now update for real...

    iSeek = fseek( SuckDATFile, 0, SEEK_SET );

    if ( iSeek != 0 ) {
        printf("SUCK.DAT error seeking to write header\n");
        exit(3);
    }

    iCount = fwrite( &fileheader, sizeof(fileheader), 1, SuckDATFile );
    if ( iCount != 1 ) {
        printf("SUCK.DAT error writing header\n");
        exit(1);
    }

    fclose( SuckDATFile );
}

CHAR *NewArgv[MAX_ARGS];
CHAR chCommand[MAX_COMMAND_LINE+1];

VOID
LookForLastCommand(
                  INT     *pargc,
                  CHAR    **pargv[]
                  )
{
    CHAR    *pSpace;
    CHAR    *pNextArg;

    GetPrivateProfileString("Init", "LastCommand", "", chCommand, MAX_COMMAND_LINE, SUCK_INI_FILE );
    if ( strlen(chCommand) == 0 ) {
        return;
    }

    pNextArg = chCommand;
    *pargv = NewArgv;
    (*pargv)[1] = "";

    *pargc = 1;

    do {
        (*pargc)++;
        pSpace = strchr( pNextArg, ' ' );
        if ( pSpace ) {
            *pSpace = '\0';
        }

        (*pargv)[(*pargc)-1] = pNextArg;
        pNextArg = pSpace + 1;
    } while ( pSpace != NULL );
}

VOID
UpdateLastCommandLine(
                     INT     argc,
                     CHAR    *argv[]
                     )
{
    CHAR    chLastCommand[MAX_COMMAND_LINE+1];
    INT     nArg;

    chLastCommand[0] = '\0';

    nArg = 1;

    while ( nArg < argc ) {
        strcat( chLastCommand, argv[nArg] );
        nArg++;
        if ( nArg != argc ) {
            strcat( chLastCommand, " " );
        }
    }
    WritePrivateProfileString("Init", "LastCommand", chLastCommand, SUCK_INI_FILE );
}


VOID
ReplaceEnvironmentStrings(
                         CHAR    *pText
                         )
{
    CHAR    *pOpenPercent;
    CHAR    *pClosePercent;
    CHAR    chBuffer[MAX_PATH];
    CHAR    *pSrc;
    CHAR    *pEnvString;

    chBuffer[0] = '\0';
    pSrc = pText;

    do {
        pOpenPercent = strchr( pSrc, '%' );
        if ( pOpenPercent == NULL ) {
            strcat( chBuffer, pSrc );
            break;
        }
        pEnvString = pOpenPercent + 1;
        pClosePercent = strchr( pEnvString, '%' );
        if ( pClosePercent == NULL ) {
            strcat( chBuffer, pSrc );
            break;
        }
        if ( pEnvString == pClosePercent ) {
            strcat( chBuffer, "%" );
        } else {
            *pOpenPercent  = '\0';
            *pClosePercent = '\0';

            strcat( chBuffer, pSrc );
            GetEnvironmentVariable( pEnvString,
                                    chBuffer + strlen(chBuffer),
                                    MAX_PATH );
        }
        pSrc = pClosePercent+1;
    } while ( TRUE );

    strcpy( pText, chBuffer );
}


DWORD
DiffTimes(
         SYSTEMTIME *start,
         SYSTEMTIME *end
         )
{
    DWORD nSecStart;
    DWORD nSecEnd;

    nSecStart = start->wHour*60*60 +
                start->wMinute*60 +
                start->wSecond;

    nSecEnd = end->wHour*60*60 +
              end->wMinute*60 +
              end->wSecond;

    return nSecEnd - nSecStart;
}

VOID
Usage(
     VOID
     )
{
    fputs("SUCK: Usage  suck [-options] <dest> <src> [<src>...]\n"
          "      (maximum of 29 src directories)\n"
          "\n"
          "  where options are:   x - List source differences (if any)\n"
          "                       s - Produce script, don't copy\n"
          "                       q - Quiet mode (no stdout)\n"
          "                       p - Display progress on one line\n"
          "                         (cannot be used with -q or -s)\n"
          "                       z - Copy over readonly files\n"
          "                       e - Exclude directory\n"
          "                         e.g. -eidw -emstools\n"
          , stderr);
}

VOID
ArgError(
        INT    nArg,
        CHAR * pszArg
        )
{
    fprintf( stderr, "\nError in arg #%d - '%s'\n\n", nArg, pszArg );
    Usage();
    exit(1);
}

int
__cdecl
main(
    int         argc,
    char        *argv[]
    )
{
    HANDLE      hThreads[MAX_THREADS];
    DWORD       dwThreadId;
    DWORD       nThreads;
    INT         nArg;
    DWORD       nPaths;
    CHAR        *pch;
    CHAR        *pch2;
    DWORD       dwTotalMask;
    OFSTRUCT    ofs;
    BOOL        fUpdateCommandLine = TRUE;
    CHAR *      pchNextExclude = gExcludes;
    SYSTEMTIME  stStart;
    SYSTEMTIME  stEnd;
    DWORD       nSeconds;
    DWORD       nMinutes;
    // kenhia 15-Mar-1996: add support for -#:<share>
    CHAR *      PlatformPoundArray[] = PLATFORM_SPECIFIC_SHARES;
    DWORD       nPound = 0;
    // DavidP 23-Jan-1998: Allow multiple levels of quiet
    DWORD       dwConsoleMode      = 0;
    BOOL        fWasConsoleModeSet = FALSE;
    HANDLE      hStdOut            = NULL;

    if ( argc < 2 ) {
        LookForLastCommand( &argc, &argv );
        fUpdateCommandLine = FALSE;
    }

    if ( argc < 3 ) {
        Usage();
        exit(1);
    }

    nArg = 1;
    nPaths = 0;

    while ( nArg < argc ) {

        pch = argv[nArg];

        if ( *pch == '-' ) {
            BOOL fExitSwitchLoop = FALSE;
            pch++;
            while ( *pch && !fExitSwitchLoop) {
                switch ( *pch ) {
                    case 's':
                        // DavidP 23-Jan-1998: Allow multiple levels of quiet
                        if ( fProgressMode ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        fScriptMode = TRUE;
                        break;
                    case 'q':
                        // DavidP 23-Jan-1998: Allow multiple levels of quiet
                        if ( fProgressMode ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        fQuietMode = TRUE;
                        break;
                    case 'p': // DavidP 23-Jan-1998: Allow multiple levels of quiet
                        if ( fQuietMode || fScriptMode ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        fProgressMode = TRUE;
                        chLineEnd = '\r';
                        break;
                    case 'x':
                        fLogTreeDifferences = TRUE;
                        break;
                    case 'y':
                        fUpdateINIBase = TRUE;
                        break;
                    case 'z':
                        fDestroy = TRUE;
                        break;
                    case 'e':
                        if ( pchNextExclude - gExcludes + strlen(++pch) + 2 > MAX_EXCLUDES ) {
                            ArgError( nArg, argv[nArg] );
                        }
                        strcpy(pchNextExclude, pch);
                        pchNextExclude += strlen(pchNextExclude)+1;
                        *pchNextExclude = 0;
                        fExitSwitchLoop = TRUE;
                        break;

                        // kenhia 15-Mar-1996: add support for -#:<share>
                    case '#':
                        pch++;
                        if ( *pch != ':' ) {
                            Usage();
                            exit(1);
                        }
                        while ( PlatformPoundArray[nPound] ) {
                            if ( nPaths >= MAX_THREADS ) {
                                Usage();
                                exit(1);
                            }
                            strcpy( chPath[nPaths], "\\\\" );
                            strcat( chPath[nPaths], PlatformPoundArray[nPound] );
                            strcat( chPath[nPaths], "\\" );
                            strcat( chPath[nPaths], pch+1 );

                            pch2 = chPath[nPaths] + strlen(chPath[nPaths]) - 1;
                            if ( *pch2 != '\\' && *pch2 != '/' && *pch2 != ':' ) {
                                *++pch2 = '\\';
                                *++pch2 = '\0';
                            }

                            ReplaceEnvironmentStrings( chPath[nPaths] );

                            nPound++;
                            nPaths++;
                        }
                        fExitSwitchLoop = TRUE;
                        break;

                    default:
                        Usage();
                        exit(1);
                }
                pch++;
            }
        } else {
            if ( nPaths >= MAX_THREADS ) {
                Usage();
                exit(1);
            }

            strcpy( chPath[nPaths], argv[nArg] );

            pch = chPath[nPaths] + strlen(chPath[nPaths]) - 1;

            if ( *pch != '\\' && *pch != '/' && *pch != ':' ) {
                *++pch = '\\';
                *++pch = '\0';
            }

            ReplaceEnvironmentStrings( chPath[nPaths] );

            nPaths++;
        }
        nArg++;
    }

    nThreads = --nPaths;

    if ( nThreads == 0 ) {
        Usage();
        exit(1);
    }

    // DavidP 23-Jan-1998: Allow multiple levels of quiet
    if ( fProgressMode ) {
        hStdOut = GetStdHandle( STD_OUTPUT_HANDLE );
        if ( hStdOut != INVALID_HANDLE_VALUE ) {
            CONSOLE_SCREEN_BUFFER_INFO csbi;
            if ( GetConsoleScreenBufferInfo( hStdOut, &csbi ) ) {
                nConsoleWidth = csbi.dwSize.X - 1;
            }
        }
        fWasConsoleModeSet = GetConsoleMode( hStdOut, &dwConsoleMode );
        if ( fWasConsoleModeSet ) {
            SetConsoleMode( hStdOut, dwConsoleMode & ~ENABLE_WRAP_AT_EOL_OUTPUT );
        }
    }

    InitializeCriticalSection( &cs );
    InitializeCriticalSection( &pcs );

    printf("Streamlined Utility for Copying Kernel v1.1 (%d %s)\n", nThreads, (nThreads == 1 ? "thread" : "threads") );

    GetSystemTime( &stStart );

    LoadFileTimesAndSizes( fUseDAT );

    dwTotalMask = 0;
    while ( nPaths ) {

        hThreads[nPaths-1] = CreateThread( NULL,
                                           0L,
                                           ThreadFunction,
                                           (LPVOID)UlongToPtr(nPaths),
                                           0,
                                           &dwThreadId );
        dwTotalMask |= dwMasks[nPaths-1];

        --nPaths;
    }

    WaitForMultipleObjects( nThreads,
                            hThreads,
                            TRUE,          // WaitAll
                            (DWORD)-1 );

    // DavidP 23-Jan-1998: Allow multiple levels of quiet
    if ( fProgressMode ) {
        printf("%*s\r", nConsoleWidth, "");
        if ( fWasConsoleModeSet ) {
            SetConsoleMode( hStdOut, dwConsoleMode );
        }
    }

    printf("Copy complete, %ld file entries\n", nFiles+nDirectories);

    nPaths = 0;
    while ( nPaths < nThreads ) {
        printf("%11ld bytes from %s\n", dwTotalSizes[nPaths], chPath[nPaths+1] );
        nPaths++;
    }

    nPaths = nThreads;
    while ( nPaths ) {
        nPaths--;
        CloseHandle( hThreads[nPaths] );
    }

    DumpStraglers( dwTotalMask );

    if ( fUpdateINIBase ) {
        UpdateFileTimesAndSizes();
    }

    FreeFileNames();

    DeleteCriticalSection( &cs );
    DeleteCriticalSection( &pcs );

    if ( fUpdateCommandLine ) {
        UpdateLastCommandLine( argc, argv );
    }

    GetSystemTime( &stEnd );

    nSeconds = DiffTimes( &stStart, &stEnd );

    nMinutes = nSeconds / 60;
    nSeconds = nSeconds % 60;
    printf("Done, Elapsed time: %02d:%02d\n", nMinutes, nSeconds);

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\soutil.c ===
/****************************** Module Header ******************************\
* Module Name: soutil.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"
/*********************************************************************
* soLosgMsg
\***************************************************************************/
void __cdecl soLogMsg(DWORD dwFlags, char *pszfmt, ...)
{
    static BOOL gfAppending = FALSE;

    va_list va;

    if (!(dwFlags & SOLM_NOLABEL)) {
        if (gfAppending) {
            fprintf(stdout, "\r\n");
        }
        fprintf(stdout, "STRUCTO: ");
    }

    if (dwFlags & SOLM_ERROR) {
        fprintf(stdout, "Error: ");
    } else if (dwFlags & SOLM_WARNING) {
        fprintf(stdout, "Warning: ");
    }

    va_start(va, pszfmt);
    vfprintf(stdout, pszfmt, va);
    va_end(va);

    if (dwFlags & SOLM_API) {
        soLogMsg (SOLM_NOLABEL | SOLM_NOEOL, " Failed. GetLastError: %d", GetLastError());
    }

    gfAppending = (dwFlags & SOLM_NOEOL);
    if (!gfAppending) {
        fprintf(stdout, "\r\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\structo\sofile.c ===
/****************************** Module Header ******************************\
* Module Name: sofile.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* 04/09/96 GerardoB Created
\***************************************************************************/
#include "structo.h"

/*********************************************************************
* soWriteOutputFileHeader
*
\***************************************************************************/
BOOL soWriteOutputFileHeader (PWORKINGFILES pwf)
{
    char ** ppszHeader;

    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        return TRUE;
    }

    if (   !soWriteFile(pwf->hfileOutput, "/*********************************************************************\\\r\n")
        || !soWriteFile(pwf->hfileOutput, "* File: %s\r\n", pwf->pszOutputFile)
        || !soWriteFile(pwf->hfileOutput, "* Generated by StructO on %s at %s\r\n", __DATE__, __TIME__)
        || !soWriteFile(pwf->hfileOutput, "\\*********************************************************************/\r\n\r\n")) {

        return FALSE;
   }

   if (pwf->dwOptions & SOWF_INLCLUDEPRECOMPH) {
       if (!soWriteFile(pwf->hfileOutput, gszPrecomph)) {
           return FALSE;
       }
   }

   /*
    * structure definitions for generated tables
    */
   ppszHeader = gpszHeader;
   while (*ppszHeader != NULL) {
       if (!soWriteFile(pwf->hfileOutput, *ppszHeader)
            || !soWriteFile(pwf->hfileOutput, "\r\n")) {

           return FALSE;
       }
       ppszHeader++;
   }


   return TRUE;
}
/*********************************************************************
* soUnmapFile
*
\***************************************************************************/
void soUnmapFile (PFILEMAP pfm)
{
    if (pfm->pmapStart != NULL) {
        UnmapViewOfFile(pfm->pmap);
        pfm->pmapStart = NULL;
        pfm->pmap = NULL;
        pfm->pmapEnd = NULL;
    }

    if (pfm->hmap != NULL) {
        CloseHandle(pfm->hmap);
        pfm->hmap = NULL;
    }

    if (pfm->hfile != INVALID_HANDLE_VALUE) {
        CloseHandle(pfm->hfile);
        pfm->hfile = INVALID_HANDLE_VALUE;
    }
}
/*********************************************************************
* soMapFile
*
\***************************************************************************/
BOOL soMapFile (char * pszFile, PFILEMAP pfm)
{
    DWORD dwFileSize;

    pfm->hfile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
    if (pfm->hfile == INVALID_HANDLE_VALUE) {
        soLogMsg(SOLM_APIERROR, "CreateFile");
        goto CleanupAndFail;
    }

    dwFileSize = GetFileSize(pfm->hfile, NULL);
    if (dwFileSize == 0xFFFFFFFF) {
        soLogMsg(SOLM_APIERROR, "GetFileSize");
        goto CleanupAndFail;
    }

    pfm->hmap = CreateFileMapping(pfm->hfile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (pfm->hmap == NULL) {
        soLogMsg(SOLM_APIERROR, "CreateFileMapping");
        goto CleanupAndFail;
    }

    pfm->pmapStart = MapViewOfFile(pfm->hmap, FILE_MAP_READ, 0, 0, 0);
    if (pfm->pmapStart == NULL) {
        soLogMsg(SOLM_APIERROR, "MapViewOfFile");
        goto CleanupAndFail;
    }
    pfm->pmap = pfm->pmapStart;
    pfm->pmapEnd = pfm->pmapStart + dwFileSize;

    return TRUE;

CleanupAndFail:
    soLogMsg(SOLM_ERROR, "soMapFile failed. File: '%s'", pszFile);
    soUnmapFile (pfm);
    return FALSE;
}
/*********************************************************************
* soBuildStructsList
*
\***************************************************************************/
BOOL soBuildStructsList (PWORKINGFILES pwf)
{
    static char gszEOL [] = "\r\n";

    char * pmap, * pStruct;
    FILEMAP fm;
    PSTRUCTLIST psl;
    PVOID pTemp;
    UINT uAlloc, uCount, uSize;


    soLogMsg (SOLM_NOEOL, "Building structs list from %s ...", pwf->pszStructsFile);

    if (!soMapFile (pwf->pszStructsFile, &fm)) {
        goto CleanupAndFail;
    }

    /*
     * Let's guess a number of structures
     */
#define SO_LISTSIZE 20
     uAlloc = SO_LISTSIZE;

    /*
     * Allocate list
     */
    pwf->psl = (PSTRUCTLIST) LocalAlloc(LPTR, sizeof(STRUCTLIST) * (uAlloc + 1));
    if (pwf->psl == NULL) {
        soLogMsg(SOLM_APIERROR, "LocalAlloc");
        goto CleanupAndFail;
    }

    /*
     * Load structure names
     */
    pmap = fm.pmapStart;
    psl = pwf->psl;
    uCount = 0;
    while (pmap < fm.pmapEnd) {
        /*
         * Name should start at first column
         */
        if (!soIsIdentifierChar(*pmap)) {
            /*
             * Skip this line
             */
             pmap = soFindTag(pmap, fm.pmapEnd, gszEOL);
             if (pmap == NULL) {
                 break;
             }
             pmap += sizeof(gszEOL) - 1;
             continue;
        }

        /*
         * Find the name
         */
        pStruct = soGetIdentifier (pmap, fm.pmapEnd, &uSize);
        if (pStruct == NULL) {
            soLogMsg(SOLM_ERROR, "soGetIdentifier failed.");
            goto CleanupAndFail;
        }

        /*
         * Grow the list if needed
         */
         if (uCount >= uAlloc) {
             soLogMsg (SOLM_APPEND, ".");
             uAlloc += SO_LISTSIZE;
             pTemp = LocalReAlloc(pwf->psl, sizeof(STRUCTLIST) * (uAlloc + 1), LMEM_MOVEABLE | LMEM_ZEROINIT);
             if (pTemp == NULL) {
                 soLogMsg(SOLM_APIERROR, "LocalReAlloc");
                 goto CleanupAndFail;
             }
             pwf->psl = (PSTRUCTLIST)pTemp;
             psl = pwf->psl + uCount;
         }

        /*
         * Copy it
         */
        psl->uSize = uSize;
        psl->pszName = soCopyTagName (pStruct, uSize);
        if (psl->pszName == NULL) {
            goto CleanupAndFail;
        }

        psl++;
        uCount++;
        pmap = pStruct + uSize;
    }

    /*
     * Make sure it found at least one struct
     */
    if (uCount == 0) {
        soLogMsg(SOLM_ERROR, "Failed to get structure name");
        goto CleanupAndFail;
    }

    /*
     * Let's save some memory
     */
    if (uCount < uAlloc) {
        pTemp = LocalReAlloc(pwf->psl, sizeof(STRUCTLIST) * (uCount + 1), LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pTemp == NULL) {
            soLogMsg(SOLM_APIERROR, "LocalReAlloc");
            goto CleanupAndFail;
        }
        pwf->psl = (PSTRUCTLIST)pTemp;
    }

    soUnmapFile (&fm);
    soLogMsg (SOLM_NOLABEL, ".");
    return TRUE;

CleanupAndFail:
    soLogMsg(SOLM_ERROR, "soBuildStructsList failed. File: '%s'", pwf->pszStructsFile);
    soUnmapFile (&fm);
    /*
     * The process is going away so never mind the heap
     */
    return FALSE;
}
/*********************************************************************
* soIncludeInputFile
*
* Add #include <pszInputFile Name>.<pszIncInputFileExt> to output file
\***************************************************************************/
BOOL soIncludeInputFile (PWORKINGFILES pwf)
{
    BOOL fRet;
    char * pszIncFile, * pDot;
    UINT uInputFileNameSize;

    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        return TRUE;
    }

    /*
     * Allocate a buffer to build the name
     */
    uInputFileNameSize = lstrlen(pwf->pszInputFile);
    pszIncFile = (char *) LocalAlloc(LPTR,
                          uInputFileNameSize + lstrlen(pwf->pszIncInputFileExt) + 2);
    if (pszIncFile == NULL) {
        soLogMsg(SOLM_APIERROR, "LocalAlloc");
        return FALSE;
    }

    /*
     * Copy file name
     */
    pDot = soFindChar (pwf->pszInputFile, pwf->pszInputFile + uInputFileNameSize, '.');
    if (pDot == NULL) {
        strcpy(pszIncFile, pwf->pszInputFile);
        strcat(pszIncFile, ".");
    } else {
        strncpy(pszIncFile, pwf->pszInputFile, (UINT)(pDot - pwf->pszInputFile + 1));
    }

    /*
     * Copy extension and write it to output file
     */
     strcat(pszIncFile, pwf->pszIncInputFileExt);
     fRet = soWriteFile(pwf->hfileOutput, gszIncInput, pszIncFile);

     LocalFree(pszIncFile);
     return fRet;
}
/*********************************************************************
* soOpenWorkingFiles
*
\***************************************************************************/
BOOL soOpenWorkingFiles (PWORKINGFILES pwf)
{
    char szTempPath [MAX_PATH];
    char szTempFile [MAX_PATH];
    DWORD dwFileSize;

    /*
     * Load the structures list if provided and not built already
     */
    if ((pwf->pszStructsFile != NULL) && (pwf->psl == NULL)) {
        if (!soBuildStructsList(pwf)) {
            goto CleanupAndFail;
        }
    }

    /*
     * Map input file
     */
    if (!soMapFile (pwf->pszInputFile, (PFILEMAP) &(pwf->hfileInput))) {
        goto CleanupAndFail;
    }


    /*
     * Open output file if not open already
     */
    if (pwf->hfileOutput == INVALID_HANDLE_VALUE) {
        pwf->hfileOutput = CreateFile(pwf->pszOutputFile, GENERIC_WRITE, 0, NULL,
                            (pwf->dwOptions & SOWF_APPENDOUTPUT ? OPEN_EXISTING : CREATE_ALWAYS),
                            FILE_ATTRIBUTE_NORMAL,  NULL);
        if (pwf->hfileOutput == INVALID_HANDLE_VALUE) {
            soLogMsg(SOLM_APIERROR, "CreateFile");
            soLogMsg(SOLM_ERROR, "Failed to open output file: %s", pwf->pszOutputFile);
            goto CleanupAndFail;
        }

        if (pwf->dwOptions & SOWF_APPENDOUTPUT) {
            if (0xFFFFFFFF == SetFilePointer (pwf->hfileOutput, 0, 0, FILE_END)) {
                soLogMsg(SOLM_APIERROR, "SetFilePointer");
                goto CleanupAndFail;
            }
        } else {
            if (!soWriteOutputFileHeader(pwf)) {
                goto CleanupAndFail;
            }
        }
    }


    /*
     * #include input file if requested
     */
    if (pwf->dwOptions & SOWF_INCLUDEINPUTFILE) {
        if (!soIncludeInputFile(pwf)) {
            goto CleanupAndFail;
        }
    }

    /*
     * Create temp file if not created already
     */
    if (pwf->hfileTemp == INVALID_HANDLE_VALUE) {
        if (!GetTempPath(sizeof(szTempPath) - 1, szTempPath)) {
            soLogMsg(SOLM_APIERROR, "GetTempPath");
            goto CleanupAndFail;
        }

        if (!GetTempFileName(szTempPath, "sot", 0, szTempFile)) {
            soLogMsg(SOLM_APIERROR, "GetTempFileName");
            soLogMsg(SOLM_ERROR, "Failed to get temp file name. szTempPath: %s.", szTempPath);
            goto CleanupAndFail;
        }

        pwf->hfileTemp = CreateFile(szTempFile, GENERIC_WRITE | GENERIC_READ, 0, NULL,
                            CREATE_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE,  NULL);
        if (pwf->hfileTemp == INVALID_HANDLE_VALUE) {
            soLogMsg(SOLM_APIERROR, "CreateFile");
            soLogMsg(SOLM_ERROR, "Failed to create temp file: '%s'", szTempFile);
            goto CleanupAndFail;
        }

        if (!soWriteFile(pwf->hfileTemp, "%s", gszTableDef)) {
            goto CleanupAndFail;
        }
    }


    return TRUE;

CleanupAndFail:
    soLogMsg(SOLM_ERROR, "soOpenWorkingFiles Failed");
    soCloseWorkingFiles (pwf, SOCWF_CLEANUP);
    return FALSE;
}

/*********************************************************************
* soCloseWorkingFiles
*
\***************************************************************************/
BOOL soCloseWorkingFiles (PWORKINGFILES pwf, DWORD dwFlags)
{

   if (dwFlags & SOCWF_CLEANUP) {
       if (pwf->hfileTemp != INVALID_HANDLE_VALUE) {
            CloseHandle(pwf->hfileTemp);
            pwf->hfileTemp = INVALID_HANDLE_VALUE;
       }
       if (pwf->hfileOutput != INVALID_HANDLE_VALUE) {
            CloseHandle(pwf->hfileOutput);
            pwf->hfileOutput = INVALID_HANDLE_VALUE;
       }
       if (pwf->psl != NULL) {
           // Never mind cleanning the heap. The process is going away.
       }
   }

   soUnmapFile((PFILEMAP) &(pwf->hfileInput));

   return TRUE;
}
/*********************************************************************
* soWriteFile
*
\***************************************************************************/
BOOL __cdecl soWriteFile(HANDLE hfile, char *pszfmt, ...)
{
    static char gszbuff [1024+1];

    BOOL fRet = TRUE;
    va_list va;
    DWORD dwWritten;

    va_start(va, pszfmt);
    vsprintf(gszbuff, pszfmt, va);

    if (!WriteFile(hfile, gszbuff, strlen(gszbuff), &dwWritten, NULL)) {
        soLogMsg(SOLM_APIERROR, "WriteFile");
        soLogMsg(SOLM_ERROR, "buffer not written: %s.", gszbuff);
        fRet = FALSE;
    }

    va_end(va);
    return fRet;
}
/*********************************************************************
* soCopyStructuresTable
*
\***************************************************************************/
BOOL soCopyStructuresTable (PWORKINGFILES pwf)
{
    static char szTemp[1024];

    char ** ppszTail;
    DWORD dwFileSize, dwRead, dwWritten;
    PSTRUCTLIST psl;
    UINT uLoops;

    soLogMsg (SOLM_NOEOL, "Writting structs table ...");

    /*
     * If there are no structures, bail.
     * If there was a struct list, fail
     */
    if (pwf->uTablesCount == 0) {
        if (pwf->psl != NULL) {
            soLogMsg(SOLM_ERROR, "None of the structures in '%s' was found", pwf->pszStructsFile);
            return FALSE;
        } else {
            return TRUE;
        }
    }

    /*
     * If building list only, done
     */
    if (pwf->dwOptions & SOWF_LISTONLY) {
        soLogMsg (SOLM_DEFAULT, "%d Structures found.", pwf->uTablesCount);
        return TRUE;
    }

   /*
     * Let them know if we didn't find any of the structures in the list
     */
    if (pwf->psl != NULL) {
        psl = pwf->psl;
        while (psl->uSize != 0) {
            if (psl->uCount == 0) {
                soLogMsg(SOLM_WARNING, "Structure not found: %s", psl->pszName);
            }
            psl++;
        }
    }

    if (!soWriteFile(pwf->hfileTemp, "%s", gszTableEnd)) {
        goto MsgAndFail;
    }

   /*
    * Move to beginning of temp file
    */
   dwFileSize = GetFileSize(pwf->hfileTemp, NULL);
   if (dwFileSize == 0xFFFFFFFF) {
       soLogMsg(SOLM_APIERROR, "GetFileSize");
       goto MsgAndFail;
   }

   if (0xFFFFFFFF == SetFilePointer (pwf->hfileTemp, 0, 0, FILE_BEGIN)) {
       soLogMsg(SOLM_APIERROR, "SetFilePointer");
       goto MsgAndFail;
   }

   /*
    * Append temp file to output file
    */
   uLoops = 0;
   while (dwFileSize != 0) {
       if (!ReadFile(pwf->hfileTemp, szTemp, sizeof(szTemp), &dwRead, NULL)) {
           soLogMsg(SOLM_APIERROR, "ReadFile");
           goto MsgAndFail;
       }

       if (!WriteFile(pwf->hfileOutput, szTemp, dwRead, &dwWritten, NULL)) {
           soLogMsg(SOLM_APIERROR, "WriteFile");
           goto MsgAndFail;
       }

       dwFileSize -= dwRead;
       if (++uLoops == 50) {
           uLoops = 0;
           soLogMsg (SOLM_APPEND, ".");
       }
   }
   soLogMsg (SOLM_NOLABEL, ".");

   soLogMsg (SOLM_DEFAULT, "%d Tables generated.", pwf->uTablesCount);

   /*
    * Write file tail (code)
    */
   ppszTail = gpszTail;
    while (*ppszTail != NULL) {
    if (!soWriteFile(pwf->hfileOutput, *ppszTail)
         || !soWriteFile(pwf->hfileOutput, "\r\n")) {

        return FALSE;
    }
    ppszTail++;
}


   return TRUE;

MsgAndFail:
   soLogMsg(SOLM_ERROR, "soCopyStructuresTable failed.");
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\symlink\makefile.inc ===
$(O)\mklnk.res: mklnk.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\symlink\common.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

VOID
GetCommandLineArgs(
    LPDWORD NumberOfArguments,
    LPWSTR Arguments[]
    );

//
// API calls to create and query symbolic links and to create hard links.
//

BOOL
CreateSymbolicLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpLinkValue,
    BOOLEAN IsMountPoint,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
SetSymbolicLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpLinkValue
    );

DWORD
QuerySymbolicLinkW(
    LPCWSTR lpExistingName,
    LPWSTR lpBuffer,
    DWORD nBufferLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\supporttools\source\devcfg\devcfg.c ===
/*
this program is based on the following information

HOWTO: Enumerate Hardware Devices by Using SetupDi Calls 
ID: Q259695 


--------------------------------------------------------------------------------
The information in this article applies to:

Microsoft Windows 2000 Driver Development Kit (DDK) 
Microsoft Windows NT 4.0 Driver Development Kit (DDK)

--------------------------------------------------------------------------------


SUMMARY
To get a list of installed hardware devices in Windows 2000, applications can employ the SetupDi class of API functions. 

*/




#include <stdio.h> 
#include <stdlib.h>
#include <tchar.h>    // Make program ansi AND unicode safe
#include <windows.h>  // Most Windows functions
#include <setupapi.h> // Used for SetupDiXxx functions
#include <cfgmgr32.h> // Used for CM_Xxxx functions
#include <regstr.h>   // Extract Registry Strings

#include "devcfg.rc"

void EnableDisableCard(BOOL bEnable, HDEVINFO hDevInfo, SP_DEVINFO_DATA * pDeviceInfoData)
{
    SP_PROPCHANGE_PARAMS PropChangeParams = {sizeof(SP_CLASSINSTALL_HEADER)};

    //
    // Set the PropChangeParams structure.
    //
    PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    PropChangeParams.Scope = DICS_FLAG_GLOBAL;
    if(bEnable) {
      PropChangeParams.StateChange = DICS_ENABLE; 
    }
    else {
      PropChangeParams.StateChange = DICS_DISABLE; 
    }

    if (!SetupDiSetClassInstallParams(hDevInfo,
        pDeviceInfoData,
        (SP_CLASSINSTALL_HEADER *)&PropChangeParams,
        sizeof(PropChangeParams)))
    {
      _tprintf(_T("failed SetClassInstallParams\n"));
      return;
    }

    //
    // Call the ClassInstaller and perform the change.
    // this function is not remote-callable
    if (!SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
        hDevInfo,
        pDeviceInfoData))
    {
      _tprintf(_T("failed CallClassInstaller\n"));
      return;
    }
    _tprintf(_T("succeded\n"));
}

void Usage()
{
  _tprintf(_T("\n"));
  _tprintf(_T("devcfg ") _T(VER_PRODUCTVERSION_STR) _T(" - Usage:\n\n"));
  _tprintf(_T("    devcfg [ <DeviceName> <e[nable]|d[isable]> [cardnumber] ]\n"));
  _tprintf(_T("\n"));
  _tprintf(_T("      without a parameter you'll get a list of all Devices\n"));
  _tprintf(_T("      installed on your computer (even the hidden ones).\n\n"));
  _tprintf(_T("       <DeviceName> must be a DeviceName as shown in the listmode\n"));
  _tprintf(_T("       (without the squarebraces), enclosed in quotation-marks(\"\")\n"));
  _tprintf(_T("       the default value for [number] is one (the first installed)\n"));
  _tprintf(_T("\n"));
  _tprintf(_T("Samples:\n"));
  _tprintf(_T("  devcfg\n"));
  _tprintf(_T("    shows all Devices installed on the machine and there status\n\n"));
  _tprintf(_T("  devcfg \"Card\" d\n"));
  _tprintf(_T("    disables the (first) installed \"Card\"\n\n"));
  _tprintf(_T("  devcfg \"Card\" e 2\n"));
  _tprintf(_T("    enables the second installed \"Card\"\n"));
}

// 
// standard main entry-point
//
int __cdecl _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
    HDEVINFO hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD i;
    BOOL bEnable;
    int iCardNumber = 1;

    if(argc == 2) // Usage
    {
      Usage();
      return 0;
    }

    if(argc == 3 || argc == 4) // enable/disable Card
    {
      if(_tcsicmp( argv[2],_T("e") ) == 0)
        bEnable = TRUE;
      else
      if(_tcsicmp( argv[2], _T("d") ) == 0)
      {
        bEnable = FALSE;
      }
      if(argc == 4) {
        iCardNumber = _ttoi( argv[3] );
        if(0 == iCardNumber)
        {
          _tprintf( _T("Error: The specified card-number is invalid.\n") );
          return 1;
        }
      }
    }

    // Create a HDEVINFO with all present devices.
    hDevInfo = SetupDiGetClassDevs(
        0, 
        0, 
        0,
        DIGCF_PRESENT | DIGCF_ALLCLASSES  
        );
    
    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
      _tprintf( _T("SetupDiGetClassDevEx failed: %lx.\n"), GetLastError() );
      return 1;
    }
    
    // Enumerate through all devices in Set.
    
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for (i=0;SetupDiEnumDeviceInfo(hDevInfo,i,
        &DeviceInfoData);i++)
    {
      DWORD DataT, dwStatus1, dwStatus2;
      LPTSTR  buffer = NULL;
      DWORD buffersize = 0;
        
      // Get status of device
      if(CR_SUCCESS != CM_Get_DevNode_Status(&dwStatus1,
                                             &dwStatus2,
                                             DeviceInfoData.DevInst, 0))
      {
        _tprintf( _T("CM_Get_DevNode_Status failed: %lx.\n"), GetLastError() );
      }

      // 
      // Call function with null to begin with, 
      // then use the returned buffer size 
      // to Alloc the buffer. Keep calling until
      // success or an unknown failure.
      // 
      while (!SetupDiGetDeviceRegistryProperty(
            hDevInfo,
            &DeviceInfoData,
            SPDRP_DEVICEDESC,
            &DataT,
            (PBYTE)buffer,
            buffersize,
            &buffersize))
      {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
          // Change the buffer size.
          if (buffer) LocalFree(buffer);
          buffer = (LPTSTR)LocalAlloc(LPTR,buffersize);
        }
        else
        {
          // Insert error handling here.
          _tprintf( _T("SetupDiGetClassDevEx failed: %lx.\n"), GetLastError() );
          break;
        }
      }
        
      if(argc == 3 || argc == 4)
      {
        if(iCardNumber > 0 && _tcsicmp(argv[1],buffer) == 0)
        {
          if(iCardNumber == 1) {
            _tprintf(_T("working on: [%s]\n"),buffer);
            EnableDisableCard(bEnable, hDevInfo, &DeviceInfoData);
          }
          //else { _tprintf(_T("skipping: [%s]\n"),buffer); }
          --iCardNumber;
        } 
        //else { _tprintf(_T("skipping: [%s]\n"),buffer); }
      }
      else
      {
        if(dwStatus2 == CM_PROB_DISABLED) {
            _tprintf(_T("Result:[%s] -- disabled\n"),buffer);
        }
        else if(dwStatus2) {
          _tprintf(_T("Result:[%s] -- unknown\n"),buffer);
        }
        else {
          _tprintf(_T("Result:[%s] -- enabled\n"),buffer);
        }
      }
        
      if (buffer) LocalFree(buffer);
    }
    
    if ( GetLastError()!=NO_ERROR &&
         GetLastError()!=ERROR_NO_MORE_ITEMS )
    {
      // Insert error handling here.
      _tprintf(_T("Unknown Error. GetLastError returned: %lx.\n"), GetLastError() );
      return 1;
    }
    
    //  Cleanup
    SetupDiDestroyDeviceInfoList(hDevInfo);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\sdktools\symlink\common.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    common.c

Abstract:

    This module contains common apis used by tlist & kill.

Author:

    Wesley Witt (wesw) 20-May-1994

Environment:

    User Mode

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "common.h"

BOOLEAN
MassageLinkValue(
    IN LPCWSTR lpLinkName,
    IN LPCWSTR lpLinkValue,
    OUT PUNICODE_STRING NtLinkName,
    OUT PUNICODE_STRING NtLinkValue,
    OUT PUNICODE_STRING DosLinkValue
    )
{
    PWSTR FilePart;
    PWSTR s, sBegin, sBackupLimit;
    NTSTATUS Status;
    USHORT nSaveNtNameLength;
    ULONG nLevels;

    //
    // Initialize output variables to NULL
    //

    RtlInitUnicodeString( NtLinkName, NULL );
    RtlInitUnicodeString( NtLinkValue, NULL );

    //
    // Translate link name into full NT path.
    //

    if (!RtlDosPathNameToNtPathName_U( lpLinkName,
                                       NtLinkName,
                                       NULL,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    //
    // All done if no link value.
    //

    if (!ARGUMENT_PRESENT( lpLinkValue )) {
        return TRUE;
        }

    //
    // If the target is a device, do not allow the link.
    //

    if (RtlIsDosDeviceName_U( (PWSTR)lpLinkValue )) {
        return FALSE;
        }

    //
    // Convert to DOS path to full path, and get Nt representation
    // of DOS path.
    //

    if (!RtlGetFullPathName_U( lpLinkValue,
                               DosLinkValue->MaximumLength,
                               DosLinkValue->Buffer,
                               NULL
                             )
       ) {
        return FALSE;
        }
    DosLinkValue->Length = wcslen( DosLinkValue->Buffer ) * sizeof( WCHAR );

    //
    // Verify that the link value is a valid NT name.
    //

    if (!RtlDosPathNameToNtPathName_U( DosLinkValue->Buffer,
                                       NtLinkValue,
                                       NULL,
                                       NULL
                                     )
       ) {
        return FALSE;
        }

    return TRUE;
}


BOOL
CreateSymbolicLinkW(
    LPCWSTR lpLinkName,
    LPCWSTR lpLinkValue,
    BOOLEAN IsMountPoint,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )

/*++

Routine Description:

    A symbolic link is established using CreateSymbolicLink.

Arguments:

    lpLinkName - Supplies the DOS file name where the symbolic link is desired.  This
        name must not exists as a file/directory.

    lpLinkValue - Points to an DOS name which is the value of the symbolic link.  This
        name may or may not exist.

    lpSecurityAttributes - Points to a SECURITY_ATTRIBUTES structure that specifies
        the security attributes for the directory to be created. The file system must
        support this parameter for it to have an effect.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    NTSTATUS Status;
    BOOLEAN TranslationStatus;
    UNICODE_STRING NtLinkName;
    UNICODE_STRING NtLinkValue;
    UNICODE_STRING DosLinkValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE FileHandle;
    ULONG FileAttributes;
    ULONG OpenOptions;
    ULONG ReparseDataLength;
    PREPARSE_DATA_BUFFER ReparseBufferHeader;
    WCHAR FullPathLinkValue[ DOS_MAX_PATH_LENGTH+1 ];

    //
    // Ensure that both names were passed.
    //

    if (!ARGUMENT_PRESENT( lpLinkName ) || !ARGUMENT_PRESENT( lpLinkValue )) {
        SetLastError( ERROR_INVALID_NAME );
        return FALSE;
        }

    //
    // Convert link name and value paths into NT versions
    //

    DosLinkValue.Buffer = FullPathLinkValue;
    DosLinkValue.MaximumLength = sizeof( FullPathLinkValue );
    DosLinkValue.Length = 0;
    if (!MassageLinkValue( lpLinkName,
                           lpLinkValue,
                           &NtLinkName,
                           &NtLinkValue,
                           &DosLinkValue
                         )
       ) {
        if (DosLinkValue.Length == 0) {
            SetLastError( ERROR_INVALID_NAME );
            }
        else {
            SetLastError( ERROR_PATH_NOT_FOUND );
            }

        RtlFreeUnicodeString( &NtLinkName );
        RtlFreeUnicodeString( &NtLinkValue );
        return FALSE;
        }

    InitializeObjectAttributes( &ObjectAttributes,
                                &NtLinkName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );

    if (ARGUMENT_PRESENT( lpSecurityAttributes )) {
        ObjectAttributes.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        }

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior.
    //

    OpenOptions = FILE_OPEN_REPARSE_POINT | FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE;

    //
    // Open link name.  Must NOT exist.
    //

    Status = NtCreateFile( &FileHandle,
                           FILE_LIST_DIRECTORY | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES |
                                FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                           FILE_CREATE,
                  