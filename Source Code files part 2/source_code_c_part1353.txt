me;

			// Force the mic vol to equal the main vol
			SetRecorderVolume(&dwMainVol);
			fChanged = TRUE;
		}
		else if (fValidMic && (m_dwMicVolume.leftVolume != dwMicVol.leftVolume || m_dwMicVolume.rightVolume != dwMicVol.rightVolume))
		{
			m_dwMicVolume.leftVolume = dwMicVol.leftVolume;
			m_dwMicVolume.rightVolume = dwMicVol.rightVolume;

			// Force the main vol to equal the mic vol
			SetRecorderVolume(&dwMicVol);
			fChanged = TRUE;
		}

		if (fChanged)
		{
			if (NULL != m_pAudioEvent)
			{
				m_pAudioEvent->OnLevelChange(FALSE /* fSpeaker */, max(m_dwMicVolume.leftVolume , m_dwMicVolume.rightVolume));
			}
		}
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   MuteAudio(BOOL fSpeaker, BOOL fMute)
*
*    PURPOSE:  Internal routine to mute an audio device
*
****************************************************************************/

VOID CAudioControl::MuteAudio(BOOL fSpeaker, BOOL fMute)
{
	INmChannelAudio *pChannel;
	if (fSpeaker)
	{
		m_fSpkMuted = fMute;
		pChannel = m_pChannelSpk;
	}
	else
	{
		m_fMicMuted = fMute;
		pChannel = m_pChannelMic;
	}

	if (NULL != pChannel)
	{
		pChannel->SetProperty(NM_AUDPROP_PAUSE, fMute);
	}

	if (NULL != m_pAudioEvent)
	{
		m_pAudioEvent->OnMuteChange(fSpeaker, fMute);
	}
}

/****************************************************************************
*
*    CLASS:    CAudioControl
*
*    MEMBER:   GetAudioSignalLevel(BOOL fSpeaker)
*
*    PURPOSE:  Internal routine to get the audio signal level
*
****************************************************************************/

DWORD CAudioControl::GetAudioSignalLevel(BOOL fSpeaker)
{
	DWORD_PTR dwLevel = 0;
	INmChannelAudio *pChannel = fSpeaker ? m_pChannelSpk : m_pChannelMic;

	if (NULL != pChannel)
	{
		pChannel->GetProperty(NM_AUDPROP_LEVEL, &dwLevel);
	}

	return (DWORD)dwLevel;
}

BOOL CAudioControl::CanSetRecorderVolume()
{
	if (NULL != m_pRecMixer)
	{
		return m_pRecMixer->CanSetVolume();
	}
	return FALSE;
}

BOOL CAudioControl::CanSetSpeakerVolume()
{
	if (NULL != m_pSpkMixer)
	{
		return m_pSpkMixer->CanSetVolume();
	}
	return FALSE;
}

void CAudioControl::SetRecorderVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pRecMixer)
	{
		m_pRecMixer->SetVolume(pdwVolume);
	}
}

void CAudioControl::SetSpeakerVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pSpkMixer)
	{
		m_pSpkMixer->SetVolume(pdwVolume);
	}
}

void CAudioControl::GetRecorderVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pRecMixer)
	{
		m_pRecMixer->GetVolume(pdwVolume);
	}
}

void CAudioControl::GetSpeakerVolume(MIXVOLUME * pdwVolume)
{
	if (NULL != m_pSpkMixer)
	{
		m_pSpkMixer->GetVolume(pdwVolume);
	}
}


void CAudioControl::SetRecorderVolume(DWORD dwVolume)
{
	MIXVOLUME mixVol;
	MIXVOLUME mixNewVol;

	GetRecorderVolume(&mixVol);

	NewMixVolume(&mixNewVol, mixVol, dwVolume);
				
	SetRecorderVolume(&mixNewVol);
	
}

void CAudioControl::SetSpeakerVolume(DWORD dwVolume)
{	
	MIXVOLUME mixVol;
	MIXVOLUME mixNewVol;

	GetSpeakerVolume(&mixVol);

	NewMixVolume(&mixNewVol, mixVol, dwVolume);
				
	SetSpeakerVolume(&mixNewVol);

}


void CAudioControl::OnDeviceChanged()
{
	MIXVOLUME dwMicVolume;
	DWORD dwNewPlaybackDevice;

	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

	dwNewPlaybackDevice = re.GetNumber(REGVAL_WAVEOUTDEVICEID, 0);

	// restore the speaker setting before changing to the new device
	// verify that we aren't changing to the same device
	if (m_pSpkMixer && (m_dwSpkVolumeOld.leftVolume <= 0x0000ffff || m_dwSpkVolumeOld.rightVolume <= 0x0000ffff) &&
		(m_dwPlaybackDevice != dwNewPlaybackDevice) )
	{
		m_pSpkMixer->SetVolume(&m_dwSpkVolumeOld);
	}


	// Initialize the proper record/playback devices:
	delete m_pRecMixer;
	m_dwRecordDevice = re.GetNumber(REGVAL_WAVEINDEVICEID, 0);
	m_pRecMixer = CMixerDevice::GetMixerForWaveDevice(
			m_hwndParent,
			m_dwRecordDevice,
			MIXER_OBJECTF_WAVEIN);

	delete m_pSpkMixer;
	m_dwPlaybackDevice = dwNewPlaybackDevice;
	m_pSpkMixer = CMixerDevice::GetMixerForWaveDevice(
			m_hwndParent,
			m_dwPlaybackDevice,
			MIXER_OBJECTF_WAVEOUT);

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwRecordDevice);
	}

	if (NULL != m_pChannelSpk)
	{
		m_pChannelSpk->SetProperty(NM_AUDPROP_WAVE_DEVICE, m_dwPlaybackDevice);
	}

	// restore the microphone setting from whatever it was in the tuning wizard
	if (m_pRecMixer)
	{
		dwMicVolume.leftVolume = dwMicVolume.rightVolume = re.GetNumber(REGVAL_CALIBRATEDVOL, 0x00ff);
		m_pRecMixer->SetVolume(&dwMicVolume);
	}

	// remember the old speaker volume
	if (m_pSpkMixer)
	{
		m_pSpkMixer->GetVolume(&m_dwSpkVolumeOld);
	}


	RefreshMixer();
}

void CAudioControl::OnAGC_Changed()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );

	BOOL fAgc = ( reAudio.GetNumber(REGVAL_AUTOGAIN,AUTOGAIN_ENABLED) == AUTOGAIN_ENABLED );


	m_fAutoMix = (reAudio.GetNumber(REGVAL_AUTOMIX, AUTOMIX_ENABLED) == AUTOMIX_ENABLED);

	if (NULL != m_pRecMixer)
	{
		m_pRecMixer->SetAGC(fAgc);
	}

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->SetProperty(NM_AUDPROP_AUTOMIX, m_fAutoMix);
	}
}

void CAudioControl::OnSilenceLevelChanged()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );

	if (MICROPHONE_AUTO_NO == reAudio.GetNumber(REGVAL_MICROPHONE_AUTO,
										MICROPHONE_AUTO_YES))
	{
		// Use "manual" mode:
	
		// BUGBUG - there is a mismatch in terminology between
		// "sensitivity" and "threshhold", which reverses the
		// sense of this value. A low threshhold implies a high
		// sensitivity, etc.
		// Reverse the sense of this value before setting the
		// Nac value, and resolve the terminology problem later.
		// PROP_SILENCE_LEVEL property is in units of 0.1%, so scale it.
		m_dwSilenceLevel = (MAX_MICROPHONE_SENSITIVITY -
					reAudio.GetNumber(REGVAL_MICROPHONE_SENSITIVITY,
									DEFAULT_MICROPHONE_SENSITIVITY))*10;
	}
	else
	{
		// Use "automatic" mode:  This is actually controlled by
		// PROP_SILENCE_LEVEL.  If at maximum (100%), then it is
		// in "automatic" mode
		m_dwSilenceLevel = 100*10; // remember units are 0.1%
	
	}

	if (NULL != m_pChannelMic)
	{
		m_pChannelMic->SetProperty(NM_AUDPROP_LEVEL, m_dwSilenceLevel);
	}
}



BOOL CAudioControl::LoadSettings()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );

	m_fSpkMuted = reAudio.GetNumber(REGVAL_SPKMUTE, FALSE);
	m_fMicMuted = reAudio.GetNumber(REGVAL_RECMUTE, FALSE);

	return TRUE;
}


BOOL CAudioControl::SaveSettings()
{
	RegEntry reAudio( AUDIO_KEY, HKEY_CURRENT_USER );
	
	reAudio.SetValue(REGVAL_SPKMUTE, m_fSpkMuted);
	reAudio.SetValue(REGVAL_RECMUTE, m_fMicMuted);


	//
	// Check if the microphone got changed during this section
	//
	if(m_pRecMixer)
	{
		MIXVOLUME dwMicVol = {0,0};
		m_pRecMixer->GetVolume(&dwMicVol);

		DWORD oldVolume = reAudio.GetNumber(REGVAL_CALIBRATEDVOL, 0x00ff);
		DWORD newVolume = max(dwMicVol.leftVolume,dwMicVol.rightVolume);
		
		if(oldVolume != newVolume)
		{
			reAudio.SetValue(REGVAL_CALIBRATEDVOL, newVolume);
		}
	}


	return TRUE;
}

HRESULT CAudioControl::SetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR uValue)
{
	INmChannelAudio *pChannel = fSpeaker ? m_pChannelSpk : m_pChannelMic;
	if (NULL != pChannel)
	{
		return(pChannel->SetProperty(uID, uValue));
	}

	return(E_UNEXPECTED);
}

HRESULT CAudioControl::GetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR *puValue)
{
	INmChannelAudio *pChannel = fSpeaker ? m_pChannelSpk : m_pChannelMic;
	if (NULL != pChannel)
	{
		return(pChannel->GetProperty(uID, puValue));
	}

	return(E_UNEXPECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\asui.cpp ===
// File: asui.cpp

#include "precomp.h"
#include "resource.h"
#include "popupmsg.h"
#include "cr.h"
#include "dshowdlg.h"
#include <help_ids.h>
#include "confroom.h"
#include "confman.h"
#include "particip.h"
#include "menuutil.h"
#include <nmremote.h>
#include "NmManager.h"

//
// AppSharing part of confroom
//


//
// IAppSharingNotify METHODS
//


STDMETHODIMP CConfRoom::OnReadyToShare(BOOL fReady)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK:  CHANGE AS CHANNEL STATE
    //
    CNmManagerObj::AppSharingChannelActiveStateChanged(fReady != FALSE);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnShareStarted(void)
{
    ASSERT(m_pAS);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnSharingStarted(void)
{
    ASSERT(m_pAS);

	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnShareEnded(void)
{
    ASSERT(m_pAS);

	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnPersonJoined(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- ADD PERSON TO AS CHANNEL MEMBER LIST
    //

	CNmManagerObj::ASMemberChanged(gccMemberID);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnPersonLeft(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- REMOVE PERSON FROM AS CHANNEL MEMBER LIST
    //

	CNmManagerObj::ASMemberChanged(gccMemberID);

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStartInControl(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change remote (gccMemberID)   to VIEWING
    //      * Change local                  to IN CONTROL
    // 

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStopInControl(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change remote (gccMemberID)   to DETACHED
    //      * Change local                  to DETACHED
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnPausedInControl(IAS_GCC_ID gccMemberID)
{
    //
    // New for 3.0
    // 3.0 SDK -- Change member state?
    //
    return S_OK;
}


STDMETHODIMP CConfRoom::OnUnpausedInControl(IAS_GCC_ID gccMemberID)
{
    //
    // New for 3.0
    // 3.0 SDK -- Change member state?
    //
    return(S_OK);
}


STDMETHODIMP CConfRoom::OnControllable(BOOL fControllable)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE LOCAL STATE?
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStartControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change local                  to VIEWING
    //      * Change remote (gccMemberID)   to IN CONTROL
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}



STDMETHODIMP CConfRoom::OnStopControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);

    //
    // 2.x SDK -- CHANGE MEMBER STATES
    //      * Change local                  to DETACHED
    //      * Change remote                 to DETACHED
    //

	CNmManagerObj::ASLocalMemberChanged();
	CNmManagerObj::ASMemberChanged(gccMemberID);
	CNmManagerObj::AppSharingChannelChanged();

    return S_OK;
}


STDMETHODIMP CConfRoom::OnPausedControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);
    return(S_OK);
}


STDMETHODIMP CConfRoom::OnUnpausedControlled(IAS_GCC_ID gccMemberID)
{
    ASSERT(m_pAS);
    return(S_OK);
}




//
// RevokeControl()
//

HRESULT CConfRoom::RevokeControl(UINT gccID)
{
	if (!m_pAS)
        return E_FAIL;

	return m_pAS->RevokeControl(gccID);
}


//
// AllowControl()
//
HRESULT CConfRoom::AllowControl(BOOL fAllow)
{
    if (!m_pAS)
        return(E_FAIL);

    return(m_pAS->AllowControl(fAllow));
}



//
// GiveControl()
//
HRESULT CConfRoom::GiveControl(UINT gccID)
{
    if (!m_pAS)
        return(E_FAIL);

    return(m_pAS->GiveControl(gccID));
}


//
// CancelGiveControl()
//
HRESULT CConfRoom::CancelGiveControl(UINT gccID)
{
    if (!m_pAS)
        return(E_FAIL);

    return(m_pAS->CancelGiveControl(gccID));
}




BOOL CConfRoom::FIsSharingAvailable(void)
{
    if (!m_pAS)
        return FALSE;

    return(m_pAS->IsSharingAvailable());
}


/*  F  C A N  S H A R E  */
/*-------------------------------------------------------------------------
    %%Function: FCanShare
    
-------------------------------------------------------------------------*/
BOOL CConfRoom::FCanShare(void)
{
    if (!m_pAS)
        return FALSE;

	return (m_pAS->CanShareNow());
}


//
// FInShare()
//
BOOL CConfRoom::FInShare(void)
{
    if (!m_pAS)
        return FALSE;

    return (m_pAS->IsInShare());
}


BOOL CConfRoom::FIsSharing(void)
{
    if (!m_pAS)
        return FALSE;

    return (m_pAS->IsSharing());
}


//
// FIsControllable()
//
BOOL CConfRoom::FIsControllable(void)
{
    if (!m_pAS)
        return FALSE;

    return (m_pAS->IsControllable());
}


//
// GetPersonShareStatus()
//
HRESULT CConfRoom::GetPersonShareStatus(UINT gccID, IAS_PERSON_STATUS * pStatus)
{
    if (!m_pAS)
        return E_FAIL;

    ZeroMemory(pStatus, sizeof(*pStatus));
    pStatus->cbSize = sizeof(*pStatus);
    return(m_pAS->GetPersonStatus(gccID, pStatus));
}


HRESULT CConfRoom::CmdShare(HWND hwnd)
{
    HRESULT hr = E_FAIL;

	DebugEntry(CConfRoom::CmdShare);

    if (m_pAS)
	{
		hr = m_pAS->Share(hwnd, IAS_SHARE_DEFAULT);

		if (SUCCEEDED(hr))
		{
			CNmManagerObj::SharableAppStateChanged(hwnd, NM_SHAPP_SHARED);
		}
	}
	DebugExitHRESULT(CConfRoom::CmdShare, hr);
	return hr;
}

HRESULT CConfRoom::CmdUnshare(HWND hwnd)
{
	HRESULT hr = E_FAIL;

	DebugEntry(CConfRoom::CmdUnshare);

    if (m_pAS)
	{
		hr = m_pAS->Unshare(hwnd);
		if (SUCCEEDED(hr))
		{
			CNmManagerObj::SharableAppStateChanged(hwnd, NM_SHAPP_NOT_SHARED);
		}
	}

	DebugExitHRESULT(CConfRoom::CmdUnshare, hr);
	return hr;
}


BOOL CConfRoom::FIsWindowShareable(HWND hwnd)
{
    if (!m_pAS)
        return(FALSE);

    return(m_pAS->IsWindowShareable(hwnd));
}


BOOL CConfRoom::FIsWindowShared(HWND hwnd)
{
    if (!m_pAS)
        return(FALSE);

    return(m_pAS->IsWindowShared(hwnd));
}


HRESULT CConfRoom::GetShareableApps(IAS_HWND_ARRAY ** pList)
{
    if (!m_pAS)
        return E_FAIL;

    return m_pAS->GetShareableApps(pList);
}


HRESULT CConfRoom::FreeShareableApps(IAS_HWND_ARRAY * pList)
{
    if (!m_pAS)
        return E_FAIL;

    return m_pAS->FreeShareableApps(pList);
}


void CConfRoom::LaunchHostUI(void)
{
    if (m_pAS)
    {
        m_pAS->LaunchHostUI();
    }
}




HRESULT GetShareState(ULONG ulGCCId, NM_SHARE_STATE *puState)
{
	HRESULT hr = E_UNEXPECTED;
	
	ASSERT(puState);
			
	*puState = NM_SHARE_UNKNOWN;

	CConfRoom *p = ::GetConfRoom();

	if(p)
	{
    	IAS_PERSON_STATUS s;
		hr = p->GetPersonShareStatus(ulGCCId, &s);

		if(SUCCEEDED(hr))
		{
			//
			// There's no share at all as far as we know, or this person isn't participating
			//
			if (!s.InShare)
			{
				*puState = NM_SHARE_UNKNOWN;
				return hr;
			}

			//
			// This person is in control of another
			//	
			if ((s.InControlOf) || (s.Controllable && !s.ControlledBy))
			{
				*puState = NM_SHARE_IN_CONTROL;
				return hr;
			}

			//
			// This person can be (and maybe is) controlled by another
			//
			if (s.Controllable)
			{
				*puState = NM_SHARE_COLLABORATING;
				return hr;
			}

			*puState = NM_SHARE_WORKING_ALONE;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\audiocpl.cpp ===
// File: AudioCpl.cpp

#include "precomp.h"
#include "resource.h"
#include "avdefs.h"
#include "ConfCpl.h"

#include "help_ids.h"
#include <ih323cc.h>
#include <initguid.h>
#include <nacguids.h>
#include <auformats.h>

#include "ConfPolicies.h"


const int SLOW_CPU_MHZ = 110;  // pentiums 110mhz - 180mhz are "slow"
const int FAST_CPU_MHZ = 200; // fast machines are 200mhz and faster
const int VERYFAST_CPU_MHZ = 500; // un-normalized, this will include 400 mhz PentIIs


// 486 and slow pentium (<= 100 mhz) settings (VERY SLOW)
const UINT CIF_RATE_VERYSLOW = 3;
const UINT SQCIF_RATE_VERYSLOW = 7;
const UINT QCIF_RATE_VERYSLOW = 7;

// pentium 75mhz settings (SLOW)
const UINT CIF_RATE_SLOW = 7;
const UINT SQCIF_RATE_SLOW = 15;
const UINT QCIF_RATE_SLOW = 15;


// pentium 200mhz settings (FAST)
const UINT CIF_RATE_FAST = 15;
const UINT SQCIF_RATE_FAST = 30;
const UINT QCIF_RATE_FAST = 30;

const UINT CIF_RATE_VERYFAST = 30;




typedef struct _CODECINFO
{
	HINSTANCE			hLib;
	IH323CallControl*	lpIH323;
	UINT				uNumFormats;
	PBASIC_AUDCAP_INFO	pCodecCapList;
	PWORD				pOldCodecOrderList;
	PWORD				pCurCodecOrderList;
	LPAPPCAPPIF 		lpIAppCap;
	LPAPPVIDCAPPIF		lpIVidAppCap;
	LPCAPSIF			lpICapsCtl;

} CODECINFO, *PCODECINFO;

typedef struct
{
	BOOL fManual;
	UINT uBandwidth;
	PCODECINFO pCodecInfo;
} ADVCODEC, *PADVCODEC;


//SS: the cpu utilization is bogus so for now hide it
//#define CODEC_LV_NUM_COLUMNS	3
#define CODEC_LV_MAX_COLUMNS	3
#define CODEC_LV_NUM_COLUMNS	2



#define MAGIC_CPU_DO_NOT_EXCEED_PERCENTAGE 50	//Don't use more than this % of the CPU for encoding
												//Also in nac\balance.cpp


// given the bandwidth identifier (1-4) and the CPU megahertz, return
// the actual bandwidth amount in bits/sec
int GetBandwidthBits(int id, int megahertz)
{
	int nBits=BW_144KBS_BITS;

	switch (id)
	{
		case BW_144KBS:
			nBits=BW_144KBS_BITS;
			break;
		case BW_288KBS:
			nBits=BW_288KBS_BITS;
			break;
		case BW_ISDN:
			nBits=BW_ISDN_BITS;
			break;
		case BW_MOREKBS:  // LAN
			if (megahertz >= VERYFAST_CPU_MHZ)
			{
				nBits = BW_FASTLAN_BITS;
			}
			else
			{
				nBits = BW_SLOWLAN_BITS;
			}
			break;
	}

	return nBits;
}


// begin data types used for ChooseCodecByBw
#define CODEC_DISABLED	99
#define CODEC_UNKNOWN	98

typedef struct _codecprefrow
{
	WORD wFormatTag;
	WORD wOrder586;
	WORD wOrder486;
	WORD wMinBW;
} CODECPREFROW;

typedef CODECPREFROW	CODECPREFTABLE[];
	
// FORMAT NAME             586 Order      486 Order       Minimum BW
static const CODECPREFTABLE g_CodecPrefTable =
{
   WAVE_FORMAT_MSG723,     1,             CODEC_DISABLED, BW_144KBS,
   WAVE_FORMAT_LH_SB16,    2,             1,              BW_288KBS,
   WAVE_FORMAT_LH_SB8,     3,             2,              BW_144KBS,
   WAVE_FORMAT_LH_SB12,    4,             3,              BW_144KBS,
   WAVE_FORMAT_MULAW,      5,             4,              BW_ISDN,
   WAVE_FORMAT_ALAW,       6,             5,              BW_ISDN,
   WAVE_FORMAT_ADPCM,      7,             6,              BW_ISDN,
   WAVE_FORMAT_LH_CELP,    8,             CODEC_DISABLED, BW_144KBS,
   WAVE_FORMAT_MSRT24,    9,             7, BW_144KBS
};
// end of stuff used by ChooseCodecByBw

static const int g_ColHdrStrId[CODEC_LV_MAX_COLUMNS] =
{
	IDS_CODECNAME,
	IDS_MAXBITRATE,
	IDS_CPUUTIL,
};



//prototypes
INT_PTR CALLBACK AdvCodecDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
int CALLBACK CodecLVCompareProc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
BOOL FillCodecListView(HWND hCB, PCODECINFO pCodecInfo);
BOOL ChooseCodecByBw(UINT uBandWidthId, PCODECINFO pCodecInfo);
void SortCodecs(PADVCODEC pAdvCodec, int nSelection);
BOOL SetAppCodecPrefs(PCODECINFO pCodecInfo,UINT uBandwith);
BOOL GetIAppCap(PCODECINFO pCodecInfo);
BOOL GetAppCapFormats(PCODECINFO pCodecInfo);
void FreeAppCapFormats(PCODECINFO pCodecInfo);
void ReleaseIAppCap(PCODECINFO pCodecInfo);
BOOL ApplyUserPrefs(PCODECINFO pCodecInfo, UINT uMaximumBandwidth);


static const DWORD _rgHelpIdsAudio[] = {

	IDC_GENERAL_GROUP, 				IDH_AUDIO_GENERAL,
	IDC_FULLDUPLEX, 				IDH_AUDIO_FULL_DUPLEX,
	IDC_AUTOGAIN,					IDH_AUDIO_AUTO_GAIN,
	IDC_AUTOMIX,                    IDH_AUDIO_AUTOMIXER,
	IDC_DIRECTSOUND,                IDH_AUDIO_DIRECTSOUND,
	IDC_START_AUDIO_WIZ,			IDH_AUDIO_TUNING_WIZARD,

	IDC_ADVANCEDCODEC,				IDH_AUDIO_ADVANCED_CODEC_SETTINGS,

	IDC_MICSENSE_GROUP,				IDH_AUDIO_MIC_SENSITIVITY,
	IDC_MICSENSE_AUTO,				IDH_AUDIO_AUTO_SENSITIVITY,
	IDC_MICSENSE_MANUAL,			IDH_AUDIO_MANUAL_SENSITIVITY,
	IDC_TRK_MIC,					IDH_AUDIO_MANUAL_SENSITIVITY,

	0, 0   // terminator
};
	


VOID InitAudioSettings(HWND hDlg, BOOL *pfFullDuplex, BOOL *pfAgc, BOOL *pfAutoMix, BOOL *pfDirectSound)
{
	BOOL	fFullDuplex = FALSE;
	BOOL	fAgc = FALSE;
	BOOL	fDirectSound;
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

	UINT uSoundCardCaps = re.GetNumber(REGVAL_SOUNDCARDCAPS,SOUNDCARD_NONE);

	ASSERT(ISSOUNDCARDPRESENT(uSoundCardCaps) && (!SysPol::NoAudio()));

	if (ISSOUNDCARDFULLDUPLEX(uSoundCardCaps) && ConfPolicies::IsFullDuplexAllowed())
	{					
		::EnableWindow(::GetDlgItem(hDlg, IDC_FULLDUPLEX), TRUE);
		// read settings from registry
		fFullDuplex = (BOOL)
			( re.GetNumber(REGVAL_FULLDUPLEX,0) == FULLDUPLEX_ENABLED );
	}					
	else
	{
		DisableControl(hDlg, IDC_FULLDUPLEX);
	}
	
	if (DOESSOUNDCARDHAVEAGC(uSoundCardCaps))
	{					
		::EnableWindow(::GetDlgItem(hDlg, IDC_AUTOGAIN), TRUE);
		// read settings from registry
		fAgc = (BOOL)
			( re.GetNumber(REGVAL_AUTOGAIN,AUTOGAIN_ENABLED) == AUTOGAIN_ENABLED );
	}					
	else
	{
		DisableControl(hDlg, IDC_AUTOGAIN);
	}


	*pfFullDuplex = fFullDuplex;

	// for automix and agc, don't try updating the check-mark if
	// NULL has been passed in

	if (pfAutoMix)
	{
		*pfAutoMix = (BOOL)(re.GetNumber(REGVAL_AUTOMIX, AUTOMIX_ENABLED) == AUTOMIX_ENABLED);
		SendDlgItemMessage(hDlg, IDC_AUTOMIX, BM_SETCHECK, *pfAutoMix, 0L);
	}

	if (pfAgc)
	{
		*pfAgc = fAgc;
		SendDlgItemMessage ( hDlg, IDC_AUTOGAIN, BM_SETCHECK, fAgc, 0L );
	}

	
	if (ISDIRECTSOUNDAVAILABLE(uSoundCardCaps))
	{
        RegEntry    rePol(POLICIES_KEY, HKEY_CURRENT_USER);

		fDirectSound = (BOOL)(re.GetNumber(REGVAL_DIRECTSOUND, DSOUND_USER_DISABLED) == DSOUND_USER_ENABLED);
		::EnableWindow(::GetDlgItem(hDlg, IDC_DIRECTSOUND),
            !rePol.GetNumber(REGVAL_POL_NOCHANGE_DIRECTSOUND, DEFAULT_POL_NOCHANGE_DIRECTSOUND));
	}
	else
	{
		fDirectSound = FALSE;
		::EnableWindow(::GetDlgItem(hDlg, IDC_DIRECTSOUND), FALSE);
		SendDlgItemMessage(hDlg, IDC_DIRECTSOUND, BM_SETCHECK, FALSE, 0L);
	}

	// don't check the checkbox if the caller didn't pass in a var to be updated
	if (pfDirectSound)
	{
		*pfDirectSound = fDirectSound;
		SendDlgItemMessage(hDlg, IDC_DIRECTSOUND, BM_SETCHECK, *pfDirectSound, 0L);
	}


	// set the check boxes for those that are enabled
	SendDlgItemMessage ( hDlg, IDC_FULLDUPLEX,
			BM_SETCHECK, *pfFullDuplex, 0L );



}
			
INT_PTR APIENTRY AudioDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static	PROPSHEETPAGE * ps;
	static UINT uOldCodecChoice;
	static UINT uNewCodecChoice;
	static BOOL fOldFullDuplex;
	static BOOL fOldAgc;
	static BOOL fOldAutoMic;
	static BOOL fOldAutoMix;
	static BOOL fOldDirectSound;
	static BOOL fOldH323GatewayEnabled;
	static UINT uOldMicSense;
	static CODECINFO CodecInfo;
	static BOOL bAdvDlg;

	switch (message) {
		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

			InitAudioSettings(hDlg, &fOldFullDuplex, &fOldAgc, &fOldAutoMix, &fOldDirectSound);

			//initialize the codecinfo structure, these will be set as and when needed
			ZeroMemory(&CodecInfo, sizeof(CodecInfo));

			uNewCodecChoice = uOldCodecChoice = re.GetNumber(REGVAL_CODECCHOICE, CODECCHOICE_AUTO);

			// Get Audio settings
			fOldAutoMic = (BOOL)
				( re.GetNumber(REGVAL_MICROPHONE_AUTO,
					DEFAULT_MICROPHONE_AUTO) == MICROPHONE_AUTO_YES );

			SendDlgItemMessage ( hDlg,
						fOldAutoMic ? IDC_MICSENSE_AUTO : IDC_MICSENSE_MANUAL,
						BM_SETCHECK, TRUE, 0L );

			EnableWindow ( GetDlgItem ( hDlg, IDC_TRK_MIC ),
				(BOOL)SendDlgItemMessage ( hDlg, IDC_MICSENSE_MANUAL,
										BM_GETCHECK, 0,0));

			SendDlgItemMessage (hDlg, IDC_TRK_MIC, TBM_SETRANGE, FALSE,
				MAKELONG (MIN_MICROPHONE_SENSITIVITY,
					MAX_MICROPHONE_SENSITIVITY ));

			uOldMicSense = re.GetNumber ( REGVAL_MICROPHONE_SENSITIVITY,
									DEFAULT_MICROPHONE_SENSITIVITY );

			SendDlgItemMessage (hDlg, IDC_TRK_MIC, TBM_SETTICFREQ,
				( MAX_MICROPHONE_SENSITIVITY - MIN_MICROPHONE_SENSITIVITY )
														/ 10, 0 );

			SendDlgItemMessage (hDlg, IDC_TRK_MIC, TBM_SETPOS, TRUE,
								uOldMicSense );

			bAdvDlg = FALSE;

			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_APPLY:
				{
					RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
					BOOL fFullDuplex = SendDlgItemMessage
							(hDlg, IDC_FULLDUPLEX, BM_GETCHECK, 0, 0 ) ?
								FULLDUPLEX_ENABLED : FULLDUPLEX_DISABLED;

					BOOL fAgc = SendDlgItemMessage
							(hDlg, IDC_AUTOGAIN, BM_GETCHECK, 0, 0 ) ?
								AUTOGAIN_ENABLED : AUTOGAIN_DISABLED;

					BOOL fAutoMix = SendDlgItemMessage
							(hDlg, IDC_AUTOMIX, BM_GETCHECK, 0, 0) ?
								AUTOMIX_ENABLED : AUTOMIX_DISABLED;

					BOOL fDirectSound = SendDlgItemMessage
							(hDlg, IDC_DIRECTSOUND, BM_GETCHECK, 0, 0) ?
								DSOUND_USER_ENABLED : DSOUND_USER_DISABLED;

					if ( fFullDuplex != fOldFullDuplex )
					{
						re.SetValue ( REGVAL_FULLDUPLEX, fFullDuplex );
						g_dwChangedSettings |= CSETTING_L_FULLDUPLEX;
					}
					if ( fAgc != fOldAgc )
					{
						re.SetValue ( REGVAL_AUTOGAIN, fAgc );
						g_dwChangedSettings |= CSETTING_L_AGC;
					}

					// use same flag bit as agc as for automix
					// since this automix and agc may evenutally
					// get combined into 1 ui choice
					if (fAutoMix != fOldAutoMix)
					{
						re.SetValue(REGVAL_AUTOMIX, fAutoMix);
						g_dwChangedSettings |= CSETTING_L_AGC;
					}

					if (fDirectSound != fOldDirectSound)
					{
						re.SetValue(REGVAL_DIRECTSOUND, fDirectSound);
						g_dwChangedSettings |= CSETTING_L_DIRECTSOUND;
					}

					UINT uBandWidth = re.GetNumber(REGVAL_TYPICALBANDWIDTH,BW_DEFAULT);

					// if the advanced dialog has not been accessed,
					// then there is nothing to changes as far as the
					// codecs go
					if (bAdvDlg)
					{
						if (uNewCodecChoice == CODECCHOICE_AUTO)
						{
							//apply heuristics and apply the prefs to registry
							ChooseCodecByBw(uBandWidth, &CodecInfo);
							SetAppCodecPrefs(&CodecInfo, uBandWidth);
						}
						else
						{
							for (int i = 0; i < (int)CodecInfo.uNumFormats &&
									CodecInfo.pCodecCapList; i++)
							{
								if (CodecInfo.pCodecCapList[i].wSortIndex !=
										CodecInfo.pOldCodecOrderList[i])
								{
									// oder has changed, save the new order
									SetAppCodecPrefs(&CodecInfo, uBandWidth);
									break;
								}
							}
						}
					}

					FreeAppCapFormats(&CodecInfo);

					// Handle the Trackbar controls:

					BOOL fAutoMic = (BOOL)SendDlgItemMessage ( hDlg, IDC_MICSENSE_AUTO,
													BM_GETCHECK, 0, 0 );

					if ( fAutoMic != fOldAutoMic ) {
						g_dwChangedSettings |= CSETTING_L_AUTOMIC;
						re.SetValue ( REGVAL_MICROPHONE_AUTO, fAutoMic ?
							MICROPHONE_AUTO_YES : MICROPHONE_AUTO_NO );
					}

					UINT uMicSense = (UINT)SendDlgItemMessage( hDlg, IDC_TRK_MIC,
								TBM_GETPOS, 0, 0 );

					if ( uMicSense != uOldMicSense ) {
						g_dwChangedSettings |= CSETTING_L_MICSENSITIVITY;
						re.SetValue ( REGVAL_MICROPHONE_SENSITIVITY, uMicSense);
					}
					break;
				}

				case PSN_RESET:
					//reset the codec choice in the registry if it has changed
					if (uNewCodecChoice != uOldCodecChoice)
					{
						RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
						re.SetValue(REGVAL_CODECCHOICE, uOldCodecChoice);
					}

					//free the capformats if allocated
					FreeAppCapFormats(&CodecInfo);
					break;
			}
			break;

		case WM_COMMAND:
			switch (GET_WM_COMMAND_ID (wParam, lParam))
			{
				case IDC_START_AUDIO_WIZ:
				{
					AUDIOWIZOUTPUT AwOutput;
					BOOL fFullDuplex, fAgc, fDirectSound, fCurrentDS;
					
					if (::FIsConferenceActive())
					{
						ConfMsgBox(hDlg,
								(LPCTSTR)IDS_NOAUDIOTUNING);
						break;
					}

					fAgc = SendDlgItemMessage
								(hDlg, IDC_AUTOGAIN, BM_GETCHECK, 0, 0 ) ?
									AUTOGAIN_ENABLED : AUTOGAIN_DISABLED;
					//SS:note the calibrated value can get out of sync
					//need a warning

					CallAudioCalibWizard(hDlg,RUNDUE_USERINVOKED,WAVE_MAPPER,&AwOutput,(INT)fAgc);
					if (AwOutput.uChanged & SOUNDCARD_CHANGED)
						g_dwChangedSettings |= CSETTING_L_AUDIODEVICE;
					
					// wizard can change duplex, and agc availability, and DirectSound
					// don't pass in AGC and AUTOMIX pointers, because we don't want
					// the checkboxes to revet back to what they were initialized at.

					InitAudioSettings(hDlg, &fFullDuplex, NULL, NULL, NULL);
					break;
				}

				case IDC_ADVANCEDCODEC:
				{
					RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );

					//SS ::: get the cap formats,
					//this will retrieve the codec caps if not allready rerieved
					if (GetAppCapFormats(&CodecInfo))
					{
						ADVCODEC AdvCodec;

						AdvCodec.fManual = (uNewCodecChoice == CODECCHOICE_MANUAL);
						AdvCodec.uBandwidth = re.GetNumber(REGVAL_TYPICALBANDWIDTH, BW_DEFAULT);
						AdvCodec.pCodecInfo = &CodecInfo;

						if ((DialogBoxParam(GetInstanceHandle(),MAKEINTRESOURCE(IDD_ADVANCEDCODEC),hDlg,AdvCodecDlgProc,
							(LPARAM)&AdvCodec)) == IDCANCEL)
						{
							//the dialog box changes it in place so current settings need to be restored into
							//update the pcodecinfo sort order from the previous current settings
							for (int i = 0; i < (int)CodecInfo.uNumFormats; i++)
								(CodecInfo.pCodecCapList[i]).wSortIndex = CodecInfo.pCurCodecOrderList[i];
						}
						else
						{
							uNewCodecChoice = (AdvCodec.fManual ?
									CODECCHOICE_MANUAL : CODECCHOICE_AUTO);
							re.SetValue(REGVAL_CODECCHOICE, uNewCodecChoice);

							//else update the current
							for (int i = 0; i < (int)CodecInfo.uNumFormats; i++)
								CodecInfo.pCurCodecOrderList[i] = (CodecInfo.pCodecCapList[i]).wSortIndex;

							bAdvDlg = TRUE;
						}
					}
					break;
				}
				
				case IDC_MICSENSE_AUTO:
				case IDC_MICSENSE_MANUAL:
					EnableWindow ( GetDlgItem ( hDlg, IDC_TRK_MIC ),
						(BOOL)SendDlgItemMessage ( hDlg, IDC_MICSENSE_MANUAL,
												BM_GETCHECK, 0,0));
					break;

				default:
					break;
			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, _rgHelpIdsAudio);
			break;

		case WM_HELP:
			DoHelp(lParam, _rgHelpIdsAudio);
			break;
	}
	return (FALSE);
}


static const DWORD aAdvCodecHelpIds[] = {

	IDC_CODECMANUAL, IDH_AUDIO_MANUAL_CODEC_SETTINGS,
	IDC_COMBO_CODEC, IDH_ADVCOMP_CODECS,
	IDC_CODECDEFAULT, IDH_ADVCOMP_DEFAULTS,
	IDC_CODECLISTLABEL, IDH_ADVCOMP_CODECS,

	0, 0   // terminator
};

INT_PTR CALLBACK AdvCodecDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	static PADVCODEC	pAdvCodec = NULL;
	static nCodecSelection=0;
	WORD				wCmdId;
	
	switch(uMsg)
	{
		case WM_INITDIALOG:
			//get the list of codecs
			pAdvCodec = (PADVCODEC)lParam;
			ASSERT(pAdvCodec);

			SendDlgItemMessage ( hDlg, IDC_CODECMANUAL,
					BM_SETCHECK, pAdvCodec->fManual, 0L );
			EnableWindow(GetDlgItem(hDlg, IDC_COMBO_CODEC), pAdvCodec->fManual);

			if (!pAdvCodec->fManual)
			{
				ChooseCodecByBw(pAdvCodec->uBandwidth, pAdvCodec->pCodecInfo);
			}

			//fill the list box;
			FillCodecListView(GetDlgItem(hDlg, IDC_COMBO_CODEC),
					pAdvCodec->pCodecInfo);

			if (pAdvCodec->fManual)
			{
				nCodecSelection = (int)SendMessage((HWND)lParam, CB_GETCURSEL, 0,0);
				// convert index of combo box choice to index in capability list
				nCodecSelection = (int)SendMessage((HWND)lParam, CB_GETITEMDATA, nCodecSelection,0);
			}

			return(TRUE);

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, aAdvCodecHelpIds);
			break;

		case WM_HELP:
			DoHelp(lParam, aAdvCodecHelpIds);
			break;

		case WM_COMMAND:
			wCmdId = GET_WM_COMMAND_ID (wParam, lParam);	// LOWORD (uParam)
			switch (wCmdId)
			{
			case IDOK:
				if (pAdvCodec->fManual)
				{
					nCodecSelection = (int)SendDlgItemMessage(hDlg, IDC_COMBO_CODEC, CB_GETCURSEL, 0,0);
					nCodecSelection = (int)SendDlgItemMessage(hDlg, IDC_COMBO_CODEC, CB_GETITEMDATA, nCodecSelection,0);
					SortCodecs(pAdvCodec, nCodecSelection);
				}
				EndDialog (hDlg, IDOK);
				return(TRUE);
	
			case IDCANCEL:
				EndDialog(hDlg, IDCANCEL);
				return(TRUE);



			case IDC_CODECMANUAL:
				pAdvCodec->fManual = (BOOL)SendDlgItemMessage ( hDlg, IDC_CODECMANUAL,
						BM_GETCHECK, 0,0);
				EnableWindow(GetDlgItem(hDlg, IDC_COMBO_CODEC), pAdvCodec->fManual);
				if (pAdvCodec->fManual)
				{
					break;
				}
				else
				{
					ChooseCodecByBw(pAdvCodec->uBandwidth, pAdvCodec->pCodecInfo);
					FillCodecListView(GetDlgItem(hDlg, IDC_COMBO_CODEC),
							pAdvCodec->pCodecInfo);
				}

				break;

			
			} // WM_COMMAND

		default:
			return FALSE;
	}
	return (FALSE);
}




BOOL FillCodecListView(HWND hCB, PCODECINFO pCodecInfo)
{
	PBASIC_AUDCAP_INFO	pCurCodecCap;
	UINT uIndex, uTotal, uItemIndex;
	UINT uSortTop, uSortTopIndex;


	SendMessage(hCB, CB_RESETCONTENT,0,0); // erase all items in CB
	
	uTotal = pCodecInfo->uNumFormats;
	uSortTop = uTotal-1;

	for (uIndex = 0; uIndex < uTotal; uIndex++)
	{
		pCurCodecCap = &(pCodecInfo->pCodecCapList[uIndex]);

		if ((!pCurCodecCap->bRecvEnabled) && (!pCurCodecCap->bSendEnabled))
		{
			continue;
		}

		uItemIndex = (UINT)SendMessage(hCB, CB_ADDSTRING, 0, (LPARAM)(pCurCodecCap->szFormat));
		SendMessage(hCB, CB_SETITEMDATA, uItemIndex, uIndex);

		if (pCurCodecCap->wSortIndex < uSortTop)
		{
			uSortTop = pCurCodecCap->wSortIndex;
			uSortTopIndex = uItemIndex;
		}
	}

	SendMessage(hCB, CB_SETCURSEL, uSortTopIndex, 0);

	return TRUE;
}


void SortCodecs(PADVCODEC pAdvCodec, int nSelection)
{
	PBASIC_AUDCAP_INFO	pDefaultCodec, pSelectedCodec, pCodec;
	WORD wSortOrderBest, wSortOrderSelected;
	UINT uIndex;


	if (!pAdvCodec->fManual)
		return;

	if ((nSelection < 0) || ((UINT)nSelection > (pAdvCodec->pCodecInfo->uNumFormats)))
	{
		return;
	}

	ChooseCodecByBw(pAdvCodec->uBandwidth, pAdvCodec->pCodecInfo);

	// this is the codec the user selected
	pSelectedCodec = &(pAdvCodec->pCodecInfo->pCodecCapList[nSelection]);

	// all codecs that have a sort index less than the selected codec
	// get moved down one
	for (uIndex = 0; uIndex < pAdvCodec->pCodecInfo->uNumFormats; uIndex++)
	{
		pCodec = &(pAdvCodec->pCodecInfo->pCodecCapList[uIndex]);
		if (pCodec->wSortIndex < pSelectedCodec->wSortIndex)
		{
			pCodec->wSortIndex = pCodec->wSortIndex + 1;
		}
	}
	pSelectedCodec->wSortIndex = 0;

}



#define SQCIF	0x1
#define QCIF	0x2
#define CIF 	0x4
#define UNKNOWN 0x8
#define get_format(s) (s == Small ? SQCIF : (s == Medium ? QCIF: (s == Large ? CIF : UNKNOWN)))

BOOL SetAppCodecPrefs(PCODECINFO pCodecInfo,UINT uBandwidth)
{

	BOOL	fRet = FALSE;
	HRESULT hr;
	DWORD dwcFormats,dwcFormatsReturned;
	BASIC_VIDCAP_INFO *pvidcaps = NULL;
	UINT dwBitsPerSec,x;
	int iFamily,format, nNormalizedSpeed;
	int nCifIncrease;
	DWORD dwSysPolBandwidth;

	// frame rates initialized to 486/P60 settings
	UINT uRateCIF=CIF_RATE_VERYSLOW, uRateQCIF=QCIF_RATE_VERYSLOW, uRateSQCIF=SQCIF_RATE_VERYSLOW;

	if (!pCodecInfo->lpIAppCap)
	{
		if (!GetIAppCap(pCodecInfo))
			goto MyExit;

	}		
	if (FAILED(hr = ((pCodecInfo->lpIAppCap)->ApplyAppFormatPrefs(pCodecInfo->pCodecCapList,
		pCodecInfo->uNumFormats))))
		goto MyExit;

	//Set the BW to something sane

#ifdef	_M_IX86
	GetNormalizedCPUSpeed (&nNormalizedSpeed,&iFamily);
#else
	//BUGBUG, setting things really high, otherwise,
	iFamily=6;
	nNormalizedSpeed=300;
#endif

	dwBitsPerSec = GetBandwidthBits(uBandwidth,nNormalizedSpeed);
	dwSysPolBandwidth = SysPol::GetMaximumBandwidth();

	// apply bandwidth policy key if the user's setting is set to
	// a LAN speed
	if ((dwSysPolBandwidth > 0) && (dwBitsPerSec >= BW_SLOWLAN_BITS))
	{
		dwBitsPerSec = dwSysPolBandwidth;
	}


	if ((iFamily >= 5) && (nNormalizedSpeed >= SLOW_CPU_MHZ))
	{
		// normal pentiums (75mhz - 180mhz)
		if (nNormalizedSpeed < FAST_CPU_MHZ)
		{
			uRateCIF =  CIF_RATE_SLOW;
			uRateQCIF = QCIF_RATE_SLOW;
			uRateSQCIF= SQCIF_RATE_SLOW;
		}

		// pentiums between 200-350 mhz
		else if (nNormalizedSpeed < VERYFAST_CPU_MHZ)
		{
			uRateCIF = CIF_RATE_FAST;
			uRateQCIF = QCIF_RATE_FAST;
			uRateSQCIF = SQCIF_RATE_FAST;
		}

		// really fast pentiums (400mhz and greater)
		else
		{
			// it would be better if we could scale between 15 and 30 frames/sec
			// depending on the CPU speed.  But H.245 doesn't have any values
			// between 15 and 30.  (See definition of Minimum Picture Interval)
			// So for now, 30 frames per sec CIF for all 400mhz and faster machines
			uRateCIF = CIF_RATE_VERYFAST;
			uRateQCIF = QCIF_RATE_FAST;
			uRateSQCIF = SQCIF_RATE_FAST;
		}

	}


	// Get the number of BASIC_VIDCAP_INFO structures available
	if (pCodecInfo->lpIVidAppCap->GetNumFormats((UINT*)&dwcFormats) != S_OK)
		goto MyExit;

	if (dwcFormats > 0)
	{
		// Allocate some memory to hold the list in
		if (!(pvidcaps = (BASIC_VIDCAP_INFO*)LocalAlloc(LPTR,dwcFormats * sizeof (BASIC_VIDCAP_INFO))))
			goto MyExit;

		// Get the list
		if (pCodecInfo->lpIVidAppCap->EnumFormats(pvidcaps, dwcFormats * sizeof (BASIC_VIDCAP_INFO),
		   (UINT*)&dwcFormatsReturned) != S_OK)
			goto MyExit;

		//Setup the Bandwitdh, and the frame rate (according to philf's #s)
		for (x=0;x<dwcFormatsReturned;x++)
		{

			// If the codec is "hardware accelerated" (0 for cpu usage), then we assume
			// that the maximum bitrate is whatever is specified at install
			// time.

			pvidcaps[x].uMaxBitrate=dwBitsPerSec;

			if (pvidcaps[x].wCPUUtilizationEncode == 0)
			{
				// hardware acceleration - don't change the frame rate
				continue;
			}

			format=get_format (pvidcaps[x].enumVideoSize);
			//Which format
			switch (format)
			{
				case SQCIF:
					pvidcaps[x].uFrameRate=uRateSQCIF;
					break;
				case QCIF:
					pvidcaps[x].uFrameRate=uRateQCIF;
					break;
				case CIF:
					pvidcaps[x].uFrameRate=uRateCIF;
					break;
				default:
					WARNING_OUT(("Incorrect Frame size discovered\r\n"));
					pvidcaps[x].uFrameRate=uRateCIF;
				}
		   }
		}

	// Ok, now submit this list
	if (pCodecInfo->lpIVidAppCap->ApplyAppFormatPrefs(pvidcaps, dwcFormats) != S_OK)
			goto MyExit;

	// Free the memory, we're done
	LocalFree(pvidcaps);

	// Set the bandwidth limit, which rebuilds capability sets
	hr = pCodecInfo->lpIH323->SetMaxPPBandwidth(dwBitsPerSec);
	fRet = !FAILED(hr);

MyExit:
	return (fRet);

}


BOOL GetIAppCap(PCODECINFO pCodecInfo)
{
	BOOL		fRet=TRUE;
	HRESULT 	hr;

	if (pCodecInfo->lpIAppCap && pCodecInfo->lpIVidAppCap && pCodecInfo->lpICapsCtl)
		return TRUE;

	if(NULL == pCodecInfo->lpIH323)
	{
		IH323CallControl *pIH323 = NULL;

		pCodecInfo->hLib = ::NmLoadLibrary(H323DLL);
		if ((pCodecInfo->hLib) == NULL)
		{
			WARNING_OUT(("LoadLibrary(H323DLL) failed"));
			return FALSE;
		}

		CREATEH323CC	pfnCreateH323 = (CREATEH323CC) ::GetProcAddress(pCodecInfo->hLib, SZ_FNCREATEH323CC);
		if (pfnCreateH323 == NULL)
		{
			ERROR_OUT(("GetProcAddress(CreateH323) failed"));
			return FALSE;
		}

		hr = pfnCreateH323(&pIH323, FALSE, 0);
		if (FAILED(hr))
		{
			ERROR_OUT(("CreateH323 failed, hr=0x%lx", hr));
			return FALSE;
		}

		pCodecInfo->lpIH323 = pIH323;
	}
    else
    {
    	// going to Release() later, so AddRef()
	    pCodecInfo->lpIH323->AddRef();
    }

	if(!pCodecInfo->lpIAppCap)
	{
		hr = pCodecInfo->lpIH323->QueryInterface(IID_IAppAudioCap, (void **)&(pCodecInfo->lpIAppCap));
		if (FAILED(hr))
		{
			fRet=FALSE;
			goto MyExit;	
		}
	}
	if(!pCodecInfo->lpIVidAppCap)
	{
		hr = pCodecInfo->lpIH323->QueryInterface(IID_IAppVidCap, (void **)&(pCodecInfo->lpIVidAppCap));
		if (FAILED(hr))
		{
			fRet=FALSE;
			goto MyExit;	
		}
	}
	if(!pCodecInfo->lpICapsCtl)
	{
		hr = pCodecInfo->lpIH323->QueryInterface(IID_IDualPubCap, (void **)&(pCodecInfo->lpICapsCtl));
		if (FAILED(hr))
		{
			fRet=FALSE;
			goto MyExit;	
		}
	}

MyExit:
	if (!fRet)
	{
		ReleaseIAppCap(pCodecInfo);
	}
	return (fRet);
}



BOOL GetAppCapFormats(PCODECINFO pCodecInfo)
{
	BOOL				fRet = FALSE;
	UINT				uNumFormats = 0;
	HRESULT 			hr;
	int 				i;
	
	if (pCodecInfo->pCodecCapList)
		return TRUE;

	if (!pCodecInfo->lpIAppCap)
	{
		if (!GetIAppCap(pCodecInfo))
			goto MyExit;

	}		
	if (FAILED(hr = ((pCodecInfo->lpIAppCap)->GetNumFormats(&uNumFormats))))
		goto MyExit;
		
	if (!uNumFormats)
		goto MyExit;
	
	if (!(pCodecInfo->pCodecCapList =  (PBASIC_AUDCAP_INFO)LocalAlloc
		(LPTR,uNumFormats * sizeof(BASIC_AUDCAP_INFO))))
		goto MyExit;
		
	if (!(pCodecInfo->pOldCodecOrderList =	(PWORD)LocalAlloc
		(LPTR,uNumFormats * sizeof(WORD))))
		goto MyExit;

		if (!(pCodecInfo->pCurCodecOrderList =	(PWORD)LocalAlloc
			(LPTR,uNumFormats * sizeof(WORD))))
		goto MyExit;


	if (FAILED(hr = ((pCodecInfo->lpIAppCap)->EnumFormats(pCodecInfo->pCodecCapList,
		uNumFormats * sizeof(BASIC_AUDCAP_INFO), &(pCodecInfo->uNumFormats)))))
	{
		//free the memory
		LocalFree(pCodecInfo->pCodecCapList);
		pCodecInfo->pCodecCapList = NULL;
		LocalFree(pCodecInfo->pOldCodecOrderList);
		pCodecInfo->pOldCodecOrderList = NULL;
		LocalFree(pCodecInfo->pCurCodecOrderList);
		pCodecInfo->pCurCodecOrderList = NULL;
		pCodecInfo->uNumFormats = 0;
		goto MyExit;
	}

	// initialize the old and the current state
	for (i=0; i<(int)pCodecInfo->uNumFormats;i++)
	{
		pCodecInfo->pCurCodecOrderList[i] = pCodecInfo->pCodecCapList[i].wSortIndex;
		pCodecInfo->pOldCodecOrderList[i] = pCodecInfo->pCodecCapList[i].wSortIndex;
		//SS:hack if we dont have the average, use the max as average
		if (!(pCodecInfo->pCodecCapList[i].uAvgBitrate))
			pCodecInfo->pCodecCapList[i].uAvgBitrate = pCodecInfo->pCodecCapList[i].uMaxBitrate;

	}

	fRet = TRUE;
	
MyExit:
	if (!fRet)
	{
		FreeAppCapFormats(pCodecInfo);
	}
	return (fRet);
}

void FreeAppCapFormats(PCODECINFO pCodecInfo)
{
	if (pCodecInfo->pCodecCapList)
	{
		LocalFree(pCodecInfo->pCodecCapList);
		pCodecInfo->pCodecCapList = NULL;
		pCodecInfo->uNumFormats = 0;
	}
	if (pCodecInfo->pOldCodecOrderList)
	{
		LocalFree(pCodecInfo->pOldCodecOrderList);
		pCodecInfo->pOldCodecOrderList = NULL;
	}
	if (pCodecInfo->pCurCodecOrderList)
	{
		LocalFree(pCodecInfo->pCurCodecOrderList);
		pCodecInfo->pCurCodecOrderList = NULL;
	}

	ReleaseIAppCap(pCodecInfo);
}

void ReleaseIAppCap(PCODECINFO pCodecInfo)
{
	if(pCodecInfo->lpIAppCap)
	{
		pCodecInfo->lpIAppCap->Release();
		pCodecInfo->lpIAppCap = NULL;
	}
	if(pCodecInfo->lpIVidAppCap)
	{
		pCodecInfo->lpIVidAppCap->Release();
		pCodecInfo->lpIVidAppCap = NULL;
	}
	if(pCodecInfo->lpICapsCtl)
	{
		pCodecInfo->lpICapsCtl->Release();
		pCodecInfo->lpICapsCtl = NULL;
	}
	if(pCodecInfo->lpIH323)
	{
		pCodecInfo->lpIH323->Release();
		pCodecInfo->lpIH323 = NULL;
	}
	if (pCodecInfo->hLib)
	{
		FreeLibrary(pCodecInfo->hLib);
		pCodecInfo->hLib = NULL;
	}
}



static void IsCodecDisabled(WORD wFormatTag, int cpu_family,
            UINT uBandwidthID, BOOL *pbSendEnabled, BOOL *pbRecvEnabled)
{
	int index;
	int size = sizeof(g_CodecPrefTable)/sizeof(CODECPREFROW);

	for (index = 0; index < size; index++)
	{
		if (g_CodecPrefTable[index].wFormatTag == wFormatTag)
		{
			// does bandwidth limit the use of this codec  ?
			if (uBandwidthID < g_CodecPrefTable[index].wMinBW)
			{
				*pbSendEnabled = FALSE;
				*pbRecvEnabled = FALSE;
				return;
			}

			*pbRecvEnabled = TRUE;  // all codecs can decode on 486

			if ((cpu_family <= 4) &&
             (CODEC_DISABLED == g_CodecPrefTable[index].wOrder486))
			{
				*pbSendEnabled = FALSE;
			}

			// otherwise, the codec can be used for sending and receiving
			else
			{
				*pbSendEnabled = TRUE;
			}
			return;
		}
	}

	WARNING_OUT(("Audiocpl.cpp:IsCodecDisabled - Unknown Codec!"));

	// it may be unknown, but enable it anyway
	*pbSendEnabled = TRUE;
	*pbRecvEnabled = TRUE;
	return;
}

static int GetCodecPrefOrder(WORD wFormatTag, int cpu_family)
{
	int index;
	int size = sizeof(g_CodecPrefTable)/sizeof(CODECPREFROW);

	for (index = 0; index < size; index++)
	{
		if (g_CodecPrefTable[index].wFormatTag == wFormatTag)
		{
			if (cpu_family > 4)
			{
				return g_CodecPrefTable[index].wOrder586;
			}
			else
			{
				return g_CodecPrefTable[index].wOrder486;
			}
		}
	}

	WARNING_OUT(("Audiocpl.cpp:GetCodecPrefOrder - Unknown Codec!"));

	// this will put the codec at the bottom of the list
	return CODEC_UNKNOWN;

}

// called by the sort routine that is within ChooseCodecByBW()
// returns -1 if v1 is more prefered.  +1 if v2 is more preferred over
// v1.  Returns 0 on tie.
static int codec_compare(const void *v1, const void *v2, int nCpuFamily)
{
	PBASIC_AUDCAP_INFO pCap1, pCap2;

	pCap1 = (PBASIC_AUDCAP_INFO)v1;
	pCap2 = (PBASIC_AUDCAP_INFO)v2;
	int pref1, pref2;

	// get preference order
	// if we can't send with this codec, we compare it as disabled
	// so that it appears on the bottom of the Codec Selection UI list
	if (pCap1->bSendEnabled == TRUE)
		pref1 = GetCodecPrefOrder(pCap1->wFormatTag, nCpuFamily);
	else
		pref1 = CODEC_DISABLED;

	if (pCap2->bSendEnabled == TRUE)
		pref2 = GetCodecPrefOrder(pCap2->wFormatTag, nCpuFamily);
	else
		pref2 = CODEC_DISABLED;

	if (pref1 < pref2)
		return -1;

	if (pref1 > pref2)
		return 1;
	
	// pref1==pref2

	// special case, G723.1 has two formats.  Higher bitrate is prefered
	if (pCap1->wFormatTag == WAVE_FORMAT_MSG723)
	{
		if (pCap1->uMaxBitrate < pCap2->uMaxBitrate)
			return 1;
		else
			return -1;
	}

	return 0;

}

BOOL ChooseCodecByBw(UINT uBandWidthId, PCODECINFO pCodecInfo)
{
	PBASIC_AUDCAP_INFO	pCodecCapList; // list of capabilities
#ifdef _M_IX86
	int nNormalizedSpeed;
#endif
	int nFamily;
	UINT uNumFormats, uNumDisabled = 0;
	UINT index;
	BOOL bSendEnabled, bRecvEnabled, bCompletelySorted;
	int *OrderList, ret, temp;

	//Fill out the PCodecInfo Structure
	if (!GetAppCapFormats(pCodecInfo))
		return FALSE;

	if (NULL == pCodecInfo->pCodecCapList)
		return FALSE;

	pCodecCapList = pCodecInfo->pCodecCapList;
	uNumFormats = pCodecInfo->uNumFormats;

	// figure out what type of CPU we have
#ifdef	_M_IX86
	GetNormalizedCPUSpeed (&nNormalizedSpeed,&nFamily);
	// A Pentium with FP emumalation is assumed to be a 486
	if (TRUE == IsFloatingPointEmulated())
	{
		nFamily = 4;
	}
#else
	// assume a DEC Alpha is a really fast pentium
	nFamily=5;
#endif

	// scan once to see which codecs should be disabled
	for (index=0; index < uNumFormats; index++)
	{
		IsCodecDisabled(pCodecCapList[index].wFormatTag,
          nFamily,uBandWidthId, &bSendEnabled, &bRecvEnabled);

		pCodecCapList[index].bSendEnabled = bSendEnabled;
		pCodecCapList[index].bRecvEnabled = bRecvEnabled;
	}


	// sort the capability list based on the preference table
	OrderList = (int *)LocalAlloc(LPTR, sizeof(int)*uNumFormats);
	if (OrderList == NULL)
		return FALSE;

	for (index = 0; index < uNumFormats; index++)
	{
		OrderList[index] = index;
	}


	//  bubble sort routine
	do
	{
		bCompletelySorted = TRUE;
		for (index=0; index < (uNumFormats-1); index++)
		{

			ret = codec_compare(&pCodecCapList[OrderList[index]],
			                    &pCodecCapList[OrderList[index+1]], nFamily);
			if (ret > 0)
			{
				// swap
				temp = OrderList[index];
				OrderList[index] = OrderList[index+1];
				OrderList[index+1] = temp;
				bCompletelySorted = FALSE;
			}
		}
	} while (bCompletelySorted == FALSE);


	// set the selection index from the result of the sort
	for (index = 0; index < uNumFormats; index++)	
	{
		pCodecCapList[OrderList[index]].wSortIndex = (WORD)index;
	}

	LocalFree(OrderList);
	
	return TRUE;
}



// this is called by the audio tuning wizard
VOID SaveDefaultCodecSettings(UINT uBandWidth)
{
	CODECINFO CodecInfo;

	ZeroMemory(&CodecInfo, sizeof(CodecInfo));

	RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
	re.SetValue(REGVAL_CODECCHOICE, CODECCHOICE_AUTO);

	ChooseCodecByBw(uBandWidth, &CodecInfo);
	//set the ordering
	SetAppCodecPrefs(&CodecInfo, uBandWidth);
	FreeAppCapFormats(&CodecInfo);
}


// this is called by the general property page
VOID UpdateCodecSettings(UINT uBandWidth)
{
	RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
	if (re.GetNumber(REGVAL_CODECCHOICE, CODECCHOICE_AUTO) ==
		CODECCHOICE_AUTO)
	{
		CODECINFO CodecInfo;

		ZeroMemory(&CodecInfo, sizeof(CodecInfo));

		ChooseCodecByBw(uBandWidth, &CodecInfo);
		//set the ordering
		SetAppCodecPrefs(&CodecInfo, uBandWidth);
		FreeAppCapFormats(&CodecInfo);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\atlexemodule.h ===
#ifndef __AtlExeModule_h__
#define __AtlExeModule_h__

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{

public: // Data
	DWORD		m_dwThreadID;
	HINSTANCE	m_hResourceModule;
	BOOL		m_bInitControl;
	BOOL		m_bVisible;
	BOOL		m_bDisableH323;
	BOOL		m_bDisableInitialILSLogon;
	BOOL        m_bCallerIsRTC;

// Construction / destriction
	CExeModule();

// Fns
	void SetUIVisible(BOOL bVisible) { m_bVisible = bVisible; }
	BOOL IsUIVisible()  { return m_bVisible; }
	BOOL IsUIActive();
	BOOL InitControlMode() { return m_bInitControl; }
	void SetInitControlMode(BOOL bInitControl) { m_bInitControl = bInitControl; }
	void SetSDKDisableH323(BOOL bDisable) { m_bDisableH323 = bDisable; };
	BOOL DidSDKDisableH323() { return m_bDisableH323; }
	void SetSDKDisableInitialILSLogon(BOOL bDisable) { m_bDisableInitialILSLogon = bDisable; };
	BOOL DidSDKDisableInitialILSLogon() { return m_bDisableInitialILSLogon; }
	void SetSDKCallerIsRTC (BOOL bCallerIsRTC) { m_bCallerIsRTC = bCallerIsRTC; }
	BOOL IsSDKCallerRTC () { return m_bCallerIsRTC; }
	HINSTANCE GetResourceModule(void) const { return m_hResourceModule; }

	LONG Unlock();

};

extern CExeModule _Module;


#endif // __AtlExeModule_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\avdefs.h ===
// File: avDefs.h

#ifndef _AVDEFS_H_

//To bring in the video stuff...from the NAC interface
#ifndef WSA_IO_PENDING

typedef struct _OVERLAPPED *    LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;

typedef
void
(CALLBACK * LPWSAOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwError,
    DWORD cbTransferred,
    LPWSAOVERLAPPED lpOverlapped,
    DWORD dwFlags
    );

#define WSA_IO_PENDING          (ERROR_IO_PENDING)

#endif // } WSA_IO_PENDING

#include <mmreg.h>
#include <msacm.h>
#include <vidinout.h>
#include <vcmstrm.h>
#include <iacapapi.h>

#endif /* _AVDEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\audioctl.h ===
#ifndef _AUDIOCTL_H_
#define _AUDIOCTL_H_

#include "SDKInternal.h"
#include "mixer.h"

interface IAudioEvent
{
public:
	virtual void OnLevelChange(BOOL fSpeaker, DWORD dwVolume) = 0;
	virtual void OnMuteChange(BOOL fSpeaker, BOOL fMute) = 0;
};
	
class CMixerDevice;

class CAudioControl
{
private:
	CMixerDevice*	m_pRecMixer;
	CMixerDevice*	m_pSpkMixer;
	MIXVOLUME		m_dwMicVolume;
	MIXVOLUME 		m_dwSpkVolume;
	BOOL			m_fMicMuted;
	BOOL			m_fSpkMuted;
	DWORD			m_dwRecordDevice;
	DWORD			m_dwPlaybackDevice;
	DWORD			m_dwSilenceLevel;
	BOOL			m_fAutoMix;
	INmChannelAudio * m_pChannelMic;
	INmChannelAudio * m_pChannelSpk;
	IAudioEvent *	m_pAudioEvent;
	HWND			m_hwndParent;

	MIXVOLUME			m_dwSpkVolumeOld;

protected:
	BOOL LoadSettings();
	BOOL SaveSettings();

public:
	CAudioControl(HWND hwnd);
	~CAudioControl();

	void	OnChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);
	void	RefreshMixer();

	VOID	OnDeviceChanged();
	VOID	OnAGC_Changed();
	VOID	OnSilenceLevelChanged();

	void	RegisterAudioEventHandler(IAudioEvent *pEvent)
					{ m_pAudioEvent = pEvent; }

	BOOL	CanSetRecorderVolume();
	BOOL	CanSetSpeakerVolume();
	void	SetRecorderVolume(MIXVOLUME *pdwVolume);
	void	SetSpeakerVolume(MIXVOLUME *pdwVolume);

	void	SetRecorderVolume(DWORD dwVolume);
	void	SetSpeakerVolume(DWORD  dwVolume);

	void	GetRecorderVolume(MIXVOLUME *pdwVolume);
	void	GetSpeakerVolume(MIXVOLUME *pdwVolume);

	DWORD	GetRecorderVolume()	{ return max(m_dwMicVolume.leftVolume , m_dwMicVolume.rightVolume); }
	DWORD	GetSpeakerVolume() { return  max(m_dwSpkVolume.leftVolume , m_dwSpkVolume.rightVolume); }


	void	MuteAudio(BOOL fSpeaker, BOOL fMute);
	DWORD	GetAudioSignalLevel(BOOL fSpeaker);

	BOOL	IsSpkMuted() { return m_fSpkMuted;}
	BOOL	IsRecMuted() { return m_fMicMuted;}

	HRESULT	SetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR uValue);
	HRESULT	GetProperty(BOOL fSpeaker, NM_AUDPROP uID, ULONG_PTR *puValue);
};

#endif	// _AUDIOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\audiolvl.h ===
#ifndef _AUDIOLEVEL_H
#define _AUDIOLEVEL_H

#include "AudioCtl.h"
#include "imsconf3.h"

#define SIGNAL_STATUS_TRANSMIT  0x01  // data is being received/sent
#define SIGNAL_STATUS_JAMMED    0x02  // wave dev failed to open

const int g_nAudLevelTotalHeight =	30;
const int g_nAudLevelMinWidth = 150;

// CAudioLevel encapsulates the rebar band for the "signal level"
// display (and mute buttons)



class CAudioLevel : public CAudioEvent
{
public:
	CAudioLevel(CAudioControl *);
	~CAudioLevel();

	BOOL Create(HWND hwndParent);
	BOOL OnTimer(WPARAM wTimerId);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	BOOL ShiftFocus(HWND hwndCur, BOOL fForward);
	BOOL IsChildWindow(HWND hwnd);
	BOOL OnMuteChange(BOOL fSpeaker, BOOL fMute);
	BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *plRet);
	BOOL OnScroll(WPARAM wParam, LPARAM lParam);
	BOOL OnLevelChange(BOOL fSpeaker, DWORD dwVolume);
	BOOL OnDeviceChanged(void);
	BOOL OnDeviceStatusChanged(BOOL fSpeaker, UINT uEvent, UINT uSubCode);


	BOOL OnPaint(PAINTSTRUCT *ps);
	BOOL PaintChannel(BOOL fSpeaker, HDC hdc=NULL);
	BOOL PaintIcons(HDC hdc);

	BOOL Resize(int nLeft, int nTop, int nWidth, int nHeight);
	BOOL Show(BOOL bVisible);

	BOOL CreateBrushes();
	BOOL ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);


private:

	HWND m_hwndParent;
	HWND m_hwndParentParent; // m_hwndParent's parent (rebar frame)

	HWND		m_hwndMicTrack;
	HWND		m_hwndMicTrackTT;
	HWND		m_hwndSpkTrack;
	HWND		m_hwndSpkTrackTT;

	HICON m_hIconSpkr;
	UINT m_uIconSpkrID;

	HICON m_hIconMic;
	UINT m_uIconMicID;

	HWND m_hwndChkbRecMute;
	HWND m_hwndChkbSpkMute;
	HWND m_hwndChkbRecMuteTT;
	HWND m_hwndChkbSpkMuteTT;

	CAudioControl *m_pAudioControl;

	RECT m_rect;
	BOOL m_fVisible;
	BOOL m_fMicTrkVisible;
	BOOL m_fSpkTrkVisible;

	RECT m_rcChannelSpk;     // window area of the signal level
	RECT m_rcChannelMic;     // window area of the signal level

	DWORD m_dwMicTrackPos, m_dwSpkTrackPos;  // trackbar thumb positions
	DWORD m_dwMicLvl, m_dwSpkLvl;            // signal level position

	HBRUSH m_hGreyBrush;  // background
	HBRUSH m_hRedBrush, m_hYellowBrush, m_hGreenBrush, m_hBlackBrush;
	HPEN   m_hHiLitePen, m_hShadowPen, m_hDkShadowPen, m_hLitePen;

	BOOL GetIconArea(BOOL fSpeaker, RECT *pRect);


};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\audiowiz.h ===
#ifndef _AUDIOWIZ_H
#define _AUDIOWIZ_H

//for uOptions in wizard calls
#define RUNDUE_CARDCHANGE		0x00000001
#define RUNDUE_NEVERBEFORE		0x00000002
#define RUNDUE_USERINVOKED		0x00000003

#define STARTWITH_BACK			0x10000000
#define ENDWITH_NEXT			0x20000000

//card capabilities
#define 	SOUNDCARD_NONE				0x00000000
#define 	SOUNDCARD_PRESENT			0x00000001
#define		SOUNDCARD_FULLDUPLEX		0x00000002
#define		SOUNDCARD_HAVEAGC			0x00000004
#define		SOUNDCARD_HAVERECVOLCNTRL	0x00000008
#define		SOUNDCARD_DIRECTSOUND		0x00000010

#define		MASKOFFFULLDUPLEX(SoundCap)	((SoundCap) & (0xFFFFFFFF ^ SOUNDCARD_FULLDUPLEX))
#define		MASKOFFHAVEAGC(SoundCap)	((SoundCap) & (0xFFFFFFFF ^ SOUNDCARD_HAVEAGC))
#define		MASKOFFHAVERECVOLCNTRL(SoundCap)	((SoundCap) & (0xFFFFFFFF ^ SOUNDCARD_HAVERECVOLCNTRL))
#define		ISSOUNDCARDPRESENT(SoundCap)	(SoundCap & SOUNDCARD_PRESENT)
#define 	ISSOUNDCARDFULLDUPLEX(SoundCap)	(SoundCap & SOUNDCARD_FULLDUPLEX)
#define		DOESSOUNDCARDHAVEAGC(SoundCap)	(SoundCap & SOUNDCARD_HAVEAGC)
#define 	DOESSOUNDCARDHAVERECVOLCNTRL(SoundCap) (SoundCap & SOUNDCARD_HAVERECVOLCNTRL)
#define 	ISDIRECTSOUNDAVAILABLE(SoundCap) (SoundCap & SOUNDCARD_DIRECTSOUND)

#pragma warning (disable:4200)
typedef struct _WIZCONFIG{
	BOOL	fCancel;	//if a dialog was cancelled, this will be set
	UINT	uFlags;		//the higher order WORD specifying the config of this dialog
	DWORD	dwCustomDataSize;
	BYTE	pCustomData[];
}WIZCONFIG, *PWIZCONFIG;
#pragma warning (default:4200)


#define AUDIOWIZ_NOCHANGES			0x00000000
#define CALIBVOL_CHANGED			0x00000001
#define SOUNDCARDCAPS_CHANGED		0x00000002
#define CODECPOWER_CHANGED			0x00000004
#define TYPBANDWIDTH_CHANGED		0x00000008
#define SOUNDCARD_CHANGED			0x00000010
#define SPEAKERVOL_CHANGED			0x00000020

#define	MASKOFFCALIBVOL_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ CALIBVOL_CHANGED))
#define	MASKOFFSOUNDCARDCAPS_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ SOUNDCARDCAPS_CHANGED))
#define	MASKOFFCODECPOWER_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ CODECPOWER_CHANGED))
#define	MASKOFFTYPBANDWIDTH_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ TYPBANDWIDTH_CHANGED))
#define	MASKOFFSOUNDCARD_CHANGED(uChange) ((uChange) | (0xFFFFFFFF ^ SOUNDCARD_CHANGED))

typedef struct _AUDIOWIZOUTPUT{
	UINT	uChanged;
	UINT	uValid;
	UINT	uSoundCardCaps;
	UINT	uCalibratedVol;
	UINT	uTypBandWidth;
	UINT	uWaveInDevId;
	UINT	uWaveOutDevId;
	TCHAR	szWaveInDevName[MAXPNAMELEN];
	TCHAR	szWaveOutDevName[MAXPNAMELEN];
} AUDIOWIZOUTPUT, *PAUDIOWIZOUTPUT;
					
//for now set uDevId to WAVE_MAPPER - later that will allow user to
//select the device.
//uOptions-rundue_userinvoked brings up just the calibration pages
//uOptions-rundue_cardchange or rundue_neverbefore also invoked full duplex check pages.

BOOL GetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig,LPUINT lpuNumPages);

void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages,
	PWIZCONFIG pWizConfig,PAUDIOWIZOUTPUT pAudioWizOut);

// Global flag keeps setting that changed for windows msg broadcast
INT_PTR CallAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId,PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc);

VOID CmdAudioCalibWizard(HWND hwnd);

#endif	//#ifndef _AUDIOWIZ_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\autoconf.h ===
#ifndef _AutoConf_h_
#define _AutoConf_h_

#define AUTOCONF_CONTEXT_OPENURL   1
#define AUTOCONF_CONTEXT_READFILEX 2

class CAutoConf
{
public:
	static void DoIt();

private:
	LPTSTR		m_szServer;
	HINTERNET   m_hInternet;
	HINTERNET	m_hOpenUrl;
	HANDLE		m_hFile;
	HINF		m_hInf;
	TCHAR		m_szFile[ MAX_PATH ];

	HANDLE		m_hEvent;
	DWORD		m_dwTimeOut;
	DWORD		m_dwGrab;

private:
	CAutoConf( LPTSTR szServer );
	~CAutoConf();

private:
	BOOL OpenConnection();
	BOOL ParseFile();
	BOOL GetFile();
	void CloseInternet();
	BOOL GrabData();
	BOOL QueryData();

private:
	static VOID CALLBACK InetCallback( HINTERNET hInternet, DWORD dwContext, DWORD dwInternetStatus,
    LPVOID lpvStatusInformation, DWORD dwStatusInformationLength );
};

#endif // _AutoConf_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\audiolvl.cpp ===
#include "precomp.h"
#include "resource.h"
#include "AudioLvl.h"



static const int g_nAudIconWidth   = 16;
static const int g_nAudIconHeight  = 16;
static const int g_nAudChkbWidth   = 13;
static const int g_nAudChkbHeight  = 13;
static const int g_nAudChkbXMargin =  13;
static const int g_nAudChkbYMargin = 12;

static const int g_nAudIconXMargin = g_nAudChkbXMargin + g_nAudChkbWidth + 3;
static const int g_nAudIconYMargin = 10;

static const int g_nAudMeterXMargin = g_nAudIconXMargin + g_nAudIconWidth + 5;
static const int g_nAudMeterHeight = 7;
static const int g_nAudMeterYMargin = g_nAudIconYMargin + (g_nAudMeterHeight/2);

static const int g_nAudMeterRightMargin = 5; // 5 pixels from end

static const int g_nAudTrkRangeMin = 0;
static const int g_nAudTrkRangeMax = 99;
static const int g_nAudTrkRangeSeg = 0xFFFF / g_nAudTrkRangeMax;
static const int g_nAudTrkTickFreq =	20;

static const int g_nAudTrkRightGap =	3;
static const int g_nAudTrkXMargin = g_nAudIconXMargin + g_nAudIconWidth + 5;
static const int g_nAudTrkYMargin =	2;
static const int g_nAudTrkHeight =	25;
static const int g_nAudTrkMinWidth = 50;


static const int RECTANGLE_WIDTH = 10;
static const int RECTANGLE_LEADING = 1;


static inline WORD ScaleMixer(DWORD dwVol)
{
	// NOTE: the "+ g_nAudTrkRangeSeg - 1" provides for a correction that
	// takes place while truncating the position when we are setting the
	// volume.  See bug 1634
	return (((LOWORD(dwVol) + g_nAudTrkRangeSeg - 1) *
		g_nAudTrkRangeMax) / 0xFFFF);
}



CAudioLevel::CAudioLevel(CAudioControl *pAudioControl) :
m_hwndParent(NULL),
m_hwndMicTrack(NULL),
m_hwndMicTrackTT(NULL),
m_hwndSpkTrack(NULL),
m_hwndSpkTrackTT(NULL),
m_hIconMic(NULL),
m_hIconSpkr(NULL),
m_hwndChkbRecMute(NULL),
m_hwndChkbSpkMute(NULL),
m_hwndChkbRecMuteTT(NULL),
m_hwndChkbSpkMuteTT(NULL),
m_fVisible(FALSE),
m_fMicTrkVisible(TRUE),
m_fSpkTrkVisible(TRUE),


m_dwMicTrackPos(0xFFFFFFFF),
m_dwSpkTrackPos(0xFFFFFFFF),
m_dwMicLvl(0),
m_dwSpkLvl(0),

m_hGreyBrush(NULL), m_hBlackBrush(NULL), m_hRedBrush(NULL),
m_hGreenBrush(NULL), m_hYellowBrush(NULL), m_hHiLitePen(NULL),
m_hShadowPen(NULL), m_hDkShadowPen(NULL), m_hLitePen(NULL)
{

	ClearStruct(&m_rect);
	m_pAudioControl = pAudioControl;


	// load icons

	m_hIconSpkr = (HICON) ::LoadImage(	::GetInstanceHandle(),
										MAKEINTRESOURCE(IDI_SPKEMPTY),
										IMAGE_ICON,
										g_nAudIconWidth,
										g_nAudIconHeight,
										LR_DEFAULTCOLOR | LR_SHARED);

	m_hIconMic = (HICON) ::LoadImage(	::GetInstanceHandle(),
										MAKEINTRESOURCE(IDI_MICEMPTY),
										IMAGE_ICON,
										g_nAudIconWidth,
										g_nAudIconHeight,
										LR_DEFAULTCOLOR | LR_SHARED);

	// create the brushes used for painting the signal level
	CreateBrushes();

}

CAudioLevel::~CAudioLevel()
{
	if (m_hGreyBrush)
		DeleteObject(m_hGreyBrush);
	if (m_hRedBrush)
		DeleteObject(m_hRedBrush);
	if (m_hYellowBrush)
		DeleteObject(m_hYellowBrush);
	if (m_hGreenBrush)
		DeleteObject(m_hGreenBrush);
	if (m_hBlackBrush)
		DeleteObject(m_hBlackBrush);

	if (m_hHiLitePen)
		DeleteObject(m_hHiLitePen);
	if (m_hDkShadowPen)
		DeleteObject(m_hDkShadowPen);
	if (m_hShadowPen)
		DeleteObject(m_hShadowPen);
	if (m_hLitePen)
		DeleteObject(m_hLitePen);

}




CAudioLevel::Create(HWND hwndParent)
{
	BOOL fCanSetRecVolume, fCanSetSpkVolume;
	BOOL fCheck;

	m_hwndParent = hwndParent;
	m_hwndParentParent = GetParent(hwndParent);


	fCanSetRecVolume = m_pAudioControl->CanSetRecorderVolume();
	fCanSetSpkVolume = m_pAudioControl->CanSetSpeakerVolume();


	// create the mute check box for microphone
	m_hwndChkbRecMute = ::CreateWindow(	_TEXT("BUTTON"),
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS |
											BS_AUTOCHECKBOX,
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) IDM_MUTE_MICROPHONE,
										GetInstanceHandle(),
										NULL);

	if (m_hwndChkbRecMute != NULL)
	{
		// mute is initially off
		fCheck = !(m_pAudioControl->IsRecMuted());
		::SendMessage(m_hwndChkbRecMute, BM_SETCHECK, fCheck, 0);

		// create the tool tip
		m_hwndChkbRecMuteTT = CreateWindowEx(0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndChkbRecMuteTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndChkbRecMute;
			ti.lpszText = (LPTSTR) IDS_AUDIO_REC_MUTE_TT;

			::SendMessage(	m_hwndChkbRecMuteTT, TTM_ADDTOOL, 0,
							(LPARAM) (LPTOOLINFO) &ti);
		}

	}


	// create the mute check box for speaker
	m_hwndChkbSpkMute = ::CreateWindow(	_TEXT("BUTTON"),
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS
											| BS_AUTOCHECKBOX,
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) IDM_MUTE_SPEAKER,
										GetInstanceHandle(),
										NULL);
	if (NULL != m_hwndChkbSpkMute)
	{
		// set appropriate mute status in microphone's mute check box
		fCheck = !(m_pAudioControl->IsSpkMuted());

		// Mute is off - so check it
		::SendMessage(m_hwndChkbSpkMute, BM_SETCHECK, fCheck, 0);

		// create the tool tip
		m_hwndChkbSpkMuteTT = CreateWindowEx(0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndChkbSpkMuteTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndChkbSpkMute;
			ti.lpszText = (LPTSTR) IDS_AUDIO_SPK_MUTE_TT;

			::SendMessage(	m_hwndChkbSpkMuteTT, TTM_ADDTOOL, 0,
							(LPARAM) (LPTOOLINFO) &ti);
		}


	}

	// create the mic level trackbar:
	m_hwndMicTrack = ::CreateWindowEx(	0L,
										TRACKBAR_CLASS,
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS
											| TBS_HORZ | TBS_NOTICKS | TBS_BOTH
											| (fCanSetRecVolume ? 0 : WS_DISABLED),
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) ID_AUDIODLG_MIC_TRACK,
										::GetInstanceHandle(),
										NULL);
	if (NULL != m_hwndMicTrack)
	{
		::SendMessage(	m_hwndMicTrack,
						TBM_SETRANGE,
						FALSE,
						MAKELONG(g_nAudTrkRangeMin, g_nAudTrkRangeMax));
		
		::SendMessage(	m_hwndMicTrack,
						TBM_SETTICFREQ,
						g_nAudTrkTickFreq,
						g_nAudTrkRangeMin);

		WORD wPos = (g_nAudTrkRangeMax - g_nAudTrkRangeMin) / 2;
		if (fCanSetRecVolume)
		{
			wPos = ScaleMixer(m_pAudioControl->GetRecorderVolume());
		}
		::SendMessage(	m_hwndMicTrack,
						TBM_SETPOS,
						TRUE,
						wPos);

		m_hwndMicTrackTT = CreateWindowEx(	0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndMicTrackTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndMicTrack;
			ti.lpszText = (LPTSTR) IDS_AUDIO_MIC_TRACK_TT;

			::SendMessage(m_hwndMicTrackTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
		}
	}



	// create the speaker level trackbar:
	m_hwndSpkTrack = ::CreateWindowEx(	0L,
										TRACKBAR_CLASS,
										g_szEmpty,
										WS_CHILD | WS_CLIPSIBLINGS 
											| TBS_HORZ | TBS_NOTICKS | TBS_BOTH
											| (fCanSetSpkVolume ? 0 : WS_DISABLED),
										0, 0, 0, 0,
										m_hwndParent,
										(HMENU) ID_AUDIODLG_SPKR_TRACK,
										::GetInstanceHandle(),
										NULL);
	if (NULL != m_hwndSpkTrack)
	{
		::SendMessage(	m_hwndSpkTrack,
						TBM_SETRANGE,
						FALSE,
						MAKELONG(g_nAudTrkRangeMin, g_nAudTrkRangeMax));
		
		::SendMessage(	m_hwndSpkTrack,
						TBM_SETTICFREQ,
						g_nAudTrkTickFreq,
						g_nAudTrkRangeMin);

		WORD wPos = (g_nAudTrkRangeMax - g_nAudTrkRangeMin) / 2;
		if (fCanSetSpkVolume)
		{
			wPos = ScaleMixer(m_pAudioControl->GetSpeakerVolume());
		}
		::SendMessage(	m_hwndSpkTrack,
						TBM_SETPOS,
						TRUE,
						wPos);

		m_hwndSpkTrackTT = CreateWindowEx(	0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwndParent, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		if (NULL != m_hwndSpkTrackTT)
		{
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND; 
			ti.hwnd = m_hwndParent; 
			ti.hinst = ::GetInstanceHandle(); 
			ti.uId = (UINT) m_hwndSpkTrack;
			ti.lpszText = (LPTSTR) IDS_AUDIO_SPK_TRACK_TT;

			::SendMessage(m_hwndSpkTrackTT, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
		}

	}





	return TRUE;
}


BOOL CAudioLevel::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CreateBrushes();
	if (NULL != m_hwndMicTrack)
	{
		::SendMessage(m_hwndMicTrack, uMsg, wParam, lParam);
	}
	if (NULL != m_hwndSpkTrack)
	{
		::SendMessage(m_hwndSpkTrack, uMsg, wParam, lParam);
	}
	return TRUE;
}

BOOL CAudioLevel::CreateBrushes()
{
	// the background color may change on us!
	COLORREF GreyColor = GetSysColor(COLOR_3DFACE);
	COLORREF BlackColor = GetSysColor(COLOR_BTNTEXT);
	const COLORREF RedColor = RGB(255,0,0);
	const COLORREF YellowColor = RGB(255,255,0);
	const COLORREF GreenColor = RGB(0,255,0);

	COLORREF ShadowColor = GetSysColor(COLOR_3DSHADOW);
	COLORREF HiLiteColor = GetSysColor(COLOR_3DHIGHLIGHT);
	COLORREF LiteColor = GetSysColor(COLOR_3DLIGHT);
	COLORREF DkShadowColor = GetSysColor(COLOR_3DDKSHADOW);

	if (m_hGreyBrush)
	{
		DeleteObject(m_hGreyBrush);
	}
	m_hGreyBrush = CreateSolidBrush(GreyColor);

	if (m_hBlackBrush)
	{
		DeleteObject(m_hBlackBrush);
	}
	m_hBlackBrush = CreateSolidBrush(BlackColor);

	if (m_hHiLitePen)
	{
		DeleteObject(m_hHiLitePen);
	}
	m_hHiLitePen = CreatePen(PS_SOLID, 0, HiLiteColor);

	if (m_hLitePen)
	{
		DeleteObject(m_hLitePen);
	}
	m_hLitePen = CreatePen(PS_SOLID, 0, LiteColor);

	if (m_hDkShadowPen)
	{
		DeleteObject(m_hDkShadowPen);
	}
	m_hDkShadowPen = CreatePen(PS_SOLID, 0, DkShadowColor);

	if (m_hShadowPen)
	{
		DeleteObject(m_hShadowPen);
	}
	m_hShadowPen = CreatePen(PS_SOLID, 0, ShadowColor);

	// red, yellow, green will never change
	if (!m_hRedBrush)
		m_hRedBrush = CreateSolidBrush (RedColor);

	if (!m_hGreenBrush)
		m_hGreenBrush = CreateSolidBrush(GreenColor);

	if (!m_hYellowBrush)
		m_hYellowBrush = CreateSolidBrush(YellowColor);

	return TRUE;


}

BOOL CAudioLevel::OnCommand(WPARAM wParam, LPARAM lParam)
{
	LRESULT lCheck;
	BOOL    fSpeaker;

	switch (LOWORD(wParam))
	{
	default:
		return FALSE;

	case IDM_MUTE_MICROPHONE_ACCEL:
		lCheck = BST_CHECKED;
		fSpeaker = FALSE;
		break;

	case IDM_MUTE_MICROPHONE:
		lCheck = BST_UNCHECKED;
		fSpeaker = FALSE;
		break;

	case IDM_MUTE_SPEAKER_ACCEL:
		lCheck = BST_CHECKED;
		fSpeaker = TRUE;
		break;
	
	case IDM_MUTE_SPEAKER:
		lCheck = BST_UNCHECKED;
		fSpeaker = TRUE;
		break;
	}

	BOOL fMute = (lCheck == ::SendMessage(
		fSpeaker ? m_hwndChkbSpkMute : m_hwndChkbRecMute,
		BM_GETCHECK, 0, 0));

	m_pAudioControl->MuteAudio(fSpeaker, fMute);
	return TRUE;
}


BOOL CAudioLevel::ShiftFocus(HWND hwndCur, BOOL fForward)
{
	BOOL bRet = FALSE;
	HWND aHwnds[] = {m_hwndChkbSpkMute,m_hwndSpkTrack,m_hwndChkbRecMute,m_hwndMicTrack};
	int nSizeArray = ARRAY_ELEMENTS(aHwnds);
	int nIndex, nSelect;
	HWND hwndNewFocus=NULL;

	if (m_fVisible)
	{
		if (hwndCur == NULL)
		{
			hwndNewFocus = m_hwndSpkTrack;
		}
		else
		{
			for (nIndex = 0; nIndex < nSizeArray; nIndex++)
			{
				if (aHwnds[nIndex] == hwndCur)
				{
					nSelect = (nIndex + (fForward ? 1 : -1)) % nSizeArray;

					if (nSelect < 0)
						nSelect += nSizeArray;

					hwndNewFocus = aHwnds[nSelect];
					break;
				}
			}
		}

		if (hwndNewFocus)
		{
			SetFocus(hwndNewFocus);
			bRet = TRUE;
		}
	}

	return bRet;
}

BOOL CAudioLevel::IsChildWindow(HWND hwnd)
{

	if (hwnd)
	{
		if ((hwnd == m_hwndSpkTrack) || (hwnd == m_hwndMicTrack) ||
			(hwnd == m_hwndChkbRecMute) || (hwnd == m_hwndChkbSpkMute))
		{
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CAudioLevel::OnMuteChange(BOOL fSpeaker, BOOL fMute)
{
	SendMessage(fSpeaker ? m_hwndChkbSpkMute : m_hwndChkbRecMute,
		BM_SETCHECK, fMute ? BST_UNCHECKED : BST_CHECKED, 0);

	return TRUE;
}




BOOL CAudioLevel::OnPaint(PAINTSTRUCT* pps)
{
	if (m_fVisible)
	{
		ASSERT(pps);
		ASSERT(pps->hdc);
		PaintIcons(pps->hdc);
	}

	return TRUE;
}


BOOL CAudioLevel::PaintChannel(BOOL fSpeaker, HDC hdc)
{
	BOOL bGotDC = FALSE;
	DWORD dwVolume;
	int nVuWidth, nDiff;
	RECT rect, rectDraw;
	HBRUSH hCurrentBrush;
	HPEN hOldPen;
	int nRects;
	int nRectangleWidth;
	int nIndex;
	const int NUM_RECTANGLES_MAX = 16;
	const int NUM_RECTANGLES_MIN = 6;
	int nRectsTotal;
	bool bTransmitting;
	POINT ptOld, pt;

	if (fSpeaker)
	{
		dwVolume = LOWORD(m_dwSpkLvl);
		bTransmitting = HIWORD(m_dwSpkLvl) & SIGNAL_STATUS_TRANSMIT;
	}
	else
	{
		dwVolume = LOWORD(m_dwMicLvl);
		bTransmitting = HIWORD(m_dwMicLvl) & SIGNAL_STATUS_TRANSMIT;
	}


	if (!hdc)
	{
		if ((fSpeaker) && (m_hwndSpkTrack))
			hdc = GetDC(m_hwndSpkTrack);
		else if (m_hwndMicTrack)
			hdc = GetDC(m_hwndMicTrack);
		bGotDC = TRUE;
	}

	if (!hdc)
		return FALSE;

	// rectangle leading is 1

	if (dwVolume > 100)
		dwVolume = 100;

	if (fSpeaker)
		rect = m_rcChannelSpk;
	else
		rect = m_rcChannelMic;

	nVuWidth = rect.right - rect.left;
	if (nVuWidth < (NUM_RECTANGLES_MIN*2))
		return FALSE;


	// "rect" represents the edges of the meter's outer rectangle

	// compute the number of individual rectangles to use
	// we do the computation this way so that sizing the rebar band
	// makes the size changes consistant
	nRectsTotal = NUM_RECTANGLES_MAX;

	nRectsTotal = (nVuWidth + (g_nAudMeterHeight - 1)) / g_nAudMeterHeight;
	nRectsTotal = min(nRectsTotal, NUM_RECTANGLES_MAX);
	nRectsTotal = max(nRectsTotal, NUM_RECTANGLES_MIN);

	// nRectangleWidth - width of colored rectangle - no leading
	nRectangleWidth = ((nVuWidth-2)/nRectsTotal) - 1;

	// nVuWidth - width of entire VU meter including edges
	nVuWidth = (nRectangleWidth + 1)*nRectsTotal + 2;

	// re-adjust meter size to be an integral number of rects
	nDiff = rect.right - (rect.left + nVuWidth);
	rect.right = rect.left + nVuWidth;

	// center vu-meter across whole channel area so that the
	// slider's thumb is always covering some portion of the channel
	rect.left += (nDiff/2);
	rect.right += (nDiff/2);

	// draw the 3D frame border
	hOldPen = (HPEN) SelectObject (hdc, m_hHiLitePen);
	MoveToEx(hdc, rect.right, rect.top, &ptOld);
	LineTo(hdc, rect.right, rect.bottom);
	LineTo(hdc, rect.left-1, rect.bottom);  // -1 because LineTo stops just short of this point

	SelectObject(hdc, m_hShadowPen);
	MoveToEx(hdc, rect.left, rect.bottom-1, &pt);
	LineTo(hdc, rect.left, rect.top);
	LineTo(hdc, rect.right, rect.top);

	SelectObject(hdc, m_hDkShadowPen);
	MoveToEx(hdc, rect.left+1, rect.bottom-2, &pt);
	LineTo(hdc, rect.left+1, rect.top+1);
	LineTo(hdc, rect.right-1, rect.top+1);

	SelectObject(hdc, m_hLitePen);
	MoveToEx(hdc, rect.left+1, rect.bottom-1, &pt);
	LineTo(hdc, rect.right-1, rect.bottom-1);
	LineTo(hdc, rect.right-1, rect.top);

	SelectObject(hdc, m_hShadowPen);

	// the top and left of the meter has a 2 line border
	// the bottom and right of the meter has a 2 line border
	rectDraw.top = rect.top + 2;
	rectDraw.bottom = rect.bottom - 1 ;
	rectDraw.left = rect.left + 2;
	rectDraw.right = rectDraw.left + nRectangleWidth;


	// how many colored rectangles do we draw ?
	nRects = (dwVolume * nRectsTotal) / 100;

	// not transmitting - don't show anything
	if ((false == bTransmitting) && (false == fSpeaker))
		nRects = 0;

	// transmitting or receiving something very quiet - 
	// light up at least one rectangle
	else if ((bTransmitting) && (nRects == 0))
		nRects = 1;
	
	hCurrentBrush = m_hGreenBrush;

	for (nIndex = 0; nIndex < nRectsTotal; nIndex++)
	{
		// far left fourth of the bar is green
		// right fourth of the bar is red
		// middle is yellow
		if (nIndex > ((nRectsTotal*3)/4))
			hCurrentBrush = m_hRedBrush;
		else if (nIndex >= nRectsTotal/2)
			hCurrentBrush = m_hYellowBrush;

		if (nIndex >= nRects)
			hCurrentBrush = m_hGreyBrush;

		FillRect(hdc, &rectDraw, hCurrentBrush);

		if (nIndex != (nRectsTotal-1))
		{
			MoveToEx(hdc, rectDraw.left + nRectangleWidth, rectDraw.top, &pt);
			LineTo(hdc, rectDraw.left + nRectangleWidth, rectDraw.bottom);
		}

		rectDraw.left += nRectangleWidth + 1;  // +1 for the leading
		rectDraw.right = rectDraw.left + nRectangleWidth;
	}

	MoveToEx(hdc, ptOld.x, ptOld.y, &pt);
	SelectObject (hdc, hOldPen);

	if (bGotDC)
	{
		DeleteDC(hdc);
	}

	return TRUE;

}




BOOL CAudioLevel::OnTimer(WPARAM wTimerID)
{
	DWORD dwLevel;



	if (m_fVisible && (NULL != m_pAudioControl))
	{
		dwLevel = m_pAudioControl->GetAudioSignalLevel(FALSE /*fSpeaker*/);	// This level ranges from 0-100
		if (dwLevel != m_dwMicLvl)
		{
			m_dwMicLvl = dwLevel;			
			// HACK: SETRANGEMAX is the only way to force the slider to update itself...
			SendMessage(m_hwndMicTrack, TBM_SETRANGEMAX, TRUE, g_nAudTrkRangeMax);
		}

		dwLevel = m_pAudioControl->GetAudioSignalLevel(TRUE /*fSpeaker*/);	// This level ranges from 0-100
		if (dwLevel != m_dwSpkLvl)
		{
			m_dwSpkLvl = dwLevel;
			SendMessage(m_hwndSpkTrack, TBM_SETRANGEMAX, TRUE, g_nAudTrkRangeMax);
		}

	}

	return TRUE;
}


// returns the coordinates of where one of the icons should be drawn
BOOL CAudioLevel::GetIconArea(BOOL fSpeaker, RECT *pRect)
{
	int nIconY;
	int nLeftMic;
	int nLeftSpk;

	nIconY = (m_rect.bottom - m_rect.top - g_nAudIconHeight - 1) / 2;
	pRect->top = m_rect.top + nIconY;
	pRect->bottom = pRect->top + g_nAudIconHeight;

	if (fSpeaker)
	{
		pRect->left = m_rect.left + ((m_rect.right - m_rect.left) / 2) + g_nAudIconXMargin;
	}
	else
	{
		pRect->left = m_rect.left + g_nAudIconXMargin;
	}

	pRect->right = pRect->left + g_nAudIconWidth;

	return TRUE;
}

BOOL CAudioLevel::PaintIcons(HDC hdc)
{
	int nIconY;
	ASSERT(hdc);
	RECT rect;

	if (NULL != m_hIconMic)
	{
		GetIconArea(FALSE, &rect);

		DrawIconEx(	hdc, 
					rect.left,
					rect.top,
					m_hIconMic,
					rect.right - rect.left,
					rect.bottom - rect.top,
					0,
					NULL,
					DI_NORMAL);


	}

	if (NULL != m_hIconSpkr)
	{
		GetIconArea(TRUE, &rect);

		DrawIconEx(	hdc, 
					rect.left,
					rect.top,
					m_hIconSpkr,
					rect.right - rect.left,
					rect.bottom - rect.top,
					0,
					NULL,
					DI_NORMAL);

	}

	return TRUE;
}


BOOL CAudioLevel::OnDeviceStatusChanged(BOOL fSpeaker, UINT uEvent, UINT uSubCode)
{
	UINT uIconID;
	HICON *phIcon;
	UINT *puIconID;
	RECT rectInvalid;


	switch (uEvent)
	{
		case NM_STREAMEVENT_DEVICE_CLOSED:
		{
			uIconID = fSpeaker ? IDI_SPKEMPTY : IDI_MICEMPTY;
			break;
		}

		case NM_STREAMEVENT_DEVICE_OPENED:
		{
			uIconID = fSpeaker ? IDI_SPEAKER : IDI_MICFONE;
			break;
		}

		case NM_STREAMEVENT_DEVICE_FAILURE:
		{
			uIconID = fSpeaker ? IDI_SPKERROR : IDI_MICERROR;
			break;
		}
			
		default:
			return FALSE;
	}

	phIcon = fSpeaker ? &m_hIconSpkr : &m_hIconMic;
	puIconID = fSpeaker ? &m_uIconSpkrID : &m_uIconMicID;

	if (*puIconID == uIconID)
		return TRUE;

	*phIcon = (HICON) ::LoadImage(	::GetInstanceHandle(),
										MAKEINTRESOURCE(uIconID),
										IMAGE_ICON,
										g_nAudIconWidth,
										g_nAudIconHeight,
										LR_DEFAULTCOLOR | LR_SHARED);

	// invalidate the icon regions
	if (m_hwndParentParent)
	{
		RECT rect;
		GetIconArea(fSpeaker, &rect);
		::MapWindowPoints(m_hwndParent, m_hwndParentParent, (LPPOINT) &rect, 2);
		::InvalidateRect(m_hwndParentParent, &rect, TRUE /* erase bkgnd */);
		::UpdateWindow(m_hwndParentParent);
	}

	return TRUE;

}


BOOL CAudioLevel::Resize(int nLeft, int nTop, int nWidth, int nHeight)
{
	int nCBY, nTBY; // checkbox, trackbar, and Icon y positions

	// Disable redraws:
	ASSERT(m_hwndChkbRecMute && m_hwndChkbSpkMute && m_hwndMicTrack && m_hwndSpkTrack);

	if (m_fVisible)
	{
		::SendMessage(m_hwndChkbRecMute, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hwndChkbSpkMute, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hwndMicTrack, WM_SETREDRAW, FALSE, 0);
		::SendMessage(m_hwndSpkTrack, WM_SETREDRAW, FALSE, 0);
	}
	
	m_rect.left =	nLeft;
	m_rect.top =	nTop;
	m_rect.right =	nLeft + nWidth;
	m_rect.bottom =	nTop + nHeight;

	nCBY = (m_rect.bottom - m_rect.top - g_nAudChkbHeight) / 2;
	if (nCBY < 0)
		nCBY = 0;

	// "+1" so the trackbar is better centered with the checkbox and icon
	nTBY = 	(m_rect.bottom - m_rect.top - g_nAudTrkHeight + 1) / 2;
	if (nTBY < 0)
		nTBY = 0;

	int nHalfPoint = nLeft + (nWidth / 2);

	if (NULL != m_hwndChkbRecMute)
	{
		::MoveWindow(	m_hwndChkbRecMute,
						nLeft + g_nAudChkbXMargin,
						nTop + nCBY,
						g_nAudChkbWidth,
						g_nAudChkbHeight,
						TRUE /* repaint */);
	}

	
	if (NULL != m_hwndChkbSpkMute)
	{
		::MoveWindow(	m_hwndChkbSpkMute,
						nHalfPoint + g_nAudChkbXMargin,
						nTop + nCBY,
						g_nAudChkbWidth,
						g_nAudChkbHeight,
						TRUE /* repaint */);
	}

	m_fMicTrkVisible = m_fVisible;
	if (NULL != m_hwndMicTrack)
	{
		int nMicTrkWidth = nHalfPoint - g_nAudTrkRightGap - (nLeft + g_nAudTrkXMargin);
		::MoveWindow(	m_hwndMicTrack,
						nLeft + g_nAudTrkXMargin,
						nTop + nTBY,
						nMicTrkWidth,
						g_nAudTrkHeight,
						FALSE /* don't repaint */);
		m_fMicTrkVisible = (nMicTrkWidth > g_nAudTrkMinWidth);
	}

	
	m_fSpkTrkVisible = m_fVisible;
	if (NULL != m_hwndSpkTrack)
	{
		int nSpkTrkWidth = nLeft + nWidth - g_nAudTrkRightGap
							- (nHalfPoint + g_nAudTrkXMargin);
		::MoveWindow(	m_hwndSpkTrack,
						nHalfPoint + g_nAudTrkXMargin,
						nTop + nTBY,
						nSpkTrkWidth,
						g_nAudTrkHeight,
						FALSE /* don't repaint */);
		m_fSpkTrkVisible = (nSpkTrkWidth > g_nAudTrkMinWidth);
	}



	// enable redraws
	if (m_fVisible)
	{
		::SendMessage(m_hwndChkbRecMute, WM_SETREDRAW, TRUE, 0);
		::SendMessage(m_hwndChkbSpkMute, WM_SETREDRAW, TRUE, 0);
		// Enable redraws:
		if (m_fMicTrkVisible)
		{
			::SendMessage(m_hwndMicTrack, WM_SETREDRAW, TRUE, 0);
		}
		if (m_fSpkTrkVisible)
		{
			::SendMessage(m_hwndSpkTrack, WM_SETREDRAW, TRUE, 0);
		}	
		// Force the title area to repaint:
		::InvalidateRect(m_hwndChkbRecMute, NULL, TRUE /* erase bkgnd */);
		::InvalidateRect(m_hwndChkbSpkMute, NULL, TRUE /* erase bkgnd */);
		::InvalidateRect(m_hwndMicTrack, NULL, TRUE /* erase bkgnd */);
		::InvalidateRect(m_hwndSpkTrack, NULL, TRUE /* erase bkgnd */);

		ASSERT(m_hwndParent);
		ASSERT(m_hwndParentParent);


		RECT rctTemp = m_rect;
		::MapWindowPoints(m_hwndParent, m_hwndParentParent, (LPPOINT) &rctTemp, 2);
		::InvalidateRect(m_hwndParentParent, &rctTemp, TRUE /* erase bkgnd */);
		::UpdateWindow(m_hwndParentParent);
	}
	
	return TRUE;


}


BOOL CAudioLevel::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *plRet)
{
	LPNMCUSTOMDRAW pCustomDraw;
	BOOL bRet = FALSE, fSpeaker;
	RECT *pChannelRect;

	*plRet = 0;

	fSpeaker = (wParam == ID_AUDIODLG_SPKR_TRACK);

	if (fSpeaker)
	{
		pChannelRect = &m_rcChannelSpk;
	}
	else
	{
		pChannelRect = &m_rcChannelMic;
	}

	pCustomDraw = (LPNMCUSTOMDRAW)lParam;

	switch (pCustomDraw->dwDrawStage)
	{
		case CDDS_PREPAINT:
			bRet = TRUE;
			*plRet = CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
			break;

		case CDDS_ITEMPREPAINT:
			if (pCustomDraw->dwItemSpec == TBCD_CHANNEL)
			{
				*plRet = CDRF_SKIPDEFAULT;
				bRet  = TRUE;

				pCustomDraw->rc.top -= 2;
				pCustomDraw->rc.bottom += 2;

				*pChannelRect = pCustomDraw->rc;

				PaintChannel(fSpeaker, pCustomDraw->hdc);
			}
			break;


		default:
			break;

	}

	return bRet;


}


BOOL CAudioLevel::OnScroll(WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;

	if ((HWND) lParam == m_hwndMicTrack)
	{
		DWORD dwCurMicTrackPos = ::SendMessage((HWND) lParam, TBM_GETPOS, 0, 0);
		if (m_dwMicTrackPos != dwCurMicTrackPos)
		{
			m_dwMicTrackPos = dwCurMicTrackPos;
			m_pAudioControl->SetRecorderVolume(
				(m_dwMicTrackPos * 0xFFFF) / g_nAudTrkRangeMax);
		}

		bRet = TRUE;
	}
	else if ((HWND) lParam == m_hwndSpkTrack)
	{
		DWORD dwCurSpkTrackPos = ::SendMessage((HWND) lParam, TBM_GETPOS, 0, 0);
		if (m_dwSpkTrackPos != dwCurSpkTrackPos)
		{
			m_dwSpkTrackPos = dwCurSpkTrackPos;
			m_pAudioControl->SetSpeakerVolume(
				(m_dwSpkTrackPos * 0xFFFF) / g_nAudTrkRangeMax);
		}

		bRet = TRUE;
	}

	return bRet;
}

BOOL CAudioLevel::OnLevelChange(BOOL fSpeaker, DWORD dwVolume)
{
	if (fSpeaker)
	{
		if (NULL != m_hwndSpkTrack)
		{
			DWORD dwTrackPos = ScaleMixer(dwVolume);
			
			if (m_dwSpkTrackPos != dwTrackPos)
			{
				m_dwSpkTrackPos = dwTrackPos;
				TRACE_OUT(("Setting Spk Volume to %d", m_dwSpkTrackPos));
				::SendMessage(	m_hwndSpkTrack,
								TBM_SETPOS,
								TRUE,
								m_dwSpkTrackPos);
			}
		}
	}
	else
	{
		if (NULL != m_hwndMicTrack)
		{
			DWORD dwTrackPos = ScaleMixer(dwVolume);
			
			if (m_dwMicTrackPos != dwTrackPos)
			{
				m_dwMicTrackPos = dwTrackPos;
				TRACE_OUT(("Setting Mic Volume to %d", m_dwMicTrackPos));
				::SendMessage(	m_hwndMicTrack,
								TBM_SETPOS,
								TRUE,
								m_dwMicTrackPos);
			}
		}
	}

	return TRUE;
}

BOOL CAudioLevel::OnDeviceChanged(void)
{
	ASSERT(m_pAudioControl);

	EnableWindow(m_hwndMicTrack, m_pAudioControl->CanSetRecorderVolume());
	EnableWindow(m_hwndSpkTrack, m_pAudioControl->CanSetSpeakerVolume());
	return TRUE;
}



BOOL CAudioLevel::Show(BOOL fVisible)
{
    m_fVisible = fVisible;
	if (m_fVisible)
	{
		// Start mic sensitivity timer:
		::SetTimer(m_hwndParent, AUDIODLG_MIC_TIMER, AUDIODLG_MIC_TIMER_PERIOD, NULL);
	}
	else
	{
		// Stop mic sensitivity timer:
		::KillTimer(m_hwndParent, AUDIODLG_MIC_TIMER);
	}

    // Hide or show all windows:
	if (NULL != m_hwndChkbRecMute)
	{
		::ShowWindow(m_hwndChkbRecMute, fVisible ? SW_SHOW : SW_HIDE);
	}
	if (NULL != m_hwndChkbSpkMute)
	{
		::ShowWindow(m_hwndChkbSpkMute, fVisible ? SW_SHOW : SW_HIDE);
	}

	if (NULL != m_hwndMicTrack)
	{
		::ShowWindow(m_hwndMicTrack, (fVisible && m_fMicTrkVisible) ? SW_SHOW : SW_HIDE);
	}
	if (NULL != m_hwndSpkTrack)
	{
		::ShowWindow(m_hwndSpkTrack, (fVisible && m_fSpkTrkVisible) ? SW_SHOW : SW_HIDE);
	}


	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\autoconf.cpp ===
#include "precomp.h"
#include "resource.h"
#include "pfnwininet.h"
#include "pfnsetupapi.h"
#include "AutoConf.h"
#include "ConfUtil.h"

// File level globals
CAutoConf * g_pAutoConf = NULL;

void CAutoConf::DoIt( void )
{
	RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);
	if( !re.GetNumber(REGVAL_AUTOCONF_USE, DEFAULT_AUTOCONF_USE ) )
	{
		TRACE_OUT(( TEXT("AutoConf: Not using autoconfiguration")));
		return;
	}

	LPTSTR szAutoConfServer = re.GetString( REGVAL_AUTOCONF_CONFIGFILE );

	if( NULL == szAutoConfServer )
	{
		WARNING_OUT(( TEXT("AutoConf: AutoConf server is unset") ));
		DisplayErrMsg( IDS_AUTOCONF_SERVERNAME_MISSING );
		return;
	}

	g_pAutoConf = new CAutoConf( szAutoConfServer );
	ASSERT( g_pAutoConf );

	if( !g_pAutoConf->OpenConnection() )
	{
		WARNING_OUT(( TEXT("AutoConf: Connect to net failed") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}
	
	if( NULL == g_pAutoConf->m_hOpenUrl )
	{
		WARNING_OUT(( TEXT("AutoConf: g_pAutoConf->m_hOpenUrl = NULL") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}

	if( FALSE == g_pAutoConf->GetFile() )
	{
		WARNING_OUT(( TEXT("AutoConf: g_pAutoConf->GetFile() == FALSE") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}

	if( FALSE == g_pAutoConf->QueryData() )
	{
		WARNING_OUT(( TEXT("AutoConf: g_pAutoConf->QueryData() == FALSE") ));
		DisplayErrMsg( IDS_AUTOCONF_FAILED );
		goto cleanup;
	}

	if( FAILED( SETUPAPI::Init() ) )
	{
		WARNING_OUT(( TEXT("AutoConf: Setupapi's failed to init") ));
		DisplayErrMsg( IDS_AUTOCONF_NEED_SETUPAPIS );
		goto cleanup;
	}

	if( !g_pAutoConf->ParseFile() )
	{
		WARNING_OUT(( TEXT("AutoConf: Could not parse inf file") ));
		DisplayErrMsg( IDS_AUTOCONF_PARSE_ERROR );
		goto cleanup;
	}
	TRACE_OUT(( TEXT("AutoConf: FILE PARSED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!") ));
	
cleanup:
	delete g_pAutoConf;
	return;
}

CAutoConf::CAutoConf( LPTSTR szServer )
	: m_szServer( szServer ), m_hInternet( NULL ), m_hOpenUrl( NULL ), m_dwGrab( 0 ),
		m_hInf( NULL ), m_hFile( INVALID_HANDLE_VALUE ), m_hEvent( NULL )
{
	ZeroMemory( m_szFile, CCHMAX( m_szFile ) );
	m_hEvent = CreateEvent( NULL, TRUE, FALSE, TEXT( "NMAutoConf_WaitEvent" ) );
	RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER);
	m_dwTimeOut = re.GetNumber(REGVAL_AUTOCONF_TIMEOUT, DEFAULT_AUTOCONF_TIMEOUT );

}

CAutoConf::~CAutoConf() 
{
	CloseInternet();
	
	if( INVALID_HANDLE_VALUE != m_hFile )
	{
		CloseHandle( m_hFile );
	}
	
	DeleteFile( m_szFile );

	if( NULL != m_hInf )
	{
		SETUPAPI::SetupCloseInfFile( m_hInf );
	}

	//WININET::DeInit();
	//SETUPAPI::DeInit();
}

BOOL CAutoConf::OpenConnection()
{
//	ASSERT( phInternet );

	if( FAILED( WININET::Init() ) )
	{
		WARNING_OUT(( TEXT("AutoConf: WININET::Init failed") ));
		DisplayErrMsg( IDS_AUTOCONF_NO_WININET );
		return FALSE;
	}

	ASSERT( NULL != m_szServer );
	m_hInternet = WININET::InternetOpen( TEXT("NetMeeting"),
											INTERNET_OPEN_TYPE_DIRECT,
											NULL,
											NULL,
											INTERNET_FLAG_ASYNC  );
	if( NULL == m_hInternet )
	{
		WARNING_OUT(( TEXT( "AutoConf: InternetOpen failed" ) ));
		return FALSE;
	}

	if( INTERNET_INVALID_STATUS_CALLBACK ==
		WININET::InternetSetStatusCallback( m_hInternet,
			(INTERNET_STATUS_CALLBACK) CAutoConf::InetCallback ) )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetSetStatusCallback failed") ));
		return FALSE;
	}

	m_hOpenUrl = WININET::InternetOpenUrl( m_hInternet,
								m_szServer,
								NULL,
								0,
								INTERNET_FLAG_KEEP_CONNECTION |
								INTERNET_FLAG_RELOAD,
								AUTOCONF_CONTEXT_OPENURL );
	if( NULL == m_hOpenUrl && ERROR_IO_PENDING != GetLastError() )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetOpenUrl failed") ));
		return FALSE;
	}

	if( WAIT_FAILED == WaitForSingleObject( m_hEvent, m_dwTimeOut ) )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetOpenUrl wait for handle failed") ));
		return FALSE;
	}

	return TRUE;
}

BOOL CAutoConf::ParseFile()
{
	LPTSTR lstrInstallSection = TEXT("NetMtg.Install.NMRK");

	m_hInf = SETUPAPI::SetupOpenInfFile( m_szFile, // name of the INF to open
										NULL, // optional, the class of the INF file
										INF_STYLE_WIN4,  // specifies the style of the INF file
										NULL  // optional, receives error information
									); 

	if( INVALID_HANDLE_VALUE == m_hInf )
	{
		return false;
	}

	return SETUPAPI::SetupInstallFromInfSection(
							  NULL,            // optional, handle of a parent window
							  m_hInf,        // handle to the INF file
							  lstrInstallSection,    // name of the Install section
							  SPINST_REGISTRY ,            // which lines to install from section
							  NULL,  // optional, key for registry installs
							  NULL, // optional, path for source files
							  0,        // optional, specifies copy behavior
							  NULL,  // optional, specifies callback routine
							  NULL,         // optional, callback routine context
							  NULL,  // optional, device information set
							  NULL	 // optional, device info structure
									);
}


BOOL CAutoConf::GetFile()
{
//	ASSERT( INVALID_HANDLE_VALUE == m_hFile );

	TCHAR szPath[ MAX_PATH ];
	
	GetTempPath(  CCHMAX( szPath ),  // size, in characters, of the buffer
				  szPath       // pointer to buffer for temp. path
				);

	GetTempFileName(  szPath,  // pointer to directory name for temporary file
					  TEXT("NMA"),  // pointer to filename prefix
					  0,        // number used to create temporary filename
					  m_szFile    // pointer to buffer that receives the new filename
					);

	m_hFile = CreateFile( m_szFile,
						GENERIC_READ | GENERIC_WRITE,
						0,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_TEMPORARY /*| FILE_FLAG_DELETE_ON_CLOSE*/,
						NULL );

	if( INVALID_HANDLE_VALUE == m_hFile )
	{
		WARNING_OUT(( TEXT("AutoConf: AutoConfGetFile returned INVALID_HANDLE_VALUE") ));
		return FALSE;
	}

	return TRUE;
}

BOOL CAutoConf::QueryData()
{
 	ASSERT( NULL != m_hOpenUrl );

	m_dwGrab = 0;
	if (!WININET::InternetQueryDataAvailable( m_hOpenUrl,
											&m_dwGrab,
											0,
											0 ) )
	{
		if( ERROR_IO_PENDING != GetLastError() )
		{
			WARNING_OUT(( TEXT("AutoConf: InternetQueryDataAvailable failed") ));
			return FALSE;
		} 
		else if( WAIT_FAILED == WaitForSingleObject( m_hEvent, m_dwTimeOut ) )
		{
			WARNING_OUT(( TEXT("AutoConf: InternetQueryDataAvailable wait for data failed") ));
			return FALSE;
		} 
	}
	GrabData();

	return TRUE;
}

BOOL CAutoConf::GrabData()
{
	ASSERT( NULL != m_hOpenUrl );
	ASSERT( INVALID_HANDLE_VALUE != m_hFile );

	if( !m_dwGrab )
	{
		TRACE_OUT(( TEXT("AutoConf: Finished Reading File") ));
		CloseHandle( m_hFile );
		m_hFile = INVALID_HANDLE_VALUE;
		return TRUE;
	}

	DWORD dwRead;
	LPTSTR pInetBuffer = new TCHAR[ m_dwGrab + 1];
	ASSERT( pInetBuffer );

	if( !WININET::InternetReadFile( m_hOpenUrl,
						(void *)pInetBuffer,
						m_dwGrab,
						&dwRead ) )// && ERROR_IO_PENDING != GetLastError() )
	{
		WARNING_OUT(( TEXT("AutoConf: InternetReadFile Failed") ));
		delete [] pInetBuffer;
		return FALSE;
	}
	else
	{
		pInetBuffer[ dwRead ] = '\0';

		if( !WriteFile( m_hFile,
						pInetBuffer,
						dwRead,
						&m_dwGrab,
						NULL ) || dwRead != m_dwGrab )
		{
			WARNING_OUT(( TEXT("AutoConf: WriteFile Failed") ));
			delete [] pInetBuffer;
			return FALSE;
		}
	}

	delete [] pInetBuffer;

	QueryData();
	return TRUE;
}

void CAutoConf::CloseInternet()
{
	HINTERNETKILL( m_hInternet );
	HINTERNETKILL( m_hOpenUrl );
}

VOID CALLBACK CAutoConf::InetCallback( HINTERNET hInternet, DWORD dwContext, DWORD dwInternetStatus,
    LPVOID lpvStatusInformation, DWORD dwStatusInformationLength )
{
	if( g_pAutoConf != NULL )
	{
		switch( dwInternetStatus )
		{
			case INTERNET_STATUS_REQUEST_COMPLETE:
			{
				TRACE_OUT(( TEXT("AutoConf: AutoConfInetCallback::INTERNET_STATUS_REQUEST_COMPLETE") ));

				if( AUTOCONF_CONTEXT_OPENURL == dwContext && g_pAutoConf->m_hOpenUrl == NULL )
				{
					TRACE_OUT(( TEXT("AutoConf: InternetOpenUrl Finished") ));
					LPINTERNET_ASYNC_RESULT lpIAR = (LPINTERNET_ASYNC_RESULT)lpvStatusInformation;
#ifndef _WIN64
					g_pAutoConf->m_hOpenUrl = (HINTERNET)lpIAR->dwResult;
#endif

					SetEvent( g_pAutoConf->m_hEvent );
				}
				else 
				{
					LPINTERNET_ASYNC_RESULT lpIAR = (LPINTERNET_ASYNC_RESULT)lpvStatusInformation;
					TRACE_OUT(( TEXT("AutoConf: QueryData returned") ));
					
					g_pAutoConf->m_dwGrab = (DWORD)lpIAR->dwResult;
					SetEvent( g_pAutoConf->m_hEvent );
				}
				break;
			}
#ifdef DEBUG
			case INTERNET_STATUS_CLOSING_CONNECTION:
		//Closing the connection to the server. The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Closing connection\n") ) );
			break;

		case INTERNET_STATUS_CONNECTED_TO_SERVER: 
		//Successfully connected to the socket address (SOCKADDR) pointed to by lpvStatusInformation. 
			TRACE_OUT(( TEXT("Connected to server") ) );
			break;

		case INTERNET_STATUS_CONNECTING_TO_SERVER: 
	//Connecting to the socket address (SOCKADDR) pointed to by lpvStatusInformation. 
			TRACE_OUT(( TEXT("Connecting to server") ) );
			break;


		case INTERNET_STATUS_CONNECTION_CLOSED:
		//Successfully closed the connection to the server. 
		//The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Connection Closed") ) );
			break;

		case INTERNET_STATUS_HANDLE_CLOSING:
		//This handle value is now terminated.
			TRACE_OUT(( TEXT("Handle value terminated\n") ) );
			break;

		case INTERNET_STATUS_HANDLE_CREATED: 
		//Used by InternetConnect to indicate it has created the new handle. 
		//This lets the application call InternetCloseHandle from another thread,
		//if the connect is taking too long. 
			TRACE_OUT(( TEXT("Handle created\n") ) );
			break;

		case INTERNET_STATUS_NAME_RESOLVED:
		//Successfully found the IP address of the name contained in lpvStatusInformation. 
			TRACE_OUT(( TEXT("Resolved name of server") ) );
			break;

		case INTERNET_STATUS_RECEIVING_RESPONSE:
		//Waiting for the server to respond to a request. 
		//The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Recieving response\n") ) );
			break;

		case INTERNET_STATUS_REDIRECT:
		//An HTTP request is about to automatically redirect the request. 
		//The lpvStatusInformation parameter points to the new URL. 
		//At this point, the application can read any data returned by the server with the
		//redirect response, and can query the response headers. It can also cancel the operation
		//by closing the handle. This callback is not made if the original request specified
		//INTERNET_FLAG_NO_AUTO_REDIRECT. 
			TRACE_OUT(( TEXT("Redirected to new server") ) );
			break;

		case INTERNET_STATUS_REQUEST_SENT: 
		//Successfully sent the information request to the server.
		//The lpvStatusInformation parameter points to a DWORD containing the number of bytes sent. 
			TRACE_OUT(( TEXT("Sent %d bytes in request"), *((DWORD *)lpvStatusInformation) ) );
			break;

		case INTERNET_STATUS_RESOLVING_NAME: 
		//Looking up the IP address of the name contained in lpvStatusInformation. 
			TRACE_OUT(( TEXT("Resolving name") ) );
			break;

		case INTERNET_STATUS_RESPONSE_RECEIVED: 
		//Successfully received a response from the server. 
		//The lpvStatusInformation parameter points to a DWORD containing the number of bytes received. 
			TRACE_OUT(( TEXT("Recieved %d bytes in response\n"), *((DWORD *)lpvStatusInformation) ) );
			break;

		case INTERNET_STATUS_SENDING_REQUEST: 
		//Sending the information request to the server. 
		//The lpvStatusInformation parameter is NULL. 
			TRACE_OUT(( TEXT("Sending request") ) );
			break;
#endif // DEBUG

			default:
				break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calib.cpp ===
// File: calib.cpp

#include "precomp.h"
#include "resource.h"
#include "WaveDev.h"
#include "dstest.h"

#include "avdefs.h"
#include <mmsystem.h>
#include <mixer.h>
#include <mperror.h>
#include <iacapapi.h>
#include <sehcall.h>

// Local includes
#include "ConfCpl.h"
#include "conf.h"

// Defined in wizard.cpp
extern UINT_PTR GetPageBeforeAudioWiz();


// move somewhere else
#define MAXNUMPAGES_INCALIBWIZ		7
#define WAVEDEVICE_OPENFAILED		-1
#define MAXSTRINGSIZE				256
#define READFROM_REGISTRY			-1

#define AUDIOWIZ_WARNING			1
#define AUDIOWIZ_ERROR				2


#define CALIB_CHECK 				1
#define CALIB_PREPARE				2

#define CALIBERR_NO_MIXERS				1
#define CALIBERR_CANT_OPEN_WAVE_DEV 	2
#define CALIBERR_CANT_SET_VOLUME		3
#define CALIBERR_USER_CANCEL			4
#define CALIBERR_MIXER_ERROR			6
#define CALIBERR_NO_MICROPHONE			7
#define CALIBERR_DEVICE_ERROR			8


#define ATW_PLAYFILE_SOUND	TEXT("TestSnd.Wav")


#define CLIPPINGVOL 0x6000
#define DECREMENT_AMOUNT	0x800
#define DECREMENT_AMOUNT_LARGE	0x1200
#define SILENCE_THRESHOLD	0x800
// trackbar sets volume range from 0-65535, but only has 100 steps.
#define TB_VOL_INCREMENT	655
#define ATW_MSG_LENGTH	256

#define MIXER_VOLUME_MAX	0x0000ffff
#define MIXER_VOLUME_UNINITIALIZED	0xffffffff

#define WM_AUDIO_CLIPPING	(WM_USER+21)
#define WM_AUDIOTHREAD_STOP (WM_USER+22)
#define WM_AUDIOTHREAD_ERROR (WM_USER+23)
#define WM_AUDIOTHREAD_SOUND (WM_USER+24)

// vu meter
#define RECTANGLE_WIDTH	10
#define RECTANGLE_LEADING 1
#define MAX_VOLUME	32768
#define MAX_VOLUME_NORMALIZED	256

#define SHABS(x)	(((x) > 0) ? (x) : (WORD)(-(x)))

typedef struct _power_struct
{
	DWORD dwMin;
	DWORD dwMax;
	DWORD dwAvg;
	LONG lDcComponent;
} AUDIO_POWER;

#define SAMPLE_SIZE 2	// 16 bit samples

typedef struct _ERRWIZINFO{
	UINT			uType;
	UINT			uButtonOptions;
	UINT			uNextWizId;
	UINT			uBackWizId;
	UINT			uErrTitleId;
	UINT			uErrTextId;
}ERRWIZINFO, *PERRWIZINFO;


typedef struct _calib_wavein
{
	HWND hVUMeter;
	DWORD nErrorTextId;
	HWND hDlg;
	UINT uWaveInDevId;
	HANDLE hEvent;     // signal to parent after creating msg queue
} CALIB_DISPLAY, *PCALIBDISPLAY;


typedef struct _AUDIOWIZINFO{
	UINT		uFlags;
	UINT		uOptions;
	UINT		uWaveInDevId;
	UINT		uWaveOutDevId;
	BOOL		iSetAgc;
	UINT		uChanged;		//set in the wizard.
	UINT		uCalibratedVol;
	UINT		uSpeakerVol;
	UINT		uSoundCardCaps;
	UINT		uTypBandWidth;
	TCHAR		szWaveInDevName[MAXPNAMELEN];
	TCHAR		szWaveOutDevName[MAXPNAMELEN];
	MIXVOLUME	uPreCalibMainVol; // record volume
	MIXVOLUME	uPreCalibSubVol;  // microphone volume
	MIXVOLUME	uPreCalibSpkVol;  // speaker/wave volume
	UINT		uOldWaveInDevId;
	UINT		uOldWaveOutDevId;
	TCHAR		szOldWaveInDevName[MAXPNAMELEN];
	TCHAR		szOldWaveOutDevName[MAXPNAMELEN];
	ERRWIZINFO	ErrWizInfo;

	DWORD		dwWizButtons;
}AUDIOWIZINFO, *PAUDIOWIZINFO;



class WaveBufferList
{
	BYTE *m_aBytes;

	DWORD m_dwBuffers;
	DWORD m_dwSize;

public:
	WaveBufferList(DWORD dwBuffers, DWORD dwSize);
	~WaveBufferList();
	BYTE *GetBuffer(DWORD dwIndex);
};



WaveBufferList::WaveBufferList(DWORD dwBuffers, DWORD dwSize) :
m_aBytes(NULL),
m_dwBuffers(dwBuffers),
m_dwSize(dwSize)
{
	if ((m_dwBuffers > 0) && (m_dwSize > 0))
	{
		m_aBytes = new BYTE[m_dwBuffers*m_dwSize];
	}
}


BYTE *WaveBufferList::GetBuffer(DWORD dwIndex)
{
	if ((dwIndex < m_dwBuffers) && (m_aBytes))
	{
		return m_aBytes + dwIndex*m_dwSize;
	}

	return NULL;
}

WaveBufferList::~WaveBufferList()
{
	if (m_aBytes)
		delete [] m_aBytes;
}









//------------------------ Prototype Definitions -------------------------
BOOL GetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, LPUINT lpuNumPages);
void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages, PWIZCONFIG pWizConfig,
	PAUDIOWIZOUTPUT pAudioWizOut);
INT_PTR CallAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId,PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc);

static INT_PTR IntCreateAudioCalibWizard(HWND hwndOwner, UINT uOptions, UINT uDevId,
	PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc);

INT_PTR APIENTRY DetSoundCardWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz0( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz1( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz2( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz3( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibWiz4( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY AudioCalibErrWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

static void SaveAudioWizChanges(PAUDIOWIZINFO pawInfo);
static UINT GetSoundCardCaps(UINT uWaveInDevId,UINT uWaveOutDevId, HWND hwnd);
static UINT CheckForFullDuplex(UINT uWaveInDevId,UINT uWaveOutDevId);
static UINT CheckForAgc(UINT uWaveInDevId);
static UINT GetWaveDeviceFromWaveMapper(UINT uNumWaveDevId, UINT uInOrOut);
static UINT CheckForWaveDeviceSupport(UINT uWaveDevId, UINT uInOrOut);

static void ProcessCalibError(UINT uCalibErr, PAUDIOWIZINFO pawInfo);
static DWORD ComputePower(SHORT *wBuffer, DWORD dwNumSamples, AUDIO_POWER *pAudioPower);
static BOOL StartAGC(CMixerDevice *pMixer, BOOL iSetAgc, UINT uSoundCardCaps);
static void PaintVUMeter (HWND hwnd, DWORD dwVolume);

static DWORD CALLBACK CalibrateTalking(PVOID);
BOOL IntGetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig,
	LPUINT lpuNumPages, INT iSetAgc);

///////////////////////

static const BYTE g_VUTable[] = {
     0,     1,     2,     3,     4,     5,     6,     7,
     8,    23,    30,    35,    39,    43,    46,    49,
    52,    55,    57,    60,    62,    64,    66,    68,
    70,    72,    74,    76,    78,    80,    81,    83,
    85,    86,    88,    89,    91,    92,    94,    95,
    97,    98,    99,   101,   102,   103,   105,   106,
   107,   108,   110,   111,   112,   113,   114,   115,
   117,   118,   119,   120,   121,   122,   123,   124,
   125,   126,   127,   128,   129,   130,   132,   132,
   133,   134,   135,   136,   137,   138,   139,   140,
   141,   142,   143,   144,   145,   146,   147,   147,
   148,   149,   150,   151,   152,   153,   154,   154,
   155,   156,   157,   158,   159,   159,   160,   161,
   162,   163,   163,   164,   165,   166,   167,   167,
   168,   169,   170,   170,   171,   172,   173,   173,
   174,   175,   176,   176,   177,   178,   179,   179,
   180,   181,   181,   182,   183,   184,   184,   185,
   186,   186,   187,   188,   188,   189,   190,   190,
   191,   192,   192,   193,   194,   194,   195,   196,
   196,   197,   198,   198,   199,   200,   200,   201,
   202,   202,   203,   204,   204,   205,   205,   206,
   207,   207,   208,   209,   209,   210,   210,   211,
   212,   212,   213,   213,   214,   215,   215,   216,
   216,   217,   218,   218,   219,   219,   220,   221,
   221,   222,   222,   223,   223,   224,   225,   225,
   226,   226,   227,   227,   228,   229,   229,   230,
   230,   231,   231,   232,   232,   233,   234,   234,
   235,   235,   236,   236,   237,   237,   238,   238,
   239,   239,   240,   241,   241,   242,   242,   243,
   243,   244,   244,   245,   245,   246,   246,   247,
   247,   248,   248,   249,   249,   250,   250,   251,
   251,   252,   252,   253,   253,   254,   254,   255
};


//functions
BOOL GetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig, LPUINT lpuNumPages)
{
	return IntGetAudioWizardPages(uOptions, uDevId,
			plpPropSheetPages, plpWizConfig,
			lpuNumPages, READFROM_REGISTRY);
}

BOOL IntGetAudioWizardPages(UINT uOptions, UINT uDevId,
	LPPROPSHEETPAGE *plpPropSheetPages, PWIZCONFIG *plpWizConfig,
	LPUINT lpuNumPages, INT iSetAgc)
{
	LPPROPSHEETPAGE psp;
	UINT			uNumPages = 0;
	PWIZCONFIG		pWizConfig;
	PAUDIOWIZINFO	pawInfo;
	LPSTR			szTemp;
	RegEntry		re( AUDIO_KEY, HKEY_CURRENT_USER );

	*plpPropSheetPages = NULL;
	*plpWizConfig = NULL;

	psp = (LPPROPSHEETPAGE) LocalAlloc(LPTR, MAXNUMPAGES_INCALIBWIZ * sizeof(PROPSHEETPAGE));
	if (NULL == psp)
	  {
		return FALSE;
	  }

	pWizConfig = (PWIZCONFIG) LocalAlloc(LPTR, sizeof(AUDIOWIZINFO) + sizeof(WIZCONFIG));
	if (NULL == pWizConfig)
	  {
		LocalFree(psp);
		return FALSE;
	  }
	pWizConfig->fCancel = FALSE;
	pWizConfig->uFlags = HIWORD(uOptions);
	pWizConfig->dwCustomDataSize = sizeof(AUDIOWIZINFO);

	pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
	pawInfo->uOptions = LOWORD(uOptions);
	pawInfo->uWaveInDevId = uDevId;
	pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
	pawInfo->iSetAgc = iSetAgc;

	pawInfo->uOldWaveInDevId = re.GetNumber(REGVAL_WAVEINDEVICEID,WAVE_MAPPER);
	szTemp = re.GetString(REGVAL_WAVEINDEVICENAME);
	if (szTemp)
	  lstrcpy(pawInfo->szOldWaveInDevName, szTemp);
	
	pawInfo->uOldWaveOutDevId = re.GetNumber(REGVAL_WAVEOUTDEVICEID,WAVE_MAPPER);
	szTemp = re.GetString(REGVAL_WAVEOUTDEVICENAME);
	if (szTemp)
	  lstrcpy(pawInfo->szOldWaveOutDevName, szTemp);

	pawInfo->uCalibratedVol = re.GetNumber(REGVAL_LASTCALIBRATEDVOL, 0xFFFFFFFF);

	pawInfo->uPreCalibSpkVol.leftVolume = MIXER_VOLUME_UNINITIALIZED;  // playback
	pawInfo->uPreCalibSpkVol.rightVolume = MIXER_VOLUME_UNINITIALIZED;  // playback

	pawInfo->uPreCalibMainVol.leftVolume  = MIXER_VOLUME_UNINITIALIZED;  // recording
	pawInfo->uPreCalibMainVol.rightVolume = MIXER_VOLUME_UNINITIALIZED;  // recording

	pawInfo->uPreCalibSubVol.leftVolume  = MIXER_VOLUME_UNINITIALIZED;   // microphone
	pawInfo->uPreCalibSubVol.rightVolume = MIXER_VOLUME_UNINITIALIZED;   // microphone

	if (!waveInGetNumDevs() || !waveOutGetNumDevs())
	  pawInfo->uSoundCardCaps = SOUNDCARD_NONE;
	else
	  pawInfo->uSoundCardCaps = SOUNDCARD_PRESENT;
	
	FillInPropertyPage(&psp[uNumPages++], IDD_DETSOUNDCARDWIZ,
						DetSoundCardWiz,(LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ0,
						AudioCalibWiz0, (LPARAM)pWizConfig);
	if ((RUNDUE_CARDCHANGE == pawInfo->uOptions) ||
		(RUNDUE_NEVERBEFORE == pawInfo->uOptions) ||
		(RUNDUE_USERINVOKED == pawInfo->uOptions))
	  {
		FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ1,
							AudioCalibWiz1,(LPARAM)pWizConfig);
	  }
	else
	  {
		//the old wavein and wave out device will remain
		pawInfo->uWaveInDevId = pawInfo->uOldWaveInDevId;
		pawInfo->uWaveOutDevId = pawInfo->uOldWaveOutDevId;
		lstrcpy(pawInfo->szWaveInDevName,pawInfo->szOldWaveOutDevName);
		lstrcpy(pawInfo->szWaveOutDevName,pawInfo->szOldWaveOutDevName);
	  }
	
	// For each of the pages that I need, fill in a PROPSHEETPAGE structure.
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ2,
						AudioCalibWiz2, (LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ3,
						AudioCalibWiz3, (LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBWIZ4,
						AudioCalibWiz4, (LPARAM)pWizConfig);
	FillInPropertyPage(&psp[uNumPages++], IDD_AUDIOCALIBERRWIZ,
						AudioCalibErrWiz, (LPARAM)pWizConfig);
	
	// The number of pages in this wizard.
	*lpuNumPages = uNumPages;
	*plpPropSheetPages = (LPPROPSHEETPAGE) psp;
	*plpWizConfig = pWizConfig;
	return TRUE;
}


void ReleaseAudioWizardPages(LPPROPSHEETPAGE lpPropSheetPages,
	PWIZCONFIG pWizConfig, PAUDIOWIZOUTPUT pAudioWizOut)
{
	PAUDIOWIZINFO	pawInfo;

	pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

	if (pAudioWizOut)
	{
		pAudioWizOut->uValid = pawInfo->uChanged;//whatever is set in the wizard is valid
		pAudioWizOut->uSoundCardCaps = pawInfo->uSoundCardCaps;
		pAudioWizOut->uCalibratedVol = pawInfo->uCalibratedVol;
		pAudioWizOut->uTypBandWidth = pawInfo->uTypBandWidth;
		pAudioWizOut->uWaveInDevId = pawInfo->uWaveInDevId;
		pAudioWizOut->uWaveOutDevId = pawInfo->uWaveOutDevId;
		lstrcpy(pAudioWizOut->szWaveInDevName,pawInfo->szWaveInDevName);
		lstrcpy(pAudioWizOut->szWaveOutDevName,pawInfo->szWaveOutDevName);
			

		//the ui needs to read the changed values and call nac methods for
		//the changes below
		pAudioWizOut->uChanged = AUDIOWIZ_NOCHANGES;
		if ((pawInfo->uChanged & SOUNDCARD_CHANGED) &&
			((pawInfo->uWaveInDevId != pawInfo->uOldWaveInDevId) ||
			 (pawInfo->uWaveOutDevId != pawInfo->uOldWaveOutDevId) ||
			 lstrcmp(pawInfo->szWaveInDevName,pawInfo->szOldWaveInDevName) ||
			 lstrcmp(pawInfo->szWaveOutDevName,pawInfo->szOldWaveOutDevName)))
		{			
				pAudioWizOut->uChanged |= SOUNDCARD_CHANGED;
				pAudioWizOut->uChanged |= SOUNDCARDCAPS_CHANGED;
					
		}
	}

	LocalFree(pWizConfig);
	LocalFree(lpPropSheetPages);

}

INT_PTR CallAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId,PAUDIOWIZOUTPUT pAudioWizOut,INT iSetAgc)
{
	//agc values are provided
	return(IntCreateAudioCalibWizard(hwndOwner, uOptions, uDevId, pAudioWizOut, iSetAgc));

}		

VOID CmdAudioCalibWizard(HWND hwnd)
{
	AUDIOWIZOUTPUT awo;
	INT_PTR nRet = IntCreateAudioCalibWizard(
					hwnd,
					RUNDUE_USERINVOKED,
					WAVE_MAPPER,
					&awo,
					READFROM_REGISTRY);

	if ((nRet > 0) && (awo.uChanged & SOUNDCARD_CHANGED))
	{
		::HandleConfSettingsChange(CSETTING_L_AUDIODEVICE);
	}
}

INT_PTR IntCreateAudioCalibWizard(HWND hwndOwner, UINT uOptions,
	UINT uDevId, PAUDIOWIZOUTPUT pAudioWizOut, INT iSetAgc)
{	
	LPPROPSHEETPAGE ppsp;
	UINT			uNumPages;
	PWIZCONFIG		pWizConfig;

	if (!IntGetAudioWizardPages(uOptions, uDevId,
			&ppsp, &pWizConfig, &uNumPages, iSetAgc))
	{
		return -1;
	}

	PROPSHEETHEADER psh;
	InitStruct(&psh);

	// Specify that this is a wizard property sheet with no Apply Now button.
	psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
	psh.hwndParent = hwndOwner;

	// Use page captions.
	ASSERT(NULL == psh.pszCaption);
	ASSERT(0 == psh.nStartPage);
	
	psh.nPages = uNumPages;
	psh.ppsp = ppsp;
	
	// Create and run the wizard.
	INT_PTR iRet = PropertySheet(&psh);

	ReleaseAudioWizardPages(ppsp, pWizConfig, pAudioWizOut);

	return iRet;
}

void SaveAudioWizChanges(PAUDIOWIZINFO pawInfo)
{
	RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
	
	if (pawInfo->uChanged & SOUNDCARDCAPS_CHANGED)
	{
		re.SetValue ( REGVAL_SOUNDCARDCAPS, pawInfo->uSoundCardCaps);
		re.SetValue ( REGVAL_FULLDUPLEX, ISSOUNDCARDFULLDUPLEX(pawInfo->uSoundCardCaps) ? FULLDUPLEX_ENABLED : FULLDUPLEX_DISABLED);

		if (!ISDIRECTSOUNDAVAILABLE(pawInfo->uSoundCardCaps))
		{
			re.SetValue(REGVAL_DIRECTSOUND, (ULONG)DSOUND_USER_DISABLED);
		}
	}

	if (pawInfo->uChanged & CALIBVOL_CHANGED)
	{
		re.SetValue ( REGVAL_CALIBRATEDVOL, pawInfo->uCalibratedVol);
		re.SetValue ( REGVAL_LASTCALIBRATEDVOL, pawInfo->uCalibratedVol);
	}		
	if (pawInfo->uChanged & SOUNDCARD_CHANGED)
	{
		re.SetValue (REGVAL_WAVEINDEVICEID, pawInfo->uWaveInDevId);
		re.SetValue (REGVAL_WAVEINDEVICENAME, pawInfo->szWaveInDevName);
		re.SetValue (REGVAL_WAVEOUTDEVICEID, pawInfo->uWaveOutDevId);
		re.SetValue (REGVAL_WAVEOUTDEVICENAME, pawInfo->szWaveOutDevName);
	}	

	if (pawInfo->uChanged & SPEAKERVOL_CHANGED)
	{
		re.SetValue (REGVAL_SPEAKERVOL, pawInfo->uSpeakerVol);	
	}

}


INT_PTR APIENTRY DetSoundCardWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE				* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;

	switch (message) {
		case WM_INITDIALOG:
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			if (g_fSilentWizard)
			{
				HideWizard(GetParent(hDlg));
			}

			return (TRUE);

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					if (pawInfo->uSoundCardCaps != SOUNDCARD_NONE)
					{
						// Skip this page; go to IDD_AUDIOCALIBWIZ0;
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}						

					// Initialize the controls.
					DWORD dwWizButtons = PSWIZB_FINISH;
					if (pWizConfig->uFlags & STARTWITH_BACK)
						dwWizButtons |= PSWIZB_BACK;
					PropSheet_SetWizButtons(GetParent(hDlg), dwWizButtons );
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
					}
					break;
				}										

				case PSN_WIZNEXT:
					// Due to bug in ComCtl32 don't allow next
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
					return TRUE;

				case PSN_WIZBACK:
					// Due to bug in ComCtl32 check if button is enabled
					if (!(pWizConfig->uFlags & STARTWITH_BACK))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}
					else
					{	
						UINT_PTR iPrev = GetPageBeforeAudioWiz();
						ASSERT( iPrev );
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iPrev);
						return TRUE;
					}
					break;

				case PSN_WIZFINISH:
				{
					RegEntry re( AUDIO_KEY, HKEY_CURRENT_USER );
					re.SetValue ( REGVAL_SOUNDCARDCAPS, pawInfo->uSoundCardCaps);
					break;
				}

				case PSN_RESET:
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;
									
				default:
					break;													
			}
			break;

		default:
			return FALSE;			
	}
	return (FALSE);
}

INT_PTR APIENTRY AudioCalibWiz0( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE				* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;

	switch (message) {
		case WM_INITDIALOG:
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			return TRUE;

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					// Initialize the controls.
					DWORD dwWizButtons = PSWIZB_NEXT;
					if (pWizConfig->uFlags & STARTWITH_BACK)
						dwWizButtons |= PSWIZB_BACK;
					PropSheet_SetWizButtons(GetParent(hDlg), dwWizButtons );
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
					}
					break;
				}

				case PSN_WIZBACK:
					// Due to bug in ComCtl32 check if button is enabled
					if (!(pWizConfig->uFlags & STARTWITH_BACK))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}
					if (pawInfo->uSoundCardCaps != SOUNDCARD_NONE)
					{
							//  don't go to the DetSoundCard page...
						UINT_PTR iPrev = GetPageBeforeAudioWiz();
						ASSERT( iPrev );
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, iPrev);
						return TRUE;
					}
				
					break;

				case PSN_RESET:
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;
									
				default:
					break;													
			}
			break;

		default:
			return FALSE;			
	}
	return (FALSE);
}


INT_PTR APIENTRY AudioCalibWiz1( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;
	UINT						uSoundCardCaps;
	int 						nIndex;
	HWND						hwndCB;
	
	switch (message)
	{
		case WM_INITDIALOG:
		{
			WAVEINCAPS	wiCaps;
			WAVEOUTCAPS woCaps;
			LPSTR		lpszTemp;
			UINT		uWaveDevId;
			UINT		uWaveDevRealId;
			UINT		uDevCnt;
			UINT		uCnt;
			UINT		uDevID;
			
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

			//we come to this page only if a sound card is present.
			
			// If we end up with WAVE_MAPPER, this means that this is the first time we run this code
			pawInfo->uWaveInDevId = uWaveDevRealId = uWaveDevId = pawInfo->uOldWaveInDevId;
			uDevCnt = waveInGetNumDevs();
			lstrcpy(pawInfo->szWaveInDevName, lpszTemp = pawInfo->szOldWaveInDevName);

			//add the device to the drop down list
			hwndCB = GetDlgItem(hDlg, IDC_WAVEIN);
			for (uDevID = 0, uCnt = uDevCnt; 0 != uCnt; uDevID++, uCnt--)
			{
				if ((waveInGetDevCaps(uDevID, &wiCaps, sizeof(WAVEINCAPS)) == MMSYSERR_NOERROR) &&
					(CheckForWaveDeviceSupport(uDevID, 0)))
				{
					nIndex = ComboBox_AddString(hwndCB, wiCaps.szPname);
					ComboBox_SetItemData(hwndCB, nIndex, uDevID);

					//if a device hasnt been chosen previously, then set the default device to the
					//zeroth one
					if (uWaveDevId == WAVE_MAPPER)
					{
						if (uDevCnt <= 1)
							uWaveDevRealId = uDevID;
						else
							if ((uWaveDevRealId == WAVE_MAPPER) && (uDevCnt == uCnt))
								uWaveDevRealId = GetWaveDeviceFromWaveMapper(uCnt, 0);
						if (uDevID == uWaveDevRealId)
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveInDevId = uDevID;
							lstrcpy(pawInfo->szWaveInDevName, wiCaps.szPname);
						}
					}
					else
					{
						if ((0 == nIndex) || (!lstrcmp(wiCaps.szPname, lpszTemp)))
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveInDevId = uDevID;
							lstrcpy(pawInfo->szWaveInDevName, wiCaps.szPname);
						}
					}
				}
			}
			// TEMPORARY 1.0 stuff because this would require too much rewrite:
			// In case no device was added to the combo box, let's put the first one in
			// even though we know it will never work.
			if ((0 == ComboBox_GetCount(hwndCB)) || (uWaveDevRealId == WAVE_MAPPER))
			{
				waveInGetDevCaps(0,&wiCaps, sizeof(WAVEINCAPS));
				if (0 == ComboBox_GetCount(hwndCB))
				{
					ComboBox_AddString(hwndCB, wiCaps.szPname);
					ComboBox_SetItemData(hwndCB, 0, 0);
				}
				ComboBox_SetCurSel(hwndCB, 0);
				pawInfo->uWaveInDevId = 0;
				lstrcpy(pawInfo->szWaveInDevName, wiCaps.szPname);
			}

			// If we end up with WAVE_MAPPER, this means that this is the first time we run this code
			pawInfo->uWaveOutDevId = uWaveDevRealId = uWaveDevId = pawInfo->uOldWaveOutDevId;
			uDevCnt = waveOutGetNumDevs();
			lstrcpy(pawInfo->szWaveOutDevName, lpszTemp = pawInfo->szOldWaveOutDevName);

			//add the device to the drop down list
			hwndCB = GetDlgItem(hDlg, IDC_WAVEOUT);
			for (uDevID = 0, uCnt = uDevCnt; 0 != uCnt; uDevID++, uCnt--)
			{
				if	((waveOutGetDevCaps(uDevID, &woCaps, sizeof(WAVEOUTCAPS)) == MMSYSERR_NOERROR) &&
					(CheckForWaveDeviceSupport(uDevID, 1)))
				{
					nIndex = ComboBox_AddString(hwndCB, woCaps.szPname);
					ComboBox_SetItemData(hwndCB, nIndex, uDevID);

					//if a device hasnt been chosen previously, then set the default device to the
					//zeroth one
					if (uWaveDevId == WAVE_MAPPER)
					{
						if (uDevCnt <= 1)
							uWaveDevRealId = uDevID;
						else
							if ((uWaveDevRealId == WAVE_MAPPER) && (uDevCnt == uCnt))
								uWaveDevRealId = GetWaveDeviceFromWaveMapper(uCnt, 1);
						if (uDevID == uWaveDevRealId)
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveOutDevId = uDevID;
							lstrcpy(pawInfo->szWaveOutDevName, woCaps.szPname);
						}
					}
					else
					{
						if ((0 == nIndex) || (!lstrcmp(woCaps.szPname, lpszTemp)))
						{
							ComboBox_SetCurSel(hwndCB, nIndex);
							pawInfo->uWaveOutDevId = uDevID;
							lstrcpy(pawInfo->szWaveOutDevName, woCaps.szPname);
						}
					}					
				}
			}
			// TEMPORARY 1.0 stuff because this would require too much rewrite:
			// In case no device was added to the combo box, let's put the first one in
			// even though we know it will never work.
			if ((0 == ComboBox_GetCount(hwndCB)) || (uWaveDevRealId == WAVE_MAPPER))
			{
				waveOutGetDevCaps(0,&woCaps, sizeof(WAVEOUTCAPS));
				if (0 == ComboBox_GetCount(hwndCB))
				{
					ComboBox_AddString(hwndCB, (LPARAM)woCaps.szPname);
					ComboBox_SetItemData(hwndCB, 0, 0);
				}
				ComboBox_SetCurSel(hwndCB, 0);
				pawInfo->uWaveOutDevId = 0;
				lstrcpy(pawInfo->szWaveOutDevName, woCaps.szPname);
			}

			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
					// Initialize the controls.
					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						break;
					}
					else
					{
						if ((1 != ComboBox_GetCount(GetDlgItem(hDlg, IDC_WAVEIN))) ||
							(1 != ComboBox_GetCount(GetDlgItem(hDlg, IDC_WAVEOUT))))
						{
							break;
						}
						// else fall through to next
					}

				case PSN_WIZNEXT:
					// set settings in registry
					//check the device
					//get the new wavein device and its info
					hwndCB = GetDlgItem(hDlg, IDC_WAVEIN);
					nIndex = ComboBox_GetCurSel(hwndCB);
					pawInfo->uWaveInDevId = (UINT)ComboBox_GetItemData(hwndCB, nIndex);
					ComboBox_GetLBText(hwndCB, nIndex, pawInfo->szWaveInDevName);

					//get the new waveout device and its info
					hwndCB = GetDlgItem(hDlg, IDC_WAVEOUT);
					nIndex = ComboBox_GetCurSel(hwndCB);
					pawInfo->uWaveOutDevId = (UINT)ComboBox_GetItemData(hwndCB, nIndex);
					ComboBox_GetLBText(hwndCB, nIndex, pawInfo->szWaveOutDevName);

					uSoundCardCaps = GetSoundCardCaps(pawInfo->uWaveInDevId,pawInfo->uWaveOutDevId, hDlg);
					
					//save it in the wizinfo struct for writing to registry 					
					pawInfo->uSoundCardCaps = uSoundCardCaps;
					
					pawInfo->uChanged |= SOUNDCARDCAPS_CHANGED;
					pawInfo->uChanged |= SOUNDCARD_CHANGED;

					if (PSN_SETACTIVE == ((NMHDR FAR *) lParam)->code)
					{
						// Skip this page;
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}
					break;

				case PSN_RESET:
				{
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;
				}

				default:
					break;													
			}
			break;

		default:
			return FALSE;			
	}
	return (FALSE);
}

// The WaveOut test page
INT_PTR WINAPI AudioCalibWiz2(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static CMixerDevice *pMixer = NULL;
	static HWND hTrackBar;
	DWORD dwTBPos;
	MIXVOLUME dwNewVol;
	static MIXVOLUME dwVol;  // last set volume
	BOOL fRet;
	static BOOL fCanSetVolume = FALSE;
	static waveOutDev *pWaveOut= NULL;
	UINT uWaveOutDevId;
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;
	TCHAR szText[ATW_MSG_LENGTH];
	MMRESULT mmr;
	static fIsPlaying;
	
	switch (msg)
	{
		case (WM_INITDIALOG):
		{
			pMixer = NULL;
			hTrackBar = GetDlgItem(hDlg, IDC_ATW_SLIDER1);

			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

			break;
		}

		case (WM_NOTIFY):
		{
			switch (((NMHDR *)lParam)->code)
			{

				case PSN_SETACTIVE:
					fIsPlaying = FALSE;

					uWaveOutDevId = pawInfo->uWaveOutDevId;

					pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, uWaveOutDevId, MIXER_OBJECTF_WAVEOUT);
					if (pMixer)
					{
						SendMessage(hTrackBar, TBM_SETRANGE, TRUE, (LPARAM)MAKELONG(0, 100));
						SendMessage(hTrackBar, TBM_SETTICFREQ, 10, 0);
						SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, 20);
						SendMessage(hTrackBar, TBM_SETLINESIZE, 0, 10);

						pMixer->GetVolume(&dwVol);
						fCanSetVolume = pMixer->SetVolume(&dwVol);
						pMixer->UnMuteVolume();

						// preserve the speaker volume so that it can be restored
						// if the user presses cancel

						if (pawInfo->uPreCalibSpkVol.leftVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pawInfo->uPreCalibSpkVol.leftVolume = dwVol.leftVolume;
						}

						if (pawInfo->uPreCalibSpkVol.rightVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pawInfo->uPreCalibSpkVol.rightVolume = dwVol.rightVolume;
						}

					}
					else
						fCanSetVolume = FALSE;

					EnableWindow(GetDlgItem(hDlg, IDC_GROUP_VOLUME), fCanSetVolume);
					EnableWindow(GetDlgItem(hDlg, IDC_ATW_SLIDER1), fCanSetVolume);
					EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_ATW_TEST), TRUE);

					if (fCanSetVolume)
					{
						FLoadString(IDS_ATW_PLAYBACK, szText, CCHMAX(szText));
						SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(dwVol.leftVolume , dwVol.rightVolume)/TB_VOL_INCREMENT);
					}

					// if we can't get a mixer, then center the trackbar and disable
					else
					{
						FLoadString(IDS_ATW_PLAYBACK_NOMIX, szText, CCHMAX(szText));
						SendMessage(hTrackBar, TBM_SETPOS, TRUE, 50);
					}

					SetDlgItemText(hDlg, IDC_ATW_PLAYTEXT, szText);
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, TEXT(""));
					
					FLoadString(IDS_TESTBUTTON_TEXT, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szText);

					pWaveOut = new waveOutDev(uWaveOutDevId, hDlg);
					if (pWaveOut == NULL)
					{
						ERROR_OUT(("AudioWiz2: Unable to create waveOutDev object"));
					}

					PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_NEXT);

					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						return TRUE;
					}

					break;

				case PSN_WIZNEXT:
				case PSN_WIZBACK:
				case PSN_WIZFINISH:
				case PSN_KILLACTIVE:
					if ((fCanSetVolume) && (pMixer))
					{
						pMixer->GetVolume(&dwNewVol);
						pawInfo->uSpeakerVol = max(dwNewVol.leftVolume , dwNewVol.rightVolume);
						pawInfo->uChanged |= SPEAKERVOL_CHANGED;
					}

					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}

					if (pWaveOut)
					{
						delete pWaveOut;
						pWaveOut = NULL;
					}

					SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

				case PSN_RESET:
					// psn_reset get's received even if user presses
					// cancel on another dialog.

					// restore speaker volume to what it was before the tuning wizard was launched
					if (pawInfo->uPreCalibSpkVol.leftVolume <= MIXER_VOLUME_MAX || pawInfo->uPreCalibSpkVol.rightVolume <= MIXER_VOLUME_MAX)
					{
						if (pMixer == NULL)
						{
							pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, pawInfo->uWaveOutDevId, MIXER_OBJECTF_WAVEOUT);
						}
						if (pMixer)
						{
							pMixer->SetVolume(&pawInfo->uPreCalibSpkVol);
						}
					}

					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}

					if (pWaveOut)
					{
						delete pWaveOut;
						pWaveOut = NULL;
					}

					break;

				default:
					return FALSE;
			}
			return TRUE;
		}


		case (WM_HSCROLL):  // trackbar notification
		{
			dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
			if (pMixer)
			{
				pMixer->GetVolume(&dwVol);
				NewMixVolume(&dwNewVol, dwVol, (dwTBPos * TB_VOL_INCREMENT));				
				pMixer->SetVolume(&dwNewVol);
			}
			break;
		}


		// mixer notifications
		case MM_MIXM_CONTROL_CHANGE:
		case MM_MIXM_LINE_CHANGE:
		{
			if (pMixer)
			{

				fRet = pMixer->GetVolume(&dwNewVol);

				if ((fRet) && (dwNewVol.leftVolume != dwVol.leftVolume || dwNewVol.rightVolume != dwVol.rightVolume))
				{
					dwVol = dwNewVol;
					SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(dwVol.leftVolume , dwVol.rightVolume)/TB_VOL_INCREMENT);
					break;
				}
			}
			break;
		}

		// when the PlayFile is done playing
		case WOM_DONE:
		{
			if ((pWaveOut) && (fIsPlaying))
			{
				pWaveOut->PlayFile(ATW_PLAYFILE_SOUND);
			}

			break;
		}


		case WM_COMMAND:
		{
			// if the device fails to open, then we
			// display the error text

			// if the WAV file fails to load, we simply disable the button

			if (LOWORD(wParam) == IDC_BUTTON_ATW_TEST)
			{

				if (fIsPlaying == TRUE)
				{
					fIsPlaying = FALSE;
					pWaveOut->Close();
					FLoadString(IDS_TESTBUTTON_TEXT, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szText);
					break;
				}

				mmr = pWaveOut->PlayFile(ATW_PLAYFILE_SOUND);

				if (mmr == MMSYSERR_ALLOCATED )
				{
					FLoadString(IDS_PLAYBACK_ERROR, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, szText);
				}

				else if (mmr != MMSYSERR_NOERROR)
				{
					EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_ATW_TEST), FALSE);
					FLoadString(IDS_PLAYBACK_ERROR2, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, szText);
				}

				else // mmr == MMSYSERR_NOERROR
				{
					SetDlgItemText(hDlg, IDC_ATW_PLAYBACK_ERROR, TEXT(""));
					FLoadString(IDS_STOPBUTTON_TEXT, szText, CCHMAX(szText));
					SetDlgItemText(hDlg, IDC_BUTTON_ATW_TEST, szText);
					fIsPlaying = TRUE;
				}

			}
			break;
		}

		default:
			return FALSE;
	}

	return TRUE;
}



// Microphone test page
INT_PTR WINAPI AudioCalibWiz3(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	static HANDLE hThread = NULL;
	static DWORD dwThreadID = 0;
	static HANDLE hEvent = NULL;
	static CMixerDevice *pMixer = NULL;
	static HWND hTrackBar;
	static DWORD dwMainVol;
	static DWORD dwSubVol;
	DWORD dwTBPos, dwNewMainVol, dwNewSubVol;
	MIXVOLUME dwVol, dwNewVol;
	BOOL fRet;
	static BOOL fCanSetVolume=FALSE;
	static CALIB_DISPLAY CalibDisplay;
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;
	static BOOL fSoundDetected;
	const TCHAR *szEventName = _TEXT("CONF.EXE ATW Event Handle");

	switch (msg)
	{
		case (WM_INITDIALOG):
		{
			hThread = NULL;
			dwThreadID = NULL;
			hTrackBar = GetDlgItem(hDlg, IDC_ATW_SLIDER2);

			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;

			break;
		}

		case (WM_NOTIFY):
		{
			switch (((NMHDR *)lParam)->code)
			{

				case PSN_SETACTIVE:
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						return TRUE;
					}

					fCanSetVolume = TRUE;
					fSoundDetected = FALSE;

					pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, pawInfo->uWaveInDevId, MIXER_OBJECTF_WAVEIN);
					if (pMixer)
					{
						SendMessage(hTrackBar, TBM_SETRANGE, TRUE, (LPARAM)MAKELONG(0, 100));
						SendMessage(hTrackBar, TBM_SETTICFREQ, 10, 0);
						SendMessage(hTrackBar, TBM_SETPAGESIZE, 0, 20);
						SendMessage(hTrackBar, TBM_SETLINESIZE, 0, 10);

						// remember the volume in case the user presses cancel
						if (pawInfo->uPreCalibMainVol.leftVolume == MIXER_VOLUME_UNINITIALIZED ||
							pawInfo->uPreCalibMainVol.rightVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pMixer->GetMainVolume(&(pawInfo->uPreCalibMainVol));
						}
						if (pawInfo->uPreCalibSubVol.leftVolume == MIXER_VOLUME_UNINITIALIZED ||
							pawInfo->uPreCalibSubVol.rightVolume == MIXER_VOLUME_UNINITIALIZED)
						{
							pMixer->GetSubVolume(&(pawInfo->uPreCalibSubVol));
						}

						MIXVOLUME mixVol = {-1, -1};
						pMixer->GetVolume(&mixVol);
						fCanSetVolume = pMixer->SetVolume(&mixVol);
						dwSubVol = dwMainVol= 0xffff;
						SendMessage(hTrackBar, TBM_SETPOS, TRUE, dwMainVol/TB_VOL_INCREMENT);
						pMixer->EnableMicrophone();
						pMixer->UnMuteVolume();

						StartAGC(pMixer, pawInfo->iSetAgc, pawInfo->uSoundCardCaps);
					}

					// no mixer!
					if (pMixer == NULL)
					{
						ProcessCalibError(CALIBERR_MIXER_ERROR, pawInfo);
					}

					// no microphone!
					else if (fCanSetVolume == FALSE)
					{
						delete pMixer;
						pMixer = NULL;
						ProcessCalibError(CALIBERR_CANT_SET_VOLUME, pawInfo);
					}

					// process error
					if ((pMixer == NULL) || (fCanSetVolume == FALSE))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, IDD_AUDIOCALIBERRWIZ);
						return TRUE;
					}

					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK|PSWIZB_NEXT);
					CalibDisplay.hDlg = hDlg;
					CalibDisplay.hVUMeter = GetDlgItem(hDlg, IDC_VUMETER);
					CalibDisplay.uWaveInDevId = pawInfo->uWaveInDevId;

					ASSERT(hEvent == NULL);

					// just create the same event twice (easier than using DuplicateHandle)
					hEvent = CreateEvent(NULL, FALSE, FALSE, szEventName);
					CalibDisplay.hEvent = CreateEvent(NULL, FALSE, FALSE, szEventName);

					ASSERT(hThread == NULL);
					hThread = NULL;

					if (hEvent && (CalibDisplay.hEvent))
					{
						hThread = CreateThread(NULL, 0, CalibrateTalking, (LPVOID)(&CalibDisplay), 0, &dwThreadID);
					}

#ifdef DEBUG
					if ((hEvent == NULL) || (CalibDisplay.hEvent == NULL))
					{
						ERROR_OUT(("ATW:  Unable to create events for thread control!\r\n"));
					}
					else if (hThread == NULL)
					{
						ERROR_OUT(("ATW:  Unable to create thread for recording loop!\r\n"));
					}
#endif

					break;

				case PSN_WIZNEXT:
				case PSN_WIZBACK:
				case PSN_WIZFINISH:
				case PSN_KILLACTIVE:
					if (hThread)
					{
						SetEvent(hEvent); // signal the thread to exit, thread will CloseHandle(hEvent)

						// wait for the thread to exit, but
						// but keep processing window messages
						AtlWaitWithMessageLoop(hThread);

						CloseHandle(hEvent);
						CloseHandle(hThread);
						hThread = NULL;
						hEvent = NULL;
						dwThreadID = 0;
					}

					
					// silent wizard get's set to max
					if (g_fSilentWizard)
					{
						pawInfo->uChanged |= CALIBVOL_CHANGED;
						pawInfo->uChanged = 0xffff;
					}
					
					else if ((fCanSetVolume) && (pMixer))
					{
						pawInfo->uChanged |= CALIBVOL_CHANGED;
						pMixer->GetVolume(&dwVol);
						pawInfo->uCalibratedVol = max (dwVol.leftVolume , dwVol.rightVolume);
					}

					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}

					// if we never got an indication back from the sound thread
					// then the next page to be displayed is the "microphone" error page
					// note the check for the silent wizard
					if ((!g_fSilentWizard) && (fSoundDetected == FALSE) && (((NMHDR *)lParam)->code == PSN_WIZNEXT))
					{
						ProcessCalibError(CALIBERR_NO_MICROPHONE, pawInfo);
						SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, IDD_AUDIOCALIBERRWIZ);
					}

					else
						SetWindowLongPtr(hDlg,	DWLP_MSGRESULT, FALSE);
					break;

				case PSN_RESET:
					// psn_reset get's received even if user presses
					// cancel on another dialog.
					if (hThread)
					{
						SetEvent(hEvent);  // signal thread to exit

						AtlWaitWithMessageLoop(hThread);

						CloseHandle(hEvent);
						hEvent = NULL;
						CloseHandle(hThread);
						hThread = NULL;
						dwThreadID = 0;
					}


					// restore recording/microphone volume to what it was before the tuning wizard was launched
					if ( (pawInfo->uPreCalibMainVol.leftVolume <= MIXER_VOLUME_MAX && pawInfo->uPreCalibMainVol.rightVolume <= MIXER_VOLUME_MAX) ||
						 (pawInfo->uPreCalibSubVol.leftVolume <= MIXER_VOLUME_MAX && pawInfo->uPreCalibSubVol.rightVolume <= MIXER_VOLUME_MAX))
					{
						if (pMixer == NULL)
						{
							pMixer = CMixerDevice::GetMixerForWaveDevice(hDlg, pawInfo->uWaveInDevId, MIXER_OBJECTF_WAVEIN);
						}
						if (pMixer)
						{
							if (pawInfo->uPreCalibMainVol.leftVolume < MIXER_VOLUME_MAX || pawInfo->uPreCalibMainVol.rightVolume < MIXER_VOLUME_MAX)
							{
								pMixer->SetMainVolume(&pawInfo->uPreCalibMainVol);
							}
							
							if (pawInfo->uPreCalibSubVol.leftVolume < MIXER_VOLUME_MAX || pawInfo->uPreCalibSubVol.rightVolume < MIXER_VOLUME_MAX)
							{
								pMixer->SetSubVolume(&pawInfo->uPreCalibSubVol);
							}
						}
					}


					if (pMixer)
					{
						delete pMixer;
						pMixer = NULL;
					}
					break;

				default:
					return FALSE;
			}
			return TRUE;
		}

		case (WM_HSCROLL):  // trackbar notification
		{

			dwTBPos = (DWORD)SendMessage(hTrackBar, TBM_GETPOS, 0, 0);
			if (pMixer)
			{
				pMixer->GetVolume(&dwVol);
				NewMixVolume(&dwNewVol, dwVol, (dwTBPos * TB_VOL_INCREMENT));				
				pMixer->SetVolume(&dwNewVol);
				
			}
			break;
		}

		// notifications from the mixer
		case MM_MIXM_CONTROL_CHANGE:
		case MM_MIXM_LINE_CHANGE:
		{
			if (pMixer)
			{
				fRet = pMixer->GetMainVolume(&dwVol);
				if ((fRet) && (dwVol.leftVolume != dwMainVol || dwVol.rightVolume != dwMainVol))
				{
					pMixer->SetSubVolume(&dwVol);
					SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(dwVol.leftVolume , dwVol.rightVolume)/TB_VOL_INCREMENT);
					break;
				}

				MIXVOLUME subvol;
				fRet = pMixer->GetSubVolume(&subvol);
				if ((fRet) && (dwVol.leftVolume != subvol.leftVolume || dwVol.rightVolume !=subvol.rightVolume))
				{
					pMixer->SetMainVolume(&subvol);
					SendMessage(hTrackBar, TBM_SETPOS, TRUE, max(subvol.leftVolume , subvol.rightVolume)/TB_VOL_INCREMENT);
					break;
				}
			}
			break;
		}

		// calibration thread sends this message to indicate that the
		// volume is too loud
		case WM_AUDIO_CLIPPING:
		{
			if (pMixer)
			{
				pMixer->GetVolume(&dwVol);
				if (dwVol.leftVolume > DECREMENT_AMOUNT || dwVol.rightVolume > DECREMENT_AMOUNT)
				{
					dwVol.leftVolume -=DECREMENT_AMOUNT;
					dwVol.rightVolume -=DECREMENT_AMOUNT;
					
					pMixer->SetVolume(&dwVol);

					// fix for Videum driver
					// check to see if the volume actually got lowered
					// if it didn't, try a larger decrement
					pMixer->GetVolume(&dwNewVol);
					if ((dwNewVol.leftVolume == dwVol.leftVolume) && (dwVol.leftVolume >= DECREMENT_AMOUNT_LARGE) ||
						(dwNewVol.rightVolume == dwVol.rightVolume) && (dwVol.rightVolume >= DECREMENT_AMOUNT_LARGE))
					{
						dwVol.leftVolume -=DECREMENT_AMOUNT_LARGE;
						dwVol.rightVolume -=DECREMENT_AMOUNT_LARGE;
					
						pMixer->SetVolume(&dwVol);
					}
				}
			}
			break;
		}

		// the recording thread is signaling back to us that there is
		// a severe error.  Assume the thread has exited
		case WM_AUDIOTHREAD_ERROR:
		{
			ProcessCalibError(CALIBERR_DEVICE_ERROR, pawInfo);
			PropSheet_SetCurSelByID(GetParent(hDlg), IDD_AUDIOCALIBERRWIZ);
			break;
		}

		// The recording thread will send this message back to us
		// at least once to indicate that the silence threshold was
		// broken.  Thus, the microphone is functional.
		case WM_AUDIOTHREAD_SOUND:
		{
			fSoundDetected = TRUE;
			break;
		}

		default:
			return FALSE;
	}

	return TRUE;
}




INT_PTR APIENTRY AudioCalibWiz4( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE		* ps;
	static PWIZCONFIG			pWizConfig;
	static PAUDIOWIZINFO		pawInfo;

	switch (message) {
		case WM_INITDIALOG:
		{

			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			return (TRUE);
		}			

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
				{
					// Initialize the controls.
					PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
					if (g_fSilentWizard)
					{
						PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
					}
					break;
				}

				case PSN_WIZNEXT:
					// Due to bug in ComCtl32 don't allow next
					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
					return TRUE;

				case PSN_WIZFINISH:
					SaveAudioWizChanges(pawInfo);
					break;
			}
			break;

	}
	return (FALSE);
}

INT_PTR APIENTRY AudioCalibErrWiz( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	PROPSHEETPAGE				* ps;
	PWIZCONFIG					pWizConfig;
	static	PAUDIOWIZINFO		pawInfo;
	TCHAR	szTemp[MAXSTRINGSIZE];
	LPTSTR pszIcon;


	//WORD	wCmdId;
	
	switch (message) {
		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			pWizConfig = (PWIZCONFIG)ps->lParam;
			pawInfo = (PAUDIOWIZINFO)pWizConfig->pCustomData;
			return (TRUE);
		}
		
		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {
				case PSN_SETACTIVE:
					// initialize the controls.

					// Show the error or warning icon
					pszIcon = (((pawInfo->ErrWizInfo).uType == AUDIOWIZ_WARNING) ?
								IDI_ASTERISK : IDI_EXCLAMATION);

					// Set the wizard bitmap to the static control
					::SendDlgItemMessage(	hDlg,
									IDC_ERRWIZICON,
									STM_SETIMAGE,
									IMAGE_ICON,
									(LPARAM) ::LoadIcon(NULL, pszIcon));

					//set the error title
					if ((pawInfo->ErrWizInfo).uErrTitleId)
					{
						LoadString(GetInstanceHandle(),(pawInfo->ErrWizInfo).uErrTitleId,
							szTemp, MAXSTRINGSIZE);
						SetDlgItemText(hDlg, IDC_ERRTITLE, szTemp);
					}

					if ((pawInfo->ErrWizInfo).uErrTextId)
					{
						//show the error text
						LoadString(GetInstanceHandle(),(pawInfo->ErrWizInfo).uErrTextId,
							szTemp, MAXSTRINGSIZE);
						SetDlgItemText(hDlg, IDC_ERRTEXT, szTemp);
					}

					PropSheet_SetWizButtons(GetParent(hDlg),
						(pawInfo->ErrWizInfo).uButtonOptions );

					if (g_fSilentWizard)
					{
						// Due to bug in ComCtl32 check if button is enabled
						if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_FINISH))
						{
							PropSheet_PressButton(GetParent(hDlg), PSBTN_FINISH);
						}
						else
						{
							PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
						}
					}
					break;

				case PSN_WIZNEXT:
					// Due to bug in ComCtl32 check if button is enabled
					if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_NEXT))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}

					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (pawInfo->ErrWizInfo).uNextWizId);
					return TRUE;

				case PSN_RESET:
					pawInfo->uChanged = AUDIOWIZ_NOCHANGES;
					break;

				case PSN_WIZFINISH:
					// Due to bug in ComCtl32 check if button is enabled
					if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_FINISH))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}

					SaveAudioWizChanges(pawInfo);
					break;
					
				case PSN_WIZBACK:
					// Due to bug in ComCtl32 check if button is enabled
					if (!((pawInfo->ErrWizInfo).uButtonOptions & PSWIZB_BACK))
					{
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
						return TRUE;
					}

					SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (pawInfo->ErrWizInfo).uBackWizId);
					return TRUE;
			}
			break;
	}
	return (FALSE);
}

void ProcessCalibError(UINT uCalibErr, PAUDIOWIZINFO pawInfo)
{
	switch (uCalibErr)
	{
	case CALIBERR_CANT_SET_VOLUME:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_WARNING;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_NORECVOLCNTRL;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ2;
		break;

	case CALIBERR_NO_MIXERS:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_AUDIO_ERROR;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ1;
		break;

	case CALIBERR_MIXER_ERROR:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_AUDIO_ERROR;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ2;
		break;

	case CALIBERR_CANT_OPEN_WAVE_DEV:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_CANTOPENWAVE;
		pawInfo->ErrWizInfo.uErrTextId = IDS_QUITPROGRAM;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_NEXT|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = IDD_AUDIOCALIBWIZ3;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ1;
		break;

	case CALIBERR_NO_MICROPHONE:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_WARNING;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_NO_MICROPHONE;
		pawInfo->ErrWizInfo.uErrTextId = IDS_NO_MICWARNING;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_NEXT|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = IDD_AUDIOCALIBWIZ4;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ3;
		break;

	default:
	case CALIBERR_DEVICE_ERROR:
		pawInfo->ErrWizInfo.uType = AUDIOWIZ_ERROR;
		pawInfo->ErrWizInfo.uErrTitleId = IDS_UNSUPPORTEDCARD;
		pawInfo->ErrWizInfo.uErrTextId = IDS_AUDIO_ERROR;
		pawInfo->ErrWizInfo.uButtonOptions = PSWIZB_FINISH|PSWIZB_BACK;
		pawInfo->ErrWizInfo.uNextWizId = 0;
		pawInfo->ErrWizInfo.uBackWizId = IDD_AUDIOCALIBWIZ2;
		break;
	}
}

UINT GetSoundCardCaps(UINT uWaveInDevId, UINT uWaveOutDevId, HWND hwnd)
{
	UINT	uSoundCardCaps;
	UINT	uRet;
	bool bFD = false;
	UINT uDSCheck;

	
	uSoundCardCaps = SOUNDCARD_PRESENT;

	if ((uRet = CheckForFullDuplex(uWaveInDevId,uWaveOutDevId)) == SOUNDCARD_NONE)
	{
		//failed to open wave device
		//SS:Error message ??
		//all applications using the wave device should be closed
		
	}
	else if (uRet == SOUNDCARD_FULLDUPLEX)
	{
		uSoundCardCaps = uSoundCardCaps | SOUNDCARD_FULLDUPLEX;
		bFD = true;
	}
	if ((uRet = CheckForAgc(uWaveInDevId)) == SOUNDCARD_NONE)
	{
		//mixer initialization failed
		//SS: Error message
	}
	else if (uRet == SOUNDCARD_HAVEAGC)
		uSoundCardCaps = uSoundCardCaps | SOUNDCARD_HAVEAGC;


	uDSCheck = DirectSoundCheck(uWaveInDevId, uWaveOutDevId, hwnd);
	if (uDSCheck & DS_FULLDUPLEX)
	{
		uSoundCardCaps = uSoundCardCaps | SOUNDCARD_DIRECTSOUND;
	}

	return(uSoundCardCaps);
}

UINT CheckForFullDuplex(UINT uWaveInDevId,UINT uWaveOutDevId)
{
	HWAVEIN 		hWaveIn=NULL;
	HWAVEOUT		hWaveOut=NULL;
	MMRESULT		mmr;
	UINT			uRet = SOUNDCARD_NONE;

	waveInDev waveIn(uWaveInDevId);
	waveOutDev waveOut(uWaveOutDevId);


	mmr = waveOut.Open();
	if (mmr != MMSYSERR_NOERROR)
	{
		return SOUNDCARD_NONE;
	}

	mmr = waveIn.Open();
	if (mmr != MMSYSERR_NOERROR)
	{
		return SOUNDCARD_PRESENT;
	}

	return SOUNDCARD_FULLDUPLEX;

	// object destructors will close devices
}

UINT GetWaveDeviceFromWaveMapper(UINT uNumWaveDevId, UINT uInOrOut)
{
	HWAVE			hWave=NULL;
	HWAVE			hWaveMapper=NULL;
	WAVEFORMATEX	WaveFormatEx;
	MMRESULT		mmr;
	UINT			uDeviceId = (UINT)-1;
	UINT			i;
	
	WaveFormatEx.wFormatTag = WAVE_FORMAT_PCM;
	WaveFormatEx.nChannels =  1;
	WaveFormatEx.nSamplesPerSec = 8000;
	WaveFormatEx.nAvgBytesPerSec = 8000*SAMPLE_SIZE;
	WaveFormatEx.nBlockAlign = SAMPLE_SIZE;
	WaveFormatEx.wBitsPerSample = SAMPLE_SIZE*8;
	WaveFormatEx.cbSize = 0;

	if (!uInOrOut)
	{
#if 0
		// First, make sure that none of the devices are already open
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveInOpen ((HWAVEIN *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				goto MyExit;
			else
				if (mmr == WAVERR_BADFORMAT)
				{
					// This is probably an 8 bit board. Try again using 8 bit format
					WaveFormatEx.nAvgBytesPerSec = 8000;
					WaveFormatEx.nBlockAlign = 1;
					WaveFormatEx.wBitsPerSample = 8;
					if ((mmr = waveInOpen ((HWAVEIN *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
						goto MyExit;
				}
			if (hWave)
			{
				waveInClose((HWAVEIN)hWave);
				hWave = (HWAVE)NULL;
			}
		}

		WaveFormatEx.nAvgBytesPerSec = 8000*SAMPLE_SIZE;
		WaveFormatEx.nBlockAlign = SAMPLE_SIZE;
		WaveFormatEx.wBitsPerSample = SAMPLE_SIZE*8;
#endif
		// Open the wave in device using wave mapper
		if (mmr = waveInOpen ((HWAVEIN *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
			{
			if (mmr == WAVERR_BADFORMAT)
			{
				// This is probably an 8 bit board. Try again using 8 bit format
				WaveFormatEx.nAvgBytesPerSec = 8000;
				WaveFormatEx.nBlockAlign = 1;
				WaveFormatEx.wBitsPerSample = 8;
				if (mmr = waveInOpen ((HWAVEIN *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
					goto MyExit;
			}
			else
				goto MyExit;
			}

		// Now, look for the wave device that is already open
		// that's the one wave mapper picked up
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveInOpen ((HWAVEIN *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				{
				uDeviceId = i;
				goto MyExit;
				}
			else
				if (hWave)
				{
					waveInClose((HWAVEIN)hWave);
					hWave = (HWAVE)NULL;
				}
		}
	}
	else
	{
#if 0
		// First, make sure that none of the devices are already open
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveOutOpen ((HWAVEOUT *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				goto MyExit;
			else
				if (mmr == WAVERR_BADFORMAT)
				{
					// This is probably an 8 bit board. Try again using 8 bit format
					WaveFormatEx.nAvgBytesPerSec = 8000;
					WaveFormatEx.nBlockAlign = 1;
					WaveFormatEx.wBitsPerSample = 8;
					if ((mmr = waveOutOpen ((HWAVEOUT *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
						goto MyExit;
				}
			if (hWave)
			{
				waveOutClose((HWAVEOUT)hWave);
				hWave = (HWAVE)NULL;
			}
		}

		WaveFormatEx.nAvgBytesPerSec = 8000*SAMPLE_SIZE;
		WaveFormatEx.nBlockAlign = SAMPLE_SIZE;
		WaveFormatEx.wBitsPerSample = SAMPLE_SIZE*8;
#endif
		// Open the wave in device using wave mapper
		if (mmr = waveOutOpen ((HWAVEOUT *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
			{
			if (mmr == WAVERR_BADFORMAT)
			{
				// This is probably an 8 bit board. Try again using 8 bit format
				WaveFormatEx.nAvgBytesPerSec = 8000;
				WaveFormatEx.nBlockAlign = 1;
				WaveFormatEx.wBitsPerSample = 8;
				if (mmr = waveOutOpen ((HWAVEOUT *) &hWaveMapper, WAVE_MAPPER, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL))
					goto MyExit;
			}
			else
				goto MyExit;
			}

		// Now, look for the wave device that is already open
		// that's the one wave mapper picked up
		for (i=0; i<uNumWaveDevId; i++, hWave=NULL)
		{
			if ((mmr = waveOutOpen ((HWAVEOUT *) &hWave, i, (WAVEFORMATEX *) &WaveFormatEx, 0, 0, CALLBACK_NULL)) == MMSYSERR_ALLOCATED)
				{
				uDeviceId = i;
				goto MyExit;
				}
			else
				if (hWave)
				{
					waveOutClose((HWAVEOUT)hWave);
					hWave = (HWAVE)NULL;
				}
		}
	}

MyExit:
	if (!uInOrOut)
	{
		if (hWave) waveInClose((HWAVEIN)hWave);
		if (hWaveMapper) waveInClose((HWAVEIN)hWaveMapper);
	}
	else
	{
		if (hWave) waveOutClose((HWAVEOUT)hWave);
		if (hWaveMapper) waveOutClose((HWAVEOUT)hWaveMapper);
	}

	return(uDeviceId);
}

UINT CheckForWaveDeviceSupport(UINT uWaveDevId, UINT uInOrOut)
{
	MMRESULT		mmr;

	// querying isn't good enough, always directly open the device
	// to see if it supports a given format
	
	if (!uInOrOut)
	{
		waveInDev	WaveIn(uWaveDevId);

		if (uWaveDevId != WAVE_MAPPER)
			WaveIn.AllowMapper(FALSE);

		mmr = WaveIn.Open(8000,16);
		if (mmr == WAVERR_BADFORMAT)
		{
			mmr = WaveIn.Open(8000,8);
			if (mmr == WAVERR_BADFORMAT)
			{
				mmr = WaveIn.Open(11025, 16);
				if (mmr == WAVERR_BADFORMAT)
				{
					mmr = WaveIn.Open(22050, 16);
					if (mmr == WAVERR_BADFORMAT)
					{
						mmr = WaveIn.Open(44100, 16);
					}
				}
			}
		}
	}
					
	else  // waveOut
	{
		waveOutDev	WaveOut(uWaveDevId);

		if (uWaveDevId != WAVE_MAPPER)
			WaveOut.AllowMapper(FALSE);

		mmr = WaveOut.Open(8000,16);
		if (mmr == WAVERR_BADFORMAT)
		{
			mmr = WaveOut.Open(8000,8);
			if (mmr == WAVERR_BADFORMAT)
			{
				mmr = WaveOut.Open(11025, 16);
				if (mmr == WAVERR_BADFORMAT)
				{
					mmr = WaveOut.Open(22050, 16);
					if (mmr == WAVERR_BADFORMAT)
					{
						mmr = WaveOut.Open(44100, 16);
					}
				}
			}
		}
	}
					
	// go ahead and allow the device to pass if it's in use
	if ((mmr == MMSYSERR_ALLOCATED) || (mmr == MMSYSERR_NOERROR))
		return TRUE;

	else
		return FALSE;

	// destructors for waveOut and waveIn will call Close()
}

UINT CheckForAgc(UINT uWaveInDevId)
{

	CMixerDevice	*pMixDev;
	UINT			uRet = SOUNDCARD_NONE;
	BOOL			fAgc;
	
	pMixDev = CMixerDevice::GetMixerForWaveDevice(
			NULL,
			uWaveInDevId,
			MIXER_OBJECTF_WAVEIN);
	//SS: we need to correlate the uDevId to mixer id
	if (pMixDev)
	{
		uRet = SOUNDCARD_PRESENT;
		if (pMixDev->GetAGC(&fAgc))
			uRet = SOUNDCARD_HAVEAGC;

		delete pMixDev;
	}
	return (uRet);
}






// This function is here to allow the help system to invoke
// the wizard via rundll32

void WINAPI RunAudioWiz(HWND hwndStub, HINSTANCE hInst, LPSTR lpszCmdLine, int CmdShow )
{
	IntCreateAudioCalibWizard(hwndStub, RUNDUE_USERINVOKED, WAVE_MAPPER,
		NULL, READFROM_REGISTRY);
}


static void PaintVUMeter (HWND hwnd, DWORD dwVolume)
{
	COLORREF RedColor = RGB(255,0,0);
	COLORREF YellowColor = RGB(255,255,0);
	COLORREF GreenColor = RGB(0,255,0);
	static DWORD dwPrevVolume=0;
	HBRUSH	hRedBrush, hOldBrush, hYellowBrush, hGreenBrush;
	HBRUSH	hBlackBrush, hCurrentBrush;
	HDC		hdc;
	RECT	rect, rectDraw, invalidRect;
	DWORD	width, boxwidth, startPos=0;
	DWORD nRect=0, yellowPos, redPos;
	LONG lDiff, lDiffTrunc = (MAX_VOLUME_NORMALIZED/2);


	// rect gets filled with the dimensions we are drawing into
	if (FALSE == GetClientRect (hwnd, &rect))
	{
		return;
	}

	// we expect volume to be between 0-32768
	if (dwVolume > MAX_VOLUME)
		dwVolume = MAX_VOLUME;

	// reduce from 15 bits to 8    // 0 <= dwVolume <= 256
	dwVolume = dwVolume / 128;

	// run it through the "normalizing" table.  Special case: F(256)==256
	if (dwVolume < MAX_VOLUME_NORMALIZED)
		dwVolume = g_VUTable[dwVolume];
	
	// visual aesthetic #1 - get rid of VU jerkiness
	// if the volume changed by more than 1/2 since the last update
	// only move the meter up half way
   // exception: if volume is explicitly 0, then skip
	lDiff = (LONG)dwVolume - (LONG)dwPrevVolume;
	if ((dwVolume != 0) && ( (lDiff > (MAX_VOLUME_NORMALIZED/2))
                       ||   (lDiff < -(MAX_VOLUME_NORMALIZED/2)) ))
		dwVolume = dwVolume - (lDiff/2);
	
	// minus 2 for the ending borders
	// if Framed rectangles are used, drop the -2
	boxwidth = rect.right - rect.left - 2;
	width = (boxwidth * dwVolume)/ MAX_VOLUME_NORMALIZED;

	// visual aesthetic #2 - to get rid of flicker
	// if volume has increased since last time
	// then there is no need to invalidate/update anything
	// otherwise only clear everything to the right of the
	// calculated "width".  +/- 1 so the border doesn't get erased
	if ((dwVolume < dwPrevVolume) || (dwVolume == 0))
	{
		invalidRect.left = rect.left + width - RECTANGLE_WIDTH;
		if (invalidRect.left < rect.left)
			invalidRect.left = rect.left;
		invalidRect.right = rect.right - 1;
		invalidRect.top = rect.top + 1;
		invalidRect.bottom = rect.bottom - 1;

		// these calls together erase the invalid region
		InvalidateRect (hwnd, &invalidRect, TRUE);
		UpdateWindow (hwnd);
	}

	hdc = GetDC (hwnd) ;

	hRedBrush = CreateSolidBrush (RedColor) ;
	hGreenBrush = CreateSolidBrush(GreenColor);
	hYellowBrush = CreateSolidBrush(YellowColor);

	hBlackBrush = (HBRUSH)GetStockObject(BLACK_BRUSH);
	hOldBrush = (HBRUSH) SelectObject (hdc, hBlackBrush);

	// draw the main
	FrameRect(hdc, &rect, hBlackBrush);

	yellowPos = boxwidth/2;
	redPos = (boxwidth*3)/4;

	SelectObject(hdc, hGreenBrush);

	hCurrentBrush = hGreenBrush;

	rectDraw.top = rect.top +1;
	rectDraw.bottom = rect.bottom -1;
	while ((startPos+RECTANGLE_WIDTH) < width)
	{
		rectDraw.left = rect.left + (RECTANGLE_WIDTH+RECTANGLE_LEADING)*nRect + 1;
		rectDraw.right = rectDraw.left + RECTANGLE_WIDTH;
		nRect++;

		FillRect(hdc, &rectDraw, hCurrentBrush);
		startPos += RECTANGLE_WIDTH+RECTANGLE_LEADING;

		if (startPos > redPos)
			hCurrentBrush = hRedBrush;
		else if (startPos > yellowPos)
			hCurrentBrush = hYellowBrush;
	}

	SelectObject (hdc, hOldBrush);
	DeleteObject(hRedBrush);
	DeleteObject(hYellowBrush);
	DeleteObject(hGreenBrush);
	ReleaseDC (hwnd, hdc) ;

	dwPrevVolume = dwVolume;
	return;
}

static DWORD ComputePower(SHORT *wBuffer, DWORD dwNumSamples, AUDIO_POWER *pAudioPower)
{
	DWORD dwIndex, dwTotal;
	LONG dcComponent;
	SHORT val;
	DWORD dwVal;

	ZeroMemory(pAudioPower, sizeof(AUDIO_POWER));
	pAudioPower->dwMin = MAX_VOLUME; // 32768

	dwTotal = 0;
	dcComponent = 0;

	for (dwIndex = 0; dwIndex < dwNumSamples; dwIndex++)
	{
		val = wBuffer[dwIndex];
		dwVal = SHABS(val);
		dwTotal += dwVal;
		dcComponent += val;

		if (dwVal > pAudioPower->dwMax)
			pAudioPower->dwMax = dwVal;
		if (dwVal < pAudioPower->dwMin)
			pAudioPower->dwMin = dwVal;
	}

	pAudioPower->lDcComponent = dcComponent / (LONG)dwNumSamples;
	pAudioPower->dwAvg = dwTotal / dwNumSamples;

	return pAudioPower->dwAvg;
}





// given a pointer to a wave In device, and a list of WAVEHDR structs
// each wave header is prepared (if needed) and fed to wavein
MMRESULT PostFreeBuffers(waveInDev *pWaveInDev, WAVEHDR *aWaveHdrs, int numBuffers, DWORD *pdwCount)
{
	int nIndex;
	MMRESULT mmr=MMSYSERR_NOERROR;
	bool bNeedToPrepare;

	// first time through - the dwUser field of all wave headers
	// will be zero.  Just look a the first header in the list
	// to figure this out.

	if (numBuffers < 1)
	{
		ASSERT(false);
		return MMSYSERR_ERROR;
	}

	bNeedToPrepare = (aWaveHdrs[0].dwUser == 0);

	if (bNeedToPrepare)
	{
		for (nIndex = 0; nIndex < numBuffers; nIndex++)
		{
			mmr = pWaveInDev->PrepareHeader(&aWaveHdrs[nIndex]);

			if (mmr != MMSYSERR_NOERROR)
			{
				return mmr;
			}

			// so that the code below works ok, just mark the done
			// bit on the wave headers

			aWaveHdrs[nIndex].dwFlags |= WHDR_DONE;
		}
	}


	// for each wave header passed in that has the "done" bit set
	// repost to wavein

	for (nIndex = 0; nIndex < numBuffers; nIndex++)
	{
		if (aWaveHdrs[nIndex].dwFlags & WHDR_DONE)
		{
			aWaveHdrs[nIndex].dwFlags &= ~(WHDR_DONE | WHDR_INQUEUE);
			aWaveHdrs[nIndex].dwFlags |= WHDR_PREPARED;

			*pdwCount = (*pdwCount) + 1;
			if (*pdwCount == 0)
				*pdwCount++;

			aWaveHdrs[nIndex].dwUser = *pdwCount;

			mmr = pWaveInDev->Record(&aWaveHdrs[nIndex]);
		}
	}

	return mmr;

}




// scan the array of wave headers for "done" buffers
// return the most recently posted buffer (if any)

BYTE *GetLatestBuffer(WAVEHDR *aWaveHdrs, int numBuffers)
{
	DWORD_PTR dwUserHigh=0;
	int nIndexHigh=0;
	int nIndex;


	for (nIndex = 0; nIndex < numBuffers; nIndex++)
	{
		if (aWaveHdrs[nIndex].dwFlags & WHDR_DONE)
		{
			if (aWaveHdrs[nIndex].dwUser > dwUserHigh)
			{
				dwUserHigh = aWaveHdrs[nIndex].dwUser;
				nIndexHigh = nIndex;
			}
		}
	}

	if (dwUserHigh > 0)
	{
		return (BYTE*)(aWaveHdrs[nIndexHigh].lpData);
	}

	return NULL;

}





static DWORD CALLBACK CalibrateTalking(PVOID pVoid)
{
	const int SIZE_WAVEIN_BUFFER = 1600; // 100ms @ 8khz, 16-bit
	const int NUM_WAVEIN_BUFFERS = 5;
	WaveBufferList waveList(NUM_WAVEIN_BUFFERS, SIZE_WAVEIN_BUFFER);
	WAVEHDR aWaveHdrs[NUM_WAVEIN_BUFFERS];

	HWND hVUMeter, hDlg;
	HANDLE hEvent;
	MMRESULT mmr;
	DWORD dwPow, dwRet, dwExitCode=0;
	AUDIO_POWER audioPower;
	CALIB_DISPLAY *pCalibDisplay;
	TCHAR szText[ATW_MSG_LENGTH];
	BOOL fOpened = TRUE;
	BOOL fSoundDetected = FALSE;
	int nRecordCount = 0, nIndex;
	DWORD dwBufferIndex = 1;
	SHORT *buffer;


	HANDLE hEventRecord = CreateEvent(NULL, TRUE, FALSE, NULL);

	waveInDev waveIn(((CALIB_DISPLAY *)pVoid)->uWaveInDevId, hEventRecord);

	pCalibDisplay = (CALIB_DISPLAY *)pVoid;
	hVUMeter = pCalibDisplay->hVUMeter;
	hDlg = pCalibDisplay->hDlg;
	hEvent = pCalibDisplay->hEvent;

	ASSERT(hEvent);


	mmr = waveIn.Open(8000,16);
	if (mmr == MMSYSERR_ALLOCATED)
	{
		FLoadString(IDS_RECORD_ERROR, szText, CCHMAX(szText));
		SetDlgItemText(hDlg, IDC_ATW_RECORD_ERROR, szText);
		fOpened = FALSE;
	}

	else if (mmr != MMSYSERR_NOERROR)
	{
		PostMessage(hDlg, WM_AUDIOTHREAD_ERROR, 0, 0);
		CloseHandle(hEvent);
		CloseHandle(hEventRecord);
		return -1;
	}
	else
	{
		SetDlgItemText(hDlg, IDC_ATW_RECORD_ERROR, "");
		ResetEvent(hEventRecord);
	}


	// initialize the array of wavehdrs
	for (nIndex=0; nIndex < NUM_WAVEIN_BUFFERS; nIndex++)
	{
		ZeroMemory(&aWaveHdrs[nIndex], sizeof(WAVEHDR));
		aWaveHdrs[nIndex].lpData = (LPSTR)(waveList.GetBuffer(nIndex));
		aWaveHdrs[nIndex].dwBufferLength = SIZE_WAVEIN_BUFFER;
	}


	while (1)
	{

		// is it time to exit ?
		dwRet = WaitForSingleObject(hEvent, 0);
		if (dwRet == WAIT_OBJECT_0)
		{
			dwExitCode = 0;
			break;
		}

		// if we still haven't opened the device
		// keep trying

		if (fOpened == FALSE)
		{
			mmr = waveIn.Open(8000,16);
			if (mmr == MMSYSERR_ALLOCATED)
			{
				PaintVUMeter(hVUMeter, 0); // draw a blank rectangle
				Sleep(500);
				continue;
			}

			if (mmr != MMSYSERR_NOERROR)
			{
				PostMessage(hDlg, WM_AUDIOTHREAD_ERROR, 0, 0);
				dwExitCode = (DWORD)(-1);
				break;
			}

			// mmr == noerror
			SetDlgItemText(hDlg, IDC_ATW_RECORD_ERROR, TEXT(""));
			fOpened = TRUE;
			ResetEvent(hEventRecord);
		}

		// wave device is open at this point

		mmr = PostFreeBuffers(&waveIn, aWaveHdrs, NUM_WAVEIN_BUFFERS, &dwBufferIndex);
		if (mmr != MMSYSERR_NOERROR)
		{
			PostMessage(hDlg, WM_AUDIOTHREAD_ERROR, 0, 0);
			dwExitCode = (DWORD) -1;
			break;
		}

		WaitForSingleObject(hEventRecord, 5000);
		ResetEvent(hEventRecord);

		buffer = (SHORT*)GetLatestBuffer(aWaveHdrs, NUM_WAVEIN_BUFFERS);

		if (buffer)
		{
			nRecordCount++;

			dwPow = ComputePower(buffer, SIZE_WAVEIN_BUFFER/2, &audioPower);

			// don't update the meter for the first 200ms.
			// "noise" from opening the soundcard tends to show up
			if (nRecordCount > 2)
			{
				PaintVUMeter(hVUMeter, audioPower.dwMax);

				// signal back to the calling window (if it hasn't already),
				// that the silence threshold was broken
				if ((fSoundDetected == FALSE) && (audioPower.dwMax > SILENCE_THRESHOLD))
				{
					PostMessage(hDlg, WM_AUDIOTHREAD_SOUND, 0,0);
					fSoundDetected = TRUE;
				}

				// check for clipping, post message back to parent thread/window
				// so that it will adjust the volume
				if (audioPower.dwMax > CLIPPINGVOL)
				{
					// should we use send message instead ?
					PostMessage(hDlg, WM_AUDIO_CLIPPING,0,0);
				}
			}
			else
				PaintVUMeter(hVUMeter, 0);

		}
	}

	waveIn.Reset();

	for (nIndex = 0; nIndex < NUM_WAVEIN_BUFFERS; nIndex++)
	{
		waveIn.UnPrepareHeader(&aWaveHdrs[nIndex]);
	}

	waveIn.Close();

	CloseHandle(hEvent);
	CloseHandle(hEventRecord);

	TRACE_OUT(("ATW: Recording Thread Exit\r\n"));

	return dwExitCode;

}




// Turns on AGC if needed
// parameter is whatever pawInfo->iSetAgc is.
// but it's probably been hardcoded to be READFROM_REGISTRY
static BOOL StartAGC(CMixerDevice *pMixer, BOOL iSetAgc, UINT uSoundCardCaps)
{
	BOOL bSet, bRet;

	if (iSetAgc == READFROM_REGISTRY)
	{
		if (DOESSOUNDCARDHAVEAGC(uSoundCardCaps))
		{
			RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
			bSet = (BOOL)( re.GetNumber(REGVAL_AUTOGAIN,AUTOGAIN_ENABLED) == AUTOGAIN_ENABLED );
		}
		else
		{
			bSet = FALSE; 		
		}
	}
	else
	{
		bSet = (iSetAgc != 0);
	}
	

	bRet = pMixer->SetAGC(bSet);	

	if (bSet == FALSE)
		return FALSE;

	return bRet;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\call.cpp ===
// File: call.cpp

#include "precomp.h"
#include "resource.h"
#include "call.h"
#include "dlgcall.h"
#include "confapi.h"
#include "popupmsg.h"
#include "passdlg.h"
#include "chcondlg.h"
#include "dshowdlg.h"

#include "conf.h"
#include "calllog.h"
#include "rostinfo.h"
#include "..\..\core\cncodes.h"  // for CN_* codes
#include <inodecnt.h> // for UI_RC_...
#include "cr.h" 	  // for CreateConfRoomWindow, UpdateUI
#include "confroom.h"
#include "confman.h"
#include "NmLdap.h"
#include "nmremote.h"
#include <tsecctrl.h>
#include "ConfPolicies.h"
#include "StatBar.h"
#include "certui.h"
#include "cmd.h"
#include "callto.h"
#include "dlgacd.h"

// External SDK stuff...
#include "NmCall.h"
#include "NmApp.h"


COBLIST * g_pCallList = NULL;  // Global list of calls in progress
extern INmSysInfo2 * g_pNmSysInfo;

static HRESULT OnUIRemotePassword(BSTR bstrConference, BSTR *pbstrPassword, LPCTSTR pCertText, BOOL fIsService);

extern BOOL FRejectIncomingCalls(void);
extern BOOL FIsConfRoomClosing(void);
extern GUID g_csguidSecurity;
extern GUID g_csguidMeetingSettings;

/*	C  C A L L	*/
/*-------------------------------------------------------------------------
	%%Function: CCall
	
-------------------------------------------------------------------------*/
CCall::CCall(LPCTSTR pszCallTo, LPCTSTR pszDisplayName, NM_ADDR_TYPE nmAddrType, BOOL bAddToMru, BOOL fIncoming) :
	RefCount(NULL),
	m_fIncoming 	   (fIncoming),
	m_pszDisplayName	(PszAlloc(pszDisplayName)),
	m_pszCallTo 	(PszAlloc(pszCallTo)),
	m_nmAddrType	(nmAddrType),
	m_bAddToMru 	(bAddToMru),
	m_fSelectedConference (FALSE),
	 m_pDlgCall 	 (NULL),
	m_pInternalICall(NULL),
	m_pos			(NULL),
	m_dwCookie		(0),
	m_ppm			 (NULL),
	m_fInRespond		(FALSE)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CCall", this);

	USES_CONVERSION;		

	if (FEmptySz(m_pszDisplayName))
	{
		delete m_pszDisplayName;

		// Default to "another person" if no name available in the call data
		m_pszDisplayName = PszLoadString(IDS_UNKNOWN_PERSON);
	}

	m_dwTick = ::GetTickCount();

	DbgMsgCall("CCall: %08X Created Name=[%s] CallTo=[%s]",
		this, m_pszDisplayName, m_pszCallTo ? m_pszCallTo : _TEXT("<NULL>"));

	// add it to the global call list
	if (NULL == g_pCallList)
	{
		g_pCallList = new COBLIST;
		if (NULL == g_pCallList)
		{
			ERROR_OUT(("CCall::CCall - unable to allocate g_pCallList"));
			return;
		}
	}
	m_pos = g_pCallList->AddTail(this);

}

CCall::~CCall()
{
	DBGENTRY(CCall::~CCall);

	RemoveFromList();

	delete m_pszDisplayName;
	delete m_pszCallTo;

	if(m_pInternalICall)
	{
		m_pInternalICall->Release();
		m_pInternalICall = NULL;
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CCall", this);
	
	DBGEXIT(CCall::~CCall);
}


/*	S E T  N M	C A L L  */
/*-------------------------------------------------------------------------
	%%Function: SetNmCall
	
-------------------------------------------------------------------------*/
VOID CCall::SetNmCall(INmCall * pCall)
{
	ASSERT(NULL != pCall);
	ASSERT((!m_pInternalICall) || (m_pInternalICall == pCall));
		
	if(!m_pInternalICall)
	{
		pCall->AddRef();		
		m_pInternalICall = pCall;
	}

	if(!m_dwCookie)
	{
		NmAdvise(m_pInternalICall, this, IID_INmCallNotify2, &m_dwCookie);
	}

	Update();
}


BOOL CCall::RemoveFromList(void)
{
	// Remove the call from the global list
	if (NULL == m_pos)
		return FALSE;

	ASSERT(NULL != g_pCallList);
	CCall * pCall = (CCall *) g_pCallList->RemoveAt(m_pos);
	ASSERT(this == pCall);
	
	m_pos = NULL;

	if(m_pInternalICall)
	{
		NmUnadvise(m_pInternalICall, IID_INmCallNotify2, m_dwCookie);
		m_dwCookie = NULL;
	}

	return TRUE;
}

VOID CCall::Cancel(BOOL fDisplayCancelMsg)
{
	if (!FComplete())
	{
		if (fDisplayCancelMsg & !FIncoming())
		{
			DisplayPopup();  // Inform the user with a small popup message
		}
		if (m_pInternalICall)
		{
			m_pInternalICall->Cancel();
		}

		Update();
	}
}			



///////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CCall::AddRef(void)
{
	return RefCount::AddRef();
}
	
STDMETHODIMP_(ULONG) CCall::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CCall::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmCallNotify2) || (riid == IID_INmCallNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmCallNotify2 *)this;
		ApiDebugMsg(("CCall::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CCall::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// INmCallNotify methods

STDMETHODIMP CCall::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CCall::StateChanged(NM_CALL_STATE uState)
{
	Update();

	return S_OK;
}

STDMETHODIMP CCall::Failed(ULONG uError)
{
	DbgMsgCall("CCall: %08X Failed uError=%d", this, uError);
	return S_OK;
}

STDMETHODIMP CCall::Accepted(INmConference *pConference)
{
	DbgMsgCall("CCall: %08X Accepted pConference=0x%08X", this, pConference);
	return S_OK;
}


VOID CCall::ShowProgress(BOOL fShow)
{
	if (NULL == m_pDlgCall)
		return;

	ShowWindow(m_pDlgCall->GetHwnd(), fShow ? SW_SHOWNORMAL : SW_HIDE);
}


VOID CCall::RemoveProgress(void)
{
	if (NULL == m_pDlgCall)
		return;

	m_pDlgCall->Destroy();
	m_pDlgCall->Release();
	m_pDlgCall = NULL;
}

/*	C A L L  E R R O R	*/
/*-------------------------------------------------------------------------
	%%Function: CallError
	
-------------------------------------------------------------------------*/
STDMETHODIMP CCall::CallError(UINT cns)
{
	UINT ids = 0;

	ShowProgress(FALSE);

	ASSERT(m_pInternalICall != NULL);
	DbgMsgCall("CCall: %08X CallError cns=%08X", this, cns);

	// Translate cns to normal error message
	switch (cns)
	{
	case CN_RC_NAME_RESOLUTION_FAILED:
		ids = IDS_RESOLVE_FAILED;
		break;

	case CN_RC_CONNECT_FAILED:
	case CN_RC_AUDIO_CONNECT_FAILED:
		ids = IDS_COULD_NOT_CONNECT;
		break;
		
	case CN_RC_CONNECT_REMOTE_NO_SECURITY:
			ids = IDS_CONNECT_REMOTE_NO_SECURITY;
		break;

	case CN_RC_CONNECT_REMOTE_DOWNLEVEL_SECURITY:
			ids = IDS_CONNECT_REMOTE_DOWNLEVEL_SECURITY;
		break;

	case CN_RC_CONNECT_AUTHENTICATION_FAILED:
		ids = IDS_CONNECT_AUTHENTICATION_FAILED;
		break;

	case CN_RC_SECURITY_FAILED:
		ids = IDS_CONNECT_SECURITY_FAILED;
		break;

	case CN_RC_CONNECT_REMOTE_REQUIRE_SECURITY:
		ids = IDS_CONNECT_REMOTE_REQUIRE_SECURITY;
		break;
		
	case CN_RC_CONFERENCE_JOIN_DENIED:
		ids = IDS_JOIN_DENIED;
		break;
		
	case CN_RC_CONFERENCE_INVITE_DENIED:
		ids = IDS_INVITE_DENIED;
		break;
		
	case CN_RC_INVITE_DENIED_REMOTE_IN_CONF:
		ids = IDS_INVITE_DENIED_REMOTE_CONF;
		break;
		
	case CN_RC_CONFERENCE_DOES_NOT_EXIST:
		ids = m_fSelectedConference ?
			IDS_CONFERENCE_DOES_NOT_EXIST : IDS_CONFERENCE_ENDED_BEFORE_JOIN;
		break;
		
	case CN_RC_CONFERENCE_ENDED_BEFORE_JOIN:
		// REVIEW: This is no longer sent?
		ids = IDS_CONFERENCE_ENDED_BEFORE_JOIN;
		break;
		
	case CN_RC_AUDIO_NOT_AVAILABLE:
		ids = IDS_AUDIO_NOT_AVAILABLE;
		break;
		
	case CN_RC_AUDIO_FAILED_AFTER_DATA:
		ids = IDS_AUDIO_FAILED_AFTER_DATA;
		break;
		
	case CN_RC_AUDIO_IN_USE_REMOTE_AFTER_DATA:
		ids = IDS_AUDIO_IN_USE_REMOTE_AFTER_DATA;
		break;
		
	case CN_RC_AUDIO_IN_USE_REMOTE:
		ids = IDS_AUDIO_IN_USE_REMOTE;
		break;
		
	case CN_RC_AUDIO_IN_USE_LOCAL_AFTER_DATA:
		ids = IDS_AUDIO_IN_USE_LOCAL_AFTER_DATA;
		break;
		
	case CN_RC_AUDIO_IN_USE_LOCAL:
		ids = IDS_AUDIO_IN_USE_LOCAL;
		break;
		
	case CN_RC_CANT_INVITE_MCU:
		ids = IDS_CANT_INVITE_MCU;
		break;
		
	case CN_RC_REMOTE_PLACING_CALL:
		ids = IDS_REMOTE_PLACING_CALL;
		break;
		
	case CN_RC_TRANSPORT_FAILURE:
		ids = IDS_TRANSPORT_UNAVAILABLE;
		break;

	case CN_RC_CANT_JOIN_ALREADY_IN_CALL:
		ids = IDS_INCALL_JOIN_FAILED;
		break;

	case CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED:
		ids = IDS_INVITE_CONF_ENDED;
		break;

	case CN_RC_GK_CALLEE_NOT_REGISTERED:
		ids = IDS_GK_CALLEE_NOT_REGISTERED;
		break;

	case CN_RC_GK_TIMEOUT:
		ids = IDS_GK_TIMEOUT;
		break;

	case CN_RC_GK_REJECTED:
		ids = IDS_GK_REJECTED;
		break;

	case CN_RC_GK_NOT_REGISTERED:
		ids = IDS_GK_NOT_REGISTERED;
		break;

	default:
		return S_FALSE;
	} /*  switch (cns) */

	DisplayMsgIdsParam(ids, m_pszDisplayName);
	return S_OK;
}


STDMETHODIMP CCall::RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin)
{
	return OnUIRemoteConference(fMCU, (PWSTR *)pwszConfNames, pbstrConfToJoin);
}

STDMETHODIMP CCall::RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, PBYTE pb, DWORD cb, BOOL fIsService)
{
	TCHAR* pLastCertText = NULL;
	if (NULL != pb) {
		ASSERT(cb > 0);
	if (!(pLastCertText = FormatCert(pb, cb)))
		{
			ERROR_OUT(("FormatCert failed"));
		}
	}

	ShowProgress(FALSE);
	HRESULT hr = OnUIRemotePassword(bstrConference, pbstrPassword, pLastCertText, fIsService);
	if (pLastCertText) delete pLastCertText;
	return hr;
}

NM_CALL_STATE CCall::GetState()
{
	NM_CALL_STATE callState = NM_CALL_INVALID;

	if(m_pInternalICall)
	{
		m_pInternalICall->GetState(&callState);
	}

	return callState;
}

/*	U P D A T E  */
/*-------------------------------------------------------------------------
	%%Function: Update

	Update the cached information about the call
-------------------------------------------------------------------------*/
VOID CCall::Update(void)
{
	DBGENTRY(CCall::Update);
	
	NM_CALL_STATE callState = GetState();;

	switch (callState)
	{
		case NM_CALL_CANCELED:
		case NM_CALL_ACCEPTED:
		case NM_CALL_REJECTED:
			// Remove the call from the global list because we'll never get
			// any more notifications for this.
			if (RemoveFromList())
			{
				if (FIncoming())
				{
					if ((NM_CALL_CANCELED == callState) && (NULL != m_ppm))
					{
						//
						// if m_fInRespond is set then we've already
						// dismissed the dialog and the call is being
						// cancelled because we discovered the underlying
						// connection is gone.
						//

						if ( !m_fInRespond )
						{
							delete m_ppm;
							m_ppm = NULL;

							// Release the lock added by OnRing
							Release();
						}
					}
					LogCall(NM_CALL_ACCEPTED == callState);
				}
				else
				{
					RemoveProgress();

					if (NM_CALL_ACCEPTED == callState)
					{

						if(m_bAddToMru)
						{
							CAcdMru CallList;
							CallList.AddEntry(m_pszDisplayName, m_pszCallTo,  m_nmAddrType);
							CallList.Save();
						}
					}
				}

				// Release the initial lock on this object
				Release();
			}
			break;

		case NM_CALL_RING:
			OnRing();
			break;

		case NM_CALL_SEARCH:
			ASSERT(NULL == m_pDlgCall);
			m_pDlgCall = new CDlgCall(this);
			break;

		case NM_CALL_WAIT:
			if (NULL != m_pDlgCall)
			{
				m_pDlgCall->OnStateChange();
			}
			break;

		default:
			ERROR_OUT(("CCall::Update: Unknown state %08X", callState));

		case NM_CALL_INVALID:
		case NM_CALL_INIT:
			break;
	}

	::UpdateUI(CRUI_CALLANIM | CRUI_TOOLBAR | CRUI_STATUSBAR);

	DBGEXIT(CCall::Update);
}


/*	F  C O M P L E T E	*/
/*-------------------------------------------------------------------------
	%%Function: FComplete
	
	Return TRUE if the call has completed
-------------------------------------------------------------------------*/
BOOL CCall::FComplete(void)
{
	switch (GetState())
		{
	case NM_CALL_ACCEPTED:
	case NM_CALL_REJECTED:
	case NM_CALL_CANCELED:
		return TRUE;

	case NM_CALL_INVALID:
	case NM_CALL_INIT:
	case NM_CALL_RING:
	case NM_CALL_SEARCH:
	case NM_CALL_WAIT:
	default:
		return FALSE;
		}
}

/*	P O P U P  M S G  R I N G I N G  C A L L B A C K  */
/*-------------------------------------------------------------------------
	%%Function: CCall::PopupMsgRingingCallback

-------------------------------------------------------------------------*/


VOID CALLBACK CCall::PopupMsgRingingCallback(LPVOID pContext, DWORD dwFlags)
{
	CCall *pCall = (CCall *) pContext;
	ASSERT(NULL != pCall);

	DbgMsgCall("CCall: %08X Responding from invite popup - result is 0x%08X", pCall, dwFlags);
	DWORD dwCLEF;

	if(!( PMF_KILLED & dwFlags ))
	{
		dwCLEF = (PMF_OK & dwFlags) ? CLEF_ACCEPTED : CLEF_REJECTED;

		if (PMF_TIMEOUT & dwFlags)
		{
			dwCLEF |= CLEF_TIMED_OUT;
		}

		pCall->RespondToRinging(dwCLEF);
	}

	if(pCall->m_ppm)
	{
		// pop up message will be destroyed after callback returns
		pCall->m_ppm = NULL;

		// Release the lock added by OnRing
		pCall->Release();
	}
}


/*	O N  R I N G  */
/*-------------------------------------------------------------------------
	%%Function: OnRing

	Handling an incoming call that just started to "ring".
-------------------------------------------------------------------------*/
VOID CCall::OnRing(void)
{
	DbgMsgCall("CCall: %08X OnRing", this);
	
	if (FRejectIncomingCalls())
	{
		// Respond negatively
		WARNING_OUT(("Rejecting invite - not listening or sys pol disabled"));
		RespondToRinging(CLEF_REJECTED);
		return;
	}

	if( ConfPolicies::IsAutoAcceptCallsEnabled() && !_Module.InitControlMode())
	{
		// Respond with success
		RespondToRinging(CLEF_ACCEPTED | CLEF_AUTO_ACCEPTED);
		return;
	}

	if(!_Module.InitControlMode())
	{
		// Display a message for the user

		TCHAR szFormatBuf[MAX_PATH];
		TCHAR szMsgBuf[MAX_PATH];

		if (FLoadString(IDS_INVITE_PERMISSION, szFormatBuf, CCHMAX(szFormatBuf)))
		{
			TCHAR szName[MAX_PATH];
			LPTSTR psz = m_pszDisplayName;
			if (FEmptySz(psz))
			{
				// The name string is blank, so fill it in with a default:
				::LoadString(::GetInstanceHandle(), IDS_UNKNOWN_PERSON,
								szName, CCHMAX(szName));
				psz = szName;
			}
			wsprintf(szMsgBuf, szFormatBuf, psz);
		}

		ASSERT(NULL == m_ppm);
		m_ppm = new CPopupMsg(PopupMsgRingingCallback, this);
		if (NULL != m_ppm)
		{
			RegEntry re(UI_KEY, HKEY_CURRENT_USER);
			UINT uTime = re.GetNumber(REGVAL_RING_TIMEOUT, DEFAULT_RING_TIMEOUT) * 1000;
			
			AddRef(); // Released in PopupMsgRingingCallback
			m_ppm->CreateDlg(szMsgBuf, TRUE, MAKEINTRESOURCE(IDI_CONFROOM),
				::GetInstanceHandle(), IDS_INVITE_SOUND, uTime);
		}
	}
}

/*	R E S P O N D  T O	R I N G I N G  */
/*-------------------------------------------------------------------------
	%%Function: RespondToRinging
	
-------------------------------------------------------------------------*/
BOOL CCall::RespondToRinging(DWORD dwCLEF)
{
	BOOL fAccept = FALSE;
	m_fInRespond = TRUE;
	
	if (NM_CALL_RING == GetState())
	{
		if (!FIsConfRoomClosing() && (CLEF_ACCEPTED & dwCLEF))
		{
			fAccept = TRUE;
			if(_Module.IsUIActive())
			{
				CConfRoom * pcr = ::GetConfRoom();
				ASSERT(pcr);
				pcr->BringToFront();
			}
		}

		CNmCallObj::StateChanged(m_pInternalICall, fAccept ? NM_CALL_ACCEPTED : NM_CALL_REJECTED);

		if (fAccept)
		{
			m_pInternalICall->Accept();
		}
		else
		{
			m_pInternalICall->Reject();
		}
	}
	else
	{
		CallError(CN_RC_CONFERENCE_ENDED_BEFORE_ACCEPTED);
	}

	m_fInRespond = FALSE;
	return fAccept;
}


/*	D I S P L A Y  P O P U P  */
/*-------------------------------------------------------------------------
	%%Function: DisplayPopup
	
-------------------------------------------------------------------------*/
VOID CCall::DisplayPopup(void)
{
	CPopupMsg* ppm = new CPopupMsg(NULL);
	if (NULL == ppm)
		return;
		
	TCHAR szMsg[MAX_PATH*2];
	if (FLoadString1(IDS_CALL_CANCELED_FORMAT, szMsg, m_pszDisplayName))
	{
		ppm->Create(szMsg, FALSE, MAKEINTRESOURCE(IDI_CONFROOM),
				::GetInstanceHandle(), IDS_PERSON_LEFT_SOUND,
				ROSTER_TIP_TIMEOUT);
	}
	else
	{
		delete ppm;
	}

}

/*	P L A C E  C A L L	*/
/*-------------------------------------------------------------------------
	%%Function: PlaceCall

	Place an outgoing call.
-------------------------------------------------------------------------*/
HRESULT
CCall::PlaceCall
(
	DWORD dwFlags,
	NM_ADDR_TYPE addrType,
	const TCHAR * const    setupAddress,
	const TCHAR * const    destinationAddress,
	const TCHAR * const    alias,
	const TCHAR * const    url,
	const TCHAR * const conference,
	const TCHAR * const password,
	const TCHAR * const    userData
){
	USES_CONVERSION;

	DBGENTRY(CCall::PlaceCall);
	
	HRESULT hr = E_FAIL;

	ASSERT(m_pInternalICall == NULL);

	INmManager2 *pNmMgr = CConfMan::GetNmManager();
	ASSERT (NULL != pNmMgr);

	hr = pNmMgr->CallEx(	&m_pInternalICall,
							dwFlags,
							addrType,
							CComBSTR( GetPszName() ),
							CComBSTR( setupAddress ),
							CComBSTR( destinationAddress ),
							CComBSTR( alias ),
							CComBSTR( url ),
							CComBSTR( conference ),
							CComBSTR( password ),
							CComBSTR( userData ) );

	if(m_pInternalICall && (CRPCF_JOIN & dwFlags) )
	{
		SetSelectedConference();
	}

	// Force an update of the status bar, animation, etc.
	::UpdateUI(CRUI_DEFAULT);

	pNmMgr->Release();

	TRACE_OUT(("CCall::PlaceCall(%s) result=%08X", m_pszCallTo? m_pszCallTo: g_szEmpty, hr));

	DBGEXIT_HR(CCall::PlaceCall, hr);
	return hr;
}


VOID CCall::LogCall(BOOL fAccepted)
{
	LPCTSTR pcszName = GetPszName();

	TCHAR szName[MAX_PATH];
	if (FEmptySz(pcszName))
	{
		if (FLoadString(IDS_UNKNOWN_PERSON, szName, CCHMAX(szName)))
			pcszName = szName;
	}

	LOGHDR logHdr;
	CRosterInfo ri;
	LPBYTE pb;
	ULONG cb;
	LPBYTE pbCert = NULL;
	ULONG cbCert = 0;
	
	if (SUCCEEDED(GetINmCall()->GetUserData(g_csguidRostInfo, &pb, &cb)))
	{
		ri.Load(pb);
	}
	
	GetINmCall()->GetUserData(g_csguidSecurity, &pbCert, &cbCert);
	
	DWORD dwCLEF = fAccepted ? CLEF_ACCEPTED : CLEF_REJECTED;
	if (ri.IsEmpty())
	{
		// No caller data - not NetMeeting
		dwCLEF |= CLEF_NO_CALL;
	}
	if (pbCert)
	{
		ASSERT(cbCert);
		dwCLEF |= CLEF_SECURE;
	}

	ZeroMemory(&logHdr, sizeof(LOGHDR));
	logHdr.dwCLEF = dwCLEF;

	if (NULL != ::GetIncomingCallLog() )
	{
		// Write the data to the log file
		::GetIncomingCallLog()->AddCall(pcszName, &logHdr, &ri, pbCert, cbCert);
	}
}


/*	C R E A T E  I N C O M I N G  C A L L  */
/*-------------------------------------------------------------------------
	%%Function: CreateIncomingCall

	Create an CCall object for the incoming call.
-------------------------------------------------------------------------*/
CCall * CreateIncomingCall(INmCall * pNmCall)
{
	HRESULT hr;
	BSTR  bstr;
	LPTSTR pszName = NULL;
	LPTSTR pszAddr = NULL;
	NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN;

	ASSERT(NULL != pNmCall);

	// Get the display name
	hr = pNmCall->GetName(&bstr);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&pszName, bstr);
		SysFreeString(bstr);
	}

	// Get the address and type
	hr = pNmCall->GetAddr(&bstr, &addrType);
	if (SUCCEEDED(hr))
	{
		hr = BSTR_to_LPTSTR(&pszAddr, bstr);
		SysFreeString(bstr);
	}

	CCall * pCall = new CCall(pszAddr, pszName, NM_ADDR_CALLTO, FALSE, TRUE /* fIncoming */);

	delete pszName;
	delete pszAddr;

	return pCall;
}



///////////////////////////////////////////////////////////////////////////
// Global Functions



/*	C A L L  F R O M  N M  C A L L	*/
/*-------------------------------------------------------------------------
	%%Function: CallFromNmCall
	
-------------------------------------------------------------------------*/
CCall * CallFromNmCall(INmCall * pNmCall)
{
	if (NULL == g_pCallList)
		return NULL;

	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCall = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCall);
		if (pNmCall == pCall->GetINmCall())
		{
			return pCall;
		}
	}

	// no matching call?
	return NULL;
}


/*	F  I S	C A L L  I N  P R O G R E S S  */
/*-------------------------------------------------------------------------
	%%Function: FIsCallInProgress

	Return TRUE if there is an incoming or outgoing call in progress.
-------------------------------------------------------------------------*/
BOOL FIsCallInProgress(void)
{
	if (NULL == g_pCallList)
		return FALSE;

	return !g_pCallList->IsEmpty();
}


/*	G E T  L A S T	O U T G O I N G  C A L L  */
/*-------------------------------------------------------------------------
	%%Function: GetLastOutgoingCall
	
-------------------------------------------------------------------------*/
CCall * GetLastOutgoingCall(void)
{
	if (NULL == g_pCallList)
		return NULL;

	CCall * pCall = NULL;
	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCallTemp = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCallTemp);
		if (!pCallTemp->FIncoming())
		{
			pCall = pCallTemp;
		}
	}

	return pCall;
}


/*	G E T  C A L L	S T A T U S  */
/*-------------------------------------------------------------------------
	%%Function: GetCallStatus

	Check the current call status and return a string for the status bar.
	Return 0 if no call information is available
-------------------------------------------------------------------------*/
DWORD GetCallStatus(LPTSTR pszStatus, int cchMax, UINT * puID)
{
	ASSERT(NULL != pszStatus);
	ASSERT(NULL != puID);
	ASSERT(cchMax > 0);

	*pszStatus = _T('\0');
	*puID = 0;

	CCall *pCall = GetLastOutgoingCall();
	if (NULL == pCall)
		return 0; // not in a call

	// Use the status info from the most recent connection attempt:
	switch (pCall->GetState())
		{
	case NM_CALL_INIT:
	{
		*puID = IDS_STATUS_SETTING_UP;
		break;
	}

	case NM_CALL_SEARCH:
	{
		*puID = IDS_STATUS_FINDING;
		break;
	}

	case NM_CALL_WAIT:
	{
		*puID = IDS_STATUS_WAITING;
		break;
	}

	default:
	{
		// unknown/useless call state
		return 0;
	}
		} /* switch */

	if (FEmptySz(pCall->GetPszName()))
	{
		return 0;
	}

	if (!FLoadString1(*puID, pszStatus, pCall->GetPszName()))
	{
		return 0;
	}

	return pCall->GetTickCount();
}


///////////////////////////////////////////////////////////////////////////
// TODO: Replace these with real connection points

/*	O N  U	I  C A L L	C R E A T E D  */
/*-------------------------------------------------------------------------
	%%Function: OnUICallCreated
	
-------------------------------------------------------------------------*/
HRESULT OnUICallCreated(INmCall *pNmCall)
{
	CCall * pCall;

	// Notify the API
	if (S_OK == pNmCall->IsIncoming())
	{
		pCall = CreateIncomingCall(pNmCall);
		if (NULL == pCall)
		{
			return S_FALSE;
		}
	}
	else
	{
		pCall = CallFromNmCall(pNmCall);
		if (NULL == pCall)
		{
			WARNING_OUT(("OnUiCallCreated: Unable to find outgoing call=%08X", pNmCall));
			return S_FALSE;
		}
	}
	pCall->SetNmCall(pNmCall);

	return S_OK;
}



HRESULT OnUIRemotePassword(BSTR bstrConference, BSTR * pbstrPassword, LPCTSTR pCertText, BOOL fIsService)
{
	HRESULT hr = S_FALSE;
	USES_CONVERSION;		

	CPasswordDlg dlgPw(::GetMainWindow(), OLE2T(bstrConference), pCertText, fIsService);

	if (IDOK == dlgPw.DoModal())
	{
		TRACE_OUT(("password dialog complete (OK pressed)"));
		
		LPTSTR_to_BSTR(pbstrPassword, dlgPw.GetPassword());
		hr = S_OK;
	}

	return hr;
}

HRESULT CCall::OnUIRemoteConference(BOOL fMCU, PWSTR* pwszConfNames, BSTR *pbstrConfToJoin)
{
	HRESULT hr = S_FALSE;

	ShowProgress(FALSE);

	// We bring up the "choose a conference" dialog
	// when calling an MCU or another node with more than
	// one "listed" conference
	CChooseConfDlg dlgChoose(::GetMainWindow(),    pwszConfNames);
	if (IDOK == dlgChoose.DoModal())
	{
		TRACE_OUT(("choose conference dialog complete (OK pressed)"));
		
		LPTSTR_to_BSTR(pbstrConfToJoin, dlgChoose.GetName());
		hr = S_OK;
		m_fSelectedConference = TRUE;
	}

	ShowProgress(TRUE);

	return hr;
}


/*	F R E E  C A L L  L I S T  */
/*-------------------------------------------------------------------------
	%%Function: FreeCallList

	Free any remaining calls
-------------------------------------------------------------------------*/
VOID FreeCallList(void)
{
	if (NULL == g_pCallList)
		return;

	while (!g_pCallList->IsEmpty())
	{
		CCall * pCall = (CCall *) g_pCallList->GetHead();
		WARNING_OUT(("FreeCallList: Orphan call=%08X", pCall));
		pCall->RemoveFromList();
		pCall->Release();
	}

	delete g_pCallList;
	g_pCallList = NULL;
}

/*	C A N C E L  A L L	O U T G O I N G  C A L L S	*/
/*-------------------------------------------------------------------------
	%%Function: CancelAllOutgoingCalls
	
-------------------------------------------------------------------------*/
VOID CancelAllOutgoingCalls(void)
{
	if (NULL == g_pCallList)
		return;

	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCall = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCall);
		if (!pCall->FIncoming())
		{
			// Cancel will release the call object.
			// Ensure that there is at least one reference.
			pCall->AddRef();
			pCall->Cancel(TRUE);
			pCall->Release();
		}
	}
}


/*	C A N C E L  A L L	C A L L S  */
/*-------------------------------------------------------------------------
	%%Function: CancelAllCalls
	
-------------------------------------------------------------------------*/
VOID CancelAllCalls(void)
{
	if (NULL == g_pCallList)
		return;

	POSITION pos = g_pCallList->GetHeadPosition();
	while (pos)
	{
		CCall * pCall = (CCall *) g_pCallList->GetNext(pos);
		ASSERT(NULL != pCall);
		// Cancel will release the call object.
		// Ensure that there is at least one reference.
		pCall->AddRef();
		pCall->Cancel(TRUE);
		pCall->Release();
	}
}


///////////////////////////////////////////////////////////////////////////
// IP Utilities

/*	F  L O C A L  I P  A D D R E S S  */
/*-------------------------------------------------------------------------
	%%Function: FLocalIpAddress

	Return TRUE if the parameter matches the local IP address.
-------------------------------------------------------------------------*/
BOOL FLocalIpAddress(DWORD dwIP)
{
	if (dwIP == 0x0100007F)
	{
		WARNING_OUT(("t-bkrav is trying to call himself"));
		return TRUE;
	}

	// Get own host name
	TCHAR sz[MAX_PATH];
	if (0 != gethostname(sz, CCHMAX(sz)))
	{
		WARNING_OUT(("FLocalIpAddress: gethostname failed? err=%s", PszWSALastError()));
		return FALSE;
	}

	HOSTENT * pHostInfo = gethostbyname(sz);
	if (NULL == pHostInfo)
	{
		WARNING_OUT(("FLocalIpAddress: gethostbyname failed? err=%s", PszWSALastError()));
		return FALSE;
	}

	return (dwIP == *(DWORD *) pHostInfo->h_addr);
}


/*	F  I P	A D D R E S S  */
/*-------------------------------------------------------------------------
	%%Function: FIpAddress

	Return TRUE if the string is in the form:  a.b.c.d
	where a,b,c,d < 256.

	Note that inet_addr returns success on strings like "55534" and "3102.550"

	FUTURE: Return the converted DWORD
-------------------------------------------------------------------------*/
BOOL FIpAddress(LPCTSTR pcsz)
{
	TCHAR ch;
	int cPeriods = 0;
	int uVal = 0;

	ASSERT(NULL != pcsz);
	while (_T('\0') != (ch = *pcsz++))
	{
		switch (ch)
		{
		case _T('0'):
		case _T('1'):
		case _T('2'):
		case _T('3'):
		case _T('4'):
		case _T('5'):
		case _T('6'):
		case _T('7'):
		case _T('8'):
		case _T('9'):
			uVal = (uVal *= 10) + (ch - _T('0'));
			if (uVal > 255)
				return FALSE;
			break;

		case _T('.'):
			cPeriods++;
			uVal = 0;
			break;

		default:
			return FALSE;
		} /* switch (ch) */
	}
	return (3 == cPeriods);
}


VOID DisplayCallError(HRESULT hr, LPCTSTR pcszName)
{
	int ids;

	WARNING_OUT(("DisplayCallError pcsz=[%s] err=%s", pcszName, PszHResult(hr)));

	switch (hr)
		{
	case S_OK:
	case S_FALSE:
		return; // no error

	default:
	case E_FAIL:
		WARNING_OUT(("DisplayCallError - message is not very informative. HRESULT=%08X", hr));
		// fall thru to IDS_RESOLVE_FAILED
	case NM_CALLERR_NAME_RESOLUTION:
		ids = IDS_RESOLVE_FAILED;
		break;

	case NM_CALLERR_NOT_INITIALIZED:
	case NM_CALLERR_NOT_FOUND:
		ids = IDS_COULD_NOT_INVITE;
		break;

	case NM_CALLERR_LOOPBACK:
		ids = IDS_CALL_LOOPBACK;
		break;

	case NM_CALLERR_ALREADY_CALLING:
		ids = IDS_ALREADY_CALLING;
		break;

	case E_OUTOFMEMORY:
		ids = IDS_ULSLOGON_OUTOFMEMORY;
		break;

	case NM_CALLERR_INVALID_PHONE_NUMBER:
		ids = IDS_CALLERR_E_BAD_PHONE_NUMBER;
		break;

	case NM_CALLERR_NO_PHONE_SUPPORT:
		ids = IDS_CALLERR_E_NO_PHONE_SUPPORT;
		break;

	case NM_CALLERR_INVALID_IPADDRESS:
		ids = IDS_CALLERR_E_BAD_IPADDRESS;
		break;

	case NM_CALLERR_HOST_RESOLUTION_FAILED:
		ids = IDS_CALLERR_E_BAD_HOSTNAME;
		break;

	case NM_CALLERR_NO_ILS:
		ids = IDS_CALLERR_E_NO_ILS;
		break;

	case NM_CALLERR_ILS_RESOLUTION_FAILED:
		ids = IDS_CALLERR_E_ILS_RESOLUTION_FAILED;
		break;

	case NM_CALLERR_NO_ADDRESS:
		ids = IDS_CALLERR_E_NO_ADDRESS;
		break;

	case NM_CALLERR_INVALID_ADDRESS:
		ids = IDS_CALLERR_E_INVALID_ADDRESS;
		break;

	case NM_CALLERR_NO_GATEKEEPER:
		ids = IDS_CALLERR_E_NO_GATEKEEPER;
		break;

	case NM_CALLERR_NOT_REGISTERED:
		ids = IDS_GK_NOT_REGISTERED;
		break;

	case NM_CALLERR_NO_GATEWAY:
		ids = IDS_CALLERR_E_NO_GATEWAY;
		break;

	case NM_CALLERR_PARAM_ERROR:
		ids = IDS_CALLERR_E_PARAM_ERROR;
		break;

	case NM_CALLERR_SECURITY_MISMATCH:
		ids = IDS_CALLERR_E_SECURITY_MISMATCH;
		break;

	case NM_CALLERR_UNESCAPE_ERROR:
		ids = IDS_CALLERR_E_UNESCAPE_ERROR;
		break;

	case NM_CALLERR_IN_CONFERENCE:
		ids = IDS_INVITE_DENIED_REMOTE_CONF;
		break;
		}

	DisplayMsgIdsParam(ids, pcszName);
}

///////////////////////////////////////////////////////////////////////
// Gateway utility routines


/*	G E T  D E F A U L T  G A T E W A Y  */
/*-------------------------------------------------------------------------
	%%Function: GetDefaultGateway
	
-------------------------------------------------------------------------*/
int GetDefaultGateway(LPTSTR psz, UINT cchMax)
{
	RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// Make sure it's enabled
	if (0 == re.GetNumber(REGVAL_USE_H323_GATEWAY, DEFAULT_USE_H323_GATEWAY))
	{
		SetEmptySz(psz);
		return 0;
	}

	lstrcpyn(psz, re.GetString(REGVAL_H323_GATEWAY), cchMax);
	return lstrlen(psz);
}

BOOL FH323GatewayEnabled(VOID)
{
	if (!::FIsAudioAllowed())
		return FALSE;

	TCHAR sz[MAX_PATH];
	return 0 != GetDefaultGateway(sz, CCHMAX(sz));
}




/*	C R E A T E  G A T E W A Y	A D D R E S S  */
/*-------------------------------------------------------------------------
	%%Function: CreateGatewayAddress

	Create a gateway address in the form: gateway/address
	e.g. "157.59.0.40/65000"
-------------------------------------------------------------------------*/
HRESULT CreateGatewayAddress(LPTSTR pszResult, UINT cchMax, LPCTSTR pszAddr)
{
	int cch = GetDefaultGateway(pszResult, cchMax);
	if (0 == cch)
		return E_FAIL;
	if (cchMax <= (UINT) (cch + 1 + lstrlen(pszAddr)))
		return E_FAIL;

	*(pszResult+cch) = _T('/');

	pszResult += cch+1;
	lstrcpy(pszResult, pszAddr);
	return S_OK;
}


///////////////////////////////////////////////////////////////////////
// Gatekeeper utility routines

NM_GK_STATE g_GkLogonState = NM_GK_NOT_IN_GK_MODE;

BOOL FGkEnabled(VOID)
{
	return ( ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() );
}


inline bool ISE164CHAR(TCHAR digit)
{
	if ((digit >= '0') && (digit <= '9'))
	{
		return true;
	}
	if ((digit == '#') || (digit == '*'))
	{
		return true;
	}

	return false;
}

// removes non E-164 chars from a phone number string
int CleanupE164String(LPTSTR szPhoneNumber)
{
	int nLength;
	int nIndex, nIndexWrite;

	if ((szPhoneNumber == NULL) || (szPhoneNumber[0] == '\0'))
	{
		return 0;
	}

	nIndexWrite = 0;
	nLength  = lstrlen(szPhoneNumber);
	for (nIndex = 0; nIndex < nLength; nIndex++)
	{
		if (ISE164CHAR(szPhoneNumber[nIndex]))
		{
			if (nIndex != nIndexWrite)
			{
				szPhoneNumber[nIndexWrite] = szPhoneNumber[nIndex];
			}
			nIndexWrite++;
		}
	}

	szPhoneNumber[nIndexWrite] = '\0';

	return nIndexWrite;  // length of the new string
}


// removes non E-164 & non-comma chars from a phone number string
int CleanupE164StringEx(LPTSTR szPhoneNumber)
{
	int nLength;
	int nIndex, nIndexWrite;

	if ((szPhoneNumber == NULL) || (szPhoneNumber[0] == '\0'))
	{
		return 0;
	}

	nIndexWrite = 0;
	nLength  = lstrlen(szPhoneNumber);
	for (nIndex = 0; nIndex < nLength; nIndex++)
	{
		if (ISE164CHAR(szPhoneNumber[nIndex]) || (szPhoneNumber[nIndex] == ',') )
		{
			if (nIndex != nIndexWrite)
			{
				szPhoneNumber[nIndexWrite] = szPhoneNumber[nIndex];
			}
			nIndexWrite++;
		}
	}

	szPhoneNumber[nIndexWrite] = '\0';

	return nIndexWrite;  // length of the new string
}


static bool _CanLogonToGk()
{
	return (NULL != g_pNmSysInfo) &&
		   FGkEnabled() &&
		   ( ( NM_GK_IDLE == g_GkLogonState ) || ( NM_GK_NOT_IN_GK_MODE == g_GkLogonState ) );

}

void GkLogon(void)
{
	if(_CanLogonToGk())
	{
			// In case the logon fails, we set this to idle
		SetGkLogonState(NM_GK_IDLE);

		RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
		LPCTSTR pszServer = reConf.GetString(REGVAL_GK_SERVER);
	
		g_pCCallto->SetGatekeeperName( pszServer );

		RegEntry		reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
		LPTSTR			  pszAliasID = NULL;
		LPTSTR			  pszAliasE164 = NULL;

		ConfPolicies::eGKAddressingMode    mode = ConfPolicies::GKAddressing_Invalid;

		mode = ConfPolicies::GetGKAddressingMode();

		if( (ConfPolicies::GKAddressing_PhoneNum == mode) || (ConfPolicies::GKAddressing_Both == mode) )
		{
			pszAliasE164 = PszAlloc(reULS.GetString( REGVAL_ULS_PHONENUM_NAME ));

			CleanupE164String(pszAliasE164);
		}

		if( (ConfPolicies::GKAddressing_Account == mode) || (ConfPolicies::GKAddressing_Both == mode) )
		{	
			pszAliasID = PszAlloc(reULS.GetString( REGVAL_ULS_GK_ACCOUNT ));
		}

		HRESULT hr = g_pNmSysInfo->GkLogon(CComBSTR(pszServer),
							CComBSTR(pszAliasID ? pszAliasID : g_szEmpty),
							CComBSTR(pszAliasE164 ? pszAliasE164 : g_szEmpty));

		delete pszAliasID;
		delete pszAliasE164;
		
		if( SUCCEEDED( hr ) )
		{
			SetGkLogonState(NM_GK_LOGGING_ON);
		}
		else
		{
			PostConfMsgBox(IDS_ERR_GK_NOT_FOUND);
		}
	}
}

void GkLogoff(void)
{
	if (NULL != g_pNmSysInfo)
	{
		g_pNmSysInfo->GkLogoff();
	}

	SetGkLogonState( NM_GK_IDLE );
}


bool IsGatekeeperLoggedOn(void)
{
	return ( NM_GK_LOGGED_ON == g_GkLogonState );

}

bool IsGatekeeperLoggingOn(void)
{
	return ( NM_GK_LOGGING_ON == g_GkLogonState );
}


void SetGkLogonState( NM_GK_STATE state )
{

	if( FGkEnabled() )
	{
		if( g_GkLogonState != state )
		{
				// Set the new state
			g_GkLogonState = state;
		}
	}
	else
	{	
			// We are not in GK mode anymore
		g_GkLogonState = NM_GK_NOT_IN_GK_MODE;
	}

	::UpdateUI(CRUI_STATUSBAR, TRUE);

	g_pCCallto->SetGatekeeperEnabled( IsGatekeeperLoggedOn() || IsGatekeeperLoggingOn() );
}



CCallResolver::CCallResolver(LPCTSTR pszAddr, NM_ADDR_TYPE addrType) :
	m_pszAddr(PszAlloc(pszAddr)),
	m_pszAddrIP(NULL),
	m_addrType(addrType)
{
}

CCallResolver::~CCallResolver()
{
	delete m_pszAddr;
	delete m_pszAddrIP;
}

///////////////////////////////////////////////////////////////////////////
// Name Resolution

HRESULT CCallResolver::CheckHostEnt(HOSTENT * pHostInfo)
{
	// Only expecting IP addresses..
	if ((AF_INET != pHostInfo->h_addrtype) || (sizeof(DWORD) != pHostInfo->h_length))
	{
		WARNING_OUT(("CCallResolver: %08X CheckHostEnt - address type=%d",this, pHostInfo->h_addrtype));
		return E_FAIL;
	}

	struct in_addr inAddr;
	inAddr.s_addr = *((DWORD *)pHostInfo->h_addr);
	if (FLocalIpAddress(inAddr.s_addr))
	{
		WARNING_OUT(("CCallResolver: %08X CheckHostEnt - Attempted to call local machine", this));
		return NM_CALLERR_LOOPBACK;
	}

	m_pszAddrIP = PszAlloc(inet_ntoa(inAddr));
	if (NULL == m_pszAddrIP)
		return E_OUTOFMEMORY;

	return S_OK;
}


HRESULT CCallResolver::ResolveMachineName(LPCTSTR pcszAddr)
{
	TCHAR szOem[MAX_PATH];
	lstrcpyn(szOem, pcszAddr, CCHMAX(szOem));
	CharUpper(szOem);
	CharToOem(szOem, szOem);

	HOSTENT * pHostInfo = gethostbyname(szOem);
	if (NULL == pHostInfo)
	{
		WARNING_OUT(("CCallResolver: %08X ResolveMachineName(%s) gethostbyname failed. err=%s",
			this, szOem, PszWSALastError()));
		return NM_CALLERR_NAME_RESOLUTION;
	}

	return CheckHostEnt(pHostInfo);
}


HRESULT CCallResolver::ResolveUlsName(LPCTSTR pcszAddr)
{
	TCHAR szIP[MAX_PATH];
	TCHAR szServer[MAX_PATH];

	LPCTSTR pcsz = ExtractServerName(pcszAddr, szServer, CCHMAX(szServer));
	if (pcsz == pcszAddr)
		return NM_CALLERR_NAME_RESOLUTION;

	HRESULT hr = S_OK;
	if( SUCCEEDED( hr = CNmLDAP::ResolveUser( pcsz, szServer, szIP, CCHMAX( szIP ) ) ) )
	{		
		hr = ResolveIpName( szIP );
	}
	
	return hr;
}


HRESULT CCallResolver::ResolveIpName(LPCTSTR pcszAddr)
{
	DWORD dwIP = inet_addr(pcszAddr);
	if (INADDR_NONE == dwIP)
		return NM_CALLERR_NAME_RESOLUTION;

	char * pAddr = (char *) &dwIP;
	HOSTENT hostInfo;
	ClearStruct(&hostInfo);
	hostInfo.h_addrtype = AF_INET;
	hostInfo.h_length = sizeof(DWORD);
	hostInfo.h_addr_list = &pAddr;

	return CheckHostEnt(&hostInfo);
}

HRESULT CCallResolver::ResolveGateway(LPCTSTR pcszAddr)
{
	TCHAR szGateway[MAX_PATH];

	LPCTSTR pchSlash = _StrChr(pcszAddr, _T('/'));
	if (NULL == pchSlash)
	{
		WARNING_OUT(("CCallResolver: %08X ResolveGateway(%s) no separator?", this, pcszAddr));
		return NM_CALLERR_NAME_RESOLUTION;
	}

	lstrcpyn(szGateway, pcszAddr, (int)(1 + (pchSlash-pcszAddr)));
	return ResolveIpName(szGateway);
}



/*	R E S O L V E  */
/*-------------------------------------------------------------------------
	%%Function: Resolve

	Attempt to resolve the string into a standard IP address.
-------------------------------------------------------------------------*/
HRESULT CCallResolver::Resolve()
{
	DBGENTRY(CCallResolver::Resolve);

	HRESULT hr = E_FAIL;

	switch (m_addrType)
		{
	case NM_ADDR_UNKNOWN:
	{
		if (NULL != _StrChr(m_pszAddr, _T('/')))
		{
			if(SUCCEEDED(hr = ResolveUlsName(m_pszAddr)))
			{
				m_addrType = NM_ADDR_ULS;
			}
			break;
		}

		if (FIpAddress(m_pszAddr))
		{
			if(SUCCEEDED(hr = ResolveIpName(m_pszAddr)))
			{
				m_addrType = NM_ADDR_IP;
			}
			break;
		}

		if(SUCCEEDED(hr = ResolveMachineName(m_pszAddr)))
		{
			m_addrType = NM_ADDR_MACHINENAME;	
		}
		break;
	}

	case NM_ADDR_H323_GATEWAY:
	{
		LPTSTR pch = (LPTSTR) _StrChr(m_pszAddr, _T('/'));
		if (NULL != pch)
		{
			// Address is in the format: Gateway/address
			// e.g. "157.59.0.40/65000" or "efusion/65000"
			*pch = _T('\0');
			pch++;
			hr = ResolveIpName(m_pszAddr);
			if (FAILED(hr))
			{
				hr = ResolveMachineName(m_pszAddr);
				if (FAILED(hr))
				{
					break;
				}
			}
			LPTSTR pszNumber = PszAlloc(pch);
			delete m_pszAddr;
			m_pszAddr = pszNumber;
		}
		else
		{
			TCHAR sz[MAX_PATH];
			if (0 == GetDefaultGateway(sz, CCHMAX(sz)))
			{
				hr = E_FAIL;
				break;
			}
			hr = ResolveIpName(sz);
			if (FAILED(hr))
			{
				hr = ResolveMachineName(sz);
				if (FAILED(hr))
				{
					break;
				}
			}
		}
		
		hr = FEmptySz(m_pszAddr) ? E_INVALIDARG : S_OK;
		break;
	}

	case NM_ADDR_ULS:
		// Make sure the address is prefixed with an ILS server
		if (NULL == _StrChr(m_pszAddr, _T('/')))
		{
			TCHAR szAddr[CCHMAXSZ_ADDRESS];
			if (!FCreateIlsName(szAddr, NULL, m_pszAddr, CCHMAX(szAddr)))
			{
				hr = E_FAIL;
				break;
			}
			delete m_pszAddr;
			m_pszAddr = PszAlloc(szAddr);
		}

		hr = ResolveUlsName(m_pszAddr);
		break;

	case NM_ADDR_IP:
		hr = ResolveIpName(m_pszAddr);
		if (FAILED(hr) && (hr != NM_CALLERR_LOOPBACK) )
		{
			hr = ResolveMachineName(m_pszAddr);
		}
		break;

	case NM_ADDR_MACHINENAME:
		hr = ResolveMachineName(m_pszAddr);
		break;

	case NM_ADDR_ALIAS_ID:
	case NM_ADDR_ALIAS_E164:
	case NM_ADDR_T120_TRANSPORT:
		hr = FEmptySz(m_pszAddr) ? E_INVALIDARG : S_OK;
		break;

	default:
		WARNING_OUT(("Resolve: Unsupported address type %d", m_addrType));
		ASSERT(E_FAIL == hr);
		break;
	} /* switch (addrType) */

	WARNING_OUT(("CCallResolver::Resolve(%d,%s) result=%08X", m_addrType, m_pszAddrIP ? m_pszAddrIP : m_pszAddr, hr));

	DBGEXIT_HR(CCallResolver::Resolve, hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calllog.h ===
//
// CallLog.h
//
// Created:  ChrisPi   10-17-96
//

#ifndef _CALLLOG_H_
#define _CALLLOG_H_

#include <cstring.hpp>

// CCallLogEntry flags:
const DWORD CLEF_ACCEPTED =			0x00000001;
const DWORD CLEF_REJECTED =			0x00000002;
const DWORD CLEF_AUTO_ACCEPTED =	0x00000004; // call was auto-accepted
const DWORD CLEF_TIMED_OUT =		0x00000008; // call was rejected due to timeout
const DWORD CLEF_SECURE =           0x00000010; // call was secure

const DWORD CLEF_NO_CALL  =         0x40000000; // No call back information
const DWORD CLEF_DELETED  =         0x80000000; // Record marked for deletion


// The header for a record in the call log file
typedef struct _tagLogHdr {
	DWORD dwSize;              // size of this entire record
	DWORD dwCLEF;              // CallLogEntry Flags (CLEF_*)
	DWORD dwPF;                // Participant flags (PF_*)
	DWORD cbName;              // size of szName, in bytes, including NULL
	DWORD cbData;              // size of rgData, in bytes
	DWORD cbCert;              // size of certificate data in bytes
	SYSTEMTIME 	sysTime;       // date/time of record creation
//  WCHAR szName;              // null terminated display name (in UNICODE)
//  BYTE  ri[];                // Roster Information
} LOGHDR;
typedef LOGHDR * PLOGHDR;


class CCallLog;
class CRosterInfo;

class CCallLogEntry
{
protected:
	LPTSTR			m_pszName;
	DWORD			m_dwFlags;
	SYSTEMTIME		m_st;
	CRosterInfo*	m_pri;
	PBYTE           m_pbCert;
	ULONG           m_cbCert;
	DWORD           m_dwFileOffset; // offset in log file

	friend		CCallLog;
public:
	CCallLogEntry(LPCTSTR pcszName, DWORD dwFlags, CRosterInfo* pri,
				LPVOID pvRosterData, PBYTE pbCert, ULONG cbCert, LPSYSTEMTIME pst, DWORD dwFileOffset);
	~CCallLogEntry();

	LPTSTR			GetName()		{ return m_pszName;		};
	DWORD			GetFlags()		{ return m_dwFlags;		};
	LPSYSTEMTIME	GetTime()		{ return &m_st;			};
	CRosterInfo*	GetRosterInfo()	{ return m_pri;			};
	DWORD			GetFileOffset()	{ return m_dwFileOffset;};
};



class CCallLog : public CSimpleArray<CCallLogEntry*>
{
private:
	BOOL    m_fUseList;            // if TRUE, add data to list
	BOOL    m_fDataRead;           // if TRUE, data has been read
	CSTRING m_strFile;             // Filename
	DWORD   m_Expire;              // Days before expiring an entry

	int		m_cTotalEntries;		// Total number of records in the log
	int		m_cDeletedEntries;		// Number of records marked for deletion
	int		m_cMaxEntries;			// Configurable max entries in file

	VOID    InitLogData(LPCTSTR pszKey, LPCTSTR pszDefault);
	HANDLE  OpenLogFile(VOID);
	BOOL    ReadData(HANDLE hFile, PVOID pv, UINT cb);
	HRESULT WriteData(HANDLE hFile, LPDWORD pdwOffset, PVOID pv, DWORD cb);
	HRESULT ReadEntry(HANDLE hFile, DWORD * pdwFileOffset, CCallLogEntry** ppcle);
	DWORD   WriteEntry(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert);
	VOID    LoadFileData(VOID);
	VOID	RewriteFile(VOID);

public:
	CCallLog(LPCTSTR pszKey, LPCTSTR pszDefault);
	~CCallLog();

	HRESULT  AddCall(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert);

private:
	HRESULT  DeleteEntry(CCallLogEntry * pcle);
};

#endif // !_CALLLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\callingbar.h ===
/****************************************************************************
*
*    FILE:     CallingBar.h
*
*    CREATED:  George Pitt 1-22-99
*
****************************************************************************/

#ifndef _CALLINGBAR_H_
#define _CALLINGBAR_H_

#include "GenContainers.h"
#include "GenControls.h"
#include "ConfUtil.h"

class CConfRoom;
struct RichAddressInfo;

// We are making some changes specifically for OSR2 beta, but we should rip them out afterwards
#define OSR2LOOK

class CCallingBar : public CToolbar, public IComboBoxChange
{
public:
	CCallingBar();

	BOOL Create(CGenWindow *pParent, CConfRoom *pConfRoom);

    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
	{
		return(CToolbar::QueryInterface(riid, ppvObject));
	}
    
    virtual ULONG STDMETHODCALLTYPE AddRef( void)
	{
		return(CToolbar::AddRef());
	}
    
    virtual ULONG STDMETHODCALLTYPE Release( void)
	{
		return(CToolbar::Release());
	}

	virtual void OnTextChange(CComboBox *pEdit);
	virtual void OnFocusChange(CComboBox *pEdit, BOOL bSet);
	virtual void OnSelectionChange(CComboBox *pCombo);

	int GetText(LPTSTR szText, int nLen);
	void SetText(LPCTSTR szText);

protected:
	virtual ~CCallingBar();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT uCmd, WPARAM wParam, LPARAM lParam);

	virtual void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);

private:
	// A pointer back to the global ConfRoom object for some functionality
	CConfRoom *m_pConfRoom;
	// The last rich address we were given
	RichAddressInfo *m_pAddr;
	// The edit text control in the bar
	CComboBox *m_pEdit;
	ITranslateAccelerator *m_pAccel;
	// Last font set on the edit control
	BOOL m_bUnderline : 1;

	void SetEditFont(BOOL bUnderline, BOOL bForce=FALSE);
	void ClearAddr(RichAddressInfo **ppAddr);
	void ClearCombo();
	void OnNewAddress(RichAddressInfo *pAddr);
} ;

#endif // _CALLINGBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calllog.cpp ===
//
// CallLog.cpp
//
// Created:  ChrisPi   10-17-96
// Updated:  RobD      10-30-96
//
// ToDo:
// - Expire records
// - UI to delete record(s)
// - system policy?
//

#include "precomp.h"
#include "rostinfo.h"
#include "CallLog.h"
#include "particip.h"	// for MAX_PARTICIPANT_NAME
#include "ConfUtil.h"

#define	MAX_DELETED_ENTRIES_BEFORE_REWRITE	10
#define LARGE_ENTRY_SIZE	256

CCallLogEntry::CCallLogEntry(	LPCTSTR pcszName,
								DWORD dwFlags,
								CRosterInfo* pri,
								LPVOID pvRosterData,
								PBYTE pbCert,
								ULONG cbCert,
								LPSYSTEMTIME pst,
								DWORD dwFileOffset) :
	m_dwFlags		(dwFlags),
	m_pri			(NULL),
	m_pbCert        (NULL),
	m_cbCert        (0),
	m_dwFileOffset	(dwFileOffset)
{
	DebugEntry(CCallLogEntry::CCallLogEntry);
	ASSERT(NULL != pcszName);
	ASSERT(NULL != pst);
	// Only one of these two parameters should be non-NULL
	ASSERT((NULL == pvRosterData) || (NULL == pri));
	LPVOID pvData = pvRosterData;
	if (NULL != pri)
	{
		UINT cbData;
		if (SUCCEEDED(pri->Save(&pvData, &cbData)))
		{
			ASSERT(pvData);
		}
	}
	if (NULL != pvData)
	{
		m_pri = new CRosterInfo();
		if (NULL != m_pri)
		{
			m_pri->Load(pvData);
		}
	}
	if (NULL != pbCert && 0 != cbCert)
	{
	    m_pbCert = new BYTE[cbCert];
	    if (NULL == m_pbCert)
	    {
	        ERROR_OUT(("CCalllogEntry::CCalllogEntry() -- failed to allocate memory"));
	    }
            else
            {
                memcpy(m_pbCert, pbCert, cbCert);
                m_cbCert = cbCert;
            }
	}
	m_st = *pst;
	m_pszName = PszAlloc(pcszName);
	DebugExitVOID(CCallLogEntry::CCallLogEntry);
}

CCallLogEntry::~CCallLogEntry()
{
	DebugEntry(CCallLogEntry::~CCallLogEntry);
	delete m_pszName;
	// NOTE: m_pri must be new'ed by the function that calls the
	// constructor - this is an optimization to avoid unnecessary
	// copying - but it's a little unclean.
	delete m_pri;
	delete []m_pbCert;
	DebugExitVOID(CCallLogEntry::~CCallLogEntry);
}


/////////////////////////////////////////////////////////////////////////

CCallLog::CCallLog(LPCTSTR pszKey, LPCTSTR pszDefault) :
	m_fUseList  (FALSE),
	m_fDataRead (FALSE),
	m_cTotalEntries (0),
	m_cDeletedEntries (0)
{
	InitLogData(pszKey, pszDefault);
	TRACE_OUT(("Using Call Log file [%s]", m_strFile));
}


CCallLog::~CCallLog()
{
	DebugEntry(CCallLog::~CCallLog);

	// Check to see if we are more than a number entries over our
	// configured maximum and re-write the file if so

	TRACE_OUT(("Entry count: total:%d deleted:%d", m_cTotalEntries,
		m_cDeletedEntries));

	if ( m_fUseList && m_cDeletedEntries > MAX_DELETED_ENTRIES_BEFORE_REWRITE )
		RewriteFile();
	else
	{
		int	size	= GetSize();

		for( int i = 0; i < size; i++ )
		{
			ASSERT( NULL != (*this)[i] );
			delete (*this)[i];
		}
	}

	DebugExitVOID(CCallLog::~CCallLog);
}


/*  A D D  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: AddCall

-------------------------------------------------------------------------*/
HRESULT CCallLog::AddCall(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert)
{
TRACE_OUT( ("CCallLog::AddCall(\"%s\")", pcszName) );
	DWORD dwFileOffset;
	HRESULT hr = S_OK;

	ASSERT(NULL != pLogHdr);

	// Grab the current local time
	::GetLocalTime(&(pLogHdr->sysTime));

	ApiDebugMsg(("CALL_LOG: [%s] %s", pcszName,
			(pLogHdr->dwCLEF & CLEF_ACCEPTED) ? "ACCEPTED" : "REJECTED"));

	// Append the data to the file
	dwFileOffset = WriteEntry(pcszName, pLogHdr, pri, pbCert, cbCert);

	TRACE_OUT(("AddCall: adding entry with %d total, %d deleted, %d max",
		m_cTotalEntries, m_cDeletedEntries, m_cMaxEntries ));

	// Create list entry only when necessary
	if (m_fUseList)
	{
		CCallLogEntry* pcleNew = new CCallLogEntry(	pcszName,
					pLogHdr->dwCLEF, pri, NULL, pbCert, cbCert, &(pLogHdr->sysTime), dwFileOffset);

		if (NULL == pcleNew)
			return E_OUTOFMEMORY;

		Add(pcleNew);

		m_cTotalEntries++;

		// Check to see if this put us over the top of valid entries
		// and remove the oldest entry if so

		if ( m_cTotalEntries - m_cDeletedEntries > m_cMaxEntries )
		{
			// Remove oldest entry
			DeleteEntry((*this)[0]);
			RemoveAt( 0 );
		}
	}
	else
	{
		// Check to see if the file is getting large based on
		// our target number of entries and a heuristic large
		// entry size. If our file has grown over this point, load
		// the file and trim the list so that we will re-write
		// a smaller file on exit.

		TRACE_OUT(("Checking file size %d against %d * %d",
			dwFileOffset, m_cMaxEntries, LARGE_ENTRY_SIZE));

		if ( dwFileOffset > (DWORD)( m_cMaxEntries * LARGE_ENTRY_SIZE ) )
		{
			TRACE_OUT(("Log file getting large, forcing LoadFileData"));

			LoadFileData();
		}
	}

	return S_OK;
}

/*  I N I T  L O G  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: InitLogData

    Get the log data from the registry.
    - the expiration information
    - the file name (with path)
    If there is no entry for the file name, a new, unique file is created.
-------------------------------------------------------------------------*/
VOID CCallLog::InitLogData(LPCTSTR pszKey, LPCTSTR pszDefault)
{
	TCHAR  szPath[MAX_PATH];
	PTSTR  pszFileName;
	HANDLE hFile;

	ASSERT(m_strFile.IsEmpty());

	RegEntry reLog(pszKey, HKEY_CURRENT_USER);

	m_Expire = reLog.GetNumber(REGVAL_LOG_EXPIRE, 0);
		
	m_strFile = reLog.GetString(REGVAL_LOG_FILE);

	m_cMaxEntries = reLog.GetNumber(REGVAL_LOG_MAX_ENTRIES,
								DEFAULT_LOG_MAX_ENTRIES );

	TRACE_OUT(("Max Entries set to %d", m_cMaxEntries ));

	// Make sure file exists and can be read/written
	hFile = OpenLogFile();
	if (NULL != hFile)
	{
		// valid file found
		CloseHandle(hFile);
		return;
	}
	// String is invalid (or empty) - make sure it's empty
	m_strFile.Empty();
	
	// Create the new log file in the NetMeeting directory
	if (!GetInstallDirectory(szPath))
	{
		WARNING_OUT(("InitLogData: Unable to get Install Directory?"));
		return;
	}
	pszFileName = &szPath[lstrlen(szPath)];

	// Try to use the default name
	wsprintf(pszFileName, TEXT("%s%s"), pszDefault, TEXT(".dat"));

	hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		// Use a unique name to avoid other users' files
		for (int iFile = 2; iFile < 999; iFile++)
		{
			wsprintf(pszFileName, TEXT("%s%d.dat"), pszDefault, iFile);

			hFile = CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
				NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

			if (INVALID_HANDLE_VALUE != hFile)
				break;

			switch (GetLastError())
				{
			case ERROR_FILE_EXISTS:     // We get this with NT
			case ERROR_ALREADY_EXISTS:  // and this with Win95
				break;
			default:
				WARNING_OUT(("Unable to create log file [%s] err=0x%08X", szPath, GetLastError()));
				break;
				} /* switch (GetLastError()) */
		}
	}

	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		m_strFile = szPath;
		reLog.SetValue(REGVAL_LOG_FILE, szPath);
	}
}


/*  O P E N  L O G  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: OpenLogFile

    Open the log file and return a handle to file.
    Return NULL if there was a problem.
-------------------------------------------------------------------------*/
HANDLE CCallLog::OpenLogFile(VOID)
{
	HANDLE   hFile;

	if (m_strFile.IsEmpty())
	{
		WARNING_OUT(("Problem opening call log file"));
		return NULL;
	}

	hFile = CreateFile(m_strFile, GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
		OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		ERROR_OUT(("OpenLogFile: Unable to open call log file"));
		hFile = NULL;
	}

	return hFile;
}


/*  R E A D  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: ReadData

-------------------------------------------------------------------------*/
BOOL CCallLog::ReadData(HANDLE hFile, PVOID pv, UINT cb)
{
	DWORD cbRead;

	ASSERT(NULL != hFile);
	ASSERT(NULL != pv);

	if (0 == cb)
		return TRUE;

	if (!ReadFile(hFile, pv, cb, &cbRead, NULL))
		return FALSE;

	return (cb == cbRead);
}



/*  W R I T E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: WriteData

    Write the data to the file.
    The file will be automatically opened/close if hFile is NULL.
-------------------------------------------------------------------------*/
HRESULT CCallLog::WriteData(HANDLE hFile, LPDWORD pdwOffset, PVOID pv, DWORD cb)
{
	HRESULT hr = E_FAIL;
	HANDLE  hFileTemp = NULL;
	DWORD   cbWritten;

	if (0 == cb)
		return S_OK; // nothing to do

	ASSERT(NULL != pv);
	ASSERT(NULL != pdwOffset);
	ASSERT(INVALID_FILE_SIZE != *pdwOffset);

	if (NULL == hFile)
	{
		// Auto-open the file, if necessary
		hFileTemp = OpenLogFile();
		if (NULL == hFileTemp)
			return E_FAIL;
		hFile = hFileTemp;
	}
	ASSERT(INVALID_HANDLE_VALUE != hFile);


	if (INVALID_FILE_SIZE != SetFilePointer(hFile, *pdwOffset, NULL, FILE_BEGIN))
	{
		if (WriteFile(hFile, pv, cb, &cbWritten, NULL) && (cb == cbWritten))
		{
			*pdwOffset += cbWritten;
			hr = S_OK;
		}
	}

	if (NULL != hFileTemp)
	{
		// Close the temporary file handle
		CloseHandle(hFileTemp);
	}

	return hr;
}



/*  W R I T E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: WriteEntry

    Write a call log entry to the end of the log file.
    The function returns the file position at which the data was written
    or INVALID_FILE_SIZE (0xFFFFFFFF) if there was a problem.
-------------------------------------------------------------------------*/
DWORD CCallLog::WriteEntry(LPCTSTR pcszName, PLOGHDR pLogHdr, CRosterInfo* pri, PBYTE pbCert, ULONG cbCert)
{
	PVOID  pvData;
	HANDLE hFile;
	DWORD  dwFilePosition;
	DWORD  dwPos;
	PWSTR  pcwszName;

	USES_CONVERSION;

	ASSERT(NULL != pcszName);
	ASSERT(NULL != pLogHdr);

	hFile = OpenLogFile();
	if (NULL == hFile)
		return INVALID_FILE_SIZE;

	dwFilePosition = SetFilePointer(hFile, 0, NULL, FILE_END);
	if (INVALID_FILE_SIZE != dwFilePosition)
	{
		dwPos = dwFilePosition;

		// Always write display name in UNICODE
		pcwszName = T2W(pcszName);
		pLogHdr->cbName = (lstrlenW(pcwszName) + 1) * sizeof(WCHAR);

		if ((NULL == pri) ||
			(!SUCCEEDED(pri->Save(&pvData, (UINT *) &(pLogHdr->cbData)))) )
		{
			// No data?
			pLogHdr->cbData = 0;
			pvData = NULL;
		}
		pLogHdr->cbCert = cbCert;
		
		// Calculate total size of record
		pLogHdr->dwSize = sizeof(LOGHDR) + pLogHdr->cbName + pLogHdr->cbData + pLogHdr->cbCert;

		if ((S_OK != WriteData(hFile, &dwPos, pLogHdr,   sizeof(LOGHDR)))  ||
			(S_OK != WriteData(hFile, &dwPos, pcwszName, pLogHdr->cbName)) ||
			(S_OK != WriteData(hFile, &dwPos, pvData,    pLogHdr->cbData)) ||
			(S_OK != WriteData(hFile, &dwPos, pbCert,    cbCert)))
		{
			dwFilePosition = INVALID_FILE_SIZE;
		}
	}

	CloseHandle(hFile);

	return dwFilePosition;
}


/*  R E A D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: ReadEntry

    Read the next entry from the file.
    *ppcle will be set to NULL if the entry was deleted.

    Return Values:
    	S_OK    - data was read successfully
    	S_FALSE - data exists, but was deleted
    	E_FAIL  - problem reading file
-------------------------------------------------------------------------*/
HRESULT CCallLog::ReadEntry(HANDLE hFile, DWORD * pdwFileOffset, CCallLogEntry** ppcle)
{
	DWORD   dwOffsetSave;
	LOGHDR  logHdr;
	WCHAR   wszName[MAX_PARTICIPANT_NAME];
	USES_CONVERSION;

	ASSERT(NULL != ppcle);
	ASSERT(NULL != hFile);
	ASSERT(NULL != pdwFileOffset);
	*ppcle = NULL; // initialize this in case we return with an error

	dwOffsetSave = *pdwFileOffset;
	if (INVALID_FILE_SIZE == SetFilePointer(hFile, dwOffsetSave, NULL, FILE_BEGIN))
		return E_FAIL;


	// Read record header
	if (!ReadData(hFile, &logHdr, sizeof(LOGHDR)) )
		return E_FAIL;

	// Return pointer to end of record
	*pdwFileOffset += logHdr.dwSize;

	if (logHdr.dwCLEF & CLEF_DELETED)
	{
		// Skip deleted record
		ASSERT(NULL == *ppcle);
		return S_FALSE;
	}
	
	if (logHdr.cbName > sizeof(wszName))
		logHdr.cbName = sizeof(wszName);


	// Read Name
	if (!ReadData(hFile, wszName, logHdr.cbName))
		return E_FAIL;

	// Read Extra Data
	PVOID pvData = NULL;
	if (logHdr.cbData != 0)
	{
		pvData = new BYTE[logHdr.cbData];
		if (NULL != pvData)
		{
			if (!ReadData(hFile, pvData, logHdr.cbData))
			{
				WARNING_OUT(("Problem reading roster data from log"));
			}
		}
	}

        PBYTE pbCert = NULL;
        if ((logHdr.dwCLEF & CLEF_SECURE ) && logHdr.cbCert != 0)
        {
            pbCert = new BYTE[logHdr.cbCert];
            if (NULL != pbCert)
            {
                if (!ReadData(hFile, pbCert, logHdr.cbCert))
                {
                    WARNING_OUT(("Problem reading certificate data from log"));
                }
            }
        }
	// Create the new log entry from the data read
	*ppcle = new CCallLogEntry(W2T(wszName), logHdr.dwCLEF,
								NULL, pvData, pbCert, logHdr.cbCert, &logHdr.sysTime, dwOffsetSave);
	delete pvData;
        delete []pbCert;
	return S_OK;
}


/*  L O A D  F I L E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: LoadFileData

    Load the call log data from the file
-------------------------------------------------------------------------*/
VOID CCallLog::LoadFileData(VOID)
{
	HANDLE hFile;
	DWORD  dwFileOffset;
	CCallLogEntry * pcle;

	hFile = OpenLogFile();
	if (NULL == hFile)
		return;

	m_cTotalEntries = 0;
	m_cDeletedEntries = 0;

	dwFileOffset = 0;
	while (E_FAIL != ReadEntry(hFile, &dwFileOffset, &pcle))
	{
		m_cTotalEntries++;

		if (NULL == pcle)
		{
			m_cDeletedEntries++;
			continue;  // deleted record
		}

		Add(pcle);

		TRACE_OUT(("Read Entry: \"%s\" (%02d/%02d/%04d %02d:%02d:%02d) : %s",
						pcle->m_pszName,
						pcle->m_st.wMonth, pcle->m_st.wDay, pcle->m_st.wYear,
						pcle->m_st.wHour, pcle->m_st.wMinute, pcle->m_st.wSecond,
						(CLEF_ACCEPTED & pcle->m_dwFlags) ? "ACCEPTED" : "REJECTED"));
	}

	CloseHandle(hFile);

	m_fUseList = TRUE;
	m_fDataRead = TRUE;

	// Now trim the list down to our configured maximum if
	// the count exceeds our target. The file will be compacted
	// when we write it out if we have more than a few deleted
	// entries.

	for( int nn = 0, delCount = m_cTotalEntries - m_cDeletedEntries - m_cMaxEntries; nn < delCount; nn++ )
	{
		DeleteEntry((*this)[0]);
		RemoveAt( 0 );
	}
}

/*  R E W R I T E   F I L E  */
/*-------------------------------------------------------------------------
    %%Function: RewriteFile

    Re-write the log file from the in-memory list, compress deleted entries
-------------------------------------------------------------------------*/
VOID CCallLog::RewriteFile(VOID)
{
	HANDLE hFile;

	TRACE_OUT(("Rewriting log file"));

	// Make sure we don't nuke the file without a list to write out
	ASSERT(m_fUseList);

	// Reset the file pointer and write the EOF marker
	if (!m_strFile.IsEmpty())
	{
		hFile = OpenLogFile();

		if (NULL != hFile)
		{
			if (INVALID_FILE_SIZE != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
			{
				SetEndOfFile(hFile);
				m_cTotalEntries = 0;
				m_cDeletedEntries = 0;
			}
			CloseHandle(hFile);
		}
	}

	// Write out all non-deleted records
	for( int i = 0; i < GetSize(); ++i )
	{
		
		CCallLogEntry* pcle = (*this)[i];
		ASSERT(NULL != pcle);

		LOGHDR LogHdr;

		// Initialize LogHdr items from memory object
		LogHdr.dwCLEF = pcle->GetFlags();
		LogHdr.dwPF = 0;
		LogHdr.sysTime = *pcle->GetTime();

		// Write out entry
		WriteEntry( pcle->m_pszName,
					&LogHdr,
					pcle->m_pri,
					pcle->m_pbCert,
					pcle->m_cbCert);

		delete pcle;
	}
}


// Grumble... Inefficient
HRESULT CCallLog::DeleteEntry(CCallLogEntry * pcle)
{
	HRESULT hr;
	DWORD   dwFlags;
	DWORD   dwOffset;

	if (NULL == pcle)
	{
		WARNING_OUT(("DeleteEntry: Unable to find entry"));
		return E_FAIL;
	}

	// Calculate offset to "CLEF"
	dwOffset = pcle->GetFileOffset() + offsetof(LOGHDR, dwCLEF);

	dwFlags = pcle->GetFlags() | CLEF_DELETED;
	hr = WriteData(NULL, &dwOffset, &dwFlags, sizeof(DWORD));

	m_cDeletedEntries++;

	TRACE_OUT(("Marked [%s] pos=%08X for deletion", pcle->GetName(), pcle->GetFileOffset() ));

	delete pcle;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\callto.cpp ===
#include	"precomp.h"
#include	"call.h"
#include	"callto.h"
#include	"conf.h"
#include	"confroom.h"
#include	"confpolicies.h"
#include	"confutil.h"
#include	"nmldap.h"


const int	CCallto::s_iMaxCalltoLength		= 255;
const int	CCallto::s_iMaxAddressLength	= 255;

//--------------------------------------------------------------------------//
//	CCallto::CCallto.														//
//--------------------------------------------------------------------------//
CCallto::CCallto(void):
	m_bUnescapedAddressOnly( false ),
	m_ulDestination( INADDR_NONE ),
	m_bGatekeeperEnabled( false ),
	m_pszGatekeeperName( NULL ),
	m_ulGatekeeperAddress( INADDR_NONE ),
	m_bGatewayEnabled( false ),
	m_pszGatewayName( NULL ),
	m_ulGatewayAddress( INADDR_NONE ),
	m_pszDefaultIlsServerName( NULL ),
	m_pszCalltoBuffer( NULL ),
	m_pszDisplayName( NULL )
{
}	//	End of CCallto::CCallto.


//--------------------------------------------------------------------------//
//	CCallto::~CCallto.														//
//--------------------------------------------------------------------------//
CCallto::~CCallto(void)
{
	delete [] m_pszGatekeeperName;
	delete [] m_pszGatewayName;
	delete [] m_pszDefaultIlsServerName;
	delete [] m_pszCalltoBuffer;
	delete [] m_pszDisplayName;

}	//	End of CCallto::~CCallto.


//--------------------------------------------------------------------------//
//	CCallto::Callto.														//
//--------------------------------------------------------------------------//
HRESULT CCallto::Callto
(
	const TCHAR * const	pszCallto,				//	pointer to the callto url to try to place the call with...
	const TCHAR * const	pszDisplayName,			//	pointer to the display name to use...
	const NM_ADDR_TYPE	nmType,					//	callto type to resolve this callto as...
	const bool			bAddressOnly,			//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
	const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
	const bool			bAddToMru,				//	whether or not save in mru...
	const bool			bUIEnabled,				//	whether or not to perform user interaction on errors...
	const HWND			hwndParent,				//	if bUIEnabled is true this is the window to parent error/status windows to...
	INmCall ** const	ppInternalCall			//	out pointer to INmCall * to receive INmCall * generated by placing call...
){
	ASSERT( pszCallto != NULL );
	ASSERT( (hwndParent == NULL) || IsWindow( hwndParent ) );

	HRESULT	hrResult;

	//	These members need to be reset at the beginning of every call...
	m_bUIEnabled			= bUIEnabled;
	m_hwndParent			= hwndParent;
	m_ulDestination			= INADDR_NONE;
	m_bUnescapedAddressOnly	= bAddressOnly;
	m_pszDisplayName		= PszAlloc( pszDisplayName );
	
	m_Parameters.SetParams( NULL );		//	Need to reset all parameter settings too...

	//	Process the callto...
	if( (hrResult = Parse( pszCallto )) == S_OK )
	{
		//	Validate that the security specified (if any) is compatible with current NM state.
		bool	bValidatedSecurity;

		if( (hrResult = GetValidatedSecurity( pbSecurityPreference, bValidatedSecurity )) == S_OK )
		{
			if( (hrResult = Resolve( nmType )) == S_OK )
			{
				hrResult = PlaceCall( pszCallto, bAddToMru, bValidatedSecurity, ppInternalCall );
			}
		}
	}

	if( FAILED( hrResult ) && m_bUIEnabled )
	{
		DisplayCallError( hrResult, (pszDisplayName != NULL)? pszDisplayName: pszCallto );
	}

	delete [] m_pszCalltoBuffer;
	delete [] m_pszDisplayName;
	m_pszCalltoBuffer	= NULL;
	m_pszDisplayName	= NULL;

	return( hrResult );

}	//	End of CCallto::Callto.


//--------------------------------------------------------------------------//
//	CCallto::Parse.															//
//--------------------------------------------------------------------------//
HRESULT CCallto::Parse
(
	const TCHAR * const	pszCallto	//	pointer to the callto url to parse...
){
	ASSERT( pszCallto != NULL );
	ASSERT( m_ulDestination == INADDR_NONE );

	HRESULT	hrResult;

	if( (m_pszCalltoBuffer = PszAlloc( pszCallto )) == NULL )	//	Make a copy that we can modify in place...
	{
		hrResult = E_OUTOFMEMORY;
	}
	else if( TrimSzCallto( m_pszCalltoBuffer ) == 0 )		//	Remove any leading/trailing blanks...
	{
		hrResult = NM_CALLERR_PARAM_ERROR;	//	Entire string was blanks...
	}
	else
	{
		hrResult = S_OK;

		m_pszParsePos = m_pszCalltoBuffer;

		if( !m_bUnescapedAddressOnly )
		{
			//	Skip over "callto:" or "callto://" which mean nothing to us now...
			static const TCHAR	pszCallto[]			= TEXT( "callto:" );
			static const TCHAR	pszDoubleSlash[]	= TEXT( "//" );

			if( StrCmpNI_literal( m_pszCalltoBuffer, pszCallto ) )
			{
				m_pszParsePos = m_pszCalltoBuffer + strlen_literal( pszCallto );

				if( StrCmpNI_literal( m_pszParsePos, pszDoubleSlash ) )
				{
					m_pszParsePos += strlen_literal( pszDoubleSlash );
				}
			}

			int	iLength	= lstrlen( m_pszCalltoBuffer );

			if( m_pszCalltoBuffer[ iLength - 1 ] == '/' )
			{
				m_pszCalltoBuffer[ iLength - 1 ] = '\0';	//	The shell seems to add a trailing slash before calling us...
			}
		}

		//	Break the callto into two pieces at the start of the parameters (if any)...
		m_pszParameters = StrChr( m_pszCalltoBuffer, '+' );

		if( m_pszParameters != NULL )
		{
			if( m_bUnescapedAddressOnly )
			{
				//	Sorry but '+' not allowed in addressing component...
				hrResult = NM_CALLERR_INVALID_ADDRESS;
			}
			else
			{
				*m_pszParameters++ = '\0';
			}
		}

		if( hrResult == S_OK )
		{
			//	Make sure we have something left before going on...
			if( m_pszParsePos[ 0 ] == '\0' )
			{
				hrResult = NM_CALLERR_NO_ADDRESS;
			}
			else
			{
				//	Not really a parsing thing but what we have at this point is conveiniently
				//	exactly what we want to use for a display name if one wasn't specified so
				//	save a copy of it before ParseAddress breaks it up into pieces...
				if( m_pszDisplayName == NULL )
				{
					m_pszDisplayName = PszAlloc( m_pszParsePos );
				}

				if( m_pszParameters != NULL )
				{
					//	Send the parameters off to be parsed...
					hrResult = m_Parameters.SetParams( m_pszParameters );
				}

				if( hrResult == S_OK )
				{
					//	Go parse the addressing component...
					hrResult = ParseAddress();
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::Parse.


//--------------------------------------------------------------------------//
//	CCallto::ParseAddress.													//
//--------------------------------------------------------------------------//
HRESULT CCallto::ParseAddress(void)
{
	ASSERT( m_pszCalltoBuffer != NULL );

	HRESULT	hrResult	= NM_CALLERR_INVALID_ADDRESS;

	if( m_Parameters.GetBooleanParam( TEXT( "h323" ), true ) && inGatekeeperMode() )
	{
		m_pszAddress	= m_pszParsePos;
		hrResult		= S_OK;			//	Bless you gatekeeper...
	}
	else if( StrChr( m_pszParsePos, '=' ) == NULL )		//	We're not going to allow the address component to contain an '='...
	{
		//	The address is allowed to be one of these formats...
		//		(1) string
		//		(2) server/email
		//		(3) server:port/email
		//	This means it may contain at most one ':', at most one '/',
		//	and given a ':', there must be a following '/'...

		TCHAR * const	pszColon	= StrChr( m_pszParsePos, ':' );
		TCHAR * const	pszSlash	= StrChr( m_pszParsePos, '/' );

		if( (pszSlash == NULL) && (pszColon == NULL) )
		{
			//	It's a valid simple (1) string format...
			m_pszAddress	= m_pszParsePos;
			m_pszIlsServer	= NULL;
			m_uiIlsPort		= DEFAULT_LDAP_PORT;
			m_pszEmail		= m_pszParsePos;

			if( m_bUnescapedAddressOnly )
			{
				hrResult = S_OK;	//	Done...
			}
			else
			{
				//	Need to unescape m_pszAddress but not m_pszEmail because it points to the same place...
				hrResult = Unescape( m_pszAddress );
			}
		}
		else if( (pszSlash != NULL) && (pszColon == NULL) )
		{
			if( StrChr( pszSlash + 1, '/' ) == NULL )
			{
				//	No colon and only one slash so it's a valid (2) format
				//	as long as each side is non zero length...
				if( (pszSlash > m_pszParsePos) && (lstrlen( pszSlash ) > 1) )
				{
					m_pszAddress	= TEXT( "" );
					m_pszIlsServer	= m_pszParsePos;
					m_uiIlsPort		= DEFAULT_LDAP_PORT;
					m_pszEmail		= pszSlash + 1;
					*pszSlash		= '\0';

					if( m_bUnescapedAddressOnly )
					{
						hrResult = S_OK;	//	Done...
					}
					else
					{
						if( (hrResult = Unescape( m_pszIlsServer )) == S_OK )
						{
							hrResult = Unescape( m_pszEmail );
						}
					}
				}
			}
		}
		else if( (pszSlash != NULL) && (pszColon != NULL) )
		{
			//	Make sure the ':' preceeds the '/' and there's only one of each...
			if( (pszColon < pszSlash) && (StrChr( pszSlash + 1, '/') == NULL) && (StrChr( pszColon + 1, ':' ) == NULL) )
			{
				//	One colon and one slash in the correct order so it's a valid (3) format as long
				//	as all three pieces are non zero length and the port piece is a number...
				if( (pszColon > m_pszParsePos) && (pszSlash > pszColon + 1) && (lstrlen( pszSlash ) > 1) )
				{
					//	We're not in gatekeeper mode so break it up into server, port, and email...
					m_pszAddress	= TEXT( "" );
					m_pszIlsServer	= m_pszParsePos;
					m_pszEmail		= pszSlash + 1;
					*pszColon		= '\0';
					*pszSlash		= '\0';

					if( m_bUnescapedAddressOnly )
					{
						hrResult = DecimalStringToUINT( pszColon + 1, m_uiIlsPort );
					}
					else
					{
						if( (hrResult = Unescape( m_pszIlsServer )) == S_OK )
						{
							if( (hrResult = Unescape( m_pszEmail )) == S_OK )
							{
								if( (hrResult = Unescape( pszColon + 1 )) == S_OK )
								{
									hrResult = DecimalStringToUINT( pszColon + 1, m_uiIlsPort );
								}
							}
						}
					}
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::ParseAddress.


//--------------------------------------------------------------------------//
//	CCallto::Resolve.														//
//--------------------------------------------------------------------------//
HRESULT CCallto::Resolve
(
	const NM_ADDR_TYPE	nmType		//	callto type to resolve this callto as...
){
	HRESULT	hrResult;

	//	First set our address type...

	if( (nmType != NM_ADDR_UNKNOWN) && (nmType != NM_ADDR_CALLTO) )
	{
		m_nmAddressType = nmType;
	}
	else
	{
		const TCHAR * const	pszType	= m_Parameters.GetParam( TEXT( "type" ), NULL );

		if( lstrcmpi( pszType, TEXT( "phone" ) ) == 0 )
		{
			m_nmAddressType = NM_ADDR_ALIAS_E164;
		}
		else if( lstrcmpi( pszType, TEXT( "ip" ) ) == 0 )
		{
			m_nmAddressType = NM_ADDR_IP;
		}
		else if( lstrcmpi( pszType, TEXT( "host" ) ) == 0 )
		{
			m_nmAddressType = NM_ADDR_MACHINENAME;
		}
		else if( lstrcmpi( pszType, TEXT( "directory" ) ) == 0 )
		{
			m_nmAddressType = NM_ADDR_ULS;
		}
		else
		{
			m_nmAddressType = NM_ADDR_UNKNOWN;
		}
	}

	//	Then see what we should do with it...

	if( m_Parameters.GetBooleanParam( TEXT( "h323" ), true ) && inGatekeeperMode() )
	{
		if (!IsGatekeeperLoggedOn() && !IsGatekeeperLoggingOn())
		{
			hrResult = NM_CALLERR_NOT_REGISTERED;
		}
		else
		{
			//	We can always send anything to the gatekeeper for actual resolution...
			if( (hrResult = GetGatekeeperIpAddress( m_ulDestination )) == S_OK )
			{
				if( m_nmAddressType == NM_ADDR_ALIAS_E164 )		//	should this also check for NM_ADDR_H323_GATEWAY???
				{
					CleanupE164StringEx( m_pszAddress );
				}
				else
				{
					m_nmAddressType = NM_ADDR_ALIAS_ID;
				}
			}
		}
	}
	else
	{
		switch( m_nmAddressType )
		{
			case NM_ADDR_ALIAS_ID:
			{
				hrResult = NM_CALLERR_NO_GATEKEEPER;
			}
			break;

			case NM_ADDR_ALIAS_E164:
			case NM_ADDR_H323_GATEWAY:
			{
				if( inGatewayMode() )
				{
					if( (hrResult = GetGatewayIpAddress( m_ulDestination )) == S_OK )
					{
						//	Explicit phone types are also still resolvable in gateway mode...
						CleanupE164StringEx( m_pszAddress );
					}
				}
				else
				{
					hrResult = NM_CALLERR_NO_PHONE_SUPPORT;
				}
			}
			break;

			case NM_ADDR_IP:
			{
				if( (hrResult = GetIpAddress( m_pszAddress, m_ulDestination )) != S_OK )
				{
					hrResult = NM_CALLERR_INVALID_IPADDRESS;
				}
			}
			break;

			case NM_ADDR_MACHINENAME:
			{
				if( (hrResult = GetIpAddressFromHostName( m_pszAddress, m_ulDestination )) != S_OK )
				{
					hrResult = NM_CALLERR_HOST_RESOLUTION_FAILED;
				}
			}
			break;

			case NM_ADDR_ULS:
			{
				//	Ils types need to be resolved against an ils...
				hrResult = GetIpAddressFromIls(	m_ulDestination );
			}
			break;

			default:
			{
				//	If we get here the type was unspecified (Automatic or 2.xx)...
				//	Our order of precedence is ipaddress,hostname,ils,fail...
				//	We will not try phone since it didn't explicitly have a phone type...

				if( (hrResult = GetIpAddress( m_pszAddress, m_ulDestination )) == S_OK )
				{
					m_nmAddressType = NM_ADDR_IP;
				}
				else
				{
					//	It's not a valid ip address so try it next as a host name...
					if( (hrResult = GetIpAddressFromHostName( m_pszAddress, m_ulDestination )) == S_OK )
					{
						m_nmAddressType = NM_ADDR_MACHINENAME;
					}
					else
					{
						//	It's not a valid host name either so try it finally as an ils lookup...
						if ( (hrResult = GetIpAddressFromIls( m_ulDestination )) == S_OK )
						{
							m_nmAddressType = NM_ADDR_ULS;
						}
					}
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::Resolve.


//--------------------------------------------------------------------------//
//	CCallto::PlaceCall.														//
//--------------------------------------------------------------------------//
HRESULT CCallto::PlaceCall
(
	const TCHAR * const	pszCallto,			//	pointer to the original callto...
	const bool			bAddToMru,			//	whether or not save in mru...
	const bool			bSecure,			//	whether or not to place the call securely...
	INmCall ** const	ppInternalCall		//	out pointer to INmCall * to receive INmCall * generated by placing call...
){
	ASSERT( m_ulDestination != INADDR_NONE );

	const TCHAR * const	pszConferenceName	= m_Parameters.GetParam( TEXT( "conference" ), NULL );
	const TCHAR * const	pszPassword			= m_Parameters.GetParam( TEXT( "password" ), NULL );
	const bool			bH323				= m_Parameters.GetBooleanParam( TEXT( "h323" ), true );
	const bool			bAV					= m_Parameters.GetBooleanParam( TEXT( "av" ), true );
	const bool			bData				= m_Parameters.GetBooleanParam( TEXT( "data" ), true );
	const TCHAR * const	pszAlias			= NULL;
	const TCHAR * const	pszE164				= NULL;
	HRESULT				hrResult;

	if( IsLocalIpAddress( m_ulDestination ) )	
	{
		//	We don't want to go any further if we are attempting to call ourselves...
		hrResult = NM_CALLERR_LOOPBACK;
	}
	else
	{
		//	Map to old style call flags...

		DWORD	dwCallFlags	= 0;

		if( pszConferenceName != NULL )
		{
			dwCallFlags |= CRPCF_JOIN;
		}

		if( bH323 )
		{
			dwCallFlags |= CRPCF_H323CC;
		}
		
		if( bSecure )
		{
			dwCallFlags |= CRPCF_SECURE;
		}
		else if( bAV )
		{
			if( g_uMediaCaps & (CAPFLAG_RECV_AUDIO | CAPFLAG_SEND_AUDIO) )
			{
				dwCallFlags |= CRPCF_AUDIO;
			}

			if( g_uMediaCaps & (CAPFLAG_RECV_VIDEO | CAPFLAG_SEND_VIDEO) )
			{
				dwCallFlags |= CRPCF_VIDEO;
			}
		}

		if( bData )
		{
			dwCallFlags |= CRPCF_DATA | CRPCF_T120;
		}

		if (((CRPCF_T120 | CRPCF_DATA) != (dwCallFlags & (CRPCF_T120 | CRPCF_DATA))) &&
			((CRPCF_H323CC | CRPCF_AUDIO) != ( dwCallFlags & (CRPCF_H323CC | CRPCF_AUDIO))) &&
			((CRPCF_H323CC | CRPCF_VIDEO) != ( dwCallFlags & (CRPCF_H323CC | CRPCF_VIDEO))))
			 
		{
			hrResult = NM_CALLERR_UNKNOWN;
		}

		CConfRoom *	pConfRoom	= ::GetConfRoom();
		ASSERT(pConfRoom);

		if (_Module.IsUIActive())
		{
			pConfRoom->BringToFront();
		}

		if( !(pConfRoom->GetMeetingPermissions() & NM_PERMIT_OUTGOINGCALLS) )
		{
			ERROR_OUT( ("CCallto::PlaceCall: meeting setting permissions do not permit outgoing calls...") );
		}
		else
		{
			CCall *	pCall	= new CCall( pszCallto, m_pszDisplayName, m_nmAddressType, bAddToMru, FALSE );

			if( pCall == NULL )
			{
				ERROR_OUT( ("CCallto::PlaceCall: CCall object not created...") );
				hrResult = E_OUTOFMEMORY;
			}
			else
			{
				pCall->AddRef(); // Protect against another thread canceling this call
				
				IncrementBusyOperations();
				{
					const TCHAR *		pszCallAlias	= (m_nmAddressType == NM_ADDR_ULS)? m_pszEmail: m_pszAddress;
					const char * const	pszDestination	= inet_ntoa( *reinterpret_cast<in_addr *>(&m_ulDestination) );

					hrResult = pCall->PlaceCall(	dwCallFlags,		//	call flags bit mask, is there a good reason why they're not named?
													m_nmAddressType,	//	address type.
													pszDestination,		//	setup address.
													pszDestination,		//	destination address.
													pszCallAlias,		//	alias.
													NULL,				//	callto url.
													pszConferenceName,	//	conference name.
													pszPassword,		//	conference password.
													NULL );				//	user data.
				}
				DecrementBusyOperations();
				
				if( FAILED( hrResult ) && (pCall->GetState() == NM_CALL_INVALID) )
				{
					// just release the call to free the data
					// otherwise wait for the call state to be changed
					pCall->Release();
				}

				if( ppInternalCall )
				{
					*ppInternalCall = pCall->GetINmCall();
					(*ppInternalCall)->AddRef();
				}

				pCall->Release();
			}
		}
	}

	return( hrResult );

}	//	End of CCallto::PlaceCall.


//--------------------------------------------------------------------------//
//	CCallto::GetValidatedSecurity.											//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetValidatedSecurity
(
	const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
	bool &				bValidatedSecurity		//	out bool reference to recieve validated security setting
){
	HRESULT	hrResult;

	//	First figure out what security setting is desired...

	if( pbSecurityPreference != NULL )
	{
		//	A preference was specified so use it.
		bValidatedSecurity = *pbSecurityPreference;
	}
	else
	{
		//	No preference was specified either so check for secure param
		//	passing the current system settings to use as the default.

		bool	bUserAlterable;
		bool	bDefaultSecurity;

		CConfRoom::get_securitySettings( bUserAlterable, bDefaultSecurity );
		
		bValidatedSecurity = m_Parameters.GetBooleanParam( TEXT( "secure" ), bDefaultSecurity );
	}

	//	And then validate that the desired setting is allowed...

    int	iSecurityPolicy	= ConfPolicies::GetSecurityLevel();

	if( (bValidatedSecurity && (iSecurityPolicy == DISABLED_POL_SECURITY)) ||
		((!bValidatedSecurity) && (iSecurityPolicy == REQUIRED_POL_SECURITY)) )
	{
		//	There was a mismatch between what they want and what they can have...
		//	Set security to what they can have and return mismatch error...

		bValidatedSecurity	= (iSecurityPolicy == REQUIRED_POL_SECURITY);
		hrResult			= NM_CALLERR_SECURITY_MISMATCH;
	}
	else
	{
		hrResult = S_OK;
    }

	return( hrResult );

}	//	End of CCallto::GetValidatedSecurity.


//--------------------------------------------------------------------------//
//	CCallto::inGatekeeperMode.												//
//--------------------------------------------------------------------------//
bool CCallto::inGatekeeperMode(void)
{
	return(ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() );

}	//	End of CCallto::inGatekeeperMode.


//--------------------------------------------------------------------------//
//	CCallto::SetGatekeeperEnabled.											//
//--------------------------------------------------------------------------//
void CCallto::SetGatekeeperEnabled
(
	const bool	bEnabled	//	new Gatekeeper state
){

	m_bGatekeeperEnabled = bEnabled;

}	//	End of CCallto::SetGatekeeperEnabled.


//--------------------------------------------------------------------------//
//	CCallto::SetGatekeeperName.												//
//--------------------------------------------------------------------------//
HRESULT CCallto::SetGatekeeperName
(
	const TCHAR * const	pszGatekeeperName	//	pointer to new Gatekeeper name
){

	if( lstrcmpi( pszGatekeeperName, m_pszGatekeeperName ) != 0 )
	{
		delete [] m_pszGatekeeperName;

		m_pszGatekeeperName		= PszAlloc( pszGatekeeperName );
		m_ulGatekeeperAddress	= INADDR_NONE;	//	We reset this cached value when the name changes...
	}

	ASSERT( (m_pszGatekeeperName != NULL) || (pszGatekeeperName == NULL) );

	return( ((pszGatekeeperName != NULL) && (m_pszGatekeeperName == NULL))? E_OUTOFMEMORY: S_OK );

}	//	End of CCallto::SetGatekeeperName.


//--------------------------------------------------------------------------//
//	CCallto::GetGatekeeperIpAddress.										//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetGatekeeperIpAddress
(
	unsigned long &	ulIpAddress		//	out unsigned long reference to receive gatekeeper IP address
){
	ASSERT( m_pszGatekeeperName != NULL );

	if( m_ulGatekeeperAddress == INADDR_NONE )
	{
		GetIpAddressFromHostName( m_pszGatekeeperName, m_ulGatekeeperAddress );
	}

	ulIpAddress = m_ulGatekeeperAddress;

	return( (m_ulGatekeeperAddress != INADDR_NONE)? S_OK: NM_CALLERR_NO_GATEKEEPER );

}	//	End of CCallto::GetGatekeeperIpAddress.


//--------------------------------------------------------------------------//
//	CCallto::inGatewayMode.													//
//--------------------------------------------------------------------------//
bool CCallto::inGatewayMode(void)
{

	return( (m_bGatewayEnabled && (m_pszGatewayName != NULL)) || (m_Parameters.GetParam( TEXT( "gateway" ), NULL ) != NULL) );

}	//	End of CCallto::inGatewayMode.


//--------------------------------------------------------------------------//
//	CCallto::SetGatewayEnabled.												//
//--------------------------------------------------------------------------//
void CCallto::SetGatewayEnabled
(
	const bool	bEnabled	//	new Gateway state
){

	m_bGatewayEnabled = bEnabled;

}	//	End of CCallto::SetGatewayEnabled.


//--------------------------------------------------------------------------//
//	CCallto::SetGatewayName.												//
//--------------------------------------------------------------------------//
HRESULT CCallto::SetGatewayName
(
	const TCHAR * const	pszGatewayName	//	pointer to new Gateway name
){

	if( lstrcmpi( pszGatewayName, m_pszGatewayName ) != 0 )
	{
		delete [] m_pszGatewayName;

		m_pszGatewayName	= PszAlloc( pszGatewayName );
		m_ulGatewayAddress	= INADDR_NONE;	//	We reset this cached value when the name changes...
	}

	ASSERT( (m_pszGatewayName != NULL) || (pszGatewayName == NULL) );

	return( ((pszGatewayName != NULL) && (m_pszGatewayName == NULL))? E_OUTOFMEMORY: S_OK );

}	//	End of CCallto::SetGatewayName.


//--------------------------------------------------------------------------//
//	CCallto::GetGatewayIpAddress.											//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetGatewayIpAddress
(
	unsigned long &	ulIpAddress		//	out unsigned long reference to receive gateway IP address
){

	const TCHAR * const	pszGateway	= m_Parameters.GetParam( TEXT( "gateway" ), NULL );

	if( pszGateway != NULL )
	{
		//	A non-default gateway was specified with this callto...
		GetIpAddressFromHostName( pszGateway, ulIpAddress );
	}
	else
	{
		if( m_ulGatewayAddress == INADDR_NONE )
		{
			GetIpAddressFromHostName( m_pszGatewayName, m_ulGatewayAddress );
		}

		ulIpAddress = m_ulGatewayAddress;
	}

	return( (ulIpAddress != INADDR_NONE)? S_OK: NM_CALLERR_NO_GATEWAY );

}	//	End of CCallto::GetGatewayIpAddress.


//--------------------------------------------------------------------------//
//	CCallto::SetIlsServerName.												//
//--------------------------------------------------------------------------//
HRESULT CCallto::SetIlsServerName
(
	const TCHAR * const	pszServerName	//	pointer to new default Ils server name
){

	delete [] m_pszDefaultIlsServerName;
	
	m_pszDefaultIlsServerName = PszAlloc( pszServerName );

	ASSERT( (m_pszDefaultIlsServerName != NULL) || (pszServerName == NULL) );

	return( ((pszServerName != NULL) && (m_pszDefaultIlsServerName == NULL))? E_OUTOFMEMORY: S_OK );

}	//	End of CCallto::SetIlsServerName.


//--------------------------------------------------------------------------//
//	CCallto::GetIpAddressFromIls.											//
//--------------------------------------------------------------------------//
HRESULT CCallto::GetIpAddressFromIls
(
	unsigned long &	ulIpAddress		//	out unsigned long reference to receive IP address
){
	ASSERT( m_pszEmail != NULL );

	HRESULT	hrResult;

	const TCHAR * const	pszActiveIlsServer	= (m_pszIlsServer != NULL)? m_pszIlsServer: m_pszDefaultIlsServerName;

	if( pszActiveIlsServer == NULL )
	{
		hrResult = NM_CALLERR_NO_ILS;
	}

	if( g_pLDAP == NULL )
	{
		g_pLDAP = new CNmLDAP;
	}

	ASSERT( g_pLDAP != NULL );

	if( g_pLDAP == NULL )
	{
		hrResult = E_OUTOFMEMORY;
	}
	else
	{
		TCHAR	szIpAddress[ 64 ];

		hrResult = g_pLDAP->ResolveUser( m_pszEmail, pszActiveIlsServer, szIpAddress, ARRAY_ELEMENTS( szIpAddress ), m_uiIlsPort );

		if( hrResult == S_OK )
		{
			//	Verify that it gave back a good IP address...
			hrResult = GetIpAddress( szIpAddress, ulIpAddress );
		}

		if( hrResult != S_OK )
		{
			hrResult = NM_CALLERR_ILS_RESOLUTION_FAILED;
		}
	}

	return( hrResult );

}	//	End of CCallto::GetIpAddressFromIls.


//--------------------------------------------------------------------------//
//	CCallto::DoUserValidation    											//
//--------------------------------------------------------------------------//
bool CCallto::DoUserValidation(const TCHAR * const pszCallto)
{
    bool    bRet        = false;
    CCallto callto;
    TCHAR   szCaption[MAX_PATH];
    TCHAR   *pszText    = NULL;

    // Parse input string to retrieve display name
    if(FAILED(callto.Parse(pszCallto)))
        goto Exit;

    // Verify we have a valid display name
    if(NULL == callto.m_pszDisplayName)
        goto Exit;

    // Allocate message buffer. MAX_PATH represents max format string size
    pszText = new TCHAR[_tcslen(callto.m_pszDisplayName) + MAX_PATH];
    if(NULL == pszText)
        goto Exit;

    // Compose message string
    if(!FLoadString1(IDS_JOIN_PERMISSION, pszText, callto.m_pszDisplayName))
        goto Exit;

    if(!FLoadString(IDS_MSGBOX_TITLE, szCaption, CCHMAX(szCaption)))
        goto Exit;

    // Display message box
    if(IDOK != MessageBox(NULL, pszText, szCaption, MB_ICONWARNING | MB_OKCANCEL | MB_TOPMOST))
        goto Exit;

    bRet = true;
Exit:
    // Free allocated buffer
    if(NULL != pszText)
    {
        delete [] pszText;
    }
    
    return bRet;
}

//--------------------------------------------------------------------------//
//	CCalltoParams::CCalltoParams.											//
//--------------------------------------------------------------------------//
CCalltoParams::CCalltoParams(void):
	m_chNameDelimiter( '+' ),
	m_chValueDelimiter( '=' ),
	m_pszParams( NULL ),
	m_iCount( 0 )
{
}	//	End of CCalltoParams::CCalltoParams.


//--------------------------------------------------------------------------//
//	CCalltoParams::CCalltoParams.											//
//--------------------------------------------------------------------------//
CCalltoParams::~CCalltoParams()
{

	delete [] m_pszParams;

}	//	End of CCalltoParams::~CCalltoParams.


//--------------------------------------------------------------------------//
//	CCalltoParams::SetParams.												//
//--------------------------------------------------------------------------//
HRESULT
CCalltoParams::SetParams
(
	const TCHAR * const	pszParams
){

	HRESULT	hrResult;

	delete [] m_pszParams;

	m_pszParams	= NULL;
	m_iCount	= 0;

	if( pszParams == NULL )
	{
		hrResult = S_OK;
	}
	else if( (m_pszParams = new TCHAR [ lstrlen( pszParams ) + 1 ]) == NULL )
	{
		hrResult = E_OUTOFMEMORY;
	}
	else
	{
		hrResult = S_OK;

		lstrcpy( m_pszParams, pszParams );

		TCHAR *	pszPos	= m_pszParams;
		TCHAR *	pszEnd;

		while( (*pszPos != '\0') && (m_iCount < ARRAY_ELEMENTS( m_pszNames )) )
		{
			m_pszNames[ m_iCount ]	= pszPos;
			m_pszValues[ m_iCount ]	= NULL;

			while( *pszPos != '\0' )
			{
				if( (*pszPos == '+') || (*pszPos == '=') )
				{
					break;
				}

				pszPos = CharNext( pszPos );
			}

			if( *pszPos != '=' )
			{
				//	Valueless param...

				if( m_pszNames[ m_iCount ] == pszPos )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have zero length param names...
					break;
				}

				pszEnd = pszPos;
				pszPos = CharNext( pszPos );

				if( (pszPos != pszEnd) && (*pszPos == '\0') )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have trailing + or =...
					break;
				}

				*pszEnd = '\0';
				m_iCount++;
			}
			else
			{
				//	Value follows...
				pszEnd = pszPos;
				pszPos = CharNext( pszPos );
				*pszEnd = '\0';

				m_pszValues[ m_iCount ] = pszPos;

				while( *pszPos != '\0' )
				{
					if( (*pszPos == '+') || (*pszPos == '=') )
					{
						break;
					}

					pszPos = CharNext( pszPos );
				}

				if( (*pszPos == '=') || (m_pszValues[ m_iCount ] == pszPos) )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have '=' or zero length param names...
					break;
				}

				pszEnd = pszPos;
				pszPos = CharNext( pszPos );

				if( (pszPos != pszEnd) && (*pszPos == '\0') )
				{
					hrResult = NM_CALLERR_PARAM_ERROR;	//	Can't have trailing + or =...
					break;
				}

				*pszEnd = '\0';
				m_iCount++;
			}
		}

		if( hrResult == S_OK )
		{
			if( m_iCount == ARRAY_ELEMENTS( m_pszNames ) )
			{
				hrResult = NM_CALLERR_PARAM_ERROR;	//	Too many params...
			}
			else
			{
				for( int nn = 0; nn < m_iCount; nn++ )
				{
					if( (hrResult = Unescape( m_pszNames[ nn ] )) != S_OK )
					{
						break;
					}

					if( m_pszValues[ nn ] != NULL )
					{
						if( (hrResult = Unescape( m_pszValues[ nn ] )) != S_OK )
						{
							break;
						}
					}
				}
			}
		}
	}

	return( hrResult );

}	//	End of CCalltoParams::SetParams.


//--------------------------------------------------------------------------//
//	CCalltoParams::GetParam.												//
//--------------------------------------------------------------------------//
const TCHAR * const
CCalltoParams::GetParam
(
	const TCHAR * const	pszName,
	const TCHAR * const	pszDefaultValue
) const
{
	ASSERT( pszName != NULL );

	TCHAR *	pszValue	= NULL;

	if( m_pszParams != NULL )
	{
		for( int nn = 0; nn < m_iCount; nn++ )
		{
			if( lstrcmpi( pszName, m_pszNames[ nn ] ) == 0 )
			{
				pszValue = m_pszValues[ nn ];
				break;
			}
		}
	}

	return( (pszValue == NULL)? pszDefaultValue: pszValue );

}	//	End of CCalltoParams::GetParam.


//--------------------------------------------------------------------------//
//	CCalltoParams::GetBooleanParam.											//
//--------------------------------------------------------------------------//
bool
CCalltoParams::GetBooleanParam
(
	const TCHAR * const	pszParamName,
	const bool			bDefaultValue
) const
{
	ASSERT( pszParamName != NULL );

	const TCHAR * const	pszValue	= GetParam( pszParamName, NULL );
	bool				bResult;

	if( pszValue == NULL )		//	this parameter wasn't specified...
	{
		bResult = bDefaultValue;
	}
	else if( *pszValue == 0 )	//	this parameter was specified but with no value...
	{
		bResult = true;
	}
	else if(	(lstrcmpi( pszValue, TEXT( "1" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "true" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "y" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "yes" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "on" ) ) == 0) )
	{
		bResult = true;
	}
	else if(	(lstrcmpi( pszValue, TEXT( "0" ) ) == 0)		||
				(lstrcmpi( pszValue, TEXT( "false" ) ) == 0)	||
				(lstrcmpi( pszValue, TEXT( "n" ) ) == 0)		||
				(lstrcmpi( pszValue, TEXT( "no" ) ) == 0)		||
				(lstrcmpi( pszValue, TEXT( "off" ) ) == 0) )
	{
		bResult = false;
	}
	else
	{
		bResult = bDefaultValue;
	}

	return( bResult );

}	//	End of CCalltoParams::GetBooleanParam.


//--------------------------------------------------------------------------//
//	IsLocalIpAddress.														//
//--------------------------------------------------------------------------//
bool IsLocalIpAddress
(
	const unsigned long	ulIpAddress		// IP Address to verify is not local
){
	bool	bResult	= (ulIpAddress == INADDR_LOOPBACK);	//	First check right away if it's the prefined loop back ip address...

	if( !bResult )
    {
	    char	szHostName[ MAX_PATH ];

	    //	Get our own local hostname...
		if( gethostname( szHostName, ARRAY_ELEMENTS( szHostName ) ) == SOCKET_ERROR )
		{
			WARNING_OUT( ("IsLocalIpAddress: gethostname() failed with error=%s", PszWSALastError()) );
		}
		else
		{
			//	Now find out which IP addresses are associated with it...
			HOSTENT *	pHostEnt	= gethostbyname( szHostName );

			if( pHostEnt == NULL )
			{
				WARNING_OUT( ("IsLocalIpAddress: gethostbyname() failed with error=%s", PszWSALastError()) );
			}
			else if( (pHostEnt->h_addrtype != AF_INET) || (pHostEnt->h_length != sizeof( ulIpAddress )) )
			{
				WARNING_OUT( ("IsLocalIpAddress: gethostbyname() returned unexpected address type: 0x%08X (%d)", pHostEnt->h_addrtype, pHostEnt->h_addrtype) );
			}
			else
			{
				ASSERT( reinterpret_cast<unsigned long **>(pHostEnt->h_addr_list) != NULL );

				//	Compare all the IP addresses associated with this machine to see if any of them match the one specified...
				for( unsigned long ** ppIpAddress = reinterpret_cast<unsigned long **>(pHostEnt->h_addr_list); *ppIpAddress != NULL; ppIpAddress++ )
				{
					if( **ppIpAddress == ulIpAddress )
					{
						bResult = true;
						break;
					}
				}
			}
		}
	}

	return( bResult );

}	//	End of IsLocalIpAddress.


//--------------------------------------------------------------------------//
//	DecimalStringToUINT.													//
//--------------------------------------------------------------------------//
HRESULT DecimalStringToUINT
(
	const TCHAR * const	pszDecimalString,		//	Pointer to string to convert...
	unsigned int &		uiValue					//	out unsigned int reference to receive converted value...
){
	ASSERT( pszDecimalString != NULL );

	HRESULT	hrResult;

	if( lstrlen( pszDecimalString ) > 10 )
	{
		hrResult = E_INVALIDARG;		//	Limit it to billions....
	}
	else
	{
		hrResult = S_OK;

		const TCHAR * pszDigit;

		for( pszDigit = pszDecimalString, uiValue = 0; *pszDigit != '\0'; pszDigit = CharNext( pszDigit ) )
		{
			if( (*pszDigit < '0') || (*pszDigit > '9') )
			{
				//	There's a non digit character in the string so fail...
				hrResult = E_INVALIDARG;
				break;
			}

			uiValue = (uiValue * 10) + *pszDigit - '0';
		}
	}

	return( hrResult );

}	//	End of DecimalStringToUINT.


//--------------------------------------------------------------------------//
//	TrimSzCallto.															//
//--------------------------------------------------------------------------//
int TrimSzCallto
(
	TCHAR * const	pszSrc		//	Pointer to string to trim blanks from in place...
){
	ASSERT( pszSrc != NULL );

	TCHAR *	pszFirst;
	int		iResult;

	for( pszFirst = pszSrc; *pszFirst == ' '; pszFirst = CharNext( pszFirst ) ){};

	if( *pszFirst == '\0' )
	{
		*pszSrc = '\0';
		iResult	= 0;
	}
	else
	{
		TCHAR *	pszLast;
		TCHAR *	psz;

		for( pszLast = pszFirst, psz = pszFirst; *psz != '\0'; psz = CharNext( psz ) )
		{
			if( *psz != ' ' )
			{
				pszLast = psz;
			}
		}

		pszLast		= CharNext( pszLast );
		*pszLast	= '\0';

		lstrcpy( pszSrc, pszFirst );
		iResult = lstrlen( pszSrc );
	}

	return( iResult );

}	//	End of TrimSzCallto.


//--------------------------------------------------------------------------//
//	GetIpAddress.															//
//--------------------------------------------------------------------------//
HRESULT GetIpAddress
(
	const TCHAR * const	pszIpAddress,	//	pointer to dotted IP address string
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
){
	ASSERT( pszIpAddress != NULL );

	ulIpAddress = INADDR_NONE;

	int				ipByte	= 0;
	int				parts	= 0;
	const TCHAR *	ptr		= pszIpAddress;
	bool			newPart	= true;
	bool			result	= true;

	while( result && (*ptr != NULL) && (parts <= 4) )
	{
		if( (*ptr >= '0') && (*ptr <= '9') )
		{
			if( newPart )
			{
				parts++;
				newPart = false;
			}

			ipByte = (ipByte * 10) + (*ptr - '0');

			if( ipByte > 255 )
			{
				result = false;
			}
		}
		else if( *ptr == '.' )
		{
			newPart	= true;
			ipByte	= 0;
		}
		else
		{
			result = false;
		}

		ptr++;
	}

	if( result && (parts == 4) )
	{
#if !defined( UNICODE )
		ulIpAddress = inet_addr( pszIpAddress );
#else
		char *	ansiIPAddress;
		int		size;

		size = WideCharToMultiByte(	CP_ACP,		// code page
									0,			// performance and mapping flags
									ipAddress,	// address of wide-character string
									-1,			// number of characters in string
									NULL,		// address of buffer for new string
									0,			// size of buffer
									NULL,		// address of default for unmappable characters
									NULL );		// address of flag set when default char. used

		if( (ansiIPAddress = new char [ size ]) != NULL )
		{
			size = WideCharToMultiByte(	CP_ACP,			// code page
										0,				// performance and mapping flags
										pszIpAddress,	// address of wide-character string
										-1,				// number of characters in string
										ansiIPAddress,	// address of buffer for new string
										size,			// size of buffer
										NULL,			// address of default for unmappable characters
										NULL );			// address of flag set when default char. used

			if( size != 0 )
			{
				ulIpAddress = inet_addr( ansiIPAddress );
			}

			delete [] ansiIPAddress;
		}
#endif	//	!defined( UNICODE )
	}

	return( (ulIpAddress != INADDR_NONE)? S_OK: E_FAIL );

}	//	End of GetIpAddress.


//--------------------------------------------------------------------------//
//	GetIpAddressFromHostName.												//
//--------------------------------------------------------------------------//
HRESULT GetIpAddressFromHostName
(
	const TCHAR * const	pszName,		//	pointer to host name to get IP address of
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
){
	ASSERT( pszName != NULL );

	HRESULT	hrResult	= E_FAIL;

	if( pszName[ 0 ] == '\0' )
	{
		ulIpAddress = INADDR_NONE;
	}
	else if( (hrResult = GetIpAddress( pszName, ulIpAddress )) != S_OK )
	{
		//	Wasn't already in dotted IP address form...

		HOSTENT *	pHostEnt;
#if !defined( UNICODE )
		TCHAR *		pszOemName = new TCHAR [ lstrlen( pszName ) + 1 ];

		if( pszOemName == NULL )
		{
			hrResult = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( pszOemName, pszName );
			CharUpper ( pszOemName );
			CharToOem( pszOemName, pszOemName );

			pHostEnt = gethostbyname( pszOemName );

			if( pHostEnt == NULL )
			{
				WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() failed with error=%s", PszWSALastError()) );
			}
			else if( (pHostEnt->h_addrtype != AF_INET) || (pHostEnt->h_length != sizeof( ulIpAddress )) )
			{
				WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() returned unexpected address type: 0x%08X (%d)", pHostEnt->h_addrtype, pHostEnt->h_addrtype) );
			}
			else
			{
				if( pHostEnt->h_addr_list[ 0 ] != NULL )
				{
					ulIpAddress	= *reinterpret_cast<unsigned long *>(pHostEnt->h_addr_list[ 0 ]);	//	Just use the first IP address
					hrResult	= S_OK;
				}
			}

			delete [] pszOemName;
		}
#else
		//	Need to figure out OEM'ing the name...

		char *	pszMultiByteName;
		int		iSize;

		iSize = WideCharToMultiByte(	CP_ACP,		// code page
										0,			// performance and mapping flags
										pszName,	// address of wide-character string
										-1,			// number of characters in string
										NULL,		// address of buffer for new string
										0,			// size of buffer
										NULL,		// address of default for unmappable characters
										NULL );		// address of flag set when default char. used

		if( (pszMultiByteName = new char [ iSize ]) == NULL )
		{
			hrResult = E_OUTOFMEMORY;
		}
		else
		{
			iSize = WideCharToMultiByte(	CP_ACP,				// code page
											0,					// performance and mapping flags
											pszName,			// address of wide-character string
											-1,					// number of characters in string
											pszMultiByteName,	// address of buffer for new string
											iSize,				// size of buffer
											NULL,				// address of default for unmappable characters
											NULL );				// address of flag set when default char. used

			if( iSize != 0 )
			{
				pHostEnt = gethostbyname( ansiHost );

				if( pHostEnt == NULL )
				{
					WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() failed with error=%s", PszWSALastError()) );
				}
				else if( (pHostEnt->h_addrtype != AF_INET) || (pHostEnt->h_length != sizeof( ulIpAddress )) )
				{
					WARNING_OUT( ("GetIpAddressFromHostName: gethostbyname() returned unexpected address type: 0x%08X (%d)", pHostEnt->h_addrtype, pHostEnt->h_addrtype) );
				}
				else
				{
					if( pHostEnt->h_addr_list[ 0 ] != NULL )
					{
						ulIpAddress	= *reinterpret_cast<unsigned long *>(pHostEnt->h_addr_list[ 0 ]);	//	Just use the first IP address
						hrResult	= S_OK;
					}
				}
			}

			delete [] pszMultiByteName;
		}
#endif	// !defined( UNICODE )
	}

	return( hrResult );

}	//	End of GetIpAddressFromHostName.


//--------------------------------------------------------------------------//
//	IsPhoneNumber.															//
//--------------------------------------------------------------------------//
bool IsPhoneNumber
(
	const TCHAR *	pszPhone	//	string to check for invalid phone number characters
){
	ASSERT( pszPhone != NULL );
	ASSERT( pszPhone[ 0 ] != '\0' );

	bool	bResult	= true;

	while( pszPhone[ 0 ] != '\0' )
	{
		switch( pszPhone[ 0 ] )
		{
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '(':
			case ')':
			case '#':
			case '*':
			case '-':
			case ',':
			case ' ':
				break;

			default:
				bResult = false;
				break;
		}
		
		pszPhone++;
	}

	return( bResult );

}	//	End of IsPhoneNumber.


//--------------------------------------------------------------------------//
//	bCanCallAsPhoneNumber.													//
//--------------------------------------------------------------------------//
bool bCanCallAsPhoneNumber
(
	const TCHAR * const	pszPhone
){
	ASSERT( pszPhone != NULL );
	ASSERT( pszPhone[ 0 ] != '\0' );

	bool	bResult	= FALSE;

	if( IsPhoneNumber( pszPhone ) )
	{
		if( ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() )
		{
			bResult = true;
		}
		else
		{
			RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

			bResult = (reConf.GetNumber( REGVAL_USE_H323_GATEWAY ) != 0);
		}
	}

	return( bResult );

}	//	End of bCanCallAsPhoneNumber.


//--------------------------------------------------------------------------//
//	unescape.																//
//--------------------------------------------------------------------------//
HRESULT Unescape
(
	TCHAR * const	pszSrc		//	pointer to string to unescape in place
){
	ASSERT( pszSrc != NULL );
	
	TCHAR *	pszPercentSign;
	HRESULT	hrResult;

	for( hrResult = S_OK, pszPercentSign = pszSrc; pszPercentSign != NULL; )
	{
		if( (pszPercentSign = StrChr( pszPercentSign, '%' )) != NULL )
		{
			TCHAR	chHighNibble	= pszPercentSign[ 1 ];

			if( ((chHighNibble >= '0') && (chHighNibble <= '9'))	||
				((chHighNibble >= 'a') && (chHighNibble <= 'f'))	||
				((chHighNibble >= 'A') && (chHighNibble <= 'F')) )
			{
				TCHAR	chLowNibble	= pszPercentSign[ 2 ];

				if( ((chLowNibble >= '0') && (chLowNibble <= '9'))	||
					((chLowNibble >= 'a') && (chLowNibble <= 'f'))	||
					((chLowNibble >= 'A') && (chLowNibble <= 'F')) )
				{
					chHighNibble	= ((chHighNibble >= '0') && (chHighNibble <= '9'))? chHighNibble - '0':
										((chHighNibble >= 'a') && (chHighNibble <= 'f'))? chHighNibble - 'a' + 10: chHighNibble - 'A' + 10;
					chLowNibble		= ((chLowNibble >= '0') && (chLowNibble <= '9'))? chLowNibble - '0':
										((chLowNibble >= 'a') && (chLowNibble <= 'f'))? chLowNibble - 'a' + 10: chLowNibble - 'A' + 10;

					*pszPercentSign++ = (chHighNibble << 4) | chLowNibble;
					lstrcpy( pszPercentSign, &pszPercentSign[ 2 ] );
				}
				else
				{
					hrResult = NM_CALLERR_UNESCAPE_ERROR;
					break;
				}
			}
			else
			{
				hrResult = NM_CALLERR_UNESCAPE_ERROR;
				break;
			}
		}
	}

	return( hrResult );

}	//	End of Unescape.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\call.h ===
// File: call.h

#ifndef _CALL_H_
#define _CALL_H_

#include "oblist.h"
#include "SDKInternal.h"

const HRESULT NM_CALLERR_NOT_REGISTERED	= NM_E(0x01EF);

class CDlgCall;  // from dlgcall.h
class CPopupMsg;

class CCall : public RefCount, INmCallNotify2
{

private:
	INmCall*		 m_pInternalICall;// Call Object in core
	CPopupMsg*		 m_ppm;				// Popup incomming call dialog
	LPTSTR    m_pszDisplayName;      // Display Name
	LPTSTR    m_pszCallTo;     // CallTo (original)
	BOOL      m_fSelectedConference;
	BOOL      m_fIncoming;
	BOOL      m_fInRespond;		// Responding to call dialog?
	NM_ADDR_TYPE	m_nmAddrType;
	BOOL		m_bAddToMru;

	POSITION  m_pos;           // position in g_pCallList
	DWORD     m_dwTick;        // tick count at call start
	DWORD     m_dwCookie;

	CDlgCall * m_pDlgCall;  // Outgoing call dialog
	VOID      RemoveProgress(void);
	VOID      ShowProgress(BOOL fShow);

	VOID      LogCall(BOOL fAccepted);

public:
	CCall(LPCTSTR pszCallTo, LPCTSTR pszDisplayName, NM_ADDR_TYPE nmAddrType, BOOL bAddToMru, BOOL fIncoming);
	~CCall();

	// IUnknown methods
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppv);

	// INmCallNotify methods
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CALL_STATE uState);
	STDMETHODIMP Failed(ULONG uError);
	STDMETHODIMP Accepted(INmConference *pConference);

	// INmCallNotify3 methods
	STDMETHODIMP CallError(UINT cns);
	STDMETHODIMP RemoteConference(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin);
	STDMETHODIMP RemotePassword(BSTR bstrConference, BSTR *pbstrPassword, PBYTE pb, DWORD cb, BOOL fIsService);

	// Internal methods
	VOID    Update(void);
	BOOL    FComplete(void);
	BOOL    RemoveFromList(void);
	VOID    OnRing(void);
	BOOL    RespondToRinging(DWORD dwCLEF);
	HRESULT OnUIRemoteConference(BOOL fMCU, PWSTR* pwszConfNames, BSTR *pbstrConfToJoin);

	VOID    SetNmCall(INmCall * pCall);

	HRESULT
	PlaceCall
	(
		DWORD dwFlags,
		NM_ADDR_TYPE addrType,
		const TCHAR * const	setupAddress,
		const TCHAR * const	destinationAddress,
		const TCHAR * const	alias,
		const TCHAR * const	url,
		const TCHAR * const conference,
		const TCHAR * const password,
		const TCHAR * const	userData
	);

	VOID    Cancel(BOOL fDisplayCancelMsg);

	INmCall * GetINmCall()       {return m_pInternalICall;}
	LPTSTR  GetPszName()         {return m_pszDisplayName;}
	BOOL    FIncoming()          {return m_fIncoming;}
	NM_CALL_STATE GetState();
	DWORD   GetTickCount()       {return m_dwTick;}
	VOID    DisplayPopup(void);
	VOID    SetSelectedConference() {m_fSelectedConference = TRUE;}

	static VOID CALLBACK PopupMsgRingingCallback(LPVOID pContext, DWORD dwFlags);
};

// Fake connection points
HRESULT OnUICallCreated(INmCall *pNmCall);

// Global utility Functions
int CleanupE164StringEx(LPTSTR szPhoneNumber);
CCall * CallFromNmCall(INmCall * pNmCall);
DWORD GetCallStatus(LPTSTR pszStatus, int cchMax, UINT * puID);
BOOL  FIsCallInProgress(void);
VOID  FreeCallList(void);

CCall * CreateIncomingCall(INmCall * pNmCall);

// Commands
VOID CancelAllOutgoingCalls(void);
VOID CancelAllCalls(void);

BOOL FIpAddress(LPCTSTR pcsz);

VOID DisplayCallError(HRESULT hr, LPCTSTR pcszName);

// Gateway utility routines
BOOL FH323GatewayEnabled(void);
int  GetDefaultGateway(LPTSTR psz, UINT cchMax);
HRESULT CreateGatewayAddress(LPTSTR pszResult, UINT cchMax, LPCTSTR pszAddr);

	// Gatekeeper logon state
extern NM_GK_STATE g_GkLogonState;



BOOL FGkEnabled(void);
void GkLogon(void);
void GkLogoff(void);
void SetGkLogonState(NM_GK_STATE state);
bool IsGatekeeperLoggedOn(void);
bool IsGatekeeperLoggingOn(void);


class CCallResolver
{

private:
	LPTSTR    m_pszAddr;       // Address (original)
	LPTSTR    m_pszAddrIP;     // Address (IP)
	NM_ADDR_TYPE m_addrType;    // Address type (of m_pszAddr)

	HRESULT ResolveIpName(LPCTSTR pcszAddr);
	HRESULT ResolveMachineName(LPCTSTR pcszAddr);
	HRESULT ResolveUlsName(LPCTSTR pcszAddr);
	HRESULT ResolveGateway(LPCTSTR pcszAddr);
	HRESULT CheckHostEnt(HOSTENT * pHostInfo);

public:
	CCallResolver(LPCTSTR pszAddr, NM_ADDR_TYPE addrType);
	~CCallResolver();

	LPCTSTR GetPszAddr() { return m_pszAddr; }
	NM_ADDR_TYPE GetAddrType() { return m_addrType; }
	LPCTSTR GetPszAddrIP() { return m_pszAddrIP; }

	HRESULT Resolve();
};

#endif // _CALL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\callingbar.cpp ===
// File: rtoolbar.cpp

#include "precomp.h"
#include "resource.h"

#include "CallingBar.h"
#include "RToolbar.h"
#include "conf.h"
#include "ConfRoom.h"
#include "richaddr.h"
#include "dlgAcd.h"
#include "callto.h"
#include "topwindow.h"
#include "roomlist.h"

#define ReleaseIt(pUnk) if (NULL != (pUnk)) { (pUnk)->Release(); (pUnk) = NULL; }


const static int CCH_MAX_NAME = 256;

// BUGBUG georgep: Hard-coded colors for the edit control
static const COLORREF EditBack = RGB(-1  , -1  , -1  );
static const COLORREF EditFore = RGB(0, 55, 55);


void CCallingBar::SetEditFont(BOOL bUnderline, BOOL bForce)
{
	// BUGBUG georgep: For now, we will never underline; We'll probably need to
	// change this some time in the future
	bUnderline = FALSE;

	if (!bForce && ((bUnderline&&m_bUnderline) || (!bUnderline&&!m_bUnderline)))
	{
		return;
	}
	m_bUnderline = bUnderline;

	LOGFONT lf;
	{
		HDC hdc = GetDC(NULL);
		lf.lfHeight = -MulDiv(10, GetDeviceCaps(hdc, LOGPIXELSY), 72);
		ReleaseDC(NULL, hdc);
	}
	lf.lfWidth = 0;
	lf.lfEscapement = 0;
	lf.lfOrientation = 0;
	lf.lfWeight = FW_NORMAL;
	lf.lfItalic = FALSE;
	lf.lfUnderline = (BYTE)bUnderline;
	lf.lfStrikeOut = FALSE;
	lf.lfCharSet = DEFAULT_CHARSET;
	lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	lf.lfQuality = DEFAULT_QUALITY;
	lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
	lf.lfFaceName[0] = '\0';

	m_pEdit->SetFont(CreateFontIndirect(&lf));
}

void CCallingBar::ClearAddr(RichAddressInfo **ppAddr)
{
	if (NULL != *ppAddr)
	{
		m_pConfRoom->FreeAddress(ppAddr);
		*ppAddr = NULL;
	}
}

void CCallingBar::ClearCombo()
{
	if (NULL == m_pEdit)
	{
		return;
	}

	// Clear the combo
	while (0 < m_pEdit->GetNumItems())
	{
		RichAddressInfo *pAddr = reinterpret_cast<RichAddressInfo*>(m_pEdit->GetUserData(0));
		ClearAddr(&pAddr);
		m_pEdit->RemoveItem(0);
	}
}

void CCallingBar::OnNewAddress(RichAddressInfo *pAddr)
{
	if (NULL != pAddr)
	{
		m_pEdit->SetSelectedIndex(-1);

		m_pEdit->SetText(pAddr->szName);

		SetEditFont(TRUE);

		ClearAddr(&m_pAddr);
		m_pAddr = pAddr;
	}
}

CCallingBar::CCallingBar() : m_pAddr(NULL), m_pEdit(NULL), m_bUnderline(FALSE), m_pAccel(NULL)
{
}

BOOL CCallingBar::Create(CGenWindow *pParent, CConfRoom *pConfRoom)
{
	m_pConfRoom = pConfRoom;

	// Create the toolbar
	if (!CToolbar::Create(pParent->GetWindow()))
	{
		return(FALSE);
	}

	CCallingBar *pDial = this;

	pDial->m_nAlignment = Center;

	// Add the directory button
	static const Buttons callButtons[] =
	{
		{ IDB_DIAL     , CBitmapButton::Disabled+1, 1, ID_TB_NEW_CALL, IDS_TT_TB_NEW_CALL, },
	} ;

	// Create the text control
	CComboBox *pEdit = new CComboBox();
	m_pEdit = pEdit;
	if (NULL != pEdit)
	{
		if (pEdit->Create(pDial->GetWindow(), 200, CBS_AUTOHSCROLL|CBS_DROPDOWN, g_szEmpty, this))
		{
			pEdit->SetTooltip(RES2T(IDS_TT_ADDRESS_BAR));

			// Set the colors and the font
			pEdit->SetColors(CreateSolidBrush(EditBack), EditBack, EditFore);

			SetEditFont(FALSE, TRUE);
			
			::SendMessage( *pEdit, CB_LIMITTEXT, CCallto::s_iMaxAddressLength, 0 );
		}
	}

	// Add the call button on the right
	AddButtons(pDial, callButtons, 1);

	// I want the second button on the right, and the ComboBox in the
	// middle
	pDial->m_uRightIndex = 1;
	pDial->m_bHasCenterChild = TRUE;

	m_pAccel = new CTranslateAccelTable(GetWindow(),
		::LoadAccelerators(GetInstanceHandle(), MAKEINTRESOURCE(IDR_CALL)));
	if (NULL != m_pAccel)
	{
		AddTranslateAccelerator(m_pAccel);
	}

	return(TRUE);
}

void CCallingBar::OnTextChange(CComboBox *pEdit)
{
	ClearAddr(&m_pAddr);
	SetEditFont(FALSE);
}

void CCallingBar::OnFocusChange(CComboBox *pEdit, BOOL bSet)
{
	if (!bSet)
	{
		RichAddressInfo *pAddr = NULL;
		int index = m_pEdit->GetSelectedIndex();
		if (0 <= index)
		{
			LPARAM lpAddr = m_pEdit->GetUserData(index);
			if (static_cast<LPARAM>(-1) != lpAddr && 0 != lpAddr)
			{
				// There are cases where the combo thinks we have a selection,
				// but there is no associated address
				pAddr = reinterpret_cast<RichAddressInfo*>(lpAddr);

				// I need to make a copy so I won't delete twice
				RichAddressInfo *pCopy = NULL;
				m_pConfRoom->CopyAddress(pAddr, &pCopy);

				OnNewAddress(pCopy);
			}
		}
	}

	if (bSet)
	{
		// Only clear this on setfocus, to avoid some weirdness when the focus is
		// lost while the list is dropped down.
		ClearCombo();

		IEnumRichAddressInfo *pEnum;
		if (SUCCEEDED(m_pConfRoom->GetRecentAddresses(&pEnum)))
		{
			for (long index=0; ; ++index)
			{
				RichAddressInfo *pAddr;

				if (S_OK != pEnum->GetAddress(index, &pAddr))
				{
					break;
				}

				m_pEdit->AddText(pAddr->szName, reinterpret_cast<LPARAM>(pAddr));
			}

			pEnum->Release();
		}
	}
}

void CCallingBar::OnSelectionChange(CComboBox *pCombo)
{
}

CCallingBar::~CCallingBar()
{
	ClearAddr(&m_pAddr);

	ReleaseIt(m_pEdit);
}

LRESULT CCallingBar::ProcessMessage(HWND hwnd, UINT uCmd, WPARAM wParam, LPARAM lParam)
{
	switch (uCmd)
	{
	case WM_DESTROY:
		if (NULL != m_pAccel)
		{
			RemoveTranslateAccelerator(m_pAccel);
			m_pAccel->Release();
			m_pAccel = NULL;
		}

		ClearCombo();
		break;

	case WM_SETFOCUS:
		if (NULL != m_pEdit)
		{
			::SetFocus(m_pEdit->GetWindow());
		}
		break;

	default:
		break;
	}

	return(CToolbar::ProcessMessage(hwnd, uCmd, wParam, lParam));
}

void CCallingBar::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
	case ID_TB_NEW_CALL:
	{

		// Make sure all the fields are updated correctly
		OnFocusChange(m_pEdit, FALSE);

		TCHAR szEdit[CCH_MAX_NAME];

	    int szEditLen = m_pEdit->GetText(szEdit, ARRAY_ELEMENTS(szEdit));

		if( szEditLen > 0 )
		{
			szEditLen = TrimSz( szEdit );
		}

		if( (m_pAddr != NULL) || (szEditLen > 0) )
		{
			const TCHAR *	pszCallto;
			const TCHAR *	pszDisplayName;
			NM_ADDR_TYPE	nmAddressType;

			if( hasValidUserInfo( m_pAddr ) )
			{
				pszCallto		= m_pAddr->rgDwStr[ 0 ].psz;
				pszDisplayName	= m_pAddr->szName;
				nmAddressType	= static_cast<NM_ADDR_TYPE>(m_pAddr->rgDwStr[ 0 ].dw);
			}
			else
			{
				pszCallto		= szEdit;
				pszDisplayName	= szEdit;
				nmAddressType	= bCanCallAsPhoneNumber( pszCallto )? NM_ADDR_ALIAS_E164: NM_ADDR_UNKNOWN;
			}

			g_pCCallto->Callto(	pszCallto,			//	pointer to the callto url to try to place the call with...
								pszDisplayName,		//	pointer to the display name to use...
								nmAddressType,		//	callto type to resolve this callto as...
								true,				//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
								NULL,				//	security preference, NULL for none. must be "compatible" with secure param if present...
								true,				//	whether or not save in mru...
								true,				//	whether or not to perform user interaction on errors...
								GetWindow(),		//	if bUIEnabled is true this is the window to parent error/status windows to...
								NULL );				//	out pointer to INmCall * to receive INmCall * generated by placing call...
		}
		else
		{
			CDlgAcd::newCall( GetWindow(), m_pConfRoom );
		}
		break;
	}

	case ID_TB_DIRECTORY:
		// Let the parent handle this command
	default:
		FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, CToolbar::ProcessMessage);
	}
}

int CCallingBar::GetText(LPTSTR szText, int nLen)
{
	if (NULL != m_pEdit)
	{
		return(m_pEdit->GetText(szText, nLen));
	}

	szText[0] = '\0';
	return(0);
}

void CCallingBar::SetText(LPCTSTR szText)
{
	if (NULL != m_pEdit)
	{
		m_pEdit->SetText(szText);
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\callto.h ===
#if	!defined( callto_h )
#define	callto_h
//--------------------------------------------------------------------------//
#include	"call.h"

#define strlen_literal( l )			((sizeof( (l) ) / sizeof( TCHAR )) - 1)
#define StrCmpNI_literal( str, l )	((bool)(StrCmpNI( (str), (l), ((sizeof( (l) ) / sizeof( TCHAR )) - 1) ) == 0))


//--------------------------------------------------------------------------//
//	Public Methods.															//
//--------------------------------------------------------------------------//
HRESULT DecimalStringToUINT
(
	const TCHAR * const	pszDecimalString,	//	Pointer to string to convert...
	unsigned int &		uiValue				//	out unsigned int reference to receive converted value...
);

HRESULT GetIpAddress
(
	const TCHAR * const	pszIpAddress,	//	pointer to dotted IP address string
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
);

HRESULT GetIpAddressFromHostName
(
	const TCHAR * const	pszName,		//	pointer to host name to get IP address of
	unsigned long &		ulIpAddress		//	out unsigned long reference to receive IP address
);

bool IsLocalIpAddress
(
	const unsigned long	IpAddress		// IP Address to verify is/not local
);

bool IsPhoneNumber
(
	const TCHAR *	pszPhone			//	string to check for invalid phone number characters
);

bool bCanCallAsPhoneNumber
(
	const TCHAR * const	pszPhone		//	string to check for call placement
);

int TrimSzCallto
(
	TCHAR * const	pszSrc				//	Pointer to string to trim blanks from in place...
);

HRESULT Unescape
(
	TCHAR * const	pszSrc				//	pointer to string to unescape in place
);


//--------------------------------------------------------------------------//
//	class CCalltoParams.													//
//--------------------------------------------------------------------------//
class CCalltoParams
{
	public:
		
		CCalltoParams(void);
		virtual ~CCalltoParams();

		HRESULT SetParams
		(
			const TCHAR * const	pszParams = NULL		//	pointer to string of "+name=value" pairs to parse
		);

		const TCHAR * const GetParam
		(
			const TCHAR * const	pszName,				//	pointer to name of parameter to get
			const TCHAR * const	pszDefaultValue = NULL	//	pointer to default value to return if "name" doesn't exist
		) const;

		bool GetBooleanParam
		(
			const TCHAR * const	pszName,				//	pointer to name of parameter to evaluate as boolean
			const bool			bDefaultValue = false	//	default value to return is "name" doesn't exist
		) const;


	private:	//	private members	----------------------------------------//

		int		m_iCount;
		TCHAR *	m_pszNames[ 15 ];
		TCHAR *	m_pszValues[ 15 ];

		TCHAR	m_chNameDelimiter;
		TCHAR	m_chValueDelimiter;
		TCHAR *	m_pszParams;
		int		m_iParamsLength;

};	//	End of class CCalltoParams.


//--------------------------------------------------------------------------//
//	class CCallto.															//
//--------------------------------------------------------------------------//
class CCallto
{
	public:

		CCallto(void);
		virtual ~CCallto(void);

	public:

		virtual HRESULT Callto
		(
			const TCHAR * const	pszCallto,				//	pointer to the callto url to try to place the call with...
			const TCHAR * const	pszDisplayName,			//	pointer to the display name to use...
			const NM_ADDR_TYPE	nmType,					//	callto type to resolve this callto as...
			const bool			bAddressOnly,			//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
			const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
			const bool			bAddToMru,				//	whether or not save in mru...
			const bool			bUIEnabled,				//	whether or not to perform user interaction on errors...
			const HWND			hwndParent,				//	if bUIEnabled is true this is the window to parent error/status windows to...
			INmCall ** const	ppInternalCall			//	out pointer to INmCall * to receive INmCall * generated by placing call...
		);

		virtual void SetGatekeeperEnabled
		(
			const bool	bEnabled					//	new Gatekeeper state
		);

		virtual HRESULT SetGatekeeperName
		(
			const TCHAR * const	pszGatekeeperName	//	new Gatekeeper name
		);

		virtual void SetGatewayEnabled
		(
			const bool	bEnabled					//	new Gateway state
		);

		virtual HRESULT SetGatewayName
		(
			const TCHAR * const	pszGatewayName		//	new Gateway name
		);

		virtual HRESULT SetIlsServerName
		(
			const TCHAR * const	pszServerName		//	pointer to new default Ils server name
		);

		static const int	s_iMaxCalltoLength;
		static const int	s_iMaxAddressLength;

        static bool DoUserValidation(const TCHAR * const pszCallto);


	private:

		HRESULT Parse
		(
			const TCHAR * const	pszCallto			//	pointer to the callto url to parse...
		);

		HRESULT ParseAddress(void);

		HRESULT Resolve
		(
			const NM_ADDR_TYPE	nmType				//	callto type to resolve this callto as if no type specified in the pszCallto parameter...
		);

		HRESULT PlaceCall
		(
			const TCHAR * const	pszCallto,			//	pointer to the callto url to try to place the call with...
			const bool			bAddToMru,			//	whether or not save in mru...
			const bool			bSecure,			//	whether or not to place the call securely...
			INmCall ** const	ppInternalCall		//	out pointer to INmCall * to receive INmCall * generated by placing call...
		);

		HRESULT GetValidatedSecurity
		(
			const bool * const	pbSecurityPreference,	//	pointer to security preference, NULL for none. must be "compatible" with secure param if present...
			bool &				bValidatedSecurity		//	out bool reference to recieve validated security setting
		);

		bool inGatekeeperMode(void);

		HRESULT GetGatekeeperIpAddress
		(
			unsigned long &	ulIpAddress				//	out unsigned long reference to receive gatekeeper IP address
		);

		bool inGatewayMode(void);

		HRESULT GetGatewayIpAddress
		(
			unsigned long &	ulIpAddress				//	out unsigned long reference to receive gateway IP address
		);

		HRESULT GetIpAddressFromIls
		(
			unsigned long &	ulIpAddress				//	out unsigned long reference to receive IP address
		);


	private:

		HWND			m_hwndParent;
		bool			m_bUnescapedAddressOnly;
		bool			m_bUIEnabled;
		unsigned long	m_ulDestination;
		TCHAR *			m_pszCalltoBuffer;
		TCHAR *			m_pszAddress;
		TCHAR *			m_pszParameters;
		TCHAR *			m_pszParsePos;
		TCHAR *			m_pszIlsServer;
		unsigned int	m_uiIlsPort;
		bool			m_bGatekeeperEnabled;
		TCHAR *			m_pszGatekeeperName;
		unsigned long	m_ulGatekeeperAddress;
		bool			m_bGatewayEnabled;
		TCHAR *			m_pszGatewayName;
		unsigned long	m_ulGatewayAddress;
		TCHAR *			m_pszDefaultIlsServerName;
		TCHAR *			m_pszEmail;
		TCHAR *			m_pszDisplayName;
		CCalltoParams	m_Parameters;
		NM_ADDR_TYPE	m_nmAddressType;

};	//	End of class CCallto.

//--------------------------------------------------------------------------//
#endif	//	!defined( callto_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltocontext.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"call.h"
#include	"confPolicies.h"
#include	"nmldap.h"
#include	"confroom.h"
#include	"regentry.h"

//#include	"debug.hpp"
#include	"callto.h"
#include	"calltoContext.h"
#include	"dlgAcd.h"
#include	"richAddr.h"


//--------------------------------------------------------------------------//
//	CUIContext::CUIContext.													//
//--------------------------------------------------------------------------//
CUIContext::CUIContext(void):
	m_parent( NULL ),
	m_callFlags( 0 )
{

}	//	End of CUIContext::CUIContext.


//--------------------------------------------------------------------------//
//	CUIContext::~CUIContext.												//
//--------------------------------------------------------------------------//
CUIContext::~CUIContext(void)
{
}	//	End of CUIContext::~CUIContext.


//--------------------------------------------------------------------------//
//	CUIContext::disambiguate.												//
//--------------------------------------------------------------------------//
HRESULT
CUIContext::disambiguate
(
	ICalltoCollection * const	calltoCollection,
	ICallto * const				,//emptyCallto,
	const ICallto ** const		selectedCallto
){
//trace( TEXT( "CUIContext::disambiguate()\r\n" ) );
	HRESULT	result	= S_FALSE;

	if( calltoCollection->get_count() > 1 )
	{
		static HRESULT	confidenceLevels[]	= {S_CONFIDENCE_CERTITUDE, S_CONFIDENCE_HIGH, S_CONFIDENCE_MEDIUM, S_CONFIDENCE_LOW};

		//	Just take the first highest confidence one until we have time to do something superior...
		for( int level = 0; (level < elementsof( confidenceLevels )) && (result == S_FALSE); level++ )
		{
			for(	*selectedCallto = calltoCollection->get_first();
					*selectedCallto != NULL;
					*selectedCallto = calltoCollection->get_next() )
			{
				if( (*selectedCallto)->get_confidence() == confidenceLevels[ level ] )
				{
					result = S_OK;
					break;
				}
			}
		}
	}

	if( result != S_OK )
	{
		::MessageBox( m_parent, RES2T( IDS_UNRESOLVED_MESSAGE ), RES2T( IDS_UNRESOLVED_CAPTION ), MB_OK );

		*selectedCallto = NULL;
	}

	return( result );

};	//	End of class CUIContext::disambiguate.


//--------------------------------------------------------------------------//
//	CUIContext::set_parentWindow.											//
//--------------------------------------------------------------------------//
void
CUIContext::set_parentWindow
(
	const HWND	window
){
//trace( TEXT( "CUIContext::set_parentWindow()\r\n" ) );

	m_parent = window;

};	//	End of class CUIContext::set_parentWindow.


//--------------------------------------------------------------------------//
//	CUIContext::set_callFlags.												//
//--------------------------------------------------------------------------//
void
CUIContext::set_callFlags
(
	const DWORD	callFlags
){
//trace( TEXT( "CUIContext::set_callFlags()\r\n" ) );

	m_callFlags = callFlags;

};	//	End of class CUIContext::set_callFlags.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::CGatekeeperContext.									//
//--------------------------------------------------------------------------//
CGatekeeperContext::CGatekeeperContext(void):
	m_enabled( false ),
	m_ipAddress( NULL )
{

}	//	End of CGatekeeperContext::CGatekeeperContext.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::~CGatekeeperContext.								//
//--------------------------------------------------------------------------//
CGatekeeperContext::~CGatekeeperContext(void)
{

	delete [] m_ipAddress;

}	//	End of CGatekeeperContext::~CGatekeeperContext.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::isEnabled.											//
//--------------------------------------------------------------------------//
bool
CGatekeeperContext::isEnabled(void) const
{

	return( m_enabled && (get_ipAddress() != NULL) );

}	//	End of CGatekeeperContext::isEnabled.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::get_ipAddress.										//
//--------------------------------------------------------------------------//
const TCHAR *
CGatekeeperContext::get_ipAddress(void) const
{

	return( m_ipAddress );

}	//	End of CGatekeeperContext::get_ipAddress.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::set_enabled.										//
//--------------------------------------------------------------------------//
void
CGatekeeperContext::set_enabled
(
	const bool	enabled
){

	m_enabled = enabled;

}	//	End of CGatekeeperContext::set_enabled.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::set_gatekeeperName.									//
//--------------------------------------------------------------------------//
HRESULT
CGatekeeperContext::set_gatekeeperName
(
	const TCHAR * const	gatekeeperName
){
	TCHAR	ipAddress[ MAX_PATH ];
	HRESULT	result	= CCalltoContext::get_ipAddressFromName( gatekeeperName, ipAddress, elementsof( ipAddress ) );

	if( result == S_OK )
	{
		result = set_ipAddress( ipAddress );
	}

	return( result );

}	//	End of CGatekeeperContext::set_gatekeeperName.


//--------------------------------------------------------------------------//
//	CGatekeeperContext::set_ipAddress.										//
//--------------------------------------------------------------------------//
HRESULT
CGatekeeperContext::set_ipAddress
(
	const TCHAR * const	ipAddress
){
	HRESULT	result	= S_FALSE;

	if( m_ipAddress != NULL )
	{
		delete [] m_ipAddress;
		m_ipAddress = NULL;
	}

	if( ipAddress != NULL )
	{
		if( (m_ipAddress = new TCHAR [ lstrlen( ipAddress ) + 1 ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( m_ipAddress, ipAddress );
			result = S_OK;
		}
	}

	return( result );

}	//	End of CGatekeeperContext::set_ipAddress.


//--------------------------------------------------------------------------//
//	CGatewayContext::CGatewayContext.										//
//--------------------------------------------------------------------------//
CGatewayContext::CGatewayContext(void):
	m_enabled( false ),
	m_ipAddress( NULL )
{
}	//	End of CGatewayContext::CGatewayContext.


//--------------------------------------------------------------------------//
//	CGatewayContext::~CGatewayContext.										//
//--------------------------------------------------------------------------//
CGatewayContext::~CGatewayContext(void)
{

	delete [] m_ipAddress;

}	//	End of CGatewayContext::~CGatewayContext.


//--------------------------------------------------------------------------//
//	CGatewayContext::isEnabled.												//
//--------------------------------------------------------------------------//
bool
CGatewayContext::isEnabled(void) const
{

	return( m_enabled && (get_ipAddress() != NULL) );

}	//	End of CGatewayContext::isEnabled.


//--------------------------------------------------------------------------//
//	CGatewayContext::get_ipAddress.											//
//--------------------------------------------------------------------------//
const TCHAR *
CGatewayContext::get_ipAddress(void) const
{

	return( m_ipAddress );

}	//	End of CGatewayContext::get_ipAddress.


//--------------------------------------------------------------------------//
//	CGatewayContext::set_enabled.											//
//--------------------------------------------------------------------------//
void
CGatewayContext::set_enabled
(
	const bool	enabled
){

	m_enabled = enabled;

}	//	End of CGatewayContext::set_enabled.


//--------------------------------------------------------------------------//
//	CGatewayContext::set_gatewayName.										//
//--------------------------------------------------------------------------//
HRESULT
CGatewayContext::set_gatewayName
(
	const TCHAR * const	gatewayName
){
	TCHAR	ipAddress[ MAX_PATH ];
	HRESULT	result	= CCalltoContext::get_ipAddressFromName( gatewayName, ipAddress, elementsof( ipAddress ) );

	if( result == S_OK )
	{
		result = set_ipAddress( ipAddress );
	}

	return( result );

}	//	End of CGatewayContext::set_gatewayName.


//--------------------------------------------------------------------------//
//	CGatewayContext::set_ipAddress.											//
//--------------------------------------------------------------------------//
HRESULT
CGatewayContext::set_ipAddress
(
	const TCHAR * const	ipAddress
){
	HRESULT	result	= S_FALSE;

	if( m_ipAddress != NULL )
	{
		delete [] m_ipAddress;
		m_ipAddress = NULL;
	}

	if( ipAddress != NULL )
	{
		if( (m_ipAddress = new TCHAR [ lstrlen( ipAddress ) + 1 ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( m_ipAddress, ipAddress );
			result = S_OK;
		}
	}

	return( result );

}	//	End of CGatewayContext::set_ipAddress.


//--------------------------------------------------------------------------//
//	CILSContext::CILSContext.												//
//--------------------------------------------------------------------------//
CILSContext::CILSContext
(
	const TCHAR * const	ilsServer
):
	m_enabled( false ),
	m_ipAddress( NULL ),
	m_ilsName( NULL )
{
}	//	End of CILSContext::CILSContext.


//--------------------------------------------------------------------------//
//	CILSContext::~CILSContext.												//
//--------------------------------------------------------------------------//
CILSContext::~CILSContext(void)
{

	delete [] m_ipAddress;
	delete [] m_ilsName;

}	//	End of CILSContext::~CILSContext.


//--------------------------------------------------------------------------//
//	CILSContext::isEnabled.													//
//--------------------------------------------------------------------------//
bool
CILSContext::isEnabled(void) const
{

	return( (g_pLDAP != NULL) && (ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct) );

}	//	End of CILSContext::isEnabled.


//--------------------------------------------------------------------------//
//	CILSContext::get_ipAddress.												//
//--------------------------------------------------------------------------//
const TCHAR *
CILSContext::get_ipAddress(void) const
{

	return( m_ipAddress );

}	//	End of CILSContext::get_ipAddress.


//--------------------------------------------------------------------------//
//	CILSContext::get_ilsName.												//
//--------------------------------------------------------------------------//
const TCHAR * const
CILSContext::get_ilsName(void) const
{

	return( m_ilsName );

}	//	End of CILSContext::get_ilsName.


//--------------------------------------------------------------------------//
//	CILSContext::set_enabled.												//
//--------------------------------------------------------------------------//
void
CILSContext::set_enabled
(
	const bool	enabled
){

	m_enabled = enabled;

}	//	End of CILSContext::set_enabled.


//--------------------------------------------------------------------------//
//	CILSContext::set_ilsName.												//
//--------------------------------------------------------------------------//
HRESULT
CILSContext::set_ilsName
(
	const TCHAR * const	ilsName
){
	HRESULT	result;

	if( m_ilsName && lstrcmpi( ilsName, m_ilsName ) == 0 )
	{
		result = S_OK;
	}
	else
	{
		result = E_FAIL;

		if( m_ilsName != NULL )
		{
			delete [] m_ilsName;
			m_ilsName = NULL;
		}

		if( ilsName != NULL )
		{
			if( (m_ilsName = new TCHAR [ lstrlen( ilsName ) + 1 ]) == NULL )
			{
				result = E_OUTOFMEMORY;
			}
			else
			{
				TCHAR	ipAddress[ MAX_PATH ];

				if( (result = CCalltoContext::get_ipAddressFromName( ilsName, ipAddress, elementsof( ipAddress ) )) == S_OK )
				{
					if( (result = set_ipAddress( ipAddress )) == S_OK )
					{
						lstrcpy( m_ilsName, ilsName );
					}
				}
			}
		}
	}

	return( result );

}	//	End of CILSContext::set_ilsName.


//--------------------------------------------------------------------------//
//	CILSContext::set_ipAddress.												//
//--------------------------------------------------------------------------//
HRESULT
CILSContext::set_ipAddress
(
	const TCHAR * const	ipAddress
){
	HRESULT	result	= S_FALSE;

	if( m_ipAddress != NULL )
	{
		delete [] m_ipAddress;
		m_ipAddress = NULL;
	}

	if( ipAddress != NULL )
	{
		if( (m_ipAddress = new TCHAR [ lstrlen( ipAddress ) + 1 ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			lstrcpy( m_ipAddress, ipAddress );
			result = S_OK;
		}
	}

	return( result );

}	//	End of CILSContext::set_ipAddress.


//--------------------------------------------------------------------------//
//	CCalltoContext::CCalltoContext.											//
//--------------------------------------------------------------------------//
CCalltoContext::CCalltoContext()
{
}	//	End of CCalltoContext::CCalltoContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::~CCalltoContext.										//
//--------------------------------------------------------------------------//
CCalltoContext::~CCalltoContext()
{
}	//	End of CCalltoContext::~CCalltoContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::callto.													//
//--------------------------------------------------------------------------//
HRESULT
CCalltoContext::callto
(
	const ICalltoProperties * const	calltoProperties,
	INmCall** ppInternalCall
){

	HRESULT	result	= CRPlaceCall( calltoProperties, this, ppInternalCall );

	if( FAILED( result ) )
	{
		DisplayCallError( result, calltoProperties->get_displayName() );
	}

	return( result );

}	//	End of CCalltoContext::callto.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_gatekeeperContext.									//
//--------------------------------------------------------------------------//
const IGatekeeperContext * const
CCalltoContext::get_gatekeeperContext(void) const
{

	return( (CGatekeeperContext::isEnabled())? this: NULL );

}	//	End of CCalltoContext::get_gatekeeperContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_gatewayContext.										//
//--------------------------------------------------------------------------//
const IGatewayContext * const
CCalltoContext::get_gatewayContext(void) const
{

	return( (CGatewayContext::isEnabled())? this: NULL );

}	//	End of CCalltoContext::get_gatewayContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_ilsContext.											//
//--------------------------------------------------------------------------//
const IILSContext * const
CCalltoContext::get_ilsContext(void) const
{

	return( (CILSContext::isEnabled())? this: NULL );

}	//	End of CCalltoContext::get_ilsContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableUIContext.									//
//--------------------------------------------------------------------------//
IMutableUIContext * const
CCalltoContext::get_mutableUIContext(void) const
{

	return( (IMutableUIContext * const) this );

}	//	End of CCalltoContext::get_mutableUIContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableGatekeeperContext.							//
//--------------------------------------------------------------------------//
IMutableGatekeeperContext * const
CCalltoContext::get_mutableGatekeeperContext(void) const
{

	return( (IMutableGatekeeperContext * const) this );

}	//	End of CCalltoContext::get_mutableGatekeeperContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableGatewayContext.								//
//--------------------------------------------------------------------------//
IMutableGatewayContext * const
CCalltoContext::get_mutableGatewayContext(void) const
{

	return( (IMutableGatewayContext * const) this );

}	//	End of CCalltoContext::get_mutableGatewayContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_mutableIlsContext.									//
//--------------------------------------------------------------------------//
IMutableILSContext * const
CCalltoContext::get_mutableIlsContext(void) const
{

	return( (IMutableILSContext * const) this );

}	//	End of CCalltoContext::get_mutableIlsContext.


//--------------------------------------------------------------------------//
//	CCalltoContext::isPhoneNumber.											//
//--------------------------------------------------------------------------//
bool
CCalltoContext::isPhoneNumber
(
	const TCHAR *	phone
){
	bool	result	= ((phone != NULL) && (phone[ 0 ] != '\0'));

	while( (phone != NULL) && (phone[ 0 ] != '\0') )
	{
		switch( phone[ 0 ] )
		{

			default:
				result = false;	//	fall through...

			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '(':
			case ')':
			case '#':
			case '*':
			case '-':
			case ',':
			case '+':
			case ' ':
				break;
		}
		
		phone++;
	}

	return( result );

}	//	End of CCalltoContext::isPhoneNumber.


//--------------------------------------------------------------------------//
//	CCalltoContext::toE164.													//
//--------------------------------------------------------------------------//
bool
CCalltoContext::toE164
(
	const TCHAR *	phone,
	TCHAR *			base10,
	int				size
){
	static TCHAR	base10map[]	=
	{
		0,		-1,		-1,		'#',	-1,		-1,		-1,		-1,		//	 !"#$%&'
		0,		0,		'*',	-1,		',',	0,		0,		-1,		//	()*+,-./
		'0',	'1',	'2',	'3',	'4',	'5',	'6',	'7',	//	01234567
		'8',	'9',	-1,		-1,		-1,		-1,		-1,		-1,		//	89:;<=>?
		-1,		'2',	'2',	'2',	'3',	'3',	'3',	'4',	//	@ABCDEFG
		'4',	'4',	'5',	'5',	'5',	'6',	'6',	'6',	//	HIJKLMNO
		'7',	'7',	'7',	'7',	'8',	'8',	'8',	'9',	//	PQRSTUVW
		'9',	'9',	'9',	-1,		-1,		-1,		-1,		-1,		//	XYZ[\]^_
		-1,		'2',	'2',	'2',	'3',	'3',	'3',	'4',	//	`abcdefg
		'4',	'4',	'5',	'5',	'5',	'6',	'6',	'6',	//	hijklmno
		'7',	'7',	'7',	'7',	'8',	'8',	'8',	'9',	//	pqrstuvw
		'9',	'9',	'9'												//	xyz
	};

	bool	result	= true;

	for( ; (*phone != NULL) && ((size > 0) || (base10 == NULL)) && result; phone++ )
	{
		if( (*phone >= ' ') && (*phone < (TCHAR) (' ' + elementsof( base10map ))) )
		{
			TCHAR	mapValue	= base10map[ *phone - ' ' ];

			if( mapValue == (TCHAR) -1 )
			{
				result = false;
			}
			else if( mapValue != (TCHAR) 0 )
			{
				if( base10 != NULL )
				{
					*base10++ = mapValue;
					size--;
				}
			}
		}
		else
		{
			result = false;
		}
	}

	if( (size <= 0) && (base10 != NULL) )
	{
		result = false;
	}
	else if( result )
	{
		if( base10 != NULL )
		{
			*base10 = NULL;
		}
	}

	return( result );

}	//	End of CCalltoContext::toE164.


//--------------------------------------------------------------------------//
//	CCalltoContext::isIPAddress.											//
//--------------------------------------------------------------------------//
bool
CCalltoContext::isIPAddress
(
	const TCHAR * const	ipAddress
){
	int		parts	= 0;
	bool	result;
	
	if( (result = (ipAddress != NULL)) != false )
	{
		const TCHAR *	ptr		= ipAddress;
		bool			newPart	= true;
		int				ipByte	= 0;
		int				base	= 10;

		while( result && (*ptr != NULL) && (parts <= 16) )
		{
			if( (*ptr >= '0') && (*ptr <= '9') )
			{
				if( newPart )
				{
					parts++;
					newPart = false;
				}

				if( (*ptr == '0') && (ipByte == 0) && (base == 10) )
				{
					base = 8;
				}
				else if( (base == 8) && ((*ptr == '8') || (*ptr == '9')) )
				{
					result = false;
				}
				else
				{
					ipByte = (ipByte * base) + (*ptr - '0');

					if( ipByte > 255 )
					{
						result = false;
					}
				}
			}
			else if( (*ptr >= 'A') && (*ptr <= 'F') )
			{
				if( base != 16 )
				{
					result = false;
				}
				else
				{
					if( newPart )
					{
						parts++;
						newPart = false;
					}

					ipByte = (ipByte * 16) + (*ptr - 'A' + 10);

					if( ipByte > 255 )
					{
						result = false;
					}
				}
			}
			else if( (*ptr >= 'a') && (*ptr <= 'f') )
			{
				if( base != 16 )
				{
					result = false;
				}
				else
				{
					if( newPart )
					{
						parts++;
						newPart = false;
					}

					ipByte = (ipByte * 16) + (*ptr - 'a' + 10);

					if( ipByte > 255 )
					{
						result = false;
					}
				}
			}
			else if( *ptr == '.' )
			{
				newPart	= true;
				ipByte	= 0;
				base	= 10;
			}
			else if( (*ptr == 'x') || (*ptr == 'X') )
			{
				base	= 16;
				result	= (ipByte == 0);
			}
			else
			{
				result = false;
			}

			ptr++;
		}

		if( result )
		{
			if( (parts != 4) && (parts != 16) )		//	4 for IPv4, 16 for IPv6 (IPng)...
			{
				if( (result = (parts < 4)) != false )
				{
#if !defined( UNICODE )
					result = (inet_addr( ipAddress ) != INADDR_NONE);	// Check for valid 1, 2, or 3 part IPv4 address...
#else
					result = false;

					char *	ansiIPAddress;
					int		size;

					size = WideCharToMultiByte(	CP_ACP,		// code page
												0,			// performance and mapping flags
												ipAddress,	// address of wide-character string
												-1,			// number of characters in string
												NULL,		// address of buffer for new string
												0,			// size of buffer
												NULL,		// address of default for unmappable characters
												NULL );		// address of flag set when default char. used

					if( (ansiIPAddress = new char [ size ]) != NULL )
					{
						size = WideCharToMultiByte(	CP_ACP,			// code page
													0,				// performance and mapping flags
													ipAddress,		// address of wide-character string
													-1,				// number of characters in string
													ansiIPAddress,	// address of buffer for new string
													size,			// size of buffer
													NULL,			// address of default for unmappable characters
													NULL );			// address of flag set when default char. used

						if( size != 0 )
						{
							result = (inet_addr( ansiIPAddress ) != INADDR_NONE);	// Check for valid 1-4 part IPv4 address...
						}

						delete [] ansiIPAddress;
					}
#endif	//	!defined( UNICODE )
				}
			}
		}
	}

	return( result );

}	//	End of CCalltoContext::isIPAddress.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_ipAddressFromName.									//
//--------------------------------------------------------------------------//
HRESULT
CCalltoContext::get_ipAddressFromName
(
	const TCHAR * const	name,
	TCHAR *				buffer,
	int					length
){
	HRESULT	result	= S_FALSE;

	if( (name != NULL) && (buffer != NULL) )
	{
		if( isIPAddress( name ) )
		{
			if( lstrlen( name ) < length )
			{
				lstrcpy( buffer, name );
				result = S_OK;
			}
		}
		else
		{
			HOSTENT *	hostEntry;

#if !defined( UNICODE )
			if( (hostEntry = gethostbyname( name )) != NULL )
			{
				if( hostEntry->h_addr_list[ 0 ] != NULL )
				{
					const char * const	ipAddress	= inet_ntoa( *((in_addr *) hostEntry->h_addr_list[ 0 ]) );

					if( lstrlen( ipAddress ) < length )
					{
						lstrcpy( buffer, ipAddress );
						result = S_OK;
					}
				}
			}
#else
			char *	ansiHost;
			int		size;

			size = WideCharToMultiByte(	CP_ACP,		// code page
										0,			// performance and mapping flags
										name,		// address of wide-character string
										-1,			// number of characters in string
										NULL,		// address of buffer for new string
										0,			// size of buffer
										NULL,		// address of default for unmappable characters
										NULL );		// address of flag set when default char. used

			if( (ansiHost = new char [ size ]) == NULL )
			{
				result = E_OUTOFMEMORY;
			}
			else
			{
				size = WideCharToMultiByte(	CP_ACP,		// code page
											0,			// performance and mapping flags
											name,		// address of wide-character string
											-1,			// number of characters in string
											ansiHost,	// address of buffer for new string
											size,		// size of buffer
											NULL,		// address of default for unmappable characters
											NULL );		// address of flag set when default char. used

				if( size != 0 )
				{
					if( (hostEntry = gethostbyname( ansiHost )) != NULL )
					{
						if( hostEntry->h_addr_list[ 0 ] != NULL )
						{
							const char * const	ipAddress = inet_ntoa( *((in_addr *) hostEntry->h_addr_list[ 0 ]) );

							if( lstrlen( ipAddress ) < length )
							{
								MultiByteToWideChar(	CP_ACP,				//	code page
														MB_PRECOMPOSED,		//	character-type options
														ipAddress,			//	string to convert
														-1,					//	length of string to convert
														buffer,				//	address of wide character buffer
														length );			//	size of buffer

								result = S_OK;
							}
						}
					}
				}

				delete [] ansiHost;
			}
#endif	// !defined( UNICODE )
		}
	}

	return( result );

}	//	End of CCalltoContext::get_ipAddressFromName.


//--------------------------------------------------------------------------//
//	CCalltoContext::get_ipAddressFromILSEmail.								//
//--------------------------------------------------------------------------//
HRESULT
CCalltoContext::get_ipAddressFromILSEmail
(
	const TCHAR * const	ilsServer,
	const TCHAR * const	ilsPort,
	const TCHAR * const	email,
	TCHAR * const		ipAddress,
	const int			size
){
	HRESULT	result;

	if( g_pLDAP == NULL )
	{
		g_pLDAP = new CNmLDAP;
	}

	if( g_pLDAP == NULL )
	{
		result = E_FAIL;
	}
	else
	{
		int	port	= (ilsPort != NULL)? (int) DecimalStringToUINT( ilsPort ): LDAP_PORT;

		result = g_pLDAP->ResolveUser( email, ilsServer, ipAddress, size, port );
	}

	return( result );

}	//	End of CCalltoContext::get_ipAddressFromILSEmail.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltonm.h ===
#if !defined( calltoNM_h )
#define	calltoNM_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoResolver.h"
#include	"calltoDisambiguator.h"


//--------------------------------------------------------------------------//
//	interface INMCallto.													//
//--------------------------------------------------------------------------//
class INMCallto
{
	protected:	//	protected constructors	--------------------------------//

		INMCallto(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~INMCallto(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		callto
		(
			const TCHAR * const	url,
			const bool			strict		= true,
			const bool			uiEnabled	= false,
			INmCall**			ppInternalCall = NULL
		) = 0;

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const = 0;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const = 0;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const = 0;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const = 0;

};	//	End of interface INMCallto.


//--------------------------------------------------------------------------//
//	class CNMCallto.														//
//--------------------------------------------------------------------------//
class CNMCallto:	public	INMCallto,
					private	CCalltoContext
{
	public:		//	public constructors	------------------------------------//

		CNMCallto(void);


	public:		//	public destructor	------------------------------------//

		~CNMCallto();


	public:		//	public methods	(INMCallto)	----------------------------//

		HRESULT
		callto
		(
			const TCHAR * const	url,
			const bool			strict		= true,
			const bool			uiEnabled	= false,
			INmCall**			ppInternalCall = NULL
		);

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const;


	private:	//	private methods	----------------------------------------//

		bool
		selfTest(void);


	public:		//	public members	----------------------------------------//

		HRESULT	m_selfTestResult;


	private:	//	private members	----------------------------------------//

		CCalltoResolver			m_resolver;
		CCalltoDisambiguator	m_disambiguator;

};	//	End of class CNMCallto.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoNM_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltodisambiguator.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoDisambiguator.h"


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::CCalltoDisambiguator.								//
//--------------------------------------------------------------------------//
CCalltoDisambiguator::CCalltoDisambiguator(void):
	m_registeredDisambiguators( 0 )
{

	addDisambiguator( &m_gatekeeperDisambiguator );
	addDisambiguator( &m_gatewayDisambiguator );
	addDisambiguator( &m_computerDisambiguator );
	addDisambiguator( &m_ilsDisambiguator );
	addDisambiguator( &m_unrecognizedDisambiguator );

}	//	End of CCalltoDisambiguator::CCalltoDisambiguator.


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::~CCalltoDisambiguator.							//
//--------------------------------------------------------------------------//
CCalltoDisambiguator::~CCalltoDisambiguator()
{
}	//	End of CCalltoDisambiguator::~CCalltoDisambiguator.


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::disambiguate.										//
//--------------------------------------------------------------------------//
HRESULT
CCalltoDisambiguator::disambiguate
(
	const ICalltoContext * const	calltoContext,
	ICalltoCollection * const		resolvedCalltoCollection,
	CCalltoCollection * const		disambiguatedCalltoCollection
){
	HRESULT	result;

	if( (calltoContext == NULL) || (resolvedCalltoCollection == NULL) || (disambiguatedCalltoCollection == NULL) )
	{
		result = E_POINTER;
	}
	else
	{
		result = S_UNDISAMBIGUATED;

		disambiguatedCalltoCollection->reset();

		//	Run through "smart" disambiguators...
		static HRESULT	confidenceLevels[]	= {S_CONFIDENCE_CERTITUDE, S_CONFIDENCE_HIGH, S_CONFIDENCE_MEDIUM, S_CONFIDENCE_LOW};

		const ICallto *	resolvedCallto;
		HRESULT			resolveResult	= S_OK;

		for( int level = 0; (level < elementsof( confidenceLevels )) && (resolveResult != S_CONFIDENCE_CERTITUDE); level++ )
		{
			for(	resolvedCallto = resolvedCalltoCollection->get_first();
					(resolvedCallto != NULL) && (resolveResult != S_CONFIDENCE_CERTITUDE);
					resolvedCallto = resolvedCalltoCollection->get_next() )
			{
				if( resolvedCallto->get_confidence() == confidenceLevels[ level ] )
				{
					for( int nn = 0; (nn < m_registeredDisambiguators) && (resolveResult != S_CONFIDENCE_CERTITUDE); nn++ )
					{
						resolveResult = m_disambiguators[ nn ]->disambiguate( calltoContext, disambiguatedCalltoCollection, resolvedCallto );

						if( FAILED( resolveResult ) && (!FAILED( result )) )
						{
							result = resolveResult;
						}
					}
				}
			}
		}
	}

	return( result );

}	//	End of CCalltoDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CCalltoDisambiguator::addDisambiguator.									//
//--------------------------------------------------------------------------//
bool
CCalltoDisambiguator::addDisambiguator
(
	IDisambiguator * const	disambiguator
){
//assert( disambiguator != NULL, TEXT( "attempted to add NULL disambiguator\r\n" ) );
//assert( m_registeredDisambiguators < elementsof( m_disambiguators ), TEXT( "attempted to add to many disambiguators: %d\r\n" ), m_registeredDisambiguators );

	if( (disambiguator != NULL) && (m_registeredDisambiguators < elementsof( m_disambiguators )) )
	{
		m_disambiguators[ m_registeredDisambiguators++ ] = disambiguator;
	}

	return( (disambiguator !=NULL ) && (m_registeredDisambiguators <= elementsof( m_disambiguators )) );

}	//	End of CCalltoDisambiguator::addDisambiguator.


//--------------------------------------------------------------------------//
//	CGatekeeperDisambiguator::disambiguate.									//
//--------------------------------------------------------------------------//
HRESULT
CGatekeeperDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	const IGatekeeperContext * const	gatekeeperContext	= calltoContext->get_gatekeeperContext();
	HRESULT								result				= S_UNDISAMBIGUATED;

	if( gatekeeperContext != NULL )
	{
		ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

		if( disambiguatedCallto != NULL )
		{
			disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
			disambiguatedCallto->set_destination( gatekeeperContext->get_ipAddress() );
			disambiguatedCallto->set_confidence( S_CONFIDENCE_CERTITUDE );
			result = S_CONFIDENCE_CERTITUDE;
		}
	}

	return( result );

}	//	End of CGatekeeperDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CGatewayDisambiguator::disambiguate.									//
//--------------------------------------------------------------------------//
HRESULT
CGatewayDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	HRESULT	result	= S_UNDISAMBIGUATED;

	if( lstrcmpi( resolvedCallto->get_type(), TEXT( "phone" ) ) == 0 )
	{
		const TCHAR * const	gateway	= resolvedCallto->get_gateway();

		if( gateway != NULL )
		{
			TCHAR	ipAddress[ MAX_PATH ];

			result = CCalltoContext::get_ipAddressFromName( gateway, ipAddress, elementsof( ipAddress ) );

			if( result == S_OK )
			{
				ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

				if( disambiguatedCallto == NULL )
				{
					result = S_UNDISAMBIGUATED;
				}
				else
				{
					disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
					disambiguatedCallto->set_destination( ipAddress );
					disambiguatedCallto->set_confidence( S_CONFIDENCE_CERTITUDE );
					result = S_CONFIDENCE_CERTITUDE;
				}
			}
		}
		else
		{
			const IGatewayContext * const	gatewayContext	= calltoContext->get_gatewayContext();

			if( gatewayContext != NULL )
			{
				ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

				if( disambiguatedCallto != NULL )
				{
					disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
					disambiguatedCallto->set_destination( gatewayContext->get_ipAddress() );
					disambiguatedCallto->set_confidence( S_CONFIDENCE_CERTITUDE );
					result = S_CONFIDENCE_CERTITUDE;
				}
			}
		}
	}

	return( result );

}	//	End of CGatewayDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CComputerDisambiguator::disambiguate.									//
//--------------------------------------------------------------------------//
HRESULT
CComputerDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	bool	ip			= (lstrcmpi( resolvedCallto->get_type(), TEXT( "ip" ) ) == 0);
	bool	computer	= (lstrcmpi( resolvedCallto->get_type(), TEXT( "computer" ) ) == 0);
	HRESULT	result		= S_UNDISAMBIGUATED;

	if( ip || computer )
	{
		TCHAR	ipAddress[ 64 ];

		result = CCalltoContext::get_ipAddressFromName(	resolvedCallto->get_value(),
														ipAddress,
														elementsof( ipAddress ) );

		if( result != S_OK )
		{
			result = S_UNDISAMBIGUATED;
		}
		else
		{
			ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

			if( disambiguatedCallto == NULL )
			{
				result = S_UNDISAMBIGUATED;
			}
			else
			{
				result = S_CONFIDENCE_CERTITUDE;

				disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
				disambiguatedCallto->set_destination( ipAddress );
				disambiguatedCallto->set_confidence( result );
			}
		}
	}

	return( result );

}	//	End of CComputerDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CILSDisambiguator::disambiguate.										//
//--------------------------------------------------------------------------//
HRESULT
CILSDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){
	const IILSContext * const	ilsContext	= calltoContext->get_ilsContext();
	const TCHAR * const			type		= resolvedCallto->get_type();
	const TCHAR *				ilsServer	= resolvedCallto->get_server();
	HRESULT						result		= S_FALSE;
	TCHAR						ipAddress[ MAX_PATH ];

	if( (ilsServer == NULL) && (ilsContext != NULL) )
	{
		ilsServer = ilsContext->get_ilsName();
	}

	if( ilsServer != NULL )
	{
		bool	ils	= (lstrcmpi( type, TEXT( "ils" ) ) == 0);

		if( ils || (lstrcmpi( type, TEXT( "email" ) ) == 0) )
		{
			result = CCalltoContext::get_ipAddressFromILSEmail(	ilsServer,
																resolvedCallto->get_serverPort(),
																resolvedCallto->get_value(),
																ipAddress,
																elementsof( ipAddress ) );
		
			if( result == S_OK )
			{
				ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

				if( disambiguatedCallto == NULL )
				{
					result = S_UNDISAMBIGUATED;
				}
				else
				{
					result = (ils)? S_CONFIDENCE_HIGH: S_CONFIDENCE_MEDIUM;

					disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
					disambiguatedCallto->set_destination( ipAddress );
					disambiguatedCallto->set_confidence( result );
				}
			}
		}
	}

	return( result );

}	//	End of CILSDisambiguator::disambiguate.


//--------------------------------------------------------------------------//
//	CUnrecognizedDisambiguator::disambiguate.								//
//--------------------------------------------------------------------------//
HRESULT
CUnrecognizedDisambiguator::disambiguate
(
	const ICalltoContext * const		calltoContext,
	IMutableCalltoCollection * const	calltoCollection,
	const ICallto * const				resolvedCallto
){

	if( calltoCollection->get_count() == 0 )
	{
		const TCHAR * const	type		= resolvedCallto->get_type();
		bool				phone		= (lstrcmpi( type, TEXT( "phone" ) ) == 0);
		bool				email		= (lstrcmpi( type, TEXT( "email" ) ) == 0);
		bool				ip			= (lstrcmpi( type, TEXT( "ip" ) ) == 0);
		bool				computer	= (lstrcmpi( type, TEXT( "computer" ) ) == 0);
		bool				ils			= (lstrcmpi( type, TEXT( "ils" ) ) == 0);
		bool				string		= (lstrcmpi( type, TEXT( "string" ) ) == 0);

		if( string || ((!phone) && (!email) && (!ip) && (!computer) && (!ils)) )
		{
			ICallto *	disambiguatedCallto	= calltoCollection->get_nextUnused();

			if( disambiguatedCallto != NULL )
			{
				disambiguatedCallto->set_qualifiedName( resolvedCallto->get_qualifiedName() );
				disambiguatedCallto->set_confidence( S_UNDISAMBIGUATED );
			}
		}
	}

	return( S_UNDISAMBIGUATED );

}	//	End of CUnrecognizedDisambiguator::disambiguate.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltonm.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoResolver.h"
#include	"calltoDisambiguator.h"
#include	"calltoNM.h"


//--------------------------------------------------------------------------//
//	CNMCallto::CNMCallto.													//
//--------------------------------------------------------------------------//
CNMCallto::CNMCallto(void)
{
//tracec( assert( selfTest(), TEXT( "class CNMCallto failed self test..." ) ),
//			TEXT( "class CNMCallto passed self test...\r\n" ) );

}	//	End of CNMCallto::CNMCallto.


//--------------------------------------------------------------------------//
//	CNMCallto::~CNMCallto.													//
//--------------------------------------------------------------------------//
CNMCallto::~CNMCallto(void)
{
}	//	End of CNMCallto::~CNMCallto.


//--------------------------------------------------------------------------//
//	CNMCallto::callto.														//
//--------------------------------------------------------------------------//
HRESULT
CNMCallto::callto
(
	const TCHAR * const	url,
	const bool			strict,
	const bool			uiEnabled,
	INmCall**			ppInternalCall
){
	CCalltoProperties	calltoProperties;
	CCalltoCollection	resolvedCalltoCollection;
	CCalltoCollection	disambiguatedCalltoCollection;
	const ICallto *		disambiguatedCallto	= NULL;
	HRESULT				result;

	if( url == NULL )
	{
		result = E_POINTER;
	}
	else if( url[ 0 ] == '\0' )
	{
		result = E_INVALIDARG;
	}
	else
	{
		result = m_resolver.resolve( this, &calltoProperties, &resolvedCalltoCollection, url, strict );

		if( resolvedCalltoCollection.get_count() > 0 )
		{
			result = m_disambiguator.disambiguate( this, &resolvedCalltoCollection, &disambiguatedCalltoCollection );

			if( (!uiEnabled) || (disambiguatedCalltoCollection.get_count() == 1) )
			{
				//	Either there's only one choice or we've been instructed NOT to
				//	present any ui...   either way we just grab the first one...
				disambiguatedCallto = disambiguatedCalltoCollection.get_first();

				//	and verify that it was really disambiguated...
				if( disambiguatedCallto->get_confidence() != S_UNDISAMBIGUATED )
				{
					result = S_OK;
				}
				else
				{
					disambiguatedCallto = NULL;
				}
			}
		}
	}

	CCallto	emptyCallto;

	if( uiEnabled && (disambiguatedCallto == NULL) )
	{
		//	the user must now make the decision...
		result = disambiguate( &disambiguatedCalltoCollection, &emptyCallto, &disambiguatedCallto );
	}

	if( (result == S_OK) && (disambiguatedCallto != NULL) )
	{
		calltoProperties.set_url( disambiguatedCallto->get_qualifiedName() );
		calltoProperties.set_destination( disambiguatedCallto->get_destination() );
		calltoProperties.set_type( disambiguatedCallto->get_type() );
		calltoProperties.set_alias( disambiguatedCallto->get_value() );

		if( StrCmpNI_literal( disambiguatedCallto->get_type(), TEXT( "phone" ) ) )
		{
			calltoProperties.set_E164( disambiguatedCallto->get_value() );
		}

		result = ((ICalltoContext *) this)->callto( &calltoProperties, ppInternalCall );
	}

	return( result );

}	//	End of CNMCallto::callto.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableUIContext.										//
//--------------------------------------------------------------------------//
IMutableUIContext * const
CNMCallto::get_mutableUIContext(void) const
{

	return( CCalltoContext::get_mutableUIContext() );

}	//	End of CNMCallto::get_mutableUIContext.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableGatekeeperContext.								//
//--------------------------------------------------------------------------//
IMutableGatekeeperContext * const
CNMCallto::get_mutableGatekeeperContext(void) const
{

	return( CCalltoContext::get_mutableGatekeeperContext() );

}	//	End of CNMCallto::get_mutableGatekeeperContext.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableGatewayContext.									//
//--------------------------------------------------------------------------//
IMutableGatewayContext * const
CNMCallto::get_mutableGatewayContext(void) const
{

	return( CCalltoContext::get_mutableGatewayContext() );

}	//	End of CNMCallto::get_mutableGatewayContext.


//--------------------------------------------------------------------------//
//	CNMCallto::get_mutableIlsContext.										//
//--------------------------------------------------------------------------//
IMutableILSContext * const
CNMCallto::get_mutableIlsContext(void) const
{

	return( CCalltoContext::get_mutableIlsContext() );

}	//	End of CNMCallto::get_mutableIlsContext.


#if 0
//--------------------------------------------------------------------------//
//	CNMCallto::selfTest.													//
//--------------------------------------------------------------------------//
bool
CNMCallto::selfTest(void)
{
	static TCHAR	buffer[ 2048 ];
	static LONG		tested	= -1;
	
	static HRESULT	confidenceLevels[]	=
	{
		S_CONFIDENCE_CERTITUDE,
		S_CONFIDENCE_HIGH,
		S_CONFIDENCE_MEDIUM,
		S_CONFIDENCE_LOW
	};

	static const TCHAR *	testUrls[]	=
	{
		TEXT( "callto:myGateway|email:jlemire@microsoft.com" ),			//	full
		TEXT( "callto:myGateway|email:jlemire" ),
		TEXT( "callto:myGateway|phone:1 (425) 703-9224" ),
		TEXT( "callto:myGateway|phone:1 (800) RU LEGIT" ),
		TEXT( "callto:myGateway|string:helpdesk" ),
		TEXT( "callto:myGateway|ils:jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|ip:157.59.14.64" ),
		TEXT( "callto:myGateway|computer:JLEMIRE-2" ),
		TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2" ),

		TEXT( "callto:email:jlemire@microsoft.com" ),					//	no gateway
		TEXT( "callto:email:jlemire" ),
		TEXT( "callto:phone:1 (425) 703-9224" ),
		TEXT( "callto:phone:1 (800) RU LEGIT" ),
		TEXT( "callto:string:helpdesk" ),
		TEXT( "callto:ils:jlemire@microsoft.com" ),
		TEXT( "callto:ils:msils/jlemire@microsoft.com" ),
		TEXT( "callto:ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:ip:157.59.14.64" ),
		TEXT( "callto:computer:JLEMIRE-2" ),
		TEXT( "callto:computer:\\\\JLEMIRE-2" ),

		TEXT( "callto:myGateway|jlemire@microsoft.com" ),				//	no type
		TEXT( "callto:myGateway|jlemire" ),
		TEXT( "callto:myGateway|1 (425) 703-9224" ),
		TEXT( "callto:myGateway|1 (800) RU LEGIT" ),
		TEXT( "callto:myGateway|helpdesk" ),
		TEXT( "callto:myGateway|jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|msils/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:myGateway|157.59.14.64" ),
		TEXT( "callto:myGateway|JLEMIRE-2" ),
		TEXT( "callto:myGateway|\\\\JLEMIRE-2" ),

		TEXT( "callto:jlemire@microsoft.com" ),							//	no gateway + no type
		TEXT( "callto:jlemire" ),
		TEXT( "callto:1 (425) 703-9224" ),
		TEXT( "callto:1 (800) RU LEGIT" ),
		TEXT( "callto:helpdesk" ),
		TEXT( "callto:jlemire@microsoft.com" ),
		TEXT( "callto:msils/jlemire@microsoft.com" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com" ),
		TEXT( "callto:157.59.14.64" ),
		TEXT( "callto:JLEMIRE-2" ),
		TEXT( "callto:\\\\JLEMIRE-2" ),

		//	repeat with params
		TEXT( "callto:myGateway|email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),			//	full
		TEXT( "callto:myGateway|email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		TEXT( "callto:email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),					//	no gateway
		TEXT( "callto:email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),				//	no type
		TEXT( "callto:myGateway|jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:myGateway|\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),							//	no gateway + no type
		TEXT( "callto:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),
		TEXT( "callto:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" ),

		//	repeat without callto:
		TEXT( "myGateway|email:jlemire@microsoft.com" ),				//	full
		TEXT( "myGateway|email:jlemire" ),
		TEXT( "myGateway|phone:1 (425) 703-9224" ),
		TEXT( "myGateway|phone:1 (800) RU LEGIT" ),
		TEXT( "myGateway|string:helpdesk" ),
		TEXT( "myGateway|ils:jlemire@microsoft.com" ),
		TEXT( "myGateway|ils:msils/jlemire@microsoft.com" ),
		TEXT( "myGateway|ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "myGateway|ip:157.59.14.64" ),
		TEXT( "myGateway|computer:JLEMIRE-2" ),
		TEXT( "myGateway|computer:\\\\JLEMIRE-2" ),

		TEXT( "email:jlemire@microsoft.com" ),							//	no gateway
		TEXT( "email:jlemire" ),
		TEXT( "phone:1 (425) 703-9224" ),
		TEXT( "phone:1 (800) RU LEGIT" ),
		TEXT( "string:helpdesk" ),
		TEXT( "ils:jlemire@microsoft.com" ),
		TEXT( "ils:msils/jlemire@microsoft.com" ),
		TEXT( "ils:msils:80/jlemire@microsoft.com" ),
		TEXT( "ip:157.59.14.64" ),
		TEXT( "computer:JLEMIRE-2" ),
		TEXT( "computer:\\\\JLEMIRE-2" ),

		TEXT( "myGateway|jlemire@microsoft.com" ),						//	no type
		TEXT( "myGateway|jlemire" ),
		TEXT( "myGateway|1 (425) 703-9224" ),
		TEXT( "myGateway|1 (800) RU LEGIT" ),
		TEXT( "myGateway|helpdesk" ),
		TEXT( "myGateway|jlemire@microsoft.com" ),
		TEXT( "myGateway|msils/jlemire@microsoft.com" ),
		TEXT( "myGateway|msils:80/jlemire@microsoft.com" ),
		TEXT( "myGateway|157.59.14.64" ),
		TEXT( "myGateway|JLEMIRE-2" ),
		TEXT( "myGateway|\\\\JLEMIRE-2" ),

		TEXT( "jlemire@microsoft.com" ),								//	no gateway + no type
		TEXT( "jlemire" ),
		TEXT( "1 (425) 703-9224" ),
		TEXT( "1 (800) RU LEGIT" ),
		TEXT( "helpdesk" ),
		TEXT( "jlemire@microsoft.com" ),
		TEXT( "msils/jlemire@microsoft.com" ),
		TEXT( "msils:80/jlemire@microsoft.com" ),
		TEXT( "msils:80/jlemire@microsoft.com" ),
		TEXT( "157.59.14.64" ),
		TEXT( "JLEMIRE-2" ),
		TEXT( "\\\\JLEMIRE-2" ),

		TEXT( "callto:futuretype:aren't I nicely extensible?" ),
		TEXT( "callto:myGateway|futuretype:aren't I nicely extensible?" )
	};

	static TCHAR *	expectedResults[ elementsof( testUrls ) ]	=
	{
		TEXT( "callto:myGateway|email:jlemire@microsoft.com" ),			//	TEXT( "callto:myGateway|email:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|email:jlemire" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|string:helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:email:jlemire@microsoft.com" ),
		TEXT( "" ),		//	TEXT( "callto:email:jlemire" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:string:helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:jlemire" )
		TEXT( "" ),		//	TEXT( "callto:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "callto:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "callto:helpdesk" )
		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "callto:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "callto:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "callto:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:myGateway|email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "callto:email:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:email:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:phone:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:string:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ils:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ils:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:ip:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:computer:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:computer:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:myGateway|\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:jlemire+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:1 (425) 703-9224+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:1 (800) RU LEGIT+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:helpdesk+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:msils/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:msils:80/jlemire@microsoft.com+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:157.59.14.64+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )
		TEXT( "" ),		//	TEXT( "callto:\\\\JLEMIRE-2+secure+certificate=NetMeeting Default Certificate+mysteryParam=" )

		TEXT( "" ),		//	TEXT( "myGateway|email:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|email:jlemire" )
		TEXT( "" ),		//	TEXT( "myGateway|phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "myGateway|phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "myGateway|string:helpdesk" )
		TEXT( "" ),		//	TEXT( "myGateway|ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "myGateway|computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "myGateway|computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "email:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "email:jlemire" )
		TEXT( "" ),		//	TEXT( "phone:1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "phone:1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "string:helpdesk" )
		TEXT( "" ),		//	TEXT( "ils:jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "ils:msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "ils:msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "ip:157.59.14.64" )
		TEXT( "" ),		//	TEXT( "computer:JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "computer:\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|jlemire" )
		TEXT( "" ),		//	TEXT( "myGateway|1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "myGateway|1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "myGateway|helpdesk" )
		TEXT( "" ),		//	TEXT( "myGateway|jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "myGateway|157.59.14.64" )
		TEXT( "" ),		//	TEXT( "myGateway|JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "myGateway|\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "jlemire" )
		TEXT( "" ),		//	TEXT( "1 (425) 703-9224" )
		TEXT( "" ),		//	TEXT( "1 (800) RU LEGIT" )
		TEXT( "" ),		//	TEXT( "helpdesk" )
		TEXT( "" ),		//	TEXT( "jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "msils/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "msils:80/jlemire@microsoft.com" )
		TEXT( "" ),		//	TEXT( "157.59.14.64" )
		TEXT( "" ),		//	TEXT( "JLEMIRE-2" )
		TEXT( "" ),		//	TEXT( "\\\\JLEMIRE-2" )

		TEXT( "" ),		//	TEXT( "callto:futuretype:aren't I nicely extensible?" )
		TEXT( "" )		//	TEXT( "callto:myGateway|futuretype:aren't I nicely extensible?" 
	};

	static int		contexts[ 4 ];
	static TCHAR *	actualResults[ elementsof( testUrls ) * elementsof( contexts ) ];

	HRESULT	result	= S_OK;

	if( InterlockedIncrement( &tested ) == 0 )
	{
		CCalltoProperties	calltoProperties;
		CCalltoCollection	resolvedCalltoCollection;
		CCalltoCollection	disambiguatedCalltoCollection;

		for( int context = 0; context < elementsof( contexts ); context++ )
		{
			CGatekeeperContext::set_enabled( context == 0 );
			CGatewayContext::set_enabled( context == 1 );
			CILSContext::set_enabled( context == 2 );

			for( int nn = 0; nn < elementsof( testUrls ); nn++ )
			{
				HRESULT	testResult	= m_resolver.resolve( this, &calltoProperties, &resolvedCalltoCollection, testUrls[ nn ], false );

				if( testResult != S_OK )
				{
					wsprintf( buffer, TEXT( "NOT RESOLVED!!!\t\tresult:0x%08X:\r\n" ), testResult );

					if( FAILED( testResult ) && (!FAILED( result )) )
					{
						result = testResult;		
					}
					else if( !FAILED( result ) )
					{
						result = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, nn );
					}
				}
				else
				{
					*buffer = NULL;

					for( int level = 0; level < elementsof( confidenceLevels ); level++ )
					{
						const ICallto *	resolvedCallto;

						for(	resolvedCallto = resolvedCalltoCollection.get_first();
								resolvedCallto != NULL;
								resolvedCallto = resolvedCalltoCollection.get_next() )
						{
							if( resolvedCallto->get_confidence() == confidenceLevels[ level ] )
							{
								wsprintf( &buffer[ lstrlen( buffer ) ], TEXT( "\t\t\t%9s: %s\r\n" ), ((confidenceLevels[ level ] == S_CONFIDENCE_CERTITUDE)? TEXT( "CERTITUDE" ): ((confidenceLevels[ level ] == S_CONFIDENCE_HIGH)? TEXT( "HIGH" ): ((confidenceLevels[ level ] == S_CONFIDENCE_MEDIUM)? TEXT( "MEDIUM" ): TEXT( "LOW" )))), resolvedCallto->get_qualifiedName() );
							}
						}
					}

					testResult = m_disambiguator.disambiguate( this, &calltoProperties, &resolvedCalltoCollection, &disambiguatedCalltoCollection );

					if( disambiguatedCalltoCollection.get_count() == 0 )
					{
						wsprintf( buffer, TEXT( "NOT DISAMBIGUATED!!!\t\tresult:0x%08X:\r\n" ), testResult );

						actualResults[ nn + (context * elementsof( testUrls )) ] = NULL;

						if( FAILED( testResult ) && (!FAILED( result )) )
						{
							result = testResult;		
						}
						else if( !FAILED( result ) )
						{
							result = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, nn );
						}
					}
					else
					{
						const ICallto *	disambiguatedCallto	= disambiguatedCalltoCollection.get_first();

						level = disambiguatedCallto->get_confidence();

						wsprintf( &buffer[ lstrlen( buffer ) ], TEXT( "\r\n%9s:\t%s\tresult:0x%08X\r\n" ), ((level == S_CONFIDENCE_CERTITUDE)? TEXT( "CERTITUDE" ): ((level == S_CONFIDENCE_HIGH)? TEXT( "HIGH" ): ((level == S_CONFIDENCE_MEDIUM)? TEXT( "MEDIUM" ): TEXT( "LOW" )))), disambiguatedCallto->get_qualifiedName(), testResult );
					}
				}

				if( (actualResults[ nn + (context * elementsof( testUrls )) ] = new TCHAR [ lstrlen( buffer ) + 1 ]) != NULL )
				{
					lstrcpy( actualResults[ nn + (context * elementsof( testUrls )) ], buffer );
				}
			}
		}

		for( int nn = 0; nn < elementsof( actualResults ); nn++ )
		{
			trace( TEXT( "------------------------------------------------------------------------------\r\n" ) );
			trace( TEXT( "%03d:\tgatekeeper:%-5s\tgateway:%s\tils:%s\r\n\r\n" ), nn, (((nn / elementsof( testUrls )) == 0)? TEXT( "true" ): TEXT( "false" )), (((nn / elementsof( testUrls )) == 1)? TEXT( "true" ): TEXT( "false" )), (((nn / elementsof( testUrls )) == 2)? TEXT( "true" ): TEXT( "false" )) );
			trace( TEXT( "\t\t\t%s\r\n" ), testUrls[ nn % elementsof( testUrls ) ] );
			trace( TEXT( "%s" ), actualResults[ nn ] );
			trace( TEXT( "------------------------------------------------------------------------------\r\n\r\n" ) );
			delete [] actualResults[ nn ];
		}

		m_selfTestResult = result;
	}

	return( result == S_OK );

}	//	End of CNMCallto::selfTest.


//--------------------------------------------------------------------------//
//	Win32 console process entry point.										//
//--------------------------------------------------------------------------//
int
main
(
	int					,//ArgC,
	const char * const	//ArgV[]
){
	CNMCallto	callto;		//	Just instantiating one of these will also cause CCalltoResolver::selfTest() to run...

	callto.callto( TEXT( "jlemire" ), false );	//	not strict...

	return( (int) callto.m_selfTestResult );

}	//	End of main.
#endif	//	0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltocontext.h ===
#if !defined( calltoContext_h )
#define	calltoContext_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"SDKInternal.h"


//--------------------------------------------------------------------------//
//	interface IUIContext.													//
//--------------------------------------------------------------------------//
class IUIContext
{
	protected:	//	protected constructors	--------------------------------//

		IUIContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IUIContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		disambiguate
		(
			ICalltoCollection * const	calltoCollection,
			ICallto * const				emptyCallto,
			const ICallto ** const		selectedCallto
		) = 0;

};	//	End of interface IUIContext.


//--------------------------------------------------------------------------//
//	interface IMutableUIContext.											//
//--------------------------------------------------------------------------//
class IMutableUIContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableUIContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableUIContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_parentWindow
		(
			const HWND	window
		) = 0;

		virtual
		void
		set_callFlags
		(
			const DWORD	callFlags
		) = 0;

};	//	End of interface IMutableUIContext.


//--------------------------------------------------------------------------//
//	class CUIContext.														//
//--------------------------------------------------------------------------//
class CUIContext:	public	IUIContext,
					public	IMutableUIContext
{
	public:		//	public constructors	------------------------------------//

		CUIContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CUIContext();


	public:		//	public methods	(IUIContext)	------------------------//

		virtual
		HRESULT
		disambiguate
		(
			ICalltoCollection * const	calltoCollection,
			ICallto * const				emptyCallto,
			const ICallto ** const		callto
		);


	public:		//	public methods	(IMutableUIContext)	--------------------//

		virtual
		void
		set_parentWindow
		(
			const HWND	window
		);

		virtual
		void
		set_callFlags
		(
			const DWORD	callFlags
		);


	private:	//	private members	----------------------------------------//

		HWND	m_parent;
		DWORD	m_callFlags;

};	//	End of class CUIContext.


//--------------------------------------------------------------------------//
//	interface IGatekeeperContext.											//
//--------------------------------------------------------------------------//
class IGatekeeperContext
{
	protected:	//	protected constructors	--------------------------------//

		IGatekeeperContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IGatekeeperContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		bool
		isEnabled(void) const = 0;

		virtual
		const TCHAR *
		get_ipAddress(void) const = 0;

};	//	End of interface IGatekeeperContext.


//--------------------------------------------------------------------------//
//	interface IMutableGatekeeperContext.									//
//--------------------------------------------------------------------------//
class IMutableGatekeeperContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableGatekeeperContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableGatekeeperContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		) = 0;

		virtual
		HRESULT
		set_gatekeeperName
		(
			const TCHAR * const	gatekeeperName
		) = 0;

};	//	End of interface IMutableGatekeeperContext.


//--------------------------------------------------------------------------//
//	class CGatekeeperContext.												//
//--------------------------------------------------------------------------//
class CGatekeeperContext:	public	IGatekeeperContext,
							public	IMutableGatekeeperContext
{
	public:		//	public constructors	------------------------------------//

		CGatekeeperContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CGatekeeperContext();


	public:		//	public methods	(IGatekeeperContext)	----------------//

		virtual
		bool
		isEnabled(void) const;

		virtual
		const TCHAR *
		get_ipAddress(void) const;


	public:		//	public methods	(IMutableGatekeeperContext)	------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		);

		virtual
		HRESULT
		set_gatekeeperName
		(
			const TCHAR * const	gatekeeperName
		);


	private:		//	private methods	------------------------------------//

		virtual
		HRESULT
		set_ipAddress
		(
			const TCHAR * const	ipAddress
		);


	private:	//	private members	----------------------------------------//

		bool	m_enabled;
		TCHAR *	m_ipAddress;

};	//	End of class CGatekeeperContext.


//--------------------------------------------------------------------------//
//	interface IGatewayContext.												//
//--------------------------------------------------------------------------//
class IGatewayContext
{
	protected:	//	protected constructors	--------------------------------//

		IGatewayContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IGatewayContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		bool
		isEnabled(void) const = 0;

		virtual
		const TCHAR *
		get_ipAddress(void) const = 0;

};	//	End of interface IGatewayContext.


//--------------------------------------------------------------------------//
//	interface IMutableGatewayContext.										//
//--------------------------------------------------------------------------//
class IMutableGatewayContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableGatewayContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableGatewayContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		) = 0;

		virtual
		HRESULT
		set_gatewayName
		(
			const TCHAR * const	gatewayName
		) = 0;

};	//	End of interface IMutableGatewayContext.


//--------------------------------------------------------------------------//
//	class CGatewayContext.													//
//--------------------------------------------------------------------------//
class CGatewayContext:	public	IGatewayContext,
						public	IMutableGatewayContext
{
	public:		//	public constructors	------------------------------------//

		CGatewayContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CGatewayContext();


	public:		//	public methods	(IGatewayContext)	--------------------//

		virtual
		bool
		isEnabled(void) const;

		virtual
		const TCHAR *
		get_ipAddress(void) const;


	public:		//	public methods	(IMutableGatewayContext)	------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		);

		virtual
		HRESULT
		set_gatewayName
		(
			const TCHAR * const	gatewayName
		);


	private:	//	private methods	----------------------------------------//

		virtual
		HRESULT
		set_ipAddress
		(
			const TCHAR * const	ipAddress
		);


	private:	//	private members	----------------------------------------//

		bool	m_enabled;
		TCHAR *	m_ipAddress;

};	//	End of class CGatewayContext.


//--------------------------------------------------------------------------//
//	interface IILSContext.													//
//--------------------------------------------------------------------------//
class IILSContext
{
	protected:	//	protected constructors	--------------------------------//

		IILSContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IILSContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		bool
		isEnabled(void) const = 0;

		virtual
		const TCHAR *
		get_ipAddress(void) const = 0;

		virtual
		const TCHAR * const
		get_ilsName(void) const = 0;

};	//	End of interface IILSContext.


//--------------------------------------------------------------------------//
//	interface IMutableILSContext.											//
//--------------------------------------------------------------------------//
class IMutableILSContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableILSContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableILSContext(){};


	public:		//	public methods	----------------------------------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		) = 0;

		virtual
		HRESULT
		set_ilsName
		(
			const TCHAR * const	ilsName
		) = 0;

};	//	End of interface IMutableILSContext.


//--------------------------------------------------------------------------//
//	class CILSContext.														//
//--------------------------------------------------------------------------//
class CILSContext:	public	IILSContext,
					public	IMutableILSContext
{
	public:		//	public constructors	------------------------------------//

		CILSContext
		(
			const TCHAR * const	ilsServer = NULL
		);


	public:		//	public destructor	------------------------------------//

		virtual
		~CILSContext();


	public:		//	public methods	(IILSContext)	------------------------//

		virtual
		bool
		isEnabled(void) const;

		virtual
		const TCHAR *
		get_ipAddress(void) const;

		virtual
		const TCHAR * const
		get_ilsName(void) const;


	public:		//	public methods	(IMutableILSContext)	----------------//

		virtual
		void
		set_enabled
		(
			const bool	enabled
		);

		virtual
		HRESULT
		set_ilsName
		(
			const TCHAR * const	ilsName
		);


	private:	//	private methods	----------------------------------------//

		virtual
		HRESULT
		set_ipAddress
		(
			const TCHAR * const	ipAddress
		);


	private:	//	private members	----------------------------------------//

		bool	m_enabled;
		TCHAR *	m_ipAddress;
		TCHAR *	m_ilsName;

};	//	End of class CILSContext.


//--------------------------------------------------------------------------//
//	interface ICalltoContext.												//
//--------------------------------------------------------------------------//
class ICalltoContext
{
	protected:	//	protected constructors	--------------------------------//

		ICalltoContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~ICalltoContext(){}


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		callto
		(
			const ICalltoProperties * const	calltoProperties,
			INmCall** ppInternalCall
		)	= 0;

		virtual
		const IGatekeeperContext * const
		get_gatekeeperContext(void) const = 0;

		virtual
		const IGatewayContext * const
		get_gatewayContext(void) const = 0;

		virtual
		const IILSContext * const
		get_ilsContext(void) const = 0;

};	//	End of interface ICalltoContext.


//--------------------------------------------------------------------------//
//	interface IMutableCalltoContext.										//
//--------------------------------------------------------------------------//
class IMutableCalltoContext
{
	protected:	//	protected constructors	--------------------------------//

		IMutableCalltoContext(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IMutableCalltoContext(){}


	public:		//	public methods	----------------------------------------//

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const = 0;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const = 0;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const = 0;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const = 0;

};	//	End of interface IMutableCalltoContext.


//--------------------------------------------------------------------------//
//	class CCalltoContext.													//
//--------------------------------------------------------------------------//
class CCalltoContext:	public	ICalltoContext,
						public	IMutableCalltoContext,
						public	CUIContext,
						public	CGatekeeperContext,
						public	CGatewayContext,
						public	CILSContext
{
	public:		//	public constructors	------------------------------------//

		CCalltoContext();


	public:		//	public destructor	------------------------------------//

		virtual
		~CCalltoContext();


	public:		//	public methods	(ICalltoContext)	--------------------//

		virtual
		HRESULT
		callto
		(
			const ICalltoProperties * const	calltoProperties,
			INmCall** ppInternalCall
		);

		virtual
		const IGatekeeperContext * const
		get_gatekeeperContext(void) const;

		virtual
		const IGatewayContext * const
		get_gatewayContext(void) const;

		virtual
		const IILSContext * const
		get_ilsContext(void) const;


	public:		//	public methods	(IMutableCalltoContext)	----------------//

		virtual
		IMutableUIContext * const
		get_mutableUIContext(void) const;

		virtual
		IMutableGatekeeperContext * const
		get_mutableGatekeeperContext(void) const;

		virtual
		IMutableGatewayContext * const
		get_mutableGatewayContext(void) const;

		virtual
		IMutableILSContext * const
		get_mutableIlsContext(void) const;


	public:	//	public static methods	------------------------------------//

		static
		bool
		isPhoneNumber
		(
			const TCHAR *	phone
		);

		static
		bool
		toE164
		(
			const TCHAR *	phone,
			TCHAR *			base10,
			int				size
		);

		static
		bool
		isIPAddress
		(
			const TCHAR * const	ipAddress
		);

		static
		HRESULT
		get_ipAddressFromName
		(
			const TCHAR * const	name,
			TCHAR *				buffer,
			int					length
		);

		static
		HRESULT
		get_ipAddressFromILSEmail
		(
			const TCHAR * const	ilsServer,
			const TCHAR * const	ilsPort,
			const TCHAR * const	email,
			TCHAR * const		ipAddress,
			const int			size
		);

};	//	End of class CCalltoContext.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoContext_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltoresolver.cpp ===
//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"precomp.h"
#include	"callto.h"
#include	"calltoContext.h"
#include	"calltoResolver.h"


//--------------------------------------------------------------------------//
//	CCalltoResolver::CCalltoResolver.										//
//--------------------------------------------------------------------------//
CCalltoResolver::CCalltoResolver(void):
	m_registeredResolvers( 0 )
{

	addResolver( &m_phoneResolver );
	addResolver( &m_emailResolver );
	addResolver( &m_ipResolver );
	addResolver( &m_computerResolver );
	addResolver( &m_ilsResolver );
	addResolver( &m_unrecognizedTypeResolver );
	addResolver( &m_stringResolver );

}	//	End of CCalltoResolver::CCalltoResolver.


//--------------------------------------------------------------------------//
//	CCalltoResolver::~CCalltoResolver.										//
//--------------------------------------------------------------------------//
CCalltoResolver::~CCalltoResolver()
{
}	//	End of CCalltoResolver::~CCalltoResolver.


//--------------------------------------------------------------------------//
//	CCalltoResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CCalltoResolver::resolve
(
	ICalltoContext * const		calltoContext,
	CCalltoProperties * const	calltoProperties,
	CCalltoCollection * const	resolvedCalltoCollection,
	const TCHAR *				url,
	const bool					strict
){
	HRESULT	result;

	if( (calltoContext == NULL) || (calltoProperties == NULL) || (resolvedCalltoCollection == NULL) )
	{
		result = E_POINTER;
	}
	else
	{
		TCHAR *	params			= StrStrI( url, TEXT( "phone:+" ) );
		
		params = StrChr( (params != NULL)? params + strlen_literal( TEXT( "phone:+" ) ): url, '+' );

		int		paramsLength	= (params == NULL)? 0: lstrlen( params );
		int		urlLength		= lstrlen( url ) - paramsLength + 1;
		int		prefixLength	= 0;

		if( !StrCmpNI_literal( url, TEXT( "callto:" ) ) )
		{
			prefixLength = strlen_literal( TEXT( "callto:" ) );
		}
		else if( StrCmpNI_literal( url, TEXT( "callto://" ) ) )
		{
			prefixLength	= strlen_literal( TEXT( "callto:" ) );
			url				+= strlen_literal( TEXT( "callto://" ) );
			urlLength		-= strlen_literal( TEXT( "callto://" ) ) - strlen_literal( TEXT( "callto:" ) );
		}

		TCHAR *	urlBuffer	= NULL;

		if( (urlBuffer = new TCHAR [ urlLength + prefixLength ]) == NULL )
		{
			result = E_OUTOFMEMORY;
		}
		else
		{
			if( paramsLength > 0 )
			{
				// Save params...
				calltoProperties->set_params( params );
			}

			// Save original callto...
			calltoProperties->set_callto( url, urlLength );

			result = S_FALSE;

			resolvedCalltoCollection->reset();

			if( urlLength > 1 )
			{
				bool	strictChecked	= !strict;

				for( int nn = 0; nn < m_registeredResolvers; nn++ )
				{
					if( prefixLength > 0 )
					{
						lstrcpy( urlBuffer, TEXT( "callto:" ) );	// Prepend default of callto: ...
						lstrcpyn( urlBuffer + strlen_literal( TEXT( "callto:" ) ), url, urlLength );
					}
					else
					{
						lstrcpyn( urlBuffer, url, urlLength );
					}

					if( !strictChecked )
					{
						if( !strictCheck( urlBuffer ) )
						{
							result = E_INVALIDARG;
							break;
						}

						strictChecked = true;
					}

					HRESULT	resolveResult	= m_resolvers[ nn ]->resolve( resolvedCalltoCollection, urlBuffer );

					if( FAILED( resolveResult ) && (!FAILED( result )) )
					{
						result = resolveResult;
					}
				}

				if( !FAILED( result ) )
				{
					result = (resolvedCalltoCollection->get_count() > 0)? S_OK: S_FALSE;
				}
			}
		}

		delete [] urlBuffer;
	}

	return( result );

}	//	End of class CCalltoResolver::resolve.


//--------------------------------------------------------------------------//
//	CCalltoResolver::addResolver.											//
//--------------------------------------------------------------------------//
bool
CCalltoResolver::addResolver
(
	IResolver * const	resolver
){
//assert( resolver != NULL, TEXT( "attempted to add NULL resolver\r\n" ) );
//assert( m_registeredResolvers < elementsof( m_resolvers ), TEXT( "attempted to add to many resolvers: %d\r\n" ), m_registeredResolvers );

	if( (resolver != NULL) && (m_registeredResolvers < elementsof( m_resolvers )) )
	{
		m_resolvers[ m_registeredResolvers++ ] = resolver;
	}

	return( (resolver != NULL) && (m_registeredResolvers <= elementsof( m_resolvers )) );

}	//	End of CCalltoResolver::addResolver.


//--------------------------------------------------------------------------//
//	CCalltoResolver::strictCheck.											//
//--------------------------------------------------------------------------//
const bool
CCalltoResolver::strictCheck
(
	const TCHAR * const	url
) const
{
//assert( url != NULL, TEXT( "attempted to strictCheck NULL url\r\n" ) );

	return( (url != NULL)	&&
			(StrCmpNI_literal( url, TEXT( "callto:phone:" ) )	||
			StrCmpNI_literal( url, TEXT( "callto:email:" ) )	||
			StrCmpNI_literal( url, TEXT( "callto:ip:" ) )		||
			StrCmpNI_literal( url, TEXT( "callto:computer:" ) )	||
			StrCmpNI_literal( url, TEXT( "callto:ils:" ) )		||
			StrCmpNI_literal( url, TEXT( "callto:string:" ) )	||
			(StrStrI( url, TEXT( "|phone:" ) ) !=  NULL)		||
			(StrStrI( url, TEXT( "|email:" ) ) !=  NULL)		||
			(StrStrI( url, TEXT( "|ip:" ) ) !=  NULL)			||
			(StrStrI( url, TEXT( "|computer:" ) ) !=  NULL)		||
			(StrStrI( url, TEXT( "|ils:" ) ) !=  NULL)			||
			(StrStrI( url, TEXT( "|string:" ) ) !=  NULL)) );

}	//	End of CCalltoResolver::strictCheck.


//--------------------------------------------------------------------------//
//	CPhoneResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CPhoneResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	phoneType;
		TCHAR *	phoneNumber	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:phone:" ) ) )				//	Check for phone type without gateway...
		{
			phoneType	= url;
			phoneNumber	= url + strlen_literal( TEXT( "callto:phone:" ) );
		}
		else if( (phoneType = StrStrI( url, TEXT( "|phone:" ) )) != NULL )	//	Check for phone type with gateway...
		{
			phoneNumber = phoneType + strlen_literal( TEXT( "|phone:" ) );
		}

		if( phoneNumber != NULL )
		{
			//	phone: type was specified for this callto:...
			if( CCalltoContext::toE164( phoneNumber, NULL, 0 ) )
			{
				ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

				if( resolvedCallto != NULL )
				{
					CCalltoContext::toE164( phoneNumber, phoneNumber, lstrlen( phoneNumber ) );
					resolvedCallto->set_qualifiedName( url );
					resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

					result = S_OK;
				}
				else
				{
					result = E_OUTOFMEMORY;
				}
			}
		}
		else
		{
			phoneNumber = url + strlen_literal( TEXT( "callto:" ) );

			if( CCalltoContext::isPhoneNumber( phoneNumber ) )
			{
				//	It smells like E164...
				result = E_OUTOFMEMORY;

				CCalltoContext::toE164( phoneNumber, phoneNumber, lstrlen( phoneNumber ) );

				TCHAR *	buffer	= new TCHAR [ lstrlen( phoneNumber ) + strlen_literal( TEXT( "callto:phone:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:phone:%s" ), phoneNumber );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CPhoneResolver::resolve.


//--------------------------------------------------------------------------//
//	CEMailResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CEMailResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	emailType;
		TCHAR *	emailAddress	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:email:" ) ) )				//	Check for email type without gateway...
		{
			emailType		= url;
			emailAddress	= url + strlen_literal( TEXT( "callto:email:" ) );
		}
		else if( (emailType = StrStrI( url, TEXT( "|email:" ) )) != NULL )	//	Check for email type with gateway...
		{
			emailAddress = emailType + strlen_literal( TEXT( "|email:" ) );
		}

		if( emailAddress != NULL )
		{
			//	email: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );
				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			emailAddress = url + strlen_literal( TEXT( "callto:" ) );

			if( (StrChr( emailAddress, ':' ) == NULL)	&&		//	isn't some other type:...
				(StrChr( emailAddress, ' ' ) == NULL)	&&		//	doesn't contain spaces...
				(StrChr( emailAddress, '|' ) == NULL)	&&		//	doesn't contain a bar (gateway)...
				(StrChr( emailAddress, '/' ) == NULL)	&&		//	isn't an old style ilsserver/email...
				((StrChr( emailAddress, '.' ) == NULL) ||		//	doesn't have a dot unless it also
				(StrChr( emailAddress, '@' ) != NULL)) )		//	has a @ so it can't be an ip address...
			{
				//	It smells like an email address...
				result = E_OUTOFMEMORY;

				TCHAR *	buffer	= new TCHAR [ lstrlen( emailAddress ) + strlen_literal( TEXT( "callto:email:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:email:%s" ), emailAddress );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CEMailResolver::resolve.


//--------------------------------------------------------------------------//
//	CIPResolver::resolve.													//
//--------------------------------------------------------------------------//
HRESULT
CIPResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	ipType;
		TCHAR *	ipAddress	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:ip:" ) ) )				//	Check for ip type without gateway...
		{
			ipType		= url;
			ipAddress	= url + strlen_literal( TEXT( "callto:ip:" ) );
		}
		else if( (ipType = StrStrI( url, TEXT( "|ip:" ) )) != NULL )	//	Check for ip type with gateway...
		{
			ipAddress = ipType + strlen_literal( TEXT( "|ip:" ) );
		}

		if( (ipAddress != NULL) && CCalltoContext::isIPAddress( ipAddress ) )
		{
			//	ip: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			ipAddress = url + strlen_literal( TEXT( "callto:" ) );

			if( CCalltoContext::isIPAddress( ipAddress ) )
			{
				//	It smells like an ip address...
				ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

				if( resolvedCallto != NULL )
				{
					TCHAR	buffer[ MAX_PATH ];

					wsprintf( buffer, TEXT( "callto:ip:%s" ), ipAddress );
					resolvedCallto->set_qualifiedName( buffer );
					resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

					result = S_OK;
				}
				else
				{
					result = E_OUTOFMEMORY;
				}
			}
		}
	}

	return( result );

}	//	End of CIPResolver::resolve.


//--------------------------------------------------------------------------//
//	CComputerResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CComputerResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	computerType;
		TCHAR *	hostName	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:computer:" ) ) )					//	Check for computer type without gateway...
		{
			computerType	= url;
			hostName		= url + strlen_literal( TEXT( "callto:computer:" ) );
		}
		else if( (computerType = StrStrI( url, TEXT( "|computer:" ) )) != NULL )	//	Check for computer type with gateway...
		{
			hostName = computerType + strlen_literal( TEXT( "|computer:" ) );
		}

		if( hostName != NULL )
		{
			//	host: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			hostName = url + strlen_literal( TEXT( "callto:" ) );

			TCHAR *	slash	= hostName;

			//	Remove any trailing /....
			while( (slash = StrChr( slash, '/' )) != NULL )
			{
				if( slash[ 1 ] == '\0' )
				{
					slash[ 0 ] = '\0';
					break;
				}

				slash++;
			}

			if( (StrChr( hostName, ':' ) == NULL)	&&		//	isn't some other type:...
				(StrChr( hostName, ' ' ) == NULL)	&&		//	doesn't contain spaces...
				(StrChr( hostName, '|' ) == NULL)	&&		//	doesn't contain a bar (gateway)...
				(StrChr( hostName, '/' ) == NULL)	&&		//	doesn't contain a slash (ils)...
				(StrChr( hostName, '@' ) == NULL) )			//	doesn't contain an @...
			{
				//	It smells like a dns host name...
				result = E_OUTOFMEMORY;

				TCHAR *	buffer	= new TCHAR [ lstrlen( hostName ) + strlen_literal( TEXT( "callto:computer:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:computer:%s" ), hostName );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence(  StrCmpNI_literal( hostName, TEXT( "\\\\" ) )? S_CONFIDENCE_HIGH: S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CComputerResolver::resolve.


//--------------------------------------------------------------------------//
//	CILSResolver::resolve.													//
//--------------------------------------------------------------------------//
HRESULT
CILSResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		const TCHAR *	ilsType;
		const TCHAR *	emailAddress	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:ils:" ) ) )			//	Check for ils type without gateway...
		{
			ilsType			= url;
			emailAddress	= url + strlen_literal( TEXT( "callto:ils:" ) );
		}
		else if( (ilsType = StrStrI( url, TEXT( "|ils:" ) )) != NULL )	//	Check for ils type with gateway...
		{
			emailAddress = ilsType + strlen_literal( TEXT( "|ils:" ) );
		}

		if( emailAddress != NULL )
		{
			//	ils: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			emailAddress = url + strlen_literal( TEXT( "callto:" ) );

			if( (StrChr( emailAddress, ' ' ) == NULL)	&&		//	doesn't contain spaces...
				(StrChr( emailAddress, '|' ) == NULL)	&&		//	doesn't contain a bar (gateway)...
				(StrChr( emailAddress, '/' ) != NULL) )			//	has a /...
			{
				//	It smells like an ilsserver/emailaddress...
				result = E_OUTOFMEMORY;

				TCHAR *	buffer	= new TCHAR [ lstrlen( emailAddress ) + strlen_literal( TEXT( "callto:ils:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						wsprintf( buffer, TEXT( "callto:ils:%s" ), emailAddress );
						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_MEDIUM );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CILSResolver::resolve.


//--------------------------------------------------------------------------//
//	CUnrecognizedTypeResolver::resolve.										//
//--------------------------------------------------------------------------//
HRESULT
CUnrecognizedTypeResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	type;
		TCHAR *	unrecognized	= url + strlen_literal( TEXT( "callto:" ) );
		TCHAR *	gateway			= NULL;
		TCHAR *	value			= NULL;

		result = S_FALSE;

		if( ((type = StrChr( unrecognized, ':' )) != NULL)	&&																//	Check for a type, but not a known one...
			(!StrCmpNI_literal( url, TEXT( "callto:phone:" ) )) && (StrStrI( url, TEXT( "|phone:" ) ) == NULL)			&&	//	isn't a phone: type...
			(!StrCmpNI_literal( url, TEXT( "callto:email:" ) )) && (StrStrI( url, TEXT( "|email:" ) ) == NULL)			&&	//	isn't an email: type...
			(!StrCmpNI_literal( url, TEXT( "callto:computer:" ) )) && (StrStrI( url, TEXT( "|computer:" ) ) == NULL)	&&	//	isn't a computer: type...
			(!StrCmpNI_literal( url, TEXT( "callto:ils:" ) )) && (StrStrI( url, TEXT( "|ils:" ) ) == NULL)				&&	//	isn't an ils: type...
			(!StrCmpNI_literal( url, TEXT( "callto:ip:" ) )) && (StrStrI( url, TEXT( "|ip:" ) ) == NULL)				&&	//	isn't an ip: type...
			(!StrCmpNI_literal( url, TEXT( "callto:string:" ) )) && (StrStrI( url, TEXT( "|string:" ) ) == NULL) )			//	isn't an string: type...
		{
			*type++	= NULL;
			value	= type;

			if( (gateway = StrChr( url, '|' )) != NULL )	//	Check for a gateway...
			{
				*gateway++	= NULL;
				type		= gateway;
				gateway		= unrecognized;
			}
		}

		if( value != NULL )
		{
			//	Some unrecognized type was specified...
			result = E_OUTOFMEMORY;

			int	length	= strlen_literal( TEXT( "callto:|%s" ) ) + lstrlen( value );

			if( gateway ==  NULL )
			{
				length += lstrlen( unrecognized );
			}
			else
			{
				length += lstrlen( gateway ) + lstrlen( type );
			}

			TCHAR *	buffer	= new TCHAR [ length ];

			if( buffer != NULL )
			{
				ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

				if( resolvedCallto != NULL )
				{
					if( gateway == NULL )
					{
						wsprintf( buffer, TEXT( "callto:%s:%s" ), unrecognized, value );
					}
					else
					{
						wsprintf( buffer, TEXT( "callto:%s|%s:%s" ), gateway, type, value );
					}

					resolvedCallto->set_qualifiedName( buffer );
					resolvedCallto->set_confidence( S_CONFIDENCE_LOW );

					result = S_OK;
				}

				delete [] buffer;
			}
		}
	}

	return( result );

}	//	End of CUnrecognizedTypeResolver::resolve.


//--------------------------------------------------------------------------//
//	CStringResolver::resolve.												//
//--------------------------------------------------------------------------//
HRESULT
CStringResolver::resolve
(
	IMutableCalltoCollection * const	calltoCollection,
	TCHAR * const						url
){
	HRESULT	result	= E_INVALIDARG;

	if( (calltoCollection != NULL) && (url != NULL) )
	{
		TCHAR *	stringType;
		TCHAR *	string	= NULL;

		result = S_FALSE;

		if( StrCmpNI_literal( url, TEXT( "callto:string:" ) ) )					//	Check for string type without gateway...
		{
			stringType	= url;
			string		= url + strlen_literal( TEXT( "callto:string:" ) );
		}
		else if( (stringType = StrStrI( url, TEXT( "|string:" ) )) != NULL )	//	Check for string type with gateway...
		{
			string = stringType + strlen_literal( TEXT( "|string:" ) );
		}

		if( string != NULL )
		{
			//	string: type was specified for this callto:...
			ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

			if( resolvedCallto != NULL )
			{
				resolvedCallto->set_qualifiedName( url );
				resolvedCallto->set_confidence( S_CONFIDENCE_HIGH );

				result = S_OK;
			}
			else
			{
				result = E_OUTOFMEMORY;
			}
		}
		else
		{
			string = url + strlen_literal( TEXT( "callto:" ) );

			if( StrChr( string, ':' ) == NULL )
			{
				//	It doesn't have a type so set it to string...
				result = E_OUTOFMEMORY;
				TCHAR *	slash;
				TCHAR *	buffer	= new TCHAR [ lstrlen( string ) + strlen_literal( TEXT( "callto:%s|string:%s" ) ) ];

				if( buffer != NULL )
				{
					ICallto * const	resolvedCallto	= calltoCollection->get_nextUnused();

					if( resolvedCallto != NULL )
					{
						if( (slash = StrChr( string, '|' )) == NULL )		//	Check for a gateway...
						{
							wsprintf( buffer, TEXT( "callto:string:%s" ), string );
						}
						else
						{
							*slash++ = NULL;
							wsprintf( buffer, TEXT( "callto:%s|string:%s" ), string, slash );
						}

						resolvedCallto->set_qualifiedName( buffer );
						resolvedCallto->set_confidence( S_CONFIDENCE_LOW );

						result = S_OK;
					}

					delete [] buffer;
				}
			}
		}
	}

	return( result );

}	//	End of CStringResolver::resolve.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltodisambiguator.h ===
#if !defined( calltoDisambiguator_h )
#define	calltoDisambiguator_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"calltoContext.h"


//--------------------------------------------------------------------------//
//	interface IDisambiguator.												//
//--------------------------------------------------------------------------//
class IDisambiguator
{
	protected:	//	protected constructors	--------------------------------//

		IDisambiguator(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IDisambiguator(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		) = 0;

};	//	End of interface IDisambiguator.


//--------------------------------------------------------------------------//
//	class CGatekeeperDisambiguator.											//
//--------------------------------------------------------------------------//
class CGatekeeperDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CGatekeeperDisambiguator.


//--------------------------------------------------------------------------//
//	class CGatewayDisambiguator.											//
//--------------------------------------------------------------------------//
class CGatewayDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CGatewayDisambiguator.


//--------------------------------------------------------------------------//
//	class CComputerDisambiguator.											//
//--------------------------------------------------------------------------//
class CComputerDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CComputerDisambiguator.


//--------------------------------------------------------------------------//
//	class CILSDisambiguator.												//
//--------------------------------------------------------------------------//
class CILSDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CILSDisambiguator.


//--------------------------------------------------------------------------//
//	class CUnrecognizedDisambiguator.										//
//--------------------------------------------------------------------------//
class CUnrecognizedDisambiguator:	public	IDisambiguator
{
	public:		//	public methods	(IDisambiguator)	--------------------//

		virtual
		HRESULT
		disambiguate
		(
			const ICalltoContext * const		calltoContext,
			IMutableCalltoCollection * const	calltoCollection,
			const ICallto * const				resolvedCallto
		);

};	//	End of CUnrecognizedDisambiguator.


//--------------------------------------------------------------------------//
//	class CCalltoDisambiguator.												//
//--------------------------------------------------------------------------//
class CCalltoDisambiguator
{
	public:		//	public constructors	------------------------------------//

		CCalltoDisambiguator(void);


	public:		//	public destructor	------------------------------------//

		~CCalltoDisambiguator();


	public:		//	public methods	----------------------------------------//

		HRESULT
		disambiguate
		(
			const ICalltoContext * const	calltoContext,
			ICalltoCollection * const		resolvedCalltoCollection,
			CCalltoCollection * const		disambiguatedCalltoCollection
		);


	private:	//	private methods	----------------------------------------//

		bool
		addDisambiguator
		(
			IDisambiguator * const	disambiguator
		);


	private:	//	private members	----------------------------------------//

		CGatekeeperDisambiguator	m_gatekeeperDisambiguator;
		CGatewayDisambiguator		m_gatewayDisambiguator;
		CILSDisambiguator			m_ilsDisambiguator;
		CComputerDisambiguator		m_computerDisambiguator;
		CUnrecognizedDisambiguator	m_unrecognizedDisambiguator;

		IDisambiguator *			m_disambiguators[ 5 ];
		int							m_registeredDisambiguators;

};	//	End of class CCalltoDisambiguator.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoDisambiguator_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calv.cpp ===
// File: calv.cpp

#include "precomp.h"
#include "resource.h"

#include "calv.h"
#include "upropdlg.h"
#include "speedial.h"
#include "dirutil.h"
#include "confroom.h"

///////////////////////////////
// Globals for FEnabledNmAddr
BOOL g_fGkEnabled = FALSE;
BOOL g_fGatewayEnabled = FALSE;
BOOL g_bGkPhoneNumberAddressing = FALSE;


CALV::CALV(int ids, int iIcon, const int * pIdMenu /*=NULL*/, bool fOwnerData /*=false*/ ) :
		m_idsName(ids),
		m_hwnd(NULL),
		m_iIcon(iIcon),
		m_pIdMenu(pIdMenu),
		m_fAvailable(FALSE),
        m_fOwnerDataList( fOwnerData )
{
}

CALV::~CALV()
{
}

VOID CALV::ClearItems(void)
{
	if (NULL != m_hwnd)
	{
		ListView_DeleteAllItems(m_hwnd);
	}
}

VOID CALV::DeleteItem(int iItem)
{
	if (ListView_DeleteItem(GetHwnd(), iItem))
	{
		// Auto-select the next item
		ListView_SetItemState(GetHwnd(), iItem,
			LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
	}
}


int CALV::GetSelection(void)
{
	return ListView_GetNextItem(m_hwnd, -1, LVNI_ALL | LVNI_SELECTED);
}

VOID CALV::SetHeader(HWND hwnd, int ids)
{
	m_hwnd = hwnd;
	DlgCallSetHeader(hwnd, ids);
}


// Return the name (from the first column)
BOOL CALV::GetSzName(LPTSTR psz, int cchMax)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return FALSE;

	return GetSzName(psz, cchMax, iItem);
}
BOOL CALV::GetSzName(LPTSTR psz, int cchMax, int iItem)
{
	return GetSzData(psz, cchMax, iItem, IDI_DLGCALL_NAME);
}

// Return the "callTo" address (from the second column)
BOOL CALV::GetSzAddress(LPTSTR psz, int cchMax)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return FALSE;

	return GetSzAddress(psz, cchMax, iItem);
}
BOOL CALV::GetSzAddress(LPTSTR psz, int cchMax, int iItem)
{
	return GetSzData(psz, cchMax, iItem, IDI_DLGCALL_ADDRESS);
}


BOOL CALV::GetSzData(LPTSTR psz, int cchMax, int iItem, int iCol)
{
	LV_ITEM lvi;
	ClearStruct(&lvi);
	lvi.iItem = iItem;
	lvi.iSubItem = iCol;
	lvi.mask = LVIF_TEXT;
	lvi.pszText = psz;
	lvi.cchTextMax = cchMax;

	return ListView_GetItem(m_hwnd, &lvi);
}


LPARAM CALV::LParamFromItem(int iItem)
{
	LV_ITEM lvi;
	ClearStruct(&lvi);
	lvi.iItem = iItem;
	lvi.mask = LVIF_PARAM;
	return ListView_GetItem(GetHwnd(), &lvi) ? lvi.lParam : 0;
}


/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo

    General interface to get the rich address info.
-------------------------------------------------------------------------*/
RAI * CALV::GetAddrInfo(void)
{
	return GetAddrInfo(NM_ADDR_ULS);
}

/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo

    Utility routine, usually called by GetAddrInfo()
-------------------------------------------------------------------------*/
RAI * CALV::GetAddrInfo(NM_ADDR_TYPE addrType)
{
	TCHAR szName[CCHMAXSZ_NAME];
	if (!GetSzName(szName, CCHMAX(szName)))
		return NULL;

	TCHAR szAddress[CCHMAXSZ_ADDRESS];
	if (!GetSzAddress(szAddress, CCHMAX(szAddress)))
		return NULL;

	return CreateRai(szName, addrType, szAddress);
}



/*  S E T  B U S Y  C U R S O R  */
/*-------------------------------------------------------------------------
    %%Function: SetBusyCursor
    
-------------------------------------------------------------------------*/
VOID CALV::SetBusyCursor(BOOL fBusy)
{
	extern int g_cBusy; // in dlgcall.cpp
	g_cBusy += fBusy ? 1 : -1;
	ASSERT(g_cBusy >= 0);

	// Wiggle the mouse - force user to send a WM_SETCURSOR
	POINT pt;
	if (::GetCursorPos(&pt))
	{
		::SetCursorPos(pt.x, pt.y);
	}
}


/*  D O  M E N U  */
/*-------------------------------------------------------------------------
    %%Function: DoMenu
    
-------------------------------------------------------------------------*/
VOID CALV::DoMenu(POINT pt, const int * pIdMenu)
{
	HMENU hMenu = ::LoadMenu(::GetInstanceHandle(), MAKEINTRESOURCE(IDM_DLGCALL));
	if (NULL == hMenu)
		return;

	HMENU hMenuTrack = ::GetSubMenu(hMenu, 0);
	ASSERT(NULL != hMenu);

	{
		// Bold the "Call" menuitem:
		MENUITEMINFO iInfo;
		iInfo.cbSize = sizeof(iInfo);
		iInfo.fMask = MIIM_STATE;
		if(::GetMenuItemInfo(hMenuTrack, IDM_DLGCALL_CALL, FALSE, &iInfo))
		{
			iInfo.fState |= MFS_DEFAULT;
			::SetMenuItemInfo(hMenuTrack, IDM_DLGCALL_CALL, FALSE, &iInfo);
		}
	}

	// Is anything selected?
	int iSelItem = GetSelection();
	UINT uFlags = (-1 == iSelItem) ? MF_GRAYED : MF_ENABLED;

	::EnableMenuItem(hMenuTrack, IDM_DLGCALL_CALL,
        ((uFlags == MF_GRAYED) || !GetConfRoom()->IsNewCallAllowed())  ?
        MF_GRAYED : MF_ENABLED);
	::EnableMenuItem(hMenuTrack, IDM_DLGCALL_PROPERTIES, uFlags);

	if (NULL != pIdMenu)
	{
		// Additional menu items
		while (0 != *pIdMenu)
		{
			int id = *pIdMenu++;
			if (-1 == id)
			{
				InsertMenu(hMenuTrack, (DWORD) -1, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
			}
			else
			{
				TCHAR sz[CCHMAXSZ];
				if (FLoadString(id, sz, CCHMAX(sz)))
				{
					UINT uf = MF_BYPOSITION | MF_STRING | uFlags;
					if (id >= IDM_DLGCALL_ALWAYS_ENABLED)
					{
						uf = (uf & ~MF_GRAYED) | MF_ENABLED;
					}
					InsertMenu(hMenuTrack, (DWORD) -1, uf, id, sz);
				}
			}
		}
	}

	// Check to see if we have "special" coordinates that signify
	// that we entered here as a result of a keyboard click
	// instead of a mouse click - and if so, get some default coords
	if ((0xFFFF == pt.x) && (0xFFFF == pt.y))
	{
		RECT rc;
		if ((-1 == iSelItem) ||
			(FALSE == ListView_GetItemRect(m_hwnd, iSelItem, &rc, LVIR_ICON)))
		{
			::GetWindowRect(m_hwnd, &rc);
			pt.x = rc.left;
			pt.y = rc.top;
		}
		else
		{
			// Convert from client coords to screen coords
			::MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);
			pt.x = rc.left + (RectWidth(rc) / 2);
			pt.y = rc.top + (RectHeight(rc) / 2);
		}
	}

	// Draw and track the "floating" popup 
	::TrackPopupMenu(hMenuTrack, TPM_LEFTALIGN | TPM_RIGHTBUTTON,
	                 pt.x, pt.y, 0, ::GetParent(m_hwnd), NULL);

	::DestroyMenu(hMenu);
}

VOID CALV::OnRClick(POINT pt)
{
	DoMenu(pt, m_pIdMenu);
}


VOID CALV::OnCommand(WPARAM wParam, LPARAM lParam)
{
	WORD wCmd = LOWORD(wParam);
	
	switch (wCmd)
	{
	case IDM_DLGCALL_PROPERTIES:
		CmdProperties();
		break;
	case IDM_DLGCALL_SPEEDDIAL:
		CmdSpeedDial();
		break;
	default:
		break;
	}
}


/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties
    
-------------------------------------------------------------------------*/
VOID CALV::CmdProperties(void)
{
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szAddr[CCHMAXSZ_ADDRESS];
	if (!GetSzName(szName, CCHMAX(szName)) ||
		!GetSzAddress(szAddr, CCHMAX(szAddr)))
	{
		return;
	}

	UPROPDLGENTRY rgProp[1] = {
		{IDS_UPROP_ADDRESS, szAddr},
	};

    CUserPropertiesDlg dlgUserProp(m_hwnd, IDI_LARGE);
    dlgUserProp.DoModal(rgProp, ARRAY_ELEMENTS(rgProp), szName, NULL);
}


/*  C M D  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: CmdSpeedDial
    
-------------------------------------------------------------------------*/
VOID CALV::CmdSpeedDial(void)
{
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szAddr[CCHMAXSZ_ADDRESS];
	if (!GetSzName(szName, CCHMAX(szName)) ||
		!GetSzAddress(szAddr, CCHMAX(szAddr)))
	{
		return;
	}

	FCreateSpeedDial(szName, szAddr);
}




/*  C M D  R E F R E S H  */
/*-------------------------------------------------------------------------
    %%Function: CmdRefresh
    
-------------------------------------------------------------------------*/
VOID CALV::CmdRefresh(void)
{
	ClearItems();
	ShowItems(m_hwnd);
}


///////////////////////////////////////////////////////////////////////
// RAI routines


/*  C R E A T E  R A I  */
/*-------------------------------------------------------------------------
    %%Function: CreateRai
    
-------------------------------------------------------------------------*/
RAI * CreateRai(LPCTSTR pszName, NM_ADDR_TYPE addrType, LPCTSTR pszAddr)
{	
	RAI * pRai = new RAI;
	LPTSTR psz = PszAlloc(pszAddr);
	if ((NULL == pRai) || (NULL == psz))
	{
		delete pRai;
		delete psz;
		return NULL;
	}

	lstrcpyn(pRai->szName, pszName, CCHMAX(pRai->szName));
	pRai->cItems = 1;
	pRai->rgDwStr[0].psz = psz;
	pRai->rgDwStr[0].dw = addrType;
	return pRai;
}
	

/*  C L E A R  R A I  */
/*-------------------------------------------------------------------------
    %%Function: ClearRai
    
-------------------------------------------------------------------------*/
VOID ClearRai(RAI ** ppRai)
{
	if (NULL == *ppRai)
		return;

	for (int i = 0; i < (*ppRai)->cItems; i++)
	{
		delete (*ppRai)->rgDwStr[i].psz;
	}
	delete *ppRai;
	*ppRai = NULL;
}

/*  D U P  R A I  */
/*-------------------------------------------------------------------------
    %%Function: DupRai
    
-------------------------------------------------------------------------*/
RAI * DupRai(RAI * pRai)
{
	if (NULL == pRai)
		return NULL;

	RAI * pRaiRet = (RAI *) new BYTE[sizeof(RAI) + (pRai->cItems-1)*sizeof(DWSTR)];
	if (NULL != pRaiRet)
	{
		lstrcpy(pRaiRet->szName, pRai->szName);
		pRaiRet->cItems = pRai->cItems;

		for (int i = 0; i < pRai->cItems; i++)
		{
			pRaiRet->rgDwStr[i].dw = pRai->rgDwStr[i].dw;
			pRaiRet->rgDwStr[i].psz = PszAlloc(pRai->rgDwStr[i].psz);
		}
	}
	
	return pRaiRet;
}


/*  F  E N A B L E D  N M  A D D R  */
/*-------------------------------------------------------------------------
    %%Function: FEnabledNmAddr
-------------------------------------------------------------------------*/
BOOL FEnabledNmAddr(DWORD dwAddrType)
{
	switch (dwAddrType)
		{
	default:
	case NM_ADDR_ULS:
			// We only care about ULS addresses if 
			// we are not in gatekeeper mode...
		return !g_fGkEnabled;

	case NM_ADDR_UNKNOWN:
	case NM_ADDR_IP:
			// We always care aobut these addresses
		return TRUE;

	case NM_ADDR_H323_GATEWAY:
	{
		return !g_fGkEnabled && g_fGatewayEnabled;
	}

	case NM_ADDR_ALIAS_ID:
		return g_fGkEnabled && !g_bGkPhoneNumberAddressing;

	case NM_ADDR_ALIAS_E164:
		return g_fGkEnabled && g_bGkPhoneNumberAddressing;

	case NM_ADDR_PSTN: // old, never enabled
		return FALSE;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calltoresolver.h ===
#if !defined( calltoResolver_h )
#define	calltoResolver_h
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Application Header Files.												//
//--------------------------------------------------------------------------//
#include	"callto.h"
#include	"calltoContext.h"


//--------------------------------------------------------------------------//
//	interface IResolver.													//
//--------------------------------------------------------------------------//
class IResolver
{
	protected:	//	protected constructors	--------------------------------//

		IResolver(){};


	public:		//	public destructor	------------------------------------//

		virtual
		~IResolver(){};


	public:		//	public methods	----------------------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		) = 0;

};	//	End of interface IResolver.


//--------------------------------------------------------------------------//
//	class CPhoneResolver.													//
//--------------------------------------------------------------------------//
class CPhoneResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CPhoneResolver.


//--------------------------------------------------------------------------//
//	class CEMailResolver.													//
//--------------------------------------------------------------------------//
class CEMailResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CEMailResolver.


//--------------------------------------------------------------------------//
//	class CIPResolver.														//
//--------------------------------------------------------------------------//
class CIPResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CIPResolver.


//--------------------------------------------------------------------------//
//	class CComputerResolver.												//
//--------------------------------------------------------------------------//
class CComputerResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CComputerResolver.


//--------------------------------------------------------------------------//
//	class CILSResolver.														//
//--------------------------------------------------------------------------//
class CILSResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CILSResolver.


//--------------------------------------------------------------------------//
//	class CUnrecognizedTypeResolver.										//
//--------------------------------------------------------------------------//
class CUnrecognizedTypeResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CUnrecognizedTypeResolver.


//--------------------------------------------------------------------------//
//	class CStringResolver.													//
//--------------------------------------------------------------------------//
class CStringResolver:	public	IResolver
{
	public:		//	public methods	(IResolver)	----------------------------//

		virtual
		HRESULT
		resolve
		(
			IMutableCalltoCollection * const	calltoCollection,
			TCHAR * const						url
		);

};	//	End of CStringResolver.


//--------------------------------------------------------------------------//
//	class CCalltoResolver.													//
//--------------------------------------------------------------------------//
class CCalltoResolver
{
	public:		//	public constructors	------------------------------------//

		CCalltoResolver();


	public:		//	public destructor	------------------------------------//

		~CCalltoResolver();


	public:		//	public methods	----------------------------------------//

		HRESULT
		resolve
		(
			ICalltoContext * const		calltoContext,
			CCalltoProperties * const	calltoProperties,
			CCalltoCollection * const	resolvedCalltoCollection,
			const TCHAR *				url,
			const bool					strict
		);


	private:	//	private methods	----------------------------------------//

		bool
		addResolver
		(
			IResolver * const	resolver
		);

		const bool
		strictCheck
		(
			const TCHAR * const	url
		) const;


	private:	//	private members	----------------------------------------//

		CPhoneResolver				m_phoneResolver;
		CEMailResolver				m_emailResolver;
		CIPResolver					m_ipResolver;
		CComputerResolver			m_computerResolver;
		CILSResolver				m_ilsResolver;
		CUnrecognizedTypeResolver	m_unrecognizedTypeResolver;
		CStringResolver				m_stringResolver;

		IResolver *					m_resolvers[ 7 ];
		int							m_registeredResolvers;

};	//	End of class CCalltoResolver.

//--------------------------------------------------------------------------//
#endif	// !defined( calltoResolver_h )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\chcondlg.h ===
/****************************************************************************
*
*    FILE:     ChConDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 6-26-96
*
****************************************************************************/

#ifndef _CHCONDLG_H_
#define _CHCONDLG_H_

#include <cstring.hpp>

class CChooseConfDlg
{
protected:
	HWND		m_hwndParent;
	HWND		m_hwnd;

	CSTRING		m_strConfName;
	PWSTR*		m_ppwszConferences;

	BOOL		ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL		GetConferenceName(int iItem, LPTSTR pszName, int cchName);
	static void	RefreshOk(HWND hwnd);



	// Handlers:
	BOOL		OnOk(LPTSTR pszName);

public:
	// Properties:

	LPCTSTR		GetName()		{ return (LPCTSTR) m_strConfName; };
	
	// Methods:
				CChooseConfDlg(HWND hwndParent, PWSTR* ppwszConferences);
	//			~CChooseConfDlg();
	INT_PTR		DoModal();

	static INT_PTR CALLBACK ChooseConfDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam);
};

#endif // _CHCONDLG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\chcondlg.cpp ===
#include "precomp.h"

/****************************************************************************
*
*    FILE:     ChConDlg.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 6-26-96
*
*    CONTENTS: CChooseConfDlg object
*
****************************************************************************/

#include <ConfWnd.h>
#include "resource.h"
#include "ChConDlg.h"
#include "help_ids.h"


// Dialog ID to Help ID mapping
static const DWORD rgHelpIdsChooseConf[] = {
IDC_STATIC_CONFNAME,    IDH_MCU_CONF_MAIN,
IDC_CONFNAME_EDIT,      IDH_MCU_CONF_NAME,
IDC_CONFNAME_LISTVIEW,  IDH_MCU_CONF_LIST,
0, 0 // terminator
};

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   CChooseConfDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CChooseConfDlg::CChooseConfDlg(	HWND hwndParent,
								PWSTR* ppwszConferences):
	m_hwndParent		(hwndParent),
	m_ppwszConferences	(ppwszConferences),
	m_hwnd				(NULL)
{
	DebugEntry(CChooseConfDlg::CChooseConfDlg);

	DebugExitVOID(CChooseConfDlg::CChooseConfDlg);
}

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CChooseConfDlg::DoModal()
{
	DebugEntry(CChooseConfDlg::DoModal);

	INT_PTR nRet = DialogBoxParam(	::GetInstanceHandle(),
								MAKEINTRESOURCE(IDD_CHOOSECONF),
								m_hwndParent,
								CChooseConfDlg::ChooseConfDlgProc,
								(LPARAM) this);

	DebugExitINT_PTR(CChooseConfDlg::DoModal, nRet);

	return nRet;
}

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   ChooseConfDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CChooseConfDlg::ChooseConfDlgProc(HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam)
{
	USES_CONVERSION;
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				((CChooseConfDlg*) lParam)->m_hwnd = hDlg;
				::SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				// Create image list and associate it with the list view:
				HWND hwndLV = ::GetDlgItem(hDlg, IDC_CONFNAME_LISTVIEW);
				if (NULL != hwndLV)
				{
					BOOL fLoadFail = FALSE;
					HIMAGELIST hIML;
					hIML = ImageList_Create( 16, 16, ILC_MASK, 1, 0 );
	 				if (NULL == hIML)
					{
						fLoadFail = TRUE;
					}
					else
					{
						HICON hIcon = ::LoadIcon(	::GetInstanceHandle(),
													MAKEINTRESOURCE(IDI_NET));
						if ((NULL == hIcon) ||
							(-1 == ImageList_AddIcon(hIML, hIcon)))
						{
							fLoadFail = TRUE;
							break;
						}
						::DestroyIcon(hIcon);
					}

					if (FALSE == fLoadFail)
					{
						// Associate the image list with the list view
						ListView_SetImageList(hwndLV, hIML, LVSIL_SMALL);
					}
					
					// TODO: init conf list and name
					PWSTR* ppwszConfNames = ((CChooseConfDlg*) lParam)->m_ppwszConferences;
					ASSERT(ppwszConfNames);
					int i = 0;
					int iItems = 0;
					while (NULL != ppwszConfNames[i])
					{
						// skip empty strings
						if ( 0 != *ppwszConfNames[i] )
						{
							LV_ITEM lvI;        // List view item structure

							// Fill in the LV_ITEM structure
							// The mask specifies the the .pszText, .iImage, .lParam and .state
							// members of the LV_ITEM structure are valid.
							lvI.mask = LVIF_TEXT | LVIF_IMAGE | /* LVIF_PARAM | */ LVIF_STATE;
							 // put focus on first item
							lvI.state = (0 == iItems) ?
											(LVIS_FOCUSED | LVIS_SELECTED) : 0;
							lvI.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
							lvI.iItem = iItems;
							lvI.iSubItem = 0;

							// The parent window is responsible for storing the text. The List view
							// window will send a LVN_GETDISPINFO when it needs the text to display/
							lvI.pszText = W2T(ppwszConfNames[i]);
							lvI.iImage = 0;
							// lvI.lParam = 0;

							if (-1 == ListView_InsertItem(hwndLV, &lvI))
							{
								ERROR_OUT(("Failed inserting item into list view"));
							}
							if (0 == iItems)
							{
								::SetDlgItemText(hDlg, IDC_CONFNAME_EDIT, lvI.pszText);
							}
							iItems++;
						}
						i++;
					}
				}
			}

			::SetFocus(::GetDlgItem(hDlg, IDC_CONFNAME_EDIT));
			::SendDlgItemMessage(hDlg, IDC_CONFNAME_EDIT, EM_SETSEL, 0, (LPARAM)-1);
			RefreshOk(hDlg);
			bMsgHandled = FALSE; // return FALSE because we set the focus
			break;
		}

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, rgHelpIdsChooseConf);
			break;

		case WM_HELP:
			DoHelp(lParam, rgHelpIdsChooseConf);
			break;

		default:
		{
			CChooseConfDlg* pccd = (CChooseConfDlg*) ::GetWindowLongPtr(	hDlg,
																		DWLP_USER);
			if (NULL != pccd)
			{
				bMsgHandled = pccd->ProcessMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CChooseConfDlg
*
*    MEMBER:   ProcessMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CChooseConfDlg::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
		
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					// BUGBUG: how long can a conf name be?
					TCHAR szName[MAX_PATH];
					if (0 != ::GetDlgItemText(	m_hwnd,
												IDC_CONFNAME_EDIT,
												szName,
												CCHMAX(szName)))
					{
						bRet = OnOk(szName);
					}
					break;
				}

				case IDCANCEL:
				{
					::EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

				case IDC_CONFNAME_EDIT:
				{
					if (EN_CHANGE == HIWORD(wParam))
					{
						RefreshOk(m_hwnd);
					}
					break;
				}
			}
			break;
		}

		case WM_NOTIFY:
		{
			if (IDC_CONFNAME_LISTVIEW == wParam)
			{
				NM_LISTVIEW* pnmv = (NM_LISTVIEW*) lParam;
				ASSERT(pnmv);
				if ((LVN_ITEMCHANGED == pnmv->hdr.code) &&
					(LVIS_SELECTED & pnmv->uNewState))
				{
					TCHAR szName[MAX_PATH];
					if (GetConferenceName(pnmv->iItem, szName, CCHMAX(szName)))
					{
						::SetDlgItemText(m_hwnd, IDC_CONFNAME_EDIT, szName);
					}
				}
				else if (NM_DBLCLK == pnmv->hdr.code)
				{
					int idx = ListView_GetNextItem(
								::GetDlgItem(m_hwnd, IDC_CONFNAME_LISTVIEW),
								-1,
								LVNI_FOCUSED | LVNI_SELECTED);
					if (idx != -1)
					{
						TCHAR szName[MAX_PATH];
						if (GetConferenceName(idx, szName, CCHMAX(szName)))
						{
							OnOk(szName);
						}
					}
				}
			}
			break;
		}
			
		default:
			break;
	}

	return bRet;
}

BOOL CChooseConfDlg::GetConferenceName(int iItem, LPTSTR pszName, int cchName)
{
	LV_ITEM lvI;
	lvI.mask = LVIF_TEXT;
	lvI.iItem = iItem;
	lvI.iSubItem = 0;
	lvI.pszText = pszName;
	lvI.cchTextMax = cchName;
	return ListView_GetItem(
					::GetDlgItem(m_hwnd, IDC_CONFNAME_LISTVIEW),
					&lvI);
}

void CChooseConfDlg::RefreshOk(HWND hwnd)
{
	BOOL fEnable = 0 != ::GetWindowTextLength(
                          GetDlgItem(hwnd, IDC_CONFNAME_EDIT));
	::EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);
}

BOOL CChooseConfDlg::OnOk(LPTSTR pszName)
{
	DebugEntry(CChooseConfDlg::OnOk);

	BOOL bRet = TRUE;

	m_strConfName = pszName;

	::EndDialog(m_hwnd, IDOK);

	DebugExitBOOL(CChooseConfDlg::OnOk, bRet);

	return bRet;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cmd.h ===
// File: cmd.h
//
// General Commands

#ifndef _CMD_H_
#define _CMD_H_

class CConfRoom;

VOID CmdDoNotDisturb(HWND hwnd);
VOID CmdHostConference(HWND hwnd);
VOID CmdShowAbout(HWND hwnd);
VOID CmdShowReleaseNotes(void);
VOID CmdSpeedDial(void);
VOID CmdLaunchWebPage(WPARAM wCmd);

VOID CmdGoMail(void);
BOOL FEnableCmdGoMail(void);

BOOL FEnableCmdShare(void);

BOOL FEnableCmdBack(void);
BOOL FEnableCmdForward(void);
BOOL FEnableCmdHangup(void);

BOOL FEnableAudioWizard(void);

BOOL FDoNotDisturb(void);
VOID SetDoNotDisturb(BOOL fSet);

VOID CmdViewStatusBar(void);
BOOL CheckMenu_ViewStatusBar(HMENU hMenu);
VOID CmdViewNavBar(void);
BOOL CheckMenu_ViewNavBar(HMENU hMenu);
VOID CmdViewFldrBar(void);
BOOL CheckMenu_ViewFldrBar(HMENU hMenu);

VOID CmdViewAudioBar(void);
BOOL FEnableCmdViewAudioBar(void);
BOOL CheckMenu_ViewAudioBar(HMENU hMenu);

VOID CmdViewTitleBar(void);
BOOL CheckMenu_ViewTitleBar(HMENU hMenu);

VOID LaunchRedirWebPage(LPCTSTR pcszPage, bool bForceFormat=false);

#endif /* _CMD_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\certui.cpp ===
// File: certui.cpp

#include "precomp.h"
#include "resource.h"
#include "nmmkcert.h"
#include "certui.h"
#include <tsecctrl.h>
#include "SDKInternal.h"
#include "ConfUtil.h"

#define SZ_CRYPTDLGDLL "CRYPTDLG"

extern INmSysInfo2 * g_pNmSysInfo;

//
// While the credentials underlying the certificate we are using
// are in use, we need to keep the certificate context around
// and the store open. So we hold the currently open cert store
// and cert context in these globals:

static PCCERT_CONTEXT g_pCertContext;
static HCERTSTORE g_hCertStore;

TCHAR * FormatCert ( PBYTE pbEncodedCert, DWORD cbEncodedCert )
{
    DWORD sc;
    PCCERT_CONTEXT pCert = NULL, pIssuerCert = NULL, pCACert = NULL;
    DWORD cbRet = 0;
    CHAR * pSubject = NULL;
    CHAR * pIssuer = NULL;
    DWORD cbSubject = 0;
    DWORD cbIssuer = 0;
    DWORD dwFlags;
    DWORD cbTotalRequired;
    CHAR szLoadStringBuf[512];
    HCERTSTORE hRootStore = NULL;
    HCERTSTORE hCAStore = NULL;
    BOOL fSelfIssued = FALSE;
    TCHAR * pInfo = NULL;
    TCHAR szNotBefore[64];
    TCHAR szNotAfter[64];

    ASSERT(pbEncodedCert);
    ASSERT(cbEncodedCert);

    //
    // Get the certificate from the encoded blob
    //

    pCert = CertCreateCertificateContext ( X509_ASN_ENCODING,
                                            pbEncodedCert,
                                            cbEncodedCert );


    if ( NULL == pCert )
    {
        // Creating the cert context failed
        ERROR_OUT(("Error creating cert context from %x (%d bytes): %x",
            pbEncodedCert, cbEncodedCert, GetLastError()));
        goto cleanup;
    }

    //
    // Get the subject information
    //

    cbSubject = CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Subject,
                        CERT_FORMAT_FLAGS,
                        NULL, 0);

    if ( 0 == cbSubject )
    {
        ERROR_OUT(("GetUserInfo: no subject string"));
        goto cleanup;
    }

    pSubject = new CHAR[cbSubject + 1];

    if ( NULL == pSubject )
    {
        ERROR_OUT(("GetUserInfo: error allocating subject name"));
        goto cleanup;
    }

    if ( 0 >= CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Subject,
                        CERT_FORMAT_FLAGS,
                        pSubject, cbSubject+1))
    {
        ERROR_OUT(("GetUserInfo: error getting subject string"));
        goto cleanup;
    }

    //
    // Get the issuer information
    //

    cbIssuer = CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Issuer,
                        CERT_FORMAT_FLAGS,
                        NULL, 0);

    if ( 0 == cbIssuer )
    {
        ERROR_OUT(("GetUserInfo: no issuer string"));
        goto cleanup;
    }

    pIssuer = new CHAR[cbIssuer + 1];

    if ( NULL == pIssuer )
    {
        ERROR_OUT(("GetUserInfo: error allocating issuer name"));
    }

    if ( 0 >= CertNameToStr (
                        pCert->dwCertEncodingType,
                        &pCert->pCertInfo->Issuer,
                        CERT_FORMAT_FLAGS,
                        pIssuer, cbIssuer+1))
    {
        ERROR_OUT(("GetUserInfo: error getting issuer string"));
        goto cleanup;
    }

    //
    // Format the file time from the cert
    //

    SYSTEMTIME stNotBefore;
    SYSTEMTIME stNotAfter;

    FileTimeToSystemTime(&(pCert->pCertInfo->NotBefore), &stNotBefore);
    FileTimeToSystemTime(&(pCert->pCertInfo->NotAfter), &stNotAfter);

    FmtDateTime(&stNotBefore, szNotBefore, CCHMAX(szNotBefore));
    FmtDateTime(&stNotAfter, szNotAfter, CCHMAX(szNotAfter));

    //
    // Open the root store for certificate verification
    //

    hRootStore = CertOpenSystemStore(0, "Root");

    if( NULL == hRootStore )
    {
        ERROR_OUT(("Couldn't open root certificate store"));
        goto cleanup;
    }

    //
    // Get the issuer certificate from the root store and check for problems
    //

    dwFlags =   CERT_STORE_REVOCATION_FLAG |
                CERT_STORE_SIGNATURE_FLAG |
                CERT_STORE_TIME_VALIDITY_FLAG;

    // Get the issuer of this cert

    pIssuerCert = CertGetIssuerCertificateFromStore(
                        hRootStore,
                        pCert,
                        NULL,
                        &dwFlags );

    // If the issuer of the certificate cannot be found in the root store,
    // check the CA store iteratively until we work our way back to a root
    // certificate

    pCACert = pCert;

    while ( NULL == pIssuerCert )
    {
        PCCERT_CONTEXT pTmpCert;

        if ( NULL == hCAStore )
        {
            hCAStore = CertOpenSystemStore(0, "CA");

            if ( NULL == hCAStore )
            {
                ERROR_OUT(("Couldn't open CA certificate store"));
                goto cleanup;
            }
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pTmpCert = CertGetIssuerCertificateFromStore(
                        hCAStore,
                        pCACert,
                        NULL,
                        &dwFlags );

        if ( NULL == pTmpCert )
        {
            TRACE_OUT(("Issuer not found in CA store either"));
            break;
        }

        if ( pCACert != pCert )
            CertFreeCertificateContext(pCACert);
        pCACert = pTmpCert;

        if ((( CERT_STORE_REVOCATION_FLAG & dwFlags ) &&
             !( CERT_STORE_NO_CRL_FLAG & dwFlags )) ||
             ( CERT_STORE_SIGNATURE_FLAG & dwFlags ) ||
             ( CERT_STORE_TIME_VALIDITY_FLAG & dwFlags ))
        {
            TRACE_OUT(("Problem with issuer in CA store: %x", dwFlags));
            break;
        }

        dwFlags =   CERT_STORE_REVOCATION_FLAG |
                    CERT_STORE_SIGNATURE_FLAG |
                    CERT_STORE_TIME_VALIDITY_FLAG;

        pIssuerCert = CertGetIssuerCertificateFromStore(
                        hRootStore,
                        pCACert,
                        NULL,
                        &dwFlags );

    }

    if ( pCACert != pCert )
        CertFreeCertificateContext ( pCACert );

    //
    // Total up the return buffer required
    //
    // BUGBUG this overestimates the requirements slightly because
    // this formatting buffer contains specifiers which will be
    // replaced during wsprintf
    cbTotalRequired =   cbSubject +
                        cbIssuer +
                        lstrlen(szNotBefore) +
                        lstrlen(szNotAfter) +
                        FLoadString2( IDS_FMTBUFFER, szLoadStringBuf,
                                    sizeof(szLoadStringBuf)) + 1;

    //
    // If there are problems, account for the extra info:
    //

    if ( NULL == pIssuerCert )
    {
        // If after all we couldn't find the issuer check if this is
        // a NetMeeting self-issued certificate and generate an appropriate
        // message if so:

        DWORD dwMagic;
        DWORD cbMagic;

        cbMagic = sizeof(dwMagic);

        // BUGBUG: why is user prop not available for remote context?
        //if (pSecurityInterface->pfn_CertGetCertificateContextProperty(pCert,
        //   CERT_FIRST_USER_PROP_ID, &dwMagic, &cbMagic) &&
        //  cbMagic == sizeof(dwMagic) && dwMagic == NMMKCERT_MAGIC )

        if ( !lstrcmp( pIssuer, SZ_NMROOTNAME ))
        {
            // We're just going to return some generic text about the
            // NetMeeting default certificate


            cbTotalRequired = FLoadString2( IDS_GENERIC_NMDC_TEXT,
                                szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
            fSelfIssued = TRUE;
        }
        else
        {
            cbTotalRequired += FLoadString2( IDS_CERTERR_NOISSUER,
                                szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
    }
    else
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            WARNING_OUT(("Verify: Signature invalid"));
            cbTotalRequired += FLoadString2( IDS_CERTERR_SIG,
                            szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            WARNING_OUT(("Verify: Cert expired"));
            cbTotalRequired += FLoadString2( IDS_CERTERR_EXPIRED,
                            szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
        if ( (dwFlags & CERT_STORE_REVOCATION_FLAG) &&
            !(dwFlags & CERT_STORE_NO_CRL_FLAG ) )
        {
            WARNING_OUT(("Verify: Cert revoked"));
            cbTotalRequired += FLoadString2( IDS_CERTERR_REVOKED,
                            szLoadStringBuf, sizeof(szLoadStringBuf)) + 1;
        }
        if ( 0 == (dwFlags & ~CERT_STORE_NO_CRL_FLAG) )
        {
            // Everything is OK:
            cbTotalRequired += FLoadString2( IDS_CERT_VERIFIED,
                                szLoadStringBuf, sizeof(szLoadStringBuf));
        }
    }


    //
    // Allocate the required buffer
    //

    pInfo = new TCHAR[cbTotalRequired];

    if ( NULL == pInfo )
    {
        ERROR_OUT(("Error allocating FormatCert return buffer"));
        goto cleanup;
    }

    //
    // If we're reporting on a NetMeeting issued certificate, just load
    // the generic text and return.
    //

    if ( fSelfIssued )
    {
        FLoadString( IDS_GENERIC_NMDC_TEXT, pInfo, cbTotalRequired );
        goto cleanup;
    }

    //
    // If we are here we can go ahead and format the data into the buffer
    //

    FLoadString( IDS_FMTBUFFER, szLoadStringBuf,
                sizeof(szLoadStringBuf));

    //
    // Do the formatting
    //

    wsprintf( pInfo, szLoadStringBuf, pSubject, pIssuer,
                            szNotBefore, szNotAfter );

    if ( NULL == pIssuerCert )
    {
        FLoadString( IDS_CERTERR_NOISSUER,
                szLoadStringBuf, sizeof(szLoadStringBuf));
        lstrcat( pInfo, szLoadStringBuf );
    }
    else
    {
        if ( dwFlags & CERT_STORE_SIGNATURE_FLAG )
        {
            FLoadString( IDS_CERTERR_SIG,
                            szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }
        if ( dwFlags & CERT_STORE_TIME_VALIDITY_FLAG )
        {
            FLoadString( IDS_CERTERR_EXPIRED,
                            szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }
        if ( (dwFlags & CERT_STORE_REVOCATION_FLAG) &&
            !(dwFlags & CERT_STORE_NO_CRL_FLAG ) )
        {
            FLoadString( IDS_CERTERR_REVOKED,
                            szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }

        if ( 0 == (dwFlags & ~CERT_STORE_NO_CRL_FLAG) )
        {
            // Everything is OK:
            FLoadString( IDS_CERT_VERIFIED,
                                szLoadStringBuf, sizeof(szLoadStringBuf));
            lstrcat( pInfo, szLoadStringBuf );
        }
    }

    ASSERT( cbRet < 1000 ); // Reasonableness check

cleanup:

    if ( NULL != pSubject )
        delete pSubject;

    if ( NULL != pIssuer )
        delete pIssuer;

    if ( NULL != pCert )
    {
        CertFreeCertificateContext ( pCert );
    }

    if ( NULL != pIssuerCert )
    {
        CertFreeCertificateContext ( pIssuerCert );
    }

    if ( NULL != hRootStore )
    {
        if ( !CertCloseStore(hRootStore, CERT_CLOSE_STORE_CHECK_FLAG))
        {
            WARNING_OUT(("FormatCert: error closing root store"));
        }
    }

    if ( NULL != hCAStore )
    {
        if ( !CertCloseStore(hCAStore, CERT_CLOSE_STORE_CHECK_FLAG))
        {
            WARNING_OUT(("FormatCert: error closing CA store"));
        }
    }

    return pInfo;
}

BOOL RefreshSelfIssuedCert (VOID)
{
    BOOL bRet = FALSE;
    DWORD dwResult;
    RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);

    if (reCONF.GetNumber(REGVAL_SECURITY_AUTHENTICATION,
                                    DEFAULT_SECURITY_AUTHENTICATION))
    {
        return TRUE;
    }

    //
    // If there's no sys info interface, that's probably OK, we're just
    // being called in the setup wizard.
    //

    if (!g_pNmSysInfo)
        return FALSE;

    //
    // Clear old cert out of transport
    //
    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            0, 0,
                            &dwResult);

    if ( g_pCertContext )
    {
        CertFreeCertificateContext ( g_pCertContext );
        g_pCertContext = NULL;
    }

    if ( g_hCertStore )
    {
        if ( !CertCloseStore ( g_hCertStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("SetSelfIssuedCert: closing store failed"));
        }
        g_hCertStore = NULL;
    }

    g_hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                    X509_ASN_ENCODING,
                                    0,
                                    CERT_SYSTEM_STORE_CURRENT_USER,
                                    WSZNMSTORE );
    if ( g_hCertStore )
    {
        //
        // We only expect one cert in here, get it
        //

        g_pCertContext = CertFindCertificateInStore(
                                              g_hCertStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_ANY,
                                              NULL,
                                              NULL);
        if ( g_pCertContext )
        {
            dwResult = -1;

            g_pNmSysInfo->ProcessSecurityData(
                                    TPRTCTRL_SETX509CREDENTIALS,
                                    (DWORD_PTR)g_pCertContext, 0,
                                    &dwResult);
            //
            // g_hCertStore and g_pCertContext now in use
            //

            if ( !dwResult )
            {
                bRet = TRUE;
            }
            else
            {
                ERROR_OUT(("RefreshSelfIssuedCert - failed in T.120"));
            }
        }
        else
        {
            ERROR_OUT(("RefreshPrivacyCert: no cert in %s?", SZNMSTORE));
        }
    }
    else
    {
        WARNING_OUT(("RefreshSelfIssuedCert: error opening %s store %x",
            SZNMSTORE, GetLastError()));
    }
    return bRet;
}

DWORD NumUserCerts(VOID)
{
    DWORD cCerts = 0;
    HCERTSTORE hStore;
    PCCERT_CONTEXT pCert = NULL;

    if ( hStore = CertOpenSystemStore(0, "MY"))
    {
        while ( pCert = CertEnumCertificatesInStore(
                                    hStore, (PCERT_CONTEXT)pCert ))
            cCerts++;
        if ( !CertCloseStore( hStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("NumUserCerts: error closing store"));
        }
    }
    return cCerts;
}

#include "cryptdlg.h"

typedef BOOL (WINAPI *PFN_CERT_SELECT_CERTIFICATE)(PCERT_SELECT_STRUCT_A);

BOOL ChangeCertDlg ( HWND hwndParent, HINSTANCE hInstance,
    PBYTE * ppEncodedCert, DWORD * pcbEncodedCert )
{
    HINSTANCE hCryptDlg = LoadLibrary ( SZ_CRYPTDLGDLL );
    PFN_CERT_SELECT_CERTIFICATE pfn_CertSelectCertificate;
    RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);
    PCCERT_CONTEXT pOldCert = NULL;
    BOOL bRet = FALSE;

    //
    // First, make sure we can get the CRYPTDLG entry point we need
    //

    if ( NULL == hCryptDlg )
    {
        ERROR_OUT(("Error loading CRYPTDLG"));
        return bRet;
    }

    pfn_CertSelectCertificate =
        (PFN_CERT_SELECT_CERTIFICATE)GetProcAddress ( hCryptDlg,
                                "CertSelectCertificateA" );

    if ( NULL == pfn_CertSelectCertificate )
    {
        ERROR_OUT(("Error getting CertSelectCertificate entry point"));
        goto cleanup;
    }

    //
    // Prepare to bring up the choose dialog
    //

    CERT_SELECT_STRUCT_A css;

    ZeroMemory ( &css, sizeof(css) );

    css.dwSize = sizeof(css);
    css.hwndParent = hwndParent;
    css.hInstance = hInstance;

    css.cCertStore = 1;

    HCERTSTORE aCertStore[1];
    aCertStore[0] = CertOpenSystemStore(0, "MY" );

    if ( NULL == aCertStore[0] )
    {
        ERROR_OUT(("Error opening 'my' store"));
        goto cleanup;
    }
    css.arrayCertStore = aCertStore;

    css.szPurposeOid = szOID_PKIX_KP_CLIENT_AUTH; // BUGBUG add server auth?

    PCCERT_CONTEXT pcc;
    pcc = NULL;

    //
    // Now, get access to the current NetMeeting certificate, if any
    //

    LPBYTE pCertID;
    DWORD cbCertID;

    if ( cbCertID = reCONF.GetBinary ( REGVAL_CERT_ID, (void**)&pCertID ))
    {

        while ( pOldCert = CertEnumCertificatesInStore(
                                    aCertStore[0], (PCERT_CONTEXT)pOldCert ))
        {
            if (cbCertID == pOldCert->pCertInfo->SerialNumber.cbData &&
                !memcmp(pCertID, pOldCert->pCertInfo->SerialNumber.pbData,
                                pOldCert->pCertInfo->SerialNumber.cbData))
            {
                // pOldCert must now be freed via CertFreeCertificateContext
                pcc = pOldCert;
                break;
            }
        }
    }

    css.cCertContext = 0;
    css.arrayCertContext = &pcc;

    if (pfn_CertSelectCertificate ( &css ))
    {
        ASSERT(1 == css.cCertContext);

        //
        // It worked, return the new cert
        //

        CoTaskMemFree ( *ppEncodedCert );

        if ( *ppEncodedCert = (PBYTE)CoTaskMemAlloc ( pcc->cbCertEncoded ))
        {
            memcpy ( *ppEncodedCert, pcc->pbCertEncoded, pcc->cbCertEncoded );
            *pcbEncodedCert = pcc->cbCertEncoded;
            bRet = TRUE;
        }
    }

cleanup:

    if ( aCertStore[0] )
        if (!CertCloseStore ( aCertStore[0], 0 ))
        {
            WARNING_OUT(("ChangeCertDlg: error closing store"));
        }

    if ( pOldCert )
    {
        CertFreeCertificateContext(pOldCert);
    }
    if ( hCryptDlg )
        FreeLibrary ( hCryptDlg );

    return bRet;
}

typedef BOOL (WINAPI *PFN_CERT_VIEW_PROPERTIES)(PCERT_VIEWPROPERTIES_STRUCT);

VOID ViewCertDlg ( HWND hwndParent, PCCERT_CONTEXT pCert )
{
    HINSTANCE hCryptDlg = LoadLibrary ( SZ_CRYPTDLGDLL );
    PFN_CERT_VIEW_PROPERTIES pfn_CertViewProperties;

    //
    // First, make sure we can get the CRYPTDLG entry point we need
    //

    if ( NULL == hCryptDlg )
    {
        ERROR_OUT(("Error loading CRYPTDLG"));
        return;
    }

    pfn_CertViewProperties =
        (PFN_CERT_VIEW_PROPERTIES)GetProcAddress ( hCryptDlg,
                                "CertViewPropertiesA" );

    if ( NULL == pfn_CertViewProperties )
    {
        ERROR_OUT(("Error getting CertViewProperties entry point"));
        goto cleanup;
    }

    CERT_VIEWPROPERTIES_STRUCT    cvp;
    ZeroMemory(&cvp, sizeof(cvp));

    cvp.dwSize = sizeof(cvp);
    cvp.pCertContext = pCert;
    cvp.hwndParent = hwndParent;

    pfn_CertViewProperties ( &cvp );

cleanup:

    if ( hCryptDlg )
        FreeLibrary ( hCryptDlg );

    return;
}

VOID FreeT120EncodedCert ( PBYTE pbEncodedCert )
{
    CoTaskMemFree(pbEncodedCert);
}

BOOL GetT120ActiveCert ( PBYTE * ppbEncodedCert, DWORD * pcbEncodedCert )
{
    if ( !g_pNmSysInfo )
    {
        ERROR_OUT(("GetT120ActiveCert: g_pNmSysInfo NULL"));
        return FALSE;
    }

    DWORD dwResult = -1;

    g_pNmSysInfo->ProcessSecurityData(TPRTCTRL_GETX509CREDENTIALS,
                                (DWORD_PTR)ppbEncodedCert,
                                (DWORD_PTR)pcbEncodedCert,
                                &dwResult);
    return ( dwResult == 0 );
}

BOOL SetT120CertInRegistry ( PBYTE pbEncodedCert, DWORD cbEncodedCert )
{
    PCCERT_CONTEXT pCert = CertCreateCertificateContext ( X509_ASN_ENCODING,
                                                        pbEncodedCert,
                                                        cbEncodedCert );

    if ( pCert )
    {
        RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);

        //
        // Set the new value
        //

        reCONF.SetValue ( REGVAL_CERT_ID,
                    pCert->pCertInfo->SerialNumber.pbData,
                    pCert->pCertInfo->SerialNumber.cbData );

        CertFreeCertificateContext(pCert);
        return TRUE;
    }
    return FALSE;
}

BOOL SetT120ActiveCert ( BOOL fSelfIssued,
                PBYTE pbEncodedCert, DWORD cbEncodedCert )
{
    BOOL bRet = FALSE;
    DWORD dwResult = -1;

    if ( !g_pNmSysInfo )
    {
        ERROR_OUT(("SetT120ActiveCert: g_pNmSysInfo NULL"));
        return FALSE;
    }

    //
    // Clear old cert out of transport
    //
    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            0, 0,
                            &dwResult);

    if (!g_pNmSysInfo)
        return FALSE;

    if ( g_pCertContext )
    {
        CertFreeCertificateContext ( g_pCertContext );
        g_pCertContext = NULL;
    }

    if ( g_hCertStore )
    {
        if ( !CertCloseStore ( g_hCertStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("SetT120ActiveCert: closing store failed"));
        }
        g_hCertStore = NULL;
    }

    if ( fSelfIssued )
    {
        g_hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                        X509_ASN_ENCODING,
                                        0,
                                        CERT_SYSTEM_STORE_CURRENT_USER,
                                        WSZNMSTORE );
        if ( g_hCertStore )
        {
            //
            // We only expect one cert in here, get it
            //

            g_pCertContext = CertFindCertificateInStore(
                                                  g_hCertStore,
                                                  X509_ASN_ENCODING,
                                                  0,
                                                  CERT_FIND_ANY,
                                                  NULL,
                                                  NULL);
            if ( g_pCertContext )
            {
                dwResult = -1;

                g_pNmSysInfo->ProcessSecurityData(
                                        TPRTCTRL_SETX509CREDENTIALS,
                                        (DWORD_PTR)g_pCertContext, 0,
                                        &dwResult);
                bRet = ( dwResult == 0 ); // BUGBUG TPRTSEC_NOERROR
            }
            else
            {
                WARNING_OUT(("SetT120ActiveCert: no cert in %s?", SZNMSTORE));
            }
        }
        else
        {
            WARNING_OUT(("SetT120ActiveCert: error opening %s store %x",
                SZNMSTORE, GetLastError()));
        }
    }
    else // !fSelfIssued
    {
        PCCERT_CONTEXT pCert = NULL;
        PCCERT_CONTEXT pCertMatch = CertCreateCertificateContext (
                                                            X509_ASN_ENCODING,
                                                            pbEncodedCert,
                                                            cbEncodedCert );

        if ( pCertMatch )
        {
            //
            // Open the user's store
            //

            if ( g_hCertStore = CertOpenSystemStore(0, "MY"))
            {

                while ( pCert = CertEnumCertificatesInStore(
                                        g_hCertStore, (PCERT_CONTEXT)pCert ))
                {
                    //
                    // Is this the same cert?
                    //

                    if ( ( pCert->pCertInfo->SerialNumber.cbData ==
                        pCertMatch->pCertInfo->SerialNumber.cbData ) &&

                        (!memcmp(pCert->pCertInfo->SerialNumber.pbData,
                            pCertMatch->pCertInfo->SerialNumber.pbData,
                                pCert->pCertInfo->SerialNumber.cbData)))
                    {
                        DWORD dwResult = -1;

                        g_pNmSysInfo->ProcessSecurityData(
                                            TPRTCTRL_SETX509CREDENTIALS,
                                            (DWORD_PTR)pCert, 0, &dwResult);

                        bRet = ( dwResult == 0 ); // BUGBUG TPRTSEC_NOERROR
                        break;
                    }
                }
                if ( pCert )
                {
                    // Found it.
                    g_pCertContext = pCert;
                }
                else
                {
                    WARNING_OUT(("SetT120ActiveCert: matching cert not found"));
                }
            }
            else
            {
                ERROR_OUT(("SetT120ActiveCert: can't open my store"));
            }
            CertFreeCertificateContext ( pCertMatch );
        }
    }
    return bRet;
}

static PCCERT_CONTEXT IGetDefaultCert ( BOOL fSystemOnly,
                                HCERTSTORE * phCertStore )
{
    RegEntry reCONF(CONFERENCING_KEY, HKEY_CURRENT_USER);
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;
    BOOL fNmDefaultCert = TRUE;
    LPBYTE pCertID;

    if ( fSystemOnly )
        fNmDefaultCert = FALSE;
    else
        fNmDefaultCert = !reCONF.GetNumber(REGVAL_SECURITY_AUTHENTICATION,
                                        DEFAULT_SECURITY_AUTHENTICATION);

    hStore = CertOpenSystemStore(0, fNmDefaultCert ?
                                    SZNMSTORE : "MY");

    if ( NULL != hStore )
    {
        PCCERT_CONTEXT pCert = NULL;
        DWORD cbCertID;

        if (!fNmDefaultCert && ( cbCertID = reCONF.GetBinary (
                        REGVAL_CERT_ID, (void**)&pCertID )))
        {
            while ( pCert = CertEnumCertificatesInStore(
                                        hStore, (PCERT_CONTEXT)pCert ))
            {
                if ( cbCertID == pCert->pCertInfo->SerialNumber.cbData &&
                    !memcmp(pCertID, pCert->pCertInfo->SerialNumber.pbData,
                                    pCert->pCertInfo->SerialNumber.cbData))
                {
                    // pCert must now be freed via CertFreeCertificateContext
                    pCertContext = pCert;
                    break;
                }
            }
        }

        if ( NULL == pCertContext )
        {
            // Delete the (stale) reg entry... the cert might have
            // been deleted by other UI.

            if ( !fNmDefaultCert )
                reCONF.DeleteValue( REGVAL_CERT_ID );

            // Find any old client certificate - if fNmDefaultCert this will be
            // the only one in the store.
            pCertContext = CertFindCertificateInStore(hStore,
                                                      X509_ASN_ENCODING,
                                                      0,
                                                      CERT_FIND_ANY,
                                                      NULL,
                                                      NULL);
        }
    }
    else
    {
        WARNING_OUT(("User store %s not opened!", fNmDefaultCert ? SZNMSTORE : "MY"));
        *phCertStore = NULL;
    }

    // Caller to free cert context
    *phCertStore = hStore;
    return pCertContext;
}

BOOL GetDefaultSystemCert ( PBYTE * ppEncodedCert, DWORD * pcbEncodedCert )
{
    HCERTSTORE hStore;
    PCCERT_CONTEXT pCertContext = IGetDefaultCert(TRUE, &hStore);
    BOOL bRet = FALSE;

    if ( pCertContext )
    {
        DWORD cb;
        PBYTE pb;

        if ( pb = (PBYTE)CoTaskMemAlloc ( pCertContext->cbCertEncoded ))
        {
            memcpy ( pb, pCertContext->pbCertEncoded,
                    pCertContext->cbCertEncoded );
            *ppEncodedCert = pb;
            *pcbEncodedCert = pCertContext->cbCertEncoded;
            bRet = TRUE;
        }
        CertFreeCertificateContext(pCertContext);
    }
    if ( hStore )
    {
        if ( !CertCloseStore ( hStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("GetDefaultSystemCert: error closing store"));
        }
    }
    return bRet;;
}

BOOL InitT120SecurityFromRegistry(VOID)
{
    BOOL bRet = FALSE;

    if ( !g_pNmSysInfo )
    {
        ERROR_OUT(("InitT120SecurityFromRegistry: g_pNmSysInfo NULL"));
        return FALSE;
    }

    //
    // Expect this to be called only once on startup
    //
    ASSERT( NULL == g_pCertContext );
    ASSERT( NULL == g_hCertStore );

    g_pCertContext = IGetDefaultCert(FALSE, &g_hCertStore);

    if ( NULL == g_pCertContext )
    {
        WARNING_OUT(("No user certificate found!"));

        // BUGBUG
        // This means the transport will not be ready for secure
        // calls... we return false but what does the caller do?
        //
    }
    else
    {
        DWORD dwResult = -1;

        g_pNmSysInfo->ProcessSecurityData(TPRTCTRL_SETX509CREDENTIALS,
                                (DWORD_PTR)g_pCertContext, 0, &dwResult);
        if ( !dwResult )
            bRet = TRUE;
        else
        {
            ERROR_OUT(("InitT120SecurityFromRegistry: picked up bad cert"));
        }
    }

    return bRet;
}


HRESULT SetCertFromCertInfo ( PCERT_INFO pCertInfo )
{
    HRESULT hRet = S_FALSE;

    ASSERT( pCertInfo );

    if (!g_pNmSysInfo)
        return hRet;

    //
    // Clear old cert out of transport
    //
    DWORD dwResult = -1;

    g_pNmSysInfo->ProcessSecurityData(
                            TPRTCTRL_SETX509CREDENTIALS,
                            0, 0,
                            &dwResult);

    if ( g_pCertContext )
    {
        CertFreeCertificateContext ( g_pCertContext );
        g_pCertContext = NULL;
    }

    if ( g_hCertStore )
    {
        if ( !CertCloseStore ( g_hCertStore, CERT_CLOSE_STORE_CHECK_FLAG ))
        {
            WARNING_OUT(("SetCertFromCertInfo: closing store failed"));
        }
        g_hCertStore = NULL;
    }

    if ( g_hCertStore = CertOpenSystemStore(0, "MY"))
    {
        //
        // Fix up relative pointers inside pCertInfo: Note that only
        // the pointers relevant to CertGetSubjectCertificateFromStore
        // are fixed up.
        //

        pCertInfo->SerialNumber.pbData += (DWORD_PTR)pCertInfo;
        pCertInfo->Issuer.pbData += (DWORD_PTR)pCertInfo;

        PCCERT_CONTEXT pCert = CertGetSubjectCertificateFromStore(
                                g_hCertStore, X509_ASN_ENCODING, pCertInfo );

        if ( pCert )
        {
            g_pNmSysInfo->ProcessSecurityData(
                                TPRTCTRL_SETX509CREDENTIALS,
                                (DWORD_PTR)pCert, 0, &dwResult);

            if ( 0 == dwResult ) // TPRTSEC_NO_ERROR
            {
                hRet = S_OK;
                g_pCertContext = pCert;
            }
        }
        else
        {
            WARNING_OUT(("SetCertFromCertInfo: matching cert not found"));
        }
    }
    else
    {
        ERROR_OUT(("SetCertFromCertInfo: can't open my store"));
    }
    return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\calv.h ===
// File calv.h
//
// Address List View class

#ifndef _CALV_H_
#define _CALV_H_

#include "confutil.h"
#include "richaddr.h"

VOID ClearRai(RAI ** ppRai);
RAI * DupRai(RAI * pRai);
RAI * CreateRai(LPCTSTR pszName, NM_ADDR_TYPE addrType, LPCTSTR pszAddr);
BOOL FEnabledNmAddr(DWORD dwAddrType);


///////////////////////////////
// Globals for FEnabledNmAddr
extern BOOL g_fGkEnabled;
extern BOOL g_fGatewayEnabled;
extern BOOL g_bGkPhoneNumberAddressing;


// Generic class for handling I/O to the list for CallDialog
class CALV : public RefCount
{
private:
	BOOL m_fAvailable;  // TRUE if data is available
	int  m_idsName;     // The address type name resource id
	HWND m_hwnd;        // The list view
	int  m_iIcon;       // small icon index
	const int * m_pIdMenu;  // Right click menu data
    bool m_fOwnerDataList;  

public:
	CALV(int ids, int iIcon=0, const int * pIdMenu=NULL, bool fOwnerData = false);
 	~CALV();

	// Return TRUE if there is data available
	BOOL FAvailable(void)          {return m_fAvailable;}
	VOID SetAvailable(BOOL fAvail) {m_fAvailable = fAvail;}
	VOID SetWindow(HWND hwnd)		{m_hwnd = hwnd;}
	HWND GetHwnd(void)             {return m_hwnd;}
	VOID ClearHwnd(void)           {m_hwnd = NULL;}
	BOOL FOwnerData(void)          {return m_fOwnerDataList;}

	int  GetSelection(void);
	VOID SetHeader(HWND hwnd, int ids);
	VOID DeleteItem(int iItem);

	// Get the standard name for the address list
	VOID GetName(LPTSTR psz, int cchMax)
	{
		FLoadString(m_idsName, psz, cchMax);
	}

	VOID DoMenu(POINT pt, const int * pIdMenu);	

	static VOID SetBusyCursor(BOOL fBusy);

	///////////////////////////////////////////////////////////////////////
	// VIRTUAL methods

	virtual int  GetIconId(LPCTSTR psz)           {return m_iIcon;}

	// Put the items into the list control
	virtual VOID ShowItems(HWND hwnd) = 0;  // This must be implemented

	// Destroy all of the data in the list control
	virtual VOID ClearItems(void);

	// Return the string data for the item/column
	virtual BOOL GetSzData(LPTSTR psz, int cchMax, int iItem, int iCol);

	// Return the name (from the first column)
	virtual BOOL GetSzName(LPTSTR psz, int cchMax);
	virtual BOOL GetSzName(LPTSTR psz, int cchMax, int iItem);

	// Return the "callTo" address (from the second column)
	virtual BOOL GetSzAddress(LPTSTR psz, int cchMax);
	virtual BOOL GetSzAddress(LPTSTR psz, int cchMax, int iItem);

	// Get the "Rich" address information
	virtual RAI * GetAddrInfo(void);
	virtual RAI * GetAddrInfo(NM_ADDR_TYPE addType);
	
	virtual LPARAM LParamFromItem(int iItem);

	// Handle a right click notification
	virtual VOID OnRClick(POINT pt);

	// Handle a command
	virtual VOID OnCommand(WPARAM wParam, LPARAM lParam);

	// Default commands
	virtual VOID CmdProperties(void);
	virtual VOID CmdSpeedDial(void);
	virtual VOID CmdRefresh(void);

    virtual void OnListCacheHint( int indexFrom, int indexTo ) 
    {
        ;     
    }

    virtual ULONG OnListFindItem( const TCHAR* szPartialMatchingString ) 
    {
        return TRUE;
    }

    virtual bool IsItemBold( int index ) 
    {
        return false;
    }

    virtual int OnListGetImageForItem( int iIndex ) 
    {
        return II_INVALIDINDEX;
    }
    virtual void OnListGetColumn1Data( int iItemIndex, int cchTextMax, TCHAR* szBuf ) { lstrcpyn( szBuf, "", cchTextMax ); }
    virtual void OnListGetColumn2Data( int iItemIndex, int cchTextMax, TCHAR* szBuf ) { lstrcpyn( szBuf, "", cchTextMax ); }
	virtual void OnListGetColumn3Data( int iItemIndex, int cchTextMax, TCHAR* szBuf ) { lstrcpyn( szBuf, "", cchTextMax ); }
};

#endif /* _CALV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cmdtb.h ===
// File: cmdtb.h

#ifndef _CMDTB_H_
#define _CMDTB_H_

enum {
	CMDTB_END      = 0, // end of list marker
	CMDTB_NEW_CALL = 1, // the first valid toolbar command index
	CMDTB_HANGUP,
	CMDTB_SHARE,
	CMDTB_WHITEBOARD,
	CMDTB_CHAT,
    CMDTB_AGENDA,
//	CMDTB_STOP,
	CMDTB_REFRESH,
	CMDTB_SPEEDDIAL,
	CMDTB_SWITCH,
	CMDTB_DELETE,
	CMDTB_DELETE_ALL,
	CMDTB_SEND_MAIL,
	CMDTB_PROPERTIES,
	CMDTB_BACK,
	CMDTB_FORWARD,
	CMDTB_HOME,
	CMDTB_MAX // count of toolbar items
};

    // CMDTB_STOP is not used anymore.... 
    // There is a bunch of old code that is not yanked from conf yet that needs this....
    // this just allows those files to compile...
#define CMDTB_STOP 666

#endif /* _CMDTB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cmd.cpp ===
// File: cmd.cpp
//
// General UI-type commands

#include "precomp.h"

#include "cmd.h"

#include "ConfPolicies.h"
#include <version.h>

#include "conf.h"
#include "confwnd.h"
#include "dshowdlg.h"
#include "dlghost.h"
#include "confroom.h"

#include "taskbar.h"  // for RefreshTaskbarIcon()

#include "getip.h"

// static strings
static const TCHAR g_cszRelNotesFileName[] = TEXT("netmeet.htm");

static BOOL g_fDoNotDisturb = 0;


BOOL FLaunchPsz(LPCTSTR pszPath)
{
	HINSTANCE hInst = ::ShellExecute(::GetMainWindow(),
		NULL, pszPath, NULL, NULL, SW_SHOWNORMAL);

	if ((INT_PTR)hInst <= 32)
	{
		ERROR_OUT(("ShellExecute() failed, rc=%d", (int)((INT_PTR) hInst)));
		return FALSE;
	}

	return TRUE;
}


static VOID LaunchWebPage(LPCTSTR pcszPage)
{
	FLaunchPsz(pcszPage);
}


BOOL IsIEClientInstalled(LPCTSTR pszClient)
{
	RegEntry re(pszClient, HKEY_LOCAL_MACHINE);
	LPTSTR pszDefault = re.GetString(NULL);

	return !FEmptySz(pszDefault);
}

BOOL FEnableCmdGoNews(void)
{
	return IsIEClientInstalled(REGVAL_IE_CLIENTS_NEWS);
}



/*  F  D O  N O T  D I S T U R B  */
/*-------------------------------------------------------------------------
    %%Function: FDoNotDisturb

-------------------------------------------------------------------------*/
BOOL FDoNotDisturb(void)
{
	return g_fDoNotDisturb;
}


/*  S E T  D O  N O T  D I S T U R B  */
/*-------------------------------------------------------------------------
    %%Function: SetDoNotDisturb

-------------------------------------------------------------------------*/
VOID SetDoNotDisturb(BOOL fSet)
{
	g_fDoNotDisturb = fSet;
}

/*  C M D  D O  N O T  D I S T U R B  */
/*-------------------------------------------------------------------------
    %%Function: CmdDoNotDisturb

-------------------------------------------------------------------------*/
VOID CmdDoNotDisturb(HWND hwnd)
{
	// Retrieve the "do not disturb" state:
	BOOL fCallsBlocked = FDoNotDisturb();

	CDontShowDlg dlgDNDWarn(IDS_DO_NOT_DISTURB_WARNING,
			REGVAL_DS_DO_NOT_DISTURB_WARNING, MB_OKCANCEL);

	if ((TRUE == fCallsBlocked) || (IDOK == dlgDNDWarn.DoModal(hwnd)))
	{
		// Toggle the DoNotDisturb state and refresh the UI
		SetDoNotDisturb(!fCallsBlocked);
		RefreshTaskbarIcon(::GetHiddenWindow());
	}
}


/*  C M D  H O S T  C O N F E R E N C E  */
/*-------------------------------------------------------------------------
    %%Function: CmdHostConference

-------------------------------------------------------------------------*/
VOID CmdHostConference(HWND hwnd)
{

	CDlgHost dlgHost;
	if (IDOK != dlgHost.DoModal(hwnd))
		return;
				
	HRESULT hr = ::GetConfRoom()->HostConference(dlgHost.PszName(), dlgHost.PszPassword(), dlgHost.IsSecure(),
        dlgHost.AttendeePermissions(), dlgHost.MaxParticipants());
	if (FAILED(hr))
	{
		DisplayErrMsg(IDS_ERRMSG_HOST);
	}
}

void FormatURL(LPTSTR szURL)
{
	LPTSTR pszFormat = new TCHAR[lstrlen(szURL)+1];
	if (NULL != pszFormat)
	{
		lstrcpy(pszFormat, szURL);

		wsprintf(szURL, pszFormat,
				::GetVersionInfo()->dwMajorVersion,
				::GetVersionInfo()->dwMinorVersion,
				::GetSystemDefaultLCID(),
				::GetUserDefaultLCID());

		delete[] pszFormat;
	}
}

/*  L A U N C H  R E D I R  W E B  P A G E  */
/*-------------------------------------------------------------------------
    %%Function: LaunchRedirWebPage

	Launch a redirector web page.  Used by CmdLaunchWebHelp.

	Note: pcszPage can be a resource ID that is associated with a
	format string that contains the URL and fields for 4 local ID's.

-------------------------------------------------------------------------*/
VOID LaunchRedirWebPage(LPCTSTR pcszPage, bool bForceFormat)
{
	TCHAR szWebPageFormat[1024]; // BUGBUG: MAX_URL??

	ASSERT(NULL != pcszPage);

	if (((UINT_PTR)pcszPage >> 16) == 0)
	{
		// pcszPage is a resource ID
		if (0 == ::LoadString(::GetInstanceHandle(), (UINT)((UINT_PTR) pcszPage),
				szWebPageFormat, CCHMAX(szWebPageFormat)))
		{
			ERROR_OUT(("LaunchRedirWebPage: Unable to find IDS=%08X", (UINT)((UINT_PTR)pcszPage)));
			return;
		}

		pcszPage = szWebPageFormat;
		bForceFormat = true;
	}

	if (bForceFormat)
	{
		lstrcpy(szWebPageFormat, pcszPage);
		FormatURL(szWebPageFormat);

		ASSERT(lstrlen(szWebPageFormat) < CCHMAX(szWebPageFormat));
		pcszPage = szWebPageFormat;
	}

	LaunchWebPage(pcszPage);
}


/*  C M D  L A U N C H  W E B  P A G E  */
/*-------------------------------------------------------------------------
    %%Function: CmdLaunchWebPage

    Display a web page, based on the command id.
-------------------------------------------------------------------------*/
VOID CmdLaunchWebPage(WPARAM wCmd)
{
	LPTSTR psz;

	switch (wCmd)
		{
	default:
		{
			ERROR_OUT(("CmdLaunchWebHelp: Unknown command id=%08X", wCmd));
			// fall through
		}
	case ID_HELP_WEB_FREE:
	case ID_HELP_WEB_FAQ:
	case ID_HELP_WEB_FEEDBACK:
	case ID_HELP_WEB_MSHOME:
	{
		// NOTE: this requires that the format strings are in the same order
		// as the menu command ID's
		LaunchRedirWebPage((LPCTSTR) wCmd - (ID_HELP_WEB_FREE - IDS_WEB_PAGE_FORMAT_FREE));
		break;
	}
	case ID_HELP_WEB_SUPPORT:
    {
        TCHAR sz[ MAX_PATH ];
        bool bForcePrintf = ConfPolicies::GetIntranetSupportURL(sz, CCHMAX(sz));
        LaunchRedirWebPage( sz, bForcePrintf );

        break;
    }
	case ID_HELP_WEB_NEWS:
	{
		RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
		psz = re.GetString(REGVAL_HOME_PAGE);
		if (FEmptySz(psz))
		{
			psz = (LPTSTR) IDS_WEB_PAGE_FORMAT_NEWS;
		}
		LaunchRedirWebPage(psz);
		break;
	}
		
	case IDM_VIDEO_GETACAMERA:
	{
		LaunchRedirWebPage(MAKEINTRESOURCE(IDS_WEB_PAGE_FORMAT_GETCAMERA));
		break;
	}

		} /* switch (wCommand) */
}


/*  C M D  S H O W  R E L E A S E  N O T E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdShowReleaseNotes

-------------------------------------------------------------------------*/
VOID CmdShowReleaseNotes(void)
{
	if (!FLaunchPsz(g_cszRelNotesFileName))
	{
		::PostConfMsgBox(IDS_RELEASE_NOTES_MISSING);
	}
}


/*  A B O U T  B O X  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: AboutBoxDlgProc

-------------------------------------------------------------------------*/
LRESULT APIENTRY AboutBoxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_INITDIALOG:
	{
		TCHAR sz[700]; // really large for copyright message
		TCHAR *szIPList[] = {sz, sz+20, sz+40, sz+80};
		TCHAR *szIPDisplay = sz+200;
		int nListSize = sizeof(szIPList)/sizeof(TCHAR*);
		int nCount, nIndex;

		if (0 != ::GetDlgItemText(hDlg, IDC_ABOUT_VERSION_STATIC, sz, CCHMAX(sz)))
		{
			// Retrieved the format buffer from the dialog:
			TCHAR szVisibleText[MAX_PATH];
			wsprintf(szVisibleText, sz, VER_PRODUCTVERSION_STR);
			// Replace the text with text that contains the version number:
			::SetDlgItemText(hDlg, IDC_ABOUT_VERSION_STATIC, szVisibleText);
		}

		// The about box copyright is > 255 characters.
		if (FLoadString(IDS_ABOUT_COPYRIGHT, sz, CCHMAX(sz)))
		{
			::SetDlgItemText(hDlg, IDC_ABOUT_COPYRIGHT, sz);
		}


		// go fetch our IP address and display it to the user
		// we can only display up to 4
		nCount = GetIPAddresses(szIPList, nListSize);
		if (nCount >= 1)
		{
			lstrcpy(szIPDisplay, szIPList[0]);
			for (nIndex = 1; nIndex < nCount; nIndex++)
			{
				lstrcat(szIPDisplay, ", ");
				lstrcat(szIPDisplay, szIPList[nIndex]);
			}
			::SetDlgItemText(hDlg, IDC_IP_ADDRESS, szIPDisplay);
		}
		else
		{
			// on error, don't show anything about IP addresses
			ShowWindow(GetDlgItem(hDlg, IDC_IP_ADDRESS), SW_HIDE);
			ShowWindow(GetDlgItem(hDlg, IDC_IPADDR_STATIC), SW_HIDE);
		}

		break;
	}

	case WM_COMMAND:
	{
		::EndDialog(hDlg, LOWORD(wParam));
		break;
	}

	default:
	{
		return FALSE;
	}
		} /* switch (uMsg) */

	return TRUE;
}


/*  C M D  S H O W  A B O U T  */
/*-------------------------------------------------------------------------
    %%Function: CmdShowAbout

-------------------------------------------------------------------------*/
VOID CmdShowAbout(HWND hwnd)
{
	::DialogBox(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_ABOUT_BOX),
				hwnd, (DLGPROC) AboutBoxDlgProc);
}



/*  F  E N A B L E  A U D I O  W I Z A R D  */
/*-------------------------------------------------------------------------
    %%Function: FEnableAudioWizard

-------------------------------------------------------------------------*/
BOOL FEnableAudioWizard(void)
{
	return FIsAudioAllowed() && (NULL == GetActiveConference());
}


///////////////////////////////////////////////////////////////////////////
// Application Sharing commands

BOOL FEnableCmdShare(void)
{
	CConfRoom * pcr = ::GetConfRoom();
	if (NULL == pcr)
		return FALSE;
	return pcr->FCanShare();
}



///////////////////////////////////////////////////////////////////////////

BOOL FEnableCmdHangup(void)
{
	return ::FIsConferenceActive();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\certui.h ===
// File: certui.h

TCHAR * FormatCert ( PBYTE pbEncodedCert, DWORD cbEncodedCert );

//
// Brings up a certificate picker dialog and returns the encoded
// certificate chosen in a buffer. Buffer must be freed via
// FreeT120EncodedCert.
//

BOOL ChangeCertDlg ( HWND hwndParent, HINSTANCE hInstance,
	PBYTE * ppEncodedCert, DWORD * pcbEncodedCert );

//
// Brings up system-dependent certificate details UI on the
// certificate specified by the context passed in.
//

VOID ViewCertDlg ( HWND hwndParent, PCCERT_CONTEXT pCert );
//
// Gets the currently active certificate from the transport and
// returns it in the buffer. Buffer must be freed via FreeT120EncodedCert.
//

BOOL GetT120ActiveCert( PBYTE * ppEncodedCert, DWORD * pcbEncodedCert );

//
// This function returns the user's default certificate as identified
// in the registry (or the first available if nothing is specified in
// the registry. The buffer returned must be freed via FreeT120EncodedCert.

BOOL GetDefaultSystemCert ( PBYTE * ppEncodedCert, DWORD * pcbEncodedCert );

//
// Sets the active certificate (NOT self issued) in the transprot using
// the supplied buffer as a template. If the cert passed in can't be
// found in the certificate store, then this function fails.
//

BOOL SetT120ActiveCert( BOOL fSelfIssued,
			PBYTE pEncodedCert, DWORD cbEncodedCert );

//
// Reads the registry for the user's initialization settings ( self-issued
// cert or system cert, and which system cert? ) and makes the corresponding
// certificate active in the transport. This function is called when the
// UI is initializing and if user startup settings need to be restored.
//

BOOL InitT120SecurityFromRegistry(VOID);

//
// Frees the passed in buffer.
//

VOID FreeT120EncodedCert( PBYTE pbEncodedCert );

//
// This function updates the registry (used for initialization) by
// saving the serial number of the supplied certificate to the registry.
// The passed in cert must be in the system store, not self-issued.
// 

BOOL SetT120CertInRegistry ( PBYTE pbEncodedCert, DWORD cbEncodedCert );

//
// This function makes the self-issued certificate in the application
// specific store active in the transport.
//

BOOL RefreshSelfIssuedCert (VOID);


//
// Utility function, returns number of certificates in system store
//

DWORD NumUserCerts(VOID);


//
// Takes pointer to CERT_INFO structure and sets cert in transport
//
HRESULT SetCertFromCertInfo ( PCERT_INFO pCertInfo );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confapi.h ===
/*
 *	ConfApi.h
 *
 *	CConfRoom Application Program Interface
 */

#ifndef _CONFAPI_H_
#define _CONFAPI_H_

VOID SetLoggedOn(BOOL fLoggedOn);

#endif /* _CONFAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\conf.h ===
// File: conf.h

#ifndef _CONF_H_
#define _CONF_H_

#include "ConfUtil.h"
#include "callto.h"

class CCallLog;

extern HWND g_hwndDropDown;
extern BOOL g_fHiColor;
extern HFONT g_hfontDlg;

extern CPing*	g_pPing;
extern OSVERSIONINFO g_osvi;
extern BOOL g_fNTDisplayDriverEnabled;
extern CCallLog* g_pInCallLog;
extern ULONG g_uMediaCaps;
extern INmSysInfo2 * g_pNmSysInfo;  // Interface to SysInfo
extern DWORD g_dwSysInfoNotifyCookie;
extern INmManager2 * g_pInternalNmManager;  // Interface to InternalINmManager
extern CCallto *	g_pCCallto;

HRESULT InitConfExe(BOOL fShowUI = TRUE);
inline LPOSVERSIONINFO GetVersionInfo()	{ return &g_osvi; }
inline BOOL IsWindowsNT() { return (VER_PLATFORM_WIN32_NT == g_osvi.dwPlatformId); }

inline CCallLog* GetIncomingCallLog() { return g_pInCallLog; }

BOOL ProcessMessage(UINT msg, WPARAM wParam, LPARAM lParam);
VOID CleanUp(BOOL fLogoffWindows=FALSE);
VOID CmdShutdown(void);
VOID HandleConfSettingsChange(DWORD dwSettings);
VOID SignalShutdownStarting(void);

#define WM_DIALMON_FIRST					(WM_USER+100)
#define WM_WINSOCK_ACTIVITY					(WM_DIALMON_FIRST+0)
#define WM_APP_EXITING						(WM_DIALMON_FIRST+3)
VOID SendDialmonMessage(UINT uMsg);
BOOL CheckRemoteControlService();

void LaunchApp(LPCTSTR lpCmdLine);

#endif // _CONF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confatltrace.h ===
#ifndef __ConfAtltrace_h__
#define __ConfAtltrace_h__


#ifdef _DEBUG

    inline void DbgZPrintAtlTrace(LPTSTR pszFormat,...)
    {
	    va_list v1;
	    va_start(v1, pszFormat);
        DbgZPrintTrace( pszFormat, v1 );
	    va_end(v1);
    }

	
	inline void DbgZPrintAtlTrace2(DWORD category, UINT level, LPSTR lpszFormat, ...)
	{
		DWORD g_dwAtlTraceCategory = 0xffffffff;
		if (category & g_dwAtlTraceCategory && level <= ATL_TRACE_LEVEL)
		{
			va_list v1;
			va_start(v1, lpszFormat);
			DbgZPrintTrace( lpszFormat, v1 );
			va_end(v1);
		}
	}

    #define ATLTRACE DbgZPrintAtlTrace
	#define ATLTRACE2 DbgZPrintAtlTrace2

#endif // _DEBUG


#endif // __ConfAtltrace_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confapi.cpp ===
/****************************************************************************
*
*	 FILE:	   ConfApi.cpp
*
*	 CONTENTS: CConfRoom Application Programming Interface
*
****************************************************************************/

#include "precomp.h"
#include "global.h"
#include "Conf.h"
#include "confapi.h"
#include "nameres.h"
#include "nmmanager.h"
#include "ConfUtil.h"


// from conf.cpp
extern INmSysInfo2 * g_pNmSysInfo;

BOOL g_fLoggedOn = FALSE;

/*  S E T  L O G G E D  O N  */
/*-------------------------------------------------------------------------
    %%Function: SetLoggedOn
    
-------------------------------------------------------------------------*/
VOID SetLoggedOn(BOOL fLoggedOn)
{
	g_fLoggedOn = fLoggedOn;

	if (NULL == g_pNmSysInfo)
		return;

	g_pNmSysInfo->SetOption(NM_SYSOPT_LOGGED_ON, fLoggedOn);
}


DWORD MapNmAddrTypeToNameType(NM_ADDR_TYPE addrType)
{
	switch (addrType)
		{
	case NM_ADDR_IP:
		return NAMETYPE_IP;

	case NM_ADDR_PSTN:
		return NAMETYPE_PSTN;

	case NM_ADDR_ULS:
		return NAMETYPE_ULS;

	case NM_ADDR_H323_GATEWAY:
		return NAMETYPE_H323GTWY;

	case NM_ADDR_ALIAS_ID:
		return NAMETYPE_ALIAS_ID;

	case NM_ADDR_ALIAS_E164:
		return NAMETYPE_ALIAS_E164;

	case NM_ADDR_UNKNOWN:
	default:
		return NAMETYPE_UNKNOWN;
		}
}

// Return TRUE if NetMeeting should display the incoming file transfer dialog
BOOL FFtDialog(void)
{
	return TRUE;
}

BOOL FUiVisible(void)
{
	HWND hwnd = ::GetMainWindow();
	if (NULL == hwnd)
		return FALSE;

	return IsWindowVisible(hwnd); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\conf.cpp ===
// File: conf.cpp

#include "precomp.h"
#include <mixer.h>
#include <EndSesn.h>
#include "NmLdap.h"

#include "conf.h"
#include "confwnd.h"
#include "taskbar.h"

#include <CR.h>
#include <tsecctrl.h>
#include "iapplet.h"
#include "inodecnt.h"
#include "ConfCpl.h"
#include "confroom.h"
#include "rtoolbar.h"
#include "GenWindow.h"
#include "cmd.h"
#include "confman.h"
#include "splash.h"
#include "calllog.h"
#include "call.h"      // for FreeCallList

#include "popupmsg.h"
#include "floatbar.h"

#include "confman.h"
#include <version.h>
#include <nmremote.h>

#include "wininet.h"
#include "setupapi.h"
#include "autoconf.h"

#include "ConfNmSysInfoNotify.h"
#include "ConfPolicies.h"

#include "DShowDlg.h"
#include "Callto.h"
#include "passdlg.h"

// SDK includes
#include "NetMeeting.h"
#include "NmApp.h"
#include "NmManager.h"		
#include "NmCall.h"			
#include "NmConference.h"
#include "SDKWindow.h"
#include "confapi.h"
#include "FtHook.h"
#include "t120app.h"
#include "certui.h"
#include "dlgcall2.h"
#include "ConfMsgFilter.h"

	
BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NetMeeting, CNetMeetingObj)
	OBJECT_ENTRY(CLSID_NmManager, CNmManagerObj)
	OBJECT_ENTRY(CLSID_NmApplet, CNmAppletObj)
END_OBJECT_MAP()


extern VOID SaveDefaultCodecSettings(UINT uBandWidth);
extern int WabReadMe(void);

HRESULT InitSDK();
void CleanupSDK();

///////////////////////////////////////////////////////////////////////////
// Global Variables

LPTSTR g_lpCmdLine = NULL;
CCallLog    * g_pInCallLog     = NULL;  // The incoming call log object
CSimpleArray<ITranslateAccelerator*> *g_pDialogList = NULL;  // Global list of modeless dialogs
CRITICAL_SECTION dialogListCriticalSection; // This is to avoid multiple access to the dialogList
INmSysInfo2 * g_pNmSysInfo     = NULL;  // Interface to SysInfo
INmManager2* g_pInternalNmManager = NULL;
DWORD		  g_dwSysInfoNotifyCookie = 0;
bool		g_bNeedCleanup = false;

bool   g_bEmbedding = FALSE;   // Started with the embedding flag
UINT   g_uEndSessionMsg;       // The "NetMeeting EndSession" message
BOOL   g_fHiColor = FALSE;     // TRUE if we have more than 256 colors
HWND   g_hwndDropDown = NULL;  //
BOOL   g_WSAStarted = FALSE;   // WSAStartup
CCallto *	g_pCCallto	= NULL;

// The flag to indicate if the NetMeeting's NT display driver is enabled.
BOOL   g_fNTDisplayDriverEnabled = FALSE;

OSVERSIONINFO g_osvi;  // The os version info structure global

///////////////////////////////////////////////////////////////////////////
// IPC-related globals:
HANDLE g_hInitialized  = NULL;
HANDLE g_hShutdown  = NULL;


///////////////////////////////////////////////////////////////////////////
// Hidden window-related globals:
CHiddenWindow * g_pHiddenWnd = NULL;
HWND  g_hwndESHidden   = NULL;
const TCHAR g_cszESHiddenWndClassName[] = _TEXT("ConfESHiddenWindow");
LRESULT CALLBACK ESHiddenWndProc(HWND, UINT, WPARAM, LPARAM);

///////////////////////////////////////////////////////////////////////////
// Remote control service related declarations

INT_PTR CALLBACK ServiceRunningDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
VOID RestartRemoteControlService();
const int MAX_REMOTE_TRIES = 30; // number of seconds to wait for service to shut down
const int SERVICE_IN_CALL = 1001;

///////////////////////////////////////////////////////////////////////////
// Media Caps

ULONG g_uMediaCaps = 0;

BOOL FIsAudioAllowed()
{
	return g_uMediaCaps & CAPFLAGS_AUDIO;
}

BOOL FIsReceiveVideoAllowed()
{
	return g_uMediaCaps & CAPFLAG_RECV_VIDEO;
}

BOOL FIsSendVideoAllowed()
{
	return g_uMediaCaps & CAPFLAG_SEND_VIDEO;
}

BOOL FIsAVCapable()
{
	return (FIsAudioAllowed() || FIsReceiveVideoAllowed() || FIsSendVideoAllowed());
}


extern BOOL SetProcessDefaultLayout(int iLayout);
typedef BOOL (WINAPI* PFNSPDL)(int);
#define LAYOUT_LTR 0
int g_iLayout = LAYOUT_LTR;
DWORD g_wsLayout = 0;

VOID CheckLanguageLayout(void)
{
	TCHAR szLayout[CCHMAXUINT];
	if (!FLoadString(IDS_DEFAULT_LAYOUT, szLayout, CCHMAX(szLayout)))
		return;

	g_iLayout = (int) DecimalStringToUINT(szLayout);
	if (0 == g_iLayout)
	{
#ifdef DEBUG
		RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);
		g_iLayout = re.GetNumber(REGVAL_DBG_RTL, DEFAULT_DBG_RTL);
		if (0 == g_iLayout)
#endif /* DEBUG */
			return;
	}

	HMODULE hmod = GetModuleHandle(TEXT("USER32"));
	if (NULL == hmod)
		return;

	PFNSPDL pfn = (PFNSPDL) GetProcAddress(hmod, "SetProcessDefaultLayout");
	if (NULL == pfn)
		return;

	BOOL fResult = pfn(g_iLayout);
	if (fResult)
	{
		g_wsLayout = WS_EX_NOINHERIT_LAYOUT;
	}
	else
	{
		ERROR_OUT(("Problem with SetProcessDefaultLayout"));
	}
}





///////////////////////////////////////////////////////////////////////////
// External Function Prototypes

// from dbgmenu.cpp
BOOL InitDebugMemoryOptions(void);


///////////////////////////////////////////////////////////////////////////
// Local Function Prototypes

BOOL HandleDialogMessage(LPMSG pMsg);



// This is for command line parsing...
LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}


// This launches a rundll32.exe which loads msconf.dll which will then wait for 
// us to terminate and make sure that the mnmdd display driver was properly deactivated.
BOOL CreateWatcherProcess()
{
    BOOL bRet = FALSE;
    HANDLE hProcess;

    // open a handle to ourselves that the watcher process can inherit
    hProcess = OpenProcess(SYNCHRONIZE,
                           TRUE,
                           GetCurrentProcessId());
    if (hProcess)
    {
        TCHAR szWindir[MAX_PATH];

        if (GetSystemDirectory(szWindir, sizeof(szWindir)/sizeof(szWindir[0])))
        {
            TCHAR szCmdLine[MAX_PATH * 2];
            PROCESS_INFORMATION pi = {0};
            STARTUPINFO si = {0};

            si.cb = sizeof(si);
            
            wsprintf(szCmdLine, "\"%s\\rundll32.exe\" msconf.dll,CleanupNetMeetingDispDriver %ld", szWindir, hProcess);

            if (CreateProcess(NULL,
                              szCmdLine,
                              NULL,
                              NULL,
                              TRUE, // we want the watcher to inherit hProcess, so we must set bInheritHandles = TRUE
                              0,
                              NULL,
                              NULL,
                              &si,
                              &pi))
            {
                bRet = TRUE;

                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
            }
        }

        CloseHandle(hProcess);
    }

    return bRet;
}


///////////////////////////////////////////////////////////////////////////

int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hInstPrev, LPTSTR lpCmdLine, int nCmdShow)
{
	// if there is another instance of NetMeeting shutting down
	// get out of here.  Ideally we should display a message and/or wait for shutdown.
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, _TEXT("CONF:ShuttingDown"));
	if (NULL != hEvent)
	{
		DWORD dwResult = WaitForSingleObject(hEvent, INFINITE);
		CloseHandle(hEvent);
		if (WAIT_TIMEOUT == dwResult)
		{
			return TRUE;
		}
	}

	// Init debug output as soon as possible
	ASSERT(::InitDebugMemoryOptions());
	ASSERT(::InitDebugModule(TEXT("CONF")));
	ASSERT(::InitDebugZones());

	g_lpCmdLine = lpCmdLine;

	int nRet = TRUE;


    BOOL fRestartService = FALSE;

    HRESULT hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

	if( SUCCEEDED( hr ) )
	{
			// Init CComModule
		_Module.Init(ObjectMap, hInstance, &LIBID_NetMeetingLib);
		_Module.m_dwThreadID = GetCurrentThreadId();
		_Module.m_hResourceModule = hInstance;
	
		TCHAR szCommandLineSeps[] = _T("-/");

			// Check to see if this is a reg/unreg request or background...
		BOOL fShowUI = TRUE;
		BOOL bRun = TRUE;
		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szCommandLineSeps);
		while (lpszToken != NULL)
		{
			if (lstrcmpi(lpszToken, _T("Embedding"))==0)
			{
				TRACE_OUT(("We are started with the -Embedding flag"));
				g_bEmbedding = TRUE;
			}
			if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
			{
				_Module.UpdateRegistryFromResource(IDR_NETMEETING, FALSE);
				nRet = _Module.UnregisterServer(TRUE);

					// These will fail without complaints
				DeleteShortcut(CSIDL_DESKTOP, g_szEmpty);
				DeleteShortcut(CSIDL_APPDATA, QUICK_LAUNCH_SUBDIR);

				bRun = FALSE;
				break;
			}
			if (lstrcmpi(lpszToken, _T("RegServer"))==0)
			{
				_Module.UpdateRegistryFromResource(IDR_NETMEETING, TRUE);
				nRet = _Module.RegisterServer(TRUE);
				bRun = FALSE;
				break;
			}

			if (lstrcmpi(lpszToken, g_cszBackgroundSwitch)==0)
			{
				fShowUI = FALSE;
			}

			lpszToken = FindOneOf(lpszToken, szCommandLineSeps);
		}

		if (bRun)
		{
			// Setup and RDS rely on the following event to determine whether NetMeeting is Running
			// this event creation should not be removed and the name should not be changed
			g_hInitialized = ::CreateEvent(NULL, TRUE, FALSE, _TEXT("CONF:Init"));
			if (NULL != g_hInitialized)
			{
				if (ERROR_ALREADY_EXISTS == ::GetLastError())
				{
					// CreateEvent returned a valid handle, but we don't want initialization to
					// succeed if we are running another copy of this exe, so we cleanup and exit
					WARNING_OUT(("Detected another conf.exe - sending a message"));
					IInternalConfExe *	pInternalConfExe;
					
					hr = CoCreateInstance( CLSID_NmManager, NULL, CLSCTX_ALL,
						IID_IInternalConfExe, (LPVOID *) &pInternalConfExe );
					if (SUCCEEDED(hr))
					{
						if(FAILED(pInternalConfExe->Launch()))
						{
							// If we are in INIT_CONTROL mode, then we can't launch NetMeeting or applets
							::ConfMsgBox(NULL, (LPCTSTR) IDS_CANT_START_NM_BECAUSE_SDK_APP_OWNS_NM);

						}
						pInternalConfExe->Release();
					}
				}
				else if(SUCCEEDED(InitHtmlHelpMarshaler(_Module.GetModuleInstance())))
				{
					// We create a seperate watcher process that will cleanup the mnmdd display driver
					// if we terminate unexpectedly. This is necessary since if we do not disable the
					// mirrored driver, all DX games will fail to run
					CreateWatcherProcess();

					//initialize ATL control contaiment code
					AtlAxWinInit();

					hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE);

					if( SUCCEEDED( hr ) )
					{
						BOOL fContinue = TRUE;

						if( FAILED(InitSDK()) )
						{
							fContinue = FALSE;
						}

						if(!g_bEmbedding)
						{
							// Before doing anything else, take care of the remote control service.
							fContinue = CheckRemoteControlService();
							fRestartService = fContinue;

							if(fContinue)
							{
								fContinue = SUCCEEDED(InitConfExe(fShowUI));
							}
						}

						if(fContinue)
						{
							TRACE_OUT(("Entering event loop..."));

							MSG msg;
							while (::GetMessage(&msg, NULL, 0, 0))
							{
								BOOL bHandled = FALSE;

								if(g_pPing)  // This is TRUE if InitConfExe has been called...
								{
									bHandled = ::HandleDialogMessage(&msg);
								}
								if(!bHandled)
								{
									::TranslateMessage(&msg);
									::DispatchMessage(&msg);
								}

							}
							TRACE_OUT(("Conf received WM_QUIT"));
						}

						if(g_bNeedCleanup)
						{
							CleanUp();
						}

						CleanupSDK();

						_Module.RevokeClassObjects();
					}
				}
				::CloseHandle(g_hInitialized);
				if (g_hShutdown)
				{
					SetEvent(g_hShutdown);
					::CloseHandle(g_hShutdown);
				}
			}
			else
			{
				ERROR_OUT(("CreateEvent (init) failed!"));
				hr = E_FAIL;
			}

			_Module.Term();
		}
		::CoUninitialize();

        //
        // Restart the remote control service if we need to.
        //
        if (fRestartService)
            RestartRemoteControlService();
	}

#ifdef DEBUG
	::ExitDebugModule();
	TRACE_OUT(("returned from ExitDebugModule"));
    ::DeinitDebugZones();
	TRACE_OUT(("returned from DeinitDebugZones"));
#endif //DEBUG

	return nRet;
}


VOID CheckMachineNameForExtendedChars ( VOID )
{

	DBGENTRY(CheckMachineNameForExtendedChars);

		// First we have to get the computer name
	TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD cchMachineName = CCHMAX(szMachineName);

		// Next we check to see if the computer nami is invalid
	if (GetComputerName(szMachineName, &cchMachineName))
	{
		for ( LPTSTR p = szMachineName; *p != _T('\0'); p++ )
		{
			if ( (WORD)(*p) & 0xFF80 )
			{
					// The machine name is invalid because it contains an invalid character
				CDontShowDlg MachineNameWarningDlg(	IDS_MACHINENAMEWARNING,
													REGVAL_DS_MACHINE_NAME_WARNING,
													DSD_ALWAYSONTOP | MB_SETFOREGROUND | MB_OK
												  );

				MachineNameWarningDlg.DoModal(NULL);

				goto end;
			}
		}
	}
	else
	{
		ERROR_OUT(("GetComputerName() failed, err=%lu", GetLastError()));
		*szMachineName = TEXT('\0');
	}

end:

	DBGEXIT(CheckMachineNameForExtendedChars);
}


VOID HandleConfSettingsChange(DWORD dwSettings)
{
	DebugEntry(HandleConfSettingsChange);
	
	USES_CONVERSION;

	TRACE_OUT(("HandleConfSettingsChange, dwSettings=0x%x", dwSettings));

	// Tell the user if she changed something that won't take
	// effect right away

	if (CSETTING_L_REQUIRESRESTARTMASK & dwSettings)
	{
	    ::ConfMsgBox(NULL, (LPCTSTR) IDS_NEED_RESTART);
	}
	if (CSETTING_L_REQUIRESNEXTCALLMASK & dwSettings)
	{
		if (::FIsConferenceActive())
		{
			::ConfMsgBox(NULL, (LPCTSTR) IDS_NEED_NEXTCALL);
		}
	}
	if (CSETTING_L_BANDWIDTH & dwSettings)
	{
		if (NULL != g_pNmSysInfo)
		{
			int nMegahertz=300, nProcFamily=6;
			RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
			UINT uSysPolBandwidth;
			UINT uBandwidth;
			
			uBandwidth = re.GetNumber(REGVAL_TYPICALBANDWIDTH, BW_DEFAULT);


#ifdef	_M_IX86
			GetNormalizedCPUSpeed(&nMegahertz, &nProcFamily);
			TRACE_OUT(("Normalized Processor Speed = %d, Processor type = %d\n", nMegahertz, nProcFamily));
#endif

			// convert bandwidth ID (1-4) to bits/sec
			uBandwidth = GetBandwidthBits(uBandwidth, nMegahertz);

			// the existance of a QOS - maximum bandwidth key implies that
			// the user's bandwidth is being over-rided (ONLY if his setting is LAN)

			uSysPolBandwidth = SysPol::GetMaximumBandwidth();

			if ((uSysPolBandwidth > 0) && (uBandwidth >= BW_SLOWLAN_BITS))
			{
				uBandwidth = max(uSysPolBandwidth, BW_144KBS_BITS);
			}

			g_pNmSysInfo->SetOption(NM_SYSOPT_BANDWIDTH, uBandwidth);
		}
	}

	if (CSETTING_L_SHOWTASKBAR & dwSettings)
	{
		// This will remove one if one is already there:
		::RemoveTaskbarIcon(::GetHiddenWindow());
		// This will add the icon if the registry switch is on:
		::AddTaskbarIcon(::GetHiddenWindow());
	}

	if (CSETTING_L_AUDIODEVICE & dwSettings)
	{
		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->OnAudioDeviceChanged();
		}
	}

	if (CSETTING_L_AGC & dwSettings)
	{
		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->OnAGC_Changed();
		}
	}

	if ((CSETTING_L_AUTOMIC|CSETTING_L_MICSENSITIVITY) & dwSettings)
	{
		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->OnSilenceLevelChanged();
		}
	}
	if( CSETTING_L_ULSSETTINGS & dwSettings )
	{
		if(g_pLDAP)
		{
			g_pLDAP->OnSettingsChanged();
		}

		if (NULL != g_pNmSysInfo)
		{
			RegEntry re(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
			LPCTSTR pcszName = re.GetString(REGVAL_ULS_NAME);

			g_pNmSysInfo->SetProperty(NM_SYSPROP_USER_NAME, CComBSTR(pcszName));
		}
	}
	if (CSETTING_L_FULLDUPLEX & dwSettings)
	{
		RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
		BOOL bFullDuplex = FALSE;
		UINT uSoundCardCaps = re.GetNumber(REGVAL_SOUNDCARDCAPS,SOUNDCARD_NONE);

		if (ISSOUNDCARDFULLDUPLEX(uSoundCardCaps))
		{
			bFullDuplex = re.GetNumber(REGVAL_FULLDUPLEX,FULLDUPLEX_DISABLED);
		}

		ASSERT(g_pNmSysInfo);

		if (NULL != g_pNmSysInfo)
		{
			g_pNmSysInfo->SetOption(NM_SYSOPT_FULLDUPLEX, bFullDuplex);
		}
	}

	if (CSETTING_L_CAPTUREDEVICE & dwSettings)
	{
		if (NULL != g_pNmSysInfo)
		{
			RegEntry re(VIDEO_KEY, HKEY_CURRENT_USER);
			DWORD dwCaptureID = re.GetNumber(REGVAL_CAPTUREDEVICEID, 0);

			g_pNmSysInfo->SetOption(NM_SYSOPT_CAPTURE_DEVICE, dwCaptureID);
		}
	}

	if (CSETTING_L_DIRECTSOUND & dwSettings)
	{
		ASSERT(g_pNmSysInfo);

		if (NULL != g_pNmSysInfo)
		{
			RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
			DWORD dwDS = re.GetNumber(REGVAL_DIRECTSOUND, DSOUND_USER_DISABLED);
			g_pNmSysInfo->SetOption(NM_SYSOPT_DIRECTSOUND, dwDS);
		}
	}

	DebugExitVOID(HandleConfSettingsChange);
}

// DeleteOldRegSettings is called the first time
// this build of NetMeeting is run by the user
// We don't touch UI\Directory as it is populated by the INF file
VOID DeleteOldRegSettings()
{
	// "%KEY_CONFERENCING%\UI"
	HKEY hKey;
	long lRet = ::RegOpenKey(HKEY_CURRENT_USER, UI_KEY, &hKey);
	if (NO_ERROR == lRet)
	{
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_X);
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_Y);
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_WIDTH);
		::RegDeleteValue(hKey, REGVAL_MP_WINDOW_HEIGHT);

		::RegCloseKey(hKey);
	}
}

static HRESULT _ValidatePolicySettings()
{
	HRESULT hr = S_OK;

	if( g_pNmSysInfo )
	{
        //
        // LAURABU BUGBUG BOGUS:
        //
        // If security required, and not available, warning
        // If security incoming required/outgoing preferred, warning
        //
	}
	else
	{
		ERROR_OUT(("g_pNmySysInfo should not me NULL"));
		hr = E_UNEXPECTED;				
	}

	return hr;
}

HRESULT InitSDK()
{
	DBGENTRY(InitSDK);
	HRESULT hr = S_OK;

	if(FAILED(hr = CSDKWindow::InitSDK())) goto end;
	if(FAILED(hr = CNmCallObj::InitSDK())) goto end;
	if(FAILED(hr = CNmManagerObj::InitSDK())) goto end;
	if(FAILED(hr = CNmConferenceObj::InitSDK())) goto end;
	if(FAILED(hr = CNetMeetingObj::InitSDK())) goto end;
	if(FAILED(hr = CFt::InitFt())) goto end;


	g_pCCallto = new CCallto;

	ASSERT( g_pCCallto != NULL );
	
	if( g_pCCallto == NULL )
	{
		hr = E_FAIL;
	}

	end:

	DBGEXIT_HR(InitSDK,hr);
	return hr;
}


void CleanupSDK()
{
	DBGENTRY(CleanupSDK);


		// Revoke the old filter object
	CoRegisterMessageFilter(NULL, NULL);


	CNmCallObj::CleanupSDK();
	CNmManagerObj::CleanupSDK();
	CNmConferenceObj::CleanupSDK();
	CSDKWindow::CleanupSDK();
	CNetMeetingObj::CleanupSDK();
	CFt::CloseFtApplet();

	DBGEXIT(CleanupSDK);
}


/*  I N I T  C O N F  E X E  */
/*-------------------------------------------------------------------------
    %%Function: InitConfExe

-------------------------------------------------------------------------*/
HRESULT InitConfExe(BOOL fShowUI)
{

		// Create a message filter object
	CComPtr<IMessageFilter> spMsgFilter;
	CComPtr<IMessageFilter> spOldMsgFilter;
	HRESULT hr = CConfMsgFilter::_CreatorClass::CreateInstance(NULL, IID_IMessageFilter, reinterpret_cast<void**>(&spMsgFilter));
	if(FAILED(hr)) return hr;

		// Register the message filter object
	hr = CoRegisterMessageFilter(spMsgFilter, &spOldMsgFilter);
	if(FAILED(hr)) return hr;

	//	Wipe out default find directory entry...  we no longer wish to persist this...
	//	in some future overhaul / cleanup we should stop using the registry for this...
	RegEntry	re( DLGCALL_MRU_KEY, HKEY_CURRENT_USER );

	re.SetValue( REGVAL_DLGCALL_DEFDIR, TEXT( "" ) );

	LPCTSTR lpCmdLine = g_lpCmdLine;
	TRACE_OUT(("InitConfExe"));

	// Init UI objects (NOTE: we continue if this fails)
	CPopupMsg::Init();
        CPasswordDlg::Init();

	// Allocate dialog list object:
	g_pDialogList = new CSimpleArray<ITranslateAccelerator*>;
	if (NULL == g_pDialogList)
	{
		ERROR_OUT(("Could not allocate g_pDialogList!"));
		return E_FAIL;
	}


	//
	// Initialize the critical section to protect the dialogList
	//
	InitializeCriticalSection(&dialogListCriticalSection);
	
	// Determine if we have MORE THAN 256 colors
	{
		HDC hdc = GetDC(NULL);
		if (NULL != hdc)
		{
			g_fHiColor = 8 < (::GetDeviceCaps(hdc, BITSPIXEL) * ::GetDeviceCaps(hdc, PLANES));
			ReleaseDC(NULL, hdc);
		}
	}

	// Get the default dialog (GUI) font for international
	// REVIEW: should we check the registry for a localized font?
	g_hfontDlg = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
	if (NULL == g_hfontDlg)
	{
		return E_FAIL;
	}

	LoadIconImages();

	// On Windows NT, determine if the NetMeeting display driver is
	// enabled.  Note that this depends on <g_osvi> being initialized.
	//
	// Since NT 5.0 will support dynamic loading of the display driver,
	// we assume that the driver is enabled if the OS major version
	// number is greater than 4.
	if (::IsWindowsNT())
	{
		RegEntry re(NM_NT_DISPLAY_DRIVER_KEY, HKEY_LOCAL_MACHINE, FALSE);

		g_fNTDisplayDriverEnabled =
			4 < g_osvi.dwMajorVersion ||
			NT_DRIVER_START_DISABLED !=
				re.GetNumber(
					REGVAL_NM_NT_DISPLAY_DRIVER_ENABLED,
					NT_DRIVER_START_DISABLED);
	}
	else
	{
		ASSERT(FALSE == g_fNTDisplayDriverEnabled);
	}

	// Check the language layout (UI can be displayed after this point)
	CheckLanguageLayout();

	// AutoConfiguration
	CAutoConf::DoIt();

	TRACE_OUT(("Command Line is \"%s\"", lpCmdLine));

	// Register hidden window class:
	WNDCLASS wcESHidden =
	{
		0L,
		ESHiddenWndProc,
		0,
		0,
		_Module.GetModuleInstance(),
		NULL,
		NULL,
		NULL,
		NULL,
		g_cszESHiddenWndClassName
	};
	
	if (!RegisterClass(&wcESHidden))
	{
		ERROR_OUT(("Could not register hidden wnd classes"));
		return E_FAIL;
	}

	
	// Register the "NetMeeting EndSession" message:
	g_uEndSessionMsg = ::RegisterWindowMessage(NM_ENDSESSION_MSG_NAME);
	
	// Create a hidden window for event processing:
	g_pHiddenWnd = new CHiddenWindow();
	if (NULL == g_pHiddenWnd)
	{
		return(E_FAIL);
	}
	g_pHiddenWnd->Create();

	g_hwndESHidden = ::CreateWindow(	g_cszESHiddenWndClassName,
										_TEXT(""),
										WS_POPUP, // not visible!
										0, 0, 0, 0,
										NULL,
										NULL,
										_Module.GetModuleInstance(),
										NULL);

	HWND hwndHidden = g_pHiddenWnd->GetWindow();

	if ((NULL == hwndHidden) || (NULL == g_hwndESHidden))
	{
		ERROR_OUT(("Could not create hidden windows"));
		return E_FAIL;
	}

	LONG lSoundCaps = SOUNDCARD_NONE;

	// Start the run-once wizard (if needed):
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// check to see if the wizard has been run in UI mode for this build
	DWORD dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_UI, 0);
	BOOL fRanWizardUI = ((VER_PRODUCTVERSION_W & HIWORD(dwVersion)) == VER_PRODUCTVERSION_W);

	BOOL fForceWizard = FALSE;
	if (!fRanWizardUI)
	{
		dwVersion = reConf.GetNumber(REGVAL_WIZARD_VERSION_NOUI, 0);
		BOOL fRanWizardNoUI = (VER_PRODUCTVERSION_DW == dwVersion);

		// wizard has not been run in UI mode
		if (!fRanWizardNoUI)
		{
			// wizard has not been run before, delete old registry settings
			DeleteOldRegSettings();

			fForceWizard = TRUE;
		}
		else
		{
			// wizard has been run in NoUI mode, we only need to run it if we are in UI mode
			if(fShowUI)
			{
				fForceWizard = TRUE;
			}
		}

		if (fForceWizard)
		{
			WabReadMe();
		}
	}

	hr = ::StartRunOnceWizard(&lSoundCaps, fForceWizard, fShowUI);
	if (FAILED(hr))
	{
		WARNING_OUT(("Did not retrieve necessary info from wizard"));
		ConfMsgBox(NULL, MAKEINTRESOURCE(IDS_ERROR_BAD_ADMIN_SETTINGS));

		return E_FAIL;
	}
	else if( S_FALSE == hr )
	{
		return NM_E_USER_CANCELED_SETUP;
	}

	if (fForceWizard)
	{
		reConf.SetValue(fShowUI ? REGVAL_WIZARD_VERSION_UI :
				REGVAL_WIZARD_VERSION_NOUI, VER_PRODUCTVERSION_DW);
	}

	// Start NetMeeting At Page Once
	if( fShowUI && fForceWizard )
	{
		if( ConfPolicies::IsShowFirstTimeUrlEnabled() )
		{
			CmdLaunchWebPage(ID_HELP_WEB_SUPPORT);
		}
	}

	// The following hack is to fix the don't run wizard twice bug
	// the side effect is that the codec ordering is blown away.
	// this code restores the key in the event that this wizard is not run.
	HKEY hKey;
	long lRet = ::RegOpenKey(HKEY_LOCAL_MACHINE,
			INTERNET_AUDIO_KEY TEXT("\\") REGVAL_ACMH323ENCODINGS , &hKey);
	if (NO_ERROR == lRet)
	{
		::RegCloseKey(hKey);
	}
	else
	{
		RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
		UINT uBandwidth = reAudio.GetNumber ( REGVAL_TYPICALBANDWIDTH, BW_DEFAULT );
		SaveDefaultCodecSettings(uBandwidth);
	}

	// Start the Splash screen only after the wizard is complete
	if (fShowUI)
	{
		::StartSplashScreen(NULL);
	}

	// Init incoming call log:
	g_pInCallLog = new CCallLog(LOG_INCOMING_KEY, TEXT("CallLog"));

	// Init capabilities:

	g_uMediaCaps = CAPFLAG_DATA;

	//
    // NOTE:  THIS IS WHERE TO CHANGE TO DISABLE H323 CALLS FOR INTEL ET AL.
    //

	if(!_Module.DidSDKDisableH323())
	{
		g_uMediaCaps |= CAPFLAG_H323_CC;

		if (SOUNDCARD_NONE != lSoundCaps)
		{
			if (!SysPol::NoAudio())
			{
				g_uMediaCaps |= CAPFLAGS_AUDIO;
			}
		}
		if (!SysPol::NoVideoReceive())
		{
			g_uMediaCaps |= CAPFLAG_RECV_VIDEO;
		}
		if (!SysPol::NoVideoSend())
		{
			g_uMediaCaps |= CAPFLAG_SEND_VIDEO;
		}
	}

	// Create Manager
	hr = CoCreateInstance(CLSID_NmManager2, NULL, CLSCTX_INPROC, IID_INmManager2, (void**)&g_pInternalNmManager);
	if (FAILED(hr))
	{
		ERROR_OUT(("Could not create INmManager"));
		return E_FAIL;
	}

	// Get the INmSysInfo3
	CComPtr<INmSysInfo > spSysInfo;
	if (SUCCEEDED(g_pInternalNmManager->GetSysInfo(&spSysInfo)))
	{
		if (FAILED(spSysInfo->QueryInterface(IID_INmSysInfo2, (void **)&g_pNmSysInfo)))
		{
			ERROR_OUT(("Could not get INmSysInfo2"));
		}
		else
		{
			ASSERT( g_pNmSysInfo );

			CComPtr<INmSysInfoNotify> spNmSysInfoNotify;
			if( SUCCEEDED ( CConfNmSysInfoNotifySink::_CreatorClass::CreateInstance( NULL, IID_INmSysInfoNotify, reinterpret_cast<void**>(&spNmSysInfoNotify))))
			{
				ASSERT(spNmSysInfoNotify);
				ASSERT(0 == g_dwSysInfoNotifyCookie);

				NmAdvise(g_pNmSysInfo, spNmSysInfoNotify, IID_INmSysInfoNotify, &g_dwSysInfoNotifyCookie);
			}
			
		}
	}

	_ValidatePolicySettings();

	hr = g_pInternalNmManager->Initialize(NULL, &g_uMediaCaps);
	if (FAILED(hr))
	{
		UINT_PTR uErrorID;

		switch (hr)
		{
			case UI_RC_NO_NODE_NAME:
			{
				// No error in this case - the user probably cancelled from
				// the intro wizard.
				uErrorID = 0;
				break;
			}
			case UI_RC_BACKLEVEL_LOADED:
			{
				uErrorID = IDS_BACKLEVEL_LOADED;
				break;
			}
			case UI_RC_T120_ALREADY_INITIALIZED:
			{
				uErrorID = IDS_T120_ALREADY_INITIALIZED;
				break;
			}

			case UI_RC_T120_FAILURE:
			{
				WARNING_OUT(("T.120 failed to initialize (winsock problem?)"));
				uErrorID = IDS_CANT_START;
				break;
			}

			default:
			{
				uErrorID = IDS_CANT_START;
				break;
			}
		}
		if (0 != uErrorID)
		{
			::ConfMsgBox(NULL, (LPCTSTR) uErrorID);
		}
		return E_FAIL;
	}

	// force the update of dll settings
	HandleConfSettingsChange(CSETTING_L_BANDWIDTH |
							CSETTING_L_CAPTUREDEVICE |
							CSETTING_L_ULSSETTINGS |
							CSETTING_L_DIRECTSOUND|
							CSETTING_L_FULLDUPLEX);

	if (FALSE == ::ConfRoomInit(_Module.GetModuleInstance()))
	{
		::ConfMsgBox(NULL, (LPCTSTR) IDS_CANT_START);
		return E_FAIL;
	}

	// Now perform the check on the machine name and warn if
	// it is problematic.
	::CheckMachineNameForExtendedChars();

	// Create the main conference manager to make sure
	// we can handle incoming calls, even in background mode
	if (!CConfMan::FCreate(g_pInternalNmManager))
	{
		ERROR_OUT(("Unable to create Conference Manager"));
		return E_FAIL;
	}

	// Initialize winsock  (for name/address resolution)
	{
		WSADATA wsaData;
		int iErr = WSAStartup(0x0101, &wsaData);
		if (0 != iErr)
		{
			ERROR_OUT(("WSAStartup() failed: %i", iErr));
			return E_FAIL;
		}
		g_WSAStarted = TRUE;
	}

	// Initialize T.120 Security settings
	::InitT120SecurityFromRegistry();

    StopSplashScreen();

    CreateConfRoomWindow(fShowUI);

	g_pPing = new CPing;

	if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct )
	{
		//	Initialize gatewayContext...
		RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

		if( reConf.GetNumber( REGVAL_USE_H323_GATEWAY ) != 0 )
		{
			g_pCCallto->SetGatewayName( reConf.GetString( REGVAL_H323_GATEWAY ) );
			g_pCCallto->SetGatewayEnabled( true );
		}

		if(ConfPolicies::LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode() && !_Module.DidSDKDisableInitialILSLogon())
		{
			InitNmLdapAndLogon();
		}
	}
	else
	{
		GkLogon();
	}

	if(!_Module.InitControlMode())
	{
		::AddTaskbarIcon(::GetHiddenWindow());
	}

	g_bNeedCleanup = true;
	CNmManagerObj::NetMeetingLaunched();
	return S_OK;
}

VOID CleanUpUi(void)
{
	SysPol::CloseKey();

	if( 0 != g_dwSysInfoNotifyCookie )
	{
		NmUnadvise(g_pNmSysInfo, IID_INmSysInfoNotify, g_dwSysInfoNotifyCookie);
		g_dwSysInfoNotifyCookie = 0;
	}

	if (NULL != g_pNmSysInfo)
	{
		if( IsGatekeeperLoggedOn() )
		{
			g_pNmSysInfo->GkLogoff();
		}

		g_pNmSysInfo->Release();
		g_pNmSysInfo = NULL;
	}

	FreeIconImages();

	CGenWindow::DeleteStandardPalette();
	CGenWindow::DeleteStandardBrush();

	CMainUI::CleanUpVideoWindow();

	CFindSomeone::Destroy();
}

VOID CleanUp(BOOL fLogoffWindows)
{

	FreeCallList();

	// Kill the taskbar icon:
	if (NULL != g_pHiddenWnd)
	{
		HWND hwndHidden = g_pHiddenWnd->GetWindow();

		TRACE_OUT(("Removing taskbar icon..."));
		::RemoveTaskbarIcon(hwndHidden);
		DestroyWindow(hwndHidden);

		g_pHiddenWnd->Release();
		g_pHiddenWnd = NULL;
	}

	// NOTE: during WM_ENDSESSION, we want
	// to log off after doing all other clean-up, in case it gets stuck
	// waiting for the logon thread to complete.
	if (FALSE == fLogoffWindows)
	{
		if(g_pLDAP)
		{
			g_pLDAP->Logoff();

			delete g_pLDAP;
			g_pLDAP = NULL;
		}
	}

	delete g_pCCallto;
	g_pCCallto = NULL;

	delete g_pPing;
	g_pPing = NULL;

	CleanUpUi();

	// These must happen AFTER all the UI is cleaned up
	if(g_pInternalNmManager)
	{
		g_pInternalNmManager->Release();
	}
	CConfMan::Destroy();

	// destroy incoming call log:
	delete g_pInCallLog;
	g_pInCallLog = NULL;

	CPopupMsg::Cleanup();
        CPasswordDlg::Cleanup();
	
	// Code to clean up gracefully

	if (FALSE == fLogoffWindows)
	{
		// NOTE: we intentionally leak this list object when shutting down
		// due to logging off windows, because we don't want to put a NULL
		// check in HandleDialogMessage() and there is no WM_QUIT to guarantee that
		// we've stopped receiving messages when shutting down in that code path

		EnterCriticalSection(&dialogListCriticalSection);

		for( int i = 0; i < g_pDialogList->GetSize(); ++i )
		{
			ASSERT( NULL != (*g_pDialogList)[i] );
			RemoveTranslateAccelerator( (*g_pDialogList)[i] );
		}

		LeaveCriticalSection(&dialogListCriticalSection);
		
		// Delete the dialog list:
		delete g_pDialogList;

		//
		// Delete the critical section
		//
		DeleteCriticalSection(&dialogListCriticalSection);
		
		g_pDialogList = NULL;
	}

	// Auto-disconnect from MSN:
	::SendDialmonMessage(WM_APP_EXITING);
	
	if (g_WSAStarted)
	{
		WSACleanup();
		g_WSAStarted = FALSE;
	}

	delete g_pConfRoom;
    g_pConfRoom = NULL;

	g_bNeedCleanup = false;
}

/*  S E N D  D I A L M O N  M E S S A G E  */
/*-------------------------------------------------------------------------
    %%Function: SendDialmonMessage

	Send a message to the dialing monitor.
	Either WINSOCK_ACTIVITY_TIMER or WM_APP_EXITING.
    (The code comes from Internet Explorer)
-------------------------------------------------------------------------*/
VOID SendDialmonMessage(UINT uMsg)
{
	HWND hwndAutodisconnectMonitor = ::FindWindow(_TEXT("MS_AutodialMonitor"), NULL);
	if (NULL != hwndAutodisconnectMonitor)
	{
		::SendMessage(hwndAutodisconnectMonitor, uMsg, 0, 0);
	}
}

// This window procedure exists for the sole purpose of receiving
// WM_ENDSESSION.  Because of bug 2287, we cannot have the regular
// hidden window handle WM_ENDSESSION.  DCL has subclassed our hidden
// window, and if we unload them inside one of it's messages, then we
// will fault.  It's too bad that we can't find a better fix (such as
// removing the subclass), but we are under time pressure to fix this
// bug for v1.0

LRESULT CALLBACK ESHiddenWndProc(	HWND hwnd, UINT uMsg,
									WPARAM wParam, LPARAM lParam)
{
	if ((WM_ENDSESSION == uMsg) && (TRUE == (BOOL) wParam))
	{
		TRACE_OUT(("Conf received WM_ENDSESSION, fLogoff=%s",
					GetBOOLString((BOOL)lParam)));
		TRACE_OUT(("Conf calling UIEndSession()"));
		CConfRoom::UIEndSession((BOOL) lParam);
		TRACE_OUT(("Conf testing lParam=%d", lParam));
		if ((BOOL) lParam)
		{
			// Logging off:
			TRACE_OUT(("Conf calling CleanUp()"));
			
			// NOTE: Passing TRUE into CleanUp() because we don't
			// want to logoff ULS / de-init name services until after insuring that DCL
			// has cleaned up properly, because it can take enough time that
			// our task might get killed.
			::CleanUp(TRUE);

			//
			// Restart the remote control service if we need to.
			//
			RestartRemoteControlService();
		}
		else
		{
			TRACE_OUT(("Conf not cleaning up - Windows shutting down"));
		}

#if 0 // LONCHANC: it faults 100% on my main dev machine.	
		if( g_pLDAP != NULL )
		{
			g_pLDAP->Logoff();
		}
#endif
		return 0;
	}
	else
	{
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
}


/*  C M D  S H U T D O W N  */
/*-------------------------------------------------------------------------
    %%Function: CmdShutdown

-------------------------------------------------------------------------*/
VOID CmdShutdown(void)
{
	HWND hwndMain = ::GetMainWindow();
	if (NULL != hwndMain)
	{
		// We have UI up, so post a WM_CLOSE with lParam = 1,
		// which indicates a forced "Exit and Stop"
		::PostMessage(hwndMain, WM_CLOSE, 0, 1);
	}
	else
	{
		::PostThreadMessage(_Module.m_dwThreadID, WM_QUIT, 0, 0);
	}
}

void SignalShutdownStarting(void)
{
	if (NULL == g_hShutdown)
	{
		g_hShutdown = ::CreateEvent(NULL, TRUE, FALSE, _TEXT("CONF:ShuttingDown"));
		_Module.RevokeClassObjects();
	}
}


/*  H A N D L E  D I A L O G  M E S S A G E  */
/*-------------------------------------------------------------------------
    %%Function: HandleDialogMessage

	Global modeless dialog handler
-------------------------------------------------------------------------*/
BOOL HandleDialogMessage(LPMSG pMsg)
{
	
	if (g_hwndDropDown != NULL)
	{
		switch (pMsg->message)
			{
		case WM_KEYDOWN:
		{
			if ((VK_ESCAPE != pMsg->wParam) && (VK_TAB != pMsg->wParam))
				break;
			if (0 != SendMessage(g_hwndDropDown, WM_CONF_DROP_KEY,
				pMsg->wParam, (LPARAM) pMsg->hwnd))
			{
				return TRUE; // message was handled
			}
			break;
		}
		
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		case WM_NCLBUTTONDOWN:
		case WM_NCRBUTTONDOWN:
		{
			if (g_hwndDropDown == pMsg->hwnd)
				break; // message is for the window, pass along as normal

			if (0 != SendMessage(g_hwndDropDown, WM_CONF_DROP_CLICK,
				0, (LPARAM) pMsg->hwnd))
			{
				return TRUE; // message was handled
			}
			break;
		}

		default:
			break;
			} /* switch (pMsg->message) */
	}

	ASSERT(NULL != g_pDialogList);

	EnterCriticalSection(&dialogListCriticalSection);


	for( int i = 0; i < g_pDialogList->GetSize(); ++i )
	{
		ITranslateAccelerator *pTrans = (*g_pDialogList)[i];
		ASSERT( NULL != pTrans );
		if( S_OK == pTrans->TranslateAccelerator(pMsg, 0) )
		{
			LeaveCriticalSection(&dialogListCriticalSection);
			return TRUE;
		}
	}
	
	LeaveCriticalSection(&dialogListCriticalSection);

	
	return FALSE;
}


//////////////////////////////////////////////////////////////////////////


/*  R E M O T E  P A S S W O R D  D L G  P R O C */
// Handles the dialog box asking if the user wants to start conf.exe even though the remote control
// service is in a call.
INT_PTR CALLBACK ServiceRunningDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		return TRUE;
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case ID_START_CONF:
			EndDialog(hDlg,1);
			break;
		case ID_EXIT:
			EndDialog(hDlg,0);
			break;
		default:
			break;
		}
		return TRUE;
		break;
	}
	return FALSE;
}

BOOL CheckRemoteControlService()
{
	BOOL fContinue = TRUE;
	
	// Store OS version info
	g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
	if (FALSE == ::GetVersionEx(&g_osvi))
	{
		ERROR_OUT(("GetVersionEx() failed!"));
		return FALSE;
	}

	if (::IsWindowsNT()) {
		SC_HANDLE hSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
		SC_HANDLE hRemoteControl = NULL;
		SERVICE_STATUS serviceStatus;

		if (hSCManager != NULL) {
			hRemoteControl = OpenService(hSCManager,REMOTE_CONTROL_NAME,SERVICE_ALL_ACCESS);
			DWORD dwError = GetLastError();
			if (hRemoteControl != NULL) {
				// If service is running...
				BOOL fSuccess = QueryServiceStatus(hRemoteControl,&serviceStatus);
				if (fSuccess && serviceStatus.dwCurrentState != SERVICE_STOPPED && serviceStatus.dwCurrentState != SERVICE_PAUSED) {
					if (serviceStatus.dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) // Service is in a call
                                        {
											fContinue = (BOOL)DialogBox(::GetInstanceHandle(),MAKEINTRESOURCE(IDD_SERVICE_RUNNING),GetDesktopWindow(),ServiceRunningDlgProc);
                                        }
					if (fContinue) {
						ControlService(hRemoteControl,SERVICE_CONTROL_PAUSE,&serviceStatus);
						for (int i = 0; i < MAX_REMOTE_TRIES; i++) {
							fSuccess = QueryServiceStatus(hRemoteControl,&serviceStatus);
							if (serviceStatus.dwCurrentState == SERVICE_PAUSED)
								break;
							TRACE_OUT(("Waiting for srvc - status is %d...",
								serviceStatus.dwCurrentState));
							Sleep(1000);
						}
						if ( MAX_REMOTE_TRIES == i )
						{
							// If we don't manage to shut down the service
							// we shouldn't try to start - it will only fail.
							WARNING_OUT(("TIMED OUT WAITING FOR SRVC!!"));
							fContinue = FALSE;
						}
					}
				}
				CloseServiceHandle(hRemoteControl);
			}
			CloseServiceHandle(hSCManager);
		}

		return fContinue;
	}
	else {	// Windows 95
            HANDLE hServiceEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_PAUSE_EVENT);
            HANDLE hActiveEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_ACTIVE_EVENT);
            DWORD dwError = GetLastError();
            if (hServiceEvent != NULL && hActiveEvent != NULL) {	// Service is running and is active
                CloseHandle(hActiveEvent);
                HANDLE hCallEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_CALL_EVENT);
                if (hCallEvent != NULL) {		// Service is in a call
                    fContinue = (BOOL)DialogBox(::GetInstanceHandle(),MAKEINTRESOURCE(IDD_SERVICE_RUNNING),GetDesktopWindow(),ServiceRunningDlgProc);
                    CloseHandle(hCallEvent);
                }
                if (fContinue) {
                    SetEvent(hServiceEvent);
                    CloseHandle(hServiceEvent);
                    for (int i = 0; i < MAX_REMOTE_TRIES; i++) {
                        hActiveEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_ACTIVE_EVENT);
                        if (NULL == hActiveEvent)
                            break;
                        TRACE_OUT(("Waiting for srvc"));
                        CloseHandle(hActiveEvent);
                        Sleep(1000);
                    }
                    if ( MAX_REMOTE_TRIES == i ) {
                        // If we don't manage to shut down the service
                        // we shouldn't try to start - it will only fail.
                        WARNING_OUT(("TIMED OUT WAITING FOR SRVC!!"));
                        fContinue = FALSE;
                    }
                }
            }
            return fContinue;
	}
}

VOID RestartRemoteControlService()
{
	RegEntry reLM = RegEntry(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);

	if (!reLM.GetNumber(REMOTE_REG_RUNSERVICE,0))
		return;

	if (ConfPolicies::IsRDSDisabled())
	{
		WARNING_OUT(("RDS launch disallowed by policy"));
		return;
	}
        BOOL fActivate = reLM.GetNumber(REMOTE_REG_ACTIVATESERVICE, DEFAULT_REMOTE_ACTIVATESERVICE);
	if (::IsWindowsNT()) {
		SERVICE_STATUS serviceStatus;
		SC_HANDLE hSCManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);
		SC_HANDLE hRemoteControl = OpenService(hSCManager,REMOTE_CONTROL_NAME,SERVICE_ALL_ACCESS);
		if (hRemoteControl != NULL) {
                    BOOL fSuccess = QueryServiceStatus(hRemoteControl,&serviceStatus);
                    if (SERVICE_STOPPED == serviceStatus.dwCurrentState)
                    {
                        StartService(hRemoteControl,0,NULL);
                    }
                    else
                    {
                        if (fActivate)
                        {
                            ControlService(hRemoteControl, SERVICE_CONTROL_CONTINUE, &serviceStatus);
                        }
                    }
		}
		else
		{
                    WARNING_OUT(("Error starting RDS"));
		}
	}
	else
        {
            if (ConfPolicies::IsRDSDisabledOnWin9x())
            {
                WARNING_OUT(("RDS launch disallowed by policy on Win9x"));
            }
            else
            {
                // Windows 95
                HANDLE hServiceEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_CONTINUE_EVENT);
                if (hServiceEvent)  // Service is running
                {
                    if (fActivate)
                    {
                        SetEvent(hServiceEvent);
                    }
                    CloseHandle(hServiceEvent);
                }
                else
                {
                    WinExec(WIN95_SERVICE_APP_NAME,SW_SHOWNORMAL);
                }
            }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confman.h ===
// File: confman.h

#ifndef _CONFMAN_H_
#define _CONFMAN_H_

#include "SDKInternal.h"

class CConfMan : public RefCount, public INmManagerNotify
{
protected:
	static CConfMan   * m_pConfMan;

public:
	static CConfMan * GetInstance()  {return m_pConfMan;}
	static BOOL       FCreate(INmManager2 *pManager);
	static VOID       Destroy();
	static INmManager2 * GetNmManager();
	static VOID       AllowAV(BOOL fAllowAV);

private:
	INmManager2 * m_pManager;
	DWORD         m_dwCookie;

	VOID         CleanUp(void);
	INmManager2 * GetINmManager()            {return m_pManager;}

public:
	CConfMan::CConfMan(INmManager2 *pManager);
	CConfMan::~CConfMan();

	VOID CheckIca();
	
	//
	// IUnknown methods:
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	//
	// INmManagerNotify methods:
	//
    STDMETHODIMP NmUI(CONFN uNotify);
    STDMETHODIMP ConferenceCreated(INmConference *pConference);
    STDMETHODIMP CallCreated(INmCall *pCall);
};


#endif /* _CONFMAN_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confcpl.h ===
// File: ConfCpl.h
//
// Main header file for Wizards and Options Dialog

#ifndef _CONFCPL_H_
#define _CONFCPL_H_

#include <ConfWiz.h>
#include <AudioWiz.h>
#include "confpolicies.h"
#include "csetting.h"

// CPL-specific WM_USER messages
#define WM_AUDIOCALIBRATE       WM_USER + 200
#define WM_DONEAUDIOCALIBRATE   WM_USER + 201
#define WM_ENDCALIBRATE         WM_USER + 202
#define WM_CALIBTIMELEFT        WM_USER + 203

// from wizard.cpp
extern BOOL g_fSilentWizard;
void HideWizard(HWND hwnd);
void ShowWizard(HWND hwnd);

class CULSWizard;

HRESULT StartRunOnceWizard(LPLONG plSoundCaps, BOOL fForce, BOOL fVisible);
BOOL FLegalEmailSz(PTSTR pszName);
bool IsLegalGateKeeperServerSz(LPCTSTR szServer);
bool IsLegalGatewaySz(LPCTSTR szServer);
bool IsLegalE164Number(LPCTSTR szPhone);
void InitDirectoryServicesDlgInfo( HWND hDlg, CULSWizard* pWiz, bool& bOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch );
void InitGatekeeperDlgInfo( HWND hDlg, HWND hDlgUserInfo, CULSWizard* pWiz, bool &rbCantChangeGkCallingMode );
void SetGKAddressingMode( HWND hDlg, HWND hDlgUserInfo, CULSWizard* pWiz, ConfPolicies::eGKAddressingMode eMode );

BOOL FLegalEmailName(HWND hdlg, UINT id);

VOID FillServerComboBox(HWND hwndCombo);

VOID FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg,
    DLGPROC pfnDlgProc, LPARAM lParam=0, LPCTSTR pszProc=NULL);

// Global flag keeps setting that changed for windows msg broadcast
extern DWORD g_dwChangedSettings;

// externs to dialog procedures in separate files
extern INT_PTR APIENTRY ConferencingDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY SecurityDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY AudioDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY VideoDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY UserDlgProc ( HWND, UINT, WPARAM, LPARAM );
extern INT_PTR APIENTRY CallOptDlgProc(HWND, UINT, WPARAM, LPARAM);
extern INT_PTR APIENTRY RemoteDlgProc ( HWND, UINT, WPARAM, LPARAM );

extern int GetBandwidthBits(int id, int megahertz);


#endif /* _CONFCPL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confman.cpp ===
// File: confman.cpp
//
// Conference Manager

#include "precomp.h"

#include "conf.h"
#include "confroom.h"
#include "confman.h"

#include "cr.h"      // for CreateConfRoom
#include "call.h"    // for OnUICallCreated

CConfMan * CConfMan::m_pConfMan = NULL; // There is only one of these

static const UINT g_cuShutdownMsgTimeout = 0x7FFFFFFF; // milliseconds


/*  C  C O N F  M A N  */
/*-------------------------------------------------------------------------
    %%Function: CConfMan
    
-------------------------------------------------------------------------*/
CConfMan::CConfMan(INmManager2 *pManager) :
	RefCount(NULL),
	m_pManager(pManager)
{
	m_pConfMan = this;

	ASSERT(NULL != m_pManager);

	NmAdvise(m_pManager, (INmManagerNotify*)this, IID_INmManagerNotify, &m_dwCookie);
	m_pManager->AddRef();

	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CConfMan", this);
}

CConfMan::~CConfMan()
{
	ASSERT(NULL == m_pManager);
	m_pConfMan = NULL;

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CConfMan", this);
}

BOOL CConfMan::FCreate(INmManager2 *pManager)
{
	if (NULL != m_pConfMan)
		return FALSE;  // already created

	m_pConfMan = new CConfMan(pManager);
	if (NULL == m_pConfMan)
		return FALSE;

	return TRUE;
}

VOID CConfMan::Destroy(void)
{
	if (NULL == m_pConfMan)
		return;

	m_pConfMan->CleanUp();

	// we should only have one more lock on this object
	m_pConfMan->Release();
	// so this will be cleared in the destructor
	ASSERT(NULL == m_pConfMan);
}

VOID CConfMan::CleanUp(void)
{
	if (NULL != m_pManager)
	{
		NmUnadvise(m_pManager, IID_INmManagerNotify, m_dwCookie);

		CConfRoom* pcr = ::GetConfRoom();
		if (NULL != pcr)
		{
			pcr->CleanUp();
		}

		m_pManager->Release();
		m_pManager = NULL;
	}

}


/*  G E T  N M  M A N A G E R  */
/*-------------------------------------------------------------------------
    %%Function: GetNmManager
    
-------------------------------------------------------------------------*/
INmManager2 * CConfMan::GetNmManager()
{
	if (NULL == m_pConfMan)
		return NULL;

	INmManager2 * pManager = m_pConfMan->GetINmManager();
	if (NULL != pManager)
	{
		pManager->AddRef();
	}
	return pManager;
}



//////////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP_(ULONG) CConfMan::AddRef(void)
{
	return RefCount::AddRef();
}

STDMETHODIMP_(ULONG) CConfMan::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CConfMan::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmManagerNotify) || (riid == IID_IUnknown))
	{
		*ppv = (INmManagerNotify *)this;
		ApiDebugMsg(("CConfMan::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CConfMan::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////
// INmManagerNotify

STDMETHODIMP CConfMan::NmUI(CONFN uNotify)
{
	return S_OK;
}

STDMETHODIMP CConfMan::ConferenceCreated(INmConference *pConference)
{
	CConfRoom * m_pConfRoom = ::GetConfRoom();
	ASSERT(NULL != m_pConfRoom);

	if(_Module.IsUIActive())
	{
		m_pConfRoom->BringToFront();
	}

	return m_pConfRoom->OnConferenceCreated(pConference);
}

STDMETHODIMP CConfMan::CallCreated(INmCall *pCall)
{
	OnUICallCreated(pCall);

	return S_OK;
}


VOID CConfMan::AllowAV(BOOL fAllowAV)
{
	CConfMan * pConfMan = CConfMan::GetInstance();
	if (NULL == pConfMan)
		return;

	INmManager2 * pManager = pConfMan->GetINmManager();
	if (NULL == pManager)
		return;

	pManager->AllowH323(fAllowAV);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confmsgfilter.h ===
#ifndef __ConfMsgFilter_h__
#define __ConfMsgFilter_h__

/////////////////////////////////////////////////////////////////////////////
// CConfMsgFilter
class ATL_NO_VTABLE CConfMsgFilter : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IMessageFilter
{

	typedef CComCreator< CComObjectNoLock< CConfMsgFilter > > _CreatorClass;

	BEGIN_COM_MAP(CConfMsgFilter)
		COM_INTERFACE_ENTRY(IMessageFilter)
	END_COM_MAP()

	STDMETHOD_(DWORD,HandleInComingCall)
	(
		DWORD dwCallType,
		HTASK htaskCaller,
		DWORD dwTickCount,
		LPINTERFACEINFO lpInterfaceInfo
	)
	{
		return SERVERCALL_ISHANDLED;
	}

	STDMETHOD_(DWORD,RetryRejectedCall)
	(
		HTASK htaskCallee,
		DWORD dwTickCount,
		DWORD dwRejectType
	)
	{
		
		if (SERVERCALL_REJECTED == dwRejectType)
		{
			MessageBox(NULL, _T("Call was rejected"), _T("IMessageFilter"), MB_OK);
			return -1;    
		}
			
		if (dwTickCount < 30000)
			return 200;    

		return -1;
	}

	STDMETHOD_(DWORD,MessagePending)
	(
		HTASK htaskCallee,
		DWORD dwTickCount,
		DWORD dwPendingType
	)
	{
		return PENDINGMSG_WAITNOPROCESS;
	}
};



#endif // __ConfMsgFilter_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confnmsysinfonotify.h ===
#ifndef __ConfNmSysInfoNotify_h__
#define __ConfNmSysInfoNotify_h__

class ATL_NO_VTABLE CConfNmSysInfoNotifySink : 
    public CComObjectRoot,
    public INmSysInfoNotify
{


    
public:

		// We create it as No Lock, but we had better make sure that
		// the lifetime of this object is not greater than the lifetime of
		// the module in which it lives
	typedef CComCreator< CComObjectNoLock< CConfNmSysInfoNotifySink > > _CreatorClass;

    DECLARE_NO_REGISTRY()

// INmSysInfoNotify
	STDMETHOD(GateKeeperNotify)( IN NM_GK_NOTIFY_CODE RasEvent );

    BEGIN_COM_MAP(CConfNmSysInfoNotifySink)
	    COM_INTERFACE_ENTRY(INmSysInfoNotify)
    END_COM_MAP()
};


#endif // __ConfNmSysInfoNotify_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confnmsysinfonotify.cpp ===
#include "precomp.h"
#include "resource.h"
#include "call.h"
#include "imsconf3.h"
#include "ConfNmSysInfoNotify.h"
#include "ConfUtil.h"


///////////////////////////////////////
// INmSysInfoNotify
///////////////////////////////////////
STDMETHODIMP CConfNmSysInfoNotifySink::GateKeeperNotify( IN NM_GK_NOTIFY_CODE code )
{
	HRESULT hr = S_OK;

	switch( code )
	{
		case NM_GKNC_REG_CONFIRM:	TRACE_OUT(("NM_GKNC_REG_CONFIRM notification received"));
			SetGkLogonState(NM_GK_LOGGED_ON);
			break;

		case NM_GKNC_LOGON_TIMEOUT: TRACE_OUT(("NM_GKNC_LOGON_TIMEOUT notification received"));
			SetGkLogonState(NM_GK_IDLE);
			PostConfMsgBox(IDS_ERR_GK_LOGON_TIMEOUT);
			break;
		case NM_GKNC_REJECTED:	TRACE_OUT(("NM_GKNC_REJECTED notification received"));
			PostConfMsgBox(IDS_ERR_GK_LOGON_REJECTED);
			SetGkLogonState(NM_GK_IDLE);
			break;

		case NM_GKNC_UNREG_CONFIRM:	TRACE_OUT(("NM_GKNC_UNREG_CONFIRM notification received"));
		case NM_GKNC_UNREG_REQ:	TRACE_OUT(("NM_GKNC_UNREG_REQ notification received"));
			SetGkLogonState(NM_GK_IDLE);
			break;
		default:
			WARNING_OUT(("Unknown notification recieved from GateKeeper"));
			break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confndui.cpp ===
#include "precomp.h"
#include "resource.h"
#include "confwnd.h"
#include "confapi.h"
#include "ConfUtil.h"


HWND GetMsgBoxParent(void)
{
	return (_Module.IsUIVisible() ? ::GetMainWindow() : HWND_DESKTOP );
}

VOID PostConfMsgBox(UINT uStringID)
{
	::PostMessage(::GetHiddenWindow(), WM_CONF_MSG_BOX, uStringID, 0);
}

static const UINT MAX_CONFMSGBOX_STRING = 1024;
int ConfMsgBox(HWND hwndParent, LPCTSTR pcszMsg, UINT uType)
{
	if(_Module.InitControlMode())
	{
		// Return a reasonable value
		// TODO: Look at MB_DEFBUTTON1
		switch (uType & 0x0F)
		{
		case MB_YESNOCANCEL:
		case MB_YESNO:
			return IDYES;
		case MB_OK:
		case MB_OKCANCEL:
		default:
			return IDOK;
		}
	}

	TCHAR	szTitleBuf[MAX_PATH];
	TCHAR	szMsgBuf[MAX_CONFMSGBOX_STRING];
	LPTSTR	pszTrueMsg = (LPTSTR) pcszMsg;

	if (0 == HIWORD(pcszMsg))
	{
		// The string pointer is actually a resource id:
		if (::LoadString(	::GetInstanceHandle(),
							PtrToUint(pcszMsg),
							szMsgBuf,
							CCHMAX(szMsgBuf)))
		{
			pszTrueMsg = szMsgBuf;
		}
		else
		{
			pszTrueMsg = NULL;
		}
	}

	// The string pointer is actually a resource id:
	::LoadString(	::GetInstanceHandle(),
					IDS_MSGBOX_TITLE,
					szTitleBuf,
					CCHMAX(szTitleBuf));

	ASSERT(pszTrueMsg);
	
	return ::MessageBox(hwndParent,
						pszTrueMsg,
						szTitleBuf,
						uType);
}

VOID DisplayMsgIdsParam(int ids, LPCTSTR pcsz)
{
	if (!_Module.InitControlMode())
	{
		TCHAR szFormat[MAX_CONFMSGBOX_STRING];
		int nLength = ::LoadString(::GetInstanceHandle(), ids, szFormat, CCHMAX(szFormat));
		ASSERT(0 != nLength);

		LPTSTR pszMsg = new TCHAR[nLength + (FEmptySz(pcsz) ? 1 : lstrlen(pcsz))];
		if (NULL == pszMsg)
		{
			ERROR_OUT(("DisplayMsgIdsParam - out of memory"));
			return;
		}

		// Format the message
		wsprintf(pszMsg, szFormat, pcsz);

		if (!::PostMessage(::GetHiddenWindow(), WM_NM_DISPLAY_MSG,
			(WPARAM) MB_ICONINFORMATION | MB_SETFOREGROUND | MB_OK, (LPARAM) pszMsg))
		{
			delete pszMsg;
			ERROR_OUT(("DisplayMsgIdsParam - out of memory"));
		}
	}
}

int DisplayMsg(LPTSTR pszMsg, UINT uType)
{
	TCHAR szTitle[MAX_PATH];
	FLoadString(IDS_MSGBOX_TITLE, szTitle, CCHMAX(szTitle));

	int id = ::MessageBox(GetMsgBoxParent(), pszMsg, szTitle, uType);

	delete pszMsg;
	return id;
}

VOID DisplayErrMsg(INT_PTR ids)
{
	ConfMsgBox(::GetMainWindow(), (LPCTSTR) ids, MB_OK | MB_SETFOREGROUND | MB_ICONERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confpolicies.h ===
#ifndef __ConfPolicies_h__
#define __ConfPolicies_h__

#include "resource.h"
#include "ConfUtil.h"
#include "ConfReg.h"

extern bool g_bAutoAccept;

namespace ConfPolicies
{

#if USE_GAL
		inline bool IsGetMyInfoFromGALEnabled( void )
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return rePol.GetNumber( REGVAL_POL_GAL_USE, DEFAULT_POL_GAL_USE ) ? true : false ;
		}

		inline bool GetMyInfoFromGALSucceeded( void )
		{
			RegEntry reIsapi( ISAPI_KEY, HKEY_CURRENT_USER );
			if( NULL == reIsapi.GetString( REGVAL_ULS_FIRST_NAME ) ||
				NULL == reIsapi.GetString( REGVAL_ULS_LAST_NAME ) ||
				NULL == reIsapi.GetString( REGVAL_ULS_EMAIL_NAME ) )
			{
				return false;
			}
			else
			{
				return true;
			}
		}

		inline DWORD GetGALName()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_NAME, DEFAULT_POL_GAL_NAME );
		}

		inline DWORD GetGALSurName()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_SURNAME, DEFAULT_POL_GAL_SURNAME );
		}

		inline DWORD GetGALEmail()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_EMAIL, DEFAULT_POL_GAL_EMAIL );
		}

		inline DWORD GetGALLocation()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_LOCATION, DEFAULT_POL_GAL_LOCATION );
		}

		inline DWORD GetGALPhoneNum()
		{

			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_PHONENUM, DEFAULT_POL_GAL_PHONENUM );
		}

		inline DWORD GetGALComment()
		{
			RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
			return (DWORD)rePol.GetNumber( REGVAL_POL_GAL_COMMENTS, DEFAULT_POL_GAL_COMMENTS );
		}
#endif // USE_GAL
	inline bool IsShowFirstTimeUrlEnabled( void )
	{
		RegEntry rePol( POLICIES_KEY, HKEY_CURRENT_USER );
		return rePol.GetNumber( REGVAL_POL_SHOW_FIRST_TIME_URL, DEFAULT_POL_SHOW_FIRST_TIME_URL ) ? true : false;
	}

    inline bool IsChatEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_CHAT, DEFAULT_POL_NO_CHAT );
    }

    inline bool IsFileTransferEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return(!rePol.GetNumber( REGVAL_POL_NO_FILETRANSFER_SEND, DEFAULT_POL_NO_FILETRANSFER_SEND)
          ||   !rePol.GetNumber( REGVAL_POL_NO_FILETRANSFER_RECEIVE, DEFAULT_POL_NO_FILETRANSFER_RECEIVE));
    }

    inline UINT GetMaxSendFileSize( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return(rePol.GetNumber(REGVAL_POL_MAX_SENDFILESIZE, DEFAULT_POL_MAX_FILE_SIZE));
    }

    inline bool IsOldWhiteboardEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_OLDWHITEBOARD, DEFAULT_POL_NO_OLDWHITEBOARD );
    }

    inline bool IsNewWhiteboardEnabled( void )
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_NEWWHITEBOARD, DEFAULT_POL_NO_NEWWHITEBOARD );
    }

	// Returns true if need to add LCID stuff
    inline bool GetIntranetSupportURL( TCHAR *sz, int cchmax )
    {
		bool bRet = false;

            // if the string params are messed up, just return false
        ASSERT( sz && ( cchmax > 0 ) );

            // Try to get the registry value
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        LPCTSTR szTemp = rePol.GetString( REGVAL_POL_INTRANET_SUPPORT_URL );

        if( szTemp[0] )
        {
            // This means that the registry value is there and the query succeeded
            lstrcpyn( sz, szTemp, cchmax );
        }
        else
        {       // There is no reg key, we use the default
            Res2THelper( IDS_WEB_PAGE_FORMAT_SUPPORT, sz, cchmax );
			bRet = true;
        }

		return(bRet);
    }

	// Returns non-empty strings if there is a web dir set by policy
    bool GetWebDirInfo(
		LPTSTR szURL=NULL, int cchmaxURL=0,
		LPTSTR szServer=NULL, int cchmaxServer=0,
		LPTSTR szName=NULL, int cchmaxName=0
		);

    bool IsAutoAcceptCallsOptionEnabled(void);
    bool IsAutoAcceptCallsPersisted(void);
    bool IsAutoAcceptCallsEnabled(void);
    void SetAutoAcceptCallsEnabled(bool bAutoAccept);

	inline int GetSecurityLevel(void)
	{
    	RegEntry reConf(POLICIES_KEY, HKEY_CURRENT_USER);
	   	return reConf.GetNumber( REGVAL_POL_SECURITY, DEFAULT_POL_SECURITY);
	}

    //
    // These two are ONLY the end-user setting.  They are not meaningful
    // if the security level is required or disabled, only standard.
    //
    inline bool IncomingSecurityRequired(void)
    {
        RegEntry reIncoming(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return(reIncoming.GetNumber(REGVAL_SECURITY_INCOMING_REQUIRED, DEFAULT_SECURITY_INCOMING_REQUIRED) != 0);
    }

    inline bool OutgoingSecurityPreferred(void)
    {
        RegEntry reOutgoing(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return(reOutgoing.GetNumber(REGVAL_SECURITY_OUTGOING_PREFERRED, DEFAULT_SECURITY_OUTGOING_PREFERRED) != 0);
    }


	inline bool IsFullDuplexAllowed(void)
	{
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_FULLDUPLEX, DEFAULT_POL_NO_FULLDUPLEX );
	}

	inline bool IsAdvancedAudioEnabled(void)
	{
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
        return !rePol.GetNumber( REGVAL_POL_NO_ADVAUDIO, DEFAULT_POL_NO_ADVAUDIO);
	}

	inline bool GetLocalConferenceParticipantName( TCHAR *sz, int cchmax )
	{

            // if the string params are messed up, just return false
        if( sz && ( cchmax > 0 ) )
        {
                // Try to get the registry value
	     	RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
		    LPCTSTR szTemp = reULS.GetString( REGVAL_ULS_EMAIL_NAME );

            if( szTemp[0] )
            {
                // This means that the registry value is there and the query succeeded
                lstrcpyn( sz, szTemp, cchmax );
            }
            else
            {       // There is no reg key, we use the default
                lstrcpy( sz, _T("Error, no local user") );
            }
        }
        else
        {   
            return false;
        }

        return true;

	}

	enum eCallingMode { CallingMode_Direct, CallingMode_GateKeeper, CallingMode_Invalid };

	inline eCallingMode GetCallingMode(void)
	{
		eCallingMode eRet = CallingMode_Invalid;
		RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
        switch( reConf.GetNumber( REGVAL_CALLING_MODE, CALLING_MODE_DIRECT) )
		{
			case CALLING_MODE_DIRECT:
				eRet = CallingMode_Direct;
				break;

			case CALLING_MODE_GATEKEEPER:
				eRet = CallingMode_GateKeeper;
				break;
		}

		return eRet;
	}
	
	inline void GetGKServerName(TCHAR* psz, int cch )
	{
		if( psz )
		{
			RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
			lstrcpyn( psz, reConf.GetString(REGVAL_GK_SERVER), cch );
		}
	}

	inline void GetGKAccountName(TCHAR* psz, int cch )
	{
		if( psz )
		{
			RegEntry	reULS( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

			lstrcpyn( psz, reULS.GetString( REGVAL_ULS_GK_ACCOUNT), cch );
		}
	}

    inline BOOL UserCanChangeCallMode(void)
    {
        RegEntry reConf(POLICIES_KEY, HKEY_CURRENT_USER);
        return !reConf.GetNumber(REGVAL_POL_NOCHANGECALLMODE, DEFAULT_POL_NOCHANGECALLMODE);
    }

	inline void GetGatewayServerName(TCHAR* psz, int cch )
	{
		if( psz )
		{
			RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
			lstrcpyn( psz, reConf.GetString(REGVAL_GK_SERVER), cch );
		}
	}


	
	enum eGKAddressingMode { GKAddressing_Invalid = 0, GKAddressing_PhoneNum, GKAddressing_Account, GKAddressing_Both };

	inline eGKAddressingMode GetGKAddressingMode(void)
	{
		RegEntry			reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );
		eGKAddressingMode	mode	= GKAddressing_Invalid;

        switch( reConf.GetNumber( REGVAL_GK_METHOD, GKAddressing_Invalid ) )
		{
			case GK_LOGON_USING_PHONENUM:
				mode = GKAddressing_PhoneNum;
				break;

			case GK_LOGON_USING_ACCOUNT:
				mode = GKAddressing_Account;
				break;

			case GK_LOGON_USING_BOTH:
				mode = GKAddressing_Both;
				break;
		}

		return( mode );
	}


	inline bool LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode(void)
	{
        RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return !reConf.GetNumber( REGVAL_DONT_LOGON_ULS, DONT_LOGON_ULS_DEFAULT);
	}

	inline bool LogOntoIlsWhenNetMeetingStarts(void)
	{
		return ((ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct) &&
		    (LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode()));
	}

	inline bool RunWhenWindowsStarts(void)
	{
        RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
        return (0 != reConf.GetNumber(REGVAL_CONF_ALWAYS_RUNNING, ALWAYS_RUNNING_DEFAULT));
	}

	inline bool InvalidMyInfo()
	{
        RegEntry reIsapi(ISAPI_KEY, HKEY_CURRENT_USER);

		return ( 
				( NULL == reIsapi.GetString( REGVAL_ULS_FIRST_NAME ) ) ||
				( NULL == reIsapi.GetString( REGVAL_ULS_LAST_NAME )  ) ||
				( NULL == reIsapi.GetString( REGVAL_ULS_EMAIL_NAME ) )
				);
	}

	inline bool IsRDSDisabled()
	{
        RegEntry rePol( POLICIES_KEY, HKEY_LOCAL_MACHINE );
        return(rePol.GetNumber( REGVAL_POL_NO_RDS, DEFAULT_POL_NO_RDS ) != FALSE);
	}

    inline bool IsRDSDisabledOnWin9x()
    {
        RegEntry rePol( POLICIES_KEY, HKEY_LOCAL_MACHINE );
        return(rePol.GetNumber ( REGVAL_POL_NO_RDS_WIN9X, DEFAULT_POL_NO_RDS_WIN9X ) != FALSE);
    }

	inline bool isWebDirectoryDisabled(void)
	{
        RegEntry	rePol( POLICIES_KEY, HKEY_CURRENT_USER );

        return( rePol.GetNumber( REGVAL_POL_NO_WEBDIR, DEFAULT_POL_NO_WEBDIR ) != FALSE );
	}

    inline bool IsAdvancedCallingAllowed(void)
    {
        RegEntry    rePol( POLICIES_KEY, HKEY_CURRENT_USER );
        return(!rePol.GetNumber( REGVAL_POL_NO_ADVANCEDCALLING, DEFAULT_POL_NO_ADVANCEDCALLING ));
    }

};


#endif // __ConfPolicies_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confroom.cpp ===
// File: confroom.cpp

#include "precomp.h"
#include "resource.h"
#include "ConfPolicies.h"
#include "ConfRoom.h"
#include "ConfWnd.h"
#include "cmd.h"
#include "RoomList.h"
#include "RToolbar.h"
#include "TopWindow.h"
#include "FloatBar.h"
#include "StatBar.h"
#include "DShowDlg.h"
#include "SDialDlg.h"
#include "UPropDlg.h"
#include "PopupMsg.h"
#include "splash.h"
#include <version.h>                    // About Box
#include <pbt.h>
#include <EndSesn.h>

#include "taskbar.h"
#include "conf.h"
#include "MenuUtil.h"
#include "call.h"
#include "ConfApi.h"
#include "NmLdap.h"
#include "VidView.h"

#include "dbgMenu.h"
#include "IndeoPal.h"
#include "setupdd.h"
#include "audiowiz.h"
#include <help_ids.h>
#include "cr.h"
#include "audioctl.h"
#include "particip.h"
#include "confman.h"
#include <nmremote.h>
#include <tsecctrl.h>
#include "t120type.h"
#include "iappldr.h"
#include "nmapp.h"
#include "NmDispid.h"
#include "FtHook.h"
#include "NmManager.h"
#include "dlgacd.h"
#include "richaddr.h"
#include "sdkinternal.h"
#include "dlghost.h"

static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

//
// GLOBAL CONFROOM
//
CConfRoom * g_pConfRoom;

// ********************************************************
// Initialize GUIDs
//
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <CLinkId.h>
#include <CNotifID.h>
#include <confguid.h>
#include <ilsguid.h>
#undef INITGUID
#pragma data_seg()


INmConference2* GetActiveConference(void)
{
	INmConference2* pConf = NULL;

	if(g_pConfRoom)
	{
		pConf = g_pConfRoom->GetActiveConference();
	}

	return pConf;
}


#ifdef DEBUG
DWORD g_fDisplayViewStatus = 0;  // Display the listview count in the status bar
#endif
DWORD g_dwPlaceCall = nmDlgCallNoFilter;  // Place a Call options

INmConference2* CConfRoom::GetActiveConference(void)
{
	if (NULL != m_pInternalNmConference)
	{
		NM_CONFERENCE_STATE state;
		HRESULT hr = m_pInternalNmConference->GetState(&state);
		ASSERT(SUCCEEDED(hr));
		if (NM_CONFERENCE_IDLE != state)
		{
			return m_pInternalNmConference;
		}
	}

	// no active conference
	return NULL;
}

HRESULT CConfRoom::HostConference
(
    LPCTSTR     pcszName,
    LPCTSTR     pcszPassword,
    BOOL        fSecure,
    DWORD       permitFlags,
    UINT        maxParticipants
)
{
	HRESULT hr = E_FAIL;
	USES_CONVERSION;

	INmConference *pConf = GetActiveConference();
	if (NULL == pConf)
	{
        ULONG   uchCaps;

		INmManager2 *pNmMgr = CConfMan::GetNmManager();
		ASSERT(NULL != pNmMgr);

        uchCaps = NMCH_DATA | NMCH_SHARE | NMCH_FT;
        if (fSecure)
        {
            uchCaps |= NMCH_SECURE;
        }
        else
        {
            uchCaps |= NMCH_AUDIO | NMCH_VIDEO;
        }

		hr = pNmMgr->CreateConferenceEx(&pConf, CComBSTR(pcszName), CComBSTR(pcszPassword),
            uchCaps, permitFlags, maxParticipants);
		if (SUCCEEDED(hr))
		{
			hr = pConf->Host();
            pConf->Release();
		}
		pNmMgr->Release();
	}
	return hr;
}

BOOL CConfRoom::LeaveConference(void)
{
	BOOL fSuccess = TRUE;
	INmConference *pConf = GetActiveConference();

	if (NULL != pConf)
	{
		HCURSOR hCurPrev = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
		HRESULT hr = pConf->Leave();
		::SetCursor(hCurPrev);
		fSuccess = SUCCEEDED(hr);
	}

	return fSuccess;
}


/*  F  H A S  C H I L D  N O D E S  */
/*-------------------------------------------------------------------------
    %%Function: FHasChildNodes

    Future: Check if ANY participants have this node as their parent.
-------------------------------------------------------------------------*/
BOOL CConfRoom::FHasChildNodes(void)
{
	return m_fTopProvider;
}


/*  G E T  M A I N  W I N D O W  */
/*-------------------------------------------------------------------------
    %%Function: GetMainWindow
    
-------------------------------------------------------------------------*/
HWND GetMainWindow(void)
{
	CConfRoom* pcr = ::GetConfRoom();
	if (NULL == pcr)
		return NULL;

	return pcr->GetTopHwnd();
}


BOOL FIsConferenceActive(void)
{
	CConfRoom *pcr = ::GetConfRoom();
	if (NULL != pcr)
	{
		return pcr->FIsConferenceActive();
	}
	return FALSE;
}

/****************************************************************************
*
*        FUNCTION: UpdateUI(DWORD dwUIMask)
*
*        PURPOSE:  Updates the UI (flags in cr.h)
*
****************************************************************************/
VOID UpdateUI(DWORD dwUIMask, BOOL fPostMsg)
{
	CConfRoom* pcr;
	if (NULL != (pcr = ::GetConfRoom()))
	{
		if (fPostMsg)
		{
			FORWARD_WM_COMMAND(pcr->GetTopHwnd(), ID_PRIVATE_UPDATE_UI, NULL, dwUIMask, ::PostMessage);
		}
		else
		{
			pcr->UpdateUI(dwUIMask);
		}
	}
	if (CRUI_TASKBARICON & dwUIMask)
	{
		::RefreshTaskbarIcon(::GetHiddenWindow());
	}
}


//
// Start/Stop App Sharing
//
VOID CConfRoom::StartAppSharing()
{
    HRESULT hr;

    ASSERT(!m_pAS);

    hr = CreateASObject(this, 0, &m_pAS);
    if (FAILED(hr))
    {
        ERROR_OUT(("CConfRoom: unable to start App Sharing"));
    }
}


VOID CConfRoom::TerminateAppSharing()
{
    if (m_pAS)
    {
        m_pAS->Release();
        m_pAS = NULL;
    }
}

/****************************************************************************
*
*        FUNCTION: UIEndSession(BOOL fLogoff)
*
*        PURPOSE:  Handles the WM_ENDSESSION at the UI level
*
****************************************************************************/
VOID CConfRoom::UIEndSession(BOOL fLogoff)
{
	DebugEntry(UIEndSession);
	
	CConfRoom* pcr;
	if (NULL != (pcr = ::GetConfRoom()))
	{
		TRACE_OUT(("UIEndSession: calling SaveSettings()"));
		pcr->SaveSettings();
        if (fLogoff)
        {
            pcr->TerminateAppSharing();
        }
	}
	
	DebugExitVOID(UIEndSession);
}


/****************************************************************************
*
*        FUNCTION: ConfRoomInit(HANDLE hInstance)
*
*        PURPOSE: Initializes window data and registers window class
*
****************************************************************************/

BOOL ConfRoomInit(HANDLE hInstance)
{
	// Ensure the common controls are loaded
	INITCOMMONCONTROLSEX icc;
	icc.dwSize = sizeof(icc);
	icc.dwICC = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;
	InitCommonControlsEx(&icc);

	// Fill out the standard window class settings
	WNDCLASSEX  wc;
	ClearStruct(&wc);
	wc.cbSize = sizeof(wc);
	wc.cbWndExtra = (int) sizeof(LPVOID);
	wc.hInstance = _Module.GetModuleInstance();
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hIcon = LoadIcon((HINSTANCE) hInstance, MAKEINTRESOURCE(IDI_CONFROOM));


	// Floating Toolbar
	wc.lpfnWndProc   = (WNDPROC) CFloatToolbar::FloatWndProc;
	wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
	wc.lpszClassName = g_szFloatWndClass;
	RegisterClassEx(&wc);

	// Popup Messages
	wc.lpfnWndProc   = (WNDPROC) CPopupMsg::PMWndProc;
	wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1);
	wc.lpszClassName = g_szPopupMsgWndClass;
	RegisterClassEx(&wc);

	// Make sure no one changed these on us
	ASSERT(wc.cbSize == sizeof(wc));
	ASSERT(wc.style == 0);
	ASSERT(wc.cbClsExtra == 0);
	ASSERT(wc.cbWndExtra == (int) sizeof(LPVOID));
	ASSERT(wc.hInstance == _Module.GetModuleInstance());
	ASSERT(wc.hCursor == LoadCursor(NULL, IDC_ARROW));

	return TRUE;
}


/*  C R E A T E  C O N F  R O O M  W I N D O W  */
/*-------------------------------------------------------------------------
    %%Function: CreateConfRoomWindow
    
-------------------------------------------------------------------------*/
BOOL CreateConfRoomWindow(BOOL fShowUI) 
{
	if (!g_pConfRoom)
	{
        g_pConfRoom = new CConfRoom;

		if (NULL == g_pConfRoom)
		{
			return FALSE;
		}
	}

    if (g_pConfRoom->FIsClosing())
	{
		return FALSE;
	}

	CTopWindow * pWnd = g_pConfRoom->GetTopWindow();
	if (NULL == pWnd)
	{
		g_pConfRoom->Init();
		
		HWND hwnd = g_pConfRoom->Create(fShowUI);

		if (NULL == hwnd)
		{
			return FALSE;
		}
		g_pConfRoom->UpdateUI(CRUI_TITLEBAR);
	}
	else if (fShowUI)
	{
		// Bring the window to the front
		g_pConfRoom->BringToFront();
	}

	return TRUE;
}



/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   CConfRoom()
*
*        PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CConfRoom::CConfRoom():
	m_pTopWindow                            (NULL),
	m_pAudioControl                 (NULL),
	m_cParticipants         (0),
	m_pPartLocal            (NULL),
	m_fTopProvider          (FALSE),
	m_dwConfCookie                  (0),
	m_pInternalNmConference         (NULL),
    m_pAS                           (NULL)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CConfRoom", this);

	if (!SysPol::AllowAddingServers())
	{
		g_dwPlaceCall |= nmDlgCallNoServerEdit;
	}

	StartAppSharing();

    //
    // Initialize meeting settings to good defaults
    //
    m_fGetPermissions       = FALSE;
    m_settings              = NM_PERMIT_ALL;
    m_attendeePermissions   = NM_PERMIT_ALL;
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ~CConfRoom()
*
*        PURPOSE:  Destructor
*
****************************************************************************/

CConfRoom::~CConfRoom()
{
	FreeDbgMenu();

	FreePartList();
	CleanUp();

    // Close the app...
    ::PostThreadMessage(_Module.m_dwThreadID, WM_QUIT, 0, 0);

	if (NULL != m_pTopWindow)
	{
		// Make sure we do not try this multiple times
		CTopWindow *pTopWindow = m_pTopWindow;
		m_pTopWindow = NULL;

		pTopWindow->Release();
	}

	if (!_Module.IsSDKCallerRTC() && m_pAudioControl)
	{
		delete m_pAudioControl;
		m_pAudioControl = NULL;
	}

    g_pConfRoom = NULL;

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CConfRoom", this);
}

VOID CConfRoom::FreePartList(void)
{
	// Free any remaining participants
	while (0 != m_PartList.GetSize())
	{
		ASSERT(m_PartList[0]);
		OnPersonLeft(m_PartList[0]->GetINmMember());
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateUI(DWORD dwUIMask)
*
*        PURPOSE:  Updates the appropriate pieces of the UI
*
****************************************************************************/

VOID CConfRoom::UpdateUI(DWORD dwUIMask)
{
	CTopWindow *pWnd = GetTopWindow();
	if (NULL == pWnd)
	{
		return;
	}

	pWnd->UpdateUI(dwUIMask);
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   Create()
*
*        PURPOSE:  Creates a window
*
****************************************************************************/

HWND CConfRoom::Create(BOOL fShowUI)
{
	ASSERT(NULL == m_pTopWindow);

	m_pTopWindow = new CTopWindow();
	if (NULL == m_pTopWindow)
	{
		return(NULL);
	}

	m_pTopWindow->Create(this, fShowUI);
	return(m_pTopWindow->GetWindow());
}

VOID CConfRoom::CleanUp()
{
	if (NULL != m_pInternalNmConference)
	{
		NmUnadvise(m_pInternalNmConference, IID_INmConferenceNotify2, m_dwConfCookie);
		m_pInternalNmConference->Release();
		m_pInternalNmConference = NULL;
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   SaveSettings()
*
*        PURPOSE:  Saves UI settings in the registry
*
****************************************************************************/

VOID CConfRoom::SaveSettings()
{
	DebugEntry(CConfRoom::SaveSettings);
	RegEntry reConf(UI_KEY, HKEY_CURRENT_USER);

	if (NULL != m_pTopWindow)
	{
		m_pTopWindow->SaveSettings();
	}

	// Save window elements to the registry:
	reConf.SetValue(REGVAL_SHOW_STATUSBAR, CheckMenu_ViewStatusBar(NULL));

	// NOTE: CMainUI saves its settings in its destructor
	
	DebugExitVOID(CConfRoom::SaveSettings);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   BringToFront()
*
*        PURPOSE:  Restores the window (if minimized) and brings it to the front
*
****************************************************************************/

BOOL CConfRoom::BringToFront()
{
	CTopWindow *pWnd = GetTopWindow();
	if (NULL == pWnd)
	{
		return(FALSE);
	}

	return(pWnd->BringToFront());
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ForceWindowResize()
*
*        PURPOSE:  Handles redrawing the window after something changed
*
****************************************************************************/

VOID CConfRoom::ForceWindowResize()
{
	CTopWindow *pWnd = GetTopWindow();
	if (NULL == pWnd)
	{
		return;
	}

	pWnd->ForceWindowResize();
}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnCommand(WPARAM, LPARAM)
*
*        PURPOSE:  Handles command messages
*
****************************************************************************/

void CConfRoom::OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify)
{
	switch(wCommand)
	{
		case IDM_FILE_HANGUP:
		{
			OnHangup(hwnd);
			break;
		}

        case ID_TB_SHARING:
        {
            CmdShowSharing();
            break;
        }

		case ID_TB_NEWWHITEBOARD:
		{
			CmdShowNewWhiteboard(NULL);
			break;
		}

		case ID_TB_WHITEBOARD:
		{
			CmdShowOldWhiteboard(NULL);
			break;
		}

		case ID_TB_FILETRANSFER:
		{
		    CmdShowFileTransfer();
            break;
		}

		case ID_TB_CHAT:
		{
			CmdShowChat();
			break;
		}

		case ID_TB_NEW_CALL:
		{
			CDlgAcd::newCall( hwnd, this );
		}
		break;

        case IDM_CALL_MEETINGSETTINGS:
        {
            CmdShowMeetingSettings(hwnd);
            break;
        }
	}          
}


HRESULT CConfRoom::FreeAddress( 
    RichAddressInfo **ppAddr)
{
	return CEnumMRU::FreeAddress(ppAddr);
}


HRESULT CConfRoom::CopyAddress( 
    RichAddressInfo *pAddrIn,
    RichAddressInfo **ppAddrOut)
{
	return CEnumMRU::CopyAddress(pAddrIn, ppAddrOut);
}


HRESULT CConfRoom::GetRecentAddresses( 
    IEnumRichAddressInfo **ppEnum)
{
	return CEnumMRU::GetRecentAddresses(ppEnum);
}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnCallStarted()
*
*        PURPOSE:  Handles the call started event
*
****************************************************************************/

VOID CConfRoom::OnCallStarted()
{
	DebugEntry(CConfRoom::OnCallStarted);
	// notify ULS

	if(g_pLDAP)
	{
		g_pLDAP->OnCallStarted();
	}

	g_pHiddenWnd->OnCallStarted();

	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnCallStarted();
	}

	DebugExitVOID(CConfRoom::OnCallStarted);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnCallEnded()
*
*        PURPOSE:  Handles the call ended event
*
****************************************************************************/

VOID CConfRoom::OnCallEnded()
{
	DebugEntry(CConfRoom::OnCallEnded);

	if(g_pLDAP)
	{
		g_pLDAP->OnCallEnded();
	}

	g_pHiddenWnd->OnCallEnded();

	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnCallEnded();
	}

	DebugExitVOID(CConfRoom::OnCallEnded);
}

void CConfRoom::OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify)
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnChangeParticipant(pPart, uNotify);
	}
}

void CConfRoom::OnChangePermissions()
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnChangePermissions();
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnHangup(BOOL fNeedConfirm)
*
*        PURPOSE:  Handles the action after a user chooses to hang up
*
****************************************************************************/

BOOL CConfRoom::OnHangup(HWND hwndParent, BOOL fNeedConfirm)
{
	DebugEntry(CConfRoom::OnHangup);
	
	BOOL bRet = FALSE;

	CancelAllCalls();

	if (FIsConferenceActive())
	{
		if (T120_NO_ERROR == T120_QueryApplet(APPLET_ID_FT, APPLET_QUERY_SHUTDOWN))
		{
			if ((FALSE == fNeedConfirm) ||
				(	((GetMemberCount() <= 2) ||
					(FALSE == FHasChildNodes()))) ||
				(IDYES == ::ConfMsgBox( hwndParent, 
										(LPCTSTR) IDS_HANGUP_ATTEMPT, 
										MB_YESNO | MB_ICONQUESTION)))
			{
				// BUGBUG: Should we wait for the async response?
				bRet = (0 == LeaveConference());
			}
		}
	}

	DebugExitBOOL(CConfRoom::OnHangup, bRet);

	return bRet;
}

/*  C H E C K  T O P  P R O V I D E R  */
/*-------------------------------------------------------------------------
    %%Function: CheckTopProvider
    
-------------------------------------------------------------------------*/
VOID CConfRoom::CheckTopProvider(void)
{
	if ((NULL == m_pInternalNmConference) || (NULL == m_pPartLocal))
		return;

	INmMember * pMember;
	if (S_OK != m_pInternalNmConference->GetTopProvider(&pMember))
		return;
	ASSERT(NULL != pMember);

	if (m_pPartLocal->GetINmMember() == pMember)
	{
		m_fTopProvider      = TRUE;
	}

    if (m_fGetPermissions)
    {
        ASSERT(m_settings            == NM_PERMIT_ALL);
        ASSERT(m_attendeePermissions == NM_PERMIT_ALL);

        m_fGetPermissions = FALSE;

        //
        // Get the meeting settings from the top provider
        //
        PBYTE pb = NULL;
        ULONG cb = 0;

        if (pMember->GetUserData(g_csguidMeetingSettings, &pb, &cb) == S_OK)
        {
            ASSERT(cb == sizeof(NM30_MTG_PERMISSIONS));
            CopyMemory(&m_settings, pb, min(cb, sizeof(m_settings)));

            CoTaskMemFree(pb);

            WARNING_OUT(("CONF:  Meeting host set permissions 0%08lx",
                m_settings));

            if (!m_fTopProvider)
            {
                //
                // The meeting settings are permissions for everybody else
                // besides the top provider.
                //
                m_attendeePermissions = m_settings;

                if (m_attendeePermissions != NM_PERMIT_ALL)
                {
        			OnChangePermissions();

                    // Bring up meeting settings
                    PostMessage(GetTopHwnd(), WM_COMMAND, IDM_CALL_MEETINGSETTINGS, 0);
                }

            }

        }
    }

}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnPersonJoined(PPARTICIPANT pPart)
*
*        PURPOSE:  Notification - new person has joined the call
*
****************************************************************************/

BOOL CConfRoom::OnPersonJoined(INmMember * pMember)
{
	CParticipant * pPart = new CParticipant(pMember);
	if (NULL == pPart)
	{
		WARNING_OUT(("CConfRoom::OnPersonJoined - Unable to create participant"));
		return FALSE;
	}
	m_PartList.Add(pPart);
	++m_cParticipants;
	if (1 == m_cParticipants)
	{
		OnCallStarted();
	}
	TRACE_OUT(("CConfRoom::OnPersonJoined - Added participant=%08X", pPart));

	OnChangeParticipant(pPart, NM_MEMBER_ADDED);

	// Popup a notification (if it isn't us)
	if (!pPart->FLocal())
	{
        TCHAR szSound[256];

        //
        // Play the "somebody joined" sound
        //
        ::LoadString(::GetInstanceHandle(), IDS_PERSON_JOINED_SOUND,
            szSound, CCHMAX(szSound));
        if (!::PlaySound(szSound, NULL, 
			SND_APPLICATION | SND_ALIAS | SND_ASYNC | SND_NOWAIT))
    	{
	    	// Use the computer speaker to beep:
		    TRACE_OUT(("PlaySound() failed, trying MessageBeep()"));
    		::MessageBeep(0xFFFFFFFF);
	    }
	}
	else
	{
		m_pPartLocal = pPart;
		CheckTopProvider();
	}

	// Title bar shows number of people in conference
	UpdateUI(CRUI_TITLEBAR);

	return TRUE;
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnPersonLeft(PPARTICIPANT pPart)
*
*        PURPOSE:  Notification - person has left the call
*
****************************************************************************/

BOOL CConfRoom::OnPersonLeft(INmMember * pMember)
{
	// Find the macthing participant
	CParticipant* pPart = NULL;

	for( int i = 0; i < m_PartList.GetSize(); i++ )
	{
		pPart = m_PartList[i];
		ASSERT(pPart);
		if( pPart->GetINmMember() == pMember )
		{	
			m_PartList.RemoveAt(i);
			--m_cParticipants;
			if (0 == m_cParticipants)
			{
				OnCallEnded();
			}
			break;
		}
	}

	if (NULL == pPart)
	{
		WARNING_OUT(("Unable to find participant for INmMember=%08X", pMember));
		return FALSE;
	}

	OnChangeParticipant(pPart, NM_MEMBER_REMOVED);

	// Popup a notification (if it isn't us)
	if (!pPart->FLocal())
	{
        TCHAR szSound[256];

        //
        // Play the "somebody left" sound
        //
        ::LoadString(::GetInstanceHandle(), IDS_PERSON_LEFT_SOUND,
            szSound, CCHMAX(szSound));
	    if (!::PlaySound(szSound, NULL, 
			SND_APPLICATION | SND_ALIAS | SND_ASYNC | SND_NOWAIT))
    	{
	    	// Use the computer speaker to beep:
		    TRACE_OUT(("PlaySound() failed, trying MessageBeep()"));
    		::MessageBeep(0xFFFFFFFF);
	    }
	}
	else
	{
		m_pPartLocal = NULL;
		m_fTopProvider = FALSE;
	}

	// Title bar shows number of people in conference
	UpdateUI(CRUI_TITLEBAR);

	// Finally, release the object
	TRACE_OUT(("CConfRoom::OnPersonLeft - Removed participant=%08X", pPart));
	pPart->Release();
	return TRUE;
}


/*  O N  P E R S O N  C H A N G E D  */
/*-------------------------------------------------------------------------
    %%Function: OnPersonChanged
    
	Notification - a person's information has changed
-------------------------------------------------------------------------*/
VOID CConfRoom::OnPersonChanged(INmMember * pMember)
{
	DBGENTRY(CConfRoom::OnPersonChanged);

	CParticipant * pPart = ParticipantFromINmMember(pMember);
	if (NULL == pPart)
		return;

	pPart->AddRef();
	pPart->Update();
	if (m_fTopProvider && !pPart->FData())
	{
		// Can't be the top provider if there are no data caps
		m_fTopProvider = FALSE;
	}

	if (pPart->FLocal() && !m_fTopProvider)
	{
		// if H.323-only adds T.120, then we may be the top provider
		CheckTopProvider();
	}
	
	OnChangeParticipant(pPart, NM_MEMBER_UPDATED);

	pPart->Release();
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   Init()
*
*        PURPOSE:  Object initialization function
*
****************************************************************************/

BOOL CConfRoom::Init()
{
	if (!_Module.IsSDKCallerRTC())
	{
        	m_pAudioControl = new CAudioControl(GetHiddenWindow());
	}
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->RegisterAudioEventHandler(this);
	}


	return (TRUE);
}



VOID CConfRoom::SetSpeakerVolume(DWORD dwLevel)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->SetSpeakerVolume(dwLevel);
		m_pAudioControl->RefreshMixer();
	}
}

VOID CConfRoom::SetRecorderVolume(DWORD dwLevel)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->SetRecorderVolume(dwLevel);
		m_pAudioControl->RefreshMixer();
	}
}

VOID CConfRoom::MuteSpeaker(BOOL fMute)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->MuteAudio(TRUE /* fSpeaker */, fMute);
	}
}

VOID CConfRoom::MuteMicrophone(BOOL fMute)
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->MuteAudio(FALSE /* fSpeaker */, fMute);
	}
}

VOID CConfRoom::OnAudioDeviceChanged()
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->OnDeviceChanged();
	}
}

VOID CConfRoom::OnAGC_Changed()
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->OnAGC_Changed();
	}
}

VOID CConfRoom::OnSilenceLevelChanged()
{
	if (NULL != m_pAudioControl)
	{
		m_pAudioControl->OnSilenceLevelChanged();
	}
}



DWORD CConfRoom::GetConferenceStatus(LPTSTR pszStatus, int cchMax, UINT * puID)
{
	ASSERT(NULL != pszStatus);
	ASSERT(NULL != puID);
	ASSERT(cchMax > 0);

	// Check global conference status
	if ( INmConference *pConf = GetActiveConference() )
	{
		// We are in a call.  Find out if it's secure.
		DWORD dwCaps;
		if ( S_OK == pConf->GetNmchCaps(&dwCaps) &&
			( NMCH_SECURE & dwCaps ) )
		{
			*puID = IDS_STATUS_IN_SECURE_CALL;
		}
		else
		{
			*puID = IDS_STATUS_IN_CALL;
		}
	}
	else if (::FDoNotDisturb())
	{
		*puID = IDS_STATUS_DO_NOT_DISTURB;
	}
	else
	{
		*puID = IDS_STATUS_NOT_IN_CALL;
	}
	
#if FALSE
	// We may need to find a new way of doing this if this is still useful info
#ifdef DEBUG
	if (g_fDisplayViewStatus)
	{
		int iCount = (NULL == m_pView) ? LB_ERR :
				ListView_GetItemCount(m_pView->GetHwnd());

		wsprintf(pszStatus, TEXT("%d items"), iCount);
		ASSERT(lstrlen(pszStatus) < cchMax);
	}
	else
#endif /* DEBUG */
#endif // FALSE

	if (0 == ::LoadString(::GetInstanceHandle(), *puID, pszStatus, cchMax))
	{
		WARNING_OUT(("Unable to load string resource=%d", *puID));
		*pszStatus = _T('\0');
	}
	return 0;
}



/*  P A R T I C I P A N T  F R O M  I  N M  M E M B E R  */
/*-------------------------------------------------------------------------
    %%Function: ParticipantFromINmMember
    
-------------------------------------------------------------------------*/
CParticipant * CConfRoom::ParticipantFromINmMember(INmMember * pMember)
{
	CParticipant *pRet = NULL;
	for( int i = 0; i < m_PartList.GetSize(); i++ )
	{
		ASSERT( m_PartList[i] );
		if( m_PartList[i]->GetINmMember() == pMember )
		{
			pRet = m_PartList[i];
			break;
		}
		else
		{
			pRet = NULL;
		}
	}
	return pRet;
}

/*  G E T  H 3 2 3  R E M O T E  */
/*-------------------------------------------------------------------------
    %%Function: GetH323Remote
    
    Get the matching H.323 remote user, if there is one
-------------------------------------------------------------------------*/
CParticipant * CConfRoom::GetH323Remote(void)
{
	CParticipant *pRet = NULL;
	for( int i = 0; i < m_PartList.GetSize(); i++ )
	{
		pRet = m_PartList[i];
		ASSERT( pRet );
		if (!pRet->FLocal() && pRet->FH323())
		{
			break;
		}
		else
		{
			pRet = NULL;
		}
	}
	return pRet;
}


STDMETHODIMP_(ULONG) CConfRoom::AddRef(void)
{
	return RefCount::AddRef();
}

STDMETHODIMP_(ULONG) CConfRoom::Release(void)
{
	return RefCount::Release();
}

STDMETHODIMP CConfRoom::QueryInterface(REFIID riid, PVOID *ppv)
{
	HRESULT hr = S_OK;

	if ((riid == IID_INmConferenceNotify) || (riid == IID_INmConferenceNotify2) ||
		(riid == IID_IUnknown))
	{
		*ppv = (INmConferenceNotify2 *)this;
		ApiDebugMsg(("CConfRoom::QueryInterface()"));
	}
	else
	{
		hr = E_NOINTERFACE;
		*ppv = NULL;
		ApiDebugMsg(("CConfRoom::QueryInterface(): Called on unknown interface."));
	}

	if (S_OK == hr)
	{
		AddRef();
	}

	return hr;
}

STDMETHODIMP CConfRoom::NmUI(CONFN uNotify)
{
	return S_OK;
}


STDMETHODIMP CConfRoom::OnConferenceCreated(INmConference *pConference)
{
	HRESULT hr = S_OK;
	DBGENTRY(CConfRoom::OnConferenceCreated);

	if (NULL != m_pInternalNmConference)
	{
		NmUnadvise(m_pInternalNmConference, IID_INmConferenceNotify2, m_dwConfCookie);
		m_pInternalNmConference->Release();
	}

	pConference->QueryInterface(IID_INmConference2, (void**)&m_pInternalNmConference);
	NmAdvise(m_pInternalNmConference, (INmConferenceNotify2*)this, IID_INmConferenceNotify2, &m_dwConfCookie);

	DBGEXIT_HR(CConfRoom::OnConferenceCreated,hr);
	return hr;
}


STDMETHODIMP CConfRoom::StateChanged(NM_CONFERENCE_STATE uState)
{
	static BOOL s_fInConference = FALSE;

	UpdateUI(CRUI_DEFAULT);

	switch (uState)
		{
	case NM_CONFERENCE_IDLE:
	{
		if (s_fInConference)
		{
			CNetMeetingObj::Broadcast_ConferenceEnded();
			s_fInConference = FALSE;

            //
            // Reset meeting settings
            //
            m_fGetPermissions                       = FALSE;
            m_settings                              = NM_PERMIT_ALL;
            m_attendeePermissions                   = NM_PERMIT_ALL;

			OnChangePermissions();

            //
            // If the call ends, kill the host properties if they are up.
            //
            CDlgHostSettings::KillHostSettings();
		}
		UpdateUI(CRUI_STATUSBAR);
		break;
	}

	case NM_CONFERENCE_INITIALIZING:
		break;
	case NM_CONFERENCE_WAITING:
	case NM_CONFERENCE_ACTIVE:
	default:
	{
		if (!s_fInConference)
		{
				// Start a new conference session
			CFt::StartNewConferenceSession();

			CNetMeetingObj::Broadcast_ConferenceStarted();

			s_fInConference     = TRUE;
            m_fGetPermissions   = TRUE;
		}
		break;
	}
		}


	return S_OK;
}

STDMETHODIMP CConfRoom::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	switch (uNotify)
	{
	case NM_MEMBER_ADDED:
		OnPersonJoined(pMember);
		break;
	case NM_MEMBER_REMOVED:
		OnPersonLeft(pMember);
		break;
	case NM_MEMBER_UPDATED:
		OnPersonChanged(pMember);
		break;
	}
	return S_OK;
}

STDMETHODIMP CConfRoom::ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	ULONG nmch;


	if (SUCCEEDED(pChannel->GetNmch(&nmch)))
	{
		TRACE_OUT(("CConfRoom:ChannelChanged type=%08X", nmch));
		switch (nmch)
		{
		case NMCH_AUDIO:
			if (NULL != m_pAudioControl)
			{
				m_pAudioControl->OnChannelChanged(uNotify, pChannel);

						// Notify the Manager object of the audio channels active state
				CNmManagerObj::AudioChannelActiveState(S_OK == pChannel->IsActive(), S_OK == com_cast<INmChannelAudio>(pChannel)->IsIncoming());
			}

			break;
		case NMCH_VIDEO:
		{
			EnterCriticalSection(&dialogListCriticalSection);
			CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
			LeaveCriticalSection(&dialogListCriticalSection);

			// BUGBUG georgep: I guess one of these things could go away after
			// we get the list, but I doubt it will ever happen
			for( int i = 0; i < tempList.GetSize(); ++i )
			{
				IConferenceChangeHandler *pHandler = tempList[i];
				ASSERT( NULL != pHandler );

				pHandler->OnVideoChannelChanged(uNotify, pChannel);
			}
			break;
		}
		default:
			break;
		}
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CConfRoom::StreamEvent( 
            /* [in] */ NM_STREAMEVENT uEvent,
            /* [in] */ UINT uSubCode,
            /* [in] */ INmChannel __RPC_FAR *pChannel)
{
	return S_OK;
}


/*  C M D  S H O W  C H A T  */
/*-------------------------------------------------------------------------
	%%Function: CmdShowChat
    
-------------------------------------------------------------------------*/
VOID CmdShowChat(void)
{
	T120_LoadApplet(APPLET_ID_CHAT, TRUE , 0, FALSE, NULL);
}


//
// CmdShowFileTransfer()
//
void CConfRoom::CmdShowFileTransfer(void)
{
    ::T120_LoadApplet(APPLET_ID_FT, TRUE, 0, FALSE, NULL);
}


//
// CmdShowSharing()
//
void CConfRoom::CmdShowSharing()
{
    LaunchHostUI();
}


/*  C M D  S H O W  N E W W H I T E B O A R D  */
/*-------------------------------------------------------------------------
	%%Function: CmdShowNewWhiteboard
    
-------------------------------------------------------------------------*/
BOOL CmdShowNewWhiteboard(LPCTSTR szFile)
{
	return ::T120_LoadApplet(APPLET_ID_WB, TRUE , 0, FALSE, (LPSTR)szFile);
	
}


/*  C M D  S H O W  W H I T E B O A R D  */
/*-------------------------------------------------------------------------
    %%Function: CmdShowOldWhiteboard
    
-------------------------------------------------------------------------*/
extern "C" { BOOL WINAPI StartStopOldWB(LPCTSTR lpsz); }

BOOL CmdShowOldWhiteboard(LPCTSTR szFile)
{
    return(StartStopOldWB(szFile));
}


//
// CmdShowMeetingSettings()
//
void CConfRoom::CmdShowMeetingSettings(HWND hwnd)
{
    INmConference2 * pConf;

    pConf = GetActiveConference();
    if (pConf)
    {
        DWORD   caps;
        HRESULT hr;
        BSTR    bstrName;
        LPTSTR  pszName = NULL;

        caps = 0;
        pConf->GetNmchCaps(&caps);

        bstrName = NULL;
        hr = pConf->GetName(&bstrName);
        if (SUCCEEDED(hr))
        {
            BSTR_to_LPTSTR(&pszName, bstrName);
            SysFreeString(bstrName);
        }

        CDlgHostSettings dlgSettings(FTopProvider(), pszName, caps, m_settings);
        dlgSettings.DoModal(hwnd);

        delete pszName;
    }
}



///////////////////////////////////////////////////////////////////////////

/*  F  T O P  P R O V I D E R  */
/*-------------------------------------------------------------------------
    %%Function: FTopProvider
    
-------------------------------------------------------------------------*/
BOOL FTopProvider(void)
{
	CConfRoom * pConfRoom = ::GetConfRoom();
	if (NULL == pConfRoom)
		return FALSE;

	return pConfRoom->FTopProvider();
}


BOOL FRejectIncomingCalls(void)
{
	BOOL bReject = TRUE;
	
	if (!FDoNotDisturb())
	{
		CConfRoom * pConfRoom = ::GetConfRoom();

		if( ( NULL == pConfRoom ) ||
            ((pConfRoom->GetMeetingPermissions() & NM_PERMIT_INCOMINGCALLS) &&
                !pConfRoom->FIsClosing()))
		{

			bReject = FALSE;
		}
	}
	
	return bReject;
}

BOOL CConfRoom::FIsClosing()
{
	return(NULL == m_pTopWindow ? FALSE : m_pTopWindow->FIsClosing());
}

BOOL FIsConfRoomClosing(void)
{
	CConfRoom * pConfRoom = ::GetConfRoom();
	if (NULL == pConfRoom)
		return FALSE;

	return pConfRoom->FIsClosing();
}


/*static*/ HRESULT CConfRoom::HangUp(BOOL bUserPrompt)
{
	DBGENTRY(CConfRoom::HangUp);
	HRESULT hr = S_OK;

	if(g_pConfRoom)
	{
		g_pConfRoom->OnHangup(g_pConfRoom->GetTopHwnd(), bUserPrompt);
	}

	DBGEXIT_HR(CConfRoom::HangUp,hr);
	return hr;
}

BOOL AllowingControl()
{
	BOOL bRet = FALSE;
	if(g_pConfRoom)
	{
        bRet = g_pConfRoom->FIsControllable();
	}
	return bRet;
}

HRESULT AllowControl(bool bAllowControl)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		hr = g_pConfRoom->AllowControl(bAllowControl);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}


bool IsSpeakerMuted()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->IsSpkMuted() ? true : false;
	}

	return true;
}


bool IsMicMuted()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->IsRecMuted() ? true : false;
	}

	return true;
}


CVideoWindow*	GetLocalVideo()
{
	if(g_pConfRoom && g_pConfRoom->m_pTopWindow)
	{
		return g_pConfRoom->m_pTopWindow->GetLocalVideo();
	}

	return NULL;
}


CVideoWindow*	GetRemoteVideo()
{
	if(g_pConfRoom && g_pConfRoom->m_pTopWindow)
	{
		return g_pConfRoom->m_pTopWindow->GetRemoteVideo();
	}

	return NULL;
}


HRESULT SetCameraDialog(ULONG ul)
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->SetCameraDialog(ul);
	}

	return E_FAIL;
}

HRESULT GetCameraDialog(ULONG* pul)
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->GetCameraDialog(pul);
	}

	return E_FAIL;
}


HRESULT GetImageQuality(ULONG* pul, BOOL bIncoming)
{
	if(bIncoming)
	{
		if(GetRemoteVideo())
		{
			*pul = GetRemoteVideo()->GetImageQuality();
			return S_OK;
		}
	}
	else
	{
		if(GetLocalVideo())
		{
			*pul = GetLocalVideo()->GetImageQuality();
			return S_OK;
		}
	}
	return E_FAIL;
}

HRESULT SetImageQuality(ULONG ul, BOOL bIncoming)
{
	if(bIncoming)
	{
		if(GetRemoteVideo())
		{
			return GetRemoteVideo()->SetImageQuality(ul);
		}
	}
	else
	{
		if(GetLocalVideo())
		{
			return GetLocalVideo()->SetImageQuality(ul);
		}
	}

	return E_FAIL;
}



BOOL IsLocalVideoPaused()
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->IsPaused();
	}

	return true;
}


BOOL IsRemoteVideoPaused()
{
	if(GetRemoteVideo())
	{
		return GetRemoteVideo()->IsPaused();
	}

	return true;
}

void PauseLocalVideo(BOOL fPause)
{
	if(GetLocalVideo())
	{
		GetLocalVideo()->Pause(fPause);
	}
}

void PauseRemoteVideo(BOOL fPause)
{
	if(GetRemoteVideo())
	{
		GetRemoteVideo()->Pause(fPause);
	}
}

HRESULT GetRemoteVideoState(NM_VIDEO_STATE *puState)
{
	if(GetRemoteVideo())
	{
		return GetRemoteVideo()->GetVideoState(puState);
	}

	return E_FAIL;
}

HRESULT GetLocalVideoState(NM_VIDEO_STATE *puState)
{
	if(GetLocalVideo())
	{
		return GetLocalVideo()->GetVideoState(puState);
	}

	return E_FAIL;
}

void MuteSpeaker(BOOL fMute)
{
	if(g_pConfRoom)
	{
		g_pConfRoom->MuteSpeaker(fMute);
	}
}

void MuteMicrophone(BOOL fMute)
{
	if(g_pConfRoom)
	{
		g_pConfRoom->MuteMicrophone(fMute);
	}
}


DWORD GetRecorderVolume()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->GetRecorderVolume();
	}

	return 0;
}

DWORD GetSpeakerVolume()
{
	if(g_pConfRoom && g_pConfRoom->m_pAudioControl) 
	{
		return g_pConfRoom->m_pAudioControl->GetSpeakerVolume();
	}

	return 0;
}

void SetRecorderVolume(DWORD dw)
{
	if(g_pConfRoom) 
	{
		g_pConfRoom->SetRecorderVolume(dw);
	}
}


void SetSpeakerVolume(DWORD dw)
{
	if(g_pConfRoom) 
	{
		g_pConfRoom->SetSpeakerVolume(dw);
	}
}

HRESULT RevokeControl(UINT gccID)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		hr = g_pConfRoom->RevokeControl(gccID);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

HRESULT GetShareableApps(IAS_HWND_ARRAY** ppList)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		hr = g_pConfRoom->GetShareableApps(ppList);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

HRESULT FreeShareableApps(IAS_HWND_ARRAY * pList)
{
	HRESULT hr = S_OK;
	
	if(g_pConfRoom)
	{
		g_pConfRoom->FreeShareableApps(pList);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

HRESULT ShareWindow(HWND hWnd)
{
	HRESULT hr = E_UNEXPECTED;
	
	if(g_pConfRoom)
	{
		if(g_pConfRoom->GetAppSharing())
		{
			hr = g_pConfRoom->CmdShare(hWnd);
		}
	}

	return hr;
}

HRESULT UnShareWindow(HWND hWnd)
{
	HRESULT hr = E_UNEXPECTED;
	
	if(g_pConfRoom)
	{
		if(g_pConfRoom->GetAppSharing())
		{
			hr = g_pConfRoom->CmdUnshare(hWnd);
		}
	}

	return hr;
}


HRESULT GetWindowState(NM_SHAPP_STATE* pState, HWND hWnd)
{
	HRESULT hr = E_FAIL;
		// We don't do error checking, the caller must check for valid ptr.
	ASSERT(pState);

	if(g_pConfRoom)
	{
		IAppSharing* pAS = g_pConfRoom->GetAppSharing();

		if(pAS)
		{
            if (pAS->IsWindowShared(hWnd))
                *pState = NM_SHAPP_SHARED;
            else
                *pState = NM_SHAPP_NOT_SHARED;
            hr = S_OK;
		}
	}

	return hr;
}

CVideoWindow* CConfRoom::GetLocalVideo()
{
	CTopWindow *pMainUI = GetTopWindow();
	return (pMainUI ? pMainUI->GetLocalVideo() : NULL);
}

CVideoWindow* CConfRoom::GetRemoteVideo()
{
	CTopWindow *pMainUI = GetTopWindow();
	return (pMainUI ? pMainUI->GetRemoteVideo() : NULL);
}

VOID CConfRoom::AddConferenceChangeHandler(IConferenceChangeHandler *pch)
{
	EnterCriticalSection(&dialogListCriticalSection);
	m_CallHandlerList.Add(pch);
	LeaveCriticalSection(&dialogListCriticalSection);
}

VOID CConfRoom::RemoveConferenceChangeHandler(IConferenceChangeHandler *pch)
{
	EnterCriticalSection(&dialogListCriticalSection);
	m_CallHandlerList.Remove(pch);
	LeaveCriticalSection(&dialogListCriticalSection);
}

void CConfRoom::OnLevelChange(BOOL fSpeaker, DWORD dwVolume)
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnAudioLevelChange(fSpeaker, dwVolume);
	}
}

void CConfRoom::OnMuteChange(BOOL fSpeaker, BOOL fMute)
{
	EnterCriticalSection(&dialogListCriticalSection);
	CCopyableArray<IConferenceChangeHandler*> tempList = m_CallHandlerList;
	LeaveCriticalSection(&dialogListCriticalSection);

	// BUGBUG georgep: I guess one of these things could go away after
	// we get the list, but I doubt it will ever happen
	for( int i = 0; i < tempList.GetSize(); ++i )
	{
		IConferenceChangeHandler *pHandler = tempList[i];
		ASSERT( NULL != pHandler );

		pHandler->OnAudioMuteChange(fSpeaker, fMute);
	}
}

BOOL CConfRoom::CanCloseChat(HWND hwndMain)
{
	BOOL fClosing = TRUE;

	if(GCC_APPLET_CANCEL_EXIT == T120_CloseApplet(APPLET_ID_CHAT, TRUE, TRUE, 1000))
	{
		fClosing = FALSE;
	}

	return(fClosing);
}

// Check to see if WB can close
BOOL CConfRoom::CanCloseWhiteboard(HWND hwndMain)
{
	BOOL fClosing = TRUE;

	if(GCC_APPLET_CANCEL_EXIT == T120_CloseApplet(APPLET_ID_WB, TRUE, TRUE, 1000))
	{
		fClosing = FALSE;
	}

	return(fClosing);
}

// Check to see if WB can close
BOOL CConfRoom::CanCloseFileTransfer(HWND hwndMain)
{
	BOOL fClosing = TRUE;

	if(GCC_APPLET_CANCEL_EXIT == T120_CloseApplet(APPLET_ID_FT, TRUE, TRUE, 1000))
	{
		fClosing = FALSE;
	}

	return(fClosing);
}


void CConfRoom::ToggleLdapLogon()
{
	if(NULL == g_pLDAP)
	{
		InitNmLdapAndLogon();
	}
	else 
	{
		if(g_pLDAP->IsLoggedOn() || g_pLDAP->IsBusy())
		{
			g_pLDAP->Logoff();
		}
		else
		{
			g_pLDAP->LogonAsync();
		}
	}
}


HWND CConfRoom::GetTopHwnd()
{
	CTopWindow *pTopWindow = GetTopWindow();
	return(NULL==pTopWindow ? NULL : pTopWindow->GetWindow());
}

HPALETTE CConfRoom::GetPalette()
{
	return(CGenWindow::GetStandardPalette());
}

DWORD CConfRoom::GetCallFlags()
{
	DWORD dwFlags = g_dwPlaceCall;

	INmConference *pConf = GetActiveConference();
                             
    //
    // If we have an active conference, use its security caps.  And they
    // can not be altered by anyone.
    //
	if ( NULL != pConf  )
	{
    	ULONG ulchCaps;

		if ( S_OK == pConf->GetNmchCaps(&ulchCaps))
		{
			if ( NMCH_SECURE & ulchCaps )
			{
				dwFlags |= nmDlgCallSecurityOn;
			}
		}
	}
	else if (NULL != g_pNmSysInfo)
	{
        switch (ConfPolicies::GetSecurityLevel())
        {
            case DISABLED_POL_SECURITY:
                //
                // Security off, and user can't change checkbox
                //
                break;

            case REQUIRED_POL_SECURITY:
                //
                // Security on, and user can't change checkbox
                //
                dwFlags |= nmDlgCallSecurityOn;
                break;

            default:
                //
                // User can change it.
                dwFlags |= nmDlgCallSecurityAlterable;

                //
                // Default depends on OUTGOING_PREFFERED
                //
                if (ConfPolicies::OutgoingSecurityPreferred())
                {
                    dwFlags |= nmDlgCallSecurityOn;
                }
                break;
        }
	}

	return(dwFlags);
}

BOOL CConfRoom::IsSharingAllowed()
{
    //
    // No app sharing, no RDS.
    //
    if (!FIsSharingAvailable())
    {
        return(FALSE);
    }
    else if (!(GetMeetingPermissions() & NM_PERMIT_SHARE))
    {
        return(FALSE);
    }

	return(TRUE);
}

BOOL CConfRoom::IsNewWhiteboardAllowed()
{
    if (ConfPolicies::IsNewWhiteboardEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_STARTWB)
        {
            return(TRUE);
        }
	}
	return(FALSE);
}

BOOL CConfRoom::IsOldWhiteboardAllowed()
{
    if (ConfPolicies::IsOldWhiteboardEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_STARTOLDWB)
        {
            return(TRUE);
        }
    }
	return(FALSE);
}

BOOL CConfRoom::IsChatAllowed()
{
    if (ConfPolicies::IsChatEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_STARTCHAT)
        {
            return(TRUE);
        }
    }
	return(FALSE);
}

BOOL CConfRoom::IsFileTransferAllowed()
{
    if (ConfPolicies::IsFileTransferEnabled())
    {
        if (GetMeetingPermissions() & NM_PERMIT_SENDFILES)
        {
            return(TRUE);
        }
    }
	return(FALSE);
}


BOOL CConfRoom::IsNewCallAllowed()
{
    if (GetMeetingPermissions() & NM_PERMIT_OUTGOINGCALLS)
    {
        return(TRUE);
    }
    return(FALSE);
}


//--------------------------------------------------------------------------//
//	CConfRoom::get_securitySettings.										//
//--------------------------------------------------------------------------//
void
CConfRoom::get_securitySettings
(
	bool &	userAlterable,
	bool &	secure
){
	INmConference *	activeConference	= (g_pConfRoom != NULL)? g_pConfRoom->GetActiveConference(): NULL;

	if( activeConference != NULL )
	{
		ULONG	conferenceCaps;

		if( activeConference->GetNmchCaps( &conferenceCaps ) == S_OK )
		{
			secure = ((conferenceCaps & NMCH_SECURE) != 0);
		}
		else
		{
			ERROR_OUT( ("Bad conference") );

			secure = false;		//	Is there really a reasonable default???
		}

		userAlterable = false;
	}
	else
	{
        switch( ConfPolicies::GetSecurityLevel() )
        {
            case DISABLED_POL_SECURITY:
			{
				secure			= false;
				userAlterable	= false;
			}
			break;

            case REQUIRED_POL_SECURITY:
			{
				secure			= true;
				userAlterable	= false;
			}
			break;

            default:
			{
                secure			= ConfPolicies::OutgoingSecurityPreferred();
				userAlterable	= true;
			}
			break;
        }
	}

}	//	End of CConfRoom::get_securitySettings.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confroom.h ===
// File: confroom.h

#ifndef _CONFROOM_H_
#define _CONFROOM_H_

#include <ias.h>
#include "MRUList.h"
#include "AudioCtl.h"
#include "ConfUtil.h"

#include	"callto.h"

class CTopWindow;
class CMainUI;
class CSeparator;
class CRoomListView;
class CConfStatusBar;
class CPopupMsg;
class CFloatToolbar;
class CVideoWindow;
class CParticipant;
class CComponentWnd;
class CAudioControl;
class CCall;

struct IComponentWnd;
struct IConferenceLink;
struct TOOLSMENUSTRUCT;
struct MYOWNERDRAWSTRUCT;
struct RichAddressInfo;

interface IEnumRichAddressInfo;

interface IConferenceChangeHandler : public IUnknown
{

public:
	virtual void OnCallStarted() = 0;
	virtual void OnCallEnded() = 0;

	virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume) = 0;
	virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute) = 0;

	virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify) = 0;

	virtual void OnChangePermissions() = 0;

	virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel) = 0;
} ;

class CConfRoom : RefCount, INmConferenceNotify2, IAppSharingNotify, IAudioEvent
{
friend class CNetMeetingObj;
friend bool IsSpeakerMuted();
friend bool IsMicMuted();
friend void MuteSpeaker(BOOL fMute);
friend void MuteMicrophone(BOOL fMute);
friend DWORD GetRecorderVolume();
friend DWORD GetSpeakerVolume();
friend void SetRecorderVolume(DWORD dw);
friend void SetSpeakerVolume(DWORD dw);
friend CVideoWindow*	GetLocalVideo();
friend CVideoWindow*	GetRemoteVideo();


private:
	CTopWindow *		m_pTopWindow;
	CSimpleArray<CParticipant*>			m_PartList;            // CParticipant list
	CCopyableArray<IConferenceChangeHandler*>			m_CallHandlerList;
	CParticipant *      m_pPartLocal;
	UINT                m_cParticipants;

    DWORD               m_dwConfCookie;
	INmConference2 *	m_pInternalNmConference;
	CAudioControl *         m_pAudioControl;
    IAppSharing *           m_pAS;
    NM30_MTG_PERMISSIONS    m_settings;             // Settings for the meeting
    NM30_MTG_PERMISSIONS    m_attendeePermissions;  // Everybody BUT host

	BOOL                m_fTopProvider : 1;        // TRUE if we're the top provider
    BOOL                m_fGetPermissions : 1;


	BOOL        LeaveConference(void);

	VOID        SaveSettings();
	
	// handlers:

	VOID		OnCallStarted();
	VOID		OnCallEnded();

	void		OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify);
	void		OnChangePermissions();

	BOOL        OnPersonJoined(INmMember * pMember);
	BOOL        OnPersonLeft(INmMember * pMember);
	VOID        OnPersonChanged(INmMember * pMember);

	VOID        CheckTopProvider(void);
	DWORD		GetCallFlags();

public:
	CConfRoom();
	~CConfRoom();

	// IUnknown methods:
	//
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObj);

	//
	// INmConferenceNotify2 methods:
	//
	STDMETHODIMP NmUI(CONFN uNotify);
	STDMETHODIMP StateChanged(NM_CONFERENCE_STATE uState);
	STDMETHODIMP MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	STDMETHODIMP ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);
	STDMETHODIMP StreamEvent(NM_STREAMEVENT uEvent, UINT uSubCode,INmChannel __RPC_FAR *pChannel);

	STDMETHODIMP OnConferenceCreated(INmConference *pConference);

    //
    // IAppSharingNotify methods
    //
    STDMETHODIMP    OnReadyToShare(BOOL fReady);
    STDMETHODIMP    OnShareStarted(void);
    STDMETHODIMP    OnSharingStarted(void);
    STDMETHODIMP    OnShareEnded(void);
    STDMETHODIMP    OnPersonJoined(IAS_GCC_ID gccMemberID);
    STDMETHODIMP    OnPersonLeft(IAS_GCC_ID gccMemberID);
    STDMETHODIMP    OnStartInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnStopInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnPausedInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnUnpausedInControl(IAS_GCC_ID gccOfMemberID);
    STDMETHODIMP    OnControllable(BOOL fControllable);
    STDMETHODIMP    OnStartControlled(IAS_GCC_ID gccByMemberID);
    STDMETHODIMP    OnStopControlled(IAS_GCC_ID gccByMemberID);
    STDMETHODIMP    OnPausedControlled(IAS_GCC_ID gccByMemberID);
    STDMETHODIMP    OnUnpausedControlled(IAS_GCC_ID gccByMemberID);

	virtual void OnLevelChange(BOOL fSpeaker, DWORD dwVolume);
	virtual void OnMuteChange(BOOL fSpeaker, BOOL fMute);

	// end IGenWindow interface

	// Public methods:
	BOOL			Init();
	HWND			Create(BOOL fShowUI);
	VOID			CleanUp();
	BOOL			BringToFront();
	VOID			UpdateUI(DWORD dwUIMask);
	VOID			ForceWindowResize();

	BOOL			FIsClosing();

	CTopWindow *    GetTopWindow()              { return m_pTopWindow; }
	HWND            GetTopHwnd();
	HPALETTE		GetPalette();

	CSimpleArray<CParticipant*>& GetParticipantList() 
												{ return m_PartList;      }

    DWORD           GetMeetingPermissions(void) { return m_attendeePermissions; }
    DWORD           GetMeetingSettings(void) { return m_settings; }
    void            CmdShowFileTransfer(void);
    void            CmdShowSharing(void);
    void            CmdShowMeetingSettings(HWND hwnd);

	HRESULT FreeAddress(RichAddressInfo **ppAddr);
	HRESULT CopyAddress(RichAddressInfo *pAddrIn,
				RichAddressInfo **ppAddrOut);

	HRESULT
	ResolveAndCall
	(
		const HWND						parentWindow,
		const TCHAR * const				displayName,
		const RichAddressInfo * const	rai,
		const bool						secure
	);

    HRESULT GetRecentAddresses(IEnumRichAddressInfo **ppEnum);

	CVideoWindow*	GetLocalVideo();
	CVideoWindow*	GetRemoteVideo();
	CAudioControl*	GetAudioControl() { return(m_pAudioControl); }

	BOOL            FIsConferenceActive(void) { return NULL != GetActiveConference(); }
	INmConference2* GetActiveConference(void);
	INmConference2* GetConference()           { return m_pInternalNmConference; }
	DWORD           GetConferenceStatus(LPTSTR pszStatus, int cchMax, UINT * puID);
	HRESULT         HostConference(LPCTSTR pcszName, LPCTSTR pcszPassword, BOOL fSecure, DWORD permitFlags, UINT maxParticipants);


	void			OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify);

	HRESULT			GetSelectedAddress(LPTSTR pszAddress, UINT cchAddress,
								   LPTSTR pszEmail=NULL, UINT cchEmail=0,
								   LPTSTR pszName=NULL,  UINT cchName=0);

	// Application Sharing Functions
	BOOL    FCanShare();
    BOOL    FIsSharingAvailable();
    void    LaunchHostUI(void);
	BOOL    FInShare();
	BOOL    FIsSharing();
    BOOL    FIsControllable();
    HRESULT GetPersonShareStatus(UINT gcc, IAS_PERSON_STATUS * pas);
    HRESULT AllowControl(BOOL fAllow);
	HRESULT RevokeControl(UINT gccTo);
    HRESULT GiveControl(UINT gccTo);
    HRESULT CancelGiveControl(UINT gccTo);

	// the following methods are used by scrapi only
	HRESULT CmdShare(HWND hwnd);
	HRESULT CmdUnshare(HWND hwnd);
    BOOL    FIsWindowShareable(HWND hwnd);
	BOOL    FIsWindowShared(HWND hwnd);
	HRESULT GetShareableApps(IAS_HWND_ARRAY** ppList);
    HRESULT FreeShareableApps(IAS_HWND_ARRAY* pList);

	// Audio Functions
	VOID			SetSpeakerVolume(DWORD dwLevel);
	VOID			SetRecorderVolume(DWORD dwLevel);
	VOID			MuteSpeaker(BOOL fMute);
	VOID			MuteMicrophone(BOOL fMute);

	VOID			OnAudioDeviceChanged();
	VOID			OnAGC_Changed();
	VOID			OnSilenceLevelChanged();

	// Member Functions
	CParticipant *  GetH323Remote(void);
	CParticipant *  ParticipantFromINmMember(INmMember * pMember);
	CParticipant *  GetLocalParticipant()     {return m_pPartLocal;}
	BOOL            FTopProvider()            {return m_fTopProvider;}

	VOID AddConferenceChangeHandler(IConferenceChangeHandler *pch);
	VOID RemoveConferenceChangeHandler(IConferenceChangeHandler *pch);

	IAppSharing *GetAppSharing() { return(m_pAS); }

	BOOL CanCloseChat(HWND hwndMain);
	BOOL CanCloseWhiteboard(HWND hwndMain);
	BOOL CanCloseFileTransfer(HWND hwndMain);

	void ToggleLdapLogon();

	// Stuff needed by CTopWindow
	UINT        GetMemberCount(void) { return m_cParticipants; }
	BOOL		OnHangup(HWND hwndParent, BOOL fNeedConfirm=TRUE);
	BOOL        FHasChildNodes(void);
    VOID        TerminateAppSharing(void);
	VOID        FreePartList(void);
    VOID        StartAppSharing(void);

	BOOL IsSharingAllowed();
	BOOL IsNewWhiteboardAllowed();
	BOOL IsOldWhiteboardAllowed();
	BOOL IsChatAllowed();
	BOOL IsFileTransferAllowed();
    BOOL IsNewCallAllowed();

	static HRESULT HangUp(BOOL bUserPrompt = TRUE);

	// Global UI shutdown handler:
	static VOID UIEndSession(BOOL fLogoff);

	static
	void
	get_securitySettings
	(
		bool &	userAlterable,
		bool &	secure
	);
};

HRESULT ShareWindow(HWND hWnd);
HRESULT UnShareWindow(HWND hWnd);
HRESULT GetWindowState(NM_SHAPP_STATE* pState, HWND hWnd);

BOOL AllowingControl();

HRESULT GetShareableApps(IAS_HWND_ARRAY** ppList);
HRESULT FreeShareableApps(IAS_HWND_ARRAY * pList);

// Global utility functions
BOOL FTopProvider(void);
BOOL FRejectIncomingCalls(void);
BOOL FIsConfRoomClosing(void);

extern CConfRoom * g_pConfRoom;
inline CConfRoom * GetConfRoom(void)        {return g_pConfRoom; }
inline CTopWindow * GetTopWindow(void)
{ return(NULL == g_pConfRoom ? NULL : g_pConfRoom->GetTopWindow()); }

HRESULT GetShareState(ULONG ulGCCId, NM_SHARE_STATE *puState);


BOOL ConfRoomInit(HANDLE hInstance);
BOOL CreateConfRoomWindow(BOOL fShowUI = TRUE);

DWORD MapNmAddrTypeToNameType(NM_ADDR_TYPE addrType);
HRESULT AllowControl(bool bAllowControl);
HRESULT RevokeControl(UINT gccID);
bool IsSpeakerMuted();
bool IsMicMuted();
DWORD GetRecorderVolume();
DWORD GetSpeakerVolume();

BOOL            CmdShowNewWhiteboard(LPCTSTR szFile);
BOOL            CmdShowOldWhiteboard(LPCTSTR szFile);
VOID            CmdShowChat(void);

void PauseLocalVideo(BOOL fPause);
void PauseRemoteVideo(BOOL fPause);
BOOL IsLocalVideoPaused();
BOOL IsRemoteVideoPaused();
HRESULT GetRemoteVideoState(NM_VIDEO_STATE *puState);
HRESULT GetLocalVideoState(NM_VIDEO_STATE *puState);
HRESULT GetImageQuality(ULONG* pul, BOOL bIncoming);
HRESULT SetImageQuality(ULONG ul, BOOL bIncoming);
HRESULT SetCameraDialog(ULONG ul);
HRESULT GetCameraDialog(ULONG* pul);

#endif // _CONFROOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confver.h ===
/* Version resource specific to conf.exe */

#define VER_DESCRIPTION_STR  "Windows\256 NetMeeting\256\0"
#define VER_INTERNALNAME_STR "conf\0"
#define VER_ORIGNAME_STR     "conf.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confwnd.cpp ===
// File: HiddenWnd.cpp

#include "precomp.h"

#include "ConfWnd.h"
#include "TaskBar.h"
#include "ConfRoom.h"
#include "Conf.h"
#include "FloatBar.h"
#include "Splash.h"
#include "Cmd.h"
#include "TopWindow.h"

const TCHAR g_cszHiddenWndClassName[] = _TEXT("ConfHiddenWindow");

BOOL CHiddenWindow::Create()
{
	return(CGenWindow::Create(NULL,
								g_szEmpty,
								WS_POPUP, // not visible!
								0,
								0, 0, 0, 0,
								_Module.GetModuleInstance(),
								NULL,
								g_cszHiddenWndClassName
								));
}

VOID CHiddenWindow::OnCallStarted()
{
	::SetTimer(GetWindow(),
				WINSOCK_ACTIVITY_TIMER,
				WINSOCK_ACTIVITY_TIMER_PERIOD,
				NULL);

}

VOID CHiddenWindow::OnCallEnded()
{
	::KillTimer(GetWindow(), WINSOCK_ACTIVITY_TIMER);
}

LRESULT CHiddenWindow::ProcessMessage( HWND hwnd, UINT uMsg,
								WPARAM wParam, LPARAM lParam)
{
	// This window is used for DCL/databeam callbacks and to route
	// WM_COMMAND messages generated by TranslateAccelerator()

	switch(uMsg)
	{
		case WM_CONF_MSG_BOX:
		{
			HWND hwndParent = NULL;
			if (_Module.IsUIVisible())
			{
				CTopWindow *pTop = GetTopWindow();
				if (NULL != pTop)
				{
					hwndParent = pTop->GetWindow();
					if (NULL != hwndParent)
					{
						hwndParent = GetLastActivePopup(hwndParent);
					}
				}
			}

			::ConfMsgBox(	hwndParent,
							(LPCTSTR) wParam,
							MB_OK | MB_ICONINFORMATION |
								MB_SETFOREGROUND);
			break;
		}

		case WM_NM_DISPLAY_MSG:
		{
			return ::DisplayMsg((LPTSTR)lParam, (UINT) wParam);
		}

		case WM_TASKBAR_NOTIFY:
		{
			switch (lParam)
			{
			case WM_RBUTTONUP:
				::OnRightClickTaskbar();
				break;

			case WM_LBUTTONDBLCLK:
				// Kill the timer, so we don't pop up the toolbar
				m_fGotDblClick = TRUE;
				::CreateConfRoomWindow();
				break;

			case WM_LBUTTONUP:
				if (FALSE == GetCursorPos(&m_ptTaskbarClickPos))
				{
					// If GetCursorPos failed, put it at 0,0
					m_ptTaskbarClickPos.x = m_ptTaskbarClickPos.y = 0;
				}

				// Create a timer that will go off one dbl-click's time from now
				::SetTimer(hwnd, TASKBAR_DBLCLICK_TIMER, GetDoubleClickTime(), NULL);
				break;
			}

			return(TRUE);
		}
		
		case WM_TIMER:
		{
			switch (wParam)
			{
				case WINSOCK_ACTIVITY_TIMER:
				{
					::SendDialmonMessage(WM_WINSOCK_ACTIVITY);
					break;
				}

				case TASKBAR_DBLCLICK_TIMER:
				{
					::KillTimer(hwnd, TASKBAR_DBLCLICK_TIMER);

					if (!m_fGotDblClick)
					{
						CFloatToolbar* pft = new CFloatToolbar(::GetConfRoom());
						if (NULL != pft)
						{
							pft->Create(m_ptTaskbarClickPos);
						}
					}

					m_fGotDblClick = FALSE;
					break;
				}

				default:
					break;
			}
			break;
		}

		case MM_MIXM_LINE_CHANGE:
		case MM_MIXM_CONTROL_CHANGE:
		{
			if(GetConfRoom())
			{
				CAudioControl *pAudioControl = GetConfRoom()->GetAudioControl();
				if (NULL != pAudioControl)
				{
					pAudioControl->RefreshMixer();
				}
			}
			break;
		}

		case WM_DESTROY:
		{
			TRACE_OUT(("Conf hidden window received WM_DESTROY"));
			return 0;
		}

		default:
			return CGenWindow::ProcessMessage(hwnd, uMsg, wParam, lParam);
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confutil.cpp ===
/****************************************************************************
*
*    FILE:     ConfUtil.cpp
*
*    CONTENTS: CConfRoom and app level utility functions
*
****************************************************************************/

#include "precomp.h"
#include "resource.h"
#include "confwnd.h"
#include "rostinfo.h"
#include "conf.h"
#include "nmmkcert.h"
#include "certui.h"
#include <ulsreg.h>
#include <confreg.h>
#include "shlWAPI.h"
#include "confutil.h"
#include "confpolicies.h"
#include "rend.h"


HFONT g_hfontDlg     = NULL;    // Default dialog font


#ifdef DEBUG
HDBGZONE ghZoneOther = NULL; // Other, conf.exe specific zones
static PTCHAR _rgZonesOther[] = {
	TEXT("UI"),
	TEXT("API"),
	TEXT("Video"),
	TEXT("Wizard"),
	TEXT("QoS"),
	TEXT("RefCount"),
	TEXT("Objects "),
	TEXT("UI Msg"),
	TEXT("Call Control"),
};

BOOL InitDebugZones(VOID)
{
	DBGINIT(&ghZoneOther, _rgZonesOther);
	return TRUE;
}

VOID DeinitDebugZones(VOID)
{
	DBGDEINIT(&ghZoneOther);
}

VOID DbgMsg(UINT iZone, PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & (1 << iZone))
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZone, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgRefCount(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_REFCOUNT)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_REFCOUNT, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgApi(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_API)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_API, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgVideo(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_VIDEO)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_VIDEO, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgUI(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_UI)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_UI, pszFormat, v1);
		va_end(v1);
	}
}

VOID DbgMsgCall(PSTR pszFormat,...)
{
	if (GETZONEMASK(ghZoneOther) & ZONE_UI)
	{
		va_list v1;
		va_start(v1, pszFormat);
		DbgZVPrintf(ghZoneOther, iZONE_UI, pszFormat, v1);
		va_end(v1);
	}
}

#endif /* DEBUG */



/*  F  L O A D  S T R I N G */
/*----------------------------------------------------------------------------
    %%Function: FLoadString

	Load a resource string.
	Assumes the buffer is valid and can hold the resource.
----------------------------------------------------------------------------*/
BOOL FLoadString(UINT id, LPTSTR lpsz, UINT cch)
{
	ASSERT(NULL != _Module.GetModuleInstance());
	ASSERT(NULL != lpsz);

	if (0 == ::LoadString(_Module.GetResourceModule(), id, lpsz, cch))
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		*lpsz = _T('\0');
		return FALSE;
	}

	return TRUE;
}


/*  F  L O A D  S T R I N G  1 */
/*----------------------------------------------------------------------------
    %%Function: FLoadString1

	Loads a resource string an formats it with the parameter.
	Assumes the resource is less than MAX_PATH characters
----------------------------------------------------------------------------*/
BOOL FLoadString1(UINT id, LPTSTR lpsz, LPVOID p)
{
	TCHAR sz[MAX_PATH];

	if (!FLoadString(id, sz, CCHMAX(sz)))
		return FALSE;

	wsprintf(lpsz, sz, p);

	return TRUE;
}

/*  F  L O A D  S T R I N G  2 */
/*----------------------------------------------------------------------------
    %%Function: FLoadString2

	Load a resource string. Return the length.
	Assumes the buffer is valid and can hold the resource.
----------------------------------------------------------------------------*/
int FLoadString2(UINT id, LPTSTR lpsz, UINT cch)
{
	ASSERT(NULL != _Module.GetModuleInstance());
	ASSERT(NULL != lpsz);

	int length = ::LoadString(_Module.GetResourceModule(), id, lpsz, cch);

	if (0 == length)
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		*lpsz = _T('\0');
	}

	return length;
}

/*  P S Z  L O A D  S T R I N G  */
/*-------------------------------------------------------------------------
    %%Function: PszLoadString

    Return the string associated with the resource.
-------------------------------------------------------------------------*/
LPTSTR PszLoadString(UINT id)
{
	TCHAR sz[MAX_PATH];

	if (0 == ::LoadString(::GetInstanceHandle(), id, sz, CCHMAX(sz)))
	{
		ERROR_OUT(("*** Resource %d does not exist", id));
		sz[0] = _T('\0');
	}

	return PszAlloc(sz);
}


/*  L O A D  R E S  I N T  */
/*-------------------------------------------------------------------------
    %%Function: LoadResInt

    Return the integer associated with the resource string.
-------------------------------------------------------------------------*/
int LoadResInt(UINT id, int iDefault)
{
	TCHAR sz[MAX_PATH];
	if (0 == ::LoadString(::GetInstanceHandle(), id, sz, CCHMAX(sz)))
		return iDefault;

	return RtStrToInt(sz);
}


/*  F  C R E A T E  I L S  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FCreateIlsName

    Combine the server and email names to form an ILS name.
    Return TRUE if the result fit in the buffer.
-------------------------------------------------------------------------*/
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszServer, LPCTSTR pszEmail, int cchMax)
{
	ASSERT(NULL != pszDest);

	TCHAR szServer[MAX_PATH];
	if (FEmptySz(pszServer))
	{
		lstrcpyn( szServer, CDirectoryManager::get_defaultServer(), CCHMAX( szServer ) );
		pszServer = szServer;
	}

	if (FEmptySz(pszEmail))
	{
		WARNING_OUT(("FCreateIlsName: Null email name?"));
		return FALSE;
	}

	int cch = lstrlen(pszServer);
	lstrcpyn(pszDest, pszServer, cchMax);
	if (cch >= (cchMax-2))
		return FALSE;

	pszDest += cch;
	*pszDest++ = _T('/');
	cchMax -= (cch+1);
	
	lstrcpyn(pszDest, pszEmail, cchMax);

	return (lstrlen(pszEmail) < cchMax);
}

/*  G E T  D E F A U L T  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: GetDefaultName

-------------------------------------------------------------------------*/
BOOL GetDefaultName(LPTSTR pszName, int nBufferMax)
{
	BOOL bRet = TRUE;

	ASSERT(pszName);
	
	// First, try to get the Registered User Name from Windows:
	
	RegEntry re(WINDOWS_CUR_VER_KEY, HKEY_LOCAL_MACHINE);
	lstrcpyn(pszName, re.GetString(REGVAL_REGISTERED_OWNER), nBufferMax);
	if (_T('\0') == pszName[0])
	{
		// The registered name was empty, try the computer name:

		DWORD dwBufMax = nBufferMax;
		if ((FALSE == ::GetComputerName(pszName, &dwBufMax)) ||
			(_T('\0') == pszName[0]))
		{
			// The computer name was empty, use UNKNOWN:
			bRet = FLoadString(IDS_UNKNOWN, pszName, nBufferMax);
		}
	}

	return bRet;
}


/*  E X T R A C T  S E R V E R  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: ExtractServerName

	Extract the server name from pcszAddr and copy it into pszServer.
	Return a pointer to the remaining data.

	Uses the default server name if none is found.
	Returns a pointer to the 2nd portion of the name.
-------------------------------------------------------------------------*/
LPCTSTR ExtractServerName(LPCTSTR pcszAddr, LPTSTR pszServer, UINT cchMax)
{
	LPCTSTR pchSlash = _StrChr(pcszAddr, _T('/'));

	if (NULL == pchSlash)
	{
		lstrcpyn( pszServer, CDirectoryManager::get_defaultServer(), cchMax );
	}
	else
	{
		lstrcpyn(pszServer, pcszAddr, (int)(1 + (pchSlash - pcszAddr)));
		pcszAddr = pchSlash+1;
	}
	return pcszAddr;
}

BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle, HWND hwndParent)
{
	LPITEMIDLIST pidlRoot;
	SHGetSpecialFolderLocation(HWND_DESKTOP, CSIDL_DRIVES, &pidlRoot);

	BROWSEINFO bi;
	ClearStruct(&bi);
	bi.hwndOwner = hwndParent;
	bi.lpszTitle = pszTitle;
	bi.ulFlags = BIF_RETURNONLYFSDIRS;
	bi.pidlRoot = pidlRoot;

	LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
	BOOL fRet = (pidl != NULL);
	if (fRet)
	{
		ASSERT(cchMax >= MAX_PATH);
		SHGetPathFromIDList(pidl, pszFolder);
		ASSERT(lstrlen(pszFolder) < (int) cchMax);
	}

	// Get the shell's allocator to free PIDLs
	LPMALLOC lpMalloc;
	if (!SHGetMalloc(&lpMalloc) && (NULL != lpMalloc))
	{
		if (NULL != pidlRoot)
		{
			lpMalloc->Free(pidlRoot);
		}
		if (pidl)
		{
			lpMalloc->Free(pidl);
		}
		lpMalloc->Release();
	}

	return fRet;
}



/*  D I S A B L E  C O N T R O L  */
/*-------------------------------------------------------------------------
    %%Function: DisableControl

-------------------------------------------------------------------------*/
VOID DisableControl(HWND hdlg, int id)
{
	if ((NULL != hdlg) && (0 != id))
	{
		HWND hwndCtrl = GetDlgItem(hdlg, id);
		ASSERT(NULL != hwndCtrl);
		EnableWindow(hwndCtrl, FALSE);
	}
}


BOOL IsWindowActive(HWND hwnd)
{
	HWND hwndFocus = GetFocus();

	while (NULL != hwndFocus)
	{
		if (hwndFocus == hwnd)
		{
			return(TRUE);
		}

		HWND hwndParent = GetParent(hwndFocus);
		if (NULL == hwndParent)
		{
			hwndFocus = GetWindow(hwndFocus, GW_OWNER);
		}
		else
		{
			hwndFocus = hwndParent;
		}
	}

	return(FALSE);
}

class CDialogTranslate : public CTranslateAccel
{
public:
	CDialogTranslate(HWND hwnd) : CTranslateAccel(hwnd) {}

	HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	)
	{
		HWND hwnd = GetWindow();

		return(::IsDialogMessage(hwnd, pMsg) ? S_OK : S_FALSE);
	}
} ;


VOID AddTranslateAccelerator(ITranslateAccelerator* pTrans)
{
	EnterCriticalSection(&dialogListCriticalSection);
	if (g_pDialogList->Add(pTrans))
	{
		pTrans->AddRef();
	}
	LeaveCriticalSection(&dialogListCriticalSection);
}

VOID RemoveTranslateAccelerator(ITranslateAccelerator* pTrans)
{
	EnterCriticalSection(&dialogListCriticalSection);
	if (g_pDialogList->Remove(pTrans))
	{
		pTrans->Release();
	}
	LeaveCriticalSection(&dialogListCriticalSection);
}

/*  A D D  M O D E L E S S  D L G  */
/*-------------------------------------------------------------------------
    %%Function: AddModelessDlg

    Add the hwnd to the global dialog list
-------------------------------------------------------------------------*/
VOID AddModelessDlg(HWND hwnd)
{
	ASSERT(NULL != g_pDialogList);

	CDialogTranslate *pDlgTrans = new CDialogTranslate(hwnd);
	if (NULL != pDlgTrans)
	{
		AddTranslateAccelerator(pDlgTrans);
		pDlgTrans->Release();
	}
}

/*  R E M O V E  M O D E L E S S  D L G  */
/*-------------------------------------------------------------------------
    %%Function: RemoveModelessDlg

    Remove the hwnd from the global dialog list
-------------------------------------------------------------------------*/
VOID RemoveModelessDlg(HWND hwnd)
{
	ASSERT(g_pDialogList);

	EnterCriticalSection(&dialogListCriticalSection);

	for (int i=g_pDialogList->GetSize()-1; i>=0; --i)
	{
		ITranslateAccelerator *pTrans = (*g_pDialogList)[i];
		ASSERT(NULL != pTrans);

		HWND hwndTemp = NULL;
		if (S_OK == pTrans->GetWindow(&hwndTemp) && hwndTemp == hwnd)
		{
			RemoveTranslateAccelerator(pTrans);
			break;
		}
	}

	LeaveCriticalSection(&dialogListCriticalSection);

}

/*  K I L L  S C R N  S A V E R  */
/*-------------------------------------------------------------------------
    %%Function: KillScrnSaver

    Remove the screen saver if it is active
-------------------------------------------------------------------------*/
VOID KillScrnSaver(void)
{
	if (!IsWindowsNT())
		return;

	POINT pos;
	::GetCursorPos(&pos);
	::SetCursorPos(0,0);
	::SetCursorPos(pos.x,pos.y);
}

/*  D X P  S Z  */
/*-------------------------------------------------------------------------
    %%Function: DxpSz

    Get the width of the string in pixels.
-------------------------------------------------------------------------*/
int DxpSz(LPCTSTR pcsz)
{
	HWND hwndDesktop = GetDesktopWindow();
	if (NULL == hwndDesktop)
		return 0;

	HDC hdc = GetDC(hwndDesktop);
	if (NULL == hdc)
		return 0;

	HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
	SIZE size;
	int dxp = ::GetTextExtentPoint32(hdc, pcsz, lstrlen(pcsz), &size)
					? size.cx : 0;

	::SelectObject(hdc, hFontOld);
	::ReleaseDC(hwndDesktop, hdc);

	return dxp;
}


/*  F  A N S I  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FAnsiSz

    Return TRUE if the string contains no DBCS characters.
-------------------------------------------------------------------------*/
BOOL FAnsiSz(LPCTSTR psz)
{
	if (NULL != psz)
	{
		char ch;
		while (_T('\0') != (ch = *psz++))
		{
			if (IsDBCSLeadByte(ch))
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////

int	g_cBusyOperations = 0;

VOID DecrementBusyOperations(void)
{
	g_cBusyOperations--;

	POINT pt;
	// Wiggle the mouse - force user to send a WM_SETCURSOR
	if (::GetCursorPos(&pt))
		::SetCursorPos(pt.x, pt.y);
}

VOID IncrementBusyOperations(void)
{
	g_cBusyOperations++;

	POINT pt;
	// Wiggle the mouse - force user to send a WM_SETCURSOR
	if (::GetCursorPos(&pt))
		::SetCursorPos(pt.x, pt.y);
}



/////////////////////////////////////////////////////////////////////////////
// String Utilities

/*  P S Z  A L L O C  */
/*-------------------------------------------------------------------------
    %%Function: PszAlloc

-------------------------------------------------------------------------*/
LPTSTR PszAlloc(LPCTSTR pszSrc)
{
	if (NULL == pszSrc)
		return NULL;

	LPTSTR pszDest = new TCHAR[lstrlen(pszSrc) + 1];
	if (NULL != pszDest)
	{
		lstrcpy(pszDest, pszSrc);
	}
	return pszDest;
}


VOID FreePsz(LPTSTR psz)
{
	delete [] psz;
}

/*  L  P  T  S  T  R _ T O _  B  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: LPTSTR_to_BSTR

-------------------------------------------------------------------------*/
HRESULT LPTSTR_to_BSTR(BSTR *pbstr, LPCTSTR psz)
{
	ASSERT(NULL != pbstr);
	if (NULL == psz)
	{
		psz = TEXT(""); // convert NULL strings to empty strings
	}

#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
	if (cch <= 0)
		return E_FAIL;

	// allocate the widestr, +1 for terminating null
	BSTR bstr = SysAllocStringLen(NULL, cch-1); // SysAllocStringLen adds 1
	if (bstr == NULL)
		return E_OUTOFMEMORY;

	MultiByteToWideChar(CP_ACP, 0, psz, -1, (LPWSTR)bstr, cch);
	((LPWSTR)bstr)[cch - 1] = 0;
#else

	BSTR bstr = SysAllocString(psz);
	if (bstr == NULL)
		return E_OUTOFMEMORY;
#endif // UNICODE

	*pbstr = bstr;
	return S_OK;
}

/*  B  S  T  R _ T O _  L  P  T  S  T  R  */
/*-------------------------------------------------------------------------
    %%Function: BSTR_to_LPTSTR

-------------------------------------------------------------------------*/
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr)
{
#ifndef UNICODE
	// compute the length of the required BSTR
	int cch =  WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return E_FAIL;

	// cch is the number of BYTES required, including the null terminator
	*ppsz = (LPTSTR) new char[cch];
	if (*ppsz == NULL)
		return E_OUTOFMEMORY;

	WideCharToMultiByte(CP_ACP, 0, (LPWSTR)bstr, -1, *ppsz, cch, NULL, NULL);
	return S_OK;
#else
	return E_NOTIMPL;
#endif // UNICODE
}

/*  P S Z  F R O M  B S T R  */
/*-------------------------------------------------------------------------
    %%Function: PszFromBstr

-------------------------------------------------------------------------*/
LPTSTR PszFromBstr(PCWSTR pwStr)
{
#ifdef UNICODE
	return PszAlloc(pwStr)
#else
	int cch = WideCharToMultiByte(CP_ACP, 0, pwStr, -1, NULL, 0, NULL, NULL);
	if (cch <= 0)
		return NULL;

	// cch is the number of BYTES required, including the null terminator
	LPTSTR psz = new char[cch];
	if (NULL != psz)
	{
		WideCharToMultiByte(CP_ACP, 0, pwStr, -1, psz, cch, NULL, NULL);
	}
	return psz;
#endif /* UNICODE */
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Advise(pUnk, pdw);
		pCP->Release();
	}
	return hRes;
}

HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	IConnectionPointContainer *pCPC;
	IConnectionPoint *pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
	{
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
		pCPC->Release();
	}
	if (SUCCEEDED(hRes))
	{
		hRes = pCP->Unadvise(dw);
		pCP->Release();
	}
	return hRes;
}

extern INmSysInfo2 * g_pNmSysInfo;

////////////////////////////////////////////////////////////////////////////
// Call into the certificate generation module to generate
// a certificate matching the ULS info for secure calling:

DWORD MakeCertWrap
(
    LPCSTR  szFirstName,
	LPCSTR  szLastName,
	LPCSTR  szEmailName,
	DWORD   dwFlags
)
{
	HMODULE hMakeCertLib = LoadLibrary(SZ_NMMKCERTLIB);
    DWORD dwRet = -1;

	if ( NULL != hMakeCertLib ) {
		PFN_NMMAKECERT pfn_MakeCert =
			(PFN_NMMAKECERT)GetProcAddress ( hMakeCertLib,
			SZ_NMMAKECERTFUNC );

		if ( NULL != pfn_MakeCert ) {
			dwRet = pfn_MakeCert(	szFirstName,
							szLastName,
							szEmailName,
							NULL,
							NULL,
							dwFlags );

			RefreshSelfIssuedCert();
		}
		else
        {
			ERROR_OUT(("GetProcAddress(%s) failed: %x",
						SZ_NMMAKECERTFUNC, GetLastError()));
		}
		FreeLibrary ( hMakeCertLib );
	}
	else
    {
		ERROR_OUT(("LoadLibrary(%s) failed: %x", SZ_NMMKCERTLIB,
			GetLastError()));
	}
    return(dwRet);
}


///////////////////////////////////////////////////////////////////////////
// Icon Utilities

HIMAGELIST g_himlIconSmall = NULL;

VOID LoadIconImages(void)
{
	ASSERT(NULL == g_himlIconSmall);
	g_himlIconSmall = ImageList_Create(DXP_ICON_SMALL, DYP_ICON_SMALL, ILC_MASK, 1, 0);
	if (NULL != g_himlIconSmall)
	{
		HBITMAP hBmp = ::LoadBitmap(::GetInstanceHandle(), MAKEINTRESOURCE(IDB_ICON_IMAGES));
		if (NULL != hBmp)
		{
			ImageList_AddMasked(g_himlIconSmall, hBmp, TOOLBAR_MASK_COLOR);
			::DeleteObject(hBmp);
		}
	}
}

VOID FreeIconImages(void)
{
	if (NULL != g_himlIconSmall)
	{
		ImageList_Destroy(g_himlIconSmall);
		g_himlIconSmall = NULL;
	}	
}


VOID DrawIconSmall(HDC hdc, int iIcon, int x, int y)
{
	ImageList_DrawEx(g_himlIconSmall, iIcon, hdc,
		x, y, DXP_ICON_SMALL, DYP_ICON_SMALL,
		CLR_DEFAULT, CLR_DEFAULT, ILD_NORMAL);
}

// Get the default dialog (GUI) font for international
HFONT GetDefaultFont(void)
{
	if (NULL == g_hfontDlg)
	{
		g_hfontDlg = (HFONT) ::GetStockObject(DEFAULT_GUI_FONT);
	}

	return g_hfontDlg;
}

/*  F  E M P T Y  D L G  I T E M  */
/*-------------------------------------------------------------------------
    %%Function: FEmptyDlgItem

    Return TRUE if the dialog control is empty
-------------------------------------------------------------------------*/
BOOL FEmptyDlgItem(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	return (0 == GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz)) );
}



/*  T R I M  D L G  I T E M  T E X T  */
/*-------------------------------------------------------------------------
    %%Function: TrimDlgItemText

    Trim the text in the edit control and return the length of the string.
-------------------------------------------------------------------------*/
UINT TrimDlgItemText(HWND hdlg, UINT id)
{
	TCHAR sz[MAX_PATH];
	GetDlgItemTextTrimmed(hdlg, id, sz, CCHMAX(sz));
	SetDlgItemText(hdlg, id, sz);
	return lstrlen(sz);
}

/*  G E T  D L G  I T E M  T E X T  T R I M M E D  */
/*-------------------------------------------------------------------------
    %%Function: GetDlgItemTextTrimmed

-------------------------------------------------------------------------*/
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cchMax)
{
	UINT cch = GetDlgItemText(hdlg, id, psz, cchMax);
	if (0 != cch)
	{
		cch = TrimSz(psz);
	}

	return cch;
}


/*  F M T  D A T E  T I M E  */
/*-------------------------------------------------------------------------
    %%Function: FmtDateTime

    Formats the system time using the current setting (MM/DD/YY HH:MM xm)
-------------------------------------------------------------------------*/
int FmtDateTime(LPSYSTEMTIME pst, LPTSTR pszDateTime, int cchMax)
{
    pszDateTime[0] = _T('\0');
    int cch = ::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                            pst, NULL, pszDateTime, cchMax);
    if ((0 != cch) && ((cchMax - cch) > 0))
    {
        // Tack on a space and then the time.
        // GetDateFormat returns count of chars
        // INCLUDING the NULL terminator, hence the - 1
        LPTSTR pszTime = pszDateTime + (cch - 1);
        pszTime[0] = _T(' ');
        pszTime[1] = _T('\0');
        cch = ::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS,
                                pst, NULL, &(pszTime[1]), (cchMax - cch));
    }

    return (cch == 0 ? 0 : lstrlen(pszDateTime));
}

/*  C O M B I N E  N A M E S  */
/*-------------------------------------------------------------------------
    %%Function: CombineNames

	Combine the two names into one string.
	The result is a "First Last" (or Intl'd "Last First") string
-------------------------------------------------------------------------*/
VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast)
{
	ASSERT(pszResult);
	TCHAR szFmt[32]; // A small value: String is "%1 %2" or "%2 %1"
	TCHAR sz[1024]; // The result (before truncating to cchResult chars)
	LPCTSTR argw[2];

	argw[0] = pcszFirst;
	argw[1] = pcszLast;

	*pszResult = _T('\0');

	if (FLoadString(IDS_NAME_ORDER, szFmt, CCHMAX(szFmt)))
	{
		if (0 != FormatMessage(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_STRING,
			szFmt, 0, 0, sz, CCHMAX(sz), (va_list *)argw ))
		{
			lstrcpyn(pszResult, sz, cchResult);
#ifndef _UNICODE
			// (see bug 3907 )
			// lstrcpyn() can clip a DBCS character in half at the end of the string
			// we need to walk the string with ::CharNext() and replace the last byte
			// with a NULL if the last byte is half of a DBCS char.
			PTSTR pszSource = sz;
			while (*pszSource && (pszSource - sz < cchResult))
			{
				PTSTR pszPrev = pszSource;
				pszSource = ::CharNext(pszPrev);
				// If we've reached the first character that didn't get copied into
				// the destination buffer, and the previous character was a double
				// byte character...
				if (((pszSource - sz) == cchResult) && ::IsDBCSLeadByte(*pszPrev))
				{
					// Replace the destination buffer's last character with '\0'
					// NOTE: pszResult[cchResult - 1] is '\0' thanks to lstrcpyn()
					pszResult[cchResult - 2] = _T('\0');
					break;
				}
			}
#endif // ! _UNICODE
		}
	}

}

BOOL NMGetSpecialFolderPath(
    HWND hwndOwner,
    LPTSTR lpszPath,
    int nFolder,
    BOOL fCreate)
{
	LPITEMIDLIST pidl = NULL;

	BOOL fRet = FALSE;

	if (NOERROR == SHGetSpecialFolderLocation(NULL, nFolder, &pidl))
	{
		ASSERT(NULL != pidl);

		if (SHGetPathFromIDList(pidl, lpszPath))
		{
			lstrcat(lpszPath, _TEXT("\\"));
			fRet = TRUE;
		}

		LPMALLOC lpMalloc;
		if (!SHGetMalloc(&lpMalloc))
		{
			ASSERT(NULL != lpMalloc);

			lpMalloc->Free(pidl);
			lpMalloc->Release();
		}
	}
	return fRet;
}


//--------------------------------------------------------------------------//
//	CDirectoryManager static data members.									//
//--------------------------------------------------------------------------//
bool	CDirectoryManager::m_webEnabled						= true;
TCHAR	CDirectoryManager::m_ils[ MAX_PATH ]				= TEXT( "" );
TCHAR	CDirectoryManager::m_displayName[ MAX_PATH ]		= TEXT( "" );
TCHAR	CDirectoryManager::m_displayNameDefault[ MAX_PATH ]	= TEXT( "Microsoft Internet Directory" );
TCHAR	CDirectoryManager::m_defaultServer[ MAX_PATH ]		= TEXT( "" );
TCHAR	CDirectoryManager::m_DomainDirectory[ MAX_PATH ]	= TEXT( "" );

		
//--------------------------------------------------------------------------//
//	CDirectoryManager::get_defaultServer.									//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_defaultServer(void)
{

	if( m_defaultServer[ 0 ] == '\0' )
	{
		//	defaultServer not yet loaded...
		RegEntry	re( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

		lstrcpyn( m_defaultServer, re.GetString( REGVAL_SERVERNAME ), CCHMAX( m_defaultServer ) );

		if( (m_defaultServer[ 0 ] == '\0') && (get_DomainDirectory() != NULL) )
		{
			//	When no default ils server has been saved in the registry we first try to default it to the
			//	server configured for the domain if any...
			lstrcpy( m_defaultServer, m_DomainDirectory );
		}

		if( (m_defaultServer[ 0 ] == '\0') && isWebDirectoryEnabled() )
		{
			//	When no default ils server has been saved in the registry we default it to m_ils...
			lstrcpy( m_defaultServer, get_webDirectoryIls() );
		}
	}

	return( m_defaultServer );

}	//	End of CDirectoryManager::get_defaultServer.


//--------------------------------------------------------------------------//
//	CDirectoryManager::set_defaultServer.									//
//--------------------------------------------------------------------------//
void
CDirectoryManager::set_defaultServer
(
	const TCHAR * const	serverName
){
	RegEntry	ulsKey( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

	ulsKey.SetValue( REGVAL_SERVERNAME, serverName );

	lstrcpy( m_defaultServer, serverName );

}	//	End of CDirectoryManager::set_defaultServer.


//--------------------------------------------------------------------------//
//	CDirectoryManager::isWebDirectory.										//
//--------------------------------------------------------------------------//
bool
CDirectoryManager::isWebDirectory
(
	const TCHAR * const	directory
){
	TCHAR	buffer[ MAX_PATH ];

	//	If directory is null then the question is "is the default server the web directory?"

	return( isWebDirectoryEnabled() && (lstrcmpi( (directory != NULL)? get_dnsName( directory ): get_defaultServer(), get_webDirectoryIls() ) == 0) );

}	//	End of CDirectoryManager::isWebDirectory.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_dnsName.											//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_dnsName
(
	const TCHAR * const	name
){

	//	Check to see if the specified name matches m_displayName...
	return( (isWebDirectoryEnabled() && (lstrcmpi( name, loadDisplayName() ) == 0))? get_webDirectoryIls() : name );

}	//	End of CDirectoryManager::get_dnsName.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_displayName.										//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_displayName
(
	const TCHAR * const	name
){

	//	Check to see if the specified name matches m_ils...
	return( (isWebDirectoryEnabled() && (lstrcmpi( name, get_webDirectoryIls() ) == 0))? loadDisplayName(): name );

}	//	End of CDirectoryManager::get_displayName.


//--------------------------------------------------------------------------//
//	CDirectoryManager::loadDisplayName.										//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::loadDisplayName(void)
{
	using namespace ConfPolicies;

	if( m_displayName[ 0 ] == '\0' )
	{
		GetWebDirInfo( NULL, 0,
			NULL, 0,
			m_displayName, ARRAY_ELEMENTS(m_displayName) );

		if ( '\0' == m_displayName[0] )
		{
			lstrcpy( m_displayName, RES2T( IDS_MS_INTERNET_DIRECTORY ) );

			if( m_displayName[ 0 ] == '\0' )
			{
				//	Loading m_displayName from the resources failed... default to m_displayNameDefault...
				lstrcpy( m_displayName, m_displayNameDefault );
			}
		}
	}

	return( m_displayName );

}	//	End of CDirectoryManager::loadDisplayName.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_webDirectoryUrl.									//
//--------------------------------------------------------------------------//
void
CDirectoryManager::get_webDirectoryUrl(LPTSTR szWebDir, int cchmax)
{
	using namespace ConfPolicies;

	if ( !isWebDirectoryEnabled() )
	{
		szWebDir[0] = '\0';
		return;
	}

    GetWebDirInfo( szWebDir, cchmax );
	if ( '\0' != szWebDir[0] )
	{
		// All done
		return;
	}

	void FormatURL(LPTSTR szURL);

	lstrcpyn(szWebDir, RES2T(IDS_WEB_PAGE_FORMAT_WEBVIEW), cchmax);
	FormatURL(szWebDir);

}	//	End of CDirectoryManager::get_webDirectoryUrl.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_webDirectoryIls.									//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_webDirectoryIls(void)
{
	using namespace ConfPolicies;

	if (!isWebDirectoryEnabled())
	{
		return(TEXT(""));
	}

	if ('\0' == m_ils[0])
	{
		GetWebDirInfo( NULL, 0,
			m_ils, ARRAY_ELEMENTS(m_ils) );
		if ('\0' == m_ils[0])
		{
			lstrcpy(m_ils, TEXT("logon.netmeeting.microsoft.com"));
		}
	}

	return(m_ils);

}	//	End of CDirectoryManager::get_webDirectoryIls.


//--------------------------------------------------------------------------//
//	CDirectoryManager::isWebDirectoryEnabled.								//
//--------------------------------------------------------------------------//
bool
CDirectoryManager::isWebDirectoryEnabled(void)
{
	static bool	policyChecked	= false;

	if( !policyChecked )
	{
		policyChecked	= true;
		m_webEnabled	= !ConfPolicies::isWebDirectoryDisabled();
	}

	return( m_webEnabled );

}	//	End of CDirectoryManager::isWebDirectoryEnabled.


//--------------------------------------------------------------------------//
//	CDirectoryManager::get_DomainDirectory.									//
//--------------------------------------------------------------------------//
const TCHAR * const
CDirectoryManager::get_DomainDirectory(void)
{
	static bool	bAccessAttempted	= false;	//	only read this info once... if it fails once assume it's not available and don't retry until restarted...

	if( (!bAccessAttempted) && m_DomainDirectory[ 0 ] == '\0' )
	{
		bAccessAttempted = true;

		//	Try to obtain the configured directory for this domain...
		ITRendezvous *	pRendezvous;
		HRESULT			hrResult;

		hrResult = ::CoCreateInstance( CLSID_Rendezvous, NULL, CLSCTX_ALL, IID_ITRendezvous, (void **) &pRendezvous );

		if( (hrResult == S_OK) && (pRendezvous != NULL) )
		{
			IEnumDirectory *	pEnumDirectory;

			hrResult = pRendezvous->EnumerateDefaultDirectories( &pEnumDirectory );

			if( (hrResult == S_OK) && (pEnumDirectory != NULL) )
			{
				ITDirectory *	pDirectory;
				bool			bFoundILS	= false;

				do
				{
					hrResult = pEnumDirectory->Next( 1, &pDirectory, NULL );

					if( (hrResult == S_OK) && (pDirectory != NULL) )
					{
						LPWSTR *		ppServers;
						DIRECTORY_TYPE	type;

						if( pDirectory->get_DirectoryType( &type ) == S_OK )
						{
							if( type == DT_ILS )	//	Found an ILS server configured on the DS... retrieve the name and port...
							{
								bFoundILS = true;
	
								BSTR	pName;
	
								if( pDirectory->get_DisplayName( &pName ) == S_OK )
								{
									USES_CONVERSION;
									lstrcpy( m_DomainDirectory, OLE2T( pName ) );
									SysFreeString( pName );
								}

								ITILSConfig *	pITILSConfig;
	
								hrResult = pDirectory->QueryInterface( IID_ITILSConfig, (void **) &pITILSConfig );

								if( (hrResult == S_OK) && (pITILSConfig != NULL) )
								{
									long	lPort;
		
									if( pITILSConfig->get_Port( &lPort ) == S_OK )
									{
										TCHAR	pszPort[ 32 ];

										wsprintf( pszPort, TEXT( ":%d" ), lPort );
										lstrcat( m_DomainDirectory, pszPort );
									}
	
									pITILSConfig->Release();
								}
							}
						}

						pDirectory->Release();
					}
				}
				while( (!bFoundILS) && (hrResult == S_OK) && (pDirectory != NULL) );

				pEnumDirectory->Release();
			}

			pRendezvous->Release();
		}
	}

	return( (m_DomainDirectory[ 0 ] != '\0')? m_DomainDirectory: NULL );

}	//	End of CDirectoryManager::get_DomainDirectory.


// Returns non-empty strings if there is a web dir set by policy
bool ConfPolicies::GetWebDirInfo(
	LPTSTR szURL, int cchmaxURL,
	LPTSTR szServer, int cchmaxServer,
	LPTSTR szName, int cchmaxName
	)
{
        // if the string params are messed up, just return false
    ASSERT( (!szURL || ( cchmaxURL > 0 ))
		&& (!szServer || ( cchmaxServer > 0 ))
		&& (!szName || ( cchmaxName > 0 ))
		);

	bool bSuccess = false;

        // Try to get the registry value
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    LPCTSTR szTemp;

    szTemp = rePol.GetString( REGVAL_POL_INTRANET_WEBDIR_URL );
    if( szTemp[0] )
    {
		if (NULL != szURL)
		{
			lstrcpyn( szURL, szTemp, cchmaxURL );
		}

		szTemp = rePol.GetString( REGVAL_POL_INTRANET_WEBDIR_SERVER );
		if (szTemp[0])
		{
			if (NULL != szServer)
			{
				lstrcpyn( szServer, szTemp, cchmaxServer );
			}

			szTemp = rePol.GetString( REGVAL_POL_INTRANET_WEBDIR_NAME );
			if( szTemp[0] )
			{
				if  (NULL != szName)
				{
					lstrcpyn( szName, szTemp, cchmaxName );
				}

				// All three values must be specified for success
				bSuccess = true;
			}
		}
    }

	if (!bSuccess)
	{
		// Empty the strings
		if (NULL != szURL   ) szURL   [0] = '\0';
		if (NULL != szServer) szServer[0] = '\0';
		if (NULL != szName  ) szName  [0] = '\0';
	}

	return(bSuccess);
}

bool g_bAutoAccept = false;

bool ConfPolicies::IsAutoAcceptCallsOptionEnabled(void)
{
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    return !rePol.GetNumber( REGVAL_POL_NO_AUTOACCEPTCALLS, DEFAULT_POL_NO_AUTOACCEPTCALLS );
}

bool ConfPolicies::IsAutoAcceptCallsPersisted(void)
{
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    return 0 != rePol.GetNumber( REGVAL_POL_PERSIST_AUTOACCEPTCALLS, DEFAULT_POL_PERSIST_AUTOACCEPTCALLS );
}

bool ConfPolicies::IsAutoAcceptCallsEnabled(void)
{
	bool bRet = false;

    if( IsAutoAcceptCallsOptionEnabled() )
	{
		bRet = g_bAutoAccept;

		if (IsAutoAcceptCallsPersisted())
		{
			// AutoAccept calls is _not_ disabled by the policy... we should check the AUTO_ACCEPT regval
			RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
			if(reConf.GetNumber(REGVAL_AUTO_ACCEPT, g_bAutoAccept) )
			{
				bRet = true;
			}
		}
	}

	return bRet;
}

void ConfPolicies::SetAutoAcceptCallsEnabled(bool bAutoAccept)
{
	g_bAutoAccept = bAutoAccept;

	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
	reConf.SetValue(REGVAL_AUTO_ACCEPT, g_bAutoAccept);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confutil.h ===
/*
 *	ConfUtil.h
 *
 *	CConfRoom and app level utility functions
 */

#ifndef _CONFUTIL_H_
#define _CONFUTIL_H_

#include "SDKInternal.h"
 
#define QUICK_LAUNCH_SUBDIR _T("\\Microsoft\\Internet Explorer\\Quick Launch")
void DeleteShortcut(int csidl, LPCTSTR pszSubDir);

// File Transfer
BOOL  FTransferInProgress(VOID);
BOOL  FEnableSendFileMenu(VOID);
BOOL  FEnableCancelSendMenu(VOID);
BOOL  FEnableCancelReceiveMenu(VOID);

// Options Dialog
#define OPTIONS_GENERAL_PAGE         0
#define OPTIONS_SECURITY_PAGE		 1
#define OPTIONS_MYINFO_PAGE          2
#define OPTIONS_FRIENDS_PAGE         3
#define OPTIONS_AUDIO_PAGE           4
#define OPTIONS_VIDEO_PAGE           5
#define OPTIONS_DEFAULT_PAGE         OPTIONS_GENERAL_PAGE

VOID LaunchConfCpl(HWND hwnd, int nStartPage);
BOOL CanLaunchConfCpl();


// Capabilities
extern BOOL FIsAudioAllowed();
extern BOOL FIsSendVideoAllowed();
extern BOOL FIsReceiveVideoAllowed();


// String Functions
BOOL FLoadString(UINT id, LPTSTR psz, UINT cb = MAX_PATH);
BOOL FLoadString1(UINT id, LPTSTR psz, LPVOID pv);
int FLoadString2(UINT id, LPTSTR psz, UINT cb = MAX_PATH);
LPTSTR PszLoadString(UINT id);
LPTSTR PszAlloc(LPCTSTR pszSrc);
VOID FreePsz(LPTSTR psz);
LPTSTR PszFromBstr(PCWSTR pwStr);

int LoadResInt(UINT id, int iDefault);

HRESULT LPTSTR_to_BSTR(BSTR *pbstr, LPCTSTR psz);
HRESULT BSTR_to_LPTSTR(LPTSTR *ppsz, BSTR bstr);


// Other
BOOL GetDefaultName(LPTSTR pszName, int nBufferMax);

LPCTSTR ExtractServerName(LPCTSTR pcszAddr, LPTSTR pszServer, UINT cchMax);
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszServer, LPCTSTR pszEmail, int cchMax);

BOOL FLocalIpAddress(DWORD dwIP);

INmConference2 * GetActiveConference(void);
BOOL FIsConferenceActive(void);


// Forward declaration
interface ITranslateAccelerator;

VOID AddModelessDlg(HWND hwnd);
VOID RemoveModelessDlg(HWND hwnd);
VOID AddTranslateAccelerator(ITranslateAccelerator* pTrans);
VOID RemoveTranslateAccelerator(ITranslateAccelerator* pTrans);

BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle, HWND hwndParent);

VOID DisableControl(HWND hdlg, int id);

VOID KillScrnSaver(void);
int  DxpSz(LPCTSTR pcszName);
BOOL FAnsiSz(LPCTSTR psz);

extern int g_cBusyOperations;
VOID DecrementBusyOperations(void);
VOID IncrementBusyOperations(void);


// Useful Macros
#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))



// ZONE bitmasks  (depends on _rgZonesOther)
#define ZONE_API       0x01
#define ZONE_VIDEO     0x02
#define ZONE_WIZARD    0x04
#define ZONE_QOS       0x08
#define ZONE_REFCOUNT  0x10
#define ZONE_OBJECTS   0x20
#define ZONE_UI        0x40
#define ZONE_CALL    0x0080

// Zone indexes
#define iZONE_API      0
#define iZONE_VIDEO    1
#define iZONE_WIZARD   2
#define iZONE_QOS      3
#define iZONE_REFCOUNT 4
#define iZONE_OBJECTS  5
#define iZONE_UI       6
#define iZONE_CALL     7

// Debugging Macros
#ifdef DEBUG
BOOL InitDebugZones(VOID);
VOID DeinitDebugZones(VOID);

extern HDBGZONE ghZoneOther; // initialized in conf.cpp

// Old: requires double brackets  ApiDebugMsg(("x=%d", x));
#define ApiDebugMsg(s)    DBGMSG(ghZoneOther, iZONE_API, s)
#define VideoDebugMsg(s)  DBGMSG(ghZoneOther, iZONE_VIDEO, s)

// General: DbgMsg(iZONE_API, "x=%d", x);
VOID DbgMsg(UINT iZone, PSTR pszFormat,...);

// Specific: DbgMsgApi("x=%d", x);
VOID DbgMsgApi(PSTR pszFormat,...);
VOID DbgMsgVideo(PSTR pszFormat,...);
VOID DbgMsgRefCount(PSTR pszFormat,...);
VOID DbgMsgUI(PSTR pszFormat,...);
VOID DbgMsgCall(PSTR pszFormat,...);


LPCTSTR PszWSALastError(void);
LPCTSTR PszLastError(void);
LPCTSTR PszHResult(HRESULT hr);

// Redefine the standard HR result display macro
#undef DBGEXIT_HR
#define DBGEXIT_HR(s,hr)   DbgZPrintFunction("Exit  " #s "  (result=%s)", PszHResult(hr));

#else

#define ApiDebugMsg(s)
#define VideoDebugMsg(s)

inline void WINAPI DbgMsgNop(LPCTSTR, ...) { }
#define DbgMsgRefCount 1 ? (void)0 : ::DbgMsgNop
#define DbgMsgApi      1 ? (void)0 : ::DbgMsgNop
#define DbgMsgVideo    1 ? (void)0 : ::DbgMsgNop
#define DbgMsgUI       1 ? (void)0 : ::DbgMsgNop
#define DbgMsgCall     1 ? (void)0 : ::DbgMsgNop

inline void WINAPI DbgMsgZoneNop(UINT, LPCTSTR, ...) { }
#define DbgMsg  1 ? (void) 0 : ::DbgMsgZoneNop

#endif /* DEBUG */

interface ITranslateAccelerator : public IUnknown
{
public:
	// Copied from IOleControlSite, but I don't use grfModifiers
	virtual HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	) = 0;
	// Copied from IOleWindow
	virtual HRESULT GetWindow(
		HWND * phwnd  //Pointer to where to return window handle
	) = 0;
} ;

BOOL IsWindowActive(HWND hwnd);

class CTranslateAccel : public ITranslateAccelerator, RefCount
{
private:
	HWND m_hwnd;

public:
	CTranslateAccel(HWND hwnd) : m_hwnd(hwnd)
	{
	}

	HWND GetWindow() const { return(m_hwnd); }

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppvObj)
	{ return(E_NOTIMPL); }
	ULONG STDMETHODCALLTYPE AddRef()
	{ return(RefCount::AddRef()); }
	ULONG STDMETHODCALLTYPE Release()
	{ return(RefCount::Release()); }

	HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	)
	{
		return(S_FALSE);
	}

	HRESULT GetWindow(
		HWND * phwnd  //Pointer to where to return window handle
	)
	{
		*phwnd = m_hwnd;
		return(S_OK);
	}
} ;

class CTranslateAccelTable : public CTranslateAccel
{
private:
	HACCEL m_hAccel;
	int m_nEntries;

public:
	CTranslateAccelTable(HWND hwnd, HACCEL hAccel) : CTranslateAccel(hwnd), m_hAccel(hAccel)
	{
		m_nEntries = CopyAcceleratorTable(m_hAccel, NULL, 0);
	}

	HRESULT TranslateAccelerator(
		LPMSG pMsg ,        //Pointer to the structure
		DWORD grfModifiers  //Flags describing the state of the keys
	)
	{
		HWND hwnd = GetWindow();

		WORD cmd = 0;
		if (!IsAccelerator(m_hAccel, m_nEntries, pMsg, &cmd) || !IsWindowActive(hwnd))
		{
			return(S_FALSE);
		}

		return(::TranslateAccelerator(hwnd, m_hAccel, pMsg) ? S_OK : S_FALSE);
	}
} ;

// Global list of modeless dialogs (declared in conf.cpp)
extern CSimpleArray<ITranslateAccelerator*>* g_pDialogList;
extern CRITICAL_SECTION dialogListCriticalSection;



/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

HRESULT NmAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
HRESULT NmUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// NmMkCert wrapper
DWORD MakeCertWrap(LPCSTR szFirstName, LPCSTR szLastName, LPCSTR szEmailName,
								DWORD dwFlags );

/////////////////////////////////////////////////////////////////////////////
// MessageBox routines

int  ConfMsgBox(HWND hwndParent, LPCTSTR pcszMsg, UINT uType=(MB_OK | MB_ICONINFORMATION));
VOID PostConfMsgBox(UINT uStringID);
VOID DisplayMsgIdsParam(int ids, LPCTSTR pcsz);
int  DisplayMsg(LPTSTR pcsz, UINT uType);
VOID DisplayErrMsg(INT_PTR ids);

HWND GetMainWindow();
BOOL FDontShowEnabled(LPCTSTR pszKey);


/////////////////////////////////////////////////////////////////////////////
// Icon utilties
VOID LoadIconImages(void);
VOID FreeIconImages(void);
VOID DrawIconSmall(HDC hdc, int iIcon, int x, int y);

extern HIMAGELIST g_himlIconSmall;

// Create an array that can be easily copied
template <class T>
class CCopyableArray : public CSimpleArray<T>
{
public:
	CCopyableArray()
	{
	}

	CCopyableArray(const CCopyableArray<T>& rhs)
	{
		*this = rhs;
	}

	CCopyableArray<T>& operator=(const CCopyableArray<T>& rhs)
	{
		if (&rhs == this)
		{
			return(*this);
		}

		RemoveAll();

		for (int i=0; i<rhs.GetSize(); ++i)
		{
			Add(rhs[i]);
		}

		return(*this);
	}
} ;

HFONT GetDefaultFont(void);

// Dialog utilities
BOOL FEmptyDlgItem(HWND hdlg, UINT id);
UINT GetDlgItemTextTrimmed(HWND hdlg, int id, PTCHAR psz, int cch);
UINT TrimDlgItemText(HWND hdlg, UINT id);

int  FmtDateTime(LPSYSTEMTIME pst, LPTSTR pszDateTime, int cchMax);

VOID CombineNames(LPTSTR pszResult, int cchResult, LPCTSTR pcszFirst, LPCTSTR pcszLast);

BOOL NMGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);


//--------------------------------------------------------------------------//
//	CDirectoryManager class.												//
//--------------------------------------------------------------------------//
class CDirectoryManager
{
	public:		//	public static methods	--------------------------------//

		static
		const TCHAR * const
		get_DomainDirectory(void);

		static
		const TCHAR * const
		get_defaultServer(void);

		static
		void
		set_defaultServer
		(
			const TCHAR * const	serverName
		);

		static
		bool
		isWebDirectory
		(
			const TCHAR * const	directory = NULL
		);

		static
		const TCHAR * const
		get_dnsName
		(
			const TCHAR * const	name
		);

		static
		const TCHAR * const
		get_displayName
		(
			const TCHAR * const	name
		);

		static
		const TCHAR * const
		loadDisplayName(void);

		static
		void
		get_webDirectoryUrl(LPTSTR szWebDir, int cchmax);

		static
		const TCHAR * const
		get_webDirectoryIls(void);

		static
		bool
		isWebDirectoryEnabled(void);


	private:	//	private static members	--------------------------------//

		static bool		m_webEnabled;
		static TCHAR	m_ils[ MAX_PATH ];
		static TCHAR	m_displayName[ MAX_PATH ];
		static TCHAR	m_displayNameDefault[ MAX_PATH ];
		static TCHAR	m_defaultServer[ MAX_PATH ];
		static TCHAR	m_DomainDirectory[ MAX_PATH ];

};	//	End of class CDirectoryManager.

//--------------------------------------------------------------------------//
#endif /* _CONFUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cplmsg.h ===
#define WM_AUDIOCALIBRATE		WM_USER + 200
#define WM_DONEAUDIOCALIBRATE	WM_USER + 201
#define WM_ENDCALIBRATE			WM_USER + 202
#define WM_CALIBTIMELEFT		WM_USER + 203
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\confwnd.h ===
// File: confwnd.h

#ifndef _CONFWND_H_
#define _CONFWND_H_

#include "GenWindow.h"

class CHiddenWindow : public CGenWindow
{
public:
	CHiddenWindow() : m_fGotDblClick(FALSE) {}

	BOOL Create();

	VOID OnCallStarted();
	VOID OnCallEnded();

protected:
	virtual ~CHiddenWindow() {}

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	POINT m_ptTaskbarClickPos;

	BOOL m_fGotDblClick;
} ;

extern CHiddenWindow * g_pHiddenWnd;
inline HWND GetHiddenWindow()
{
	return g_pHiddenWnd==NULL ? NULL : g_pHiddenWnd->GetWindow();
}

// Hidden window messages:
const UINT WM_CONF_MSG_BOX =            WM_USER + 10;
const UINT WM_CONFOBJ_FLUSH_FRIENDS =   WM_USER + 20;
const UINT WM_FTUI =                    WM_USER + 0x0503;
const UINT WM_STATUSBAR_UPDATE =        WM_USER + 0x0504;

const UINT WM_NM_DISPLAY_MSG =          WM_USER + 0x05FF; // wParam=uType, lParam=pszMsg

const UINT WM_CONF_DROP_KEY =           WM_USER + 0x0600; // wParam=key, lParam=hwnd
const UINT WM_CONF_DROP_CLICK =         WM_USER + 0x0601; // wParam=0, lParam=hwnd

// End Session Hidden window messages:
const UINT WM_TASKBAR_NOTIFY =          WM_USER + 200;

#endif /* _CONFWND_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cr.h ===
/****************************************************************************
*
*    FILE:     CR.h
*
*    PURPOSE:  Conference Room UI interface to external components
*
*    CREATED:  Chris Pirich (ChrisPi) 8-30-95
*
****************************************************************************/

#ifndef _CR_H_
#define _CR_H_

#define	CRUI_TOOLBAR		0x00000100
#define	CRUI_STATUSBAR		0x00000200
#define	CRUI_CALLANIM		0x00000400
#define	CRUI_TITLEBAR		0x00000800
#define	CRUI_TASKBARICON	0x00001000
#define	CRUI_APPICON		0x00002000

#define CRUI_DEFAULT		(CRUI_TOOLBAR | CRUI_STATUSBAR | CRUI_CALLANIM | CRUI_TITLEBAR)

VOID UpdateUI(DWORD dwUIMask, BOOL fPostMsg=FALSE);
#endif // _CR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cplmain.cpp ===
// File: CplMain.cpp

#include "precomp.h"
#include "resource.h"
#include "Conf.h"
#include "ConfCpl.h"
#include "confwnd.h"
#include "ConfPolicies.h"

//*** Global Data *****************************************************

// Global flag keeps setting that changed for windows msg broadcast
DWORD g_dwChangedSettings = 0;

BOOL g_fInOptionsDialog = FALSE;

static const int nMaxPropPages = 7;

INT_PTR CreatePropSheet(HWND hwndOwner, HINSTANCE hInst, int nStartPage)
{
	int pageMap[nMaxPropPages];
	ZeroMemory(&pageMap, sizeof(pageMap));

	PROPSHEETPAGE psp[nMaxPropPages];
	ZeroMemory(&psp, sizeof(psp));

	RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
	RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);

    ASSERT(nStartPage < nMaxPropPages);

    int nPages = 0;

    if (!rePol.GetNumber( REGVAL_POL_NO_GENERALPAGE,
								DEFAULT_POL_NO_GENERALPAGE ))
	{
        pageMap[OPTIONS_GENERAL_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_OPT_GENERAL,
				UserDlgProc);
		ASSERT(nPages <= nMaxPropPages);
	}
	if (!rePol.GetNumber( REGVAL_POL_NO_SECURITYPAGE,
								DEFAULT_POL_NO_SECURITYPAGE ))
	{
		pageMap[OPTIONS_SECURITY_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_SECURITY,
				SecurityDlgProc);
		ASSERT(nPages <= nMaxPropPages);

	}
	if (!rePol.GetNumber( REGVAL_POL_NO_AUDIOPAGE,
								DEFAULT_POL_NO_AUDIOPAGE ) &&
		!rePol.GetNumber( REGVAL_POL_NO_AUDIO,
								DEFAULT_POL_NO_AUDIO) &&
		ISSOUNDCARDPRESENT(reAudio.GetNumber( REGVAL_SOUNDCARDCAPS,
								SOUNDCARD_NONE)) )
	{
        pageMap[OPTIONS_AUDIO_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_AUDIO,
				AudioDlgProc);
		ASSERT(nPages <= nMaxPropPages);
	}
	if (!rePol.GetNumber( REGVAL_POL_NO_VIDEOPAGE,
								DEFAULT_POL_NO_VIDEOPAGE ) &&
		(!rePol.GetNumber( REGVAL_POL_NO_VIDEO_SEND,
								DEFAULT_POL_NO_VIDEO_SEND) ||
		!rePol.GetNumber( REGVAL_POL_NO_VIDEO_RECEIVE,
								DEFAULT_POL_NO_VIDEO_RECEIVE)))
	{
        pageMap[OPTIONS_VIDEO_PAGE] = nPages;
		FillInPropertyPage(&psp[nPages++], IDD_VIDEO,
				VideoDlgProc);
		ASSERT(nPages <= nMaxPropPages);
	}

	// If no pages are allowed, tell the user and get out
	if ( !nPages ) {
		ConfMsgBox ( hwndOwner, (LPCTSTR)IDS_ALLPAGESDISABLED );
		return 0;
	}

	PROPSHEETHEADER psh;
	InitStruct(&psh);

	psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
	psh.hwndParent = hwndOwner;
	psh.hInstance = hInst;
	ASSERT(NULL == psh.hIcon);
	psh.pszCaption = (LPSTR)IDS_CPLNAME;
	psh.nPages = nPages;
	psh.nStartPage = pageMap[nStartPage];
	psh.ppsp = (LPCPROPSHEETPAGE) &psp;

	return (PropertySheet(&psh));
}


/*	L A U N C H  C O N F  C P L  */
/*-------------------------------------------------------------------------
	%%Function: LaunchConfCpl

-------------------------------------------------------------------------*/
VOID LaunchConfCpl(HWND hwnd, int nStartPage)
{

	if (g_fInOptionsDialog)
	{
		return;
	}

	g_fInOptionsDialog = TRUE;
    CreatePropSheet(hwnd, GetInstanceHandle(), nStartPage);
	g_fInOptionsDialog = FALSE;

	// Broadcast change notification if anything changed
	if (g_dwChangedSettings)
	{
		HandleConfSettingsChange(g_dwChangedSettings);
		g_dwChangedSettings = 0;
	}
}

BOOL CanLaunchConfCpl()
{
	return !g_fInOptionsDialog;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\csetting.h ===
/*
 * CSetting.h	conferencing setting change broadcast definitions
 *
 * ClausGi 2-19-96
 *
 */

#ifndef _CSETTING_H_
#define _CSETTING_H_


#define STRCSETTINGMSG	TEXT("ConfSettingsChanged")

///////////////////////////////////////////////////
//
// Registered message with above name contains flag
// field in LPARAM, WPARAM is reserved.
//
// The conferencing control panel applet will broadcast the above
// registered message with the bit fields of the changed settings set.
//
//
// bit definitions follow

#define CSETTING_L_ULSRESTRICTION	0x00000001  // removed
#define CSETTING_L_SHOWTASKBAR		0x00000002
#define CSETTING_L_DIRECTSOUND		0x00000004

#define CSETTING_L_FTDIRECTORY		0x00000008
#define CSETTING_L_BANDWIDTH		0x00000400
#define CSETTING_L_FULLDUPLEX		0x00000800
#define CSETTING_L_AUTOACCEPT		0x00001000
#define CSETTING_L_AUTOACCEPTJOIN	0x00002000

#define CSETTING_L_USEULSSERVER 	0x00010000
#define CSETTING_L_FILETRANSFERMODE 0x00020000
#define CSETTING_L_SD_REFRESH		0x00040000  // removed
#define CSETTING_L_MICSENSITIVITY	0x00080000
#define CSETTING_L_AUTOMIC			0x00100000

#define CSETTING_L_ULSSETTINGS		0x00800000
#define CSETTING_L_AUDIODEVICE		0x02000000
#define CSETTING_L_AGC				0x04000000
#define CSETTING_L_VIDEO			0x08000000
#define CSETTING_L_VIDEOSIZE		0x10000000
#define CSETTING_L_COMMWAIT 		0x20000000
#define CSETTING_L_ICAINTRAY        0x40000000
#define CSETTING_L_CAPTUREDEVICE	0x80000000

// This mask is used by the control panel to decide
// if a restart is necessary. If a setting above is
// being handled fully during notification it should
// be removed from the mask below.

#define CSETTING_L_REQUIRESRESTARTMASK	(0)

#define CSETTING_L_REQUIRESNEXTCALLMASK (0)

// Global flag keeps setting that changed for windows msg broadcast
extern DWORD g_dwChangedSettings;

#endif /* _CSETTING_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN DWORD,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    DWORD               lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC


/////////////////////////////////////////////////////////////

#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    DWORD               lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }

typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN DWORD                lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    DWORD               lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);

//  CertVerifyTrust for WIN16 - like as WinVerifyTrust().
HRESULT
WINAPI CertVerifyTrust16(
    PCCERT_CONTEXT    pcCertToTest,
    DWORD             cCAs,
    HCERTSTORE *      rgCAs,
    DWORD *           pcChain,
    PCCERT_CONTEXT ** prgChain,
    BOOL *            fTrust);
#endif // !WIN16


#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dbgmenu.h ===
// File: dbgmenu.h

#ifndef _DBGMENU_H_
#define _DBGMENU_H_

const int IDM_DEBUG          = 50000; // debug menu ID
const int IDM_DEBUG_FIRST    = 50001; // start of menu item range
const int IDM_DEBUG_LAST     = 50099; // end of menu item range



#define AS_DEBUG_KEY                "Software\\Microsoft\\Conferencing\\AppSharing\\Debug"
#define REGVAL_AS_HATCHSCREENDATA   "HatchScreenData"
#define REGVAL_AS_HATCHBMPORDERS    "HatchBitmapOrders"
#define REGVAL_AS_COMPRESSION       "GDCCompression"
#define REGVAL_AS_VIEWSELF          "ViewOwnSharedStuff"
#define REGVAL_AS_NOFLOWCONTROL     "NoFlowControl"
#define REGVAL_OM_NOCOMPRESSION     "NoOMCompression"

// Base debug option classe
class CDebugOption
{
public:
	int   m_bst; // Current Button State (BST_CHECKED, BST_UNCHECKED, BST_INDETERMINATE)
	PTSTR m_psz; // Text to display

	CDebugOption();
	~CDebugOption();
	CDebugOption(PTSTR psz, int bst = BST_INDETERMINATE);

	virtual void Update(void);
};

// Option checkbox data for modifying a memory flag
class DBGOPTPDW : public CDebugOption
{
public:
	DWORD m_dwMask;    // bit to flip
	DWORD * m_pdw;       // pointer to data

	DBGOPTPDW(PTSTR psz, DWORD dwMask, DWORD * pdw);
	DBGOPTPDW();
	void Update(void);
};


// Option checkbox data for modifying a registry entry
class DBGOPTREG : public CDebugOption
{
public:
	DWORD m_dwMask;    // bit to flip
	DWORD m_dwDefault; // default value
	HKEY  m_hkey;      // key
	PTSTR m_pszSubKey; // subkey
	PTSTR m_pszEntry;  // entry

	DBGOPTREG(PTSTR psz,
		DWORD dwMask,
		DWORD dwDefault,
		PTSTR pszEntry,
		PTSTR pszSubKey = CONFERENCING_KEY,
		HKEY hkey = HKEY_CURRENT_USER);
	~DBGOPTREG();

	void Update(void);
};

// Option checkbox data used explicitly for maintaining compression data.
// Because of the use of static variables, this subclass should not be used
// for any other purpose.

class DBGOPTCOMPRESS : public CDebugOption
{
public:
	static DWORD m_dwCompression;  // actual compression value
	static int m_total;         // total number of instances of this subclass
	static int m_count;         // internally used counter

	static DWORD m_dwDefault;   // default value
	static HKEY  m_hkey;        // key
	static PTSTR m_pszSubKey;   // subkey
	static PTSTR m_pszEntry;    // entry

	BOOL m_bCheckedOn;          // if true, a checked option turns a bit on;
                                // otherwise, it turns a bit off
	DWORD m_dwMask;             // which bits in m_dwCompression to change

	DBGOPTCOMPRESS(PTSTR psz,
		DWORD dwMask,
		BOOL bCheckedOn);
	~DBGOPTCOMPRESS();

	void Update(void);
};

class CDebugMenu
{
public:
	HWND        m_hwnd;
	HMENU       m_hMenu;
	HMENU       m_hMenuDebug;
	HWND        m_hwndDbgopt;

    
	CDebugMenu(VOID);
//	~CDebugMenu(VOID);

	VOID        InitDebugMenu(HWND hwnd);
	BOOL        OnDebugCommand(WPARAM wCmd);

// Member Info Menu Item
	VOID DbgMemberInfo(VOID);
	VOID InitMemberDlg(HWND);
	VOID FillMemberList(HWND);
	VOID ShowMemberInfo(HWND, CParticipant *);

	static INT_PTR CALLBACK DbgListDlgProc(HWND, UINT, WPARAM, LPARAM);

// Version Menu Item
	VOID DbgVersion(VOID);
	BOOL DlgVersionMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgVersionDlgProc(HWND, UINT, WPARAM, LPARAM);

	BOOL InitVerDlg(HWND);
	BOOL FillVerList(HWND);
	VOID ShowVerInfo(HWND, LPSTR *, int);


// Debug Options Menu Item
	VOID DbgOptions(VOID);
	BOOL DlgOptionsMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgOptionsDlgProc(HWND, UINT, WPARAM, LPARAM);

	VOID InitOptionsData(HWND);
	VOID AddDbgOptions(LV_ITEM *);
	VOID AddASOptions(LV_ITEM *);

// Debug Zones Menu Item
	VOID DbgChangeZones(VOID);
	VOID AddZones(LV_ITEM *);
	VOID InitZonesData(HWND);
	VOID SaveZonesData(VOID);
	BOOL DlgZonesMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgZonesDlgProc(HWND, UINT, WPARAM, LPARAM);

// System Policy Menu Item
	VOID DbgSysPolicy(VOID);
	VOID InitPolicyData(HWND hDlg);
	VOID AddPolicyOptions(LV_ITEM *);
	BOOL DlgPolicyMsg(HWND, UINT, WPARAM, LPARAM);
	static INT_PTR CALLBACK DbgPolicyDlgProc(HWND, UINT, WPARAM, LPARAM);

// User Interface Menu Item
	VOID DbgUI(VOID);
	VOID InitUIData(HWND hDlg);
	VOID AddUIOptions(LV_ITEM *);
	static INT_PTR CALLBACK DbgUIDlgProc(HWND, UINT, WPARAM, LPARAM);

// General Dialog-Checkbox functions
	BOOL InitOptionsDlg(HWND);
	BOOL SaveOptionsData(HWND);
	VOID FreeOptionsData(HWND);
	VOID ToggleOption(LV_ITEM *);
	VOID OnNotifyDbgopt(LPARAM);

	VOID AddOption(LV_ITEM * plvItem, CDebugOption * pDbgOpt);
	VOID AddOptionPdw(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, DWORD * pdw);
	VOID AddOptionReg(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, DWORD dwDefault,
		PTSTR pszEntry, PTSTR pszSubKey, HKEY hkey);
	VOID CDebugMenu::AddOptionCompress(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, BOOL bCheckedOn);
	VOID AddOptionSection(LV_ITEM* plvItem, PTSTR psz);
};

// Global Interface
#ifdef DEBUG
VOID InitDbgMenu(HWND hwnd);
VOID FreeDbgMenu(void);
BOOL OnDebugCommand(WPARAM wCmd);
#else
#define InitDbgMenu(hwnd)
#define FreeDbgMenu()
#endif

#endif // _DBGMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dbgfiles.h ===
/* DbgFiles.h  - module file names */


/*** OPRAH files ***/
static LPTSTR _rgszModuleOprah[] = {
TEXT("conf.exe"),
TEXT("msconf.dll"),
TEXT("msconfft.dll"),
TEXT("msconfwb.dll"),
TEXT("nmcom.dll"),
TEXT("nminf.dll"),
TEXT("nmwb.dll"),
TEXT("mnmcpi32.dll"),
TEXT("mst120.dll"),
TEXT("nmasn1.dll"),
TEXT("ils.dll"),
TEXT("nmpgmgrp.exe"),
TEXT("nmexchex.exe"),
TEXT("mnmsrvc.exe"),
};

// Audio specific files
static LPTSTR _rgszModuleAudio[] = {
TEXT("dcap32.dll"),
TEXT("h323cc.dll"),
TEXT("lhacm.acm"),
TEXT("nac.dll"),
TEXT("rrcm.dll"),
TEXT("h245.dll"),
TEXT("h245ws.dll"),
TEXT("callcont.dll"),
TEXT("msica.dll"),
};



/*** Windows files ***/
static LPTSTR _rgszModuleWin95[] = {
TEXT("gdi.exe"),
TEXT("user.exe"),
TEXT("krnl386.exe"),
TEXT("comctl32.dll"),
TEXT("user32.dll"),
TEXT("gdi32.dll"),
TEXT("kernel32.dll"),
TEXT("wldap32.dll"),
};


typedef struct tagDbgMod {
        LPSTR * rgsz;
        int     cFiles;
        BOOL    fShow;
        DWORD   id;
} DBGMOD;


DBGMOD _rgModules[] = {
{_rgszModuleOprah,    ARRAY_ELEMENTS(_rgszModuleOprah),    TRUE, IDC_DBG_VER_OPRAH},
{_rgszModuleAudio,    ARRAY_ELEMENTS(_rgszModuleAudio),    TRUE, IDC_DBG_VER_AUDIO},
{_rgszModuleWin95,    ARRAY_ELEMENTS(_rgszModuleWin95),    FALSE, IDC_DBG_VER_WINDOWS},
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dbgmenu.cpp ===
/****************************************************************************
*
*    FILE:     DbgMenu.cpp
*
*    CREATED:  Robert Donner (RobD) 2-04-96
*
*    CONTENTS: CDebugMenu object
*
****************************************************************************/

/*
	To add a debug menu option:
		1) Add the text to _rgDbgSz
		2) Add a function call to OnDebugCommand

	To add a checkbox in the debug options dialog:
		2) Use either AddOptionReg or AddOptionPdw with appropriate parameters

	To add a file to the version list
		1) Edit dbgfiles.txt
*/

#include "precomp.h"

#include "particip.h"
#include "DbgMenu.h"
#include "confroom.h"
#include "conf.h"
#include "version.h"
#include "pfnver.h"
#include "dlgacd.h"

#include <ConfCpl.h>

#ifdef DEBUG /*** THIS WHOLE FILE ***/

#include "DbgFiles.h"  // List of files for version info

#include "..\..\core\imember.h"   // for CNmMember
#include "..\..\as\h\gdc.h"       // for GCT compression stuff

CDebugMenu * g_pDbgMenu = NULL;
HWND ghwndVerList;

////////////////////////////
// Local Function Prototypes
VOID DbgSplash(HWND hwnd);
VOID DbgTest2(void);
VOID DbgTest3(void);

VOID DbgWizard(BOOL fVisible);
VOID DbgBreak(void);

VOID UpdateCrtDbgSettings(void);
VOID InitNmDebugOptions(void);
VOID SaveNmDebugOptions(void);

/*** Globals ***/
extern DWORD g_fDisplayFPS;        // vidview.cpp
extern DWORD g_fDisplayViewStatus; // statbar.cpp
extern DWORD g_dwPlaceCall;        // controom.cpp

#define iDbgChecked 1
#define iDbgUnchecked 2
DWORD  _dwDebugModuleFlags;



/*** Debug Menu Data ***/

enum {
	IDM_DBG_OPTIONS = IDM_DEBUG_FIRST,
	IDM_DBG_ZONES,
	IDM_DBG_POLICY,
	IDM_DBG_UI,
	IDM_DBG_VERSION,
	IDM_DBG_MEMBERS,
	IDM_DBG_WIZARD,
	IDM_DBG_BREAK,
	IDM_DBG_SPLASH,
	IDM_DBG_TEST2,
	IDM_DBG_TEST3
};


static DWSTR _rgDbgMenu[] = {
	IDM_DBG_OPTIONS, TEXT("Debug Options..."),
	IDM_DBG_ZONES,   TEXT("Zones..."),
	IDM_DBG_POLICY,  TEXT("System Policies..."),
	IDM_DBG_UI,      TEXT("User Interface..."),
	0, NULL,
	IDM_DBG_VERSION, TEXT("Version Info..."),
	IDM_DBG_MEMBERS, TEXT("Member Info..."),
	0, NULL,
	IDM_DBG_WIZARD,  TEXT("Run Wizard"),
	IDM_DBG_BREAK,   TEXT("Break"),
	0, NULL,
	IDM_DBG_SPLASH,  TEXT("Show/Hide Splash Screen"),
	IDM_DBG_TEST2,   TEXT("Test 2"),
	IDM_DBG_TEST3,   TEXT("Test 3"),
};


BOOL CDebugMenu::OnDebugCommand(WPARAM wCmd)
{
	switch (wCmd)
		{
	case IDM_DBG_OPTIONS: DbgOptions();     break;
	case IDM_DBG_ZONES:   DbgChangeZones(); break;
	case IDM_DBG_POLICY:  DbgSysPolicy();   break;
	case IDM_DBG_UI:      DbgUI();          break;
	case IDM_DBG_VERSION: DbgVersion();     break;
	case IDM_DBG_MEMBERS: DbgMemberInfo();  break;
	case IDM_DBG_WIZARD:  DbgWizard(TRUE);  break;
	case IDM_DBG_BREAK:   DbgBreak();       break;
	case IDM_DBG_SPLASH:  DbgSplash(m_hwnd);break;
	case IDM_DBG_TEST2:   DbgTest2();       break;
	case IDM_DBG_TEST3:   DbgTest3();       break;
	default: break;
		}

	return TRUE;
}




/*** Version Info Data ***/


// FUTURE: Merge these into a single structure
#define cVerInfo 11
#define VERSION_INDEX 3

static PTSTR _rgszVerInfo[cVerInfo] = {
TEXT("InternalName"),
TEXT("Size"),
TEXT("Date"),
TEXT("FileVersion"),
TEXT("FileDescription"),
TEXT("CompanyName"),
TEXT("LegalCopyright"),
TEXT("ProductName"),
TEXT("ProductVersion"),
TEXT("InternalName"),
TEXT("OriginalFilename")
};


static PTSTR _rgVerTitle[cVerInfo] = {
TEXT("Filename"),
TEXT("Size"),
TEXT("Date"),
TEXT("Version"),
TEXT("Description"),
TEXT("Company"),
TEXT("Trademark"),
TEXT("Product"),
TEXT("Version"),
TEXT("Name"),
TEXT("File")
};


static int _rgVerWidth[cVerInfo] = {
 70,
 70,
 70,
 70,
 200,
 70,
 70,
 70,
 70,
 70,
 70
};

static TCHAR _szStringFileInfo[] = TEXT("StringFileInfo");
static TCHAR _szVerIntlUSA[]     = TEXT("040904E4");
static TCHAR _szVerIntlAlt[]     = TEXT("040904B0");
static TCHAR _szVerFormat[]      = TEXT("\\%s\\%s\\%s");


/*** Debug Option Checkboxes ***/

#define DEBUG_DFL_ENABLE_TRACE_MESSAGES  0x0001
#define DEBUG_DFL_LOG_TRACE_MESSAGES     0x0002
#define DEBUG_DFL_DUMP_THREAD_ID         0x0004
#define DEBUG_DFL_ENABLE_CALL_TRACING    0x0008
#define DEBUG_DFL_DUMP_TIME              0x0010
#define DEBUG_DFL_INDENT                 0x2000

/* Static members of DBGOPTCOMPRESS class */

int DBGOPTCOMPRESS::m_total = 0;     // total number of instances of this subclass
int DBGOPTCOMPRESS::m_count = 0;     // internally used counter

DWORD DBGOPTCOMPRESS::m_dwCompression;               // actual compression value
DWORD DBGOPTCOMPRESS::m_dwDefault = GCT_DEFAULT;     // default value
HKEY  DBGOPTCOMPRESS::m_hkey = HKEY_LOCAL_MACHINE;   // key
PTSTR DBGOPTCOMPRESS::m_pszSubKey = AS_DEBUG_KEY;    // subkey
PTSTR DBGOPTCOMPRESS::m_pszEntry = REGVAL_AS_COMPRESSION;   // entry

VOID ShowDbgView(void)
{
	if (ShellExecute(NULL, NULL, "dbgview.exe", NULL, NULL, SW_SHOW) <= (HINSTANCE) 32)
	{
		ConfMsgBox(NULL, TEXT("Unable to start 'DbgView.exe'"));
	}
}



/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   CDebugMenu()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CDebugMenu::CDebugMenu(VOID):
	m_hwnd(NULL),
	m_hMenu(NULL),
	m_hMenuDebug(NULL)
{
	DebugEntry(CDebugMenu::CDebugMenu);

	DebugExitVOID(CDebugMenu::CDebugMenu);
}


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   InitDebugMenu()
*
*    PURPOSE:  Puts debug menu options on the menu bar
*
****************************************************************************/

VOID CDebugMenu::InitDebugMenu(HWND hwnd)
{
	m_hwnd = hwnd;
	if (NULL == hwnd)
		return;

	m_hMenu = GetMenu(hwnd);
	if (NULL == m_hMenu)
		return;

	m_hMenuDebug = CreateMenu();
	if (NULL == m_hMenuDebug)
		return;

	
	for (int i = 0; i < ARRAY_ELEMENTS(_rgDbgMenu); i++)
	{
		if (0 == _rgDbgMenu[i].dw)
		{
			AppendMenu(m_hMenuDebug, MF_SEPARATOR, 0, 0);
		}
		else if (!AppendMenu(m_hMenuDebug, MF_STRING | MF_ENABLED,
				_rgDbgMenu[i].dw, _rgDbgMenu[i].psz))
		{
			return;
		}
	}

	AppendMenu(m_hMenu, MF_POPUP, (UINT_PTR) m_hMenuDebug, TEXT(" "));
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  O P T I O N S
/////////////////////////////////////////////////////////////////////////////

/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgOptions()
*
*    PURPOSE:  Brings up the debug options dialog box
*
****************************************************************************/

VOID CDebugMenu::DbgOptions(VOID)
{
	DebugEntry(CDebugMenu::DbgOptions);

	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgOptionsDlgProc, (LPARAM) this);

	DebugExitVOID(CDebugMenu::DbgOptions);
}


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgOptionsDlgProc()
*
*    PURPOSE:  Dialog Proc for debug options
*
****************************************************************************/

INT_PTR CALLBACK CDebugMenu::DbgOptionsDlgProc(HWND hDlg, UINT uMsg,
											WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitOptionsData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgOptionsMsg(hDlg, uMsg, wParam, lParam);
}


/*  I N I T  O P T I O N S  D L G */
/*----------------------------------------------------------------------------
    %%Function: InitOptionsDlg

----------------------------------------------------------------------------*/
BOOL CDebugMenu::InitOptionsDlg(HWND hDlg)
{
	m_hwndDbgopt = GetDlgItem(hDlg, IDL_DEBUG);
	if (NULL == m_hwndDbgopt)
		return FALSE;

	/* Initialize the list view images */
	{

		HICON hCheckedIcon = LoadIcon(GetInstanceHandle(), MAKEINTRESOURCE(IDI_CHECKON));
		HICON hUncheckedIcon = LoadIcon(GetInstanceHandle(), MAKEINTRESOURCE(IDI_CHECKOFF));
		HIMAGELIST hStates = ImageList_Create(16, 16, ILC_MASK, 2, 2);
		if ((NULL == hStates) || (NULL == hCheckedIcon) || (NULL == hUncheckedIcon))
		{
			return FALSE;
		}

		ImageList_AddIcon(hStates, hCheckedIcon);
		ImageList_AddIcon(hStates, hUncheckedIcon);

		// Associate the image list with the list view
		ListView_SetImageList(m_hwndDbgopt, hStates, LVSIL_STATE);
	}

	/* Initialize the column structure */
	{
		LV_COLUMN lvC;
		RECT rc;

		GetClientRect(m_hwndDbgopt, &rc);

		ZeroMemory(&lvC, sizeof(lvC));
		lvC.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH | LVCF_TEXT;
		lvC.fmt = LVCFMT_LEFT;
		lvC.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL)
							- GetSystemMetrics(SM_CXSMICON)
							- 2 * GetSystemMetrics(SM_CXEDGE);

		// Add the column.
		if (-1 == ListView_InsertColumn(m_hwndDbgopt, 0, &lvC))
		{
			ERROR_OUT(("Could not insert column in list view"));
			return FALSE;
		}
	}

	return TRUE;
}


VOID CDebugMenu::InitOptionsData(HWND hDlg)
{
	LV_ITEM lvI;

	// Fill in the LV_ITEM structure
	// The mask specifies the the .pszText, .iImage, .lParam and .state
	// members of the LV_ITEM structure are valid.

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddDbgOptions(&lvI);
	AddASOptions(&lvI);
}



/*  A D D  O P T I O N */
/*----------------------------------------------------------------------------
    %%Function: AddOption

	Add an option line to the listbox
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOption(LV_ITEM * plvItem, CDebugOption * pDbgOpt)
{
	plvItem->pszText = pDbgOpt->m_psz;
	plvItem->lParam = (LPARAM) pDbgOpt;
	plvItem->state &= ~LVIS_STATEIMAGEMASK;

	if (BST_CHECKED == pDbgOpt->m_bst)
		plvItem->state |= INDEXTOSTATEIMAGEMASK(iDbgChecked);
	else if (BST_UNCHECKED == pDbgOpt->m_bst)
		plvItem->state |= INDEXTOSTATEIMAGEMASK(iDbgUnchecked);

	if (-1 == ListView_InsertItem(m_hwndDbgopt, plvItem))
	{
		ERROR_OUT(("problem adding item entry to list view"));
	}
	else
	{
		plvItem->iItem++;
	}
}


/*  A D D  O P T I O N  S E C T I O N */
/*----------------------------------------------------------------------------
    %%Function: AddOptionSection

	Add a simple section title
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionSection(LV_ITEM* plvItem, PTSTR psz)
{
	CDebugOption * pDbgOpt = new CDebugOption(psz);
	if (NULL != pDbgOpt)
		AddOption(plvItem, pDbgOpt);
}


/*  A D D  O P T I O N  P D W */
/*----------------------------------------------------------------------------
    %%Function: AddOptionPdw

	Add an option (global memory flag)
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionPdw(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, DWORD * pdw = &_dwDebugModuleFlags)
{
	DBGOPTPDW * pDbgOpt = new DBGOPTPDW(psz, dwMask, pdw);
	if (NULL != pDbgOpt)
		AddOption(plvItem, (CDebugOption * ) pDbgOpt);
}

/*  A D D  O P T I O N  R E G */
/*----------------------------------------------------------------------------
    %%Function: AddOptionReg

	Add a registry option
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionReg(LV_ITEM* plvItem, PTSTR psz, DWORD dwMask, DWORD dwDefault,
	PTSTR pszEntry, PTSTR pszSubKey = CONFERENCING_KEY, HKEY hkey = HKEY_CURRENT_USER)
{
	DBGOPTREG * pDbgOpt = new DBGOPTREG(psz, dwMask, dwDefault, pszEntry, pszSubKey, hkey);
	if (NULL != pDbgOpt)
		AddOption(plvItem, (CDebugOption * ) pDbgOpt);
}

/*  A D D  O P T I O N  C O M P R E S S */
/*----------------------------------------------------------------------------
    %%Function: AddOptionCompress

	Add an option (compression data)
----------------------------------------------------------------------------*/
VOID CDebugMenu::AddOptionCompress(LV_ITEM * plvItem, PTSTR psz, DWORD dwMask, BOOL bCheckedOn)
{
	DBGOPTCOMPRESS * pDbgOpt = new DBGOPTCOMPRESS(psz, dwMask, bCheckedOn);
	if (NULL != pDbgOpt)
		AddOption(plvItem, (CDebugOption * ) pDbgOpt);
}

VOID CDebugMenu::AddDbgOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____Debug Output____"));

	AddOptionReg(plvItem, TEXT("Use OutputDebugString"), 1,DEFAULT_DBG_OUTPUT,
		REGVAL_DBG_OUTPUT, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Output to Window"), 1, DEFAULT_DBG_NO_WIN,
		REGVAL_DBG_WIN_OUTPUT, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Ouput to File"), 1, DEFAULT_DBG_NO_FILE,
		REGVAL_DBG_FILE_OUTPUT, DEBUG_KEY, HKEY_LOCAL_MACHINE);

	AddOptionReg(plvItem, TEXT("Show ThreadId"), 1, 0,
		REGVAL_DBG_SHOW_THREADID, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Show Module Name"), 1, 0,
		REGVAL_DBG_SHOW_MODULE, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Enable Retail Log Output"), 1, 0,
		REGVAL_RETAIL_LOG, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Show Time"), 1, 0,
		REGVAL_DBG_SHOW_TIME, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Format Time"), 2, 0,
		REGVAL_DBG_SHOW_TIME, DEBUG_KEY, HKEY_LOCAL_MACHINE);

	_dwDebugModuleFlags = GetDebugOutputFlags();
	AddOptionPdw(plvItem, TEXT("Function Level Indenting (conf)"),DEBUG_DFL_INDENT);
}

VOID CDebugMenu::AddPolicyOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____Calling____"));
    AddOptionReg(plvItem, TEXT("No Auto-Accept"), 1, DEFAULT_POL_NO_AUTOACCEPTCALLS, REGVAL_POL_NO_AUTOACCEPTCALLS, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Do not allow directory services"), 1, DEFAULT_POL_NO_DIRECTORY_SERVICES, REGVAL_POL_NO_DIRECTORY_SERVICES, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Adding Directory Servers"), 1, 0, REGVAL_POL_NO_ADDING_NEW_ULS, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("No changing Call mode"), 1, 0, REGVAL_POL_NOCHANGECALLMODE, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("No web directory"), 1, 0, REGVAL_POL_NO_WEBDIR, POLICIES_KEY);
	
	AddOptionSection(plvItem, TEXT("____Applets____"));
	AddOptionReg(plvItem, TEXT("No Chat"), 1, DEFAULT_POL_NO_CHAT, REGVAL_POL_NO_CHAT, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Old Whiteboard"), 1, DEFAULT_POL_NO_OLDWHITEBOARD, REGVAL_POL_NO_OLDWHITEBOARD, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("No New Whiteboard"), 1, DEFAULT_POL_NO_NEWWHITEBOARD, REGVAL_POL_NO_NEWWHITEBOARD, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No File Transfer Send"), 1, DEFAULT_POL_NO_FILETRANSFER_SEND, REGVAL_POL_NO_FILETRANSFER_SEND, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No File Transfer Receive"), 1, DEFAULT_POL_NO_FILETRANSFER_RECEIVE, REGVAL_POL_NO_FILETRANSFER_RECEIVE, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Audio"), 1, DEFAULT_POL_NO_AUDIO, REGVAL_POL_NO_AUDIO, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Video Send"), 1, DEFAULT_POL_NO_VIDEO_SEND, REGVAL_POL_NO_VIDEO_SEND, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("No Video Receive"), 1, DEFAULT_POL_NO_VIDEO_RECEIVE, REGVAL_POL_NO_VIDEO_RECEIVE, POLICIES_KEY);

	AddOptionSection(plvItem, TEXT("____Sharing____"));
	AddOptionReg(plvItem, TEXT("Disable all Sharing features"), 1, DEFAULT_POL_NO_APP_SHARING, REGVAL_POL_NO_APP_SHARING, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Prevent the user from sharing"), 1, DEFAULT_POL_NO_SHARING, REGVAL_POL_NO_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable sharing MS-DOS windows"), 1, DEFAULT_POL_NO_MSDOS_SHARING, REGVAL_POL_NO_MSDOS_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable sharing explorer windows"), 1, DEFAULT_POL_NO_EXPLORER_SHARING, REGVAL_POL_NO_EXPLORER_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable sharing the desktop"), 1, DEFAULT_POL_NO_DESKTOP_SHARING, REGVAL_POL_NO_DESKTOP_SHARING, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Disable sharing in true color"), 1, DEFAULT_POL_NO_TRUECOLOR_SHARING, REGVAL_POL_NO_TRUECOLOR_SHARING, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Prevent the user from allowing control"), 1, DEFAULT_POL_NO_ALLOW_CONTROL, REGVAL_POL_NO_ALLOW_CONTROL, POLICIES_KEY);

	AddOptionSection(plvItem, TEXT("____Options Dialog____"));
	AddOptionReg(plvItem, TEXT("Disable the 'General' page"), 1, DEFAULT_POL_NO_GENERALPAGE, REGVAL_POL_NO_GENERALPAGE, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Disable the 'Advanced Calling' button"), 1, DEFAULT_POL_NO_ADVANCEDCALLING, REGVAL_POL_NO_ADVANCEDCALLING, POLICIES_KEY);
    AddOptionReg(plvItem, TEXT("Disable the 'Security' page"), 1, DEFAULT_POL_NO_SECURITYPAGE, REGVAL_POL_NO_SECURITYPAGE, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable the 'Audio' page"), 1, DEFAULT_POL_NO_AUDIOPAGE, REGVAL_POL_NO_AUDIOPAGE, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable the 'Video' page"), 1, DEFAULT_POL_NO_VIDEOPAGE, REGVAL_POL_NO_VIDEOPAGE, POLICIES_KEY);

	AddOptionSection(plvItem, TEXT("____Audio / NAC____"));
    AddOptionReg(plvItem, TEXT("No changing Direct Sound usage"), 1, 0, REGVAL_POL_NOCHANGE_DIRECTSOUND, POLICIES_KEY);
	AddOptionReg(plvItem, TEXT("Disable WinSock2"), 1, 0, REGVAL_DISABLE_WINSOCK2, NACOBJECT_KEY, HKEY_LOCAL_MACHINE);

}



VOID CDebugMenu::AddASOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____Application Sharing____"));
	AddOptionReg(plvItem, TEXT("Hatch Screen Data"), 1, 0, REGVAL_AS_HATCHSCREENDATA, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
    AddOptionReg(plvItem, TEXT("Hatch Bitmap Orders"), 1, 0, REGVAL_AS_HATCHBMPORDERS, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionCompress(plvItem, TEXT("Disable AS persist compression"), GCT_PERSIST_PKZIP, FALSE),
	AddOptionCompress(plvItem, TEXT("Disable AS compression"), GCT_PKZIP, FALSE);
    AddOptionReg(plvItem, TEXT("View own shared apps"), 1, 0, REGVAL_AS_VIEWSELF, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
    AddOptionReg(plvItem, TEXT("No AS Flow Control"), 1, 0, REGVAL_AS_NOFLOWCONTROL, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);
    AddOptionReg(plvItem, TEXT("Disable OM compression"), 1, 0, REGVAL_OM_NOCOMPRESSION, AS_DEBUG_KEY, HKEY_LOCAL_MACHINE);

}


VOID CDebugMenu::AddUIOptions(LV_ITEM * plvItem)
{
	AddOptionSection(plvItem, TEXT("____User Interface____"));
	AddOptionReg(plvItem, TEXT("Call Progress TopMost"), 1, DEFAULT_DBG_CALLTOP, REGVAL_DBG_CALLTOP, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionPdw(plvItem, TEXT("Display Frames Per Second"), 1, &g_fDisplayFPS);
	AddOptionPdw(plvItem, TEXT("Display View Status"), 1, &g_fDisplayViewStatus);
	AddOptionReg(plvItem, TEXT("Right to Left Layout"), 1, DEFAULT_DBG_RTL, REGVAL_DBG_RTL, DEBUG_KEY, HKEY_LOCAL_MACHINE);
	AddOptionReg(plvItem, TEXT("Fake CallTo"), 1, DEFAULT_DBG_FAKE_CALLTO, REGVAL_DBG_FAKE_CALLTO, DEBUG_KEY, HKEY_LOCAL_MACHINE);

	AddOptionSection(plvItem, TEXT("____Place a Call____"));
	AddOptionPdw(plvItem, TEXT("No ILS Filter"),      nmDlgCallNoFilter,    &g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No Server Edit"),     nmDlgCallNoServerEdit,&g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No ILS View"),        nmDlgCallNoIls,       &g_dwPlaceCall);
#if USE_GAL
	AddOptionPdw(plvItem, TEXT("No GAL View"),        nmDlgCallNoGal,       &g_dwPlaceCall);
#endif // #if USE_GAL
	AddOptionPdw(plvItem, TEXT("No WAB View"),        nmDlgCallNoWab,       &g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No Speed Dial View"), nmDlgCallNoSpeedDial, &g_dwPlaceCall);
	AddOptionPdw(plvItem, TEXT("No History View"),    nmDlgCallNoHistory,   &g_dwPlaceCall);
}



/*  T O G G L E  O P T I O N */
/*----------------------------------------------------------------------------
    %%Function: ToggleOption

	Toggle the checkbox for an option
----------------------------------------------------------------------------*/
VOID CDebugMenu::ToggleOption(LV_ITEM * plvI)
{
	UINT state = plvI->state & LVIS_STATEIMAGEMASK;

	if (0 == state)
		return; // nothing to toggle

	plvI->state &= ~LVIS_STATEIMAGEMASK;
	if (state == (UINT) INDEXTOSTATEIMAGEMASK(iDbgChecked))
	{
		((CDebugOption *) (plvI->lParam))->m_bst = BST_UNCHECKED;
		plvI->state |= INDEXTOSTATEIMAGEMASK(iDbgUnchecked);
	}
	else
	{
		((CDebugOption *) (plvI->lParam))->m_bst = BST_CHECKED;
		plvI->state |= INDEXTOSTATEIMAGEMASK(iDbgChecked);
	}

	if (!ListView_SetItem(m_hwndDbgopt, plvI))
	{
		ERROR_OUT(("error setting listview item info"));
	}
}


/*  S A V E  O P T I O N S  D A T A */
/*----------------------------------------------------------------------------
    %%Function: SaveOptionsData

	Save all of the data by calling the Update routine of each item
----------------------------------------------------------------------------*/
BOOL CDebugMenu::SaveOptionsData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_PARAM | LVIF_STATE;
	lvI.stateMask = LVIS_STATEIMAGEMASK;

	while (ListView_GetItem(m_hwndDbgopt, &lvI))
	{
		CDebugOption * pDbgOpt = (CDebugOption *) lvI.lParam;
		if (NULL != pDbgOpt)
		{
			pDbgOpt->Update();
		}
		lvI.iItem++;
	}

	return TRUE;
}


/*  F R E E  O P T I O N S  D A T A */
/*----------------------------------------------------------------------------
    %%Function: FreeOptionsData

	Free any allocated data associated with the options list
----------------------------------------------------------------------------*/
VOID CDebugMenu::FreeOptionsData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
//	lvI.iItem = 0;
//	lvI.iSubItem = 0;
	lvI.mask = LVIF_PARAM | LVIF_STATE;
	lvI.stateMask = LVIS_STATEIMAGEMASK;

	while (ListView_GetItem(m_hwndDbgopt, &lvI))
	{
		CDebugOption * pDbgOpt = (CDebugOption *) lvI.lParam;
		if (NULL != pDbgOpt)
		{
			delete pDbgOpt;
		}
		lvI.iItem++;
	}
}


/*  O N  N O T I F Y  D B G O P T */
/*----------------------------------------------------------------------------
    %%Function: OnNotifyDbgopt

	Handle any notifications for the debug options dialog
----------------------------------------------------------------------------*/
VOID CDebugMenu::OnNotifyDbgopt(LPARAM lParam)
{
	NM_LISTVIEW FAR * lpnmlv = (NM_LISTVIEW FAR *)lParam;
	ASSERT(NULL != lpnmlv);
	
	switch (lpnmlv->hdr.code)
		{
	case LVN_KEYDOWN:
	{
		LV_ITEM lvI;
		LV_KEYDOWN * lplvkd = (LV_KEYDOWN *)lParam;

		if (lplvkd->wVKey == VK_SPACE)
		{
			ZeroMemory(&lvI, sizeof(lvI));
			lvI.iItem = ListView_GetNextItem(m_hwndDbgopt, -1, LVNI_FOCUSED|LVNI_SELECTED);
//			lvI.iSubItem = 0;
			lvI.mask = LVIF_PARAM | LVIF_STATE;
			lvI.stateMask = LVIS_STATEIMAGEMASK;

			if (ListView_GetItem(m_hwndDbgopt, &lvI))
			{
				ToggleOption(&lvI);
			}
		}
		break;
	}

	case NM_DBLCLK:
	case NM_CLICK:
	{
		LV_ITEM lvI;
		LV_HITTESTINFO lvH;
		int idx;

		ZeroMemory(&lvH, sizeof(lvH));
		GetCursorPos(&lvH.pt);
		ScreenToClient(m_hwndDbgopt, &lvH.pt);

		if ((NM_CLICK == lpnmlv->hdr.code) && ((UINT) lvH.pt.x) > 16)
			break;

		idx = ListView_HitTest(m_hwndDbgopt, &lvH);
		if (-1 == idx)
			break;

		ZeroMemory(&lvI, sizeof(lvI));
		lvI.iItem = idx;
//		lvI.iSubItem = 0;
		lvI.stateMask = LVIS_STATEIMAGEMASK;
		lvI.mask = LVIF_PARAM | LVIF_STATE;

		if (ListView_GetItem(m_hwndDbgopt, &lvI))
		{
			ToggleOption(&lvI);
		}
		break;
	}

	default:
		break;
		}
}


/*  D L G  O P T I O N S  M S G */
/*----------------------------------------------------------------------------
    %%Function: DlgOptionsMsg

----------------------------------------------------------------------------*/
BOOL CDebugMenu::DlgOptionsMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDB_SHOWDBG:
		{
			ShowDbgView();
			return TRUE;
		}

		case IDOK:
			SaveOptionsData(hwnd);
			SetDebugOutputFlags(_dwDebugModuleFlags);
			SetDbgFlags();
			UpdateCrtDbgSettings();
			SaveNmDebugOptions();
			// fall thru to IDCANCEL

		case IDCANCEL:
		{
			FreeOptionsData(hwnd);			
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	case WM_NOTIFY:
		if (IDL_DEBUG == wParam)
			OnNotifyDbgopt(lParam);
		break;

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}



CDebugOption::CDebugOption()
{
}

CDebugOption::CDebugOption(PTSTR psz, int bst)
{
	m_psz = psz;
	m_bst = bst;
}
CDebugOption::~CDebugOption()
{
}

VOID CDebugOption::Update(void)
{
}

DBGOPTPDW::DBGOPTPDW(PTSTR psz, DWORD dwMask, DWORD * pdw)
 : CDebugOption(psz)
{
	m_psz = psz;
	m_dwMask = dwMask;
	m_pdw =pdw;
	m_bst = IS_FLAG_SET(*m_pdw, m_dwMask) ? BST_CHECKED : BST_UNCHECKED;
}

void DBGOPTPDW::Update(void)
{
	if (BST_CHECKED == m_bst)
		SET_FLAG(*m_pdw, m_dwMask);
	else if (BST_UNCHECKED == m_bst)
		CLEAR_FLAG(*m_pdw, m_dwMask);
}

DBGOPTREG::DBGOPTREG(PTSTR psz, DWORD dwMask, DWORD dwDefault,
		PTSTR pszEntry, PTSTR pszSubKey, HKEY hkey)
 : CDebugOption(psz)
{
	m_psz = psz;
	m_dwMask = dwMask;
	m_dwDefault = dwDefault;
	m_pszEntry = pszEntry;
	m_pszSubKey = pszSubKey;
	m_hkey = hkey;

	RegEntry re(m_pszSubKey, m_hkey);
	DWORD dw = re.GetNumber(m_pszEntry, m_dwDefault);
	m_bst = IS_FLAG_SET(dw, m_dwMask) ? BST_CHECKED : BST_UNCHECKED;
};

DBGOPTREG::~DBGOPTREG()
{
}


void DBGOPTREG::Update(void)
{
	RegEntry re(m_pszSubKey, m_hkey);
	DWORD dw = re.GetNumber(m_pszEntry, m_dwDefault);
	if (BST_CHECKED == m_bst)
		SET_FLAG(dw, m_dwMask);
	else if (BST_UNCHECKED == m_bst)
		CLEAR_FLAG(dw, m_dwMask);

	re.SetValue(m_pszEntry, dw);
}

DBGOPTCOMPRESS::DBGOPTCOMPRESS(PTSTR psz, DWORD dwMask, BOOL bCheckedOn)
 : CDebugOption(psz)
{
	m_psz = psz;
	m_total++;				// count how many instances we are creating
	m_dwMask = dwMask;
	m_bCheckedOn = bCheckedOn;

	RegEntry re(m_pszSubKey, m_hkey);

	if (m_total == 1)		// we only need to read the registry entry once
		m_dwCompression = re.GetNumber(m_pszEntry, m_dwDefault);

	if (m_bCheckedOn == TRUE)		// check or uncheck the box depending on the semantics
		m_bst = IS_FLAG_SET(m_dwCompression, m_dwMask) ? BST_CHECKED : BST_UNCHECKED;
	else
		m_bst = IS_FLAG_SET(m_dwCompression, m_dwMask) ? BST_UNCHECKED : BST_CHECKED;

}

void DBGOPTCOMPRESS::Update(void)
{
	m_count++;					// count number of times this function has been executed

	if (m_bCheckedOn == TRUE)
	{		// set or clear flag depending on semantics and whether the
		if (BST_CHECKED == m_bst)	// user checked the option box
			SET_FLAG(m_dwCompression, m_dwMask);
		else if (BST_UNCHECKED == m_bst)
			CLEAR_FLAG(m_dwCompression, m_dwMask);
	}
	else
	{
		if (BST_CHECKED == m_bst)
			CLEAR_FLAG(m_dwCompression, m_dwMask);
		else if (BST_UNCHECKED == m_bst)
			SET_FLAG(m_dwCompression, m_dwMask);
	}

	if (m_count == m_total)
	{	// if this is the last call, time to update the registry

		// If only GCT_PERSIST_PKZIP is set, then that means the user checked "Disable compression",
		// so set compression to GCT_NOCOMPRESSION
		if (GCT_PERSIST_PKZIP == m_dwCompression)
			m_dwCompression = GCT_NOCOMPRESSION;

		RegEntry re(m_pszSubKey, m_hkey);

		// If user has left everything at default, then simply delete the registry entry.
		if (m_dwCompression != GCT_DEFAULT)
			re.SetValue(m_pszEntry, m_dwCompression);
		else
			re.DeleteValue(m_pszEntry);
	}
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  Z O N E S
/////////////////////////////////////////////////////////////////////////////

VOID CDebugMenu::DbgChangeZones(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgZonesDlgProc, (LPARAM) this);
}


INT_PTR CALLBACK CDebugMenu::DbgZonesDlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitZonesData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgZonesMsg(hDlg, uMsg, wParam, lParam);
}


BOOL CDebugMenu::DlgZonesMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDB_SHOWDBG:
		{
			ShowDbgView();
			return TRUE;
		}

		case IDOK:
			SaveOptionsData(hwnd);
			SaveZonesData();
			SetDbgFlags();

			// fall thru to IDCANCEL

		case IDCANCEL:
		{
			FreeOptionsData(hwnd);			
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	case WM_NOTIFY:
		if (IDL_DEBUG == wParam)
			OnNotifyDbgopt(lParam);
		break;

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}




VOID CDebugMenu::InitZonesData(HWND hDlg)
{
	LV_ITEM lvI;

	// Fill in the LV_ITEM structure
	// The mask specifies the the .pszText, .iImage, .lParam and .state
	// members of the LV_ITEM structure are valid.

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddZones(&lvI);

	SetWindowText(hDlg, TEXT("Debug Zone Settings"));
}


VOID CDebugMenu::AddZones(LV_ITEM * plvItem)
{
	PDBGZONEINFO  prgZones;
	PDBGZONEINFO  pZone;
	UINT cModules;
	UINT iModule;
	UINT iZone;
	UINT cch;
	TCHAR sz[256];
	PTCHAR pch;
	
 	if ((!NmDbgGetAllZoneParams(&prgZones, &cModules)) || (0 == cModules))
 		return; // no zones?

   	for (iModule = 0; iModule < cModules; iModule++)
   	{
		pZone = &prgZones[iModule];
		AddOptionSection(plvItem, TEXT("----------------------------------------"));

		lstrcpy(sz, pZone->pszModule);
		cch = lstrlen(sz);
		if (0 == cch)
			continue;
		for (pch = sz + cch-1; _T(' ') == *pch; pch--)
			;
		lstrcpy(++pch, TEXT(": "));
		pch += 2;
		for (iZone = 0; (iZone < MAXNUM_OF_ZONES) && (*(pZone->szZoneNames[iZone])); iZone++)
		{
	   		lstrcpy(pch, pZone->szZoneNames[iZone]);
			AddOptionPdw(plvItem, sz, 1 << iZone, &pZone->ulZoneMask);
		}
	}

	NmDbgFreeZoneParams(prgZones);
}

VOID CDebugMenu::SaveZonesData(VOID)
{
	RegEntry reZones(ZONES_KEY, HKEY_LOCAL_MACHINE);
	PDBGZONEINFO  prgZones;
	UINT cModules;
	UINT iModule;
	
 	if ((!NmDbgGetAllZoneParams(&prgZones, &cModules)) || (0 == cModules))
 		return; // no zones?

   	for (iModule = 0; iModule < cModules; iModule++)
   	{
		reZones.SetValue(prgZones[iModule].pszModule, prgZones[iModule].ulZoneMask);
	}

	NmDbgFreeZoneParams(prgZones);
}

/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  S Y S  P O L I C Y
/////////////////////////////////////////////////////////////////////////////

VOID CDebugMenu::DbgSysPolicy(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgPolicyDlgProc, (LPARAM) this);
}


INT_PTR CALLBACK CDebugMenu::DbgPolicyDlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;

		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitPolicyData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgPolicyMsg(hDlg, uMsg, wParam, lParam);
}


BOOL CDebugMenu::DlgPolicyMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDOK:
			SaveOptionsData(hwnd);

			// fall thru to IDCANCEL

		case IDCANCEL:
			FreeOptionsData(hwnd);			
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;

		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	case WM_NOTIFY:
		if (IDL_DEBUG == wParam)
			OnNotifyDbgopt(lParam);
		break;

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}


VOID CDebugMenu::InitPolicyData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddPolicyOptions(&lvI);
	
	ShowWindow(GetDlgItem(hDlg, IDB_SHOWDBG), SW_HIDE);
	SetWindowText(hDlg, TEXT("System Policies"));
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  U S E R  I N T E R F A C E
/////////////////////////////////////////////////////////////////////////////

VOID CDebugMenu::DbgUI(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_OPTIONS),
		m_hwnd, CDebugMenu::DbgUIDlgProc, (LPARAM) this);
}


INT_PTR CALLBACK CDebugMenu::DbgUIDlgProc(HWND hDlg, UINT uMsg,
		WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;

		SetWindowLongPtr(hDlg, DWLP_USER, lParam);
		((CDebugMenu *) lParam)->InitOptionsDlg(hDlg);
		((CDebugMenu *) lParam)->InitUIData(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgPolicyMsg(hDlg, uMsg, wParam, lParam);
}


VOID CDebugMenu::InitUIData(HWND hDlg)
{
	LV_ITEM lvI;

	ZeroMemory(&lvI, sizeof(lvI));
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
	lvI.stateMask = LVIS_STATEIMAGEMASK;
	lvI.cchTextMax = 256;

	AddUIOptions(&lvI);
	
	ShowWindow(GetDlgItem(hDlg, IDB_SHOWDBG), SW_HIDE);
	SetWindowText(hDlg, TEXT("User Interface"));
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  V E R S I O N
/////////////////////////////////////////////////////////////////////////////


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgVersion()
*
*    PURPOSE:  Brings up the debug options dialog box
*
****************************************************************************/

VOID CDebugMenu::DbgVersion(VOID)
{
	if (SUCCEEDED(DLLVER::Init()))
	{
		DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_VERSION),
			m_hwnd, CDebugMenu::DbgVersionDlgProc, (LPARAM) this);
	}
}


/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DbgVersionDlgProc()
*
*    PURPOSE:  Dialog Proc for version information
*
****************************************************************************/

INT_PTR CALLBACK CDebugMenu::DbgVersionDlgProc(HWND hDlg, UINT uMsg,
											WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);

		((CDebugMenu *) lParam)->InitVerDlg(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	return ppd->DlgVersionMsg(hDlg, uMsg, wParam, lParam);
}

/****************************************************************************
*
*    CLASS:    CDebugMenu
*
*    MEMBER:   DlgVersionMsg()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CDebugMenu::DlgVersionMsg(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDC_DBG_VER_OPRAH:
		case IDC_DBG_VER_AUDIO:
		case IDC_DBG_VER_WINDOWS:
			FillVerList(hwnd);
			return TRUE;

		case IDOK:
		case IDCANCEL:
		{
			EndDialog(hwnd, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

#ifdef NOTUSED
	case WM_NOTIFY:
	{
		if (IDL_DBG_VERINFO != wParam)
			break;

		NM_LISTVIEW * pnmv = (NM_LISTVIEW *) lParam;
		if (pnmv->hdr.code == LVN_COLUMNCLICK)
		{
			ASSERT(pnmv->hdr.hwndFrom == GetDlgItem(hwnd, IDL_DBG_VERINFO));
			SortVerList(pnmv->hdr.hwndFrom, pnmv->iSubItem);
		}
		break;
	}
#endif /* NOTUSED */

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}


/*  I N I T  V E R  D L G */
/*----------------------------------------------------------------------------
    %%Function: InitVerDlg

----------------------------------------------------------------------------*/
BOOL CDebugMenu::InitVerDlg(HWND hDlg)
{
	LV_COLUMN lvc;
	int  iCol;
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_VERINFO);
	ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

	for (int i = 0; i < ARRAY_ELEMENTS(_rgModules); i++)
		CheckDlgButton(hDlg, _rgModules[i].id , _rgModules[i].fShow);

	// Set up columns
	ZeroMemory(&lvc, sizeof(lvc));
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

	for (iCol = 0; iCol < cVerInfo; iCol++)
	{
		lvc.iSubItem = iCol;
		lvc.pszText = _rgVerTitle[iCol];
		lvc.cx = _rgVerWidth[iCol];
		lvc.fmt = (iCol == 1) ? LVCFMT_RIGHT : LVCFMT_LEFT;
		ListView_InsertColumn(hwnd, iCol, &lvc);
	}

	return FillVerList(hDlg);
}


/*  F I L L  V E R  L I S T */
/*----------------------------------------------------------------------------
    %%Function: FillVerList

----------------------------------------------------------------------------*/
BOOL CDebugMenu::FillVerList(HWND hDlg)
{
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_VERINFO);
	ghwndVerList = hwnd;

	ListView_DeleteAllItems(hwnd);

	for (int i = 0; i < ARRAY_ELEMENTS(_rgModules); i++)
	{
		_rgModules[i].fShow = IsDlgButtonChecked(hDlg, _rgModules[i].id);
		if (_rgModules[i].fShow)
			ShowVerInfo(hwnd, _rgModules[i].rgsz, _rgModules[i].cFiles);
	}

	return TRUE;
}


/*  S H O W  V E R  I N F O */
/*----------------------------------------------------------------------------
    %%Function: ShowVerInfo

----------------------------------------------------------------------------*/
VOID CDebugMenu::ShowVerInfo(HWND hwnd, LPTSTR * rgsz, int cFiles)
{
	int   iCol;
	int   iPos;
	DWORD dw;
	DWORD dwSize;
	UINT  cbBytes;
	TCHAR rgch[2048]; // a really big buffer;
	TCHAR szField[256];
	TCHAR szDir[MAX_PATH];
	LPTSTR lpszVerIntl;
	LPTSTR lpsz;
	LV_ITEM lvItem;
	HANDLE  hFind;
	WIN32_FIND_DATA findData;
	SYSTEMTIME sysTime;

	// Get and set data for each line
	ZeroMemory(&lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = ListView_GetItemCount(hwnd);
	ListView_SetItemCount(hwnd, lvItem.iItem + cFiles);

	GetInstallDirectory(szDir);

	for (int i = 0; i < cFiles; i++, lvItem.iItem++)
	{
		lvItem.pszText = rgsz[i];
		lvItem.cchTextMax = lstrlen(lvItem.pszText);
		lvItem.lParam = lvItem.iItem;
		iPos = ListView_InsertItem(hwnd, &lvItem);

		// Find file and get attributes (size and creation date)
		wsprintf(rgch, TEXT("%s%s"), szDir, lvItem.pszText);
		hFind = FindFirstFile(rgch, &findData);
		if (INVALID_HANDLE_VALUE == hFind)
		{
			GetSystemDirectory(rgch, sizeof(rgch));
			lstrcat(rgch, TEXT("\\"));
			lstrcat(rgch, lvItem.pszText);
			hFind = FindFirstFile(rgch, &findData);
		}
		if (INVALID_HANDLE_VALUE == hFind)
		{
			ZeroMemory(&findData, sizeof(findData));
			ListView_SetItemText(hwnd, iPos, 1, TEXT("-"));
			ListView_SetItemText(hwnd, iPos, 2, TEXT("-"));
		}
		else
		{
			FindClose(hFind);

			wsprintf(szField, TEXT("%d"), findData.nFileSizeLow);
			ListView_SetItemText(hwnd, iPos, 1, szField);
			FileTimeToSystemTime(&findData.ftLastWriteTime, &sysTime);
			wsprintf(szField, TEXT("%d/%02d/%02d"), sysTime.wYear, sysTime.wMonth, sysTime.wDay);
			ListView_SetItemText(hwnd, iPos, 2, szField);
		}

		// Get version information
		dwSize = DLLVER::GetFileVersionInfoSize(lvItem.pszText, &dw);

		if ((0 == dwSize) || (sizeof(rgch) < dwSize) ||
			!DLLVER::GetFileVersionInfo(lvItem.pszText, dw, dwSize, rgch))
		{
			continue;
		}

		// attempt to determine intl version ("040904E4" or "040904B0")
		wsprintf(szField, _szVerFormat, _szStringFileInfo, _szVerIntlUSA, _rgszVerInfo[VERSION_INDEX]);
		if (DLLVER::VerQueryValue(rgch, szField, (LPVOID *) &lpsz, &cbBytes))
			lpszVerIntl = _szVerIntlUSA;
		else
			lpszVerIntl = _szVerIntlAlt;
		// FUTURE display the language/code page info

		for (iCol = 3; iCol < cVerInfo; iCol++)
		{
			wsprintf(szField, _szVerFormat, _szStringFileInfo, lpszVerIntl, _rgszVerInfo[iCol]);
			if (!DLLVER::VerQueryValue(rgch, szField, (LPVOID *) &lpsz, &cbBytes))
				lpsz = TEXT("-");

			ListView_SetItemText(hwnd, iPos, iCol, lpsz);
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// D I A L O G:  M E M B E R
/////////////////////////////////////////////////////////////////////////////

static DWSTR _rgColMember[] = {
80, TEXT("Name"),
30, TEXT("Ver"),
65, TEXT("GccId"),
65, TEXT("Parent"),
60, TEXT("Flags"),
40, TEXT("Send"),
40, TEXT("Recv"),
45, TEXT("Using"),
90, TEXT("IP"),
80, TEXT("Email"),
120, TEXT("ULS"),
};

enum {
	ICOL_PART_NAME = 0,
	ICOL_PART_VER,
	ICOL_PART_GCCID,
	ICOL_PART_PARENT,
	ICOL_PART_FLAGS,
	ICOL_PART_CAPS_SEND,
	ICOL_PART_CAPS_RECV,
	ICOL_PART_CAPS_INUSE,
	ICOL_PART_IP,
	ICOL_PART_EMAIL,
	ICOL_PART_ULS,
};


VOID CDebugMenu::DbgMemberInfo(VOID)
{
	DialogBoxParam(GetInstanceHandle(), MAKEINTRESOURCE(IDD_DBG_LIST),
		m_hwnd, CDebugMenu::DbgListDlgProc, (LPARAM) this);
}

VOID CDebugMenu::InitMemberDlg(HWND hDlg)
{
	LV_COLUMN lvc;
	int  iCol;
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_LIST);
	ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

	// Set up columns
	ZeroMemory(&lvc, sizeof(lvc));
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;

	for (iCol = 0; iCol < ARRAY_ELEMENTS(_rgColMember); iCol++)
	{
		lvc.iSubItem = iCol;
		lvc.pszText = _rgColMember[iCol].psz;
		lvc.cx = _rgColMember[iCol].dw;
		ListView_InsertColumn(hwnd, iCol, &lvc);
	}

	FillMemberList(hDlg);
	SetWindowText(hDlg, TEXT("Member Information"));
}


VOID CDebugMenu::FillMemberList(HWND hDlg)
{
	HWND hwnd;

	ASSERT(NULL != hDlg);
	hwnd = GetDlgItem(hDlg, IDL_DBG_LIST);

	ListView_DeleteAllItems(hwnd);

	CConfRoom * pcr = ::GetConfRoom();
	if (NULL == pcr)
		return;

	CSimpleArray<CParticipant*>& rMemberList = pcr->GetParticipantList();

	for( int i = 0; i < rMemberList.GetSize(); ++i )
	{
		ASSERT( rMemberList[i] );
		ShowMemberInfo( hwnd, rMemberList[i] );
	}
}


VOID CDebugMenu::ShowMemberInfo(HWND hwnd, CParticipant * pPart)
{
	HRESULT hr;
	ULONG   ul;
	int     iPos;
	LV_ITEM lvItem;
	TCHAR   sz[MAX_PATH];

	if (NULL == pPart)
		return;

	// Get and set data for each line
	ZeroMemory(&lvItem, sizeof(lvItem));
	
	lvItem.mask = LVIF_TEXT;
	lvItem.pszText = pPart->GetPszName();
	lvItem.cchTextMax = lstrlen(lvItem.pszText);
	lvItem.lParam = (LPARAM) pPart;
	iPos = ListView_InsertItem(hwnd, &lvItem);

	wsprintf(sz, TEXT("%08X"), pPart->GetGccId());
	ListView_SetItemText(hwnd, iPos, ICOL_PART_GCCID, sz);

	INmMember * pMember = pPart->GetINmMember();
	if (NULL != pMember)
	{
		hr = pMember->GetNmVersion(&ul);
		wsprintf(sz, "%d", ul);
		ListView_SetItemText(hwnd, iPos, ICOL_PART_VER, sz);

		wsprintf(sz, TEXT("%08X"), ((CNmMember *) pMember)->GetGccIdParent());
		ListView_SetItemText(hwnd, iPos, ICOL_PART_PARENT, sz);
	}

	lstrcpy(sz, TEXT("?"));
	hr = pPart->GetIpAddr(sz, CCHMAX(sz));
	ListView_SetItemText(hwnd, iPos, ICOL_PART_IP, sz);

	lstrcpy(sz, TEXT("?"));
	hr = pPart->GetUlsAddr(sz, CCHMAX(sz));
	ListView_SetItemText(hwnd, iPos, ICOL_PART_ULS, sz);

	lstrcpy(sz, TEXT("?"));
	hr = pPart->GetEmailAddr(sz, CCHMAX(sz));
	ListView_SetItemText(hwnd, iPos, ICOL_PART_EMAIL, sz);

	DWORD dwFlags = pPart->GetDwFlags();
	wsprintf(sz, TEXT("%s%s%s%s %s%s%s"),
		dwFlags & PF_T120          ? "D" : "",
		dwFlags & PF_H323          ? "H" : "",
		dwFlags & PF_MEDIA_AUDIO   ? "A" : "",
		dwFlags & PF_MEDIA_VIDEO   ? "V" : "",
		pPart->FLocal()            ? "L" : "",
		pPart->FMcu()              ? "M" : "",
		dwFlags & PF_T120_TOP_PROV ? "T" : "");
	ListView_SetItemText(hwnd, iPos, ICOL_PART_FLAGS, sz);

	DWORD uCaps = pPart->GetDwCaps();
	wsprintf(sz, TEXT("%s%s"),
		uCaps & CAPFLAG_SEND_AUDIO ? "A" : "",
		uCaps & CAPFLAG_SEND_VIDEO ? "V" : "");
	ListView_SetItemText(hwnd, iPos, ICOL_PART_CAPS_SEND,  sz);
	
	wsprintf(sz, TEXT("%s%s"),
		uCaps & CAPFLAG_RECV_AUDIO ? "A" : "",
		uCaps & CAPFLAG_RECV_VIDEO ? "V" : "");
	ListView_SetItemText(hwnd, iPos, ICOL_PART_CAPS_RECV,  sz);
	
	wsprintf(sz, TEXT("%s%s%s%s"),
		uCaps & CAPFLAG_DATA_IN_USE  ? "D" : "",
		uCaps & CAPFLAG_AUDIO_IN_USE ? "A" : "",
		uCaps & CAPFLAG_VIDEO_IN_USE ? "V" : "",
		uCaps & CAPFLAG_H323_IN_USE  ? "H" : "");

	ListView_SetItemText(hwnd, iPos, ICOL_PART_CAPS_INUSE, sz);
	
	if (pPart->FLocal())
	{
		ListView_SetItemState(hwnd, iPos, LVIS_FOCUSED | LVIS_SELECTED, 0x000F);
	}
}


INT_PTR CALLBACK CDebugMenu::DbgListDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (WM_INITDIALOG == uMsg)
	{
		if (NULL == lParam)
			return FALSE;
		SetWindowLongPtr(hDlg, DWLP_USER, lParam);

		((CDebugMenu *) lParam)->InitMemberDlg(hDlg);
		return TRUE;
	}

	CDebugMenu * ppd = (CDebugMenu*) GetWindowLongPtr(hDlg, DWLP_USER);
	if (NULL == ppd)
		return FALSE;

	switch (uMsg)
		{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
			{
		case IDOK:
		case IDCANCEL:
		{
			EndDialog(hDlg, LOWORD(wParam));
			return TRUE;
		}
		default:
			break;
			} /* switch (wParam) */
		break;
	} /* WM_COMMAND */

	default:
		break;
		} /* switch (uMsg) */

	return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// O T H E R  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////



/*  D B G  W I Z A R D  */
/*-------------------------------------------------------------------------
    %%Function: DbgWizard

-------------------------------------------------------------------------*/
VOID DbgWizard(BOOL fVisible)
{
	LONG lSoundCaps = SOUNDCARD_NONE;
	HRESULT hr = StartRunOnceWizard(&lSoundCaps, TRUE, fVisible);
	TRACE_OUT(("StartRunOnceWizard result=%08X", hr));
}



#if defined (_M_IX86)
#define _DbgBreak() __asm { int 3 }
#else
#define _DbgBreak() DebugBreak()
#endif

VOID DbgBreak(void)
{
	// Break into the debugger
	_DbgBreak();
}



/////////////////////////////////////////////////////////////////////////////
// T E S T  F U N C T I O N S
/////////////////////////////////////////////////////////////////////////////

#include "splash.h"
VOID DbgSplash(HWND hwnd)
{
	if (NULL == g_pSplashScreen)
	{
		StartSplashScreen(hwnd);
	}
	else
	{
		StopSplashScreen();
	}
}

VOID DbgTest2(void)
{
	TRACE_OUT(("Test 2 complete"));
}

VOID DbgTest3(void)
{
	TRACE_OUT(("Test 3 complete"));
}

/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////

BOOL _FEnsureDbgMenu(void)
{
	if (NULL != g_pDbgMenu)
		return TRUE;

	g_pDbgMenu = new CDebugMenu;
	return (NULL != g_pDbgMenu);
}

VOID FreeDbgMenu(void)
{
	delete g_pDbgMenu;
	g_pDbgMenu = NULL;
}

VOID InitDbgMenu(HWND hwnd)
{
	if (_FEnsureDbgMenu())
		g_pDbgMenu->InitDebugMenu(hwnd);
}

BOOL OnDebugCommand(WPARAM wCmd)
{
	if (!_FEnsureDbgMenu())
		return FALSE;

	return g_pDbgMenu->OnDebugCommand(wCmd);
}


/////////////////////////////////////////////////////////////////////////////
//
/////////////////////////////////////////////////////////////////////////////

VOID DbgGetComments(LPTSTR psz)
{
	// NetMeeting version
	lstrcpy(psz, "NM3." VERSIONBUILD_STR);


	// OS version
	if (IsWindowsNT())
	{
		RegEntry re(WINDOWS_NT_KEY, HKEY_LOCAL_MACHINE);
		LPTSTR pszVer = re.GetString("CurrentVersion");
		if (0 == lstrcmp(pszVer, "4.0"))
		{
			lstrcat(psz, ", NT4 ");
		}
		else if (0 == lstrcmp(pszVer, "5.0"))
		{
			lstrcat(psz, ", NT5 ");
		}
		else
		{
			lstrcat(psz, ", NT ");
			lstrcat(psz, pszVer);
		}

		pszVer = re.GetString("CSDVersion");
		if (!FEmptySz(pszVer))
		{
			if (0 == lstrcmp(pszVer, "Service Pack 3"))
				lstrcat(psz, "SP-3");
			else
				lstrcat(psz, pszVer);
		}
	}
	else
	{
		RegEntry re(WINDOWS_KEY, HKEY_LOCAL_MACHINE);
		LPTSTR pszVer = re.GetString("Version");
		if (0 == lstrcmp(pszVer, "Windows 95"))
		{
			lstrcat(psz, ", Win95");
		}
		else if (0 == lstrcmp(pszVer, "Windows 98"))
		{
			lstrcat(psz, ", Win98");
		}
		else if (NULL != pszVer)
		{
			lstrcat(psz, ", ");
			lstrcat(psz, pszVer);
		}
	}


	// Internet Explorer version
	{
		RegEntry re(TEXT("Software\\Microsoft\\Internet Explorer"), HKEY_LOCAL_MACHINE);
		lstrcat(psz, ", IE");
		lstrcat(psz, re.GetString("Version"));
	}
}
/////////////////////////////////////////////////////////////////////////////


#define STRING_CASE(val)               case val: pcsz = #val; break

LPCTSTR PszLastError(void)
{
	static TCHAR _szErr[MAX_PATH];
	DWORD dwErr = GetLastError();

	if (0 == FormatMessage(
		FORMAT_MESSAGE_FROM_SYSTEM,  // source and processing options
	    NULL,                        // pointer to  message source
	    dwErr,                       // requested message identifier
		0,                           // language identifier for requested message
		_szErr,                      // pointer to message buffer
		CCHMAX(_szErr),              // maximum size of message buffer
		NULL))                       // address of array of message inserts
	{
		wsprintf(_szErr, TEXT("0x%08X (%d)"), dwErr, dwErr);
	}

	return _szErr;
}


LPCTSTR PszWSALastError(void)
{
	LPCTSTR pcsz;
	DWORD dwErr = WSAGetLastError();
	switch (dwErr)
		{
	STRING_CASE(WSAEWOULDBLOCK);
	STRING_CASE(WSAEINPROGRESS);
	STRING_CASE(HOST_NOT_FOUND);
	STRING_CASE(WSATRY_AGAIN);
	STRING_CASE(WSANO_RECOVERY);
	STRING_CASE(WSANO_DATA);
	
	default:
	{
		static TCHAR _szErr[MAX_PATH];
		wsprintf(_szErr, TEXT("0x%08X (%d)"), dwErr, dwErr);
		pcsz = _szErr;
		break;
	}
		}

	return pcsz;
}


/*  P S Z  H  R E S U L T  */
/*-------------------------------------------------------------------------
    %%Function: PszHResult

-------------------------------------------------------------------------*/
LPCTSTR PszHResult(HRESULT hr)
{
   LPCSTR pcsz;
   switch (hr)
   {
// Common HResults
	  STRING_CASE(S_OK);
	  STRING_CASE(S_FALSE);

	  STRING_CASE(E_FAIL);
	  STRING_CASE(E_OUTOFMEMORY);

// NM COM API 2.0
	  STRING_CASE(NM_S_NEXT_CONFERENCE);
	  STRING_CASE(NM_S_ON_RESTART);
	  STRING_CASE(NM_CALLERR_NOT_INITIALIZED);
	  STRING_CASE(NM_CALLERR_MEDIA);
	  STRING_CASE(NM_CALLERR_NAME_RESOLUTION);
	  STRING_CASE(NM_CALLERR_PASSWORD);
	  STRING_CASE(NM_CALLERR_CONFERENCE_NAME);
	  STRING_CASE(NM_CALLERR_IN_CONFERENCE);
	  STRING_CASE(NM_CALLERR_NOT_FOUND);
	  STRING_CASE(NM_CALLERR_MCU);
	  STRING_CASE(NM_CALLERR_REJECTED);
	  STRING_CASE(NM_CALLERR_AUDIO);
	  STRING_CASE(NM_CALLERR_AUDIO_LOCAL);
	  STRING_CASE(NM_CALLERR_AUDIO_REMOTE);
	  STRING_CASE(NM_CALLERR_UNKNOWN);
	  STRING_CASE(NM_E_NOT_INITIALIZED);
	  STRING_CASE(NM_E_CHANNEL_ALREADY_EXISTS);
	  STRING_CASE(NM_E_NO_T120_CONFERENCE);
	  STRING_CASE(NM_E_NOT_ACTIVE);

// NM COM API 3.0
	  STRING_CASE(NM_CALLERR_LOOPBACK);

	default:
		pcsz = GetHRESULTString(hr);
		break;
	}

	return pcsz;
}


/////////////////////////////////////////////////////////////////////////////

/*  I N I T  N M  D E B U G  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitNmDebugOptions

    Initialize NetMeeting UI-specific debug options.
-------------------------------------------------------------------------*/
VOID InitNmDebugOptions(void)
{
    RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	g_fDisplayFPS = re.GetNumber(REGVAL_DBG_DISPLAY_FPS, 0);
	g_fDisplayViewStatus = re.GetNumber(REGVAL_DBG_DISPLAY_VIEWSTATUS, 0);
}

VOID SaveNmDebugOptions(void)
{
    RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);

	re.SetValue(REGVAL_DBG_DISPLAY_FPS, g_fDisplayFPS);
	re.SetValue(REGVAL_DBG_DISPLAY_VIEWSTATUS, g_fDisplayViewStatus);
}



/*  U P D A T E  C R T  D B G  S E T T I N G S  */
/*-------------------------------------------------------------------------
    %%Function: UpdateCrtDbgSettings

    Update the C runtime debug memory settings
-------------------------------------------------------------------------*/
VOID UpdateCrtDbgSettings(void)
{
#if 0
	// This depends on the use of the debug c runtime library
	int tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

	// Always enable memory leak checking debug spew
	tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
	
	_CrtSetDbgFlag(tmpFlag);
#endif // 0
}


/*  I N I T  D E B U G  M E M O R Y  O P T I O N S  */
/*-------------------------------------------------------------------------
    %%Function: InitDebugMemoryOptions

    Initilize the runtime memory
-------------------------------------------------------------------------*/
BOOL InitDebugMemoryOptions(void)
{
	InitNmDebugOptions();
	UpdateCrtDbgSettings();

#if 0
	_CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW); // create a message box on errors
#endif // 0

	return TRUE;
}

#endif /* DEBUG - whole file */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dirutil.h ===
// File: util.h

#ifndef _UTIL_H_
#define _UTIL_H_

#include "SDKInternal.h"
#include "confutil.h"

int  FindSzCombo(HWND hwnd, LPCTSTR pszSrc, LPTSTR pszResult);
VOID AutoCompleteCombo(HWND hwnd, LPCTSTR psz);
VOID AutoCompleteEdit(HWND hwnd, LPCTSTR psz);

int  DisplayMsg(HWND hwndParent, LPCTSTR pszMsg, UINT uType);
int  DisplayMsgId(HWND hwndParent, UINT id);
VOID DisplayMsgErr(HWND hwndParent, UINT id, PVOID pv);
VOID DisplayMsgErr(HWND hwndParent, UINT id);

	// Atl defines a function AtlWaitWithMessageLoop
	// We are not linking with ATL, but when we start,
	// this function can be removed
HRESULT WaitWithMessageLoop( HANDLE hEvent );

VOID AddToolTip(HWND hwndParent, HWND hwndCtrl, UINT_PTR idMsg);
HWND CreateStaticText(HWND hwnd, INT_PTR id);
HWND CreateButton(HWND hwndParent, int ids, INT_PTR id);

BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax);
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszEmail, int cchMax);

// from nmobj.cpp
HRESULT PlaceCall(LPCTSTR pszName, LPCTSTR pszAddress,
	NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwFlags = 0,
	LPCTSTR pszConference = NULL, LPCTSTR pszPassword = NULL);


HRESULT ExtractAddress( DWORD dwAddrType, LPTSTR szAddress, LPTSTR szExtractedAddr, int cchMax );
bool IsValidAddress( DWORD dwAddrType, LPTSTR szAddr );

// from dlgcall.h
#define IDI_DLGCALL_NAME     0
#define IDI_DLGCALL_ADDRESS  1
#define IDI_MISC1			 2
#define IDI_DLGCALL_COMMENT  IDI_MISC1
#define IDI_DLGCALL_PHONENUM IDI_MISC1

int     DlgCallAddItem(HWND hwndList, LPCTSTR pszName, LPCTSTR pszAddress,
                       int iImage=0, LPARAM lParam=0, int iItem=0, LPCTSTR pszComment=NULL);
VOID    DlgCallSetHeader(HWND hwndList, int ids);
HRESULT CallToSz(LPCTSTR pcszAddress);

#endif /* _UTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgacd.cpp ===
//--------------------------------------------------------------------------//
//      Header Files.                                                                                                                   //
//--------------------------------------------------------------------------//
#include "precomp.h"
#include "resource.h"
#include "help_ids.h"
#include "dlgcall2.h"
#include "mrulist2.h"
#include "dlgacd.h"
#include "dlgCall2.h"
#include "calv.h"
#include "dirutil.h"
#include "callto.h"
#include "conf.h"
#include "confroom.h"
#include "confpolicies.h"


extern void UpdateSecurityCheck(CConfRoom *pConfRoom, HWND hDlg, UINT idCheck);


//--------------------------------------------------------------------------//
//      CDlgAcd::CDlgAcd.                                                                                                               //
//--------------------------------------------------------------------------//
CDlgAcd::CDlgAcd(CConfRoom *pConfRoom):
        m_hwnd( NULL ),
        m_nameCombo( NULL ),
        m_addressTypeCombo( NULL ),
        m_pRai( NULL ),
        m_mruRai( NULL ),
        m_pConfRoom( pConfRoom ),
        m_secure( false )
{
        //      Ensure the common controls are loaded...
        INITCOMMONCONTROLSEX    icc;

        icc.dwSize      = sizeof(icc);
        icc.dwICC       = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;

        InitCommonControlsEx( &icc );

}       //      End of CDlgAcd::CDlgAcd.


//--------------------------------------------------------------------------//
//      CDlgAcd::~CDlgAcd.                                                                                                              //
//--------------------------------------------------------------------------//
CDlgAcd::~CDlgAcd()
{

        ClearRai( &m_mruRai );

}       //      End of CDlgAcd::~CDlgAcd.


//--------------------------------------------------------------------------//
//      CDlgAcd::doModal.                                                                                                               //
//--------------------------------------------------------------------------//
INT_PTR CDlgAcd::doModal
(
        HWND                            parent,
        RichAddressInfo *       rai,
        bool &                          secure
){
        INT_PTR result;

        m_pRai          = rai;
        m_secure        = secure;

        result = DialogBoxParam(        ::GetInstanceHandle(),
                                                                MAKEINTRESOURCE( IDD_ACD ),
                                                                parent,
                                                                DlgProcAcd,
                                                                (LPARAM) this );

        secure = m_secure;

        return( result );

}       //      End of CDlgAcd::doModal.


//--------------------------------------------------------------------------//
//      CDlgAcd::DlgProcAcd.                                                                                                    //
//--------------------------------------------------------------------------//
INT_PTR
CALLBACK
CDlgAcd::DlgProcAcd
(
        HWND    dialog,
        UINT    message,
        WPARAM  wParam,
        LPARAM  lParam
){
        static const DWORD      helpIDMap[] =
        {
                IDC_STATIC_ADDRESS,             IDH_GENERAL_GENERAL,
                IDB_ACD_ADDRESS,                IDH_PLACECALL_TO_TEXT,
                IDL_ACD_ADDRESS,                IDH_PLACECALL_TO_TEXT,
                IDC_ACD_USING_STATIC,   IDH_PLACECALL_USING,
                IDL_ACD_ADDR_TYPE,              IDH_PLACECALL_USING,
                IDC_SECURE_CALL,                IDH_PLACECALL_SECURITY_CHKBX,
                IDC_ACD_DIRECTORY,              IDH_PLACECALL_TO,
                IDOK,                                   IDH_PLACECALL_CALL,
                0,                                              0
        };

        bool    result  = false;

        switch( message )
        {
                case WM_INITDIALOG:
                {
                        ASSERT(NULL != lParam);
                        ::SetWindowLongPtr( dialog, DWLP_USER, lParam );
                        result = ((CDlgAcd *) lParam)->onInitDialog( dialog );
                }
                break;

                case WM_COMMAND:
                {
                        CDlgAcd *       acd     = (CDlgAcd *) ::GetWindowLongPtr( dialog, DWLP_USER );

                        if( acd != NULL )
                        {
                                result = acd->onCommand( LOWORD( wParam ), HIWORD( wParam ) );
                        }
                }
                break;

                case WM_CONTEXTMENU:
                {
                        DoHelpWhatsThis( wParam, helpIDMap );
                }
                break;
                
                case WM_HELP:
                {
                        DoHelp( lParam, helpIDMap );
                }
                break;
        }

        return( (BOOL) result );

}       //      End of CDlgAcd::DlgProcAcd.


//--------------------------------------------------------------------------//
//      CDlgAcd::onInitDialog.                                                                                                  //
//--------------------------------------------------------------------------//
bool
CDlgAcd::onInitDialog
(
        HWND    dialog
){

        m_hwnd = dialog;

        UpdateSecurityCheck(m_pConfRoom, m_hwnd, IDC_SECURE_CALL);

        HICON   directoryIcon   = LoadIcon( ::GetInstanceHandle(), MAKEINTRESOURCE( IDI_DIRECTORY ) );

        if( directoryIcon != NULL )
        {
                ::SendDlgItemMessage( dialog, IDC_ACD_DIRECTORY, BM_SETIMAGE, IMAGE_ICON, (LPARAM) directoryIcon );
        }

        m_nameCombo                     = GetDlgItem( m_hwnd, IDL_ACD_ADDRESS );
        m_addressTypeCombo      = GetDlgItem( m_hwnd, IDL_ACD_ADDR_TYPE );

        ComboBox_LimitText( m_nameCombo, CCHMAXSZ_ADDRESS - 1 );

        fillCallMruList();
        fillAddressTypesList();

        ::SendMessage( m_nameCombo, EM_LIMITTEXT, CCallto::s_iMaxAddressLength, 0 );

        if( hasValidUserInfo( m_pRai ) )
        {
                ::SetWindowText( m_nameCombo, m_pRai->szName );
                ::SendMessage( m_addressTypeCombo, CB_SETCURSEL, m_pRai->rgDwStr[ 0 ].dw, 0 );
        }
        else
        {
                ::SendMessage( m_addressTypeCombo, CB_SETCURSEL, 0, 0 );
        }

        CenterWindow( m_hwnd, ::GetParent( m_hwnd ) );

        if (m_pConfRoom->FIsConferenceActive())
        {
                // Simulate a call started to get all the states right
                OnCallStarted();
        }

        return( true );         //      Default focus...

}       //      End of CDlgAcd::onInitDialog.


//--------------------------------------------------------------------------//
//      CDlgAcd::fillCallMruList.                                                                                               //
//--------------------------------------------------------------------------//
void
CDlgAcd::fillCallMruList(void)
{
        ASSERT(NULL != m_nameCombo);

        COMBOBOXEXITEM  cbi;

        ClearStruct( &cbi );

        cbi.mask        = CBEIF_TEXT;
        cbi.iItem       = -1;   //      Always insert at the end...

        HRESULT result  = S_OK;

        for( int nn = 0; result == S_OK; nn++ )
        {
                RichAddressInfo *       rai;

                if( (result = m_callMruList.GetAddress( nn, &rai )) == S_OK )
                {
                        cbi.pszText             = rai->szName;
                        cbi.cchTextMax  = lstrlen( cbi.pszText );

                        int     index   = (int)::SendMessage( m_nameCombo, CBEM_INSERTITEM, 0, (LPARAM) &cbi );

                        if( index != CB_ERR )
                        {
                                ::SendMessage( m_nameCombo, CB_SETITEMDATA, index, nn );
                        }
                        else
                        {
                                result = S_FALSE;
                        }

                        ClearRai( &rai );
                }
        }

}       //      End of CDlgAcd::fillCallMruList.


//--------------------------------------------------------------------------//
//      CDlgAcd::fillAddressTypesList.                                                                                  //
//--------------------------------------------------------------------------//
void
CDlgAcd::fillAddressTypesList(void)
{
        using namespace ConfPolicies;

        enum CallMode
        {
                CM_GK           = 0x0001,       // GateKeeper
                CM_GW           = 0x0002,       // Gateway
                CM_NoGate       = 0x0004,       // Neither
        } ;

        static const struct
        {
                LPARAM dwCallType;
                UINT idTitle;
                UINT uCallMode;
        } s_mpCtIds[] =
        {
                {       NM_ADDR_UNKNOWN,                IDS_ACD_CT_AUTOMATIC,   CM_GK|CM_GW|CM_NoGate   },
                {       NM_ADDR_MACHINENAME,    IDS_ACD_CT_IP,                  CM_GW|CM_NoGate                 },
                {       NM_ADDR_ULS,                    IDS_ACD_CT_ILS,                 CM_GW|CM_NoGate                 },
                {       NM_ADDR_ALIAS_E164,             IDS_ACD_CT_PHONE,               CM_GK|CM_GW                             },
                {       NM_ADDR_ALIAS_ID,               IDS_ACD_CT_ALIAS,               CM_GK                                   },
        } ;

        HWND    combo   = GetDlgItem( m_hwnd, IDL_ACD_ADDR_TYPE );

        if( combo != NULL )
        {
                UINT uCallType = CM_NoGate;

                if (CallingMode_GateKeeper == GetCallingMode())
                {
                        uCallType = CM_GK;
                }
                else
                {
                        RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
                        if (reConf.GetNumber( REGVAL_USE_H323_GATEWAY ) != 0)
                        {
                                uCallType = CM_GW;
                        }
                }

                for( int nn = 0; nn < ARRAY_ELEMENTS(s_mpCtIds); nn++ )
                {
                        if (0 == (uCallType & s_mpCtIds[nn].uCallMode))
                        {
                                continue;
                        }

                        TCHAR   sz[ CCHMAXSZ_NAME ];

                        if( FLoadString( s_mpCtIds[ nn ].idTitle, sz, CCHMAX( sz ) ) )
                        {
                                int     index   = (int)::SendMessage( combo, CB_INSERTSTRING, -1, (LPARAM) sz );

                                if( index != CB_ERR )
                                {
                                        ::SendMessage( combo, CB_SETITEMDATA, index, s_mpCtIds[ nn ].dwCallType );
                                }
                        }
                }
        }

}       //      End of CDlgAcd::fillAddressTypesList.


//--------------------------------------------------------------------------//
//      CDlgAcd::onCommand.                                                                                                             //
//--------------------------------------------------------------------------//
bool
CDlgAcd::onCommand
(
        int command,
        int     notification
){
        ASSERT(NULL != m_hwnd);

        bool    result = false;

        switch( command )
        {
                case IDC_SECURE_CALL:
                {
                        m_secure = (IsDlgButtonChecked( m_hwnd, IDC_SECURE_CALL ) == BST_CHECKED);
                }
                break;

                case IDL_ACD_ADDRESS:
                {
                        if( notification == CBN_EDITCHANGE )
                        {
                                onEditChange();
                        }
                        else if( notification == CBN_SELCHANGE )
                        {
                                int iSel = (int)::SendMessage( m_nameCombo, CB_GETCURSEL, 0, 0 );

                                if (iSel >= 0)
                                {
                                        onMruSelect( iSel );
                                }
                        }
                }
                break;

                case IDL_ACD_ADDR_TYPE:
                        if (CBN_SELCHANGE == notification)
                        {
                                // Pretend like the user just typed in the edit control
                                onEditChange();
                        }
                        break;

                case IDC_ACD_DIRECTORY:
                {
                        CFindSomeone::findSomeone(m_pConfRoom);
                        ::EndDialog( m_hwnd, IDCANCEL );
                }
                break;

                case IDOK:
                {
                        if( m_mruRai != NULL )
                        {
                                lstrcpy( m_pRai->szName, m_mruRai->szName );
                                m_pRai->cItems                          = m_mruRai->cItems;

                                for( int nn = 0; nn < m_mruRai->cItems; nn++ )
                                {
                                        m_pRai->rgDwStr[ nn ].dw        = m_mruRai->rgDwStr[ nn ].dw;
                                        m_pRai->rgDwStr[ nn ].psz       = PszAlloc( m_mruRai->rgDwStr[ nn ].psz );
                                }
                        }
                        else
                        {
                                int     type    = (int)::SendMessage( m_addressTypeCombo, CB_GETCURSEL, 0, 0 );

                                type = (int)((type == CB_ERR)? NM_ADDR_UNKNOWN: ComboBox_GetItemData(m_addressTypeCombo, type));

                                ::SendMessage( GetDlgItem( m_hwnd, IDL_ACD_ADDRESS), WM_GETTEXT, CCHMAX( m_pRai->szName ), (LPARAM) m_pRai->szName );

                                if( (type == NM_ADDR_UNKNOWN) && bCanCallAsPhoneNumber( m_pRai->szName ) )
                                {
                                        type = NM_ADDR_ALIAS_E164;
                                }

                                m_pRai->cItems                          = 1;
                                m_pRai->rgDwStr[ 0 ].dw         = type;
                                m_pRai->rgDwStr[ 0 ].psz        = PszAlloc( m_pRai->szName );
                        }

                        ::EndDialog( m_hwnd, IDOK );
                        result = true;
                }
                break;

                case IDCANCEL:
                {
                        ::EndDialog( m_hwnd, IDCANCEL );
                        result = true;
                }
                break;
        }

        return( result );

}       //      End of CDlgAcd::onCommand.


//--------------------------------------------------------------------------//
//      CDlgAcd::onEditChange.                                                                                                  //
//--------------------------------------------------------------------------//
void
CDlgAcd::onEditChange(void)
{
        TCHAR   szEdit[ CCHMAXSZ_ADDRESS ];
        int             cch     = get_editText( szEdit, CCHMAX( szEdit ) );

        EnableWindow( GetDlgItem( m_hwnd, IDOK ), (cch > 0) );
        ClearRai( &m_mruRai );

}       //      End of CDlgAcd::onEditChange.


//--------------------------------------------------------------------------//
//      CDlgAcd::onMruSelect.                                                                                                   //
//--------------------------------------------------------------------------//
void
CDlgAcd::onMruSelect
(
        int     selection
){
        int             mruIndex = (int)::SendMessage( m_nameCombo, CB_GETITEMDATA, selection, 0 );
        HRESULT result;

        RichAddressInfo *       rai;

        if( (result = m_callMruList.GetAddress( mruIndex, &rai )) == S_OK )
        {
                ::SetWindowText( m_nameCombo, rai->szName );

                DWORD dwType = rai->rgDwStr[ 0 ].dw;

                // HACKHACK georgep: We know Automatic is at index 0
                for (int typeIndex=ComboBox_GetCount(m_addressTypeCombo)-1; typeIndex>0; --typeIndex)
                {
                        if (static_cast<DWORD>(ComboBox_GetItemData(m_addressTypeCombo, typeIndex))
                                == dwType)
                        {
                                break;
                        }
                }
                ComboBox_SetCurSel(m_addressTypeCombo, typeIndex);

                m_mruRai = rai;
        }

}       //      End of CDlgAcd::onMruSelect.


//--------------------------------------------------------------------------//
//      CDlgAcd::newCall.                                                                                                               //
//--------------------------------------------------------------------------//
void
CDlgAcd::newCall
(
        HWND    parentWindow,
        CConfRoom * pConfRoom
){
        CDlgAcd                 placeCall(pConfRoom);
        RichAddressInfo rai;
        bool                    userAlterable;
        bool                    secure;

        pConfRoom->AddConferenceChangeHandler(&placeCall);

        pConfRoom->get_securitySettings( userAlterable, secure );

        rai.szName[ 0 ] = '\0';
        rai.cItems              = 0;

        if( placeCall.doModal( parentWindow, &rai, secure ) == IDOK )
        {
                NM_ADDR_TYPE            nmType          = static_cast<NM_ADDR_TYPE>(rai.rgDwStr[ 0 ].dw);

                g_pCCallto->Callto(     rai.szName,             //      pointer to the callto url to try to place the call with...
                                                        NULL,                   //      pointer to the display name to use...
                                                        nmType,                 //      callto type to resolve this callto as...
                                                        true,                   //      the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
                                                        &secure,                //      security preference, NULL for none. must be "compatible" with secure param if present...
                                                        true,                   //      whether or not save in mru...
                                                        true,                   //      whether or not to perform user interaction on errors...
                                                        parentWindow,   //      if bUIEnabled is true this is the window to parent error/status windows to...
                                                        NULL );                 //      out pointer to INmCall * to receive INmCall * generated by placing call...

                for( int nn = 0; nn < rai.cItems; nn++ )
                {
                        delete [] rai.rgDwStr[ nn ].psz;
                }
        }

        pConfRoom->RemoveConferenceChangeHandler(&placeCall);

}       //      End of CDlgAcd::newCall.


//--------------------------------------------------------------------------//
//      CDlgAcd::get_editText.                                                                                                  //
//--------------------------------------------------------------------------//
int
CDlgAcd::get_editText
(
        LPTSTR  psz,
        int             cchMax
){
        ASSERT(NULL != m_nameCombo);

        SetEmptySz( psz );
        GetWindowText( m_nameCombo, psz, cchMax );
        
        return( TrimSz( psz ) );

}       //      End of get_editText.


void CDlgAcd::OnCallStarted()
{
        UpdateSecurityCheck(m_pConfRoom, m_hwnd, IDC_SECURE_CALL);

        // BUGBUG georgep: We get notified before the actual conference state
        // changes, so we need to disable manually
    ::EnableWindow( GetDlgItem(m_hwnd, IDC_SECURE_CALL), FALSE );
}

void CDlgAcd::OnCallEnded()
{
        UpdateSecurityCheck(m_pConfRoom, m_hwnd, IDC_SECURE_CALL);
    ::CheckDlgButton( m_hwnd, IDC_SECURE_CALL, m_secure );
}

//--------------------------------------------------------------------------//
//      CEnumMRU::CEnumMRU.                                                                                                             //
//--------------------------------------------------------------------------//
CEnumMRU::CEnumMRU():
        RefCount( NULL )
{
}       //      CEnumMRU::CEnumMRU.


//--------------------------------------------------------------------------//
//      CEnumMRU::AddRef.                                                                                                               //
//--------------------------------------------------------------------------//
ULONG
STDMETHODCALLTYPE
CEnumMRU::AddRef(void)
{

        return( RefCount::AddRef() );

}       //      CEnumMRU::AddRef.


//--------------------------------------------------------------------------//
//      CEnumMRU::Release.                                                                                                              //
//--------------------------------------------------------------------------//
ULONG
STDMETHODCALLTYPE
CEnumMRU::Release(void)
{
        return( RefCount::Release() );

}       //      CEnumMRU::Release.


//--------------------------------------------------------------------------//
//      CEnumMRU::GetAddress.                                                                                                   //
//--------------------------------------------------------------------------//
HRESULT
STDMETHODCALLTYPE
CEnumMRU::GetAddress
(
        long                            index,
        RichAddressInfo **      ppAddr
){
        HRESULT result  = S_FALSE;

        if( GetNumEntries() <= index )
        {
                result = S_FALSE;
        }
        else
        {
                // HACKHACK georgep: Just using the Address as the display name. We
                // should clean this up later so we are not taking up extra memory and
                // registry space
                *ppAddr = CreateRai( GetString( index, ACD_ADDR ), (NM_ADDR_TYPE) GetDWORD( index, ACD_TYPE ), GetString( index, ACD_ADDR ) );
                result  = (*ppAddr == NULL)? E_OUTOFMEMORY: S_OK;
        }

        return( result );

}       //      CEnumMRU::GetAddress.


//--------------------------------------------------------------------------//
//      CEnumMRU::GetRecentAddresses.                                                                                   //
//--------------------------------------------------------------------------//
HRESULT
CEnumMRU::GetRecentAddresses
(
        IEnumRichAddressInfo ** ppEnum
){

        *ppEnum = new CEnumMRU();

        return( (*ppEnum == NULL)? E_OUTOFMEMORY: S_OK );

}       //      End of CEnumMRU::GetRecentAddresses.


//--------------------------------------------------------------------------//
//      CEnumMRU::FreeAddress.                                                                                                  //
//--------------------------------------------------------------------------//
HRESULT
CEnumMRU::FreeAddress
(
        RichAddressInfo **      ppAddr
){

        ClearRai( ppAddr );

        return( S_OK );

}       //      End of CEnumMRU::FreeAddress.


//--------------------------------------------------------------------------//
//      CEnumMRU::CopyAddress.                                                                                                  //
//--------------------------------------------------------------------------//
HRESULT
CEnumMRU::CopyAddress
(
        RichAddressInfo *       pAddrIn,
        RichAddressInfo **      ppAddrOut
){

        *ppAddrOut = DupRai( pAddrIn );

        return( (*ppAddrOut == NULL)? E_OUTOFMEMORY: S_OK );

}       //      End of CEnumMRU::CopyAddress.

CAcdMru::CAcdMru() :
        CMRUList2( _rgMruCall, CENTRYMAX_MRUCALL )
{
}

int CAcdMru::CompareEntry(int iItem, PMRUE pEntry)
{
        ASSERT(NULL != pEntry);

        int iRet = 0;

        LPCTSTR psz1 = GetString(iItem, ACD_ADDR);
        LPCTSTR psz2 = GetString(pEntry, ACD_ADDR);

        ASSERT(NULL != psz1 && NULL != psz2);

        return(lstrcmpi(psz1, psz2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgacd.h ===
#if	!defined( CDLGACD_H )
#define	CDLGACD_H
//--------------------------------------------------------------------------//

//--------------------------------------------------------------------------//
//	Header Files.															//
//--------------------------------------------------------------------------//
#include	"MRUList2.h"
#include	"richaddr.h"
#include	"confroom.h"

#define USE_GAL 0


#define NM_CALLDLG_DEFAULT 0x0000
#define NM_CALLDLG_NO_ILS_FILTER 0x0002
#define NM_CALLDLG_NO_ILS 0x0010

#if USE_GAL
#define NM_CALLDLG_NO_GAL 0x0020
#endif // USE_GAL

#define NM_CALLDLG_NO_WAB 0x0040
#define NM_CALLDLG_NO_SPEEDDIAL 0x0080
#define NM_CALLDLG_NO_HISTORY 0x0100

enum NmDlgCallOption
{
	nmDlgCallNormal = NM_CALLDLG_DEFAULT,
	nmDlgCallNoFilter = NM_CALLDLG_NO_ILS_FILTER,
	nmDlgCallNoIls = NM_CALLDLG_NO_ILS,

#if USE_GAL
	nmDlgCallNoGal = NM_CALLDLG_NO_GAL,
#endif // USE_GAL

	nmDlgCallNoWab = NM_CALLDLG_NO_WAB,
	nmDlgCallNoSpeedDial = NM_CALLDLG_NO_SPEEDDIAL,
	nmDlgCallNoHistory = NM_CALLDLG_NO_HISTORY,
	nmDlgCallSecurityAlterable = 0x0200,
	nmDlgCallSecurityOn = 0x0400,
	nmDlgCallNoServerEdit = 0x0800,
};

const DWSTR	_rgMruCall[] =
{
	{	3,			DLGCALL_MRU_KEY					},
	{	MRUTYPE_SZ,	REGVAL_DLGCALL_NAME_MRU_PREFIX	},
	{	MRUTYPE_SZ,	REGVAL_DLGCALL_ADDR_MRU_PREFIX	},
	{	MRUTYPE_DW,	REGVAL_DLGCALL_TYPE_MRU_PREFIX	}
};

enum ACD_MRUFIELDS
{
	ACD_NAME = 0,
	ACD_ADDR,
	ACD_TYPE,
} ;

const int	CENTRYMAX_MRUCALL	= 15;  // maximum number of recent calls


class CAcdMru : public CMRUList2
{
public:
	CAcdMru();

protected:
	int CompareEntry(int iItem, PMRUE pEntry);
} ;

//--------------------------------------------------------------------------//
//	CEnumMRU Class.															//
//--------------------------------------------------------------------------//
class CEnumMRU:	public IEnumRichAddressInfo,
				public RefCount,
				public CAcdMru
{
	public:		//	public constructor	------------------------------------//

		CEnumMRU();

	public:		//	public methods	----------------------------------------//

		ULONG
		STDMETHODCALLTYPE
		AddRef(void);

		ULONG
		STDMETHODCALLTYPE
		Release(void);

	    virtual
		HRESULT
		STDMETHODCALLTYPE
		GetAddress
		(
			long				index,
			RichAddressInfo **	ppAddr
		);


	public:		//	public static methods	--------------------------------//

		static
		HRESULT
		GetRecentAddresses
		(
			IEnumRichAddressInfo **	ppEnum
		);

		static
		HRESULT
		FreeAddress
		(
			RichAddressInfo **	ppAddr
		);

		static
		HRESULT
		CopyAddress
		(
			RichAddressInfo *	pAddrIn,
			RichAddressInfo **	ppAddrOut
		);

};	//	End of class CEnumMRU.


//--------------------------------------------------------------------------//
//	CDlgAcd Class.															//
//--------------------------------------------------------------------------//
class CDlgAcd : public IConferenceChangeHandler
{
	public:		//	public constructor	------------------------------------//

		CDlgAcd(CConfRoom *pConfRoom);


	public:		//	public destructor	------------------------------------//

		virtual
		~CDlgAcd();


	public:		// IConferenceChangeHandler methods
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
		{
			return(E_FAIL);
		}

        virtual ULONG STDMETHODCALLTYPE AddRef( void)
		{
			return(3);
		}

        virtual ULONG STDMETHODCALLTYPE Release( void)
		{
			return(2);
		}

		virtual void OnCallStarted();
		virtual void OnCallEnded();

		virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume) {}
		virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute) {}

		virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify) {}

		virtual void OnChangePermissions() {}

		virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel) {}

	public:		//	public methods	----------------------------------------//

		INT_PTR
		doModal
		(
			HWND				parent,
			RichAddressInfo *	rai,
			bool &				secure
		);


	public:		//	public static methods	--------------------------------//

		static
		void
		newCall
		(
			HWND	parentWindow,
			CConfRoom * pConfRoom
		);


	private:	//	private methods	----------------------------------------//

		bool
		onInitDialog
		(
			HWND	dialog
		);

		bool
		onCommand
		(
			int command,
			int	notification
		);

		void
		onEditChange(void);

		void
		onMruSelect
		(
			int	selection
		);

		void
		fillCallMruList(void);

		void
		fillAddressTypesList(void);

		int
		get_editText
		(
			LPTSTR	psz,
			int		cchMax
		);


	private:	//	private static methods	--------------------------------//

		static
		INT_PTR
		CALLBACK
		DlgProcAcd
		(
			HWND	dialog,
			UINT	message,
			WPARAM	wParam,
			LPARAM	lParam
		);


	private:	//	private members	----------------------------------------//

		HWND				m_hwnd;
		HWND				m_nameCombo;
		HWND				m_addressTypeCombo;
		RichAddressInfo *	m_pRai;
		RichAddressInfo *	m_mruRai;
		CConfRoom *			m_pConfRoom;
		bool				m_secure;
		CEnumMRU			m_callMruList;

};	//	End of class CDlgAcd.

//--------------------------------------------------------------------------//
#endif	//	!defined( CDLGACD_H )

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgauth.cpp ===
// File: dlgauth.cpp

#include "precomp.h"
#include "resource.h"
#include "ConfUtil.h"
#include "dlgauth.h"

extern GUID g_csguidSecurity;

/*  C  D L G  A U T H  */
/*-------------------------------------------------------------------------
    %%Function: CDlgAuth

-------------------------------------------------------------------------*/
CDlgAuth::CDlgAuth(INmCall * pCall):
	m_hwnd(NULL),
	m_pCall(pCall)
{
}

CDlgAuth::~CDlgAuth(void)
{
}


INT_PTR CDlgAuth::DoModal(void)
{
	return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_SECURE_CALL_INFO),
						::GetMainWindow(), CDlgAuth::DlgProcAuth, (LPARAM) this);
}



/*  D L G  P R O C  A U T H  */
/*-------------------------------------------------------------------------
    %%Function: DlgProcAuth

-------------------------------------------------------------------------*/
BOOL CALLBACK CDlgAuth::DlgProcAuth(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		ASSERT(NULL != lParam);
		::SetWindowLongPtr(hdlg, DWLP_USER, lParam);

		CDlgAuth * pDlg = (CDlgAuth *) lParam;
		pDlg->m_hwnd = hdlg;
		pDlg->OnInitDialog();
		return TRUE; // default focus is ok
	}

	case WM_COMMAND:
	{
		CDlgAuth * pDlg = (CDlgAuth*) GetWindowLongPtr(hdlg, DWLP_USER);
		if (NULL != pDlg)
		{
			pDlg->OnCommand(wParam, lParam);
		}
		break;
	}
	
	default:
		break;
	}

	return FALSE;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
BOOL CDlgAuth::OnCommand(WPARAM wParam, LPARAM lParam)
{
	ASSERT(NULL != m_hwnd);

	WORD wCmd = LOWORD(wParam);
	
	switch (wCmd)
	{
	case IDOK:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

	case IDCANCEL:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

	default:
		break;
	}

	return FALSE;
}



/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgAuth::OnInitDialog(void)
{
	PBYTE pb = NULL;
	ULONG cb = 0;

	CenterWindow(m_hwnd,HWND_DESKTOP);
	ASSERT(NULL != m_pCall);
	if (NULL != m_pCall && S_OK == m_pCall->GetUserData(g_csguidSecurity,&pb,&cb)) {
		if (cb > 0) {
			// Data was properly validated.
			SetDlgItemText(m_hwnd,IDC_SECURE_CALL_CERT,(LPCTSTR)pb);
			CoTaskMemFree(pb);
		}
		else {
			// Something went wrong.  Print an error message in the dialog box.
			TCHAR szTextBuf[MAX_PATH];
			if (FLoadString(IDS_SECURITY_INVALID_CERT,
					szTextBuf, CCHMAX(szTextBuf)))
			SetDlgItemText(m_hwnd,IDC_SECURE_CALL_CERT,szTextBuf);
		}
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgauth.h ===
// File: dlgauth.h

#ifndef _CDLGAUTH_H_
#define _CDLGAUTH_H_

#include "SDKInternal.h"

class CDlgAuth
{
private:
	HWND   m_hwnd;
	INmCall * m_pCall;
	
public:
	CDlgAuth(INmCall * pCall);
	~CDlgAuth();

	// Properties:
	INT_PTR DoModal(void);
	VOID OnInitDialog(void);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	static BOOL CALLBACK DlgProcAuth(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGAUTH_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dirutil.cpp ===
// File: util.cpp

#include "precomp.h"
#include "resource.h"

#include <oprahcom.h>
#include <strutil.h>
#include "dirutil.h"

/*  F I N D  S Z  C O M B O  */
/*-------------------------------------------------------------------------
    %%Function: FindSzCombo

    Find the item that matches at least the first part of the string
    from the names in the combo box list.

    Returns the item index or -1 if not found.
-------------------------------------------------------------------------*/
int FindSzCombo(HWND hwnd, LPCTSTR pszSrc, LPTSTR pszResult)
{
	int cch = lstrlen(pszSrc);
	if (0 == cch)
		return -1;

	TCHAR szBuff[CCHMAXSZ];
	lstrcpy(szBuff, pszSrc);
	CharUpperBuff(szBuff, CCHMAX(szBuff));
	
	COMBOBOXEXITEM cbi;
	ClearStruct(&cbi);
	cbi.mask = CBEIF_TEXT;
	cbi.pszText = pszResult;

	for ( ; ; cbi.iItem++)
	{
		cbi.cchTextMax = CCHMAX(szBuff);
		if (0 == SendMessage(hwnd, CBEM_GETITEM, 0, (LPARAM) &cbi))
			return -1;

		TCHAR szTemp[CCHMAXSZ];
		lstrcpy(szTemp, pszResult);
		CharUpperBuff(szTemp, CCHMAX(szTemp));

		if (0 == _StrCmpN(szBuff, szTemp, cch))
			return (int)(cbi.iItem);
	}
}

	// Atl defines a function AtlWaitWithMessageLoop
	// We are not linking with ATL, but when we start,
	// this function can be removed
HRESULT WaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	HRESULT hr = S_OK;
	
	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return S_OK;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			return E_FAIL;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return S_OK; // Event is now signaled.
		}
	}

	return hr;
}


/*  A U T O  C O M P L E T E  C O M B O  */
/*-------------------------------------------------------------------------
    %%Function: AutoCompleteCombo

    Update the current edit text with the suggestion and select it.
-------------------------------------------------------------------------*/
VOID AutoCompleteCombo(HWND hwnd, LPCTSTR psz)
{
	HWND hwndEdit = (HWND) SendMessage(hwnd, CBEM_GETEDITCONTROL, 0, 0);
	if (NULL != hwndEdit)
	{
		AutoCompleteEdit(hwndEdit, psz);
	}
}

VOID AutoCompleteEdit(HWND hwndEdit, LPCTSTR psz)
{
	const int cchLast = 0x7FFF;

	int cch = GetWindowTextLength(hwndEdit);
	Edit_SetSel(hwndEdit, cchLast, cchLast);
	Edit_ReplaceSel(hwndEdit, psz);
	Edit_SetSel(hwndEdit, cch, cchLast);
}



/*  F G E T  D E F A U L T  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: FGetDefaultServer

-------------------------------------------------------------------------*/
BOOL FGetDefaultServer(LPTSTR pszServer, UINT cchMax)
{
	RegEntry ulsKey(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
	LPTSTR psz = ulsKey.GetString(REGVAL_SERVERNAME);
	if (FEmptySz(psz))
		return FALSE;

	lstrcpyn(pszServer, psz, cchMax);
	return TRUE;
}


/*  F  C R E A T E  I L S  N A M E  */
/*-------------------------------------------------------------------------
    %%Function: FCreateIlsName

    Combine the server and email names to form an ILS name.
    Return TRUE if the result fit in the buffer.
-------------------------------------------------------------------------*/
BOOL FCreateIlsName(LPTSTR pszDest, LPCTSTR pszEmail, int cchMax)
{
	ASSERT(NULL != pszDest);

	TCHAR szServer[MAX_PATH];
	if (!FGetDefaultServer(szServer, CCHMAX(szServer)))
		return FALSE;

	if (FEmptySz(pszEmail))
	{
		WARNING_OUT(("FCreateIlsName: Null email name?"));
		return FALSE;
	}

	int cch = lstrlen(szServer);
	lstrcpyn(pszDest, szServer, cchMax);
	if (cch >= (cchMax-2))
		return FALSE;

	pszDest += cch;
	*pszDest++ = _T('/');
	cchMax -= (cch+1);
	
	lstrcpyn(pszDest, pszEmail, cchMax);

	return (lstrlen(pszEmail) < cchMax);
}

/*  D I S P L A Y  M S G  */
/*-------------------------------------------------------------------------
    %%Function: DisplayMsg

    Display a message with the standard title.
-------------------------------------------------------------------------*/
int DisplayMsg(HWND hwndParent, LPCTSTR pszMsg, UINT uType)
{
	TCHAR szTitle[MAX_PATH];
	FLoadString(IDS_MSGBOX_TITLE, szTitle, CCHMAX(szTitle));

	return ::MessageBox(hwndParent, pszMsg, szTitle, uType);
}

int DisplayMsgId(HWND hwndParent, UINT id)
{
	TCHAR szMsg[CCHMAXSZ];
	if (!FLoadString(id, szMsg, CCHMAX(szMsg)))
		return IDOK;

	return DisplayMsg(hwndParent, szMsg,
				MB_ICONINFORMATION | MB_SETFOREGROUND | MB_OK);
}

VOID DisplayMsgErr(HWND hwndParent, UINT id, PVOID pv)
{
	TCHAR szFormat[CCHMAXSZ];
	if (!FLoadString(id, szFormat, CCHMAX(szFormat)))
		return;

	TCHAR szMsg[CCHMAXSZ*2];
	wsprintf(szMsg, szFormat, pv);
	ASSERT(lstrlen(szMsg) < CCHMAX(szMsg));

	DisplayMsg(hwndParent, szMsg, MB_OK | MB_SETFOREGROUND | MB_ICONERROR);
}

VOID DisplayMsgErr(HWND hwndParent, UINT id)
{
	TCHAR szFormat[CCHMAXSZ];
	if (FLoadString(id, szFormat, CCHMAX(szFormat)))
	{
		DisplayMsg(hwndParent, szFormat, MB_OK | MB_SETFOREGROUND | MB_ICONERROR);
	}
}




/*  A D D  T O O L  T I P  */
/*-------------------------------------------------------------------------
    %%Function: AddToolTip

    Add a tooltip to a control.
-------------------------------------------------------------------------*/
VOID AddToolTip(HWND hwndParent, HWND hwndCtrl, UINT_PTR idMsg)
{
	if (NULL == hwndCtrl)
		return;

	HWND hwnd = ::CreateWindowEx(0, TOOLTIPS_CLASS, NULL, 0,
			CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
			hwndParent, NULL, ::GetInstanceHandle(), NULL);

	if (NULL == hwnd)
		return;
		
	TOOLINFO ti;
	ti.cbSize = sizeof(TOOLINFO);
	ti.uFlags = TTF_SUBCLASS | TTF_IDISHWND;
	ti.hwnd = hwndParent;
	ti.hinst = ::GetInstanceHandle();
	ti.uId = (UINT_PTR) hwndCtrl; // Note: subclassing the window!
	ti.lpszText = (LPTSTR) idMsg;

	::SendMessage(hwnd, TTM_ADDTOOL, 0, (LPARAM) (LPTOOLINFO) &ti);
}


/*  C R E A T E  S T A T I C  T E X T  */
/*-------------------------------------------------------------------------
    %%Function: CreateStaticText

-------------------------------------------------------------------------*/
HWND CreateStaticText(HWND hwndParent, INT_PTR id)
{
	HWND hwndCtrl = ::CreateWindowEx(0, g_cszStatic, NULL,
			WS_CHILD | WS_VISIBLE, 0, 0, 0, 0,
			hwndParent, (HMENU) id, ::GetInstanceHandle(), NULL);
	if (NULL == hwndCtrl)
		return NULL;

	// Set the font:
	::SendMessage(hwndCtrl, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

	TCHAR sz[CCHMAXSZ];
	if (FLoadString(PtrToInt((LPVOID)id), sz, CCHMAX(sz)))
	{
		::SetWindowText(hwndCtrl, sz);
	}
	return hwndCtrl;
}


/*  C R E A T E  B U T T O N  */
/*-------------------------------------------------------------------------
    %%Function: CreateButton

-------------------------------------------------------------------------*/
HWND CreateButton(HWND hwndParent, int ids, INT_PTR id)
{
	TCHAR sz[CCHMAXSZ];
	if (!FLoadString(ids, sz, CCHMAX(sz)))
		return NULL;

	HWND hwndCtrl = CreateWindow(g_cszButton, sz,
			WS_CHILD | WS_VISIBLE |  WS_TABSTOP |
			WS_CLIPCHILDREN | BS_PUSHBUTTON,
			0, 0, 0, 0,
			hwndParent, (HMENU) id,
			::GetInstanceHandle(), NULL);

	if (NULL != hwndCtrl)
	{
		::SendMessage(hwndCtrl, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);
	}
	return hwndCtrl;
}



bool IsValid_e164_Char( TCHAR t )
{
	bool bRet = false;

	switch( t )
	{
		case _T('0'):
		case _T('1'):
		case _T('2'):
		case _T('3'):
		case _T('4'):
		case _T('5'):
		case _T('6'):
		case _T('7'):
		case _T('8'):
		case _T('9'):
		case _T('#'):
		case _T('*'):
		case _T(','):
			bRet = true;

	}

	return bRet;
}


HRESULT ExtractAddress( DWORD dwAddrType, LPTSTR szAddress, LPTSTR szExtractedAddr, int cchMax )
{
	HRESULT hr = S_OK;
	LPTSTR pchRead;
	LPTSTR pchWrite;

	if( szAddress && szExtractedAddr && ( cchMax > 0 ) )
	{
		switch( dwAddrType )
		{
			case NM_ADDR_UNKNOWN:
			case NM_ADDR_IP:
			case NM_ADDR_MACHINENAME:
			case NM_ADDR_ULS:
			case NM_ADDR_ALIAS_ID:
				lstrcpyn( szExtractedAddr, szAddress, cchMax );
				break;

				// THese are phone numbers, yank the non-telephone num keys...
			case NM_ADDR_PSTN:
			case NM_ADDR_H323_GATEWAY:
			case NM_ADDR_ALIAS_E164:
			{
				pchRead = szAddress;
				pchWrite = szExtractedAddr;
				while( *pchRead != NULL )
				{
					if( IsValid_e164_Char( *pchRead ) )
					{
							// REVIEW: Is this rite for unicode??
						*pchWrite = *pchRead;					
						pchWrite = CharNext(pchWrite);
					}						
					pchRead = CharNext( pchRead );
				}
					// This will copy the NULL termination...
				*pchWrite = *pchRead;
			}
				
				break;
			
			default:
				hr = E_FAIL;
				break;

		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

	return hr;
}

bool IsValidAddress( DWORD dwAddrType, LPTSTR szAddr )
{
	bool bRet = false;

	if( szAddr && szAddr[0] )
	{
		bRet = true;
	}

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgcall.h ===
// File: dlgcall.h

#ifndef _CDLGCALL_H_
#define _CDLGCALL_H_

class CDlgCall : public RefCount
{
private:
	CCall * m_pCall;
	HWND    m_hwnd;

	int     m_nTextWidth;

	VOID CreateCallDlg();

public:
	CDlgCall(CCall * pCall);
	~CDlgCall();

	ULONG   STDMETHODCALLTYPE AddRef(void);
	ULONG   STDMETHODCALLTYPE Release(void);

	HWND GetHwnd(void)  {return m_hwnd;}

	VOID Destroy(void);
	VOID OnStateChange(void);

	VOID OnInitDialog(HWND hdlg);
	VOID OnCancel(void);
	VOID OnDestroy(void);

	static INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGCall_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgcall.cpp ===
// File: dlgcall.cpp
//
// Outgoing call progress dialog

#include "precomp.h"
#include "resource.h"
#include "call.h"
#include "dlgcall.h"
#include "conf.h"
#include "ConfUtil.h"

static int g_cDlgCall = 0; // number of outgoing call dialogs
static int g_dypOffset = 0;

/*  C  D L G  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: CDlgCall

-------------------------------------------------------------------------*/
CDlgCall::CDlgCall(CCall * pCall):
	RefCount(NULL),
	m_pCall(pCall),
	m_hwnd(NULL)
{
	ASSERT(NULL != m_pCall);
	m_pCall->AddRef();  // Released in destructor

	AddRef(); // Destroyed when call goes to a completed state

	if(!_Module.InitControlMode())
	{
		CreateCallDlg();
		g_cDlgCall++;
	}
}

CDlgCall::~CDlgCall(void)
{
	m_pCall->Release();

	g_cDlgCall--;
	if (0 == g_cDlgCall)
	{
		g_dypOffset = 0; // center new dialogs
	}
}

STDMETHODIMP_(ULONG) CDlgCall::AddRef(void)
{
	return RefCount::AddRef();
}

STDMETHODIMP_(ULONG) CDlgCall::Release(void)
{
	return RefCount::Release();
}



/*  C R E A T E  C A L L  D L G  */
/*-------------------------------------------------------------------------
    %%Function: CreateCallDlg

    Create the outgoing call progress dialog
-------------------------------------------------------------------------*/
VOID CDlgCall::CreateCallDlg()
{
	ASSERT(NULL == m_hwnd);
	ASSERT(NULL != m_pCall);
	LPCTSTR pcszName = m_pCall->GetPszName();
	if (NULL == pcszName)
		return;

	// determine the maximum width of the string
	TCHAR szMsg[MAX_PATH*2];
	FLoadString1(IDS_STATUS_WAITING, szMsg, (PVOID) pcszName);
	m_nTextWidth = DxpSz(szMsg);

	FLoadString1(IDS_STATUS_FINDING, szMsg, (PVOID) pcszName);
	int dxp = DxpSz(szMsg);
	if (m_nTextWidth < dxp)
	{
		m_nTextWidth = dxp;
	}

	m_hwnd = ::CreateDialogParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_CALL_PROGRESS),
						::GetMainWindow(), CDlgCall::DlgProc, (LPARAM) this);
	if (NULL == m_hwnd)
		return;
	
	::SetDlgItemText(m_hwnd, IDC_MSG_STATIC, szMsg);

	RECT rc;
	::GetWindowRect(m_hwnd, &rc);

	// Stretch the width to fit the person's name,
	int nWidth = RectWidth(rc) + m_nTextWidth;
	int nHeight = RectHeight(rc);
	MoveWindow(m_hwnd, 0, 0, nWidth, nHeight, FALSE);

	// Center it
	CenterWindow(m_hwnd, HWND_DESKTOP);
	::GetWindowRect(m_hwnd, &rc);

	// Move it down
	OffsetRect(&rc, 0, g_dypOffset);

	// Show, move, make topmost
	HWND hwndInsertAfter = HWND_TOPMOST;
#ifdef DEBUG
	{	// Hack to allow call placement to be debugged
		RegEntry reDebug(DEBUG_KEY, HKEY_LOCAL_MACHINE);
		if (0 == reDebug.GetNumber(REGVAL_DBG_CALLTOP, DEFAULT_DBG_CALLTOP))
		{
			hwndInsertAfter = HWND_NOTOPMOST;
		}
	}
#endif
	::SetWindowPos(m_hwnd, hwndInsertAfter, rc.left, rc.top, nWidth, nHeight,
		SWP_SHOWWINDOW | SWP_DRAWFRAME);

	// Adjust for next time
	g_dypOffset += nHeight;

	// Check for wrap-around
	RECT rcDeskTop;
	GetWindowRect(GetDesktopWindow(), &rcDeskTop);
	if ((rc.bottom + nHeight) > rcDeskTop.bottom)
	{
		g_dypOffset -= rc.top;
	}
}


/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgCall::OnInitDialog(HWND hdlg)
{
	HWND hwnd;
	RECT rc;

	::SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR) this);

	AddModelessDlg(hdlg);
			
	// Move the Cancel button
	hwnd = ::GetDlgItem(hdlg, IDCANCEL);
	if ((NULL != hwnd) && ::GetWindowRect(hwnd, &rc))
	{
		// Turn rc top and left into client coords:
		::MapWindowPoints(NULL, hdlg, (LPPOINT) &rc, 1);
		::SetWindowPos(hwnd, NULL,
				rc.left + m_nTextWidth, rc.top, 0, 0,
				SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);
	}

	// Stretch the text field:
	hwnd = ::GetDlgItem(hdlg, IDC_MSG_STATIC);
	if ((NULL != hwnd) && ::GetWindowRect(hwnd, &rc))
	{
		::SetWindowPos(hwnd, NULL,
				0, 0, m_nTextWidth, rc.bottom - rc.top,
				SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);

		// and set the font
		::SendMessage(hwnd, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	}

	// Start the animation
	hwnd = GetDlgItem(hdlg, IDC_CALL_ANIMATION);
	Animate_Open(hwnd, MAKEINTRESOURCE(IDA_CALL_ANIMATION));
	Animate_Play(hwnd, 0, -1, -1);
}

// Change the state of the call
VOID CDlgCall::OnStateChange(void)
{
	if (NULL == m_hwnd)
		return;

	// Assume the only state change is to "Waiting"
	TCHAR szMsg[MAX_PATH*2];
	FLoadString1(IDS_STATUS_WAITING, szMsg, (PVOID) m_pCall->GetPszName());
	SetWindowText(GetDlgItem(m_hwnd, IDC_MSG_STATIC), szMsg);
}


// Destroy the window
// Can be called by OnCancel or the owner
VOID CDlgCall::Destroy(void)
{
	if (NULL != m_hwnd)
	{
        ASSERT(IsWindow(m_hwnd));
		DestroyWindow(m_hwnd);
		m_hwnd = NULL;
	}
}

// Cancel/Close the dialog
VOID CDlgCall::OnCancel(void)
{
	ASSERT(NULL != m_pCall);
	m_pCall->Cancel(FALSE);

    return;
}

// Handle the destruction of the dialog
VOID CDlgCall::OnDestroy(void)
{
	SetWindowLongPtr(m_hwnd, DWLP_USER, 0L);

	HWND hwnd = GetDlgItem(m_hwnd, IDC_CALL_ANIMATION);
	if (NULL != hwnd)
	{		
		Animate_Stop(hwnd);
		Animate_Close(hwnd);
	}

	::RemoveModelessDlg(m_hwnd);

	Release(); // This normally destroys the object
}


/*  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: DlgProc

-------------------------------------------------------------------------*/
INT_PTR CALLBACK CDlgCall::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			CDlgCall * ppm = (CDlgCall*) lParam;
			ASSERT(NULL != ppm);
			ppm->AddRef();
			ppm->OnInitDialog(hDlg);
			return TRUE;
		}

		case WM_COMMAND:
		{
			switch (GET_WM_COMMAND_ID(wParam, lParam))
				{
			case IDCANCEL:
			{
				CDlgCall * pDlg = (CDlgCall*) GetWindowLongPtr(hDlg, DWLP_USER);
				if (NULL != pDlg)
				{
					// OnCancel will cause this window to be destoyed
					// AddRef this object so that it does not go away.
					pDlg->AddRef();
					pDlg->OnCancel();
					pDlg->Release();
				}
				break;
			}
			default:
				break;
				}

			return TRUE;
		}

		case WM_DESTROY:
		{
			CDlgCall * pDlg = (CDlgCall*) GetWindowLongPtr(hDlg, DWLP_USER);
			if (NULL != pDlg)
			{
				pDlg->OnDestroy();
				pDlg->Release();
			}
			break;
		}

		default:
			break;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgcall2.cpp ===
// File: dlgcall.cpp

#include "precomp.h"
#include "resource.h"
#include "help_ids.h"

#include "dlgcall2.h"

#include "dirutil.h"
#include "mrulist2.h"

#include "ldap.h"
#include "wab.h"
#include "calv.h"
#include "speedial.h"
#include "history.h"
#include "dlgacd.h"
#include "conf.h"
#include "confroom.h"
#include "confutil.h"
#include "confpolicies.h"
#include "cmd.h"

// GUI constants for this dialog
const UINT DX_BORDER = 6;     // Standard spacing for Office dialogs
const UINT DY_BORDER = 6;     // Standard spacing for Office dialogs
const UINT DY_COMBOBOX = 200; // Height of the dropped list

const UINT DX_DLGCALL_MIN = 460;
const UINT DY_DLGCALL_MIN = 400;

const UINT DX_DLGCALL_DEFAULT = 800;
const UINT DY_DLGCALL_DEFAULT = 600;

void GetDefaultRect(const HWND hwndParent, RECT & rcRect, const int iDefaultWidth, const int iDefaultHeight);
int GetPixelsPerChar(const HWND hwnd);

const static struct _ColumnInfo
{
	int	iColumnLabelIds;
	int	iMinColumnChars;

}	ciColumnInfo[ MAX_DIR_COLUMNS ]	=
{
	{	IDS_DIR_COLUMN_EMAIL,		28	},
	{	IDS_DIR_COLUMN_AUDIO,		0	},
	{	IDS_DIR_COLUMN_VIDEO,		0	},
	{	IDS_DIR_COLUMN_LAST_NAME,	16	},
	{	IDS_DIR_COLUMN_FIRST_NAME,	14	},
	{	IDS_DIR_COLUMN_LOCATION,	16	},
	{	IDS_DIR_COLUMN_COMMENTS,	22	}
};


///////////////////////////////////////////////////////////////////////////
// Local Data

static const DWORD	_mpIdHelpDlgCall[] =
{
	IDM_DLGCALL_DELETE_ILS,		IDH_FINDSOMEONE_DELETE_ILS,
	IDM_DLGCALL_NEWWINDOW,		IDH_FINDSOMEONE_BROWSER,
	IDM_DLGCALL_REFRESH,		IDH_FINDSOMEONE_REFRESH,
	ID_TB_HELP,					IDH_FINDSOMEONE_HELP,
	IDS_DLGCALL_EDIT_HDR,		IDH_PLACECALL_NAME,
	IDE_DLGCALL_NAME,			IDH_PLACECALL_NAME,
	IDC_DLGCALL_COMBO,			IDH_PLACECALL_INFOSTORE,
	IDS_SECURITY_CHECKBOX,		IDH_PLACECALL_SECURITY_CHKBX,
	IDL_DLGCALL_LIST,			IDH_PLACECALL_LIST,
	IDL_DLGCALL_LISTOWNERDATA,	IDH_PLACECALL_LIST,
	IDL_DLGCALL_ILS_LISTVIEW,	IDH_PLACECALL_LIST,
	IDOK,						IDH_PLACECALL_CALL,
	0,							0
};


int g_cBusy = 0;             // non-zero if busy connecting to server

#ifdef nmDlgCallNormal
const int NM_CALLDLG_DEFAULT       = nmDlgCallNormal;
const int NM_CALLDLG_NO_ILS_FILTER = nmDlgCallNoFilter;
const int NM_CALLDLG_NO_ILS        = nmDlgCallNoIls;
const int NM_CALLDLG_NO_GAL        = nmDlgCallNoGal;
const int NM_CALLDLG_NO_WAB        = nmDlgCallNoWab;
const int NM_CALLDLG_NO_SPEEDDIAL  = nmDlgCallNoSpeedDial;
const int NM_CALLDLG_NO_HISTORY    = nmDlgCallNoHistory;
#endif /* old NM_CALL_DLG constants */


// Dir list types:
const UINT DLT_ULS =					0;
const UINT DLT_IN_CALL_LOG =			1;
const UINT DLT_OUT_CALL_LOG =			2;
const UINT DLT_WAB =					3;

struct DLTCOLUMNINFO
{
	int		nColumns;			// number of columns
	int		nIconColumns;		// number of icon-only columns
	UINT	uStringID;			// string ID of first column
	LPTSTR	pszRVOrder;			// reg val to store column order
	LPTSTR	pszRVWidths;		// reg val to store column widths
	LPTSTR	pszRVSortAscending;	// reg val to store sort direction
	LPTSTR	pszRVSortColumn;	// reg val to store sort column
};

const DLTCOLUMNINFO g_rgDLColumnInfo[] =
{
	{ 	MAX_DIR_COLUMNS, 2, IDS_DIR_COLUMN_FIRST,			// DLT_ULS
		&REGVAL_DIR_COLUMN_ORDER, &REGVAL_DIR_COLUMN_WIDTHS,
		&REGVAL_DIR_SORT_ASCENDING, &REGVAL_DIR_SORT_COLUMN	},
};

CFindSomeone* CFindSomeone::s_pDlgCall= NULL;

///////////////////////////////////////////////////////////////////////////
int StringCompare( const TCHAR * const psz1, const TCHAR * const psz2 );


void UpdateSecurityCheck(CConfRoom *pConfRoom, HWND hDlg, UINT idCheck)
{
	bool userAlterable, secure;

	pConfRoom->get_securitySettings( userAlterable, secure );

	EnableWindow( GetDlgItem(hDlg, idCheck), userAlterable );
	::CheckDlgButton( hDlg, idCheck, secure? BST_CHECKED: BST_UNCHECKED );
}


/*  C  D L G  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: CFindSomeone

-------------------------------------------------------------------------*/
CFindSomeone::CFindSomeone(CConfRoom *pConfRoom):
	m_pAccel(NULL),
	m_dwOptions(0),
	m_hwndList(NULL),
	m_ilsListView(NULL),
	m_hwndCombo(NULL),
	m_hwndComboEdit(NULL),
	m_hwndEdit(NULL),
	m_webView( NULL ),
	m_WndOwnerDataListOldWndProc(NULL),
	m_fInEdit(FALSE),
	m_iSel(0),
	m_pMruServer(NULL),
	m_pUls(NULL),
	m_pSpeedDial(NULL),
#if USE_GAL
	m_pGAL(NULL),
#endif //#if USE_GAL
	m_pAlv(NULL),
	m_pWab(NULL),
	m_pHistory(NULL),
	m_pszDefault(NULL),
	m_pRai(NULL),
	m_pConfRoom(pConfRoom),
	m_bPlacedCall(false)
{
	SetEmptySz(m_szAddress);
	SetEmptySz(m_szDirectory);

	// BUGBUG georgep: Why are we checking m_dwOptions? It was set to 0 above.

	if ((0 == (m_dwOptions & NM_CALLDLG_NO_WAB)) &&
		(NULL == CWAB::GetInstance()) )
	{
		m_pWab = new CWAB();
	}

	if (0 == (m_dwOptions & NM_CALLDLG_NO_ILS))
	{
		m_pMruServer = GetMruListServer();
		m_pUls = new CLDAP();
	}

	if (0 == (m_dwOptions & NM_CALLDLG_NO_SPEEDDIAL))
	{
		m_pSpeedDial = new CSPEEDDIAL();
	}
	
#if USE_GAL
	if ((0 == (m_dwOptions & NM_CALLDLG_NO_GAL)) &&
		CGAL::FLoadMapiFns() )
	{
		m_pGAL = new CGAL();
	}
#endif // USE_GAL

	if (0 == (m_dwOptions & NM_CALLDLG_NO_HISTORY))
	{
		m_pHistory = new CHISTORY();
	}
	
	// Load the small icon list
	m_himlIcon = ImageList_Create(DXP_ICON_SMALL, DYP_ICON_SMALL, ILC_MASK, 1, 0);
	if (NULL != m_himlIcon)
	{
		HBITMAP hBmp = ::LoadBitmap(::GetInstanceHandle(), MAKEINTRESOURCE(IDB_ICON_IMAGES));
		if (NULL != hBmp)
		{
			ImageList_AddMasked(m_himlIcon, hBmp, TOOLBAR_MASK_COLOR);
			::DeleteObject(hBmp);
		}
	}

	m_pConfRoom->AddConferenceChangeHandler(this);
}

CFindSomeone::~CFindSomeone(void)
{
	// Clear any existing data
	if (NULL != m_pAlv)
	{
		m_pAlv->ClearItems();
	}

	delete m_pMruServer;

	if (NULL != m_pWab)
	{
		m_pWab->Release();
	}
	if (NULL != m_pUls)
	{
		m_pUls->Release();
	}
	if (NULL != m_pSpeedDial)
	{
		m_pSpeedDial->Release();
	}
	if (NULL != m_himlIcon)
	{
		ImageList_Destroy(m_himlIcon);
	}
#if USE_GAL
	if (NULL != m_pGAL)
	{
		m_pGAL->Release();
	}
#endif // USE_GAL
	if (NULL != m_pHistory)
	{
		m_pHistory->Release();
	}

	ClearRai(&m_pRai);

	m_pConfRoom->RemoveConferenceChangeHandler(this);
}


//--------------------------------------------------------------------------//
//	CFindSomeone::findSomeone.												//
//--------------------------------------------------------------------------//
void
CFindSomeone::findSomeone(CConfRoom *pConfRoom)
{
	if (NULL == s_pDlgCall)
	{
		s_pDlgCall = new CFindSomeone(pConfRoom);
		s_pDlgCall->doModeless();
	}

	if (NULL != s_pDlgCall)
	{
		HWND hwnd = s_pDlgCall->GetWindow();

		::ShowWindow( hwnd, SW_RESTORE );
		::SetForegroundWindow( hwnd );
	}

}	//	End of CFindSomeone::findSomeone.


//--------------------------------------------------------------------------//
//	CDlgCall::Destroy.														//
//--------------------------------------------------------------------------//
void
CFindSomeone::Destroy()
{
WARNING_OUT(("Entering CFindSomeone::Destroy( )..."));
	CFindSomeone *	pDlgCall	= s_pDlgCall;
	s_pDlgCall = NULL;

	if( pDlgCall != NULL )
	{
		if( pDlgCall->m_pUls != NULL )
		{
			//	Stop the CLDAP thread from trying to interact with the FindSomeone
			//	windows after we've already destroyed them...
			pDlgCall->m_pUls->CloseServer();
		}

		HWND hwnd = pDlgCall->GetWindow();
		if (NULL != hwnd)
		{
WARNING_OUT(("CFindSomeone::Destroy( ): destroying windows..."));
			DestroyWindow(hwnd);
		}

		pDlgCall->Release();
	}
WARNING_OUT(("Exiting CFindSomeone::Destroy( )..."));

}	//	End of CDlgCall::Destroy.


HWND CFindSomeone::GetHwndList()
{
	return ( m_pAlv && m_pAlv->FOwnerData() ) ?
		m_hwndOwnerDataList : (m_pAlv == (CALV *) m_pUls)? m_ilsListView: m_hwndList;
}

RAI * CFindSomeone::GetAddrInfo()
{
	return DupRai(m_pRai);
}


/*  F  M S G  S P E C I A L  */
/*-------------------------------------------------------------------------
    %%Function: FMsgSpecial

    Return TRUE if this is a special message, not to be passed to IsDialogMessage
-------------------------------------------------------------------------*/
BOOL CFindSomeone::FMsgSpecial(MSG * pMsg)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_CHAR:
		if (VK_F5 == pMsg->wParam)
			return TRUE;
		if (VK_RETURN == pMsg->wParam)
		{
			if (m_hwndComboEdit == GetFocus())
			{
				return TRUE;
			}
		}
		break;
	default:
		break;
	}

	return FALSE;
}


/*  D O  M O D A L  */
/*-------------------------------------------------------------------------
    %%Function: DoModal

-------------------------------------------------------------------------*/
HRESULT
CFindSomeone::doModeless(void)
{

#if 0
	HACCEL hAccel = LoadAccelerators(::GetInstanceHandle(), MAKEINTRESOURCE(IDA_DLGCALL));
#endif

	HRESULT hr = CreateDlgCall(NULL);
#if 0
	if (SUCCEEDED(hr) && (NULL != m_hwnd))
	{
		while (IsWindow(m_hwnd))
		{
			MSG msg;
			if (!::GetMessage(&msg, NULL, 0, 0))
			{
				// Don't eat the WM_QUIT
				PostQuitMessage(msg.wParam);
				break; // out of loop
			}

			if (FMsgSpecial(&msg) || !IsDialogMessage(m_hwnd, &msg))
			{
				if (FALSE == ::TranslateAccelerator(m_hwnd, hAccel, &msg))
				{
					::TranslateMessage(&msg);
					::DispatchMessage(&msg);
				}
			}
		}
	}
#endif

	return hr;
}


// Determine the standard font size
VOID CFindSomeone::CalcDyText(void)
{
	m_dyText = 14; // default to something reasonable
	HWND hwnd = GetWindow();

	ASSERT(NULL != hwnd);

	HDC hdc = GetDC(hwnd);
	if (NULL == hdc)
		return;

	TEXTMETRIC tm;
	if (GetTextMetrics(hdc, &tm))
	{
		m_dyText = tm.tmHeight;
	}

	// Leave space for 4 n's (two on each side)
	TCHAR sz[MAX_PATH];
	const int cSpaceN = 4;
	for (int ich = 0; ich < cSpaceN; ich++)
	{
		sz[ich] = _T('n');
	}
	if (FLoadString( IDS_DLGCALL_CLOSE, &sz[cSpaceN], CCHMAX(sz)-cSpaceN))
	{
		HFONT hfont = SelectFont(hdc, ::GetDefaultFont());
		RECT rc;
		SetRect(&rc, 0, 0, 0, 0);
		m_dyButton = 2*DY_BORDER + DrawText(hdc, sz, -1, &rc, DT_CALCRECT);
		m_dxButton = rc.right;
		hfont = SelectFont(hdc, hfont);
	}

	ReleaseDC(hwnd, hdc);
}

HWND CreatIconButton(HWND hwndParent, int idTooltip, int idCmd, int idIcon)
{
	HWND hwndButton = CreateButton( hwndParent, idTooltip, idCmd );
	if (NULL != hwndButton)
	{
		AddToolTip(hwndParent, hwndButton, idTooltip);

		SetWindowLong(hwndButton, GWL_STYLE, BS_PUSHBUTTON|BS_ICON|WS_VISIBLE|WS_CHILD|WS_TABSTOP);

		HANDLE hIcon = LoadImage(GetInstanceHandle(), MAKEINTRESOURCE(idIcon),
			IMAGE_ICON, 0, 0, 0);
		SendMessage(hwndButton, BM_SETIMAGE, IMAGE_ICON, reinterpret_cast<LPARAM>(hIcon));
	}

	return(hwndButton);
}
	
/*  C R E A T E  D L G  C A L L  */
/*-------------------------------------------------------------------------
    %%Function: CreateDlgCall

	The order in which these windows is created is very important.
	See the Layout function and pay attention to the tab order

-------------------------------------------------------------------------*/
HRESULT CFindSomeone::CreateDlgCall(HWND hwndParent)
{
	TCHAR sz[CCHMAXSZ];

	HRESULT hr = S_OK;
	
	if (NULL == m_himlIcon)
		return E_FAIL; // no pretty icons, don't bother trying to continue

	if (!FLoadString(IDS_DLGCALL_TITLE, sz, CCHMAX(sz)))
		return E_FAIL;

	// Get the window position
	PVOID pv;
	RECT rcDest; // left, right, width, height
	RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);
	if (sizeof(rcDest) == re.GetBinary(REGVAL_DLGCALL_POSITION, &pv))
	{
		CopyMemory(&rcDest, pv, sizeof(rcDest));
	}
	else
	{
		GetDefaultRect( hwndParent, rcDest, DX_DLGCALL_DEFAULT, DY_DLGCALL_DEFAULT );
		rcDest.right	-= rcDest.left;
		rcDest.bottom	-= rcDest.top;
	}

	if (!CFrame::Create(
		hwndParent,
		sz,
		WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME,
		0,
		rcDest.left, rcDest.top, rcDest.right, rcDest.bottom,
		GetInstanceHandle(),
		LoadIcon(GetInstanceHandle(), MAKEINTRESOURCE(IDI_WEBVIEW))
		))
	{
		return E_OUTOFMEMORY;
	}

	HWND hwndThis = GetWindow();

	CalcDyText();

	//////////////////////////////////
	// Static text at the top
	HWND hwnd = CreateStaticText(hwndThis, IDS_DLGCALL_HDR);

	DWORD dwStyle = WS_CHILD | WS_BORDER | WS_VSCROLL | WS_VISIBLE | WS_TABSTOP |
				WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBS_AUTOHSCROLL;

	// Either a complicated combo edit/listbox or a simple drop list
	if ((NULL != m_pUls) && m_pUls->FAvailable())
	{
		dwStyle |= (0 != (nmDlgCallNoServerEdit & m_dwOptions)) ?
		          CBS_DROPDOWNLIST : CBS_DROPDOWN;
	}
	else
	{
		dwStyle |= CBS_DROPDOWNLIST;
	}

	m_hwndCombo = ::CreateWindowEx(0L, g_cszComboBoxEx, g_cszEmpty, dwStyle,
				0, 0, DX_BORDER, DY_COMBOBOX,
				hwndThis, (HMENU) IDC_DLGCALL_COMBO,
				::GetInstanceHandle(), NULL);
	if (NULL != m_hwndCombo)
	{
		// Set the icons
		::SendMessage(m_hwndCombo, CBEM_SETIMAGELIST, 0, (LPARAM) m_himlIcon);

		// Set the font:
		::SendMessage(m_hwndCombo, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

		// Limit the text
		::SendMessage(m_hwndCombo, CB_LIMITTEXT, CCHMAXSZ_ADDRESS-1, 0L);

		// Set extended user interface
		::SendMessage(m_hwndCombo, CB_SETEXTENDEDUI, 1, 0L);

		m_hwndComboEdit = (HWND) SendMessage(m_hwndCombo, CBEM_GETEDITCONTROL, 0, 0);
		if (NULL != m_hwndComboEdit)
		{
			// Add a tooltip to the combo box (actually, the edit control)
			AddToolTip(hwndThis, m_hwndComboEdit, IDS_DLGCALL_COMBO_TOOLTIP);
		}
		else
		{
			// Add a tooltip to the combo box
			AddToolTip(hwndThis, m_hwndCombo, IDS_DLGCALL_COMBO_TOOLTIP);
		}
	}

	CreatIconButton(hwndThis, IDS_TT_DELETE_ILS, IDM_DLGCALL_DELETE_ILS, IDI_DELETE);
	CreatIconButton(hwndThis, IDS_TT_NEWWINDOW , IDM_DLGCALL_NEWWINDOW , IDI_NEWHTMLWINDOW);
	CreatIconButton(hwndThis, IDS_TT_REFRESH   , IDM_DLGCALL_REFRESH   , IDI_REFRESH);
	CreatIconButton(hwndThis, IDS_TT_HELP      , ID_TB_HELP            , IDI_HELP);

	//////////////////////////////////
	// GroupBox
	m_hwndFrame  = ::CreateWindowEx( 0, TEXT( "button" ), g_cszEmpty,
				WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | WS_GROUP | BS_GROUPBOX,
				0, 0, 0, 0,
				hwndThis, (HMENU) -1,
				::GetInstanceHandle(), NULL);

	//////////////////////////////////
	// Edit Control
	CreateStaticText(hwndThis, IDS_DLGCALL_EDIT_HDR);

	m_hwndEdit = ::CreateWindowEx(WS_EX_CLIENTEDGE, g_cszEdit, g_cszEmpty,
				WS_CHILD | WS_BORDER | WS_VISIBLE | WS_TABSTOP | WS_CLIPCHILDREN |
				ES_AUTOHSCROLL,
				0, 0, 0, 0,
				hwndThis, (HMENU) IDE_DLGCALL_NAME,
				::GetInstanceHandle(), NULL);
	if (NULL != m_hwndEdit)
	{
		// Set the font:
		::SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

		// Limit the text
		::SendMessage(m_hwndEdit, EM_LIMITTEXT, CCHMAXSZ_ADDRESS-1, 0L);

		// Add a tooltip to the edit control
		AddToolTip(hwndThis, m_hwndEdit, IDS_DLGCALL_EDIT_TOOLTIP);
	}

	////////////////////////////////
	// Main Listbox
	m_hwndList = CreateWindowEx(WS_EX_CLIENTEDGE, g_cszListView, g_cszEmpty,
			WS_CHILD | WS_CLIPCHILDREN | WS_BORDER | WS_TABSTOP | WS_VISIBLE |
			LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS |
			LVS_SORTASCENDING | LVS_NOSORTHEADER,
			0, 0, 0, 0,
			hwndThis, (HMENU) IDL_DLGCALL_LIST,
			::GetInstanceHandle(), NULL);
	if (NULL != m_hwndList)
	{
		ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);
		ListView_SetImageList(m_hwndList, m_himlIcon, LVSIL_SMALL);

		LV_COLUMN lvc;
		ClearStruct(&lvc);
		lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
		lvc.pszText = sz;

		if (FLoadString(IDS_NAME, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 0;
			ListView_InsertColumn(m_hwndList, IDI_DLGCALL_NAME, &lvc);
		}

		if (FLoadString(IDS_ADDRESS, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 1;
			ListView_InsertColumn(m_hwndList, IDI_DLGCALL_ADDRESS, &lvc);
		}
		
		m_cVisible = ListView_GetCountPerPage(m_hwndList);
	}


	////////////////////////////////
	// OwnerData Listbox
	m_hwndOwnerDataList = CreateWindowEx(WS_EX_CLIENTEDGE, g_cszListView, g_cszEmpty,
			WS_CHILD | WS_CLIPCHILDREN | WS_BORDER | WS_TABSTOP | WS_VISIBLE |
			LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SHAREIMAGELISTS |
			LVS_SORTASCENDING | LVS_NOSORTHEADER | LVS_OWNERDATA,
			0, 0, 0, 0,
			hwndThis, (HMENU) IDL_DLGCALL_LISTOWNERDATA,
			::GetInstanceHandle(), NULL);

	if (NULL != m_hwndOwnerDataList)
	{
		ListView_SetExtendedListViewStyle(m_hwndOwnerDataList, LVS_EX_FULLROWSELECT);
		ListView_SetImageList(m_hwndOwnerDataList, m_himlIcon, LVSIL_SMALL);

		LV_COLUMN lvc;
		ClearStruct(&lvc);
		lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
		lvc.pszText = sz;

		if (FLoadString(IDS_NAME, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 0;
			ListView_InsertColumn(m_hwndOwnerDataList, IDI_DLGCALL_NAME, &lvc);
		}

		if (FLoadString(IDS_ADDRESS, sz, CCHMAX(sz)))
		{
			lvc.iSubItem = 1;
			ListView_InsertColumn(m_hwndOwnerDataList, IDI_DLGCALL_ADDRESS, &lvc);
		}

		m_WndOwnerDataListOldWndProc = reinterpret_cast< WNDPROC >(GetWindowLongPtr(m_hwndOwnerDataList, GWLP_WNDPROC));
		SetWindowLongPtr(m_hwndOwnerDataList, GWLP_USERDATA, reinterpret_cast< LONG_PTR >( this ));
		SetWindowLongPtr(m_hwndOwnerDataList, GWLP_WNDPROC, reinterpret_cast< LONG_PTR >( OwnerDataListWndProc));
    }




	////////////////////////////////
	// ILS Listbox
	m_ilsListView = CreateWindowEx(	WS_EX_CLIENTEDGE,
									WC_LISTVIEW,		// list view class
									TEXT( "" ),			// no default text
									WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_TABSTOP |
									LVS_REPORT | LVS_SINGLESEL | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS | LVS_SHOWSELALWAYS,
									0, 0,
									0, 0,
									hwndThis,
									(HMENU) IDL_DLGCALL_ILS_LISTVIEW,
									::GetInstanceHandle(),
									NULL );

	if( m_ilsListView != NULL )
	{
		InitColumns();

		// Associate the image list with the list view
		ListView_SetImageList( m_ilsListView, m_himlIcon, LVSIL_SMALL);

		// set the style to do drag and drop headers and full row select
		ListView_SetExtendedListViewStyle( m_ilsListView, ListView_GetExtendedListViewStyle( m_ilsListView ) |
															LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES );
	}

	TCHAR szWebDir[1024];
	CDirectoryManager::get_webDirectoryUrl(szWebDir, ARRAY_ELEMENTS(szWebDir));

	m_webView = CreateWindowEx( WS_EX_CLIENTEDGE | WS_EX_CONTROLPARENT,
								TEXT( "AtlAxWin" ),
								szWebDir,
								WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_TABSTOP,
								0, 0,
								0, 0,
								hwndThis,
								(HMENU) IDL_DLGCALL_WEB_VIEW,
								::GetInstanceHandle(),
								NULL );

	//////////////////////////////////
	// Security Control
	FLoadString( IDS_SECURITY_CHECKBOX, sz, CCHMAX( sz ) );

	HWND	securityCheckBox;
	
	securityCheckBox = ::CreateWindow(
		TEXT( "button" ),
		sz,
		WS_CHILD | WS_TABSTOP | WS_VISIBLE | BS_AUTOCHECKBOX | BS_MULTILINE | BS_TOP,
		0, 0, 0, 0,
		hwndThis,
		(HMENU) IDS_SECURITY_CHECKBOX,
		::GetInstanceHandle(),
		NULL );

	if( securityCheckBox != NULL )
	{
		// Set the font:
		::SendMessage(securityCheckBox, WM_SETFONT, (WPARAM) GetDefaultFont(), 0);

		UpdateSecurityCheck(m_pConfRoom, hwndThis, IDS_SECURITY_CHECKBOX);
	}

	CreateButton( hwndThis, IDS_DLGCALL_CALL, IDOK );
	CreateButton( hwndThis, IDS_DLGCALL_CLOSE, IDCANCEL );

	// Finally, initialize the data in each list
	InitAlv();

	Layout();

	if( m_ilsListView != NULL )
	{
		LoadColumnInfo();
	}

	if (m_pConfRoom->FIsConferenceActive())
	{
		// Simulate a call started to get all the states right
		OnCallStarted();
	}

	ShowWindow(hwndThis, SW_SHOWNORMAL);

	::EnableWindow(GetDlgItem(hwndThis, IDOK), FALSE);
	
	if( m_pAlv )
	{
		SetFocus(m_hwndEdit);
		if (!FEmptySz(m_pszDefault))
		{
			SetWindowText(m_hwndEdit, m_pszDefault);
		}
	}
	else
	{
		hr = E_FAIL;
	}

	return hr;
}

bool
get_textRect
(
	const HWND			window,
	RECT &				rect,
	const TCHAR * const	measureText = NULL
);


//--------------------------------------------------------------------------//
//	get_textRect.															//
//--------------------------------------------------------------------------//
bool
get_textRect
(
	const HWND			window,
	RECT &				rect,
	const TCHAR * const	measureText
){
	HDC		dc		= GetDC( window );
	bool	result	= false;

	if( dc != NULL )
	{
		HFONT	font = SelectFont( dc, ::GetDefaultFont() );
		
		if( measureText != NULL )
		{
			DrawText( dc, measureText, -1, &rect, DT_CALCRECT | DT_WORDBREAK );
			result = true;
		}
		else
		{
			int	length;

			if( (length = ::SendMessage( window, WM_GETTEXTLENGTH, 0, 0 )) > 0 )
			{
				TCHAR *	text	= new TCHAR [ length + 1 ];

				if( text != NULL )
				{
					::SendMessage( window, WM_GETTEXT, length + 1, (LPARAM) text );
					DrawText( dc, text, -1, &rect, DT_CALCRECT | DT_WORDBREAK );
					delete [] text;
					result = true;
				}
			}
		}

		SelectFont( dc,  font );
		ReleaseDC( window, dc );
	}

	return( result );

}	//	End of get_textRect.


//--------------------------------------------------------------------------//
//	CFindSomeone::Layout.													//
//--------------------------------------------------------------------------//
void
CFindSomeone::Layout(void)
{
	// BUGBUG georgep: Hard coded for now
	static const int IconButtonWidth = 24;
	static const int IconButtonHeight = 24;

	static const int idIconButtons[] =
	{
		IDM_DLGCALL_DELETE_ILS,
		IDM_DLGCALL_NEWWINDOW,
		IDM_DLGCALL_REFRESH,
		ID_TB_HELP,
	};
	static const int NumIconButtons = ARRAY_ELEMENTS(idIconButtons);

	HWND hwnd = GetWindow();

	HDWP hdwp = BeginDeferWindowPos(15);

	//	Get client area (inside margin/border)...
	RECT rc;
	GetClientRect(hwnd, &rc);
	int	clientWidth		= rc.right - 2*DX_BORDER;
	int	clientHeight	= rc.bottom - (DY_BORDER + DY_BORDER + m_dyButton);

	int maxComboLabelWidth	= (clientWidth - NumIconButtons*(DX_BORDER + IconButtonWidth)) / 2;

	HWND	comboLabel	= GetDlgItem( hwnd, IDS_DLGCALL_HDR );
	RECT	comboRect;
	RECT	comboLabelRect;

	GetWindowRect( m_hwndCombo, &comboRect );

	SetRect( &comboLabelRect, 0, 0, maxComboLabelWidth, 0 );
	get_textRect( comboLabel, comboLabelRect );

	int	comboHeight			= RectHeight( comboRect );
	int	comboLabelWidth		= RectWidth( comboLabelRect );
	int	comboLabelHeight	= RectHeight( comboLabelRect );

	int	maxHeight	= max( comboHeight, comboLabelHeight );

	int comboLabelLeft	= DX_BORDER;
	int	comboLabelTop	= max( DY_BORDER, (DY_BORDER + ((maxHeight - comboLabelHeight) / 2)) );

	hdwp = DeferWindowPos(hdwp,
					comboLabel,
					NULL,
					comboLabelLeft,
					comboLabelTop,
					comboLabelWidth,
					comboLabelHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	int	comboLeft		= comboLabelLeft + comboLabelWidth + DX_BORDER;
	int	comboTop		= max( DY_BORDER, (DY_BORDER + ((maxHeight - comboHeight) / 2)) );
	int comboWidth		= clientWidth - (comboLabelLeft + comboLabelWidth
		+ NumIconButtons*(DX_BORDER + IconButtonWidth) );

	hdwp = DeferWindowPos(hdwp,
					m_hwndCombo,
					NULL,
					comboLeft,
					comboTop,
					comboWidth,
					DY_COMBOBOX,
					SWP_NOACTIVATE | SWP_NOZORDER );

	{
		for (int i=0; i<NumIconButtons; ++i)
		{
			hdwp = DeferWindowPos(hdwp,
				GetDlgItem(hwnd, idIconButtons[i]),
				NULL,
				comboLeft + comboWidth + DX_BORDER + i*(IconButtonWidth+DX_BORDER),
				comboTop,
				IconButtonWidth,
				IconButtonHeight,
				SWP_NOACTIVATE | SWP_NOZORDER );
		}
	}

	int	frameTop	= maxHeight + DY_BORDER;

	hdwp = DeferWindowPos(hdwp,
					m_hwndFrame,
					NULL,
					DX_BORDER,
					frameTop,
					clientWidth,
					clientHeight - frameTop,
					SWP_NOACTIVATE | SWP_NOZORDER );

	// Add a little because groups draw inside their bounds
	frameTop += 2 * DY_BORDER;

	RECT	editLabelRect;
	HWND	editLabel		= GetDlgItem( hwnd, IDS_DLGCALL_EDIT_HDR );
	int		editLabelWidth	= (clientWidth - (DX_BORDER * 6)) / 2;

	SetRect( &editLabelRect, 0, 0, editLabelWidth, 0 );
	get_textRect( editLabel, editLabelRect );

	int	editLabelHeight	= RectHeight( editLabelRect );
	int editLabelLeft	= DY_BORDER * 3;
	int editLabelTop	= frameTop + DY_BORDER;

	hdwp = DeferWindowPos(hdwp,
					editLabel,
					NULL,
					editLabelLeft,
					editLabelTop,
					editLabelWidth,
					editLabelHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	int editTop	= editLabelTop + editLabelHeight + DY_BORDER;

	// Edit Control
	hdwp = DeferWindowPos(hdwp,
					m_hwndEdit,
					NULL,
					editLabelLeft,
					editTop,
					editLabelWidth,
					comboHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	int	buttonTop		= clientHeight - ((DY_BORDER * 3) / 2) - m_dyButton;
	int	listViewLeft	= 3 * DX_BORDER;
	int	listViewTop		= editTop + comboHeight + DY_BORDER;
	int	listViewWidth	= clientWidth - (DX_BORDER * 4);
	int	listViewHeight	= buttonTop - listViewTop - DY_BORDER;
	int	columns			= _GetCurListViewNumColumns();
	int	columnWidth		= listViewWidth / columns;

	// ListBox
	hdwp = DeferWindowPos(hdwp,
					m_hwndList,
					NULL,
					listViewLeft,
					listViewTop,
					listViewWidth,
					listViewHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	hdwp = DeferWindowPos(hdwp,
					m_hwndOwnerDataList,
					NULL,
					listViewLeft,
					listViewTop,
					listViewWidth,
					listViewHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	hdwp = DeferWindowPos(hdwp,
					m_ilsListView,
					NULL,
					listViewLeft,
					listViewTop,
					listViewWidth,
					listViewHeight,
					SWP_NOACTIVATE | SWP_NOZORDER );

	HWND hWndList = GetHwndList();

	if( hWndList != m_ilsListView )
	{
		for( int i = 0; i < columns; i++ )
		{
			ListView_SetColumnWidth( hWndList, i, columnWidth );
		}
	}

	InvalidateRect( ListView_GetHeader(hWndList), NULL, true );

	m_cVisible = ListView_GetCountPerPage(hWndList);
	
	{
		int		securityWidth	= editLabelWidth - GetSystemMetrics( SM_CXSMICON );
		HWND	security		= GetDlgItem( hwnd, IDS_SECURITY_CHECKBOX );
		RECT	securityRect;

		SetRect( &securityRect, 0, 0, securityWidth, 0 );
		get_textRect( security, securityRect );

		// + 2 for the focus rect
		int	securityHeight	= RectHeight( securityRect ) + 2;
		int checkHeight = GetSystemMetrics(SM_CYMENUCHECK);
		securityHeight = max (securityHeight, checkHeight);

		hdwp = DeferWindowPos(hdwp,
						security,
						NULL,
						listViewLeft,
						buttonTop,
						securityWidth,
						securityHeight,
						SWP_NOACTIVATE | SWP_NOZORDER );
	}

	HWND	callButton =	GetDlgItem( hwnd, IDOK );

	hdwp = DeferWindowPos(hdwp,
					callButton,
					NULL,
					clientWidth - DX_BORDER - m_dxButton,
					buttonTop,
					m_dxButton,
					m_dyButton,
					SWP_NOACTIVATE | SWP_NOZORDER );

	hdwp = DeferWindowPos(hdwp,
					m_webView,
					NULL,
					DX_BORDER,
					frameTop,
					clientWidth,
					clientHeight - frameTop,
					SWP_NOACTIVATE | SWP_NOZORDER );

	// Center the close button at the bottom of the window
	HWND	closeButton =	GetDlgItem( hwnd, IDCANCEL );

	hdwp = DeferWindowPos(hdwp,
					closeButton,
					NULL,
					(clientWidth - m_dxButton) / 2,
					clientHeight + DY_BORDER,
					m_dxButton,
					m_dyButton,
					SWP_NOACTIVATE | SWP_NOZORDER );

	EndDeferWindowPos(hdwp);
}	//	End of CFindSomeone::Layout.

static BOOL IsInClient(HWND hwnd, POINT *ppt)
{
	RECT rc;
	GetClientRect(hwnd, &rc);
	MapWindowPoints(hwnd, HWND_DESKTOP, (POINT *) &rc, 2);
	return(PtInRect(&rc, *ppt));
}

void CFindSomeone::OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
{
	POINT pt = { xPos, yPos };

	if (IsInClient(GetHwndList(), &pt))
	{
		m_pAlv->OnRClick(pt);
		return;
	}

	if (IsInClient(GetWindow(), &pt))
	{
		DoHelpWhatsThis(reinterpret_cast<WPARAM>(hwndContext), _mpIdHelpDlgCall);
		return;
	}

	FORWARD_WM_CONTEXTMENU(hwnd, hwndContext, xPos, yPos, CFrame::ProcessMessage);
}

LRESULT CFindSomeone::ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		HANDLE_MSG(hwnd, WM_COMMAND    , OnCommand);
		HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);

	case WM_GETMINMAXINFO:
	{
		LPMINMAXINFO lpminmax = (LPMINMAXINFO) lParam;
		lpminmax->ptMinTrackSize.x = DX_DLGCALL_MIN;
		lpminmax->ptMinTrackSize.y = DY_DLGCALL_MIN;
		return 0;
	}

	case WM_DISPLAY_MSG:
	{
		DisplayMsgId(hwnd, (int) wParam);
		return 0;
	}

	case WM_CLOSE:
		Destroy();
		break;

	case WM_CREATE:
	{
		HACCEL hAccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_DLGCALL));
		if (NULL != hAccel)
		{
			m_pAccel = new CTranslateAccelTable(hwnd, hAccel);
			if (NULL != m_pAccel)
			{
				AddTranslateAccelerator(m_pAccel);
			}
		}

		// Must be done AFTER adding the accelerator table
		AddModelessDlg(hwnd);

		break;
	}

	case WM_DESTROY:
	{
		if (NULL != m_pAccel)
		{
			RemoveTranslateAccelerator(m_pAccel);
			m_pAccel->Release();
			m_pAccel = NULL;
		}

		RemoveModelessDlg(hwnd);

		if (NULL != m_pAlv)
		{
			m_pAlv->ClearItems();
			m_pAlv->ClearHwnd();
		}

		RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);

		// Save the window size/position
		WINDOWPLACEMENT wp = { sizeof(wp), };
		if (GetWindowPlacement(hwnd, &wp))
		{
			RECT rc = wp.rcNormalPosition;
			rc.right -= rc.left;
			rc.bottom -= rc.top;
			re.SetValue(REGVAL_DLGCALL_POSITION, &rc, sizeof(rc));
		}

		// Save the selected view
		TCHAR szServer[CCHMAXSZ_SERVER];
		if (0 != GetWindowText(m_hwndComboEdit, szServer, CCHMAX(szServer)))
		{
			TRACE_OUT(("Saving last used directory is [%s]", szServer));
			re.SetValue(REGVAL_DLGCALL_DEFDIR, szServer);
		}

		StoreColumnInfo();

		return 0;
	}

	case WM_HELP:
	{
		DoHelp(lParam, _mpIdHelpDlgCall);
		break;
	}

	case WM_NOTIFY:
	{
		switch (wParam)
			{
		case IDL_DLGCALL_LIST:
		case IDL_DLGCALL_LISTOWNERDATA:
		case IDL_DLGCALL_ILS_LISTVIEW:
			return OnNotifyList(lParam);
		case IDC_DLGCALL_COMBO:
			OnNotifyCombo(lParam);
 			break;
 		default:
 			break;
	 		}
		break;
	}

	case WM_SETTINGCHANGE:
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof(wp);
		if (!GetWindowPlacement(hwnd, &wp))
			break;
		switch (wp.showCmd)
		{
		case SW_NORMAL:
		case SW_RESTORE:
		{
			CalcDyText();
			Layout();
			break;
		}

		default:
			break;
		}
		break;
	}

	case WM_SETCURSOR:
	{
		if (0 == g_cBusy)
			break;

		::SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_APPSTARTING)));
		return TRUE;
	}
	
	case WM_SETFOCUS:
	{
		::SetFocus(m_hwndEdit);
		return 0;
	}

	default:
		break;
	}

	return(CFrame::ProcessMessage(hwnd, uMsg, wParam, lParam));
}


/*  O N  N O T I F Y  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: OnNotifyList

-------------------------------------------------------------------------*/
LRESULT CFindSomeone::OnNotifyList(LPARAM lParam)
{
	LPNMHDR pnmh = (LPNMHDR) lParam;
	HWND hwnd = GetWindow();

	switch (pnmh->code)
		{
	case NM_DBLCLK:
	{
		OnCommand(hwnd, IDOK, NULL, 0);
		break;
	}

	case LVN_KEYDOWN:
	{
		LPNMLVKEYDOWN pkdn = (LPNMLVKEYDOWN) lParam;
		switch (pkdn->wVKey)
			{
		case VK_F5:
			OnCommand(hwnd, IDM_DLGCALL_REFRESH, NULL, 0);
			break;
		case VK_DELETE:
			OnCommand(hwnd, IDM_DLGCALL_DELETE, NULL, 0);
			break;
		default:
			break;
			}
		break;
	}

	case LVN_ITEMCHANGED:
	{
		CConfRoom *pConfRoom = GetConfRoom();
        if (m_fInEdit || NULL == pConfRoom || !pConfRoom->IsNewCallAllowed())
			break;

		int iSel = m_pAlv->GetSelection();
		BOOL fEnable = (-1 != iSel);
		EnableWindow(GetDlgItem(hwnd, IDOK), fEnable);
		break;
	}

	case LVN_GETDISPINFO:
	{
		LV_DISPINFO *lpdi = (LV_DISPINFO *)lParam;
		if (lpdi->item.mask & LVIF_TEXT)
		{
			switch( lpdi->item.iSubItem )
			{
				case 0:
					m_pAlv->OnListGetColumn1Data(lpdi->item.iItem, lpdi->item.cchTextMax, lpdi->item.pszText);
					break;

				case 1:
					m_pAlv->OnListGetColumn2Data(lpdi->item.iItem, lpdi->item.cchTextMax, lpdi->item.pszText);
					break;
				
				case 2:
					m_pAlv->OnListGetColumn3Data(lpdi->item.iItem, lpdi->item.cchTextMax, lpdi->item.pszText);
					break;
			}
		}

        if( lpdi->item.mask & LVIF_IMAGE )
        {
            lpdi->item.iImage = m_pAlv->OnListGetImageForItem( lpdi->item.iItem );
        }

		break;
	}

	case LVN_ODCACHEHINT:
	{
		LPNMLVCACHEHINT lpCacheHint = reinterpret_cast< LPNMLVCACHEHINT > (lParam);
		m_pAlv->OnListCacheHint(lpCacheHint->iFrom, lpCacheHint->iTo);
		break;
	}

	case LVN_ODFINDITEM:
	{
		LPNMLVFINDITEM lpFindItem = reinterpret_cast< LPNMLVFINDITEM > (lParam);
		if (0 == (lpFindItem->lvfi.flags & (LVFI_PARTIAL | LVFI_STRING)))
			break;

		return m_pAlv->OnListFindItem(lpFindItem->lvfi.psz);
	}

	case LVN_COLUMNCLICK:
	{
		if( m_pAlv == m_pUls )
		{
			// The user clicked on one of the column headings - sort by
			// this column.
			TRACE_OUT(("CFindSomeone::OnNotify called (NM_COLUMNCLICK)"));
			NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
			ASSERT(pNm);

			if (pNm->iSubItem == m_iSortColumn)
			{
				m_fSortAscending = !m_fSortAscending;
			}
			else if( pNm->iSubItem != -1 )
			{
				m_fSortAscending = TRUE;
			}

			if( pNm->iSubItem != -1 )
			{
				m_iSortColumn = pNm->iSubItem;
			}
			else
			{
				pNm->iSubItem = m_iSortColumn;
			}

			SendMessage( pNm->hdr.hwndFrom, WM_SETREDRAW, FALSE, 0 );

			ListView_SortItems( pNm->hdr.hwndFrom,
								CompareWrapper,
								(LPARAM) this );

			SendMessage( pNm->hdr.hwndFrom, WM_SETREDRAW, TRUE, 0 );
		}
		break;
	}

	case NM_CUSTOMDRAW:
	{
		return DoCustomDraw((LPNMLVCUSTOMDRAW)lParam);
	}

	default:
		break;
	}
	
	return 0;
}


/*  D O  C U S T O M  D R A W  */
/*-------------------------------------------------------------------------
    %%Function: DoCustomDraw

-------------------------------------------------------------------------*/
LRESULT CFindSomeone::DoCustomDraw(LPNMLVCUSTOMDRAW lplvcd)
{
	switch (lplvcd->nmcd.dwDrawStage)
		{
	case CDDS_PREPAINT:
	{
		return CDRF_NOTIFYITEMDRAW;
	}

	case CDDS_ITEMPREPAINT:
	{
		if (!m_pAlv->IsItemBold(lplvcd->nmcd.dwItemSpec))
			break;

		//get the existing font
		HFONT hFont = (HFONT)SendMessage(m_hwndOwnerDataList, WM_GETFONT, 0, 0);
		if (NULL == hFont)
			break;

		LOGFONT  lf;
		if (0 == GetObject(hFont, sizeof(lf), &lf))
			break;
		lf.lfWeight = FW_BOLD;
		hFont = CreateFontIndirect(&lf);
		if (NULL == hFont)
			break;

		SelectObject(lplvcd->nmcd.hdc, hFont);
		return  CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
	}

	case CDDS_ITEMPOSTPAINT:
	{
		HFONT hFont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
		if (NULL != hFont)
		{
			//clean up stuff here
			hFont = (HFONT)SelectObject(lplvcd->nmcd.hdc, hFont);
			DeleteFont(hFont);
		}
		break;
	}

	default:
		break;
	}

	return CDRF_DODEFAULT;
}


/*  U P D A T E  I L S  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: UpdateIlsServer

    Update the current ILS server based on the text in the combo's edit control.
-------------------------------------------------------------------------*/
VOID CFindSomeone::UpdateIlsServer(void)
{
	TCHAR szServer[CCHMAXSZ_SERVER];
	if (0 == GetWindowText(m_hwndComboEdit, szServer, CCHMAX(szServer)))
		return;

	const TCHAR * const	displayName	= CDirectoryManager::get_displayName( szServer );
	const TCHAR * const	dnsName		= CDirectoryManager::get_dnsName( szServer );

	SetWindowText( m_hwndComboEdit, displayName );

	int iSel = ::SendMessage(m_hwndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM) displayName );
	if ((CB_ERR == iSel) && (NULL != m_pUls) && m_pUls->FAvailable())
	{
        RegEntry    rePol(POLICIES_KEY, HKEY_CURRENT_USER);

        //
		// Assume this is an ILS server - and add it to the list ONLY if
        // not prevented by policy.
        //
        if (!rePol.GetNumber(REGVAL_POL_NO_ADDING_NEW_ULS, DEFAULT_POL_NO_ADDING_NEW_ULS))
        {
    		if (NULL != m_pMruServer)
	    	{
		    	if( m_pMruServer->AddNewEntry( dnsName ) )
			    {
				    iSel = AddAlvSz( m_pUls, displayName, m_iIlsFirst );
    			}
	    	}
        }
	}

	if (CB_ERR == iSel)
		return;

	if (NULL != m_pAlv)
	{
		m_pAlv->ClearItems();
	}

	if (iSel >= m_iIlsFirst)
	{
		if( NULL != m_pUls )
		{
			m_pAlv = m_pUls;

			if( !CDirectoryManager::isWebDirectory( dnsName ) )
			{
				m_pUls->SetServer( dnsName );
					// We have to send this twice so that we don't autocomplete..
				SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSel, 0);
				SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSel, 0);
			}
		}
	}

	ShowList(iSel);
}


LRESULT CFindSomeone::OnNotifyCombo(LPARAM lParam)
{
	NMCOMBOBOXEX * pNmcbe = (NMCOMBOBOXEX*) lParam;

	switch(pNmcbe->hdr.code)
		{
	case CBEN_ENDEDIT:
	{
		PNMCBEENDEDIT pnmcbee = (PNMCBEENDEDIT) lParam;
		if (_T('\0') != pnmcbee->szText[0])
		{
			EndComboEdit(pnmcbee->iWhy);
		}
		break;
	}

	// NOTE: the IE 3.0 comctl32.dll sends us the wrong notification
	// when running under NT.  We handle it here, but if we are running
	// on NT using the IE 4.0 comctl32.dll, it will be handled above.
	case CBEN_ENDEDITW:
	{
		PNMCBEENDEDITW pnmcbee = (PNMCBEENDEDITW) lParam;
		if (L'\0' != pnmcbee->szText[0])
		{
			EndComboEdit(pnmcbee->iWhy);
		}
		break;
	}


	default:
		break;
		}

	return 0;
}

VOID CFindSomeone::EndComboEdit(int iWhy)
{
	switch (iWhy)
	{
	case CBENF_RETURN:
	{
		if (SendMessage(m_hwndCombo, CB_GETDROPPEDSTATE, 0, 0))
		{
			// remove the dropdown
			SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, 0, 0);
		}

		UpdateIlsServer();
		break;
	}

	case CBENF_KILLFOCUS:
	{
		// remove the dropdown
		SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, 0, 0);
		break;
	}

	case CBENF_DROPDOWN:
	default:
		break;
	}
}

static void DoAxMethod(HWND hwnd, LPWSTR szMethod)
{
	IUnknown *pUnk;
	if (SUCCEEDED(AtlAxGetControl(hwnd, &pUnk)))
	{
		CComPtr<IDispatch> spDispatch = com_cast<IDispatch>(pUnk);
		if (spDispatch)
		{
			DISPID dispid;
			if (SUCCEEDED(spDispatch->GetIDsOfNames(IID_NULL, &szMethod, 1,
							LOCALE_USER_DEFAULT, &dispid)))
			{
				DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

				HRESULT hr = spDispatch->Invoke(
						dispid,
						IID_NULL,
						LOCALE_USER_DEFAULT,
						DISPATCH_METHOD,
						&dispparamsNoArgs, NULL, NULL, NULL);
			}
		}

		pUnk->Release();
	}
}

static void NewHtmlWindow(HWND hwnd)
{
	IUnknown *pUnk;
	if (SUCCEEDED(AtlAxGetControl(hwnd, &pUnk)))
	{
		CComPtr<IWebBrowser> spWeb = com_cast<IWebBrowser>(pUnk);
		if (spWeb)
		{
			BSTR bstrLocation;

			if (SUCCEEDED(spWeb->get_LocationURL(&bstrLocation)))
			{
				USES_CONVERSION;

				LaunchRedirWebPage(OLE2T(bstrLocation));

				SysFreeString(bstrLocation);
			}
		}

		pUnk->Release();
	}
}

/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
void CFindSomeone::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	ASSERT(NULL != hwnd);

	switch (id)
	{
	case ID_TB_HELP:
		FORWARD_WM_SYSCOMMAND(hwnd, SC_CONTEXTHELP, 0, 0, SendMessage);
		break;

	case IDM_DLGCALL_ENTER:
		if (IsWindowActive(m_hwndCombo))
		{
			UpdateIlsServer();
		}
		else
		{
			HWND hwndFocus = GetFocus();
			TCHAR szClass[20];

			GetClassName(hwndFocus, szClass, ARRAY_ELEMENTS(szClass));
			if (0 == lstrcmpi(szClass, TEXT("button"))
				&& BS_PUSHBUTTON == (GetWindowStyle(hwndFocus)&(BS_PUSHBUTTON|BS_CHECKBOX|BS_RADIOBUTTON)))
			{
				// Push the button
				OnCommand(hwnd, GetDlgCtrlID(hwndFocus), hwndFocus, BN_CLICKED);
			}
			else if (IsWindowEnabled(GetDlgItem(hwnd, IDOK)))
			{
				// Try to complete the call
				OnCommand(hwnd, IDOK, NULL, 0);
			}
			else
			{
				MessageBeep(MB_ICONHAND);
			}
		}
		break;

	case IDC_DLGCALL_COMBO:
	{
		switch (codeNotify)
			{
		case CBN_EDITCHANGE:
		{
			OnEditChangeDirectory();
			break;
		}
		case CBN_KILLFOCUS:
		{
			int iSel = ::SendMessage(m_hwndCombo, CB_GETCURSEL, 0, 0);
			if (CB_ERR == iSel)
			{
				UpdateIlsServer();
			}
			else if (iSel != m_iSel)
			{
				ShowList(iSel);
			}
			break;
		}
		case CBN_SELENDOK:
		{
			int iSel = ::SendMessage(m_hwndCombo, CB_GETCURSEL, 0, 0);
				// We have to send this so that we don't autocomplete..
			SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSel, 0);
			ShowList(iSel);
			break;
		}
		default:
			break;
			} /* switch (HIWORD(wParam)) */
		break;
	}

	case IDM_DLGCALL_CALL:
	case IDOK:
	{
		CConfRoom *pConfRoom = GetConfRoom();
        if (NULL == pConfRoom || !pConfRoom->IsNewCallAllowed())
        {
            WARNING_OUT(("Meeting settings prevent outgoing calls"));
            break;
        }

		if (SUCCEEDED(HrGetSelection()))
		{
			onCall();
		}
		else
		{
			if( !hasValidUserInfo( m_pRai ) )
			{
				DisplayMsgErr( hwnd, IDS_NO_CALL_LOG_INFO );
			}
			else
			{
				TCHAR szName[CCHMAXSZ_NAME];
				GetEditText(szName, CCHMAX(szName));
				DisplayMsgErr(hwnd, IDS_ERR_CALLTO, szName);
			}
		}
		break;
	}

	case IDCANCEL:
	{
		PostMessage( hwnd, WM_CLOSE, 0, 0 );
		break;
	}

	case IDE_DLGCALL_NAME:
	{
		switch (codeNotify)
		{
		case EN_CHANGE:
		{
			TCHAR sz[CCHMAXSZ];
			sz[0] = _T('\0');
			GetWindowText(m_hwndEdit, sz, CCHMAX(sz));

			int iSel = CFindSomeone::FindSzBySortedColumn(sz);

			if (-1 != iSel)
			{
				HWND hwndCurr = GetHwndList();

				// Select the item found
				ListView_SetItemState(hwndCurr, iSel, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

				int iTop = ListView_GetTopIndex(hwndCurr);
				int cDiff = (iSel - iTop);
				if ((cDiff < 0) || (cDiff > m_cVisible))
				{
					// Scroll the item into view
					RECT rc;
					ListView_GetItemRect(hwndCurr, iSel, &rc, LVIR_BOUNDS);
					ListView_Scroll(hwndCurr, 0, cDiff * (rc.bottom - rc.top));
				}
			}

			break;
		}
		default:
			break;
		} /* switch (HIWORD(wParam)) */

		break;
	}

	case IDM_DLGCALL_NEWWINDOW:
		NewHtmlWindow(m_webView);
		break;

	case IDM_DLGCALL_REFRESH:
		if (IsWindowVisible(m_webView))
		{
			DoAxMethod(m_webView, L"Refresh");
			break;
		}

		// Fall through
	case IDM_DLGCALL_PROPERTIES:
	case IDM_DLGCALL_DELETE:
	case IDM_DLGCALL_SPEEDDIAL:
	case IDM_DLGCALL_WAB:
	case IDM_DLGCALL_STOP:
	{
		if (NULL != m_pAlv)
		{
			m_pAlv->OnCommand(GET_WM_COMMAND_MPS(id, hwndCtl, codeNotify));
		}
		break;
	}

	case IDM_DLGCALL_DELETE_ILS:
		OnDeleteIlsServer();
		break;
	default:
		break;
	}
}


int CFindSomeone::GetEditText(LPTSTR psz, int cchMax)
{
	ASSERT(NULL != m_hwndEdit);
	int cch = GetWindowText(m_hwndEdit, psz, cchMax);
	return TrimSz(psz);
}


HRESULT CFindSomeone::HrGetSelection(void)
{
	HRESULT	result	= E_FAIL;

	//	Check if we have a selection
	if( ListView_GetNextItem( GetHwndList(), -1, LVNI_ALL | LVNI_SELECTED ) != -1 )
	{
		m_pRai = m_pAlv->GetAddrInfo();
	
		if( hasValidUserInfo( m_pRai ) )
		{
			result = S_OK;
		}
	}

	return( result );

}	//	End of CFindSomeone::HrGetSelection.


/*  F I N D  S Z  */
/*-------------------------------------------------------------------------
    %%Function: FindSz

    First the item that matches at least the first part of the string
    from the current list.
-------------------------------------------------------------------------*/
int CFindSomeone::FindSz(LPCTSTR psz)
{
	LV_FINDINFO lvfi;
	ClearStruct(&lvfi);
	lvfi.flags = LVFI_PARTIAL;
	lvfi.psz = (LPTSTR) psz;

	return ListView_FindItem(GetHwndList(), -1, &lvfi);
}


//--------------------------------------------------------------------------//
//	CFindSomeone::FindSzBySortedColumn.										//
//--------------------------------------------------------------------------//
int CFindSomeone::FindSzBySortedColumn(LPCTSTR psz)
{
	ASSERT( psz != NULL );

	TCHAR	pszColumnText[ MAX_PATH ];
	HWND	hwndList		= GetHwndList();
	bool	bSorted			= hwndList == m_ilsListView;
	int		iSearchColumn	= bSorted ? m_iSortColumn : 0;
	int		iStart			= 0;
	int		iEnd			= ListView_GetItemCount( hwndList ) - 1;
	int		iMid			= iEnd / 2;
	int		iCompareLength	= lstrlen( psz );
	int		iResult			= -1;
	bool	bAscending		= (m_fSortAscending != FALSE);

	if( iEnd > 0 )
	{
		if( bSorted && ((iSearchColumn == COLUMN_INDEX_AUDIO) || (iSearchColumn == COLUMN_INDEX_VIDEO) ))
		{
			bSorted = false;

			//	The list is sorted by av capabilities.... perform a linear search on the first (unsorted) text column...
			int iColumnOrder[ MAX_DIR_COLUMNS ];

			if( ListView_GetColumnOrderArray( m_ilsListView, g_rgDLColumnInfo[ DLT_ULS ].nColumns, iColumnOrder ) )
			{
				if( (iColumnOrder[ 0 ] == COLUMN_INDEX_AUDIO) || (iColumnOrder[ 0 ] == COLUMN_INDEX_VIDEO) )
				{
					if( (iColumnOrder[ 1 ] == COLUMN_INDEX_AUDIO) || (iColumnOrder[ 1 ] == COLUMN_INDEX_VIDEO) )
					{
						iSearchColumn = 2;
					}
					else
					{
						iSearchColumn = 1;
					}
				}
				else
				{
					iSearchColumn = 0;
				}

				iSearchColumn = iColumnOrder[iSearchColumn];
			}
		}

		if (!bSorted)
		{
			// Do a linear search
			for( int nn = 0; nn <= iEnd; nn++ )
			{
				ListView_GetItemText( hwndList, nn, iSearchColumn, pszColumnText, CCHMAX( pszColumnText ) );

				if( iCompareLength < CCHMAX( pszColumnText ) - 1 )
				{
					pszColumnText[ iCompareLength ] = '\0';		//	Only compare iCompareLength characters...
				}

				if( StringCompare( psz, pszColumnText ) == 0 )
				{
					iResult = nn;
					break;
				}
			}
		}
		else
		{
			while( iStart <= iEnd )
			{
				pszColumnText[ 0 ] = '\0';

				ListView_GetItemText( hwndList, iMid, iSearchColumn, pszColumnText, CCHMAX( pszColumnText ) );

				if( iCompareLength < CCHMAX( pszColumnText ) - 1 )
				{
					pszColumnText[ iCompareLength ] = '\0';		//	Only compare iCompareLength characters...
				}

				int		iCompareResult	= StringCompare( psz, pszColumnText );
				bool	pszIsLess		= (iCompareResult <= 0);

				if( iCompareResult == 0 )
				{
					//	We've found a match but we will keep going because there may be more than one
					//	and we want to find the "first" one...
					iResult = iMid;
				}
				else
				{
					if( !bAscending )
					{
						pszIsLess = !pszIsLess;
					}
				}
					
				if( pszIsLess )
				{
					iEnd = iMid - 1;
				}
				else
				{
					iStart = iMid + 1;
				}

				iMid = iStart + ((iEnd - iStart) / 2);
			}
		}
	}

	return( iResult );

}	//	End of CFindSomeone::FindSzBySortedColumn.


VOID CFindSomeone::OnEditChangeDirectory(void)
{
	if (m_fInEdit)
		return;

	TCHAR szEdit[CCHMAXSZ_ADDRESS];
	TCHAR szBuff[CCHMAXSZ_ADDRESS];

	szEdit[0] = _T('\0');
	int cch = GetWindowText(m_hwndCombo, szEdit, CCHMAX(szEdit));
	CharUpperBuff(szEdit, CCHMAX(szEdit));

	if (0 == cch)
		return;

	// Check if anything changed
	PTCHAR pchSrc = m_szDirectory;
	PTCHAR pchDest = szEdit;
	while ((_T('\0') != *pchSrc) && (*pchSrc == *pchDest))
	{
		// REVIEW: not DBCS safe
		pchSrc++;
		pchDest++;
	}
	if (_T('\0') == *pchDest)
	{
		lstrcpy(m_szDirectory, szEdit);
		return; // quick exit - nothing to do
	}

	if (-1 == FindSzCombo(m_hwndCombo, szEdit, szBuff))
		return;

	m_fInEdit = TRUE;
	AutoCompleteCombo(m_hwndCombo, &szBuff[cch]);
	lstrcpyn(m_szDirectory, szBuff, cch+1);
	CharUpperBuff(m_szDirectory, CCHMAX(m_szDirectory));
	m_fInEdit = FALSE;
}



/*  I N I T  A L V  */
/*-------------------------------------------------------------------------
    %%Function: InitAlv

-------------------------------------------------------------------------*/
VOID CFindSomeone::InitAlv(void)
{
	int iSelDefault = LB_ERR;

	ASSERT( NULL == m_pAlv );



	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);
	
	bool bGkEnabled = CALLING_MODE_GATEKEEPER == reConf.GetNumber(REGVAL_CALLING_MODE, CALLING_MODE_DIRECT );

#if USE_GAL
	// Add each of the view items to the list
	if ((NULL != m_pGAL) && m_pGAL->FAvailable())
	{
		AddAlv(m_pGAL);
		if( !m_pAlv )
		{
			m_pAlv = m_pGAL;
		}
	}
#endif // #if USE_GAL
	if((!bGkEnabled) && (NULL != m_pSpeedDial) && m_pSpeedDial->FAvailable())
	{
		AddAlv(m_pSpeedDial);
		if( !m_pAlv )
		{
			m_pAlv = m_pSpeedDial;
		}

	}

	if ( (!bGkEnabled) && ( NULL != m_pHistory) && m_pHistory->FAvailable())
	{
		AddAlv(m_pHistory);
		if( !m_pAlv )
		{
			m_pAlv = m_pHistory;
		}

	}
	if ((NULL != m_pWab) && m_pWab->FAvailable())
	{
		AddAlv(m_pWab);
		if( !m_pAlv )
		{
			m_pAlv = m_pWab;
		}
	}

	m_iIlsFirst = ::SendMessage(m_hwndCombo, CB_GETCOUNT, 0, 0);

	// Add the list of ILS servers
	if (bGkEnabled)
	{
		// If there is a customized Web View, we will show it in GK mode as
		// well as in ILS mode
		if ((NULL != m_pUls) && ConfPolicies::GetWebDirInfo())
		{
			AddAlvSz( m_pUls, CDirectoryManager::get_displayName( CDirectoryManager::get_webDirectoryIls() ));
		}
	}
	else
	{
		if((NULL != m_pUls) && m_pUls->FAvailable() && (NULL != m_pMruServer) && !_IsDirectoryServicePolicyDisabled())
		{
			m_pAlv = m_pUls;

			for( int i = m_pMruServer->GetNumEntries() - 1; i >= 0; i-- )
			{
				AddAlvSz( m_pUls, CDirectoryManager::get_displayName( m_pMruServer->GetNameEntry( i ) ) );
			}
		}
	}

	iSelDefault = CB_ERR;

	if( m_pAlv )
	{
		// We know that there is at lest one directory server in the combobox

		// Get the user's last selection
		RegEntry reMru(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);
		LPTSTR psz = reMru.GetString(REGVAL_DLGCALL_DEFDIR);

		if (!FEmptySz(psz))
		{
			TRACE_OUT(("Last directory was [%s]",psz));
			iSelDefault = ::SendMessage(m_hwndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM) psz);
		}
		else
		{
			// This may be the first time, and there is no last use one in the registry
			TCHAR szDirectoryName[CCHMAXSZ];

			if( m_pAlv )
			{
				if( m_pAlv != m_pUls )
				{
					m_pAlv->GetName(szDirectoryName, CCHMAX(szDirectoryName));

					iSelDefault = ::SendMessage(m_hwndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1, (LPARAM) szDirectoryName);
				}
				else if( m_pMruServer->GetNumEntries() > 0 )
				{
					iSelDefault = m_iIlsFirst;
				}
			}
		}

		iSelDefault = (CB_ERR != iSelDefault) ? iSelDefault : 0;

		ShowList(iSelDefault);

			// We have to send this twice so that we don't autocomplete..
		SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSelDefault, 0);
		SendMessage(m_hwndCombo, CB_SETCURSEL, (WPARAM) iSelDefault, 0);
	}
	else
	{
		// The user has no directory services set up
		DisplayMsgErr( NULL, IDS_NO_DIRECTORY_SERVICES_OR_ADDRESS_BOOKS );
	}
}

bool CFindSomeone::_IsDirectoryServicePolicyDisabled()
{
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    return rePol.GetNumber( REGVAL_POL_NO_DIRECTORY_SERVICES, DEFAULT_POL_NO_DIRECTORY_SERVICES ) ? true : false;
}

int CFindSomeone::AddAlv(CALV * pAlv)
{
	TCHAR sz[CCHMAXSZ];

	pAlv->GetName(sz, CCHMAX(sz));
	return AddAlvSz(pAlv, sz);
}

int CFindSomeone::AddAlvSz(CALV * pAlv, LPCTSTR psz, int cbIndex)
{
	ASSERT(NULL != pAlv);
	ASSERT(NULL != m_hwndCombo);

	COMBOBOXEXITEM cbi;
	ClearStruct(&cbi);

	cbi.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
	cbi.iItem = cbIndex;
	cbi.iImage = pAlv->GetIconId(psz);
	cbi.iSelectedImage = cbi.iImage;
	cbi.pszText = (LPTSTR) psz;
	cbi.cchTextMax = lstrlen(cbi.pszText);

	int iIndex = ::SendMessage(m_hwndCombo, CBEM_INSERTITEM, 0, (LPARAM) &cbi);
	if (CB_ERR != iIndex)
	{
		::SendMessage(m_hwndCombo, CB_SETITEMDATA, iIndex, (LPARAM) pAlv);
	}

	return iIndex;
}



/*  S H O W  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: ShowList

-------------------------------------------------------------------------*/
VOID CFindSomeone::ShowList(int iSel)
{
	HWND hwnd = GetWindow();

	if (CB_ERR == iSel)
		return;
	m_iSel = iSel;

	BOOL bPrevListWasOwnerData = m_pAlv->FOwnerData();
	int nColsPrevListView = _GetCurListViewNumColumns();
	BOOL bPrevChangedNumCols = FALSE;

	// Clear any existing data
	if (NULL != m_pAlv)
	{
		m_pAlv->ClearItems();
		if( nColsPrevListView != _GetCurListViewNumColumns() )
		{	
			bPrevChangedNumCols = TRUE;
		}
	}

	// Get the new selection
	m_pAlv = (CALV *) ::SendMessage(m_hwndCombo, CB_GETITEMDATA, iSel, 0);
	ASSERT(m_pAlv != NULL);
	ASSERT(m_pAlv != (CALV *) -1);
	
	BOOL bCurListIsOwnerData = m_pAlv->FOwnerData();

	bool webDir = false;

    TCHAR szServer[CCHMAXSZ_SERVER];
	szServer[0] = 0;

	if (m_pAlv == m_pUls)
	{
        COMBOBOXEXITEM  cbi;

        ClearStruct(&cbi);
        cbi.mask = CBEIF_TEXT;
        cbi.iItem = iSel;
        cbi.pszText = szServer;
        cbi.cchTextMax = ARRAY_ELEMENTS(szServer);

		::SendMessage(m_hwndCombo, CBEM_GETITEM, iSel, (LPARAM)&cbi);

		TRACE_OUT(("CBEM_GETITEM got %s for text", szServer));

		webDir	= CDirectoryManager::isWebDirectory( szServer );
	}

	// Show or hide all windows between HELP and CANCEL
	HWND start = GetDlgItem(hwnd, ID_TB_HELP);
	HWND end   = GetDlgItem(hwnd, IDCANCEL);

	if (NULL != start)
	{
		UINT uShow = webDir ? SW_HIDE : SW_SHOW;
		for (HWND child=::GetWindow(start, GW_HWNDNEXT);
			child!=NULL && child!=end; child=::GetWindow(child, GW_HWNDNEXT))
		{
			ShowWindow(child, uShow);
		}

		ShowWindow(m_webView, SW_HIDE+SW_SHOW-uShow);
	}
	EnableWindow(GetDlgItem(hwnd, IDM_DLGCALL_NEWWINDOW), webDir);
	EnableWindow( GetDlgItem( hwnd, IDM_DLGCALL_DELETE_ILS ), FALSE );

	if (m_pAlv == m_pUls)
	{
		::ShowWindow( m_hwndOwnerDataList,	SW_HIDE );
		::ShowWindow( m_hwndList,			SW_HIDE );

		if( webDir )
		{
			::SetFocus( m_webView );
		}
		else
		{
	        m_pUls->SetServer( CDirectoryManager::get_dnsName( szServer ) );

			m_pAlv->ShowItems(GetHwndList());

			::SetFocus( m_ilsListView );

			RegEntry    rePol( POLICIES_KEY, HKEY_CURRENT_USER );

		    if (!rePol.GetNumber(REGVAL_POL_NO_ADDING_NEW_ULS, DEFAULT_POL_NO_ADDING_NEW_ULS))
			{
				EnableWindow( GetDlgItem( hwnd, IDM_DLGCALL_DELETE_ILS ), TRUE );
			}
		}
	}
	else
	{
		if( m_ilsListView != NULL )
		{
			::ShowWindow( m_ilsListView, SW_HIDE );
			::ShowWindow( m_webView, SW_HIDE );
			m_pUls->CacheServerData();
		}

		if (m_pAlv->FOwnerData())
		{
			::ShowWindow(m_hwndList, SW_HIDE);
		}
		else
		{
			::ShowWindow(m_hwndOwnerDataList, SW_HIDE);
		}

		m_pAlv->ShowItems(GetHwndList());
		::SetFocus( GetHwndList() );
	}

	if( bPrevChangedNumCols || ( bCurListIsOwnerData != bPrevListWasOwnerData ) || ( nColsPrevListView != _GetCurListViewNumColumns() ) )
	{
		Layout();
	}

}


int CFindSomeone::_GetCurListViewNumColumns()
{

	int nListViewColumns = DEFAULT_NUM_LISTVIEW_COLUMNS;

	HWND hListViewHeader = NULL;
	HWND hWndList = GetHwndList();
	if( hWndList )
	{
		hListViewHeader = ListView_GetHeader( hWndList );
		if( hListViewHeader )
		{
			nListViewColumns = Header_GetItemCount( hListViewHeader );
		}
	}

	return nListViewColumns;
}


/*  D L G  C A L L  S E T  H E A D E R  */
/*-------------------------------------------------------------------------
    %%Function: DlgCallSetHeader

    Set the listbox header text for the "address" / "email" / "status" field.
-------------------------------------------------------------------------*/
VOID DlgCallSetHeader(HWND hwndList, int ids)
{
	HWND hwnd = ListView_GetHeader(hwndList);
	if (NULL == hwnd)
		return;

	TCHAR sz[CCHMAXSZ];
	if (!FLoadString(ids, sz, CCHMAX(sz)))
		return;

	HDITEM hdItem;
	ClearStruct(&hdItem);
	hdItem.mask = HDI_TEXT; // | HDI_IMAGE; hdItem.iImage = II_ASCENDING;
	hdItem.pszText = sz;
	hdItem.cchTextMax = lstrlen(hdItem.pszText);
	Header_SetItem(hwnd, IDI_DLGCALL_ADDRESS, &hdItem);
}


/*  D L G  C A L L  A D D  I T E M  */
/*-------------------------------------------------------------------------
    %%Function: DlgCallAddItem

    Add the name and address to the list, returning the position.
-------------------------------------------------------------------------*/
int DlgCallAddItem(HWND hwndList, LPCTSTR pszName, LPCTSTR pszAddress, int iImage, LPARAM lParam, int iItem, LPCTSTR pszComment)
{
	LV_ITEM lvItem;
	ClearStruct(&lvItem);
	lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
	lvItem.iItem = iItem;
	lvItem.lParam = lParam;
	lvItem.iImage = iImage;
	lvItem.pszText = (LPTSTR) pszName;
	lvItem.cchTextMax = lstrlen(lvItem.pszText);
	int iPos = ListView_InsertItem(hwndList, &lvItem);
	if (-1 != iPos)
	{
		ListView_SetItemText(hwndList, iPos, IDI_DLGCALL_ADDRESS, (LPTSTR) pszAddress);

		if( pszComment )
		{
			ListView_SetItemText(hwndList, iPos, IDI_DLGCALL_COMMENT, (LPTSTR) pszComment);
		}
	}

	return iPos;
}




/*  C A L L  T O  S Z  */
/*-------------------------------------------------------------------------
    %%Function: CallToSz

    Call an address using "CallTo:"
-------------------------------------------------------------------------*/
HRESULT CallToSz(LPCTSTR pcszAddress)
{
#ifdef DEBUG
	RegEntry re(DEBUG_KEY, HKEY_LOCAL_MACHINE);
	if (0 != re.GetNumber(REGVAL_DBG_FAKE_CALLTO, DEFAULT_DBG_FAKE_CALLTO))
	{
		MessageBox(NULL, pcszAddress, "Called", MB_OK);
		return S_OK;
	}
#endif /* DEBUG */

	if (FEmptySz(pcszAddress))
		return E_INVALIDARG;

	TCHAR sz[MAX_PATH];
	lstrcpy(sz, g_cszCallTo);
	int cch = lstrlen(sz);
	if (CCHMAX(sz) <= (cch + lstrlen(pcszAddress)))
		return E_INVALIDARG; // the address won't fit
	lstrcpy(&sz[cch], pcszAddress);

	HINSTANCE hInst = ShellExecute(NULL, NULL, sz, NULL, NULL, SW_SHOWNORMAL);

	return ((INT_PTR)hInst > 32) ? S_OK : E_FAIL;
}


//--------------------------------------------------------------------------//
//	GetMruListServer.														//
//--------------------------------------------------------------------------//
CMRUList *
GetMruListServer(void)
{
	CMRUList *	pMruList	= new CMRUList;

	if( pMruList != NULL )
	{
		pMruList->Load( DIR_MRU_KEY );

		if( CDirectoryManager::isWebDirectoryEnabled() )
		{
			//	Make sure the web directory is in the list...
			pMruList->AppendEntry( CDirectoryManager::get_webDirectoryIls() );
		}

		const TCHAR * const	defaultServer	= CDirectoryManager::get_defaultServer();

		if( lstrlen( defaultServer ) > 0 )
		{
			//	Make sure the default server name is in the list and at the top...
			pMruList->AddNewEntry( defaultServer );
		}
	}

	return( pMruList );

}	//	End of GetMruListServer.


// The only purpose for this function is to avoid scrollbar tracking of the data
/* static */
LRESULT CALLBACK CFindSomeone::OwnerDataListWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
	CFindSomeone* pThis = reinterpret_cast< CFindSomeone* >( GetWindowLongPtr( hwnd, GWLP_USERDATA ) );
	WNDPROC lpPrevWndFunc = pThis->m_WndOwnerDataListOldWndProc;

	bool bUserDroppedScrollSlider = false;

	if (WM_VSCROLL == uMsg)
	{
		switch (LOWORD(wParam))
		{
		case SB_THUMBTRACK:
			// don't track
			return FALSE;

		case SB_THUMBPOSITION:
			bUserDroppedScrollSlider = true;
			// fake a final SB_THUMBTRACK notification
			CallWindowProc(lpPrevWndFunc, hwnd, uMsg, MAKEWPARAM(SB_THUMBTRACK, HIWORD(wParam)), lParam);
			break;

		default:
			break;
		}
	}

	LRESULT lRet = CallWindowProc(lpPrevWndFunc, hwnd, uMsg, wParam, lParam);

	if( bUserDroppedScrollSlider )
	{
		ListView_SetItemState(hwnd, GetScrollPos( hwnd, SB_VERT ), LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
	}

	return lRet;
}


//--------------------------------------------------------------------------//
//--------------------------------------------------------------------------//
//	copied from 2.11 dirlist.cpp.											//
//--------------------------------------------------------------------------//
//--------------------------------------------------------------------------//
//--------------------------------------------------------------------------//
//	CFindSomeone::InitColumns.												//
//--------------------------------------------------------------------------//
BOOL CFindSomeone::InitColumns(void)
{
	BOOL bRet = FALSE;
	
	if (NULL != m_ilsListView)
	{
		// Remove all columns:
		// NOTE: we could optimize by removing only extras and changing the rest
		while( ListView_DeleteColumn( m_ilsListView, 0 ) ){};

		// Now initialize the columns we will need
		// Initialize the LV_COLUMN structure
		// the mask specifies that the .fmt, .ex, width, and .subitem members
		// of the structure are valid,
		LV_COLUMN lvC;			// List View Column structure
		TCHAR szText[256];		// place to store some text

		lvC.pszText	= szText;
		lvC.fmt		= LVCFMT_LEFT;  // left align the column

		// Add the columns.
	    for (int index = 0; index < g_rgDLColumnInfo[DLT_ULS].nColumns; index++)
		{
			HD_ITEM	hdi;

			switch( index )
			{
				case COLUMN_INDEX_AUDIO:
					hdi.iImage	= II_AUDIO_COLUMN_HEADER;
					lvC.mask	= LVCF_SUBITEM;
					break;
				case COLUMN_INDEX_VIDEO:
					hdi.iImage	= II_VIDEO_COLUMN_HEADER;
					lvC.mask	= LVCF_SUBITEM;
					break;
				default:
					hdi.iImage	= -1;
					lvC.mask	= LVCF_TEXT | LVCF_FMT | LVCF_SUBITEM;

					LoadString( ::GetInstanceHandle(),
								ciColumnInfo[ index ].iColumnLabelIds,
								szText,
								CCHMAX(szText));
					break;
			}

			lvC.iSubItem = index;

			if( ListView_InsertColumn( m_ilsListView, index, &lvC ) == -1 )
			{
				WARNING_OUT(("Could not insert column %d in list view", index));
			}
			else if( hdi.iImage != -1 )
			{
				hdi.mask	= HDI_IMAGE | HDI_FORMAT;
				hdi.fmt		= HDF_IMAGE;
				
				Header_SetItem( ListView_GetHeader( m_ilsListView ), index, &hdi );
			}
		}

		Header_SetImageList( ListView_GetHeader( m_ilsListView ), m_himlIcon );
		bRet = TRUE;
	}
	// ISSUE: do we want to persist this data?
	m_fSortAscending	= TRUE;
	m_iSortColumn		= COLUMN_INDEX_LAST_NAME;

	return bRet;
}


//--------------------------------------------------------------------------//
//	CFindSomeone::LoadColumnInfo.											//
//--------------------------------------------------------------------------//
BOOL
CFindSomeone::LoadColumnInfo(void)
{
	RegEntry re(UI_KEY, HKEY_CURRENT_USER);

    // load column info from registry:
	LPLONG plColumns = NULL;
	DWORD dwLength = re.GetBinary(	g_rgDLColumnInfo[DLT_ULS].pszRVWidths,
									(LPVOID*) &plColumns);

	if (dwLength == (sizeof(LONG) * g_rgDLColumnInfo[DLT_ULS].nColumns))
	{
		// get width of each column
		for (int i = 0; i < g_rgDLColumnInfo[DLT_ULS].nColumns; i++)
		{
			m_alColumns[i] = plColumns[i];
			ListView_SetColumnWidth(m_ilsListView, i, m_alColumns[i]);
		}
	}
	else
	{
		int iMinColumnPixels[ MAX_DIR_COLUMNS ];

		int	iPixelsPerChar	= GetPixelsPerChar( m_ilsListView );
		int	ii;

		//	Loop through all the columns setting their minimum widths...
		for( ii = 0; ii < g_rgDLColumnInfo[ DLT_ULS ].nColumns; ii++ )
		{
			if( (ii == COLUMN_INDEX_AUDIO) || (ii == COLUMN_INDEX_VIDEO) )
			{
				//	We use a 16x16 icon, plus add 7 pixels for padding.
				//	There's also padding built into the icons to make them look more centered....
				//	The column header icons are aligned left and the column icons are aligned right...
				iMinColumnPixels[ ii ] = 23;
			}
			else
			{
				iMinColumnPixels[ ii ] = ciColumnInfo[ ii ].iMinColumnChars * iPixelsPerChar;
			}
		}

		//	Loop through all but the last column setting each columns to it's minimum width...
		for( ii = 0; ii < g_rgDLColumnInfo[ DLT_ULS ].nColumns - 1; ii++ )
		{
			ListView_SetColumnWidth( m_ilsListView, ii, iMinColumnPixels[ ii ] );
			m_alColumns[ ii ] = ListView_GetColumnWidth( m_ilsListView, ii );
		}

		//	The last column gets the rest...
		int	iLastColoumnIndex = g_rgDLColumnInfo[ DLT_ULS ].nColumns - 1;

		ListView_SetColumnWidth( m_ilsListView, iLastColoumnIndex, LVSCW_AUTOSIZE_USEHEADER );
		m_alColumns[ iLastColoumnIndex ] = ListView_GetColumnWidth( m_ilsListView, iLastColoumnIndex );

		if( m_alColumns[ iLastColoumnIndex ] < iMinColumnPixels[ iLastColoumnIndex ] )
		{
			ListView_SetColumnWidth( m_ilsListView, iLastColoumnIndex, iMinColumnPixels[ iLastColoumnIndex ] );
			m_alColumns[ iLastColoumnIndex ] = ListView_GetColumnWidth( m_ilsListView, iLastColoumnIndex );
		}
	}

	// set column order
	LPLONG plColumnOrder = NULL;
	dwLength = re.GetBinary(	g_rgDLColumnInfo[DLT_ULS].pszRVOrder,
								(LPVOID*) &plColumnOrder);
	if (dwLength == (sizeof(LONG) * g_rgDLColumnInfo[DLT_ULS].nColumns))
	{
		ListView_SetColumnOrderArray(	m_ilsListView,
										g_rgDLColumnInfo[DLT_ULS].nColumns,
										plColumnOrder);

		// load the sort column and direction
		m_iSortColumn = re.GetNumber(g_rgDLColumnInfo[DLT_ULS].pszRVSortColumn, COLUMN_INDEX_LAST_NAME );
		ASSERT(m_iSortColumn < g_rgDLColumnInfo[DLT_ULS].nColumns);
		m_fSortAscending = re.GetNumber(g_rgDLColumnInfo[DLT_ULS].pszRVSortAscending, TRUE);
	}
	else
	{
		const static int	iDefaultColumnOrder[] = { COLUMN_INDEX_AUDIO, COLUMN_INDEX_VIDEO, COLUMN_INDEX_LAST_NAME, COLUMN_INDEX_FIRST_NAME, COLUMN_INDEX_ADDRESS, COLUMN_INDEX_LOCATION, COLUMN_INDEX_COMMENTS };

		ListView_SetColumnOrderArray( m_ilsListView, ARRAY_ELEMENTS( iDefaultColumnOrder ), iDefaultColumnOrder );
	}

	return TRUE;
}


//--------------------------------------------------------------------------//
//	CFindSomeone::CompareWrapper.											//
//--------------------------------------------------------------------------//
int
CALLBACK
CFindSomeone::CompareWrapper
(
	LPARAM	param1,
	LPARAM	param2,
	LPARAM	This
){

	return( ((CFindSomeone *) This)->DirListViewCompareProc( param1, param2 ) );

}	//	End of CFindSomeone::CompareWrapper.


//--------------------------------------------------------------------------//
//	CFindSomeone::DirListViewCompareProc.									//
//--------------------------------------------------------------------------//
int
CFindSomeone::DirListViewCompareProc
(
	LPARAM	param1,
	LPARAM	param2
){
	LV_ITEM	lvi;
	int		result;

	if( (m_iSortColumn == COLUMN_INDEX_AUDIO) || (m_iSortColumn == COLUMN_INDEX_VIDEO) )
	{
		lvi.mask		= LVIF_IMAGE;
		lvi.iItem		= LParamToPos( param1 );
		lvi.iSubItem	= m_iSortColumn;

		ListView_GetItem( m_ilsListView, &lvi );

		int	iImage1	= lvi.iImage;

		lvi.iItem = LParamToPos( param2 );

		ListView_GetItem( m_ilsListView, &lvi );

		result = lvi.iImage - iImage1;
	}
	else
	{
		// BUGBUG: need better constant for max size
		TCHAR	szText1[ MAX_PATH ];
		TCHAR	szText2[ MAX_PATH ];

		lvi.mask		= LVIF_TEXT;
		lvi.iItem		= LParamToPos( param1 );
		lvi.iSubItem	= m_iSortColumn;
		lvi.pszText		= szText1;
		lvi.cchTextMax	= CCHMAX( szText1 );

		ListView_GetItem( m_ilsListView, &lvi );

		lvi.iItem	= LParamToPos( param2 );
		lvi.pszText	= szText2;

		ListView_GetItem( m_ilsListView, &lvi );

		result = StringCompare( szText1, szText2 );
	}

	if( !m_fSortAscending )
	{
		result = -result;
	}

	return( result );
}


//--------------------------------------------------------------------------//
//	CFindSomeone::LParamToPos.												//
//--------------------------------------------------------------------------//
int CFindSomeone::LParamToPos(LPARAM lParam)
{
	LV_FINDINFO lvF;

	lvF.flags	= LVFI_PARAM;
	lvF.lParam	= lParam;

	return( ListView_FindItem( m_ilsListView, -1, &lvF ) );		//	Note: retuns -1 on failure...

}


//--------------------------------------------------------------------------//
//	CFindSomeone::StoreColumnInfo.											//
//--------------------------------------------------------------------------//
void
CFindSomeone::StoreColumnInfo(void)
{
	if( IsWindow( m_ilsListView ) )
	{
		RegEntry	re( UI_KEY, HKEY_CURRENT_USER );
		DWORD		dwStyle	= ::GetWindowLong( m_ilsListView, GWL_STYLE );

		if( (dwStyle & LVS_TYPEMASK) == LVS_REPORT )
		{
			// get width of each column
			for( int i = 0; i < g_rgDLColumnInfo[ DLT_ULS ].nColumns; i++ )
			{
				m_alColumns[ i ] = ListView_GetColumnWidth( m_ilsListView, i );
			}
		}

		// save this back to registry
		re.SetValue( g_rgDLColumnInfo[ DLT_ULS ].pszRVWidths,
					(LPVOID) m_alColumns,
					sizeof( LONG ) * g_rgDLColumnInfo[ DLT_ULS ].nColumns );

		int anColumnOrder[MAX_DIR_COLUMNS];

		if( ListView_GetColumnOrderArray( m_ilsListView,
										g_rgDLColumnInfo[ DLT_ULS ].nColumns,
										anColumnOrder ) )
		{
			// save the column order to registry
			re.SetValue( g_rgDLColumnInfo[ DLT_ULS ].pszRVOrder,
						(LPVOID) anColumnOrder,
						sizeof( LONG ) * g_rgDLColumnInfo[ DLT_ULS ].nColumns );
		}

		// save the sort column and direction
		re.SetValue(g_rgDLColumnInfo[ DLT_ULS ].pszRVSortColumn, m_iSortColumn);
		re.SetValue(g_rgDLColumnInfo[ DLT_ULS ].pszRVSortAscending, m_fSortAscending);
	}

}	//	End of CFindSomeone::StoreColumnInfo.


//--------------------------------------------------------------------------//
//	CFindSomeone::onCall.													//
//--------------------------------------------------------------------------//
void
CFindSomeone::onCall(void)
{
	if( m_pRai != NULL )
	{
		const bool			secure	= (IsDlgButtonChecked( GetWindow(), IDS_SECURITY_CHECKBOX ) == BST_CHECKED);
		const NM_ADDR_TYPE	nmType	= static_cast<NM_ADDR_TYPE>(m_pRai->rgDwStr[ 0 ].dw);

		g_pCCallto->Callto(	m_pRai->rgDwStr[ 0 ].psz,	//	pointer to the callto url to try to place the call with...
							m_pRai->szName,				//	pointer to the display name to use...
							nmType,						//	callto type to resolve this callto as...
							true,						//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
							&secure,					//	security preference, NULL for none. must be "compatible" with secure param if present...
							false,						//	whether or not save in mru...
							true,						//	whether or not to perform user interaction on errors...
							GetWindow(),				//	if bUIEnabled is true this is the window to parent error/status windows to...
							NULL );						//	out pointer to INmCall * to receive INmCall * generated by placing call...
	}

}	//	End of CFindSomeone::onCall.


//--------------------------------------------------------------------------//
//	CFindSomeone::OnDeleteIlsServer.										//
//--------------------------------------------------------------------------//
void CFindSomeone::OnDeleteIlsServer(void)
{

	if( m_pMruServer != NULL )
	{
		int	iSelectionIndex	= ::SendMessage( m_hwndCombo, CB_GETCURSEL, 0, 0 );

		if( iSelectionIndex != CB_ERR )
		{
			int	iLength	= ::SendMessage( m_hwndCombo, CB_GETLBTEXTLEN, iSelectionIndex, 0 );

			TCHAR * pszIls	= new TCHAR [ iLength + 1 ];

			if( pszIls != NULL )
			{
				if( ::SendMessage( m_hwndCombo, CB_GETLBTEXT, iSelectionIndex, (LPARAM) pszIls ) != CB_ERR )
				{
					HWND	hwndDialog	= s_pDlgCall->GetWindow();

					//	First make sure this directory server isn't their default server....
					if( lstrcmpi( pszIls, CDirectoryManager::get_defaultServer() ) == 0 )
					{
						::MessageBox( hwndDialog, RES2T( IDS_DLGCALL_CANT_DELETE_DEFAULT_ILS ), RES2T( IDS_MSGBOX_TITLE ), MB_SETFOREGROUND | MB_OK | MB_ICONEXCLAMATION );
					}
					else
					{
						//	Next make them confirm they want to do this...
						if( ::MessageBox( hwndDialog, RES2T( IDS_DLGCALL_CONFIRM_DELETE_ILS ), RES2T( IDS_MSGBOX_TITLE ), MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 ) == IDYES )
						{
							if( m_pMruServer->DeleteEntry( pszIls ) )
							{
								m_pMruServer->Save();

								int	iCount	= ::SendMessage( m_hwndCombo, CB_DELETESTRING, iSelectionIndex, 0 );

								if( iCount <= iSelectionIndex )
								{
									iSelectionIndex--;
								}

								::SendMessage( m_hwndCombo, CB_SETCURSEL, iSelectionIndex, 0 );
								ShowList( iSelectionIndex );
    						}
						}
					}
				}
						
				delete [] pszIls;
			}
		}
	}

}	//	End of CFindSomeone::OnDeleteIlsServer.


void CFindSomeone::OnCallStarted()
{
	HWND hwnd = GetWindow();

    m_secure = ::IsDlgButtonChecked( hwnd, IDS_SECURITY_CHECKBOX ) != 0;
	UpdateSecurityCheck(m_pConfRoom, hwnd, IDS_SECURITY_CHECKBOX);

	// BUGBUG georgep: We get notified before the actual conference state
	// changes, so we need to disable manually
    ::EnableWindow( GetDlgItem(hwnd, IDS_SECURITY_CHECKBOX), FALSE );
}

void CFindSomeone::OnCallEnded()
{
	HWND hwnd = GetWindow();

	UpdateSecurityCheck(m_pConfRoom, hwnd, IDS_SECURITY_CHECKBOX);
    ::CheckDlgButton( hwnd, IDS_SECURITY_CHECKBOX, m_secure );
}

//--------------------------------------------------------------------------//
//	StringCompare.															//
//--------------------------------------------------------------------------//
int StringCompare( const TCHAR * const psz1, const TCHAR * const psz2 )
{
	ASSERT( psz1 != NULL );
	ASSERT( psz2 != NULL );

	int	iResult	= CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE | SORT_STRINGSORT, psz1, -1, psz2, -1 );

	ASSERT( iResult != 0);

	if( iResult == CSTR_LESS_THAN )
	{
		iResult = -1;
	}
	else if( iResult == CSTR_GREATER_THAN )
	{
		iResult = 1;
	}
	else
	{
		iResult = 0;
	}

	return( iResult );

}	//	End of StringCompare.


//--------------------------------------------------------------------------//
//	GetDefaultRect.															//
//--------------------------------------------------------------------------//
void GetDefaultRect(const HWND hwndParent, RECT & rcRect, const int iDefaultWidth, const int iDefaultHeight)
{
	RECT	rcWorkArea;
	bool	bResizeAndCenter = true;

	if( !SystemParametersInfo( SPI_GETWORKAREA, 0, &rcWorkArea, 0 ) )
	{
		SetRect( &rcWorkArea, 0, 0, GetSystemMetrics( SM_CXSCREEN ) - 1, GetSystemMetrics( SM_CYSCREEN ) - 1 );
	}

	if( IsWindow( hwndParent ) )
	{
		GetWindowRect( hwndParent, &rcRect );

		rcRect.left	+= DX_BORDER;
		rcRect.top	+= DY_BORDER + GetSystemMetrics( SM_CYCAPTION );

		rcRect.right	= rcRect.left + iDefaultWidth;
		rcRect.bottom	= rcRect.top + iDefaultHeight;

		if( (rcRect.left >= rcWorkArea.left) && (rcRect.top >= rcWorkArea.top) &&
			(rcRect.right <= rcWorkArea.right) && (rcRect.bottom <= rcWorkArea.bottom) )
		{
			bResizeAndCenter = false;
		}
	}

	if( bResizeAndCenter )
	{
		int	iWidth	= rcWorkArea.right - rcWorkArea.left;

		if( iWidth > iDefaultWidth )
		{
			iWidth -= iDefaultWidth;
			iWidth /= 2;

			rcWorkArea.left += iWidth;
			rcWorkArea.right = rcWorkArea.left + iDefaultWidth;
		}
		else
		{
			iWidth = (rcWorkArea.right - rcWorkArea.left) / 10;

			rcWorkArea.left		+= iWidth;
			rcWorkArea.right	-= iWidth;
		}

		int	iHeight	= rcWorkArea.bottom - rcWorkArea.top;

		if( iHeight > iDefaultHeight )
		{
			iHeight -= iDefaultHeight;
			iHeight /= 2;

			rcWorkArea.top += iHeight;
			rcWorkArea.bottom = rcWorkArea.top + iDefaultHeight;
		}
		else
		{
			iHeight = (rcWorkArea.bottom - rcWorkArea.top) / 10;

			rcWorkArea.top		+= iHeight;
			rcWorkArea.bottom	-= iHeight;
		}

		rcRect = rcWorkArea;
	}

}	//	End of GetDefaultRect.


//--------------------------------------------------------------------------//
//	GetPixelsPerChar.														//
//--------------------------------------------------------------------------//
int GetPixelsPerChar(const HWND hwnd)
{
	int	iPixels	= 10;

	if( IsWindow( hwnd ) )
	{
		HDC	hDC;

		if( (hDC = GetDC( hwnd )) != NULL )
		{
			HFONT	hFont;

			if( (hFont = (HFONT) SendMessage( hwnd, WM_GETFONT, 0, 0 )) != NULL )
			{
				hFont = (HFONT) SelectObject( hDC, hFont );

				TEXTMETRIC	tmMetrics;

				GetTextMetrics( hDC, &tmMetrics );

				iPixels = tmMetrics.tmAveCharWidth;

				SelectObject( hDC, hFont );
			}

			ReleaseDC( hwnd, hDC );
		}
	}

	return( iPixels );

}	//	End of GetPixelsPerChar.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlghost.h ===
// File: dlghost.h

#ifndef _CDLGHOST_H_
#define _CDLGHOST_H_

class CDlgHost
{
private:
	HWND   m_hwnd;
	LPTSTR m_pszName;
	LPTSTR m_pszPassword;
	BOOL   m_fSecure;
    DWORD  m_attendeePermissions;
    UINT   m_maxParticipants;

public:
	CDlgHost();
	~CDlgHost();

	// Properties:
	LPCTSTR PszName()     const {return m_pszName;}
	LPCTSTR PszPassword() const {return m_pszPassword;}
	BOOL IsSecure() const {return m_fSecure;}
    DWORD   AttendeePermissions() const {return m_attendeePermissions;}
    UINT    MaxParticipants() const {return m_maxParticipants;}
	
	INT_PTR DoModal(HWND hwnd);
	VOID OnInitDialog(void);
	BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	static INT_PTR CALLBACK DlgProcHost(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};



class CDlgHostSettings
{
private:
    HWND    m_hwnd;
    BOOL    m_fHost;
    LPTSTR  m_pszName;
    DWORD   m_caps;
    NM30_MTG_PERMISSIONS   m_permissions;

public:
    CDlgHostSettings(BOOL fHost, LPTSTR szName, DWORD caps, NM30_MTG_PERMISSIONS permissions);
    ~CDlgHostSettings(void);

    static void KillHostSettings();

    INT_PTR DoModal(HWND hwnd);
    void    OnInitDialog(void);

    static INT_PTR CALLBACK DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif /* _CDLGHOST_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dshowdlg.h ===
/****************************************************************************
*
*    FILE:     DShowDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 5-6-96
*
****************************************************************************/

#ifndef _DSHOWDLG_H_
#define _DSHOWDLG_H_

static const int DS_MAX_MESSAGE_LENGTH = 1024; // characters
static const int DS_MAX_TEXT_WIDTH = 320; // pixels

// NOTE: must not conflict with MB_* flags in winuser.h
#define DSD_ALWAYSONTOP				0x01000000L

class CDontShowDlg
{
protected:
	HWND		m_hwnd;
	UINT		m_uFlags;

	LPTSTR		m_pszRegVal;
	UINT_PTR	m_uMsgId;
	RegEntry	m_reDontShow;

	int			m_nWidth;
	int			m_nHeight;
	int			m_nTextWidth;
	int			m_nTextHeight;

	BOOL		OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

	// Handlers:
	BOOL		OnOk();

public:
	
	// Methods:
				CDontShowDlg(	UINT uMsgId,
								LPCTSTR pcszRegVal,
								UINT uFlags=0);
				~CDontShowDlg()	{ delete m_pszRegVal;	};
	INT_PTR	DoModal(HWND hwnd);

	static INT_PTR CALLBACK DontShowDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam);
};

BOOL FEnableDontShow(LPCTSTR pszKey);

#endif // _DSHOWDLG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlgcall2.h ===
// File: DlgCall.h

#ifndef _CDLGCALL2_H_
#define _CDLGCALL2_H_

#include "richaddr.h"
#include "GenContainers.h"
#include "ConfRoom.h"

class CLDAP;
class CWAB;
class CGAL;
class CSPEEDDIAL;
class CHISTORY;
class CALV;
class CTranslateAccelTable;

class CMRUList;

#define MAX_DIR_COLUMNS	7

//	These are the indexes the columns are actually added to the listview in...
#define	COLUMN_INDEX_ADDRESS	0
#define	COLUMN_INDEX_AUDIO		1
#define	COLUMN_INDEX_VIDEO		2
#define	COLUMN_INDEX_LAST_NAME	3
#define	COLUMN_INDEX_FIRST_NAME	4
#define	COLUMN_INDEX_LOCATION	5
#define	COLUMN_INDEX_COMMENTS	6



class CFindSomeone : public CFrame, public IConferenceChangeHandler
{
public:
	static void findSomeone(CConfRoom *pConfRoom);

	static VOID Destroy();

	virtual void Layout();

	virtual void OnDesiredSizeChanged()
	{
		ScheduleLayout();
	}

	public:		// IConferenceChangeHandler methods
        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
		{
			return(CFrame::QueryInterface(riid, ppvObject));
		}
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
		{
			return(CFrame::AddRef());
		}
        
        virtual ULONG STDMETHODCALLTYPE Release( void)
		{
			return(CFrame::Release());
		}

		virtual void OnCallStarted();
		virtual void OnCallEnded();

		virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume) {}
		virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute) {}

		virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify) {}

		virtual void OnChangePermissions() {}

		virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel) {}

protected:
	~CFindSomeone();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
		// constants
	enum { DEFAULT_NUM_LISTVIEW_COLUMNS = 2 };

		// Member Vars
	static CFindSomeone *s_pDlgCall;

	CTranslateAccelTable *m_pAccel;	// The accelerator table we need to clean up

	HWND    m_hwndList;          // list view
	HWND    m_ilsListView;       // ils list view
	HWND    m_webView;			 // web view
	HWND    m_hwndOwnerDataList; // list view ( The owner-data one )
	WNDPROC m_WndOwnerDataListOldWndProc;  // For subclassing the above wnd

	HWND    m_hwndFrame;         // group box
	HWND    m_hwndCombo;         // combo box
	HWND    m_hwndComboEdit;     // combo box's edit control
	HWND    m_hwndEdit;          // edit control (for type-ahead)
	BOOL    m_fInEdit;           // TRUE if editing the name/address

	DWORD   m_dwOptions;         // options (NM_CALLDLG_*)
	LPCTSTR m_pszDefault;        // initial text to put in the edit control

	HIMAGELIST m_himlIcon;       // small icon image list
	int     m_cVisible;          // number of visible lines in the listbox
	int     m_dxButton;          // width of the "Advanced..." button
	int     m_dyButton;          // height of the "Advanced..." button
	int     m_dyText;            // height of a line of text
	int     m_dyTextIntro;       // height of intro text at top of dialog
	LPTSTR  m_pszTextIntro;      // Introductory text for top of dialog
	bool    m_bPlacedCall;       // TRUE if we successfuly placed a call
	bool    m_secure;		     // Save the state of the secure button

	int     m_iIlsFirst;         // index of first ILS server
	CMRUList * m_pMruServer;     // list of ILS servers
	RAI      * m_pRai;           // Rich Address Information

	// CALV items
	CLDAP    * m_pUls;
	CWAB     * m_pWab;
	CSPEEDDIAL * m_pSpeedDial;

#if USE_GAL
    CGAL     * m_pGAL;
#endif // USE_GAL
    CHISTORY * m_pHistory;

	CConfRoom * m_pConfRoom;


#ifdef ENABLE_BL
	CBL      * m_pBl;
#endif /* ENABLE_BL */

	CALV     * m_pAlv;        // Current Address List View (NOTE: NULL == m_pUls)
	int        m_iSel;        // current selection in combo box
	TCHAR      m_szAddress[CCHMAXSZ_ADDRESS];
	TCHAR      m_szDirectory[CCHMAXSZ];

	CFindSomeone(CConfRoom *pConfRoom);

	HWND GetHwndList();
	int  GetEditText(LPTSTR psz, int cchMax);
	RAI * GetAddrInfo();
	
	int  AddAlv(CALV * pAlv);
	int  AddAlvSz(CALV * pAlv, LPCTSTR psz, int cbIndex=-1);

	HRESULT doModeless(void);
	HRESULT CreateDlgCall(HWND hwndParent);
	BOOL FMsgSpecial(MSG * pMsg);
	VOID CalcDyText(void);
	VOID InitAlv(void);

	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);

	LRESULT OnNotifyCombo(LPARAM lParam);
	LRESULT OnNotifyList(LPARAM lParam);
	VOID EndComboEdit(int iWhy);
	VOID UpdateIlsServer(void);
	LRESULT DoCustomDraw(LPNMLVCUSTOMDRAW lplvcd);

	VOID ShowList(int iSel);

	HWND
	createIlsListView(void);

	VOID OnEditChangeDirectory(void);
	int  FindSz(LPCTSTR psz);
	int FindSzBySortedColumn(LPCTSTR psz);
	HRESULT HrGetSelection(void);
	void OnDeleteIlsServer(void);

    static LRESULT CALLBACK OwnerDataListWndProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

private:
	// Helper Fns
	int _GetCurListViewNumColumns();
	bool _IsDirectoryServicePolicyDisabled();

	BOOL
	InitColumns(void);

	BOOL
	LoadColumnInfo(void);

	void
	StoreColumnInfo(void);

	static
	int
	CALLBACK
	CompareWrapper
	(
		LPARAM	param1,
		LPARAM	param2,
		LPARAM	This
	);

	int
	DirListViewCompareProc
	(
		LPARAM	param1,
		LPARAM	param2
	);

	int
	LParamToPos
	(
		LPARAM lParam
	);

	void
	onAdvanced(void);

	void
	onCall(void);

	LONG	m_alColumns[MAX_DIR_COLUMNS];
	int		m_iSortColumn;
	BOOL	m_fSortAscending;
};

CMRUList * GetMruListServer(void);

#define WM_DISPLAY_MSG    (WM_USER + 200)

#endif /* _CDLGCALL2_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dshowdlg.cpp ===
#include "precomp.h"
#include "resource.h"

/****************************************************************************
*
*    FILE:     DShowDlg.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 5-6-96
*
*    CONTENTS: CDontShowDlg object
*
****************************************************************************/

#include "DShowDlg.h"
#include "conf.h"
#include "ConfUtil.h"

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   CDontShowDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CDontShowDlg::CDontShowDlg(	UINT uMsgId,
							LPCTSTR pcszRegVal,
							UINT uFlags):
	m_uMsgId		(uMsgId),
	m_hwnd			(NULL),
	m_reDontShow	(UI_KEY, HKEY_CURRENT_USER),
	m_uFlags		(uFlags),
	m_nWidth		(0),
	m_nHeight		(0),
	m_nTextWidth	(0),
	m_nTextHeight	(0)
{
	DebugEntry(CDontShowDlg::CDontShowDlg);

	ASSERT(pcszRegVal);
	
	m_pszRegVal = PszAlloc(pcszRegVal);

	DebugExitVOID(CDontShowDlg::CDontShowDlg);
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CDontShowDlg::DoModal(HWND hwnd)
{
	DebugEntry(CDontShowDlg::DoModal);

	INT_PTR nRet = IDCANCEL;

	if (_Module.InitControlMode())
	{
		nRet = IDOK;
	}
	else if (NULL != m_pszRegVal)
	{
	// If the "dont show me" check box has been checked before and stored in
	// the registry, then return IDOK, so the calling code doesn't have to
	// differentiate the two cases.

		nRet = (TRUE == m_reDontShow.GetNumber(m_pszRegVal, FALSE)) ?
				IDOK : IDCANCEL;
	}
	
	if (IDOK != nRet)
	{
		HWND hwndDesktop = ::GetDesktopWindow();
		if (NULL != hwndDesktop)
		{
			HDC hdc = ::GetDC(hwndDesktop);
			if (NULL != hdc)
			{
				HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
				TCHAR szString[DS_MAX_MESSAGE_LENGTH];
				LPTSTR pszString = NULL;
				if (0 != HIWORD(m_uMsgId))
				{
					// use m_uMsgId as a string pointer
					// NOTE: object must be used on the stack since the pointer is
					// not copied
					pszString = (LPTSTR) m_uMsgId;
				}
				else if (::LoadString(	::GetInstanceHandle(), (UINT)m_uMsgId,
										szString, ARRAY_ELEMENTS(szString)))
				{
					pszString = szString;
				}
				if (NULL != pszString)
				{
					m_nTextWidth = DS_MAX_TEXT_WIDTH;

					RECT rct = {0, 0, m_nTextWidth, 0xFFFF};
					m_nTextHeight = ::DrawText(	hdc,
												pszString,
												-1,
												&rct,
												DT_LEFT | DT_CALCRECT | DT_WORDBREAK);
				}
				::SelectObject(hdc, hFontOld);
				::ReleaseDC(hwndDesktop, hdc);
			}
		}

		// If the box wasn't checked before, then bring up the dialog:
		nRet = DialogBoxParam(	::GetInstanceHandle(),
								MAKEINTRESOURCE(IDD_DONT_SHOW_ME),
								hwnd,
								CDontShowDlg::DontShowDlgProc,
								(LPARAM) this);
	}

	DebugExitINT_PTR(CDontShowDlg::DoModal, nRet);

	return nRet;
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   DontShowDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CDontShowDlg::DontShowDlgProc(HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				CDontShowDlg* pdsd = (CDontShowDlg*) lParam;
				pdsd->m_hwnd = hDlg;
				::SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				int nInitialTextWidth = 0;
				int nInitialTextHeight = 0;

				TCHAR szMsgBuf[DS_MAX_MESSAGE_LENGTH];
				if (0 != HIWORD(pdsd->m_uMsgId))
				{
					// use m_uMsgId as a string pointer
					// NOTE: object must be used on the stack since the pointer is
					// not copied
					ASSERT(IS_VALID_READ_PTR((LPTSTR) pdsd->m_uMsgId, TCHAR));
					lstrcpyn(szMsgBuf, (LPTSTR) pdsd->m_uMsgId, CCHMAX(szMsgBuf));
				}
				else
				{
					::LoadString(	::GetInstanceHandle(),
									(INT)pdsd->m_uMsgId,
									szMsgBuf,
									(INT)ARRAY_ELEMENTS(szMsgBuf));
				}

				// Set the text
				::SetDlgItemText(	hDlg,
									IDC_TEXT_STATIC,
									szMsgBuf);

				RECT rctDlg;
				::GetWindowRect(hDlg, &rctDlg);
				int nOrigWidth = rctDlg.right - rctDlg.left;
				int nOrigHeight = rctDlg.bottom - rctDlg.top;
				HWND hwndText = ::GetDlgItem(hDlg, IDC_TEXT_STATIC);
				if (NULL != hwndText)
				{
					RECT rctText;
					if (::GetWindowRect(hwndText, &rctText))
					{
						nInitialTextWidth = rctText.right - rctText.left;
						nInitialTextHeight = rctText.bottom - rctText.top;
						// Resize the text control
						::SetWindowPos(	hwndText,
										NULL, 0, 0,
										pdsd->m_nTextWidth,
										pdsd->m_nTextHeight,
										SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
					}

					// Set the font (for DBCS systems)
					::SendMessage(hwndText, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
				}

				pdsd->m_nWidth = (nOrigWidth - nInitialTextWidth)
									+ pdsd->m_nTextWidth;
				pdsd->m_nHeight = (nOrigHeight - nInitialTextHeight)
									+ pdsd->m_nTextHeight;

				RECT rctCtrl;
				// Move the ok button (IDOK)
				HWND hwndOK = ::GetDlgItem(hDlg, IDOK);
				if ((NULL != hwndOK) && ::GetWindowRect(hwndOK, &rctCtrl))
				{
					// Turn rctCtrl's top and left into client coords:
					::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 2);
					if (pdsd->m_uFlags & MB_OKCANCEL)
					{
						::SetWindowPos(	hwndOK,
										NULL,
										rctCtrl.left + ((pdsd->m_nWidth - nOrigWidth) / 2),
										rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
										0, 0,
										SWP_NOACTIVATE | SWP_NOZORDER
											| SWP_NOSIZE | SWP_NOREDRAW);
					}
					else
					{
						// center the OK button
						::SetWindowPos(	hwndOK,
										NULL,
										(pdsd->m_nWidth / 2) -
											((rctCtrl.right - rctCtrl.left) / 2),
										rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
										0, 0,
										SWP_NOACTIVATE | SWP_NOZORDER
											| SWP_NOSIZE | SWP_NOREDRAW);
					}
				}
				// Move the cancel button (IDCANCEL)
				HWND hwndCancel = ::GetDlgItem(hDlg, IDCANCEL);
				if ((NULL != hwndCancel) && ::GetWindowRect(hwndCancel, &rctCtrl))
				{
					if (pdsd->m_uFlags & MB_OKCANCEL)
					{
						// Turn rctCtrl's top and left into client coords:
						::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
						::SetWindowPos(	hwndCancel,
										NULL,
										rctCtrl.left + ((pdsd->m_nWidth - nOrigWidth) / 2),
										rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
										0, 0,
										SWP_NOACTIVATE | SWP_NOZORDER
											| SWP_NOSIZE | SWP_NOREDRAW);
					}
					else
					{
						::ShowWindow(hwndCancel, SW_HIDE);
					}
				}
				// Move the check box (IDC_DONT_SHOW_ME_CHECK)
				HWND hwndCheck = ::GetDlgItem(hDlg, IDC_DONT_SHOW_ME_CHECK);
				if ((NULL != hwndCheck) && ::GetWindowRect(hwndCheck, &rctCtrl))
				{
					// Turn rctCtrl's top and left into client coords:
					::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
					::SetWindowPos(	hwndCheck,
									NULL,
									rctCtrl.left,
									rctCtrl.top + (pdsd->m_nHeight - nOrigHeight),
									0, 0,
									SWP_NOACTIVATE | SWP_NOZORDER
										| SWP_NOSIZE | SWP_NOREDRAW);
				}
				
				// Show, resize, and activate
				::SetWindowPos(	hDlg,
								0,
								0,
								0,
								pdsd->m_nWidth,
								pdsd->m_nHeight,
								SWP_SHOWWINDOW | SWP_NOZORDER |
									SWP_NOMOVE | SWP_DRAWFRAME);

				// Put the appropriate icon on the dialog:
				HWND hwndIcon = ::GetDlgItem(hDlg, IDC_ICON_STATIC);
				::SendMessage(	hwndIcon,
								STM_SETICON,
								(WPARAM) ::LoadIcon(NULL, IDI_INFORMATION),
								0);

				if (pdsd->m_uFlags & DSD_ALWAYSONTOP)
				{
					::SetWindowPos(	hDlg,
									HWND_TOPMOST,
									0, 0, 0, 0,
									SWP_NOMOVE | SWP_NOSIZE);
				}
				if (pdsd->m_uFlags & MB_SETFOREGROUND)
				{
					::SetForegroundWindow(hDlg);
				}
			}

			bMsgHandled = 1;
			break;
		}

		default:
		{
			CDontShowDlg* ppd = (CDontShowDlg*) GetWindowLongPtr(	hDlg,
																DWLP_USER);

			if (NULL != ppd)
			{
				bMsgHandled = ppd->OnMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   OnMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CDontShowDlg::OnMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
		
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					bRet = OnOk();
					break;
				}

				case IDCANCEL:
				{
					::EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

			}
			break;
		}
			
		default:
			break;
	}

	return bRet;
}

/****************************************************************************
*
*    CLASS:    CDontShowDlg
*
*    MEMBER:   OnOk()
*
*    PURPOSE:  processes the WM_COMMAND,IDOK message
*
****************************************************************************/

BOOL CDontShowDlg::OnOk()
{
	DebugEntry(CDontShowDlg::OnOk);

	BOOL bRet = TRUE;

	if ((BST_CHECKED == ::IsDlgButtonChecked(m_hwnd, IDC_DONT_SHOW_ME_CHECK)) &&
		(NULL != m_pszRegVal))
	{
		m_reDontShow.SetValue(m_pszRegVal, TRUE);
	}

	::EndDialog(m_hwnd, IDOK);

	DebugExitBOOL(CDontShowDlg::OnOk, bRet);

	return bRet;
}

///////////////////////////////////////////////////////////////////////////////
//

/*  F  E N A B L E  D O N T  S H O W  */
/*-------------------------------------------------------------------------
    %%Function: FEnableDontShow

    Return TRUE if the "Don't Show" dialog is enabled
-------------------------------------------------------------------------*/
BOOL FEnableDontShow(LPCTSTR pszKey)
{
	RegEntry reUI(UI_KEY, HKEY_CURRENT_USER);
	return (0 == reUI.GetNumber(pszKey, 0));
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dlghost.cpp ===
// File: dlghost.cpp

#include "precomp.h"

#include "resource.h"
#include "dlghost.h"
#include "ConfPolicies.h"
#include <help_ids.h>


// Dialog ID to Help ID mapping
static const DWORD rgHelpIdsHostMeeting[] = {
IDE_HOST_GENERAL,       IDH_HOST_GENERAL,
IDE_HOST_SETTINGS,      IDH_HOST_SETTINGS,
IDE_HOST_NAME,          IDH_HOST_NAME,
IDE_HOST_PASSWORD,      IDH_HOST_PASSWORD,
IDE_HOST_SECURE,        IDH_HOST_SECURE,
IDE_HOST_YOUACCEPT,     IDH_HOST_ACCEPT_PEOPLE,
IDE_HOST_YOUINVITE,     IDH_HOST_INVITE_PEOPLE,
IDE_HOST_TOOLS,         IDH_HOST_TOOLS,
IDE_HOST_TOOLS2,        IDH_HOST_TOOLS,
IDE_HOST_YOUSHARE,      IDH_HOST_SHARE,
IDE_HOST_YOUWB,         IDH_HOST_WHITEBD,
IDE_HOST_YOUCHAT,       IDH_HOST_CHAT,
IDE_HOST_YOUFT,         IDH_HOST_XFER,
IDE_HOST_YOUAUDIO,      IDH_HOST_AUDIO,
IDE_HOST_YOUVIDEO,      IDH_HOST_VIDEO,
0, 0 // terminator
};

static HWND  s_hwndSettings = NULL;


/*  C  D L G  H O S T  */
/*-------------------------------------------------------------------------
    %%Function: CDlgHost

-------------------------------------------------------------------------*/
CDlgHost::CDlgHost(void):
	m_hwnd(NULL),
	m_pszName(NULL),
	m_pszPassword(NULL),
    m_attendeePermissions(NM_PERMIT_ALL),
    m_maxParticipants(-1)
{
}

CDlgHost::~CDlgHost(void)
{
	delete m_pszName;
	delete m_pszPassword;
}


INT_PTR CDlgHost::DoModal(HWND hwnd)
{
	return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_HOST),
						hwnd, CDlgHost::DlgProcHost, (LPARAM) this);
}



/*  D L G  P R O C  H O S T  */
/*-------------------------------------------------------------------------
    %%Function: DlgProcHost

-------------------------------------------------------------------------*/
INT_PTR CALLBACK CDlgHost::DlgProcHost(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG:
	{
		ASSERT(NULL != lParam);
		::SetWindowLongPtr(hdlg, DWLP_USER, lParam);

		CDlgHost * pDlg = (CDlgHost*) lParam;
		pDlg->m_hwnd = hdlg;
		pDlg->OnInitDialog();
		return TRUE; // default focus is ok
	}

	case WM_COMMAND:
	{
		CDlgHost * pDlg = (CDlgHost*) GetWindowLongPtr(hdlg, DWLP_USER);
		if (NULL != pDlg)
		{
			pDlg->OnCommand(wParam, lParam);
		}
		break;
	}

    case WM_CONTEXTMENU:
        DoHelpWhatsThis(wParam, rgHelpIdsHostMeeting);
        break;

    case WM_HELP:
        DoHelp(lParam, rgHelpIdsHostMeeting);
        break;
	
	default:
		break;
	}

	return FALSE;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
BOOL CDlgHost::OnCommand(WPARAM wParam, LPARAM lParam)
{
    TCHAR   szName[MAX_PATH];
    TCHAR   szPassword[MAX_PATH];

    UINT wCmd = GET_WM_COMMAND_ID(wParam, lParam);
	
	switch (wCmd)
	{
	case IDOK:
	{
		TCHAR sz[MAX_PATH];
		if (0 != GetDlgItemText(m_hwnd, IDE_HOST_NAME, sz, CCHMAX(sz)))
		{
			m_pszName = PszAlloc(sz);
		}

		if (0 != GetDlgItemText(m_hwnd, IDE_HOST_PASSWORD, sz, CCHMAX(sz)))
		{
			m_pszPassword = PszAlloc(sz);
		}

        m_fSecure = ::IsDlgButtonChecked(m_hwnd, IDE_HOST_SECURE);

        //
        // Permissions
        //
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUACCEPT))
        {
            m_attendeePermissions &= ~NM_PERMIT_INCOMINGCALLS;
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUINVITE))
        {
            m_attendeePermissions &= ~NM_PERMIT_OUTGOINGCALLS;
        }

        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUSHARE))
        {
            m_attendeePermissions &= ~NM_PERMIT_SHARE;
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUWB))
        {
            m_attendeePermissions &= ~(NM_PERMIT_STARTOLDWB | NM_PERMIT_STARTWB);
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUCHAT))
        {
            m_attendeePermissions &= ~NM_PERMIT_STARTCHAT;
        }
        if (::IsDlgButtonChecked(m_hwnd, IDE_HOST_YOUFT))
        {
            m_attendeePermissions &= ~NM_PERMIT_SENDFILES;
        }
		// fall thru to IDCANCEL
	}

	case IDCANCEL:
	{
		::EndDialog(m_hwnd, wCmd);
		return TRUE;
	}

    case IDE_HOST_NAME:
    case IDE_HOST_PASSWORD:
    {
        switch (GET_WM_COMMAND_CMD(wParam, lParam))
        {
            case EN_CHANGE:
            {
                BOOL    fOkName;
                BOOL    fOkPassword;

                //
                // Look at the name
                //
                GetDlgItemText(m_hwnd, IDE_HOST_NAME, szName, CCHMAX(szName));

                if (!szName[0])
                {
                    fOkName = FALSE;
                }
                else if (!FAnsiSz(szName))
                {
                    fOkName = FALSE;
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDE_HOST_NAME)
                    {
                        // User typed bogus char in name field
                        MessageBeep(0);
                    }
                }
                else
                {
                    fOkName = TRUE;
                }

                //
                // Look at the password, it CAN be empty
                //
                GetDlgItemText(m_hwnd, IDE_HOST_PASSWORD, szPassword, CCHMAX(szPassword));

                if (!szPassword[0])
                {
                    fOkPassword = TRUE;
                }
                else if (FAnsiSz(szPassword))
                {
                    fOkPassword = TRUE;
                }
                else
                {
                    fOkPassword = FALSE;
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDE_HOST_PASSWORD)
                    {
                        // User typed bogus char in password field
                        MessageBeep(0);
                    }
                }

                EnableWindow(GetDlgItem(m_hwnd, IDOK), fOkName && fOkPassword);

                break;
            }
        }
        break;
    }

	default:
		break;
	}

	return FALSE;
}



/*  O N  I N I T  D I A L O G  */
/*-------------------------------------------------------------------------
    %%Function: OnInitDialog

-------------------------------------------------------------------------*/
VOID CDlgHost::OnInitDialog(void)
{
	TCHAR sz[MAX_PATH];
    BOOL  fSecureAlterable;
    BOOL  fSecureOn;

    switch (ConfPolicies::GetSecurityLevel())
    {
        case DISABLED_POL_SECURITY:
            fSecureOn = FALSE;
            fSecureAlterable = FALSE;
            break;

        case REQUIRED_POL_SECURITY:
            fSecureOn = TRUE;
            fSecureAlterable = FALSE;
            break;

        default:
            fSecureOn = ConfPolicies::OutgoingSecurityPreferred();
            fSecureAlterable = TRUE;
            break;
    }

    ::CheckDlgButton(m_hwnd, IDE_HOST_SECURE, fSecureOn);
    ::EnableWindow(::GetDlgItem(m_hwnd, IDE_HOST_SECURE), fSecureAlterable);

	if (FLoadString(IDS_DEFAULT_CONF_NAME, sz, CCHMAX(sz)))
	{
		SetDlgItemText(m_hwnd, IDE_HOST_NAME, sz);
	}

	Edit_LimitText(GetDlgItem(m_hwnd, IDE_HOST_NAME), CCHMAXSZ_NAME - 1);
	Edit_LimitText(GetDlgItem(m_hwnd, IDE_HOST_PASSWORD), CCHMAXSZ_NAME - 1);

}



//
// C  D L G  H O S T  S E T T I N G S
//
// This is a simple description of what restrictions there are in this
// meeting.  Users see this when
//      (a) They join a restricted meeting
//      (b) They or the host chooses the Meeting Properties menu item under Call
//
CDlgHostSettings::CDlgHostSettings
(
    BOOL        fHost,
    LPTSTR      szName,
    DWORD       caps,
    NM30_MTG_PERMISSIONS permissions
)
{
    m_hwnd          = NULL;
    m_fHost         = fHost;
    m_pszName       = szName;
    m_caps          = caps;
    m_permissions   = permissions;
}


CDlgHostSettings::~CDlgHostSettings(void)
{
}


void CDlgHostSettings::KillHostSettings(void)
{
    if (s_hwndSettings)
    {
        // Kill current one.
        WARNING_OUT(("Killing previous meeting settings dialog"));
        SendMessage(s_hwndSettings, WM_COMMAND, IDCANCEL, 0);
        ASSERT(!s_hwndSettings);
    }
}


INT_PTR CDlgHostSettings::DoModal(HWND hwnd)
{
    CDlgHostSettings::KillHostSettings();

    return DialogBoxParam(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_HOST_SETTINGS),
        hwnd, CDlgHostSettings::DlgProc, (LPARAM)this);
}


//
// CDlgHostSettings::DlgProc()
//
INT_PTR CALLBACK CDlgHostSettings::DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT(lParam != NULL);
            SetWindowLongPtr(hdlg, DWLP_USER, lParam);

            CDlgHostSettings * pDlg = (CDlgHostSettings *) lParam;

            ASSERT(!s_hwndSettings);
            s_hwndSettings = hdlg;
            pDlg->m_hwnd = hdlg;
            pDlg->OnInitDialog();
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (s_hwndSettings == hdlg)
                    {
                        s_hwndSettings = NULL;
                    }
                    ::EndDialog(hdlg, GET_WM_COMMAND_ID(wParam, lParam));
                    return TRUE;
            }
            break;
        }

        case WM_CONTEXTMENU:
        {
            DoHelpWhatsThis(wParam, rgHelpIdsHostMeeting);
            break;
        }

        case WM_HELP:
        {
            DoHelp(lParam, rgHelpIdsHostMeeting);
            break;
        }

        default:
            break;
    }

    return FALSE;
}


//
// CDlgHostSettings::OnInitDialog()
//
void CDlgHostSettings::OnInitDialog(void)
{
    TCHAR   szText[256];
    TCHAR   szRestrict[128];
    TCHAR   szResult[384];

    ::SetDlgItemText(m_hwnd, IDE_HOST_NAME, m_pszName);

    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_SECURE), ((m_caps & NMCH_SECURE) != 0));

    //
    // Meeting settings
    //
    if (!m_fHost)
	{
		SetDlgItemText(m_hwnd, IDE_HOST_YOUACCEPT, RES2T(IDS_NONHOST_YOUACCEPT));
	}
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUACCEPT),
        !(m_permissions & NM_PERMIT_INCOMINGCALLS));

    if (!m_fHost)
	{
		SetDlgItemText(m_hwnd, IDE_HOST_YOUINVITE, RES2T(IDS_NONHOST_YOUINVITE));
	}
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUINVITE),
        !(m_permissions & NM_PERMIT_OUTGOINGCALLS));

    //
    // Meeting tools
    //
	if (!m_fHost)
	{
		SetDlgItemText(m_hwnd, IDE_HOST_TOOLS, RES2T(IDS_NONHOST_TOOLS));
	}

    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUSHARE),
        !(m_permissions & NM_PERMIT_SHARE));
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUWB),
        !(m_permissions & (NM_PERMIT_STARTWB | NM_PERMIT_STARTOLDWB)));
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUCHAT),
        !(m_permissions & NM_PERMIT_STARTCHAT));
    EnableWindow(GetDlgItem(m_hwnd, IDE_HOST_YOUFT),
        !(m_permissions & NM_PERMIT_SENDFILES));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dstest.h ===
#ifndef _DSTEST_H_
#define _DSTEST_H_

#define DS_AVAILABLE	1
#define DS_FULLDUPLEX   2
#define DS_FULLDUPLEX_RECOMMENDED 3

UINT DirectSoundCheck(UINT waveInID, UINT waveOutID, HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\dstest.cpp ===
#include "precomp.h"
#include <confreg.h>
#include "audiowiz.h"
#include <dsound.h>
#include <mmsystem.h>
#include "wavedev.h"
#include <nmdsprv.h>

#include "dstest.h"

// assume 10 direct sound devices as a max
#define MAX_DS_DEVS 10

// directsound functions
typedef HRESULT (WINAPI *LPFNDSCREATE)(const GUID *, LPDIRECTSOUND *, IUnknown FAR *);
typedef HRESULT (WINAPI *LPFNDSENUM)(LPDSENUMCALLBACKA , LPVOID);

// directsound capture functions
typedef HRESULT (WINAPI *DS_CAP_CREATE)(LPGUID, LPDIRECTSOUNDCAPTURE *, LPUNKNOWN);
typedef HRESULT (WINAPI *DS_CAP_ENUM)(LPDSENUMCALLBACKA, LPVOID);


static HRESULT MapWaveOutIdToGuid(UINT waveOutId, GUID *pGuid, LPFNDSCREATE dsCreate, LPFNDSENUM dsEnum);
static HRESULT MapWaveInIdToGuid(UINT waveInId, GUID *pGuid, DS_CAP_CREATE dscCreate, DS_CAP_ENUM dscEnum);




struct GuidDescription
{
	GUID guid;
	BOOL fAllocated;
};

static GuidDescription guidList_DS[MAX_DS_DEVS];
static int nGList_DS = 0;


static GuidDescription guidList_DSC[MAX_DS_DEVS];
static int nGList_DSC = 0;



static BOOL CALLBACK DSEnumCallback(GUID FAR * lpGuid, LPTSTR lpstrDescription,
                    LPTSTR lpstrModule, LPVOID lpContext)
{
	GuidDescription *pList;
	int *pListSize;

	if (lpContext)
	{
		pList = guidList_DS;
		pListSize = &nGList_DS;
	}
	else
	{
		pList = guidList_DSC;
		pListSize = &nGList_DSC;
	}

	if (lpGuid)
	{
		pList[*pListSize].guid = *lpGuid;
	}
	else
	{
		pList[*pListSize].guid = GUID_NULL;
	}

	pList->fAllocated = FALSE;
//	pList->szDescription = new TCHAR[lstrlen(lpstrDescription) + 1];
//	if (pList->szDescription)
//	{
//		lstrcpy(pList->szDescription, lpstrDescription);
//	}	

	*pListSize = *pListSize + 1;

	if ((*pListSize) < MAX_DS_DEVS)
		return TRUE;
	return FALSE;
}








// returns a set of flags (see dstest.h) indicating full duplex
// capabilities
UINT DirectSoundCheck(UINT waveInID, UINT waveOutID, HWND hwnd)
{
	BOOL bRet;
	HRESULT hr;
	HINSTANCE hDSI;
	LPFNDSCREATE dsCreate;
	LPFNDSENUM dsEnum;
	GUID dsguid, dscguid;
	LPDIRECTSOUND pDirectSound = NULL;
	MMRESULT mmr;
	int nRetVal = 0;
	DSBUFFERDESC dsBufDesc;
	LPDIRECTSOUNDBUFFER pDirectSoundBuffer;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM,1,8000,16000,2,16,0};
	DS_CAP_CREATE dsCapCreate = NULL;
	DS_CAP_ENUM dsCapEnum = NULL;
	DSCBUFFERDESC dscBufDesc;
	LPDIRECTSOUNDCAPTURE pDirectSoundCapture=NULL;
	LPDIRECTSOUNDCAPTUREBUFFER pDSCBuffer = NULL;

    //
    // If changing DirectSound is prevented by policy and the current
    // setting is off, skip the test.  If the setting is on, we always
    // want to perform the test in case the system is no longer DS capable.
    //
    RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    if (rePol.GetNumber(REGVAL_POL_NOCHANGE_DIRECTSOUND, DEFAULT_POL_NOCHANGE_DIRECTSOUND))
    {
        // changing DS is prevented by policy.
    	RegEntry re(AUDIO_KEY, HKEY_CURRENT_USER);
        if (re.GetNumber(REGVAL_DIRECTSOUND, DSOUND_USER_DISABLED) != DSOUND_USER_ENABLED)
    	{
	    	return 0;
        }
	}

	PlaySound(NULL, NULL, NULL); // cancel any running playsound

	hDSI = LoadLibrary(TEXT("DSOUND.DLL"));

	if (hDSI == NULL)
	{
		return 0; // direct sound is not available!
	}

	// check for Direct Sound 5 or higher
	// Existance of DirectSoundCapture functions implies DSound v.5
	dsEnum = (LPFNDSENUM)GetProcAddress(hDSI, "DirectSoundEnumerateA");
	dsCreate = (LPFNDSCREATE)GetProcAddress(hDSI, "DirectSoundCreate");
	dsCapEnum = (DS_CAP_ENUM)GetProcAddress(hDSI, "DirectSoundCaptureEnumerateA");
	dsCapCreate = (DS_CAP_CREATE)GetProcAddress(hDSI, TEXT("DirectSoundCaptureCreate"));

	if ((dsCapCreate == NULL) || (dsCreate == NULL) || (dsEnum == NULL) || (dsCapEnum==NULL))
	{
		FreeLibrary(hDSI);
		return 0;
	}

	hr = MapWaveOutIdToGuid(waveOutID, &dsguid, dsCreate, dsEnum);
	if (FAILED(hr))
	{
		WARNING_OUT(("Unable to map waveOutID to DirectSound guid!"));
		FreeLibrary(hDSI);
		return 0;
	}

	hr = MapWaveInIdToGuid(waveInID, &dscguid, dsCapCreate, dsCapEnum);
	if (FAILED(hr))
	{
		WARNING_OUT(("Unable to map waveOutID to DirectSound guid!"));
		FreeLibrary(hDSI);
		return 0;
	}

	nRetVal = DS_AVAILABLE;


	// Open DirectSound First
	hr = dsCreate((dsguid==GUID_NULL)?NULL:&dsguid, &pDirectSound, NULL);
	if (FAILED(hr))
	{
		WARNING_OUT(("Direct Sound failed to open by itself!"));
		FreeLibrary(hDSI);
		return 0;
	}

	// set cooperative level
	hr = pDirectSound->SetCooperativeLevel(hwnd, DSSCL_PRIORITY);
	if (hr != DS_OK)
	{
		WARNING_OUT(("Direct Sound: failed to set cooperative level"));
		pDirectSound->Release();
		FreeLibrary(hDSI);
		return 0;
	}


	ZeroMemory(&dsBufDesc,sizeof(dsBufDesc));
	dsBufDesc.dwSize = sizeof(dsBufDesc);
	dsBufDesc.dwFlags = DSBCAPS_PRIMARYBUFFER;
	hr = pDirectSound->CreateSoundBuffer(&dsBufDesc,&pDirectSoundBuffer,NULL);
	if (hr == S_OK)
	{
		pDirectSoundBuffer->SetFormat(&waveFormat);
	}
	else
	{
		WARNING_OUT(("Direct Sound: failed to set format"));
		pDirectSound->Release();
		FreeLibrary(hDSI);
		return 0;
	}



	// now attempt to open DirectSoundCapture
	hr = dsCapCreate((dscguid==GUID_NULL)?NULL:&dscguid, &pDirectSoundCapture, NULL);
	if (SUCCEEDED(hr))
	{
		dscBufDesc.dwSize = sizeof(dscBufDesc);
		dscBufDesc.dwFlags = 0;
		dscBufDesc.dwBufferBytes = 1000;
		dscBufDesc.dwReserved = 0;
		dscBufDesc.lpwfxFormat = &waveFormat;
		hr = pDirectSoundCapture->CreateCaptureBuffer(&dscBufDesc, &pDSCBuffer, NULL);
		if (SUCCEEDED(hr))
		{
			// full duplex is avaiable;
			nRetVal |= DS_FULLDUPLEX;
		}
	}

	if (pDSCBuffer)
	{
		pDSCBuffer->Release();
	}
	if (pDirectSoundCapture)
	{
		pDirectSoundCapture->Release();
	}

	pDirectSoundBuffer->Release();
	pDirectSound->Release();


	FreeLibrary(hDSI);

	return nRetVal;

}



HRESULT MapWaveOutIdToGuid(UINT waveOutID, GUID *pGuid, LPFNDSCREATE dsCreate, LPFNDSENUM dsEnum)
{
	waveOutDev waveOut(waveOutID);
	MMRESULT mmr;
	HRESULT hr;
	LPDIRECTSOUND pDS;
	DSCAPS dscaps;
	BOOL fEmulFound, bRet;
	int index;
	GUID *pIID;
	WAVEOUTCAPS waveOutCaps;

	if (waveOutID == WAVE_MAPPER || waveOutGetNumDevs()==1)
	{
		// we want the default or there is only one DS device, take the easy way out
		*pGuid =  GUID_NULL;
		return S_OK;
	}


	// The New way.  DirectX on Win98/NT 5 gives an IKsProperty interface
	// to generate the mapping correctly

	ZeroMemory(&waveOutCaps, sizeof(WAVEOUTCAPS));
	mmr = waveOutGetDevCaps(waveOutID, &waveOutCaps, sizeof(WAVEOUTCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveOutCaps.szPname, FALSE, pGuid);
		if (SUCCEEDED(hr))
		{
			TRACE_OUT(("dstest.cpp: Succeeded in mapping Wave ID to DS guid through IKsProperty interface\r\n"));
			return hr;
		}
		// if we failed to make a mapping, fall through to the old code path
		WARNING_OUT(("dstest.cpp: Failed to map Wave ID to DS guid through IKsProperty interface\r\n"));
	}



	// the old way!
	// try to figure out which Guid maps to a wave id
	// Do this by opening the wave device corresponding to the wave id and then
	// all the DS devices in sequence and see which one fails.
	// Yes, this is a monstrous hack and clearly unreliable
	ZeroMemory(guidList_DS, sizeof(guidList_DS));
	nGList_DS = 0;

	hr = dsEnum((LPDSENUMCALLBACK)DSEnumCallback, (VOID*)TRUE);
	if (hr != DS_OK)
	{
		WARNING_OUT(("DirectSoundEnumerate failed\n"));
		return hr;
	}

	mmr = waveOut.Open(8000, 16);

	if (mmr != MMSYSERR_NOERROR)
	{
		return DSERR_INVALIDPARAM;
	}

	// now open all the DS devices in turn
	for (index = 0; index < nGList_DS; index++)
	{
		if (guidList_DS[index].guid==GUID_NULL)
			pIID = NULL;
		else
			pIID = &(guidList_DS[index].guid);
		hr = dsCreate(pIID, &pDS, NULL);
		if (hr != DS_OK)
		{
			guidList_DS[index].fAllocated = TRUE;
		}
		else
		{
			pDS->Release();
		}
	}

	waveOut.Close();

	hr = DSERR_ALLOCATED;

	dscaps.dwSize = sizeof(dscaps);
	fEmulFound = FALSE;
	// try opening the DS devices that failed the first time
	for (index = 0; index < nGList_DS; index++)
	{
		if (guidList_DS[index].fAllocated == TRUE)
		{
			if (guidList_DS[index].guid==GUID_NULL)
				pIID = NULL;
			else
				pIID = &(guidList_DS[index].guid);

			hr = dsCreate(pIID, &pDS, NULL);
			if (hr == DS_OK)
			{
				*pGuid = guidList_DS[index].guid;
				// get dsound capabilities.
				pDS->GetCaps(&dscaps);
				pDS->Release();
				if (dscaps.dwFlags & DSCAPS_EMULDRIVER)
					fEmulFound = TRUE;	// keep looking in case there's also a native driver
				else
					break;	// native DS driver. Look no further
					
			}
		}
	}

	if (fEmulFound)
		hr = DS_OK;
		
	if (hr != DS_OK)
	{
		WARNING_OUT(("Can't map id %d to DSound guid!\n", waveOutID));
		hr = DSERR_ALLOCATED;
	}

	return hr;
}





HRESULT MapWaveInIdToGuid(UINT waveInId, GUID *pGuid, DS_CAP_CREATE dscCreate, DS_CAP_ENUM dscEnum)
{

	HRESULT hr;
	waveInDev WaveIn(waveInId);
	WAVEINCAPS waveInCaps;
	UINT uNumWaveDevs;
	GUID guid = GUID_NULL;
	int nIndex;
	MMRESULT mmr;
	WAVEFORMATEX waveFormat = {WAVE_FORMAT_PCM, 1, 8000, 16000, 2, 16, 0};
	IDirectSoundCapture *pDSC=NULL;

	*pGuid = GUID_NULL;

	// only one wave device, take the easy way out
	uNumWaveDevs = waveInGetNumDevs();

	if ((uNumWaveDevs <= 1) || (waveInId == WAVE_MAPPER))
	{
		return S_OK;
	}

	// more than one wavein device
	// try to use the IKSProperty interface to map a WaveIN ID to
	// DirectSoundCaptureGuid
	// Win98 and Windows 2000 only.  (Probably will fail on Win95)

	mmr = waveInGetDevCaps(waveInId, &waveInCaps, sizeof(WAVEINCAPS));
	if (mmr == MMSYSERR_NOERROR)
	{
		hr = DsprvGetWaveDeviceMapping(waveInCaps.szPname, TRUE, &guid);
		if (SUCCEEDED(hr))
		{
			*pGuid = guid;
			return S_OK;
		}
	}


	// Use the old way to map devices

	ZeroMemory(guidList_DSC, sizeof(guidList_DSC));
	nGList_DSC = 0;


	hr = dscEnum((LPDSENUMCALLBACK)DSEnumCallback, NULL);
	if (hr != DS_OK)
	{
		WARNING_OUT(("DirectSoundCaptureEnumerate failed\n"));
		return hr;
	}



	//  hack approach to mapping the device to a guid
	mmr = WaveIn.Open(waveFormat.nSamplesPerSec, waveFormat.wBitsPerSample);
	if (mmr != MMSYSERR_NOERROR)
	{
		return S_FALSE;
	}

	// find all the DSC devices that fail to open
	for (nIndex = 0; nIndex < nGList_DSC; nIndex++)
	{
		guidList_DSC[nIndex].fAllocated = FALSE;

		if (guidList_DSC[nIndex].guid == GUID_NULL)
		{
			hr = dscCreate(NULL, &pDSC, NULL);
		}
		else
		{
			hr = dscCreate(&(guidList_DSC[nIndex].guid), &pDSC, NULL);
		}

		if (FAILED(hr))
		{
			guidList_DSC[nIndex].fAllocated = TRUE;
		}
		else
		{
			pDSC->Release();
			pDSC=NULL;
		}
	}

	WaveIn.Close();

	// scan through the list of allocated devices and
	// see which one opens
	for (nIndex = 0; nIndex < nGList_DSC; nIndex++)
	{
		if (guidList_DSC[nIndex].fAllocated)
		{
			if (guidList_DSC[nIndex].guid == GUID_NULL)
			{
				hr = dscCreate(NULL, &pDSC, NULL);
			}
			else
			{
				hr = dscCreate(&(guidList_DSC[nIndex].guid), &pDSC, NULL);
			}
			if (SUCCEEDED(hr))
			{
				// we have a winner
				pDSC->Release();
				pDSC = NULL;
				*pGuid = guidList_DSC[nIndex].guid;
				return S_OK;
			}
		}
	}


	// if we got to this point, it means we failed to map a device
	// just use GUID_NULL and return an error
	return S_FALSE;
}



// This function answers the question:
// we have full duplex and DirectSound, but do we really
// trust it to work well in FD-DS Mode ?  Returns TRUE if so,
// FALSE otherwise.

/*BOOL IsFDDSRecommended(UINT waveInId, UINT waveOutId)
{
	WAVEINCAPS waveInCaps;
	WAVEOUTCAPS waveOutCaps;
	MMRESULT mmr;
	TCHAR szRegKey[30];
	RegEntry re(AUDIODEVCAPS_KEY, HKEY_LOCAL_MACHINE, FALSE);
	LONG lCaps;

	mmr = waveInGetDevCaps(waveInId, &waveInCaps, sizeof(waveInCaps));
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	mmr = waveOutGetDevCaps(waveOutId, &waveOutCaps, sizeof(waveOutCaps));
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	// assume that if the two devices are made by different manufacturers
	// then DirectSound can always be enabled (because it's two serpate devices)
	if (waveInCaps.wMid != waveOutCaps.wMid)
	{
		return TRUE;
	}


	// does a key for this specific product exist
	wsprintf(szRegKey, "Dev-%d-%d", waveInCaps.wMid, waveInCaps.wPid);
	lCaps = re.GetNumber(szRegKey, -1);

	if (lCaps == -1)
	{
		// maybe we have a string for all of the products
		// by this manufacturer
		wsprintf(szRegKey, "Dev-%d", waveInCaps.wMid);
		lCaps = re.GetNumber(szRegKey, -1);
	}

	if (lCaps == -1)
	{
		// it's an unknown device, we can't trust it to be
		// full duplex - direct sound
		return FALSE;
	}

	
	// examine this devices caps
	if (lCaps & DEVCAPS_AUDIO_FDDS)
	{
		return TRUE;
	}

	return FALSE;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\enumvar.h ===
/*++ 
 
Copyright (c) 1996 Microsoft Corporation 
 
Module Name: 
 
    CEnumVar.h 
 
Abstract: 
 
Author: 
 
Environment: 
 
    User mode 
 
Revision History : 
 
--*/ 
#ifndef _CENUMVAR_H_ 
#define _CENUMVAR_H_ 
 
class FAR CEnumVariant : public IEnumVARIANT 
{ 
public: 
    // IUnknown methods 
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj) ; 
    STDMETHOD_(ULONG, AddRef)() ; 
    STDMETHOD_(ULONG, Release)() ; 
 
    // IEnumVARIANT methods 
    STDMETHOD(Next)(ULONG cElements, 
                    VARIANT FAR* pvar, 
                    ULONG FAR* pcElementFetched); 
    STDMETHOD(Skip)(ULONG cElements); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum); 
 
    CEnumVariant(); 
    ~CEnumVariant(); 
 
	static HRESULT Create(SAFEARRAY FAR* psa, ULONG cElements, CEnumVariant** ppenumvariant);


private: 
    ULONG m_cRef; 

    ULONG m_cElements;
    long m_lLBound;
    long m_lCurrent;
	SAFEARRAY* m_psa;

}; 
 
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\enumvar.cpp ===
/************************************************************************* 
** 
**  This is a part of the Microsoft Source Code Samples. 
** 
**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. 
** 
**  This source code is only intended as a supplement to Microsoft Development 
**  Tools and/or WinHelp documentation.  See these sources for detailed 
**  information regarding the Microsoft samples programs. 
** 
**  OLE Automation TypeLibrary Browse Helper Sample 
** 
**  enumvar.cpp 
** 
**  CEnumVariant implementation 
** 
**  Written by Microsoft Product Support Services, Windows Developer Support 
** 
*************************************************************************/ 

#include <windows.h> 
#include "precomp.h"
#include "Enumvar.h"   
 
/* 
 * CEnumVariant::Create 
 * 
 * Purpose: 
 *  Creates an instance of the IEnumVARIANT enumerator object and initializes it. 
 * 
 * Parameters: 
 *  psa        Safe array containing items to be enumerated. 
 *  cElements  Number of items to be enumerated.  
 *  ppenumvariant    Returns enumerator object. 
 * 
 * Return Value: 
 *  HRESULT 
 * 
 */ 
//static 
HRESULT  
CEnumVariant::Create(SAFEARRAY FAR* psa, ULONG cElements, CEnumVariant** ppenumvariant)  
{    
    HRESULT hr; 
    CEnumVariant FAR* penumvariant = NULL; 
    long lLBound; 
                       
    *ppenumvariant = NULL; 
     
    penumvariant = new CEnumVariant(); 
    if (penumvariant == NULL) 
        goto error;  
         
    penumvariant->m_cRef = 0; 
     
    // Copy elements into safe array that is used in enumerator implemenatation and  
    // initialize state of enumerator. 
    hr = SafeArrayGetLBound(psa, 1, &lLBound); 
    if (FAILED(hr)) 
        goto error; 
    penumvariant->m_cElements = cElements;     
    penumvariant->m_lLBound = lLBound; 
    penumvariant->m_lCurrent = lLBound;                   
    hr = SafeArrayCopy(psa, &penumvariant->m_psa); 
    if (FAILED(hr)) 
       goto error; 
     
    *ppenumvariant = penumvariant; 
    return NOERROR; 
     
error:  
    if (penumvariant == NULL) 
        return E_OUTOFMEMORY;    
                               
    if (penumvariant->m_psa)  
        SafeArrayDestroy(penumvariant->m_psa);    
    penumvariant->m_psa = NULL;      
    delete penumvariant; 
    return hr; 
} 
 
/* 
 * CEnumVariant::CEnumVariant 
 * 
 * Purpose: 
 *  Constructor for CEnumVariant object. Initializes members to NULL. 
 * 
 */ 
CEnumVariant::CEnumVariant() 
{     
    m_psa = NULL; 
} 
 
/* 
 * CEnumVariant::~CEnumVariant 
 * 
 * Purpose: 
 *  Destructor for CEnumVariant object.  
 * 
 */ 
CEnumVariant::~CEnumVariant() 
{                    
    if (m_psa) SafeArrayDestroy(m_psa); 
} 
 
/* 
 * CEnumVariant::QueryInterface, AddRef, Release 
 * 
 * Purpose: 
 *  Implements IUnknown::QueryInterface, AddRef, Release 
 * 
 */ 
STDMETHODIMP 
CEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)  
{    
    *ppv = NULL; 
         
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)  
        *ppv = this;      
    else return E_NOINTERFACE;  
 
    AddRef(); 
    return NOERROR;     
} 
 
 
STDMETHODIMP_(ULONG) 
CEnumVariant::AddRef(void) 
{ 
 
#ifdef _DEBUG    
    TCHAR ach[50]; 
    wsprintf(ach, TEXT("Ref = %ld, Enum\r\n"), m_cRef+1);  
    TRACE_OUT((ach));
#endif   
     
    return ++m_cRef;  // AddRef Application Object if enumerator will outlive application object 
} 
 
 
STDMETHODIMP_(ULONG) 
CEnumVariant::Release(void) 
{ 
 
#ifdef _DEBUG    
    TCHAR ach[50]; 
    wsprintf(ach, TEXT("Ref = %ld, Enum\r\n"), m_cRef-1);  
    TRACE_OUT((ach));
#endif   
     
    if(--m_cRef == 0) 
    { 
        delete this; 
        return 0; 
    } 
    return m_cRef; 
} 
 
/* 
 * CEnumVariant::Next 
 * 
 * Purpose: 
 *  Retrieves the next cElements elements. Implements IEnumVARIANT::Next.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched) 
{  
    HRESULT hr; 
    ULONG l; 
    long l1; 
    ULONG l2; 
     
    if (pcElementFetched != NULL) 
        *pcElementFetched = 0; 
         
    // Retrieve the next cElements elements. 
    for (l1=m_lCurrent, l2=0; l1<(long)(m_lLBound+m_cElements) && l2<cElements; l1++, l2++) 
    { 
       hr = SafeArrayGetElement(m_psa, &l1, &pvar[l2]);  
       if (FAILED(hr)) 
           goto error;  
    } 
    // Set count of elements retrieved 
    if (pcElementFetched != NULL) 
        *pcElementFetched = l2; 
    m_lCurrent = l1; 
     
    return  (l2 < cElements) ? S_FALSE : NOERROR; 
 
error: 
    for (l=0; l<cElements; l++) 
        VariantClear(&pvar[l]); 
    return hr;     
} 
 
/* 
 * CEnumVariant::Skip 
 * 
 * Purpose: 
 *  Skips the next cElements elements. Implements IEnumVARIANT::Skip.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Skip(ULONG cElements) 
{    
    m_lCurrent += cElements;  
    if (m_lCurrent > (long)(m_lLBound+m_cElements)) 
    { 
        m_lCurrent =  m_lLBound+m_cElements; 
        return S_FALSE; 
    }  
    else return NOERROR; 
} 
 
/* 
 * CEnumVariant::Reset 
 * 
 * Purpose: 
 *  Resets the current element in the enumerator to the beginning. Implements IEnumVARIANT::Reset.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Reset() 
{  
    m_lCurrent = m_lLBound; 
    return NOERROR; 
} 
 
/* 
 * CEnumVariant::Clone 
 * 
 * Purpose: 
 *  Creates a copy of the current enumeration state. Implements IEnumVARIANT::Clone.  
 * 
 */ 
STDMETHODIMP 
CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum) 
{ 
    CEnumVariant FAR* penum = NULL; 
    HRESULT hr; 
     
    *ppenum = NULL; 
     
    hr = CEnumVariant::Create(m_psa, m_cElements, &penum); 
    if (FAILED(hr)) 
        goto error;         
    penum->AddRef(); 
    penum->m_lCurrent = m_lCurrent;  
     
    *ppenum = penum;         
    return NOERROR; 
      
error: 
    if (penum) 
        penum->Release(); 
    return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\friends.h ===
/****************************************************************************
*
*    FILE:     Friends.h
*
*    CONTENTS: Friends-Related Utility Function Prototypes
*
****************************************************************************/

#ifndef _FRIENDS_H_
#define _FRIENDS_H_
#include <clink.h>

// Functions:

#endif  // ! _FRIENDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\floatbar.cpp ===
// File: floatbar.cpp

#include "precomp.h"

#include "global.h"
#include "ConfRoom.h"
#include "cmd.h"
#include "FloatBar.h"
#include "resource.h"
#include "ConfPolicies.h"

CFloatToolbar::CFloatToolbar(CConfRoom* pcr):
	m_pConfRoom		(pcr),
	m_hwnd			(NULL),
	m_hwndT			(NULL),
	m_hBmp			(NULL),
    m_fInPopup      (FALSE)
{
	TRACE_OUT(("Constructing CFloatToolbar"));
}

CFloatToolbar::~CFloatToolbar()
{
	TRACE_OUT(("Destructing CFloatToolbar"));

    ASSERT(!m_fInPopup);

	if (NULL != m_hBmp)
	{
		::DeleteObject(m_hBmp);
	}
	
	if (NULL != m_hwnd)
	{
		// bug 1450: don't destroy the window inside the notification,
		// instead, use PostMessage() to insure that we return from the
		// WM_NOTIFY message before the window is destroyed:
		::PostMessage(m_hwnd, WM_CLOSE, 0L, 0L);
		// DestroyWindow(m_hwnd);
	}

}

/****************************************************************************
*
*    CLASS:    CFloatToolbar
*
*    MEMBER:   FloatWndProc(HWND, unsigned, WORD, LONG)
*
*    PURPOSE:
*
****************************************************************************/

LRESULT CALLBACK CFloatToolbar::FloatWndProc(
	HWND hWnd,                /* window handle                   */
	UINT message,             /* type of message                 */
	WPARAM wParam,            /* additional information          */
	LPARAM lParam)            /* additional information          */
{
	CFloatToolbar* pft;
	LPCREATESTRUCT lpcs;

	switch (message)
	{
		case WM_CREATE:
		{
			TRACE_OUT(("Float Window created"));
			
			lpcs = (LPCREATESTRUCT) lParam;
			pft = (CFloatToolbar*) lpcs->lpCreateParams;
			ASSERT(pft);
			::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pft);

			const COLORMAP MyColorMap[] =
			{
				{TOOLBAR_MASK_COLOR,		::GetSysColor(COLOR_BTNFACE)},     // bright grey
				{TOOLBAR_HIGHLIGHT_COLOR,	::GetSysColor(COLOR_BTNHIGHLIGHT)},// white
			};
			pft->m_hBmp = ::CreateMappedBitmap(	GetInstanceHandle(),
												IDB_POPUPBAR,
												0,
												(LPCOLORMAP) MyColorMap,
												2);

            CConfRoom *  pcr = GetConfRoom();

            BYTE bASState   = (pcr && pcr->IsSharingAllowed()) ? TBSTATE_ENABLED : 0;
			BYTE bChatState = (pcr && pcr->IsChatAllowed()) ? TBSTATE_ENABLED : 0;
            BYTE bWBState   = (pcr && pcr->IsNewWhiteboardAllowed()) ? TBSTATE_ENABLED : 0;
            BYTE bFTState   = (pcr && pcr->IsFileTransferAllowed()) ? TBSTATE_ENABLED : 0;

			TBBUTTON tbFloatButtonAry[] =
			{
				{ ShareBitmapIndex     , ID_TB_SHARING      , bASState,     TBSTYLE_BUTTON, 0, -1 },
				{ ChatBitmapIndex      , ID_TB_CHAT         , bChatState,   TBSTYLE_BUTTON, 0, -1 },
				{ WhiteboardBitmapIndex, ID_TB_NEWWHITEBOARD, bWBState,     TBSTYLE_BUTTON, 0, -1 },
				{ FTBitmapIndex        , ID_TB_FILETRANSFER , bFTState,     TBSTYLE_BUTTON, 0, -1 },
			} ;

			ASSERT(pft->m_pConfRoom);

			pft->m_hwndT = CreateToolbarEx(hWnd,
										WS_CHILD | WS_VISIBLE | CCS_NODIVIDER |
										TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | CCS_ADJUSTABLE,
										ID_FLOAT_TOOLBAR,
										NUM_FLOATBAR_TOOLBAR_BITMAPS,
										NULL,					// no instance
										(UINT_PTR) pft->m_hBmp,		// bitmap handle
										tbFloatButtonAry,		// buttons
										ARRAY_ELEMENTS(tbFloatButtonAry),
										16, 16,					// button sizes
										16, 16,					// bitmap sizes
										sizeof(TBBUTTON));

			ASSERT(pft->m_hwndT);
			
			// Put buttons in the correct state:
			pft->UpdateButtons();
			
			// Make the toolbar control window active so we can insure we will get a
			// WM_ACTIVATE when the user clicks somewhere off the toolbar
			::SetForegroundWindow(pft->m_hwndT);

			break;
		}

		case WM_ACTIVATE:
		{
			// Click outside the toolbar:
			pft = (CFloatToolbar*) ::GetWindowLongPtr(hWnd, GWLP_USERDATA);

            //
            // Kill the toolbar if we're not in the middle of handling the
            // popup menu with the list of apps to share.  In that case,
            // activation will cancel menu mode and we'll get a chance to
            // kill ourselves after we come back.
            //
            // We don't want to because COMCTL32 will trash our heap.  It
            // can't handle the toolbar window and structure going away
            // while processing a TBN_DROPDOWN notification.  When we return
            // back it will try to use the now-freed window data.
            //
            // Yes, we post ourselves a WM_CLOSE on destroy, but with a
            // message box up or other things, this could easily be
            // processed long before menu processing returns.
            //
			if ((NULL != pft) &&
                (!pft->m_fInPopup) &&
                (NULL != pft->m_hwnd) &&
                (NULL != pft->m_hwndT))
			{
				// NULL out the object pointer:
				::SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
				delete pft;
			}
			break;
		}
		
		case WM_NOTIFY:
		{
			// BUGBUG: Copied from CConfRoom : put this is a central location:
			LPNMHDR pnmh = (LPNMHDR) lParam;
			
			if (TTN_NEEDTEXT == pnmh->code)
			{
				LPTOOLTIPTEXT lpToolTipText = (LPTOOLTIPTEXT)lParam;
				if (0 == (TTF_IDISHWND & lpToolTipText->uFlags))
				{
					lpToolTipText->hinst = ::GetInstanceHandle();
					lpToolTipText->lpszText = (LPTSTR) lpToolTipText->hdr.idFrom;
				}
			}
			break;
		}

		case WM_COMMAND:
		{
			TRACE_OUT(("Float Window command wp=0x%x", wParam));
			
			pft = (CFloatToolbar*) ::GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if (NULL != pft)
			{
                if (NULL != pft->m_pConfRoom)
                {
                    ::PostMessage(pft->m_pConfRoom->GetTopHwnd(), WM_COMMAND,
                        wParam, lParam);
                }

                //
                // If we're in the middle of the popup, don't kill ourself.
                // We wait until the stack unwinds back above.
                //
                if (!pft->m_fInPopup)
                {
    				// Dismiss the floating toolbar window:
	    			// NULL out the object pointer:
		    		::SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
				    delete pft;
                }
			}
			break;
		}

		default:
		{
			return ::DefWindowProc(hWnd, message, wParam, lParam);
		}
	}
	return FALSE;
}

/****************************************************************************
*
*    CLASS:    CFloatToolbar
*
*    MEMBER:   Create(POINT ptClickPos)
*
*    PURPOSE:  Creates a floating toolbar window
*
****************************************************************************/

HWND CFloatToolbar::Create(POINT ptClickPos)
{
	// BUGBUG: move these defines once the size is finalized
	static const int TOOLBAR_WIDTH  = 6 + 23 * NUM_FLOATBAR_STANDARD_TOOLBAR_BUTTONS;
	static const int TOOLBAR_HEIGHT = 6 + 22 * 1;

	HWND hwndDesktop = GetDesktopWindow();
	RECT rctDesktop;

	if (NULL != hwndDesktop)
	{
		if (GetWindowRect(hwndDesktop, &rctDesktop))
		{
			// First attempt will be to center the toolbar horizontally
			// with respect to the mouse position and place it directly
			// above vertically.

			int xPos = ptClickPos.x - (TOOLBAR_WIDTH / 2);
			int yPos = ptClickPos.y - (TOOLBAR_HEIGHT);

			// If we are too high on the screen (the taskbar is probably
			// docked on top), then use the click position as the top of
			// where the toolbar will appear.
			
			if (yPos < 0)
			{
				yPos = ptClickPos.y;
			}

			// Repeat the same logic for the horizontal position
			if (xPos < 0)
			{
				xPos = ptClickPos.x;
			}

			// If the toolbar if off the screen to the right, then right-justify it
			if (xPos > (rctDesktop.right - TOOLBAR_WIDTH))
			{
				xPos = ptClickPos.x - TOOLBAR_WIDTH;
			}

			m_hwnd = CreateWindowEx(WS_EX_PALETTEWINDOW,
									g_szFloatWndClass,
									g_szEmpty,
									WS_POPUP | WS_VISIBLE | WS_DLGFRAME,
									xPos, yPos,
									TOOLBAR_WIDTH, TOOLBAR_HEIGHT,
									NULL,
									NULL,
									_Module.GetModuleInstance(),
									(LPVOID) this);


			return m_hwnd;
		}
	}

	// Something went wrong
	return NULL;
}

/****************************************************************************
*
*    CLASS:    CFloatToolbar
*
*    MEMBER:   UpdateButtons()
*
*    PURPOSE:  Puts the toolbar buttons in their correct state
*
****************************************************************************/

BOOL CFloatToolbar::UpdateButtons()
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\floatbar.h ===
/****************************************************************************
*
*    FILE:     FloatTBar.h
*
*    CREATED:  Chris Pirich (ChrisPi) 7-27-95
*
****************************************************************************/

class CFloatToolbar
{
private:
	enum { 
			IndexShareBtn,
			IndexChatBtn,
			IndexWBBtn,
			IndexFTBtn,
			NUM_FLOATBAR_STANDARD_TOOLBAR_BUTTONS
	};

	enum {
			ShareBitmapIndex,
			WhiteboardBitmapIndex,
			ChatBitmapIndex,
			FTBitmapIndex,
				// This has to be the last index for 
				// the count to be correct...
			NUM_FLOATBAR_TOOLBAR_BITMAPS

	};


	HWND		m_hwndT;
	HBITMAP		m_hBmp;
	CConfRoom*	m_pConfRoom;
    BOOL        m_fInPopup;

	BOOL		UpdateButtons();
public:
	HWND		m_hwnd;

	// Methods:
				CFloatToolbar(CConfRoom* pcr);
				~CFloatToolbar();
	HWND		Create(POINT ptClickPos);
	static LRESULT CALLBACK FloatWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\fthook.h ===
#ifndef __FtHook_h__
#define __FtHook_h__

#include "IMbFt.h"

namespace CFt
{

	// These are per-process/SDK session
HRESULT InitFt();
bool IsFtActive();
HRESULT EnsureLoadFtApplet();
HRESULT StartNewConferenceSession();
void CloseFtApplet();
bool IsMemberInFtSession(T120NodeID gccID);

HRESULT SendFile(LPCSTR pszFileName,
				 T120NodeID gccID,
				 MBFTEVENTHANDLE *phEvent,
				 MBFTFILEHANDLE *phFile);

HRESULT CancelFt(MBFTEVENTHANDLE hEvent, MBFTFILEHANDLE hFile);
HRESULT AcceptFileOffer(MBFT_FILE_OFFER *pOffer, LPCSTR pszRecvFileDir, LPCSTR pszFileName);
HRESULT ShowFtUI();


HRESULT Advise(IMbftEvents* pSink);
HRESULT UnAdvise(IMbftEvents* pSink);

///////////////////////////////////////////////////////////////////////
//

class CFtEvents : public IMbftEvents
{

public:

	// IMbftEvent Interface
	STDMETHOD(OnInitializeComplete)(void);
	STDMETHOD(OnPeerAdded)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnPeerRemoved)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnFileOffer)(MBFT_FILE_OFFER *pOffer);
	STDMETHOD(OnFileProgress)(MBFT_FILE_PROGRESS *pProgress);
	STDMETHOD(OnFileEnd)(MBFTFILEHANDLE hFile);
	STDMETHOD(OnFileError)(MBFT_EVENT_ERROR *pEvent);
	STDMETHOD(OnFileEventEnd)(MBFTEVENTHANDLE hEvent);
	STDMETHOD(OnSessionEnd)(void);
};

}; // end namespace CFt

#endif // __FtHook_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\fthook.cpp ===
#include "precomp.h"
#include "FtHook.h"
#include "NmManager.h"
#include "NmConference.h"
#include "iAppLdr.h"

namespace CFt
{

static CFtEvents*					s_pFtEventsObj = NULL;
static IMbftControl*				s_pMbftControl = NULL;
static bool							s_bInitialized = false;
static CSimpleArray<IMbftEvents*>*	s_pEventSinkArray = NULL;
static CSimpleArray<T120NodeID>*	s_pFtMemberList = NULL;
static HINSTANCE					s_hmsconfft = NULL;

PFNCREATEMBFTOBJECT pfnFT_CreateInterface;

HRESULT InitFt()
{
	pfnFT_CreateInterface = NULL;
	s_pEventSinkArray = new CSimpleArray<IMbftEvents*>;
	s_pFtMemberList = new CSimpleArray<T120NodeID>;
	s_pFtEventsObj = new CFtEvents();
	return (s_pFtEventsObj ? S_OK : E_OUTOFMEMORY);
}

bool IsFtActive()
{
	return s_bInitialized && s_pMbftControl;
}

HRESULT EnsureLoadFtApplet()
{
	HRESULT hr = S_FALSE;

	if(T120_NO_ERROR == ::T120_LoadApplet(APPLET_ID_FT,
										  FALSE,
										  0,    
										  _Module.InitControlMode(),
										  NULL))

	{
		s_bInitialized = true;
		hr = S_OK;
	}

	return hr;
}

HRESULT ShowFtUI()
{
	if(T120_NO_ERROR == ::T120_LoadApplet(APPLET_ID_FT,
										  TRUE,         
										  0,            
										  FALSE,		
										  NULL))		
	{
		s_bInitialized = true;
		return S_OK;
	}
	return E_FAIL;
}

HRESULT StartNewConferenceSession()
{
	HRESULT hr = E_FAIL;
	if(s_bInitialized && !s_pMbftControl)
	{
		if (S_OK == EnsureLoadFtApplet())
		{
			ASSERT (s_hmsconfft == NULL);
			ASSERT (pfnFT_CreateInterface == NULL);

			s_hmsconfft = LoadLibrary(_T("nmft.dll"));
		
			if (s_hmsconfft)
			{
				pfnFT_CreateInterface = (PFNCREATEMBFTOBJECT) GetProcAddress(s_hmsconfft, _T("FT_CreateInterface"));
				if (pfnFT_CreateInterface)
				{
					hr = pfnFT_CreateInterface(&s_pMbftControl, s_pFtEventsObj);
					ASSERT (SUCCEEDED(hr));
					ASSERT (s_pMbftControl);
				}
				FreeLibrary(s_hmsconfft);
			}
			s_hmsconfft = NULL;
			pfnFT_CreateInterface = NULL;
		}
	}

	return hr;
}

void CloseFtApplet()
{
	if(s_pEventSinkArray)
	{
		ASSERT(0 == s_pEventSinkArray->GetSize());
		delete s_pEventSinkArray;
		s_pEventSinkArray = NULL;
	}

	if(s_pFtMemberList)
	{
		delete s_pFtMemberList;
		s_pFtMemberList = NULL;
	}
	if(s_pFtEventsObj)
	{
		delete s_pFtEventsObj;
		s_pFtEventsObj = NULL;
	}

	if(s_bInitialized)
	{
		s_bInitialized = false;
	}
}

bool IsMemberInFtSession(T120NodeID gccID)
{
	if(s_pFtMemberList)		
	{
		return (-1 != s_pFtMemberList->Find(gccID));
	}
	
	return false;
}

HRESULT Advise(IMbftEvents* pSink)
{
	HRESULT hr = EnsureLoadFtApplet();

	if(s_pEventSinkArray)
	{
		ASSERT(-1 == s_pEventSinkArray->Find(pSink));
		s_pEventSinkArray->Add(pSink);
		hr = S_OK;
	}

	return hr;
}

HRESULT UnAdvise(IMbftEvents* pSink)
{
	HRESULT hr = E_UNEXPECTED;
	
	if(s_pEventSinkArray)
	{
		s_pEventSinkArray->Remove(pSink);
		hr = S_OK;
	}

	return hr;
}

HRESULT CancelFt(MBFTEVENTHANDLE hEvent, MBFTFILEHANDLE hFile)
{
	if(s_pMbftControl)
	{
		s_pMbftControl->CancelFt(hEvent, hFile);
		return S_OK;
	}

	return E_FAIL;
}

HRESULT AcceptFileOffer(MBFT_FILE_OFFER *pOffer, LPCSTR pszRecvFileDir, LPCSTR pszFileName)
{
	if(s_pMbftControl)
	{
		return s_pMbftControl->AcceptFileOffer(pOffer, pszRecvFileDir, pszFileName);
	}

	return E_FAIL;
}


HRESULT SendFile(LPCSTR pszFileName,
				 T120NodeID gccID,
				 MBFTEVENTHANDLE *phEvent,
				 MBFTFILEHANDLE *phFile)
{
	if(s_pMbftControl)
	{
		return s_pMbftControl->SendFile(pszFileName, gccID, phEvent, phFile);
	}
	
	return E_FAIL;
}



	// IMbftEvent Interface
STDMETHODIMP CFtEvents::OnInitializeComplete(void)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnInitializeComplete();
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnPeerAdded(MBFT_PEER_INFO *pInfo)
{
	if(s_pFtMemberList)
	{
		if(-1 == s_pFtMemberList->Find(pInfo->NodeID))
		{
			s_pFtMemberList->Add(pInfo->NodeID);
		}
	}

	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnPeerAdded(pInfo);
		}
	}

	return S_OK;
}

STDMETHODIMP CFtEvents::OnPeerRemoved(MBFT_PEER_INFO *pInfo)
{

	if(s_pFtMemberList)
	{
		s_pFtMemberList->Remove(pInfo->NodeID);
	}

	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnPeerRemoved(pInfo);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileOffer(MBFT_FILE_OFFER *pOffer)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileOffer(pOffer);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileProgress(MBFT_FILE_PROGRESS *pProgress)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileProgress(pProgress);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileEnd(MBFTFILEHANDLE hFile)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileEnd(hFile);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileError(MBFT_EVENT_ERROR *pEvent)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileError(pEvent);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnFileEventEnd(MBFTEVENTHANDLE hEvent)
{
	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnFileEventEnd(hEvent);
		}
	}
	return S_OK;
}

STDMETHODIMP CFtEvents::OnSessionEnd(void)
{
	if(s_pFtMemberList)
	{
		s_pFtMemberList->RemoveAll();
	}

	if(s_pEventSinkArray)
	{
		for(int i = 0; i < s_pEventSinkArray->GetSize(); ++i)
		{
			(*s_pEventSinkArray)[i]->OnSessionEnd();
		}
	}

	if(s_pMbftControl)
	{
		s_pMbftControl->ReleaseInterface();
		s_pMbftControl = NULL;
	}

	return S_OK;
}


}; // end namespace CFt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\gal.cpp ===
// File: GAL.cpp

#include "precomp.h"
#include "resource.h"
#include "help_ids.h"

#include "dirutil.h"

#include "GAL.h"
#include "MapiInit.h"
#include "AdLkup.h"
#include <lst.h>



#define NM_INVALID_MAPI_PROPERTY 0

    // Registry Stuff
/* static */ LPCTSTR CGAL::msc_szDefaultILSServerRegKey    = ISAPI_CLIENT_KEY;
/* static */ LPCTSTR CGAL::msc_szDefaultILSServerValue     = REGVAL_SERVERNAME;
/* static */ LPCTSTR CGAL::msc_szNMPolRegKey               = POLICIES_KEY;
/* static */ LPCTSTR CGAL::msc_szNMExchangeAtrValue        = REGVAL_POL_NMADDRPROP;
/* static */ LPCTSTR CGAL::msc_szSMTPADDRESSNAME           = TEXT( "SMTP" );

    // If there is no DISPLAY_NAME or ACCOUNT_NAME, don't display anything
/* static */ LPCTSTR CGAL::msc_szNoDisplayName			= TEXT( "" );
/* static */ LPCTSTR CGAL::msc_szNoEMailName			= TEXT( "" );
/* static */ LPCTSTR CGAL::msc_szNoBusinessTelephoneNum	= TEXT( "" );

// Async stuff - there is only one instance of the GAL thread
/* static */ HINSTANCE CGAL::m_hInstMapi32DLL          = NULL;
/* static */ HANDLE    CGAL::m_hEventEndAsyncThread    = NULL;
/* static */ HANDLE    CGAL::m_hAsyncLogOntoGalThread  = NULL;
/* static */ CGAL::eAsyncLogonState CGAL::m_AsyncLogonState = CGAL::AsyncLogonState_Idle;

/* static */ IAddrBook      * CGAL::m_pAddrBook        = NULL;
/* static */ IMAPITable     * CGAL::m_pContentsTable   = NULL;
/* static */ IMAPIContainer * CGAL::m_pGAL             = NULL;
/* static */ ULONG            CGAL::m_nRows = 0;


static const int _rgIdMenu[] = {
	IDM_DLGCALL_SPEEDDIAL,
	0
};


CGAL::CGAL() :
	CALV(IDS_DLGCALL_GAL, II_GAL, _rgIdMenu, true ),
    m_nBlockSize( DefaultBlockSize ),
    m_MaxCacheSize( DefaultMaxCacheSize ), 
    m_bBeginningBookmarkIsValid( false ),
    m_bEndBookmarkIsValid( false ),
    m_hrGALError( S_OK ),
	m_hWndListView(NULL)
{
	DbgMsg(iZONE_OBJECTS, "CGAL - Constructed(%08X)", this);

	_ResetCache();

	msc_ErrorEntry_NoGAL = CGalEntry();

	if (NULL == m_hInstMapi32DLL)
	{
		WARNING_OUT(("MAPI32.dll was not loaded?"));
		return;
	}

		//////////////////////////////////////////////////////////////////////////////////////////
		// We have to see if the GAL is available.. 
		// this is modified from Q188482 and Q171636
		//////////////////////////////////////////////////////////////////////////////////////////

		// first we have to initialize MAPI for this ( the main ) thread...
	MAPIINIT_0 mi = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS };
	TRACE_OUT(("Initializing MAPI"));
	HRESULT hr = lpfnMAPIInitialize(&mi);
	
	if( SUCCEEDED( hr ) )
	{
		TRACE_OUT(("MAPI Initialized"));

			// We have to get a pointer to the AdminProfile which is basically
			// a manipulator for the mapisvc.inf file that should be on user's computer
		LPPROFADMIN pAdminProfiles = NULL; 
		hr = lpfnMAPIAdminProfiles( 0L, &pAdminProfiles );

		if( SUCCEEDED( hr ) )
		{	ASSERT( pAdminProfiles );

				// Get the profile table to search for the default profile
			LPMAPITABLE pProfTable = NULL;
			hr = pAdminProfiles->GetProfileTable( 0L, &pProfTable );
			if( SUCCEEDED( hr ) )
			{	ASSERT( pProfTable );

					// Set the restriction to search for the default profile			
				SRestriction Restriction;
				SPropValue spv;
				Restriction.rt = RES_PROPERTY;
				Restriction.res.resProperty.relop = RELOP_EQ;
				Restriction.res.resProperty.ulPropTag = PR_DEFAULT_PROFILE;
				Restriction.res.resProperty.lpProp = &spv;
				spv.ulPropTag = PR_DEFAULT_PROFILE;
				spv.Value.b = TRUE;

					// Find the default profile....
				hr = pProfTable->FindRow( &Restriction, BOOKMARK_BEGINNING, 0 );
				if( SUCCEEDED( hr ) )
				{
					// We have a default profile
					LPSRowSet pRow = NULL;
					hr = pProfTable->QueryRows( 1, 0, &pRow );
					if( SUCCEEDED( hr ) )
					{	ASSERT( pRow );

						// The profile table entry really should have only two properties, 
						//  We will simply enumerate the proprtiies instead of hard-coding the
						//  order of the properties ( in case it changes in the future )
						//  PR_DISPLAY_NAME and PR_DEFAULT_PROFILE
						for( UINT iCur = 0; iCur < pRow->aRow->cValues; ++iCur )
						{
								// We are only interested in the PR_DISPLAY_NAME property
							if( pRow->aRow->lpProps[iCur].ulPropTag == PR_DISPLAY_NAME )
							{
									// Now that we have the default profile, we want to get the
									// profile admin interface for this profile

								LPSERVICEADMIN pSvcAdmin = NULL;  // Pointer to IServiceAdmin object
								hr = pAdminProfiles->AdminServices( pRow->aRow->lpProps[iCur].Value.LPSZ,
																	NULL,
																	0L,
																	0L,
																	&pSvcAdmin 
																  );
								
								if( SUCCEEDED( hr ) )
								{ ASSERT( pSvcAdmin );

									LPMAPITABLE pSvcTable = NULL;
									if( SUCCEEDED( hr = pSvcAdmin->GetMsgServiceTable( 0L, &pSvcTable ) ) )
									{	ASSERT( pSvcTable );

										enum {iSvcName, iSvcUID, cptaSvc};
										SizedSPropTagArray (cptaSvc, sptCols) = { cptaSvc,
																			  PR_SERVICE_NAME,
																			  PR_SERVICE_UID };

										Restriction.rt = RES_PROPERTY;
										Restriction.res.resProperty.relop = RELOP_EQ;
										Restriction.res.resProperty.ulPropTag = PR_SERVICE_NAME;
										Restriction.res.resProperty.lpProp = &spv;
										spv.ulPropTag = PR_SERVICE_NAME;
										spv.Value.LPSZ = _T("MSEMS");

										LPSRowSet pRowExch = NULL;
										if ( SUCCEEDED( hr = lpfnHrQueryAllRows( pSvcTable,
																					(LPSPropTagArray)&sptCols,
																					&Restriction,
																					NULL,
																					0,
																					&pRowExch ) ) )
										{
											SetAvailable(TRUE);
											lpfnFreeProws( pRowExch );
											iCur = pRow->aRow->cValues;
										}

										pSvcTable->Release();
										pSvcTable = NULL;
									}

									pSvcAdmin->Release();
									pSvcAdmin = NULL;
								}
							}
						}

						lpfnFreeProws( pRow );
					}
				}

				pProfTable->Release();
				pProfTable = NULL;
			}

			pAdminProfiles->Release();
			pAdminProfiles = NULL;
		}

		lpfnMAPIUninitialize();
	}
	
	m_MaxJumpSize = m_nBlockSize;
}


CGAL::~CGAL()
{   
	// Kill the cache
	_ResetCache();

	DbgMsg(iZONE_OBJECTS, "CGAL - Destroyed(%08X)", this);
}   


// static function to load MAPI32.dll
BOOL CGAL::FLoadMapiFns(void)
{
	if (NULL != m_hInstMapi32DLL)
		return TRUE;

	return LoadMapiFns(&m_hInstMapi32DLL);
}

// static function to unload MAPI32.dll and logoff, if necessary
VOID CGAL::UnloadMapiFns(void)
{
	if (NULL != m_hAsyncLogOntoGalThread)
	{
		TRACE_OUT(("Setting AsyncLogOntoGalThread End Event"));
		ASSERT(NULL != m_hEventEndAsyncThread);
		SetEvent(m_hEventEndAsyncThread);

		WARNING_OUT(("Waiting for AsyncLogOntoGalThread to exit (start)"));
		WaitForSingleObject(m_hAsyncLogOntoGalThread, 30000); // 30 seconds max
		WARNING_OUT(("Waiting for AsyncLogOntoGalThread to exit (end)"));

		CloseHandle(m_hAsyncLogOntoGalThread);
		m_hAsyncLogOntoGalThread = NULL;

		CloseHandle(m_hEventEndAsyncThread);
		m_hEventEndAsyncThread = NULL;
	}

	if (NULL != m_hInstMapi32DLL)
	{
		FreeLibrary(m_hInstMapi32DLL);
		m_hInstMapi32DLL = NULL;
	}
}

/* virtual */ int CGAL::OnListGetImageForItem( int iIndex ) {


    if( !_IsLoggedOn() )
    {
        return II_INVALIDINDEX;
    }

    CGalEntry* pEntry = _GetEntry( iIndex );
    
    if( pEntry->GetDisplayType() == DT_MAILUSER ) { return II_INVALIDINDEX; }

    switch( pEntry->GetDisplayType() ) {
        case DT_DISTLIST:               return II_DISTLIST;
        case DT_FORUM:                  return II_FORUM;
        case DT_AGENT:                  return II_AGENT;
        case DT_ORGANIZATION:           return II_ORGANIZATION;
        case DT_PRIVATE_DISTLIST:       return II_PRIVATE_DISTLIST;
        case DT_REMOTE_MAILUSER:        return II_REMOTE_MAILUSER;

        default:    
            ERROR_OUT(("We have an invalid Display Type"));
            return II_INVALIDINDEX;
    }

	return II_INVALIDINDEX;

}


/* virtual */ bool CGAL::IsItemBold( int index ) {


    if( !_IsLoggedOn() )
    {
        return false;
    }

    CGalEntry* pEntry = _GetEntry( index );

    switch( pEntry->GetDisplayType() ) {
        case DT_DISTLIST:               
        case DT_PRIVATE_DISTLIST:       
            return true;
        
        case DT_MAILUSER:
        case DT_FORUM:                  
        case DT_AGENT:                  
        case DT_ORGANIZATION:           
        case DT_REMOTE_MAILUSER:        
            return false;

        default:
            ERROR_OUT(("Invalid DT in CGAL::IsItemBold"));
            return false;
    }

    return false;

}

HRESULT CGAL::_GetEmailNames( int* pnEmailNames, LPTSTR** ppszEmailNames, int iItem )
{	
	HRESULT hr = S_OK;
	*pnEmailNames = 1;
	*ppszEmailNames = new LPTSTR[1];
	(*ppszEmailNames)[0] = NULL;
		
	CGalEntry* pCurSel = _GetItemFromCache( iItem );
	if( pCurSel )
	{
		(*ppszEmailNames)[0] = PszAlloc( pCurSel->GetEMail() );
	}

	return hr;
}


/* virtual */ RAI * CGAL::GetAddrInfo(void)
{

	RAI* pRai = NULL;


	int iItem = GetSelection();

	if (-1 != iItem) 
	{
		HWND hwnd = GetHwnd();
		LPTSTR* pszPhoneNums = NULL;
		LPTSTR* pszEmailNames = NULL;
		int nPhoneNums = 0;
		int nEmailNames = 0;


		CGalEntry* pCurSel = _GetItemFromCache( iItem );


		if( g_fGkEnabled )
		{
			if( g_bGkPhoneNumberAddressing )
			{
				_GetPhoneNumbers( pCurSel->GetInstanceKey(), &nPhoneNums, &pszPhoneNums );
			}
			else
			{
				_GetEmailNames( &nEmailNames, &pszEmailNames, iItem );
			}
		}
		else
		{ // This is regular call placement mode

			if( g_fGatewayEnabled )
			{
				_GetPhoneNumbers( pCurSel->GetInstanceKey(), &nPhoneNums, &pszPhoneNums );
			}

			nEmailNames = 1;
			pszEmailNames = new LPTSTR[1];
			pszEmailNames[0] = new TCHAR[CCHMAXSZ];
			GetSzAddress( pszEmailNames[0], CCHMAXSZ, iItem );
		}

		if( nPhoneNums || nEmailNames )
		{

			int nItems = nPhoneNums + nEmailNames;
			DWORD cbLen = sizeof(RAI) + sizeof(DWSTR)* nItems;
			pRai = reinterpret_cast<RAI*>(new BYTE[ cbLen ]);
			ZeroMemory(pRai, cbLen);
			pRai->cItems = nItems;


			int iCur = 0;
			lstrcpyn( pRai->szName, pCurSel->GetName(), CCHMAX(pRai->szName) );

				// First copy the e-mail names
			for( int i = 0; i < nEmailNames; i++ )
			{
				DWORD dwAddressType = g_fGkEnabled ? NM_ADDR_ALIAS_ID : NM_ADDR_ULS;
				pRai->rgDwStr[iCur].dw = dwAddressType;
				pRai->rgDwStr[iCur].psz = pszEmailNames[i];
				++iCur;
			}
			delete [] pszEmailNames;

				// Copy the phone numbirs
			for( i = 0; i < nPhoneNums; i++ )
			{
				pRai->rgDwStr[iCur].dw = g_fGkEnabled ? NM_ADDR_ALIAS_E164 : NM_ADDR_H323_GATEWAY;
				pRai->rgDwStr[iCur].psz = pszPhoneNums[i];
				++iCur;
			}
			delete [] pszPhoneNums;
		}

	}

	return pRai;

}


HRESULT CGAL::_GetPhoneNumbers( const SBinary& rEntryID, int* pcPhoneNumbers, LPTSTR** ppszPhoneNums )
{
	
	HRESULT hr = S_OK;

	if( pcPhoneNumbers && ppszPhoneNums )
	{
		*pcPhoneNumbers = 0;
		*ppszPhoneNums = NULL;

		ULONG PhoneNumPropTags[] = {
			PR_BUSINESS_TELEPHONE_NUMBER,
			PR_HOME_TELEPHONE_NUMBER,
			PR_PRIMARY_TELEPHONE_NUMBER,
			PR_BUSINESS2_TELEPHONE_NUMBER,
			PR_CELLULAR_TELEPHONE_NUMBER,
			PR_RADIO_TELEPHONE_NUMBER,
			PR_CAR_TELEPHONE_NUMBER,
			PR_OTHER_TELEPHONE_NUMBER,
			PR_PAGER_TELEPHONE_NUMBER
		};

		BYTE* pb = new BYTE[ sizeof( SPropTagArray ) + sizeof( ULONG ) * ARRAY_ELEMENTS(PhoneNumPropTags) ];

		if( pb )
		{
			SPropTagArray* pta = reinterpret_cast<SPropTagArray*>(pb);

			pta->cValues = ARRAY_ELEMENTS(PhoneNumPropTags);

			for( UINT iCur = 0; iCur < pta->cValues; iCur++ )
			{
				pta->aulPropTag[iCur] = PhoneNumPropTags[iCur];
			}

			hr = m_pContentsTable->SetColumns(pta, TBL_BATCH);
			if (SUCCEEDED(hr))
			{
				if( SUCCEEDED( hr = _SetCursorTo( rEntryID ) ) )
				{
					LPSRowSet   pRow;
							// Get the item from the GAL
					if ( SUCCEEDED ( hr = m_pContentsTable->QueryRows( 1, TBL_NOADVANCE, &pRow ) ) ) 
					{
						lst<LPTSTR> PhoneNums;

						// First we have to find out how many nums there are
						for( UINT iCur = 0; iCur < pRow->aRow->cValues; ++iCur )
						{
							if( LOWORD( pRow->aRow->lpProps[iCur].ulPropTag ) != PT_ERROR )
							{
								TCHAR szExtractedAddress[CCHMAXSZ];

								DWORD dwAddrType = g_fGkEnabled ? NM_ADDR_ALIAS_E164 : NM_ADDR_H323_GATEWAY;
								
								ExtractAddress( dwAddrType, 
#ifdef UNICODE
												pRow->aRow->lpProps[iCur].Value.lpszW, 
#else
												pRow->aRow->lpProps[iCur].Value.lpszA, 
#endif // UNICODE
												szExtractedAddress, 
												CCHMAX(szExtractedAddress) 
											  );


								if( IsValidAddress( dwAddrType, szExtractedAddress ) )
								{
									++(*pcPhoneNumbers);
									PhoneNums.push_back(PszAlloc(
#ifdef UNICODE
																	pRow->aRow->lpProps[iCur].Value.lpszW
#else
																	pRow->aRow->lpProps[iCur].Value.lpszA
#endif // UNICODE
																)
													   );
								}
							}
						}
						
						*ppszPhoneNums = new LPTSTR[ PhoneNums.size() ];
						if( *ppszPhoneNums )
						{
							lst<LPTSTR>::iterator I = PhoneNums.begin();
							int iCur = 0;
							while( I != PhoneNums.end() )
							{	
								*ppszPhoneNums[iCur] = *I;
								++iCur, ++I;
							}
						}
						else
						{
							hr = E_OUTOFMEMORY;
						}

						lpfnFreeProws( pRow );
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
			}			

			delete [] pb;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}
	return hr;
}


/* virtual */ void CGAL::OnListCacheHint( int indexFrom, int indexTo ) {

    if( !_IsLoggedOn() )
    {
        return;
    }
//        TRACE_OUT(("OnListCacheHint( %d, %d )", indexFrom, indexTo ));

}


/* virtual */ VOID CGAL::CmdProperties( void ) {

	int iItem = GetSelection();
	if (-1 == iItem) {
		return;
    }


    HRESULT hr;
	HWND hwnd = GetHwnd();

    CGalEntry* pCurSel = _GetItemFromCache( iItem );

    const SBinary& rEntryID = pCurSel->GetEntryID();

    ULONG ulFlags = DIALOG_MODAL;

#ifdef UNICODE
    ulFlags |= MAPI_UNICODE;
#endif // UNICODE

	hr = m_pAddrBook->Details( reinterpret_cast< LPULONG >(  &hwnd ), 
                               NULL, 
                               NULL,
                               rEntryID.cb, 
                               reinterpret_cast< LPENTRYID >( rEntryID.lpb ),
		                       NULL, 
                               NULL, 
                               NULL, 
                               ulFlags
                             );    
}


    // This is called when the Global Address List item is selected from the
    //  combo box in the call dialog
/* virtual */ VOID CGAL::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);
	ListView_SetItemCount(hwnd, 0);
	
	m_hWndListView = hwnd;

	if(SUCCEEDED(m_hrGALError))
	{
		TCHAR szPhoneNumber[CCHMAXSZ];
		if( FLoadString(IDS_PHONENUM, szPhoneNumber, CCHMAX(szPhoneNumber)) )
		{
			LV_COLUMN lvc;
			ClearStruct(&lvc);
			lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
			lvc.pszText = szPhoneNumber;
			lvc.iSubItem = 2;
			ListView_InsertColumn(hwnd, IDI_DLGCALL_PHONENUM, &lvc);
		}

		m_MaxCacheSize = ListView_GetCountPerPage(hwnd) * NUM_LISTVIEW_PAGES_IN_CACHE;
		if (m_MaxCacheSize < m_MaxJumpSize)
		{
			// The cache has to be at least as big as the jump size
			m_MaxCacheSize = m_MaxJumpSize * 2;
		}

		if (!_IsLoggedOn())
		{
			_AsyncLogOntoGAL();
		}
		else 
		{
			_sInitListViewAndGalColumns(hwnd);
		}
	}
}


/*  C L E A R  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ClearItems
    
-------------------------------------------------------------------------*/
VOID CGAL::ClearItems(void)
{
	CALV::ClearItems();

	if( IsWindow(m_hWndListView) )
	{
		ListView_DeleteColumn(m_hWndListView, IDI_DLGCALL_PHONENUM);
	}
	else
	{
		WARNING_OUT(("m_hWndListView is not valid in CGAL::ClearItems"));
	}
}



/*  _  S  I N I T  L I S T  V I E W  A N D  G A L  C O L U M N S  */
/*-------------------------------------------------------------------------
    %%Function: _sInitListViewAndGalColumns
    
-------------------------------------------------------------------------*/
HRESULT CGAL::_sInitListViewAndGalColumns(HWND hwnd)
{
	// Set the GAL columns before we let the listview try to get the data
	struct SPropTagArray_sptCols {
		ULONG cValues;
		ULONG aulPropTag[ NUM_PROPS ];
	} sptCols;

	sptCols.cValues = NUM_PROPS;
	sptCols.aulPropTag[ NAME_PROP_INDEX ]						= PR_DISPLAY_NAME;
	sptCols.aulPropTag[ ACCOUNT_PROP_INDEX ]					= PR_ACCOUNT;
	sptCols.aulPropTag[ INSTANCEKEY_PROP_INDEX ]				= PR_INSTANCE_KEY;
	sptCols.aulPropTag[ ENTRYID_PROP_INDEX ]					= PR_ENTRYID;
	sptCols.aulPropTag[ DISPLAY_TYPE_INDEX ]					= PR_DISPLAY_TYPE;
	sptCols.aulPropTag[ BUSINESS_PHONE_NUM_PROP_INDEX ]			= PR_BUSINESS_TELEPHONE_NUMBER;

	HRESULT hr = m_pContentsTable->SetColumns((LPSPropTagArray) &sptCols, TBL_BATCH);
	if (SUCCEEDED(hr))
	{
		// Get the row count so we can initialize the OWNER DATA ListView
		hr = m_pContentsTable->GetRowCount(0, &m_nRows);
		if (SUCCEEDED(hr))
		{
			// Set the list view size to the number of entries in the GAL
			ListView_SetItemCount(hwnd, m_nRows);
		}
	}

	return hr;
}


/*  _  A S Y N C  L O G  O N T O  G  A  L  */
/*-------------------------------------------------------------------------
    %%Function: _AsyncLogOntoGAL
    
-------------------------------------------------------------------------*/
HRESULT CGAL::_AsyncLogOntoGAL(void)
{

	if ((AsyncLogonState_Idle != m_AsyncLogonState) ||
		(NULL != m_hAsyncLogOntoGalThread))
	{
		return S_FALSE;
	}

	m_AsyncLogonState = AsyncLogonState_LoggingOn;
	ASSERT(NULL == m_hEventEndAsyncThread);
	m_hEventEndAsyncThread = CreateEvent(NULL, TRUE, FALSE, NULL);

	DWORD dwThID;
	TRACE_OUT(("Creating AsyncLogOntoGal Thread"));
	m_hAsyncLogOntoGalThread = CreateThread(NULL, 0, _sAsyncLogOntoGalThreadfn, 
	                                        static_cast< LPVOID >(GetHwnd()), 0, &dwThID);

	if (NULL == m_hAsyncLogOntoGalThread)
	{
		m_AsyncLogonState = AsyncLogonState_Idle;
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

/* static */ DWORD CALLBACK CGAL::_sAsyncLogOntoGalThreadfn(LPVOID pv)
{
	SetBusyCursor(TRUE);
	HRESULT hr = _sAsyncLogOntoGal();
	SetBusyCursor(FALSE);

	if (S_OK == hr)
	{
		TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling _InitListViewAndGalColumns"));
		_sInitListViewAndGalColumns((HWND) pv);

		// This keeps the thread around until we're done
		WaitForSingleObject(m_hEventEndAsyncThread, INFINITE);
	}

	// Clean up in the same thread
	hr = _sAsyncLogoffGal();

	return (DWORD) hr;
}


/* static */ HRESULT CGAL::_sAsyncLogOntoGal(void)
{
	ULONG cbeid = 0L;
	LPENTRYID lpeid = NULL;
	HRESULT hr = S_OK;
	ULONG ulObjType;

	MAPIINIT_0 mi = { MAPI_INIT_VERSION, MAPI_MULTITHREAD_NOTIFICATIONS };

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling MAPIInitialize"));

	hr = lpfnMAPIInitialize(&mi);
	if (FAILED(hr))
		return hr;

    TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling MAPILogonEx"));
    IMAPISession* pMapiSession;
    hr = lpfnMAPILogonEx( NULL, 
                          NULL, 
                          NULL, 
                          MAPI_EXTENDED | MAPI_USE_DEFAULT, 
                          &pMapiSession );
	if (FAILED(hr))
		return hr;

        // Open the main address book
	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling OpenAddressBook"));
	ASSERT(NULL == m_pAddrBook);
	hr = pMapiSession->OpenAddressBook(NULL, NULL, AB_NO_DIALOG, &m_pAddrBook);

	pMapiSession->Release();
	pMapiSession = NULL;

	if (FAILED(hr))
		return hr;

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling HrFindExchangeGlobalAddressList "));
	hr = HrFindExchangeGlobalAddressList(m_pAddrBook, &cbeid, &lpeid);
	if (FAILED(hr))
		return hr;

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling OpenEntry"));
	ASSERT(NULL == m_pGAL);
	hr = m_pAddrBook->OpenEntry(cbeid, lpeid, NULL, MAPI_BEST_ACCESS,
	                            &ulObjType, reinterpret_cast< IUnknown** >( &m_pGAL));
	if (FAILED(hr))
		return hr;

	if (ulObjType != MAPI_ABCONT)
		return GAL_E_GAL_NOT_FOUND;

	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Calling GetContentsTable"));
	ASSERT(NULL == m_pContentsTable);
	hr = m_pGAL->GetContentsTable(0L, &m_pContentsTable);
	if (FAILED(hr))
		return hr;

	m_AsyncLogonState = AsyncLogonState_LoggedOn;

	return hr;
}    
    
/* static */ HRESULT CGAL::_sAsyncLogoffGal(void)
{
	// Free and release all the stuff that we hold onto
	TRACE_OUT(("in _AsyncLogOntoGalThreadfn: Releasing MAPI Interfaces"));

	if (NULL != m_pContentsTable)
	{
		m_pContentsTable->Release();
		m_pContentsTable = NULL;
	}
	if (NULL != m_pAddrBook)
	{
		m_pAddrBook->Release();
		m_pAddrBook = NULL;
	}
	if (NULL != m_pGAL)
	{
		m_pGAL->Release();
		m_pGAL = NULL;
	}

	WARNING_OUT(("in _AsyncLogOntoGalThreadfn: Calling lpfnMAPIUninitialize"));        
	lpfnMAPIUninitialize();

	m_AsyncLogonState = AsyncLogonState_Idle;
	return S_OK;
}



HRESULT CGAL::_SetCursorTo( const CGalEntry& rEntry ) {
    return _SetCursorTo( rEntry.GetInstanceKey() );
}


HRESULT CGAL::_SetCursorTo( LPCTSTR szPartialMatch ) {


        // Find the row that matches the partial String based on the DISPLAY_NAME;
    SRestriction Restriction;
    SPropValue spv;
    Restriction.rt = RES_PROPERTY;
    Restriction.res.resProperty.relop = RELOP_GE;
    Restriction.res.resProperty.lpProp = &spv;
    Restriction.res.resProperty.ulPropTag = PR_DISPLAY_NAME;
    spv.ulPropTag = PR_DISPLAY_NAME;

#ifdef  UNICODE
    spv.Value.lpszW = const_cast< LPTSTR >( szPartialMatch );
#else 
    spv.Value.lpszA = const_cast< LPTSTR >( szPartialMatch );
#endif // UNICODE

        // Find the first row that is lexographically greater than or equal to the search string
    HRESULT hr = m_pContentsTable->FindRow( &Restriction, BOOKMARK_BEGINNING, 0 );
    if( FAILED( hr ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
             // This is not really an error, because we handle it from the calling 
             //   function.  That is, we don't have to set m_hrGALError here...
            return MAPI_E_NOT_FOUND;
        }

        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return GAL_E_QUERYROWS_FAILED;
    }

    return S_OK;
}

HRESULT CGAL::_SetCursorTo( const SBinary& rInstanceKey ) {

    HRESULT hr;

        // there is an exchange reg key, we have to get the user's data from the GAL
    SRestriction Restriction;
    SPropValue spv;

        // Search for the user using the instance key data that is in the CGalEntry for the currently
        //   selected list box item
    Restriction.rt = RES_PROPERTY;
    Restriction.res.resProperty.relop = RELOP_EQ;
    Restriction.res.resProperty.ulPropTag = PR_INSTANCE_KEY;
    Restriction.res.resProperty.lpProp = &spv;

    spv.ulPropTag = PR_INSTANCE_KEY;

        // Get the INSTANCE_KEY from the cache
    spv.Value.bin.cb = rInstanceKey.cb;
    spv.Value.bin.lpb = new byte[ spv.Value.bin.cb ];
    ASSERT( spv.Value.bin.cb );
    memcpy( spv.Value.bin.lpb, rInstanceKey.lpb, spv.Value.bin.cb );

        // find the user in the table...
    hr = m_pContentsTable->FindRow( &Restriction, BOOKMARK_BEGINNING, 0 );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_FINDROW_FAILED;
        delete [] ( spv.Value.bin.lpb );
        return GAL_E_FINDROW_FAILED;
    }

    delete [] ( spv.Value.bin.lpb );
    return S_OK;
}


bool CGAL::_GetSzAddressFromExchangeServer( int iItem, LPTSTR psz, int cchMax ) {
    
    HRESULT hr;

        // In the registry, there may be a key that says what the MAPI attribute
        // is in which the users' ILS server is stored in the GAL... If the 
        // reg key exists, we have to get the property from the GAL
    DWORD dwAttr = _GetExchangeAttribute( );
    bool bExtensionFound = ( NM_INVALID_MAPI_PROPERTY != dwAttr );

        // Re-create the table so that it includes the MAPI property tag found in the EXCHANGE REG ATTRUBITE
    SizedSPropTagArray( 3, sptColsExtensionFound ) = { 3, PR_EMAIL_ADDRESS, PR_ADDRTYPE, PROP_TAG( PT_TSTRING, dwAttr) };
    SizedSPropTagArray( 2, sptColsExtensionNotFound ) = { 2, PR_EMAIL_ADDRESS, PR_ADDRTYPE };
    const int EmailPropertyIndex = 0;
    const int EmailAddressTypePropertyIndex = 1;
    const int ExtensionPropertyIndex = 2;
    
    if( bExtensionFound ) {
        if(FAILED(hr = m_pContentsTable->SetColumns( ( LPSPropTagArray ) &sptColsExtensionFound, TBL_BATCH ) ) ) {
            m_hrGALError = GAL_E_SETCOLUMNS_FAILED;
            return false;
        }
    }
    else {
        if(FAILED(hr = m_pContentsTable->SetColumns( ( LPSPropTagArray ) &sptColsExtensionNotFound, TBL_BATCH ) ) ) {
            m_hrGALError = GAL_E_SETCOLUMNS_FAILED;
            return false;
        }
    }

    if( FAILED( hr = _SetCursorTo( *_GetItemFromCache( iItem ) ) ) ) {
        return false;
    }

    LPSRowSet   pRow;
            // Get the item from the GAL
    if ( SUCCEEDED ( hr = m_pContentsTable->QueryRows( 1, TBL_NOADVANCE, &pRow ) ) ) {
        
        if( bExtensionFound ) {
                // Copy the extension data from the entry if it is there
            if( LOWORD( pRow->aRow->lpProps[ ExtensionPropertyIndex ].ulPropTag ) != PT_ERROR ) {
                TRACE_OUT(("Using custom Exchange data for address"));
                _CopyPropertyString( psz, pRow->aRow->lpProps[ ExtensionPropertyIndex ], cchMax );
                lpfnFreeProws( pRow );
                return true;
            }
        }
            // If the extension was not found in the reg, or if there was no extension data. 
            // use the e-mail address if it is SMTP type...
        if( LOWORD( pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].ulPropTag ) != PT_ERROR ) {
                // Check to see if the address type is SMTP
#ifdef UNICODE
            TRACE_OUT(("Email address %s:%s", pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszW, pRow->aRow->lpProps[ EmailPropertyIndex ].Value.lpszW ));
            if( !lstrcmp( msc_szSMTPADDRESSNAME, pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszW ) ) {
#else
            TRACE_OUT(("Email address %s:%s", pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszA, pRow->aRow->lpProps[ EmailPropertyIndex ].Value.lpszA ));
            if( !lstrcmp( msc_szSMTPADDRESSNAME, pRow->aRow->lpProps[ EmailAddressTypePropertyIndex ].Value.lpszA ) ) {     
#endif // UNICODE
                TRACE_OUT(("Using SMTP E-mail as address"));
                if( LOWORD( pRow->aRow->lpProps[ EmailPropertyIndex ].ulPropTag ) != PT_ERROR ) {
                    FGetDefaultServer( psz, cchMax - 1 );
                    int ServerPrefixLen = lstrlen( psz );
                    psz[ ServerPrefixLen ] = TEXT( '/' );
                    ++ServerPrefixLen;
                    ASSERT( ServerPrefixLen < cchMax );
                    _CopyPropertyString( psz + ServerPrefixLen, pRow->aRow->lpProps[ EmailPropertyIndex ], cchMax - ServerPrefixLen );
                    lpfnFreeProws( pRow );
                    return true;
                }
            }
        }

        lpfnFreeProws( pRow );
    }
    else {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return false;
    }

        // This means that we did not find the data on the server
    return false;
}


void CGAL::_CopyPropertyString( LPTSTR psz, SPropValue& rProp, int cchMax ) {

#ifdef  UNICODE    
    lstrcpyn( psz, rProp.Value.lpszW, cchMax );
#else
    lstrcpyn( psz, rProp.Value.lpszA, cchMax );
#endif // UNICODE

}


    // When the user selects CALL, we have to
    // Create an address for them to callto://

BOOL CGAL::GetSzAddress(LPTSTR psz, int cchMax, int iItem)
{
	// try and get the data from the exchange server as per the spec...
	if (_GetSzAddressFromExchangeServer(iItem, psz, cchMax))
	{
		TRACE_OUT(("CGAL::GetSzAddress() returning address [%s]", psz));                    
		return TRUE;
	}


	// If the data is not on the server, we are going to create the address in the format
	//      <default_server>/<PR_ACCOUNT string>        
	if (!FGetDefaultServer(psz, cchMax - 1))
		return FALSE;

	// Because the syntax is callto:<servername>/<username> 
	// we have to put in the forward-slash
	int cch = lstrlen(psz);
	psz[cch++] = '/';
	psz += cch;
	cchMax -= cch;

	// There was no data on the server for us, so we will just use the PR_ACCOUNT data that we have cached
	return CALV::GetSzData(psz, cchMax, iItem, IDI_DLGCALL_ADDRESS);
}



    // When the user types in a search string ( partial match string ) in the edit box
    //  above the ListView, we want to show them the entries starting with the given string
ULONG CGAL::OnListFindItem( LPCTSTR szPartialMatchingString ) {

    if( !_IsLoggedOn() )
    {
        return 0;
    }

        // If we have such an item cached, return the index to it
    int index;
    if( -1 != (  index = _FindItemInCache( szPartialMatchingString ) ) ) {
        return index;
    }
        // if the edit box is empty ( NULL string ), then we know to return item 0
    if( szPartialMatchingString[ 0 ] == '\0' ) {
        return 0;
    }
    
    HRESULT hr;
    if( FAILED( hr = _SetCursorTo( szPartialMatchingString ) ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
            return m_nRows - 1;
        }
        return 0;
    }


        // We have to find the row number of the cursor where the partial match is...
    ULONG ulRow, ulPositionNumerator, ulPositionDenominator;
    m_pContentsTable->QueryPosition( &ulRow, &ulPositionNumerator, &ulPositionDenominator );
    if( ulRow == 0xFFFFFFFF  ) {
        // If QueryPosition is unable to determine the ROW, it will return the row based on the
        //     fraction ulPositionNumerator/ulPositionDenominator
        ulRow = MulDiv( m_nRows, ulPositionNumerator, ulPositionDenominator );
    }

        // Kill the cache, becasue we are jumping to a new block of data
        //  We do this because the _FindItemInCache call above failed to
        //  return the desired item...
    _ResetCache();        
    m_IndexOfFirstItemInCache = ulRow;
    m_IndexOfLastItemInCache = ulRow - 1;
        
    // Jump back a few, so we can cache some entries before the one we are looking for
    long lJumped;
    hr = m_pContentsTable->SeekRow( BOOKMARK_CURRENT, -( m_nBlockSize / 2 ), &lJumped );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_SEEKROW_FAILED;
        return 0;
    }

        // We hawe to change the sign of lJumped because we are jumping backwards
    lJumped *= -1;

    // Set the begin bookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
    ASSERT( SUCCEEDED( hr ) );
    m_bBeginningBookmarkIsValid = true;

    // Read in a block of rows
    LPSRowSet pRow = NULL;
    hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return 0;
    }

        // For each item in the block

        // This should always be the case,
        // but we vant to make sure that we have enough rows to get to the
        // item that we are looking for...
    ASSERT( pRow->cRows >= static_cast< ULONG >( lJumped ) );

    for( ULONG i = 0; i < pRow->cRows; i++ ) {
        
        CGalEntry* pEntry;

        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) { 
            lpfnFreeProws( pRow );
            return 0;
        }
                    
        if( 0 == lJumped ) {
            ulRow = m_IndexOfLastItemInCache + 1;
        }

        --lJumped;

        m_EntryCache.push_back( pEntry );
        m_IndexOfLastItemInCache++;
    }

    lpfnFreeProws( pRow );

    // Set the end bookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return 0;
    }

    m_bEndBookmarkIsValid = true;

    VERIFYCACHE

    return ulRow;
}


    // This is called by the ListView Notification handler.  Because the ListView is OWNERDATA
    //  it has to ask us every time it needs the string data for the columns...
void CGAL::OnListGetColumn1Data( int iItemIndex, int cchTextMax, LPTSTR szBuf ) {

    if( !_IsLoggedOn() )
    {
        lstrcpyn( szBuf, g_cszEmpty, cchTextMax );
    }
    else 
    {
        LPCTSTR pszName = _GetEntry( iItemIndex )->GetName();
        if( NULL == pszName ) 
        {
            pszName = g_cszEmpty;
        }
        lstrcpyn( szBuf, pszName, cchTextMax );
    }
}

    // This is called by the ListView Notification handler.  Because the ListView is OWNERDATA
    //  it has to ask us every time it needs the string data for the columns...
void CGAL::OnListGetColumn2Data( int iItemIndex, int cchTextMax, LPTSTR szBuf ) {
    if( !_IsLoggedOn() )
    {
        lstrcpyn( szBuf, g_cszEmpty, cchTextMax );
    }
    else {

        LPCTSTR pszEMail = _GetEntry( iItemIndex )->GetEMail();
        if( NULL == pszEMail ) 
        {
            pszEMail = g_cszEmpty;
        }

        lstrcpyn( szBuf, pszEMail, cchTextMax );
    }
}

    // This is called by the ListView Notification handler.  Because the ListView is OWNERDATA
    //  it has to ask us every time it needs the string data for the columns...
void CGAL::OnListGetColumn3Data( int iItemIndex, int cchTextMax, LPTSTR szBuf ) {
    if( !_IsLoggedOn() )
    {
        lstrcpyn( szBuf, g_cszEmpty, cchTextMax );
    }
    else {
		
		lstrcpyn( szBuf, g_cszEmpty, cchTextMax );

        LPCTSTR pszBusinessTelephone = _GetEntry( iItemIndex )->GetBusinessTelephone();
        if( NULL == pszBusinessTelephone ) 
        {
            pszBusinessTelephone = g_cszEmpty;
        }
        lstrcpyn( szBuf, pszBusinessTelephone, cchTextMax );
    }
}


    // When the user types in a search string in the edit box, we first check to see if there is an
    //  item in the cache that satisfys the partial search criteria
int CGAL::_FindItemInCache( LPCTSTR szPartialMatchString ) {

    if( m_EntryCache.size() == 0 ) { return -1; }
    if( ( *( m_EntryCache.front() ) <= szPartialMatchString ) && ( *( m_EntryCache.back() ) >= szPartialMatchString ) ) {
        int index = m_IndexOfFirstItemInCache;
        lst< CGalEntry* >::iterator I = m_EntryCache.begin();
        while( ( *( *I ) ) < szPartialMatchString ) {
            ++I;
            ++index;
        }
        return index;
    }

    return -1;
}

    // _GetEntry returns a reference to the desired entry.  If the entry is in the cache, it retrieves it, and if
    //  it is not in the cache, it loads it from the GAL and saves it in the cache
CGAL::CGalEntry* CGAL::_GetEntry( int index )
{
	CGalEntry* pRet = &msc_ErrorEntry_NoGAL;

	if (!_IsLoggedOn() || FAILED(m_hrGALError))
	{
	//   rRet = msc_ErrorEntry_NoGAL;
	}
        // If the entry is in the cache, return it
    else if( ( index >= m_IndexOfFirstItemInCache ) && ( index <= m_IndexOfLastItemInCache ) ) {
        pRet = _GetItemFromCache( index );        
    }
    else if( m_EntryCache.size() == 0 ) {
        // If the cache is empty, LongJump
        // Do a long jump to index, reset the cached data and return the item at index
        pRet = _LongJumpTo( index );
    }
    else if( ( index < m_IndexOfFirstItemInCache ) && ( ( m_IndexOfFirstItemInCache - index  ) <= m_MaxJumpSize ) ) {
        // If index is less than the first index by less than m_MaxJumSize
        // Fill in the entries below the first index and return the item at _index_
        pRet = _GetEntriesAtBeginningOfList( index );
    }
    else if( ( index > m_IndexOfLastItemInCache ) && ( ( index - m_IndexOfLastItemInCache ) <= m_MaxJumpSize ) ) {
        // else if index is greater than the last index by less than m_MaxJumpSize
        // Fill in the entries above the last index and return the item at _index_
        pRet = _GetEntriesAtEndOfList( index );
    }
    else {
        // Do a long jump to index, reset the cached data and return the item at index
        pRet = _LongJumpTo( index );
    }

    return pRet;
}



    // If the ListView needs an item that is far enough away from the current cache block to require a 
    //   new cache block, this function in called.  The cache is destroyed and a new cache block is 
    //   created at the longjump item's index
CGAL::CGalEntry* CGAL::_LongJumpTo( int index ) {

    HRESULT hr;

        // first we have to kill the cache and free the old bookmarks because they will no longer be valid...
    _ResetCache();

        // Seek approximately to the spot that we are looking for...    
    int CacheIndex = index;
    int Offset = m_nBlockSize / 2;

    if( CacheIndex < Offset ) {
        CacheIndex = 0;
    }
    else {
        CacheIndex -= Offset;
    }

    hr = m_pContentsTable->SeekRowApprox( CacheIndex, m_nRows );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_SEEKROWAPPROX_FAILED;
        return &msc_ErrorEntry_SeekRowApproxFailed;
    }

    m_IndexOfFirstItemInCache = CacheIndex;
    m_IndexOfLastItemInCache = m_IndexOfFirstItemInCache - 1;

    // Set the beginningBookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return &msc_ErrorEntry_CreateBookmarkFailed;
    }

    m_bBeginningBookmarkIsValid = true;

    lst< CGalEntry* >::iterator IRet = m_EntryCache.end();


    // Get a block of rows
    LPSRowSet   pRow = NULL;
    hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return &msc_ErrorEntry_QueryRowsFailed;
    }

        // For each item in the block
    for( ULONG i = 0; i < pRow->cRows; i++ ) {

        CGalEntry* pEntry;
        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) { 
            lpfnFreeProws( pRow );
            return &msc_ErrorEntry_NoInstanceKeyFound; 
        }

        m_EntryCache.push_back( pEntry );

            // if the current item is equal to the first item in our list, we are done
        m_IndexOfLastItemInCache++;
        if( m_IndexOfLastItemInCache == index ) {
            IRet = --( m_EntryCache.end() ); 
        }
    }


    if( IRet == m_EntryCache.end() ) {
        // There is a small chance that this could happen
        // if there were problems on the server.
        WARNING_OUT(("In CGAL::_LongJumpTo(...) QueryRows only returned %u items", pRow->cRows ));
        WARNING_OUT(("\tm_IndexOfFirstItemInCache = %u, m_IndexOfLastItemInCache = %u, index = %u", m_IndexOfFirstItemInCache, m_IndexOfLastItemInCache, index ));
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return &msc_ErrorEntry_QueryRowsFailed;
    }

    lpfnFreeProws( pRow );

    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );

    // Set the beginningBookmark
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return &msc_ErrorEntry_CreateBookmarkFailed;
    }
    m_bEndBookmarkIsValid = true;

    VERIFYCACHE

    return *IRet;
}


    // If the user is scrolling backwards and comes to an index whose data is not in the cache, we hawe
    //  to get some entries at the beginning of the list... We will start at a position somewhat before the
    //  first item's index  and keep getting items from the GAL until we have all the items up to the first item
    //  in the list.  We continue to jump back a little and get items to the beginning of the list until we have
    //  cached the requested index.  Because we have the item handy, we will return it
CGAL::CGalEntry* CGAL::_GetEntriesAtBeginningOfList( int index ) {
        
    HRESULT hr;
        
        // The beginning bookmark may not be valid, because the user may have been scrolling forward
        //  and because the cache is kept at a constant size, the item at the front bookmark may have
        //  been removed from the cache.  If this is the case, we have to re-create the front bookmark
    if( !m_bBeginningBookmarkIsValid ) {
        if( _CreateBeginningBookmark() ) {
                // This means that the listView needs to be update 
            ListView_RedrawItems( GetHwnd(), 0, m_nRows );
            return &msc_ErrorEntry_FindRowFailed;
        }
    }

    // Seek row to the beginning bookmark -m_nBlockSize items
    long lJumped;
    hr = m_pContentsTable->SeekRow( m_BookmarkOfFirstItemInCache, -m_nBlockSize, &lJumped );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_SEEKROW_FAILED;
        return &msc_ErrorEntry_SeekRowFailed;
    }

    lJumped *= -1; // We have to change the sign on this number ( which will be negative )

    ASSERT( SUCCEEDED( hr ) );

    if( 0 == lJumped ) {
        // We are at the beginning of the list
        m_IndexOfLastItemInCache -= m_IndexOfFirstItemInCache;
        m_IndexOfFirstItemInCache = 0;
    }
    else {
        // Free the beginningBookmark
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfFirstItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return &msc_ErrorEntry_FreeBookmarkFailed;
        }

        // Set the beginningBookmark
        hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
            return &msc_ErrorEntry_CreateBookmarkFailed;
        }
    }

    // QueryRow for lJumped items

    lst< CGalEntry* >::iterator IInsertPos = m_EntryCache.begin();

    // Get a block of rows
    LPSRowSet   pRow = NULL;
    hr = m_pContentsTable->QueryRows( lJumped, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return &msc_ErrorEntry_QueryRowsFailed;
    }

        // For each item in the block
    for( ULONG i = 0; i < pRow->cRows; i++ ) {

        CGalEntry* pEntry;

        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) { 
            lpfnFreeProws( pRow );
            return &msc_ErrorEntry_NoInstanceKeyFound; 
        }

        // if the current item is equal to the first item in our list, we are done
        --m_IndexOfFirstItemInCache;
        m_EntryCache.insert( IInsertPos, pEntry );
    }

    VERIFYCACHE

    lpfnFreeProws( pRow );

    if( FAILED( _KillExcessItemsFromBackOfCache() ) ) {
            // THis ist the only thing that can fail in _KillExcessItemsFromBackOfCache
        return &msc_ErrorEntry_FreeBookmarkFailed;
    }

    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );
           
    // return the item corresponding to the index
    return _GetItemFromCache( index );
}


HRESULT CGAL::_KillExcessItemsFromBackOfCache( void ) {

    // if the cache size is greater than m_MaxCacheSize
    if( m_EntryCache.size() > static_cast< size_t >( m_MaxCacheSize ) ) {
        // kill as many as we need to from the front of the list, fixing m_IndexOfFirstItemInCache
        int NumItemsToKill = ( m_EntryCache.size() - m_MaxCacheSize );
        while( NumItemsToKill-- ) {
            delete m_EntryCache.back();
            m_EntryCache.erase( --( m_EntryCache.end() ) );
            --m_IndexOfLastItemInCache;
        }

        // Free the beginning bookmark
        if( m_bEndBookmarkIsValid ) {
            // flag the front bookmark as invalid
            m_bEndBookmarkIsValid = false;
            HRESULT hr = m_pContentsTable->FreeBookmark( m_BookmarkOfItemAfterLastItemInCache );       
            if( FAILED( hr ) ) {
                m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
                return m_hrGALError;
            }
        }
    }
       
    return S_OK;
}


// In certain circumstances _CreateBeginningBookmark will return TRUE to indicate that the listView needs to be updated...
bool CGAL::_CreateBeginningBookmark( void ) {

    HRESULT hr;
    bool bRet = false;

    if( FAILED( hr = _SetCursorTo( *m_EntryCache.front() ) ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
                // The item is not in the table anymore. We have to
            _LongJumpTo( m_IndexOfFirstItemInCache );            
            return true;
        }
        else {
            m_hrGALError = GAL_E_FINDROW_FAILED;
            return false;
        }
    }

    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfFirstItemInCache );
    m_bBeginningBookmarkIsValid = true;
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return false;
    }

    return false;
}


// ruturn true if the item at IEntry is the item requested at index
bool CGAL::_CreateEndBookmark( int index, lst< CGalEntry* >::iterator& IEntry ) {

    HRESULT hr;
    bool bRet = false;
    IEntry = m_EntryCache.end();

    hr = _SetCursorTo( *m_EntryCache.back() );
    if( FAILED( hr ) ) {



    }
    if( FAILED( hr ) ) {
        if( MAPI_E_NOT_FOUND == hr ) {
                // This means that the listView needs to be update 
            ListView_RedrawItems( GetHwnd(), 0, m_nRows );
            IEntry = m_EntryCache.end();
            return true;
        }
        else {
            m_hrGALError = GAL_E_FINDROW_FAILED;
            return false;
        }
    }

    // Get a block of entries
    LPSRowSet   pRow = NULL;

        // Get a bunch of rows
    hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );

    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_QUERYROWS_FAILED;
        return false;
    }
    
    // If no entries are returned, this means that we have hit the end of the list
    if( 0 == ( pRow->cRows )  ) { 
        hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
            return true;
        }

        m_bEndBookmarkIsValid = true;

        IEntry = --( m_EntryCache.end() );
        return true;
    }

    // Verify that the first entry is the last item in our list
    ASSERT( 0 == memcmp( pRow->aRow[ 0 ].lpProps[ INSTANCEKEY_PROP_INDEX ].Value.bin.lpb, m_EntryCache.back()->GetInstanceKey().lpb, pRow->aRow[ 0 ].lpProps[ INSTANCEKEY_PROP_INDEX ].Value.bin.cb ) );
    
        // for each entry returned
    for( ULONG i = 1; i < pRow->cRows; i++ ) {

        CGalEntry* pEntry;
        
        if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) {
            lpfnFreeProws( pRow );
            return false;
        }

        // push it to the back of the entry list and increment m_IndexOfLastItemInCache
        m_EntryCache.push_back( pEntry );

        m_IndexOfLastItemInCache++;
        if( m_IndexOfLastItemInCache == index ) {
            bRet = true;
            IEntry = --( m_EntryCache.end() );
        }
    }

    lpfnFreeProws( pRow );

    if( FAILED( _KillExcessItemsFromFrontOfCache() ) ) {
            // This is the only thang that can fail in _KillExcessItemsFromFrontOfCache
        return false;
    }

    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );        

    // Create a bookmark and store it in m_BookmarkOfItemAfterLastItemInCache
    hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
    if( FAILED( hr ) ) {
        m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
        return true;
    }

    m_bEndBookmarkIsValid = true;

    return bRet;
}


    // If the user is scrolling forwards and the ListView requests an item that is a little bit beyond the 
    //  end of the cache, we have to get some more entries...
CGAL::CGalEntry* CGAL::_GetEntriesAtEndOfList( int index ) {
    
    lst< CGalEntry* >::iterator IRet;
    HRESULT hr;        

    // if m_bEndBookmarkIsValid
    if( m_bEndBookmarkIsValid ) {
        // SeekRow to m_BookmarkOfItemAfterLastItemInCache
        hr = m_pContentsTable->SeekRow( m_BookmarkOfItemAfterLastItemInCache, 0, NULL );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_SEEKROW_FAILED;
            return &msc_ErrorEntry_SeekRowFailed;
        }
    }
    else {
        // Set the end bookmark to the item after the last item in the cache
        if( _CreateEndBookmark( index, IRet ) ) {
            if( IRet != m_EntryCache.end() ) {
                VERIFYCACHE     
                return *IRet;
            }
            
            // this means that the end item is no longer in the GAL table
            //  we have to update the list view
            _LongJumpTo( index );
            ListView_RedrawItems( GetHwnd(), 0, m_nRows );
            return &msc_ErrorEntry_FindRowFailed;
        }
    }

    if( index > m_IndexOfLastItemInCache ) {
        // Get a block of entries
        LPSRowSet   pRow = NULL;

            // Get a bunch of rows
        hr = m_pContentsTable->QueryRows( m_nBlockSize, 0, &pRow );
    
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_QUERYROWS_FAILED;
            return &msc_ErrorEntry_QueryRowsFailed;
        }
        
        // If no entries are returned, this means that we have hit the end of the list
        if( 0 == ( pRow->cRows )  ) { 
            return m_EntryCache.back();
        }

            // for each entry returned
        for( ULONG i = 0; i < pRow->cRows; i++ ) {

            CGalEntry* pEntry;  
            if( FAILED( _MakeGalEntry( pRow->aRow[ i ], &pEntry ) ) ) {
                lpfnFreeProws( pRow );
                return &msc_ErrorEntry_NoInstanceKeyFound;
            }

                // push it to the back of the entry list and increment m_IndexOfLastItemInCache
            m_EntryCache.push_back( pEntry );

            m_IndexOfLastItemInCache++;
            // if m_IndexOfLastItemInCache == index, store the iterator for when we return the entry
            if( index == m_IndexOfLastItemInCache ) {
                IRet = --( m_EntryCache.end() );
            }
        }
        lpfnFreeProws( pRow );

        // Free m_BookmarkOfItemAfterLastItemInCache
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfItemAfterLastItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return &msc_ErrorEntry_FreeBookmarkFailed;
        }

        
        // Create a bookmark and store it in m_BookmarkOfItemAfterLastItemInCache
        hr = m_pContentsTable->CreateBookmark( &m_BookmarkOfItemAfterLastItemInCache );
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_CREATEBOOKMARK_FAILED;
            return &msc_ErrorEntry_CreateBookmarkFailed;
        }

        ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );
    } 


    if( FAILED( _KillExcessItemsFromFrontOfCache() ) ) {
            // This is the only thang that can fail in _KillExcessItemsFromFrontOfCache
        return &msc_ErrorEntry_FreeBookmarkFailed;
    }
        
    VERIFYCACHE

    // return the entry
    return *IRet;
}


    // The only thing that can fail is freebookmark, in which case GAL_E_FREEBOOKMARK_FAILED is returned
HRESULT CGAL::_KillExcessItemsFromFrontOfCache( void ) {

    // if the cache size is greater than m_MaxCacheSize
    if( m_EntryCache.size() > static_cast< size_t >( m_MaxCacheSize ) ) {

        // kill as many as we need to from the front of the list, fixing m_IndexOfFirstItemInCache
        int NumItemsToKill = ( m_EntryCache.size() - m_MaxCacheSize );
        while( NumItemsToKill-- ) {
            delete m_EntryCache.front();                
            m_EntryCache.erase( m_EntryCache.begin() );
            ++m_IndexOfFirstItemInCache;
        }


        // flag the front bookmark as invalid
        m_bBeginningBookmarkIsValid = false;
        HRESULT hr = m_pContentsTable->FreeBookmark( m_BookmarkOfFirstItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return GAL_E_FREEBOOKMARK_FAILED;
        }

    }

    return S_OK;
}


    // _GetItemInCache will return an entry from the cache
    //    the cache size should be set to a small enough number that
    //    the fact that we are using a linear search should not be a problem
    //    if we wanted to support a larger cache, another collection class other than a lst class
    //    would be used ( like a tree or a hash table )
CGAL::CGalEntry* CGAL::_GetItemFromCache( int index ) {
    
    ASSERT( ( m_IndexOfLastItemInCache - m_IndexOfFirstItemInCache ) == static_cast< int >( m_EntryCache.size() - 1 ) );
    lst< CGalEntry* >::iterator I = m_EntryCache.begin();
    int i = m_IndexOfFirstItemInCache;
    while( i != index ) {
        ASSERT( I != m_EntryCache.end() );
        ++i, ++I;
    }
    return *I;
}



    // There may be a registry key that stores the mapi property that the user should 
    //   use to find the ils server and username of people that the user calls with the GAL....
    //   If this reg key exists, the MAPI property will be queried when the user presses the CALL button 
    //   in the dialog....
DWORD CGAL::_GetExchangeAttribute( void ) {


    RegEntry re( msc_szNMPolRegKey, HKEY_CURRENT_USER );
    
    return re.GetNumber( msc_szNMExchangeAtrValue, NM_INVALID_MAPI_PROPERTY );
}

void CGAL::_ResetCache( void ) {
    HRESULT hr;

    lst< CGalEntry* >::iterator I = m_EntryCache.begin();
    while( I != m_EntryCache.end() ) {
        delete ( *I );
        I++;
    }
    m_EntryCache.erase( m_EntryCache.begin(), m_EntryCache.end() );
    m_IndexOfFirstItemInCache = INVALID_CACHE_INDEX;
    m_IndexOfLastItemInCache = INVALID_CACHE_INDEX - 1;
    if( m_bBeginningBookmarkIsValid ) {
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfFirstItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return;
        }
    }
    if( m_bEndBookmarkIsValid ) {
        hr = m_pContentsTable->FreeBookmark( m_BookmarkOfItemAfterLastItemInCache );       
        if( FAILED( hr ) ) {
            m_hrGALError = GAL_E_FREEBOOKMARK_FAILED;
            return;
        }
    }
}


    // Create a GAL Entry from a SRow structure returned by QueryRows
    // The username and EMail name may be absent, this is not an error
    // if the INSTANCE_KEY is missing, that would constitute an error
HRESULT CGAL::_MakeGalEntry( SRow& rRow, CGalEntry** ppEntry ) {

    *ppEntry = NULL;

    LPSPropValue lpProps = rRow.lpProps;

    LPCTSTR szName;
    if( LOWORD( lpProps[ NAME_PROP_INDEX ].ulPropTag ) != PT_ERROR ) {

#ifdef  UNICODE
        szName = lpProps[ NAME_PROP_INDEX ].Value.lpszW;        
#else 
        szName = lpProps[ NAME_PROP_INDEX ].Value.lpszA;
#endif // UNICODE
    }
    else {
        szName = msc_szNoDisplayName;
    }

	LPCTSTR szEMail;
    if( LOWORD( lpProps[ ACCOUNT_PROP_INDEX ].ulPropTag ) != PT_ERROR ) {

#ifdef  UNICODE
        szEMail = lpProps[ ACCOUNT_PROP_INDEX ].Value.lpszW;
#else 
        szEMail = lpProps[ ACCOUNT_PROP_INDEX ].Value.lpszA;
#endif // UNICODE

    }
    else {
        szEMail = msc_szNoEMailName;
    }
            
        // Get the instance key    
    if( LOWORD( lpProps[ INSTANCEKEY_PROP_INDEX ].ulPropTag ) == PT_ERROR ) {
        m_hrGALError = GAL_E_NOINSTANCEKEY;
        return m_hrGALError;
    }
    ASSERT( PR_INSTANCE_KEY == lpProps[ INSTANCEKEY_PROP_INDEX ].ulPropTag );        
    SBinary& rInstanceKey = lpProps[ INSTANCEKEY_PROP_INDEX ].Value.bin;

        // Get the entryid    
    if( LOWORD( lpProps[ ENTRYID_PROP_INDEX ].ulPropTag ) == PT_ERROR ) {
        m_hrGALError = GAL_E_NOENTRYID;
        return m_hrGALError;
    }
    ASSERT( PR_ENTRYID == lpProps[ ENTRYID_PROP_INDEX ].ulPropTag );        
    SBinary& rEntryID = lpProps[ ENTRYID_PROP_INDEX ].Value.bin;
    
        // Get the display Type
    ULONG ulDisplayType = DT_MAILUSER;
    if( LOWORD( lpProps[ DISPLAY_TYPE_INDEX ].ulPropTag ) != PT_ERROR ) {
        ulDisplayType = lpProps[ DISPLAY_TYPE_INDEX ].Value.ul;
    }

		// Get the business telephone number
	LPCTSTR szBusinessTelephoneNum;
    if( LOWORD( lpProps[ BUSINESS_PHONE_NUM_PROP_INDEX ].ulPropTag ) != PT_ERROR ) {

#ifdef  UNICODE
        szBusinessTelephoneNum = lpProps[ BUSINESS_PHONE_NUM_PROP_INDEX ].Value.lpszW;
#else 
        szBusinessTelephoneNum = lpProps[ BUSINESS_PHONE_NUM_PROP_INDEX ].Value.lpszA;
#endif // UNICODE

    }
    else {
        szBusinessTelephoneNum = msc_szNoBusinessTelephoneNum;
    }

    *ppEntry = new CGalEntry( szName, szEMail, rInstanceKey, rEntryID, ulDisplayType, szBusinessTelephoneNum );

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

CGAL::CGalEntry::CGalEntry( void )
    : m_szName( NULL ), 
      m_szEMail( NULL ),
      m_ulDisplayType( DT_MAILUSER ),
	  m_szBusinessTelephoneNum(NULL)
{ 
    m_EntryID.cb = 0;
    m_EntryID.lpb = NULL;
    m_InstanceKey.cb = 0;
    m_InstanceKey.lpb = NULL;
}

CGAL::CGalEntry::CGalEntry( const CGalEntry& r ) 
    : m_szName( NULL ), 
      m_szEMail( NULL ),
      m_ulDisplayType( DT_MAILUSER ),
	  m_szBusinessTelephoneNum(NULL)
{ 
    m_EntryID.cb = 0;
    m_EntryID.lpb = NULL;
    m_InstanceKey.cb = 0;
    m_InstanceKey.lpb = NULL;
     *this = r; 
}

CGAL::CGalEntry::CGalEntry( LPCTSTR szName, LPCTSTR szEMail, SBinary& rInstanceKey, SBinary& rEntryID, ULONG ulDisplayType, LPCTSTR szBusinessTelephoneNum  ) 
    : m_ulDisplayType( ulDisplayType )
{
    m_EntryID.cb = rEntryID.cb;
    m_InstanceKey.cb = rInstanceKey.cb;

    if( m_EntryID.cb ) {
        m_EntryID.lpb = new BYTE[ m_EntryID.cb ];
        memcpy( m_EntryID.lpb, rEntryID.lpb, m_EntryID.cb );
    }

    if( m_InstanceKey.cb ) {
        m_InstanceKey.lpb = new BYTE[ m_InstanceKey.cb ];
        memcpy( m_InstanceKey.lpb, rInstanceKey.lpb, m_InstanceKey.cb );
    }

    m_szName = PszAlloc( szName );
    m_szEMail = PszAlloc( szEMail );
	m_szBusinessTelephoneNum = PszAlloc( szBusinessTelephoneNum );
}

CGAL::CGalEntry::CGalEntry( LPCTSTR szName, LPCTSTR szEMail ) 
    : m_ulDisplayType( DT_MAILUSER ),
	  m_szBusinessTelephoneNum(NULL)
{
    m_EntryID.cb = 0;
    m_EntryID.lpb = NULL;
    m_InstanceKey.cb = 0;
    m_InstanceKey.lpb = NULL;

    m_szName = PszAlloc( szName );
    m_szEMail = PszAlloc( szEMail );
}


CGAL::CGalEntry::~CGalEntry( void ) {
    delete [] m_szName;
    delete [] m_szEMail;
    delete [] m_EntryID.lpb;
    delete [] m_InstanceKey.lpb;
	delete [] m_szBusinessTelephoneNum;
}


CGAL::CGalEntry& CGAL::CGalEntry::operator=( const CGalEntry& r ) {
    if( this != &r ) {
        
        m_ulDisplayType = r.m_ulDisplayType;

        delete [] m_EntryID.lpb;        
        m_EntryID.lpb = NULL;
        delete [] m_InstanceKey.lpb;    
        m_InstanceKey.lpb = NULL;

        delete [] m_szName;
        delete [] m_szEMail;
		delete [] m_szBusinessTelephoneNum;

        m_szName = NULL;
        m_szEMail = NULL;
		m_szBusinessTelephoneNum = NULL;

        m_EntryID.cb = r.m_EntryID.cb;
        if( m_EntryID.cb ) {
            m_EntryID.lpb = new BYTE[ m_EntryID.cb ];
            memcpy( m_EntryID.lpb, r.m_EntryID.lpb, m_EntryID.cb );
        }

        m_InstanceKey.cb = r.m_InstanceKey.cb;
        if( m_InstanceKey.cb ) {
            m_InstanceKey.lpb = new BYTE[ m_InstanceKey.cb ];
            memcpy( m_InstanceKey.lpb, r.m_InstanceKey.lpb, m_InstanceKey.cb );
        }

        m_szName = PszAlloc( r.m_szName );
        m_szEMail = PszAlloc( r.m_szEMail );
		m_szBusinessTelephoneNum = PszAlloc( r.m_szBusinessTelephoneNum );
    }
    
    return *this;
}

bool CGAL::CGalEntry::operator==( const CGalEntry& r ) const {
    return ( ( m_InstanceKey.cb == r.m_InstanceKey.cb ) && ( 0 == memcmp( &m_InstanceKey.cb, &r.m_InstanceKey.cb, m_InstanceKey.cb ) ) );
}

bool CGAL::CGalEntry::operator>=( LPCTSTR sz ) const {
    return ( 0 <= lstrcmpi( m_szName, sz ) );
}

bool CGAL::CGalEntry::operator<( LPCTSTR sz ) const {
    return ( 0 > lstrcmpi( m_szName, sz ) );
}

bool CGAL::CGalEntry::operator<=( LPCTSTR sz ) const {
    return ( 0 >= lstrcmpi( m_szName, sz ) );
}


////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////






/////////////////////////////////////////////////////////////////////////
// Testin functions... These are pretty streight-forward....
#if TESTING_CGAL 
    void CGAL::_VerifyCache( void ) {
#if 0
        if( !IS_ZONE_ENABLED( ghZoneApi, ZONE_GALVERIFICATION_FLAG ) ) { return; }
        HRESULT hr;
        hr = _SetCursorTo( *m_EntryCache.front() );

        lst< CGalEntry* >::iterator I = m_EntryCache.begin();
        while( m_EntryCache.end() != I ) {
            LPSRowSet   pRow;
            hr = m_pContentsTable->QueryRows ( 50, 0, &pRow );
            ASSERT( SUCCEEDED( hr ) );
            for( ULONG i = 0; i < pRow->cRows; i++ ) {
                CGalEntry* pEntry;
                _MakeGalEntry( pRow->aRow[ i ], &pEntry );
                if( ( **I ) != ( *pEntry ) ) {
                    ULONG Count;
                    hr = m_pContentsTable->GetRowCount( 0, &Count );
                    ASSERT( SUCCEEDED( hr ) );
                    ASSERT( 0 );
                    lpfnFreeProws( pRow );
                    delete pEntry;
                    return;
                }
                delete pEntry;
                I++;
                if( m_EntryCache.end() == I ) { break; }

            }
            lpfnFreeProws( pRow );
        }
#endif
    }

    char* _MakeRandomString( void ) {
        static char sz[ 200 ];
        int len = ( rand() % 6 ) + 1;
        sz[ len ] = '\0';
        for( int i = len - 1; len >= 0; len-- ) {
            sz[ len ] = ( rand() % 26 ) + 'a'; 
        }

        return sz;
    }

    void CGAL::_Test( void ) {
        int e = 7557;
        _GetEntry( e );
        for( int o = 0; o < 10; o++ ) {
            _GetEntry( e - o );
        }
        for( int i = 0; i < 500; i++ ) {
            int nEntry = rand() % ( m_nRows - 1 );
            _GetEntry( nEntry );
            if( rand() % 2 ) {
                // Slide for a while
                int j, NewIndex;
                int nSlide = rand() % 100;
                if( rand() % 2 ) {
                    // Slide Up for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = j + nEntry;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows ) ) ) {
                            _GetEntry( NewIndex );
                        }
                    }

                }
                else {
                        // Slide Down for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = nEntry - j;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows ) ) ) {
                            _GetEntry( NewIndex );
                        }
                    }
                }
            }
        }
        TRACE_OUT(( "The first test is successful!" ));

        _ResetCache();
        
        for( i = 0; i < 500; i++ ) {
            int nEntry = OnListFindItem( _MakeRandomString() );
            if( rand() % 2 ) {
                // Slide for a while
                int j, NewIndex;
                int nSlide = rand() % 100;
                if( rand() % 2 ) {
                    // Slide Up for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = j + nEntry;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows )  ) ) {
                            _GetEntry( NewIndex );
                        }
                    }

                }
                else {
                        // Slide Down for a while
                    for( j = 0; j < nSlide; j++ ) {
                        NewIndex = nEntry - j;
                        if( ( NewIndex >= 0 ) && ( NewIndex < static_cast< int >( m_nRows )  ) ) {
                            _GetEntry( NewIndex );
                        }

                    }
                }
            }

        }

        TRACE_OUT(( "The second test is successful!" ));

    }

#endif // #if TESTING_CGAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\getip.cpp ===
#include "precomp.h"
#include "getip.h"

#define MAX_HOSTNAME_LENGTH	80

int __stdcall GetIPAddresses(char **szAddressArray, int numAddresses)
{
	hostent *pHostent;
	char szHostname[MAX_HOSTNAME_LENGTH];
	int nRet, nIndex;
	int nCount;
	in_addr* pInterfaceAddr;


	nRet = gethostname(szHostname, MAX_HOSTNAME_LENGTH);
	szHostname[MAX_HOSTNAME_LENGTH-1] = '\0';


	if (nRet < 0)
	{
		return nRet;
	}


	pHostent = gethostbyname(szHostname);

	if (pHostent == NULL)
	{
		return -1;
	}


	nCount = 0;
	for (nIndex = 0; nIndex < numAddresses; nIndex++)
	{
		if (pHostent->h_addr_list[nIndex] != NULL)
			nCount++;
		else
			break;
	}

	// enumerate the addresses backwards - PPP addresses will get listed
	// first ???
	for (nIndex = (nCount-1); nIndex >= 0; nIndex--)
	{
		pInterfaceAddr = (in_addr*)(pHostent->h_addr_list[nIndex]);
		lstrcpy(szAddressArray[nCount - 1 - nIndex], inet_ntoa(*pInterfaceAddr));
	}

	return nCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\gal.h ===
// File: GAL.h

#ifndef __GAL_h__
#define __GAL_h__

#include "richaddr.h"

#include <mapix.h>

    // lst.h contains the template list class that we are using
#include "lst.h"
#include "calv.h"


    // Various debugging macros to facilitate testing
    // if the TESTING_CGAL macro is defined as non-zero there
    // is significant overhaed in exhaustively testing the CGAL stuff...
#ifdef _DEBUG
    #define TESTING_CGAL 1
#else 
    #define TESTING_CGAL 0
#endif // _DEBUG
   
#if TESTING_CGAL 
    #define VERIFYCACHE _VerifyCache( );
    #define TESTCGAL    _Test();
#else 
    #define VERIFYCACHE
    #define TESTCGAL
#endif // TESTING_CGAL

#define CONSTANT( x ) enum{ x }


#define MAKE_GAL_ERROR( e )         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, e )
#define GAL_E_GAL_NOT_FOUND                 MAKE_GAL_ERROR( 0x0001 )
#define GAL_E_GETROWCOUNT_FAILED            MAKE_GAL_ERROR( 0x0002 )
#define GAL_E_SETCOLUMNS_FAILED             MAKE_GAL_ERROR( 0x0003 )
#define GAL_E_FINDROW_FAILED                MAKE_GAL_ERROR( 0x0004 )
#define GAL_E_SEEKROW_FAILED                MAKE_GAL_ERROR( 0x0005 )
#define GAL_E_SEEKROWAPPROX_FAILED          MAKE_GAL_ERROR( 0x0006 )
#define GAL_E_CREATEBOOKMARK_FAILED         MAKE_GAL_ERROR( 0x0007 )
#define GAL_E_QUERYROWS_FAILED              MAKE_GAL_ERROR( 0x0008 )
#define GAL_E_FREEBOOKMARK_FAILED           MAKE_GAL_ERROR( 0x0009 )
#define GAL_E_NOINSTANCEKEY                 MAKE_GAL_ERROR( 0x000a )
#define GAL_E_NOENTRYID                     MAKE_GAL_ERROR( 0x000b )

    // CGAL is the Exchange Global Address List View....

class CGAL : public CALV
{

public: // Data Types

        // A CGalEntry holds information about an individual entry in the GAL
    class CGalEntry {
    private:
        LPTSTR      m_szName;					// PR_DISPLAY_NAME
        LPTSTR      m_szEMail;					// PR_ACCOUNT
        SBinary     m_EntryID;					// PR_ENTRYID
        SBinary     m_InstanceKey;				// PR_INSTANCE_KEY
        ULONG       m_ulDisplayType;			// PR_DISPLAY_TYPE
		LPTSTR      m_szBusinessTelephoneNum;	// PR_BUSINESS_TELEPHONE_NUMBER;

    public: // Constructiors / destructiors / initializers / assignment
        CGalEntry( void );
        CGalEntry( const CGalEntry& r );
        CGalEntry( LPCTSTR szName, LPCTSTR szEMail, SBinary& rInstanceKey, SBinary& rEntryID, ULONG ulDisplayType, LPCTSTR szBusinessTelephoneNum );
        CGalEntry( LPCTSTR szName, LPCTSTR szEMail );
        ~CGalEntry( void );

        CGalEntry& operator=( const CGalEntry& r );

            // Get functions
        LPCTSTR GetName( void ) const				{ return m_szName;					}
        LPCTSTR GetEMail( void ) const				{ return m_szEMail;					}
		LPCTSTR GetBusinessTelephone( void ) const	{ return m_szBusinessTelephoneNum;	}
        const SBinary& GetInstanceKey( void ) const { return m_InstanceKey;				}
        const SBinary& GetEntryID( void ) const     { return m_EntryID;					}
        ULONG GetDisplayType( void ) const          { return m_ulDisplayType;			}

            // Comparison Operators
        bool operator==( const CGalEntry& r ) const;
        bool operator!=( const CGalEntry& r ) const { return !( *this == r ); }
        bool operator>=( LPCTSTR sz ) const;
        bool operator<=( LPCTSTR sz ) const;
        bool operator<( LPCTSTR sz ) const;
  
    };

private: // Static Data

    enum ePropertyIndices { 
             NAME_PROP_INDEX = 0,
             ACCOUNT_PROP_INDEX,
             INSTANCEKEY_PROP_INDEX,
             ENTRYID_PROP_INDEX,
             DISPLAY_TYPE_INDEX,
			 BUSINESS_PHONE_NUM_PROP_INDEX,
             NUM_PROPS
           };

    enum eAsyncLogonState {
        AsyncLogonState_Idle,
        AsyncLogonState_LoggingOn,
        AsyncLogonState_LoggedOn,
        AsyncLogonState_Error

    };

    CONSTANT( NUM_LISTVIEW_PAGES_IN_CACHE   = 15 );
    CONSTANT( INVALID_CACHE_INDEX           = -1 );
    CONSTANT( DefaultMaxCacheSize           = 1000 );
    CONSTANT( DefaultBlockSize              = 50 );

    static LPCTSTR         msc_szNoDisplayName;
    static LPCTSTR         msc_szNoEMailName;
	static LPCTSTR         msc_szNoBusinessTelephoneNum;
    static const char*          msc_szNMExchangeAtrValue;
    static const char*          msc_szNMPolRegKey;
    static const char*          msc_szDefaultILSServerRegKey;
    static const char*          msc_szDefaultILSServerValue;
    static const char*          msc_szSMTPADDRESSNAME;

private: // Data
	HRESULT                     m_hrGALError;
	CGalEntry                   msc_ErrorEntry_NoGAL; 
	HWND						m_hWndListView;


        // Cache Stuff
    int                         m_nBlockSize;
    lst< CGalEntry* >           m_EntryCache;
    int                         m_IndexOfFirstItemInCache;
    int                         m_IndexOfLastItemInCache;
    bool                        m_bBeginningBookmarkIsValid;
    bool                        m_bEndBookmarkIsValid;
    BOOKMARK                    m_BookmarkOfFirstItemInCache;
    BOOKMARK                    m_BookmarkOfItemAfterLastItemInCache;
    int                         m_MaxCacheSize;
    int                         m_MaxJumpSize;
   
public: // Async globals (public so they can be accessed by static functions)
	static HINSTANCE            m_hInstMapi32DLL;
	static HANDLE               m_hEventEndAsyncThread;
	static HANDLE               m_hAsyncLogOntoGalThread;
	static eAsyncLogonState     m_AsyncLogonState;

	    // Mapi Interfaces
	static IAddrBook           *m_pAddrBook;
	static IMAPITable          *m_pContentsTable;
	static IMAPIContainer      *m_pGAL;
	static ULONG                m_nRows;

	static BOOL FLoadMapiFns(void);
	static VOID UnloadMapiFns(void);


public:
	CGAL();
	~CGAL();

	// CALV methods
	virtual VOID  ShowItems( HWND hwnd );
	virtual VOID  ClearItems(void);
	virtual BOOL  GetSzAddress(LPTSTR psz, int cchMax, int iItem);
	virtual ULONG OnListFindItem( LPCTSTR szPartialMatchingString ); 
	virtual void  OnListGetColumn1Data( int iItemIndex, int cchTextMax, LPTSTR szBuf );
	virtual void  OnListGetColumn2Data( int iItemIndex, int cchTextMax, LPTSTR szBuf );
	virtual void  OnListGetColumn3Data( int iItemIndex, int cchTextMax, TCHAR* szBuf );
	virtual VOID  CmdProperties( void );
	virtual void  OnListCacheHint( int indexFrom, int indexTo );
	virtual int   OnListGetImageForItem( int iIndex );
	virtual bool  IsItemBold( int index );
	virtual RAI * GetAddrInfo(void);


private: // Helper Fns
    DWORD _GetExchangeAttribute( void );

        // Helper fns to get GAL Entries
    CGalEntry* _GetEntry( int index );
    CGalEntry* _GetItemFromCache( int index );
    CGalEntry* _GetEntriesAtBeginningOfList( int index );
    CGalEntry* _GetEntriesAtEndOfList( int index );
    CGalEntry* _LongJumpTo( int index );
    bool _CreateEndBookmark( int index, lst< CGalEntry* >::iterator& IEntry );
    bool _CreateBeginningBookmark( void );
    int _FindItemInCache( LPCTSTR szPartialMatchString );
    void _ResetCache( void );
    HRESULT _MakeGalEntry( SRow& rRow, CGalEntry** ppEntry );
    HRESULT _KillExcessItemsFromFrontOfCache( void );
    HRESULT _KillExcessItemsFromBackOfCache( void );
    bool _GetSzAddressFromExchangeServer(int iItem, LPTSTR psz, int cchMax);
    void _CopyPropertyString( LPTSTR psz, SPropValue& rProp, int cchMax );
    HRESULT _SetCursorTo( LPCTSTR szPartialMatch );
    HRESULT _SetCursorTo( const SBinary& rInstanceKey );
    HRESULT _SetCursorTo( const CGalEntry& rEntry );

    
	bool _IsLoggedOn( void ) const { return AsyncLogonState_LoggedOn == m_AsyncLogonState; }
	HRESULT _GetPhoneNumbers( const SBinary& rEntryID, int* pcPhoneNumbers, LPTSTR** ppszPhoneNums );
	HRESULT _GetEmailNames( int* pnEmailNames, LPTSTR** ppszEmailNames, int iItem );

	// Async logon/logoff
	HRESULT _AsyncLogOntoGAL(void);
	static HRESULT _sAsyncLogOntoGal(void);
	static HRESULT _sAsyncLogoffGal(void);
	static DWORD CALLBACK _sAsyncLogOntoGalThreadfn(LPVOID);
	static HRESULT _sInitListViewAndGalColumns(HWND hwnd);

#if TESTING_CGAL 

    void _VerifyCache( void );    
    void _Test( void );

#endif // #if TESTING_CGAL 

};

// These should be removed...
#define msc_ErrorEntry_FindRowFailed        msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_SeekRowFailed        msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_SeekRowApproxFailed  msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_CreateBookmarkFailed msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_QueryRowsFailed      msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_FreeBookmarkFailed   msc_ErrorEntry_NoGAL
#define msc_ErrorEntry_NoInstanceKeyFound   msc_ErrorEntry_NoGAL

#endif // __GAL_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\getip.h ===
#ifndef NMCONF_GETIP_H
#define NMCONF_GETIP_H


int __stdcall GetIPAddresses(char **szAddressArray, int numAddresses);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\gencpl.cpp ===
// File: gencpl.cpp

#include "precomp.h"
#include <oprahcom.h>
#include "resource.h"
#include "help_ids.h"
#include "csetting.h"
#include "confwnd.h"
#include "conf.h"
#include "ConfCpl.h"
#include "ConfPolicies.h"
#include <nmremote.h>

extern int MessageBoxResource(HWND hwnd, UINT uMessage, UINT uTitle, UINT uFlags);


const int MAXPASSWORDLENGTH = 36;
const int MINPASSWORDLENGTH = 7;

INT_PTR CALLBACK RemotePasswordDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	HWND hOldPasswordText, hNewPasswordText, hVerificationText;
	int nOldPasswordLength, nNewPasswordLength, nVerificationLength;
	CHAR lpOldPassword[MAXPASSWORDLENGTH], lpNewPassword[MAXPASSWORDLENGTH], lpVerification[MAXPASSWORDLENGTH];
	WCHAR lpwszOldPassword[MAXPASSWORDLENGTH], lpwszNewPassword[MAXPASSWORDLENGTH];
	PBYTE pbHashedPassword=NULL;
	DWORD cbHashedPassword=0;
	
	PBYTE pbRegPassword = NULL;
	DWORD cbRegPassword;

	switch (iMsg)
	{
            case WM_INITDIALOG:
                SendDlgItemMessage(hDlg, IDC_EDITOLDPASSWORD, EM_LIMITTEXT,
                                   MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDITNEWPASSWORD, EM_LIMITTEXT,
                                   MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDITVERIFICATION, EM_LIMITTEXT,
                               MAXPASSWORDLENGTH - 1, 0);
                
                // If there's no old password, disable that UI
                {
                    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                    if ( 0 == reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_EDITOLDPASSWORD), FALSE);
                        SetFocus(GetDlgItem(hDlg, IDC_EDITNEWPASSWORD));
                    }
                }
                
                return TRUE;
                
	case WM_COMMAND: 
		switch (LOWORD(wParam))
		{
		case IDOK: {
			RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
			CHash hashObject;
			
			hOldPasswordText = GetDlgItem(hDlg,IDC_EDITOLDPASSWORD);
			hNewPasswordText = GetDlgItem(hDlg,IDC_EDITNEWPASSWORD);
			hVerificationText = GetDlgItem(hDlg,IDC_EDITVERIFICATION);
			nOldPasswordLength = GetWindowText(hOldPasswordText,lpOldPassword,MAXPASSWORDLENGTH);
			MultiByteToWideChar(CP_ACP, 0, lpOldPassword, -1, lpwszOldPassword, MAXPASSWORDLENGTH);

			cbRegPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword);

			// Decode password string
			cbHashedPassword = hashObject.GetHashedData((LPBYTE)lpwszOldPassword, 
								sizeof(WCHAR)*strlen(lpOldPassword), 
								(void **)&pbHashedPassword);

			if (0 != cbRegPassword && !(cbHashedPassword == cbRegPassword && 0 == memcmp(pbHashedPassword,pbRegPassword,cbHashedPassword))) {
				// Error Case - Old password incorrect.
				MessageBoxResource(hDlg,IDS_REMOTE_OLD_PASSWORD_WRONG_TEXT,IDS_REMOTE_OLD_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hOldPasswordText,NULL);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hOldPasswordText);
				break;
			}
			nNewPasswordLength = GetWindowText(hNewPasswordText,lpNewPassword,MAXPASSWORDLENGTH);
			nVerificationLength = GetWindowText(hVerificationText,lpVerification,MAXPASSWORDLENGTH);
			if (lstrcmp(lpNewPassword,lpVerification) != 0) {
				// Error Case - New password and verification do not match.
				MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_WRONG_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hNewPasswordText);
				break;
			}
                        if (nNewPasswordLength < MINPASSWORDLENGTH)
                        {
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_LENGTH_TEXT,IDS_REMOTE_NEW_PASSWORD_LENGTH_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            break;
                        }
			if (!lstrlen(lpVerification)) {
				// Don't allow empty password
				MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_EMPTY,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hNewPasswordText);
				break;
			}
			if (!FAnsiSz(lpNewPassword)) {
				// Error Case - T.120 can't handle UNICODE passwords
				MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_INVALID_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
				SetWindowText(hNewPasswordText,NULL);
				SetWindowText(hVerificationText,NULL);
				SetFocus(hNewPasswordText);
				break;
			}

			// If we get here, then go ahead and change the password.
			MultiByteToWideChar(CP_ACP, 0, lpNewPassword, -1, lpwszNewPassword, MAXPASSWORDLENGTH);
			cbHashedPassword = hashObject.GetHashedData((LPBYTE)lpwszNewPassword, 
								sizeof(WCHAR)*lstrlen(lpNewPassword), 
								(void **)&pbHashedPassword);
			ASSERT (0 != cbHashedPassword);

			reLM.SetValue(REMOTE_REG_PASSWORD,pbHashedPassword,cbHashedPassword);
			MessageBoxResource(hDlg,IDS_REMOTE_PASSWORD_CHANGED_TEXT,IDS_REMOTE_PASSWORD_CHANGED_TITLE,MB_OK | MB_ICONEXCLAMATION);
			// Return 1 if non-null password is set
			EndDialog(hDlg, *lpNewPassword != _T('\0'));
			break;
		}
		case IDCANCEL:
			EndDialog(hDlg,0);
			break;
		default:
			break;
		}
		return TRUE;

	}
	return FALSE;
}

int MessageBoxResource(HWND hwnd, UINT uMessage, UINT uTitle, UINT uFlags)
{
	TCHAR szTitle[MAX_PATH];
	TCHAR szMessage[MAX_PATH];

	FLoadString(uMessage,szMessage,CCHMAX(szMessage));
	FLoadString(uTitle,szTitle,CCHMAX(szTitle));
	return MessageBox(hwnd, szMessage, szTitle, uFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\history.h ===
// File: history.h

#ifndef _HISTORY_H_
#define _HISTORY_H_

#include "calv.h"


// The header for a record in the call log file
typedef struct _tagLogHdr {
	DWORD dwSize;              // size of this entire record
	DWORD dwCLEF;              // CallLogEntry Flags (CLEF_*)
	DWORD dwPF;                // Participant flags (PF_*)
	DWORD cbName;              // size of szName, in bytes, including NULL
        DWORD cbData;              // size of rgData, in bytes
        DWORD cbCert;              // size of certificate, in bytes
	SYSTEMTIME 	sysTime;       // date/time of record creation
//  WCHAR szName;              // null terminated display name (in UNICODE)
//  BYTE  ri[];                // Roster Information
} LOGHDR;


class CHISTORY : public CALV
{
private:
	HANDLE m_hFile;
	LPTSTR m_pszFile;

	int
	Compare
	(
		LPARAM	param1,
		LPARAM	param2
	);
	static
	int
	CALLBACK
	StaticCompare
	(
		LPARAM	param1,
		LPARAM	param2,
		LPARAM	pThis
	);

public:
	CHISTORY();
	~CHISTORY();

	VOID CmdDelete(void);
	VOID CmdProperties(void);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID ClearItems(void);
	VOID OnCommand(WPARAM wParam, LPARAM lParam);

	//
	HANDLE  OpenLogFile(VOID);
	BOOL    FSetFilePos(DWORD dwOffset);
	BOOL    FReadData(PVOID pv, UINT cb);
	HRESULT ReadEntry(DWORD dwOffset, LOGHDR * pLogHdr, LPTSTR * ppszName, LPTSTR * ppszAddress);
	VOID    LoadFileData(HWND hwnd);
	HRESULT WriteData(LPDWORD pdwOffset, PVOID pv, DWORD cb);
	HRESULT DeleteEntry(DWORD dwOffset);

	UINT    GetStatusString(DWORD dwCLEF);
};

#endif /* _HISTORY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\history.cpp ===
// File: history.cpp

#include "precomp.h"
#include "resource.h"

#include "dirutil.h"
#include "upropdlg.h"
#include "history.h"

// CCallLogEntry flags:
const DWORD CLEF_ACCEPTED =			0x00000001;
const DWORD CLEF_REJECTED =			0x00000002;
const DWORD CLEF_AUTO_ACCEPTED =	0x00000004; // call was auto-accepted
const DWORD CLEF_TIMED_OUT =		0x00000008; // call was rejected due to timeout
const DWORD CLEF_SECURE =           0x00000010; // call was secure

const DWORD CLEF_NO_CALL  =         0x40000000; // No call back information
const DWORD CLEF_DELETED  =         0x80000000; // Record marked for deletion

const WCHAR g_cszwULS[] = L"ULS:";

static const int _rgIdMenu[] = {
	IDM_DLGCALL_DELETE,
	0
};


/*  C  H  I  S  T  O  R  Y  */
/*-------------------------------------------------------------------------
    %%Function: CHISTORY

-------------------------------------------------------------------------*/
CHISTORY::CHISTORY() :
	CALV(IDS_DLGCALL_HISTORY, II_HISTORY, _rgIdMenu)
{
	DbgMsg(iZONE_OBJECTS, "CHISTORY - Constructed(%08X)", this);

	RegEntry re(LOG_INCOMING_KEY, HKEY_CURRENT_USER);
	m_pszFile = PszAlloc(re.GetString(REGVAL_LOG_FILE));

	// Make sure file exists and can be read/written
	m_hFile = OpenLogFile();
	SetAvailable(NULL != m_hFile);
}

CHISTORY::~CHISTORY()
{
	if (NULL != m_hFile)
	{
		CloseHandle(m_hFile);
	}
	delete m_pszFile;

	DbgMsg(iZONE_OBJECTS, "CHISTORY - Destroyed(%08X)", this);
}


int
CHISTORY::Compare
(
	LPARAM	param1,
	LPARAM	param2
)
{
	int ret = 0;

	LPTSTR pszName1, pszAddress1;
	LPTSTR pszName2, pszAddress2;
	LOGHDR logHdr1, logHdr2;

	if (SUCCEEDED(ReadEntry((DWORD)param1, &logHdr1, &pszName1, &pszAddress1)))
	{
		if (SUCCEEDED(ReadEntry((DWORD)param2, &logHdr2, &pszName2, &pszAddress2)))
		{
			FILETIME ft1, ft2;

			SystemTimeToFileTime(&logHdr1.sysTime, &ft1);
			SystemTimeToFileTime(&logHdr2.sysTime, &ft2);

			// Sort in reverse order so most recent is at the top
			ret = -CompareFileTime(&ft1, &ft2);

			delete pszName2;
			delete pszAddress2;
		}

		delete pszName1;
		delete pszAddress1;
	}

	return(ret);
}


int
CALLBACK
CHISTORY::StaticCompare
(
	LPARAM	param1,
	LPARAM	param2,
	LPARAM	pThis
)
{
	return(reinterpret_cast<CHISTORY*>(pThis)->Compare(param1, param2));
}


///////////////////////////////////////////////////////////////////////////
// CALV methods


/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems

-------------------------------------------------------------------------*/
VOID CHISTORY::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);

	TCHAR szReceived[CCHMAXSZ];
	if( FLoadString(IDS_RECEIVED, szReceived, CCHMAX(szReceived)) )
	{
		LV_COLUMN lvc;
		ClearStruct(&lvc);
		lvc.mask = LVCF_TEXT | LVCF_SUBITEM;
		lvc.pszText = szReceived;
		lvc.iSubItem = IDI_MISC1;
		ListView_InsertColumn(hwnd, IDI_MISC1, &lvc);
	}

	if (!FAvailable())
		return;

	LoadFileData(hwnd);

	ListView_SortItems( hwnd, StaticCompare, (LPARAM) this );
}


VOID CHISTORY::ClearItems(void)
{
	CALV::ClearItems();

	HWND hWndListView = GetHwnd();
	if( IsWindow(hWndListView) )
	{
		ListView_DeleteColumn(hWndListView, IDI_MISC1);
	}
}


VOID CHISTORY::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
	case IDM_DLGCALL_DELETE:
		CmdDelete();
		break;
	case IDM_DLGCALL_PROPERTIES:
		CmdProperties();
		break;
	default:
		CALV::OnCommand(wParam, lParam);
		break;
		}
}

VOID CHISTORY::CmdDelete(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	LPARAM lParam = LParamFromItem(iItem);
	if (SUCCEEDED(DeleteEntry((DWORD)lParam)))
	{
		DeleteItem(iItem);
	}
}


UINT CHISTORY::GetStatusString(DWORD dwCLEF)
{
	if (CLEF_ACCEPTED & dwCLEF)
		return IDS_HISTORY_ACCEPTED;

	if (CLEF_TIMED_OUT & dwCLEF)
		return IDS_HISTORY_NOT_ANSWERED;

	ASSERT(CLEF_REJECTED & dwCLEF);
	return IDS_HISTORY_IGNORED;
}


VOID CHISTORY::CmdProperties(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	LPTSTR pszName;
	LPTSTR pszAddress;
	TCHAR  szStatus[CCHMAXSZ];
	TCHAR  szTime[CCHMAXSZ];
	LOGHDR logHdr;
	PBYTE  pbCert = NULL;
        PCCERT_CONTEXT pCert = NULL;

	LPARAM lParam = LParamFromItem(iItem);

	if (SUCCEEDED(ReadEntry((DWORD)lParam, &logHdr, &pszName, &pszAddress)))
	{
	    if (logHdr.dwCLEF & CLEF_SECURE)  // is secure call
	    {
	        ASSERT(logHdr.cbCert);
	        pbCert = new BYTE[logHdr.cbCert];
                if (FSetFilePos(lParam+sizeof(logHdr)+logHdr.cbName+logHdr.cbData))
	        {
                    if (FReadData(pbCert, logHdr.cbCert))
                    {
                        pCert = CertCreateCertificateContext(X509_ASN_ENCODING, pbCert, logHdr.cbCert);
                        if (NULL == pCert)
                        {
                            WARNING_OUT(("Certificate in Call Log is damaged."));
                        }
                    }
	        }
	        delete []pbCert;
	    }
	
            FLoadString(GetStatusString(logHdr.dwCLEF), szStatus, CCHMAX(szStatus));
            FmtDateTime(&logHdr.sysTime, szTime, CCHMAX(szTime));

            if (NULL == pszAddress)
            {
                pszAddress = PszLoadString(IDS_HISTORY_NO_ADDRESS);
            }

            UPROPDLGENTRY rgProp[] = {
                {IDS_UPROP_ADDRESS,  pszAddress},
                {IDS_UPROP_STATUS,   szStatus},
                {IDS_UPROP_RECEIVED, szTime},
            };

			CUserPropertiesDlg dlgUserProp(GetHwnd(), IDI_LARGE);
			dlgUserProp.DoModal(rgProp, ARRAY_ELEMENTS(rgProp), pszName, pCert);
	}

        if ( pCert )
            CertFreeCertificateContext ( pCert );

	delete pszName;
	delete pszAddress;
}


///////////////////////////////////////////////////////////////////////////


/*  O P E N  L O G  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: OpenLogFile

    Open the log file and return a handle to file.
    Return NULL if there was a problem.
-------------------------------------------------------------------------*/
HANDLE CHISTORY::OpenLogFile(VOID)
{
	HANDLE hFile = CreateFile(m_pszFile, GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
		OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (INVALID_HANDLE_VALUE == hFile)
	{
		ERROR_OUT(("OpenLogFile: Unable to open call log file"));
		hFile = NULL;
	}

	return hFile;
}

BOOL CHISTORY::FSetFilePos(DWORD dwOffset)
{
	ASSERT(NULL != m_hFile);
	return (INVALID_FILE_SIZE != SetFilePointer(m_hFile, dwOffset, NULL, FILE_BEGIN));
}


/*  L O A D  F I L E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: LoadFileData

    Load the call log data from the file
-------------------------------------------------------------------------*/
VOID CHISTORY::LoadFileData(HWND hwnd)
{
	HANDLE hFile = OpenLogFile();
	if (NULL == hFile)
		return;

	LPTSTR pszName, pszAddress;
	LOGHDR logHdr;
	DWORD dwOffset = 0;

	HRESULT hr = S_OK;
	while (SUCCEEDED(hr))
	{
		hr = ReadEntry(dwOffset, &logHdr, &pszName, &pszAddress);
		if (S_OK == hr)
		{
			TCHAR szTime[CCHMAXSZ];
            FmtDateTime(&logHdr.sysTime, szTime, CCHMAX(szTime));

			DlgCallAddItem(hwnd, pszName, pszAddress, II_COMPUTER, dwOffset, 0,
				szTime);
		}

		dwOffset += logHdr.dwSize;

		delete pszName;
		pszName = NULL;
		delete pszAddress;
		pszAddress = NULL;
	}

	CloseHandle(hFile);
}


/*  R E A D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: ReadEntry

    Read the next entry from the file.

    Return Values:
    	S_OK    - data was read successfully
    	S_FALSE - data exists, but was deleted
    	E_FAIL  - problem reading file
-------------------------------------------------------------------------*/
HRESULT CHISTORY::ReadEntry(DWORD dwOffset,
	LOGHDR * pLogHdr, LPTSTR * ppszName, LPTSTR * ppszAddress)
{
	ASSERT(NULL != m_hFile);

	*ppszName = NULL;
	*ppszAddress = NULL;

	if (!FSetFilePos(dwOffset))
		return E_FAIL;

	// Read record header
	if (!FReadData(pLogHdr, sizeof(LOGHDR)) )
		return E_FAIL;
	
	// Read Name
	WCHAR szwName[CCHMAXSZ_NAME];
	if (!FReadData(szwName, min(pLogHdr->cbName, sizeof(szwName))))
		return E_FAIL;

	*ppszName = PszFromBstr(szwName);

	if (FReadData(szwName, min(pLogHdr->cbData, sizeof(szwName))))
	{
		LPCWSTR pchw = _StrStrW(szwName, g_cszwULS);
		if (NULL != pchw)
		{
			pchw += CCHMAX(g_cszwULS)-1; // -1 for NULL
			*ppszAddress = PszFromBstr(pchw);
		}
	}

	return (0 == (pLogHdr->dwCLEF & CLEF_DELETED)) ? S_OK : S_FALSE;
}


/*  R E A D  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: FReadData

-------------------------------------------------------------------------*/
BOOL CHISTORY::FReadData(PVOID pv, UINT cb)
{
	DWORD cbRead;

	ASSERT(NULL != m_hFile);
	ASSERT(NULL != pv);

	if (0 == cb)
		return TRUE;

	if (!ReadFile(m_hFile, pv, cb, &cbRead, NULL))
		return FALSE;

	return (cb == cbRead);
}


/*  D E L E T E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: DeleteEntry

    Delete a single entry.
-------------------------------------------------------------------------*/
HRESULT CHISTORY::DeleteEntry(DWORD dwOffset)
{
	// Calculate offset to "CLEF"
	dwOffset += FIELD_OFFSET(LOGHDR,dwCLEF);

	if (!FSetFilePos(dwOffset))
		return E_FAIL;

	DWORD dwFlags;
	if (!FReadData(&dwFlags, sizeof(dwFlags)))
		return E_FAIL;

	dwFlags = dwFlags | CLEF_DELETED;

	if (!FSetFilePos(dwOffset))
		return E_FAIL;

	return WriteData(&dwOffset, &dwFlags, sizeof(dwFlags));
}


/*  W R I T E  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: WriteData

    Write the data to the file.
    The file will be automatically opened/close if hFile is NULL.
-------------------------------------------------------------------------*/
HRESULT CHISTORY::WriteData(LPDWORD pdwOffset, PVOID pv, DWORD cb)
{
	ASSERT(NULL != m_hFile);
	ASSERT(0 != cb);
	ASSERT(NULL != pv);
	ASSERT(NULL != pdwOffset);
	ASSERT(INVALID_FILE_SIZE != *pdwOffset);

	HRESULT hr = E_FAIL;

	if (FSetFilePos(*pdwOffset))
	{
		DWORD cbWritten;
		if (WriteFile(m_hFile, pv, cb, &cbWritten, NULL) && (cb == cbWritten))
		{
			*pdwOffset += cbWritten;
			hr = S_OK;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\ldap.cpp ===
// File: ldap.cpp

#include "precomp.h"
#include "resource.h"

#include "mapidefs.h"
#include "pfnwldap.h"
#include "ldap.h"
#include "wab.h"

#include "dirutil.h"
#include "dlgcall2.h" // for WM_DISPLAY_MESSAGE
#include "upropdlg.h"

#define CDIRCACHE_IMAGES			3

// static strings
static const TCHAR s_szSearchFormat3[]  = TEXT("(&(objectClass=RTPerson)(cn=%s)%s)");
static const TCHAR s_szSearchFormat2[]  = TEXT("(&(objectClass=RTPerson)(cn=%s)(sappid=ms-netmeeting)(sprotid=h323)%s)");
static const TCHAR s_szSearchCategory[] = TEXT("(ILSA39321630=%d)");

static LPCTSTR s_pszOrg                 = TEXT("o=Microsoft");

static const TCHAR s_cszAttribShow[]      = TEXT("sFlags");        // "Hide Me" (1=Show, 0=Hidden)
static const TCHAR s_cszAttribEmail[]     = TEXT("cn");            // Email address
static const TCHAR s_cszAttribFirstName[] = TEXT("givenName");     // First Name
static const TCHAR s_cszAttribLastName[]  = TEXT("surName");       // Last Name
static const TCHAR s_cszAttribLocation[]  = TEXT("location");		   // Location
static const TCHAR s_cszAttribComment[]   = TEXT("comment");       // Comments

static const TCHAR s_cszAttribInACall[]   = TEXT("ilsA26214430");  // 400 = in a call
static const TCHAR s_cszAttribVersion[]   = TEXT("ilsA26279966");  // 401 = version number
static const TCHAR s_cszAttribAudio[]     = TEXT("ilsA32833566");  // 501 = send audio
static const TCHAR s_cszAttribVideo[]     = TEXT("ilsA32964638");  // 503 = send video
static const TCHAR s_cszAttribCategory[]  = TEXT("ilsA39321630");  // 600 = category


static LPCTSTR s_rgAttrNameAddr[] = {
	(LPTSTR) s_cszAttribShow,
	(LPTSTR) s_cszAttribEmail,
	(LPTSTR) s_cszAttribFirstName,
	(LPTSTR) s_cszAttribLastName,
	(LPTSTR) s_cszAttribLocation,
	(LPTSTR) s_cszAttribInACall,
	(LPTSTR) s_cszAttribAudio,
	(LPTSTR) s_cszAttribVideo,
	(LPTSTR) s_cszAttribComment,
	NULL};


static LPCTSTR s_rgAttrAll[] = {
	(LPTSTR) s_cszAttribFirstName,
	(LPTSTR) s_cszAttribLastName,
	(LPTSTR) s_cszAttribComment,
	(LPTSTR) s_cszAttribAudio,
	(LPTSTR) s_cszAttribVideo,
	(LPTSTR) s_cszAttribVersion,
	(LPTSTR) s_cszAttribCategory,
	NULL};


static const int _rgIdMenu[] = {
	IDM_DLGCALL_SPEEDDIAL,
	IDM_DLGCALL_WAB,
	-1,
	IDM_DLGCALL_REFRESH,
	IDM_DLGCALL_STOP,
	0
};

// Local functions
VOID ConvertVersionInfo(LPTSTR pszVersion, LPTSTR pszCategory);


///////////////////////////////////////////////////////////////////////

CLDAP::CLDAP() :
	CALV(0, II_SERVER, _rgIdMenu),
	m_pLdap(NULL),
	m_ulPort(DEFAULT_LDAP_PORT),
	m_msgId(0),
	m_hThread(NULL),
	m_hWnd( NULL ),
	m_hSearchMutex( NULL ),

	m_fDirInProgress( FALSE ),
	m_cTotalEntries( 0 ),
	m_cEntries( 0 ),
	m_fHaveRefreshed( FALSE ),
	m_dwTickStart( 0 ),
	m_fIsCacheable( FALSE ),
	m_fNeedsRefresh( FALSE ),
	m_bSearchCancelled( false ),
	m_uniqueId( 0 )
{
	DbgMsg(iZONE_OBJECTS, "CLDAP - Constructed(%08X)", this);

	HRESULT hr = WLDAP::Init();
	SetAvailable(S_OK == hr);

	m_szServer[0] = _T('\0');
	m_szAddress[0] = _T('\0');
	
	m_hSearchMutex = CreateMutex( NULL, false, NULL );

	RegEntry reUI(UI_KEY, HKEY_CURRENT_USER);
	m_fCacheDirectory = (0 != reUI.GetNumber(
		REGVAL_CACHE_DIRECTORY, DEFAULT_CACHE_DIRECTORY));
	
	m_cMinutesExpire = reUI.GetNumber(
		REGVAL_CACHE_DIRECTORY_EXPIRATION, DEFAULT_CACHE_DIRECTORY_EXPIRATION);

}

CLDAP::~CLDAP()
{
	CloseServer();

	if (NULL != m_hThread)
	{
		WARNING_OUT(("CLDAP - waiting for AsyncSearch Thread to exit (start)"));
		WaitForSingleObject(m_hThread, 10000); // 10 seconds max
		WARNING_OUT(("CLDAP - waiting for AsyncSearch to exit (end)"));
	}

	if( m_hSearchMutex )
	{
		CloseHandle( m_hSearchMutex );
	}

	// Free any cached data
	while (!m_listDirCache.IsEmpty())
	{
		DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.RemoveHead();
		ASSERT(NULL != pDirCache);
		FreeDirCache(pDirCache);
	}

	DbgMsg(iZONE_OBJECTS, "CLDAP - Destroyed(%08X)", this);
}




///////////////////////////////////////////////////////////////////////////
// CALV methods


/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems

-------------------------------------------------------------------------*/
VOID CLDAP::ShowItems(HWND hwnd)
{
	DBGENTRY(CLDAP::ShowItems);

	m_hWnd = hwnd;
	SetWindow( hwnd );		//	set in base class too...

	CALV::ClearItems();
	DisplayDirectory();

	DBGEXIT(CLDAP::ShowItems);
}


/*  C L E A R  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ClearItems

-------------------------------------------------------------------------*/
VOID CLDAP::ClearItems(void)
{
	DBGENTRY( CLDAP::ClearItems );

	StopSearch();

	DBGEXIT( CLDAP::ClearItems );
}


/* virtual */
RAI * CLDAP::GetAddrInfo(void)
{
	DBGENTRY(CLDAP::GetAddrInfo);

	int		selectedItem	= CALV::GetSelection();
	RAI *	pRai			= NULL;

	if( selectedItem != -1 )
	{
		if( (pRai = new RAI) != NULL )
		{
			pRai->cItems		= 1;
			pRai->rgDwStr->dw	= NM_ADDR_ULS;

			GetSzName( pRai->szName, CCHMAX( pRai->szName ), selectedItem );

			TCHAR	buffer[ CCHMAXSZ ];

			GetSzAddress( buffer, CCHMAX( buffer ),selectedItem );
			pRai->rgDwStr->psz = PszAlloc( buffer );
		}
	}

	DBGEXIT(CLDAP::GetAddrInfo);

	return( pRai );
}


/*  G E T  S Z  A D D R E S S  */
/*-------------------------------------------------------------------------
    %%Function: GetSzAddress

-------------------------------------------------------------------------*/
BOOL CLDAP::GetSzAddress(LPTSTR psz, int cchMax, int iItem)
{
	DBGENTRY(CLDAP::GetSzAddress);

	BOOL bRet = TRUE;

	int cch = lstrlen(m_szServer);

	if ((cch+2) < cchMax)
	{
		lstrcpy(psz, m_szServer);
		psz += cch;
		*psz++ = _T('/');
		cchMax -= (cch+1);

		bRet = CALV::GetSzData( psz, cchMax, iItem, COLUMN_INDEX_ADDRESS );
	}
	else
	{
		bRet = FALSE;
	}


	DBGEXIT(CLDAP::GetSzAddress);
	
	return bRet;
}


/*  O N  C O M M A N D  */
/*-------------------------------------------------------------------------
    %%Function: OnCommand

-------------------------------------------------------------------------*/
VOID CLDAP::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
	case IDM_DLGCALL_STOP:
		StopSearch();
		break;
	case IDM_DLGCALL_REFRESH:
		if (NULL == m_hThread)
		{
			CALV::ClearItems();
			StartSearch();
		}
		break;
	case IDM_DLGCALL_WAB:
		CmdAddToWab();
		break;
	default:
		CALV::OnCommand(wParam, lParam);
		break;
		}
}


/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties

-------------------------------------------------------------------------*/
VOID CLDAP::CmdProperties(void)
{
	DBGENTRY(CLDAP::CmdProperties);

	DWORD dwThID;

	HANDLE hThread = CreateThread(NULL, 0, _sAsyncPropertyThreadFn,
                             (LPVOID) this, 0, &dwThID);
	CloseHandle(hThread);

	DBGEXIT(CLDAP::CmdProperties);
}

DWORD CALLBACK CLDAP::_sAsyncPropertyThreadFn(LPVOID pv)
{
	DBGENTRY(CLDAP::_sAsyncPropertyThreadFn);

	CLDAP * pThis = (CLDAP *) pv;
	ASSERT(NULL != pThis);
	pThis->ShowProperties();

	DBGEXIT(CLDAP::_sAsyncPropertyThreadFn);

	return 0;
}

VOID CLDAP::ShowProperties(void)
{
	DBGENTRY(CLDAP::ShowProperties);

	SetBusyCursor(TRUE);
	LDAPUSERDATA ldapUserData;
	BOOL fOk = FGetUserData(&ldapUserData);
	SetBusyCursor(FALSE);
	if (!fOk)
		return;

	TCHAR szHasHardware[CCHMAXSZ];
	FLoadString(IDS_HARDWARE_DETECTED, szHasHardware, CCHMAX(szHasHardware));
	TCHAR szNoHardware[CCHMAXSZ];
	FLoadString(IDS_NO_HARDWARE_DETECTED, szNoHardware, CCHMAX(szNoHardware));

	UPROPDLGENTRY rgProp[] = {
		{IDS_UPROP_EMAIL, ldapUserData.szEmail},
		{IDS_UPROP_COMMENTS,  ldapUserData.szComment},
		{IDS_UPROP_VIDEO, ldapUserData.fVideoSend ? szHasHardware : szNoHardware},
		{IDS_UPROP_AUDIO, ldapUserData.fAudioSend ? szHasHardware : szNoHardware},
		{IDS_UPROP_VERSION,   ldapUserData.szVersion},
	};

	CUserPropertiesDlg dlgUserProp(GetHwnd(), IDI_LARGE);
	dlgUserProp.DoModal(rgProp, ARRAY_ELEMENTS(rgProp), ldapUserData.szName, NULL);

	DBGEXIT(CLDAP::ShowProperties);
}


/*  C M D  A D D  T O  W A B  */
/*-------------------------------------------------------------------------
    %%Function: CmdAddToWab

-------------------------------------------------------------------------*/
VOID CLDAP::CmdAddToWab(void)
{
	DBGENTRY(CLDAP::CmdAddToWab);

	LDAPUSERDATA ldapUserData;
	if (!FGetUserData(&ldapUserData))
		return;

	CreateWabEntry(ldapUserData.szName, ldapUserData.szFirst, ldapUserData.szLast, ldapUserData.szEmail,
		NULL, NULL, ldapUserData.szComment, m_szServer);

	DBGEXIT(CLDAP::CmdAddToWab);
}

///////////////////////////////////////////////////////////////////////////


/*  S E T  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: SetServer

-------------------------------------------------------------------------*/
VOID CLDAP::SetServer(LPCTSTR pcszServer)
{
	DBGENTRY(CLDAP::SetServer);

	if ((0 != lstrcmpi(m_szServer, pcszServer)) || (DEFAULT_LDAP_PORT != m_ulPort))
	{
		CloseServer();
		
		int cch;
		LPCTSTR pszSeparator = _StrChr(pcszServer, _T(':'));
		if (NULL != pszSeparator)
		{
			cch = (pszSeparator - pcszServer) + 1;
			if (cch >= CCHMAX(m_szAddress))
				return;
			m_ulPort = DecimalStringToUINT(pszSeparator + 1);	
		}
		else
		{
			cch = CCHMAX(m_szAddress);
			m_ulPort = DEFAULT_LDAP_PORT;
		}

		// save the information before changing the server name
		CacheServerData();

		lstrcpyn(m_szAddress, pcszServer, cch);
		lstrcpyn(m_szServer, pcszServer, CCHMAX(m_szServer));
	}
	

	DBGEXIT(CLDAP::SetServer);
}


/*  D I R E C T O R Y  S T A R T  */
/*-------------------------------------------------------------------------
    %%Function: DirectoryStart

    Initiate directory request
-------------------------------------------------------------------------*/
VOID CLDAP::StartSearch(void)
{
	DBGENTRY(CLDAP::StartSearch);

        if (NULL == m_hThread)
        {
            DWORD dwThID;

			AddRef();
            m_bSearchCancelled = false;
            HANDLE hThread = CreateThread(NULL, 0, _sAsyncSearchThreadFn,
                                          (LPVOID) this, CREATE_SUSPENDED, &dwThID);
            if (NULL != hThread)
            {
		m_hThread = hThread;
		ResumeThread(hThread);
            }
			else
			{
				Release();
			}
        }

	DBGEXIT(CLDAP::StartSearch);
}

DWORD CALLBACK CLDAP::_sAsyncSearchThreadFn(LPVOID pv)
{

	DBGENTRY(CLDAP::_sAsyncSearchThreadFn);

	CLDAP * pThis = (CLDAP *) pv;
	ASSERT(NULL != pThis);
	pThis->AsyncSearch();
	pThis->Release();

	DBGEXIT(CLDAP::_sAsyncSearchThreadFn);

	return 0;
}

VOID CLDAP::AsyncSearch(void)
{
	DBGENTRY(CLDAP::AsyncSearch);
	
	HRESULT hr;

	WARNING_OUT(("AsyncSearch Started"));
	ASSERT(NULL != m_hThread);

	SetBusyCursor(TRUE);
	//	We can not call EnableWindow() from this thread as it av's some of the time.  This is a
	//	known windows bug.  It also doesn't really solve the problem (#4726) it was put in here
	//	to solve anyway.  We will work around this in a future build by re-architecting this so
	//	this little helper thread doesn't mess with the ui at all.  It is problematic and very
	//	inefficient anyway.
//	::EnableWindow(GetDlgItem(GetParent(GetHwnd()), IDM_DLGCALL_REFRESH), FALSE);

	m_fDirInProgress	= TRUE;
	m_dwTickStart		= ::GetTickCount();
	m_uniqueId			= 0;

	if( SUCCEEDED( WaitWithMessageLoop( m_hSearchMutex ) ) )
	{
		if (!FAvailable())
		{
			hr = E_ACCESSDENIED;
		}
		else if (!FOpenServer())
		{
			CloseServer();
			hr = E_FAIL;
		}
		else
		{
			hr = DoQuery();
		}

		SetBusyCursor(FALSE);	//	This should be moved outside the if so it is always executed...

	//	We can not call EnableWindow() from this thread as it av's some of the time.  This is a
	//	known windows bug.  It also doesn't really solve the problem (#4726) it was put in here
	//	to solve anyway.  We will work around this in a future build by re-architecting this so
	//	this little helper thread doesn't mess with the ui at all.  It is problematic and very
	//	inefficient anyway.
//		::EnableWindow(GetDlgItem(GetParent(GetHwnd()), IDM_DLGCALL_REFRESH), TRUE);

		HWND hwnd = GetHwnd();
		if (-1 == ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_FOCUSED))
		{
			// No selection - set focus to the first item
			ListView_SetItemState(hwnd, 0, LVIS_FOCUSED, LVIS_FOCUSED);
		}

		ReleaseMutex( m_hSearchMutex );

		if (FAILED(hr))
		{
			PostMessage(GetParent(hwnd), WM_DISPLAY_MSG, IDS_ULSLOGON_ERROR, 0);
		}

		WARNING_OUT(("AsyncSearch Complete"));

		// Close the thread handle safely
		HANDLE hThread = m_hThread;
		m_hThread = NULL;
		CloseHandle(hThread);
	}

	if (m_fDirInProgress)
	{
		// Only cache if data took more than 2 seconds to retrieve
		m_fIsCacheable = ((::GetTickCount() - m_dwTickStart) > 2000);
		m_fDirInProgress = FALSE;
	}

	DBGEXIT(CLDAP::AsyncSearch);
}




///////////////////////////////////////////////////////////////////////////


/*  F  O P E N  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: FOpenServer

    Make sure the connection to the LDAP server is open
-------------------------------------------------------------------------*/
BOOL CLDAP::FOpenServer(void)
{
	DBGENTRY(CLDAP::FOpenServer);

	BOOL bRet = TRUE;
	
	if( NULL == m_pLdap )
	{
		if( m_bSearchCancelled )
		{
			bRet = FALSE;
		}
		else
		{
			WARNING_OUT(("Opening Server [%s] Port [%d]", m_szAddress, m_ulPort));

			m_pLdap = WLDAP::ldap_open(m_szAddress, m_ulPort);

			if( (m_pLdap == NULL) && (m_ulPort == DEFAULT_LDAP_PORT) )
			{
				m_pLdap = WLDAP::ldap_open(m_szAddress, ALTERNATE_LDAP_PORT);		//	Automatically retry with alternate port...

				if( m_pLdap != NULL )
				{
					m_ulPort = ALTERNATE_LDAP_PORT;
				}
			}

			if(NULL != m_pLdap)
			{
				LONG lTimeOut = 30; // seconds for timeout
				WLDAP::ldap_set_option(m_pLdap, LDAP_OPT_TIMELIMIT, &lTimeOut);
				

				// Defaults to ILS 2
				ASSERT(LDAP_VERSION2 == m_pLdap->ld_version);

				ULONG ulRet = WLDAP::ldap_simple_bind_s(m_pLdap, NULL, NULL);

				WARNING_OUT(("Logon [%s] complete", m_szServer));
			}
			else
			{
				WARNING_OUT(("ldap_open err=%d", GetLastError()));
				return FALSE;
			}
		}
	}

	DBGEXIT(CLDAP::FOpenServer);
	return bRet;
}


/*  C L O S E  S E R V E R  */
/*-------------------------------------------------------------------------
    %%Function: CloseServer

-------------------------------------------------------------------------*/
VOID CLDAP::CloseServer(void)
{
	DBGENTRY(CLDAP::CloseServer);

	if(m_pLdap)
	{
		StopSearch();

		if( SUCCEEDED( WaitWithMessageLoop( m_hSearchMutex ) ) )
		{

			WLDAP::ldap_unbind(m_pLdap);
			m_pLdap = NULL;

			ReleaseMutex( m_hSearchMutex );
		}

		WARNING_OUT(("Logoff [%s] complete", m_szServer));
	}
}


/*  G E T  N E X T  A T T R I B U T E  */
/*-------------------------------------------------------------------------
    %%Function: GetNextAttribute

-------------------------------------------------------------------------*/
LPTSTR CLDAP::GetNextAttribute(LPCTSTR pszExpect, LPTSTR psz, int cchMax, LPTSTR pszAttrib, LDAPMessage * pEntry, BerElement * pElement)
{
	
	DBGENTRY(CLDAP::GetNextAttribute);

	ASSERT(NULL != psz);

	if ((NULL == pszAttrib) || (0 != lstrcmpi(pszAttrib, pszExpect)))
	{
		*psz = _T('\0');
	}
	else
	{
		LPTSTR * rgVal = WLDAP::ldap_get_values(m_pLdap, pEntry, pszAttrib);
		if( rgVal[0] )
		{
			lstrcpyn(psz, rgVal[0], cchMax);
		}
		else
		{
			psz[0] = _T('\0');
		}
		WLDAP::ldap_value_free(rgVal);

		pszAttrib = WLDAP::ldap_next_attribute(m_pLdap, pEntry, pElement);
	}


	DBGEXIT(CLDAP::GetNextAttribute);

	return pszAttrib;
}


/*  D O  Q U E R Y  */
/*-------------------------------------------------------------------------
    %%Function: DoQuery

-------------------------------------------------------------------------*/
HRESULT CLDAP::DoQuery(void)
{

	DBGENTRY(CLDAP::DoQuery);

	HRESULT hr = S_FALSE;

	ASSERT(FLoggedOn());

	TCHAR szSearch[MAX_PATH];
	ASSERT(CCHMAX(s_szSearchFormat3) + CCHMAX(s_szSearchCategory) < CCHMAX(szSearch));
	ASSERT(CCHMAX(s_szSearchFormat2) + CCHMAX(s_szSearchCategory) < CCHMAX(szSearch));

	if( !m_bSearchCancelled )
	{
		wsprintf(szSearch,
			(LDAP_VERSION2 == m_pLdap->ld_version) ? s_szSearchFormat2 : s_szSearchFormat3,
			(LDAP_VERSION2 == m_pLdap->ld_version) ? TEXT("%") : TEXT("*"), _T(""));
		ASSERT(lstrlen(szSearch) < CCHMAX(szSearch));

		ASSERT(0 == m_msgId); // one search at a time

		m_msgId = WLDAP::ldap_search(m_pLdap, (PCHAR) "objectClass=RTPerson", LDAP_SCOPE_BASE,
			szSearch, (PCHAR *) s_rgAttrNameAddr, 0);

		if( m_msgId == -1 )
		{
			m_msgId = 0;
			hr = E_FAIL;
		}
		else
		{
			SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0 );

			while( (0 != m_msgId) && (!m_bSearchCancelled) )
			{
				LDAP_TIMEVAL timeOut = {2, 0};
				LDAPMessage * pResult = NULL;
WARNING_OUT(("DoQuery calling ldap_result"));
				int iResult = WLDAP::ldap_result(m_pLdap, m_msgId, 0, &timeOut, &pResult);
WARNING_OUT( ("DoQuery back from ldap_result: 0x%08X", iResult) );
				if (0 == iResult)
				{
					SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0 );
					UpdateWindow( m_hWnd );
					SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0 );
					continue;
				}

				if (LDAP_RES_SEARCH_ENTRY != iResult)
				{
					// S_FALSE = abandoned
//					hr = (-1 == iResult) ? S_OK : S_FALSE;
					hr = (-1 == iResult) ? E_FAIL : S_FALSE;
					break;
				}

				AddEntries(pResult);

				WLDAP::ldap_msgfree(pResult);
			}

			SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0 );

			m_msgId = 0;
			DirComplete( TRUE );

			forceSort();
		}
	}

	DBGEXIT(CLDAP::DoQuery);
	return hr;
}


/*  A D D  E N T R I E S  */
/*-------------------------------------------------------------------------
    %%Function: AddEntries

    Add the Entries to the listbox.  (Data ordered by s_rgAttrNameAddr.)
-------------------------------------------------------------------------*/
VOID CLDAP::AddEntries(LDAPMessage * pResult)
{
	DBGENTRY(CLDAP::AddEntries);

	LDAPMessage * pEntry;
	BerElement  * pElement;

	for (pEntry = WLDAP::ldap_first_entry(m_pLdap, pResult);
		 NULL != pEntry;
		 pEntry = WLDAP::ldap_next_entry(m_pLdap, pEntry))
	{
		LPTSTR pszAttrib = WLDAP::ldap_first_attribute(m_pLdap, pEntry, &pElement);
		if (NULL == pszAttrib)
			break;

		// Must have a "Show Me" attribute
		if (0 != lstrcmpi(pszAttrib, s_cszAttribShow))
			continue;

		LPTSTR * rgVal = WLDAP::ldap_get_values(m_pLdap, pEntry, pszAttrib);
		BOOL fShow = (_T('1') == *rgVal[0]);
		WLDAP::ldap_value_free(rgVal);

		if (!fShow)
			continue;
		pszAttrib = WLDAP::ldap_next_attribute(m_pLdap, pEntry, pElement);

		TCHAR szEmail[CCHMAXSZ_EMAIL];
		pszAttrib = GetNextAttribute(s_cszAttribEmail, szEmail, CCHMAX(szEmail),
			pszAttrib, pEntry, pElement);

		TCHAR szFirstName[CCHMAXSZ_FIRSTNAME];
		pszAttrib = GetNextAttribute(s_cszAttribFirstName, szFirstName, CCHMAX(szFirstName),
			pszAttrib, pEntry, pElement);

		TCHAR szLastName[CCHMAXSZ_LASTNAME];
		pszAttrib = GetNextAttribute(s_cszAttribLastName, szLastName, CCHMAX(szLastName),
			pszAttrib, pEntry, pElement);

		TCHAR szLocation[CCHMAXSZ_LASTNAME];
		pszAttrib = GetNextAttribute(s_cszAttribLocation, szLocation, CCHMAX(szLocation),
			pszAttrib, pEntry, pElement);

		TCHAR szTemp[4];
		pszAttrib = GetNextAttribute(s_cszAttribInACall, szTemp, CCHMAX(szTemp),
			pszAttrib, pEntry, pElement);

		int iInCallImage = (szTemp[0] == _T('1')) ? II_IN_A_CALL : II_COMPUTER;

		pszAttrib = GetNextAttribute(s_cszAttribAudio, szTemp, CCHMAX(szTemp),
			pszAttrib, pEntry, pElement);

		int iAudioImage = (szTemp[0] == _T('1')) ? II_AUDIO_CAPABLE : 0;

		pszAttrib = GetNextAttribute(s_cszAttribVideo, szTemp, CCHMAX(szTemp),
			pszAttrib, pEntry, pElement);

		int iVideoImage = (szTemp[0] == _T('1')) ? II_VIDEO_CAPABLE : 0;

		TCHAR szComment[CCHMAXSZ_COMMENT];
		pszAttrib = GetNextAttribute(s_cszAttribComment, szComment, CCHMAX(szComment),
			pszAttrib, pEntry, pElement);

		lvAddItem( 0, iInCallImage, iAudioImage, iVideoImage, szEmail, szFirstName, szLastName, szLocation, szComment );
	}

	DBGEXIT(CLDAP::AddEntries);
}


//--------------------------------------------------------------------------//
//	CLDAP::lvAddItem.														//
//--------------------------------------------------------------------------//
int
CLDAP::lvAddItem
(
	int		item,
	int		iInCallImage,
	int		iAudioImage,
	int		iVideoImage,
	LPCTSTR	address,
	LPCTSTR	firstName,
	LPCTSTR	lastName,
	LPCTSTR	location,
	LPCTSTR	comments
){
	LV_ITEM	lvItem;

	ClearStruct( &lvItem );

	lvItem.mask			= LVIF_PARAM;
	lvItem.iItem		= item;
	lvItem.lParam		= m_uniqueId++;			// assign a unique lParam for this item

	int index	= ListView_InsertItem( m_hWnd, &lvItem );

	if( index != -1 )
	{
		if( lastName )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_LAST_NAME, (LPTSTR) lastName );
		}

		if( firstName )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_FIRST_NAME, (LPTSTR) firstName );
		}

		if( iAudioImage != 0 )
		{
			lvItem.mask		= LVIF_IMAGE;
			lvItem.iSubItem	= COLUMN_INDEX_AUDIO;
			lvItem.iImage	= iAudioImage;

			ListView_SetItem( m_hWnd, &lvItem );
		}

		if( iVideoImage != 0 )
		{
			lvItem.mask		= LVIF_IMAGE;
			lvItem.iSubItem	= COLUMN_INDEX_VIDEO;
			lvItem.iImage	= iVideoImage;

			ListView_SetItem( m_hWnd, &lvItem );
		}

		if( address )
		{
			lvItem.mask			= LVIF_IMAGE | LVIF_TEXT;
			lvItem.iSubItem		= COLUMN_INDEX_ADDRESS;
			lvItem.iImage		= iInCallImage;
			lvItem.pszText		= (LPTSTR) address;
			lvItem.cchTextMax	= lstrlen( lvItem.pszText );

			ListView_SetItem( m_hWnd, &lvItem );
		}

		if( location )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_LOCATION, (LPTSTR) location );
		}

		if( comments )
		{
			ListView_SetItemText( m_hWnd, index, COLUMN_INDEX_COMMENTS, (LPTSTR) comments );
		}
	}

	return( index );

}	//	End of CLDAP::lvAddItem.


/*  S T O P  S E A R C H  */
/*-------------------------------------------------------------------------
    %%Function: StopSearch

-------------------------------------------------------------------------*/
VOID CLDAP::StopSearch(void)
{
	DBGENTRY(CLDAP::StopSearch);

	m_bSearchCancelled = true;

	if (0 != m_msgId)
	{
//	Dont call ldap_abandon() from this thread as the search thread may be inside ldap_result()
//	at the time.  For now just set m_msgId to zero and the search thread will stop when ldap_result()
//	returns.
//		ULONG uResult = WLDAP::ldap_abandon(m_pLdap, m_msgId);
		WARNING_OUT(("Stopping Search..."));
		m_msgId = 0;

		m_fDirInProgress = FALSE;
		m_fIsCacheable = FALSE;

		DirComplete(FALSE);
	}

	DBGEXIT(CLDAP::StopSearch);
}



/*  F  G E T  U S E R  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: FGetUserData

    Get the data for a single user.
-------------------------------------------------------------------------*/
BOOL CLDAP::FGetUserData(LDAPUSERDATA * pLdapUserData)
{
	DBGENTRY(CLDAP::FGetUserData);
	ClearStruct(pLdapUserData);

	if (!FLoggedOn())
	{
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}

	int iItem = CALV::GetSelection();
	if (-1 == iItem)
	{
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}
	if (!GetSzData(pLdapUserData->szEmail, CCHMAX(pLdapUserData->szEmail), iItem, COLUMN_INDEX_ADDRESS))
	{
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}

	TCHAR szSearch[CCHMAX(s_szSearchFormat2) + CCHMAXSZ_EMAIL];
	wsprintf(szSearch,
		(LDAP_VERSION2 == m_pLdap->ld_version) ? s_szSearchFormat2 : s_szSearchFormat3,
		pLdapUserData->szEmail, g_cszEmpty);
	ASSERT(lstrlen(szSearch) < CCHMAX(szSearch));

	LDAPMessage * pResult = NULL;

	ULONG ulRet = WLDAP::ldap_search_s(m_pLdap, (LPTSTR) "objectClass=RTPerson", LDAP_SCOPE_BASE,
		szSearch, (PCHAR *) s_rgAttrAll, FALSE, &pResult);
	if (LDAP_SUCCESS != ulRet)
	{
		WLDAP::ldap_msgfree(pResult);
		WARNING_OUT(("ldap_search (code=%08X)", ulRet));
		DBGEXIT(CLDAP::FGetUserData);
		return FALSE;
	}

	LDAPMessage * pEntry = WLDAP::ldap_first_entry(m_pLdap, pResult);
	if (NULL != pEntry)
	{
		BerElement * pElement;
		LPTSTR pszAttrib = WLDAP::ldap_first_attribute(m_pLdap, pEntry, &pElement);
			// Make sure that the first attribute is s_cszAttribFirstName...
		if ((NULL != pszAttrib) && (0 == lstrcmpi(pszAttrib, s_cszAttribFirstName)))
		{
			LPTSTR * rgVal = WLDAP::ldap_get_values(m_pLdap, pEntry, pszAttrib);
			WLDAP::ldap_value_free(rgVal);
//			pszAttrib = WLDAP::ldap_next_attribute(m_pLdap, pEntry, pElement);

			pszAttrib = GetNextAttribute(s_cszAttribFirstName,
					pLdapUserData->szFirst, CCHMAX(pLdapUserData->szFirst),
					pszAttrib, pEntry, pElement);

			pszAttrib = GetNextAttribute(s_cszAttribLastName,
					pLdapUserData->szLast, CCHMAX(pLdapUserData->szLast),
					pszAttrib, pEntry, pElement);

			CombineNames(pLdapUserData->szName, CCHMAX(pLdapUserData->szName),
					pLdapUserData->szFirst, pLdapUserData->szLast);

			pszAttrib = GetNextAttribute(s_cszAttribComment,
					pLdapUserData->szComment, CCHMAX(pLdapUserData->szComment),
					pszAttrib, pEntry, pElement);

			TCHAR szTemp[4];
			pszAttrib = GetNextAttribute(s_cszAttribAudio, szTemp, CCHMAX(szTemp),
					pszAttrib, pEntry, pElement);
			pLdapUserData->fAudioSend = _T('1') == szTemp[0];
			pszAttrib = GetNextAttribute(s_cszAttribVideo, szTemp, CCHMAX(szTemp),
					pszAttrib, pEntry, pElement);
			pLdapUserData->fVideoSend = _T('1') == szTemp[0];

			pszAttrib = GetNextAttribute(s_cszAttribVersion,
				pLdapUserData->szVersion, CCHMAX(pLdapUserData->szVersion),
					pszAttrib, pEntry, pElement);
			pszAttrib = GetNextAttribute(s_cszAttribCategory, szTemp, CCHMAX(szTemp),
					pszAttrib, pEntry, pElement);
			ConvertVersionInfo(pLdapUserData->szVersion, szTemp);
		}
	}

	WLDAP::ldap_msgfree(pResult);

	DBGEXIT(CLDAP::FGetUserData);
	return TRUE;
}


/*  C O N V E R T  V E R S I O N  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: ConvertVersionInfo

-------------------------------------------------------------------------*/
VOID ConvertVersionInfo(LPTSTR pszVersion, LPTSTR pszCategory)
{
	UINT uVer = DecimalStringToUINT(pszVersion);

	if (0 == uVer)
	{
		lstrcpy(pszVersion, FEmptySz(pszCategory) ? TEXT("1.0") : TEXT("2"));
	}
	else
	{
		LPCTSTR pszRel;

		switch (LOBYTE(HIWORD(uVer)))
			{
		case 3:  pszRel = TEXT("2.11"); break;
		case 4:  pszRel = TEXT("3.0");  break;
		case 5:  pszRel = TEXT("4.0");  break;
		default: pszRel = g_cszEmpty;   break;
			}

		TCHAR szFormat[CCHMAXSZ];
		FLoadString(IDS_FORMAT_VERSION, szFormat, CCHMAX(szFormat));
		wsprintf(pszVersion, szFormat, pszRel,
			HIBYTE(HIWORD(uVer)), LOBYTE(HIWORD(uVer)), LOWORD(uVer));
	}
}

//--------------------------------------------------------------------------//
//	CLDAP::FreeDirCache.													//
//--------------------------------------------------------------------------//
void
CLDAP::FreeDirCache
(
	DIRCACHE *	pDirCache
){
	TRACE_OUT(("FreeDirCache [%s] filter=%d, expire=%d",
		pDirCache->pszServer, pDirCache->dwTickExpire));

	ASSERT(NULL != pDirCache);
	PBYTE pb = pDirCache->pData;
	delete pDirCache->pszServer;
	delete pDirCache;

	while (NULL != pb)
	{
		PBYTE pTemp = pb;
		pb = (PBYTE) * (DWORD_PTR *) pb;
		delete pTemp;
	}

}	//	End of CLDAP::FreeDirCache.


//--------------------------------------------------------------------------//
//	CLDAP::FreeDirCache.													//
//--------------------------------------------------------------------------//
void
CLDAP::DirComplete
(
	bool	//fPostUiUpdate
){

	if( m_fDirInProgress )
	{
		// Only cache if data took more than 2 seconds to retrieve
		m_fIsCacheable = ((::GetTickCount() - m_dwTickStart) > 2000);
		m_fDirInProgress = FALSE;
	}

	m_cTotalEntries	= 0;
	m_cEntries		= 0;

}	//	End of CLDAP:DirComplete.


//--------------------------------------------------------------------------//
//	CLDAP::GetSzName.														//
//--------------------------------------------------------------------------//
BOOL
CLDAP::GetSzName
(
	LPTSTR	psz,
	int		cchMax,
	int		iItem
){
	TCHAR	szOrder[ MAX_PATH ];

	bool	bFirstNameFirst	= ((::LoadString( ::GetInstanceHandle(), IDS_NAME_ORDER, szOrder, CCHMAX(szOrder)) == 0) ||
								(_T( '1' ) == szOrder[ 1 ]));

	int		iFirst			= bFirstNameFirst? COLUMN_INDEX_FIRST_NAME: COLUMN_INDEX_LAST_NAME;
	int		iLast			= bFirstNameFirst? COLUMN_INDEX_LAST_NAME: COLUMN_INDEX_FIRST_NAME;

	GetSzData( psz, cchMax, iItem, iFirst );

	int	length	= lstrlen( psz );

	if( (length > 0) && (length < cchMax - 1) )
	{
		lstrcat( psz, TEXT( " " ) );
		length++;
	}

	GetSzData( &psz[ length ], cchMax - length, iItem, iLast );

	return( lstrlen( psz ) > 0 );

}	//	End of CLDAP::GetSzName.


static const int	CDIRCACHE_SZ	= 5;	//	number of strings
static const int	CDIRCACHE_IMAGE	= 3;	//	number of images


//--------------------------------------------------------------------------//
//	CLDAP::CacheServerData.													//
//--------------------------------------------------------------------------//
void
CLDAP::CacheServerData(void)
{
	DIRCACHE * pDirCache;

	if (!m_fCacheDirectory)
		return; // User disabled directory caching

	if (!m_fIsCacheable)
	{
		TRACE_OUT(("CacheServerData: not caching [%s]", m_szServer));
		return;
	}

	if (m_fDirInProgress)
		return; // don't cache partial data

	// Remove any previous cached data
	POSITION pos = FindCachedData();

	if (NULL != pos)
	{
		pDirCache = (DIRCACHE *) m_listDirCache.RemoveAt(pos);
		ASSERT(NULL != pDirCache);
		FreeDirCache(pDirCache);
	}

	DWORD dwTickExpire = m_dwTickStart + (m_cMinutesExpire * 60000);

	if (dwTickExpire < GetTickCount())
	{
		TRACE_OUT(("CacheServerData: [%s] data has expired", m_szServer));
		return; // data is already expired
	}

	int cItems = ListView_GetItemCount(m_hWnd);
	if (0 == cItems)
		return; // nothing to cache

	pDirCache = new DIRCACHE;
	if (NULL == pDirCache)
		return;

	pDirCache->pszServer = PszAlloc(m_szServer);
	pDirCache->dwTickExpire = dwTickExpire;
	pDirCache->pData = NULL;

	LPTSTR pPrev = (LPTSTR) &pDirCache->pData;

	m_listDirCache.AddTail(pDirCache);

	LV_ITEM lvi;
	lvi.cchTextMax = MAX_PATH;
	for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
	{
		int		iInCallImage	= -1;
		int		iAudioImage		= -1;
		int		iVideoImage		= -1;
		int		i				= 0;			// index into rgcb, rgsz
		int		cb				= 0;			// total length of string data
		int		rgcb[CDIRCACHE_SZ];				// size of each string
		TCHAR	rgsz[CDIRCACHE_SZ][MAX_PATH];	// string buffers

		// Get the string data for each column
		lvi.mask = LVIF_IMAGE;
		for (lvi.iSubItem = 0; lvi.iSubItem < MAX_DIR_COLUMNS; lvi.iSubItem++)
		{
			if( (lvi.iSubItem != COLUMN_INDEX_AUDIO) && (lvi.iSubItem != COLUMN_INDEX_VIDEO) )
			{
				lvi.mask |= LVIF_TEXT;
				lvi.pszText = rgsz[i];
				ListView_GetItem(m_hWnd, &lvi);
				rgcb[i] = lstrlen(lvi.pszText);
				cb += rgcb[i] + 1;		//	Plus one for the NULL...
				i++;

				if( lvi.iSubItem == COLUMN_INDEX_ADDRESS )
				{
					iInCallImage = lvi.iImage;
				}
			}
			else
			{
				lvi.mask &= ~LVIF_TEXT;
				ListView_GetItem(m_hWnd, &lvi);

				if( lvi.iSubItem == COLUMN_INDEX_AUDIO )
				{
					iAudioImage = lvi.iImage;
				}
				else if( lvi.iSubItem == COLUMN_INDEX_VIDEO)
				{
					iVideoImage = lvi.iImage;
				}
			}
		}

		// allocate space for: a link (DWORD), strings (cb), images (CDIRCACHE_IMAGES)
		PBYTE pData = new BYTE[ sizeof(DWORD_PTR) + cb + CDIRCACHE_IMAGES ];
		if (NULL == pData)
		{
			// can't hold all data - give up and return
			ClearServerCache();
			return;
		}
		* ((DWORD_PTR *) pData) = 0;  // link to next item is null
		PBYTE pb = pData + sizeof(DWORD_PTR);

		// copy the string data into the buffer
		for (i = 0; i < CDIRCACHE_SZ; i++)
		{
			lstrcpy((LPTSTR) pb, rgsz[i]);
			pb += rgcb[i] + 1;
		}

		*pb++ = (BYTE) iInCallImage;
		*pb++ = (BYTE) iAudioImage;
		*pb = (BYTE) iVideoImage;
		* ((DWORD_PTR *) pPrev) = (DWORD_PTR) pData; // link into the previous data
		pPrev = (LPTSTR) pData;
	}

	TRACE_OUT(("CacheServerData: [%s]  expire=%d",
		m_szServer, dwTickExpire));

}	//	End of CLDAP::CacheServerData.


//--------------------------------------------------------------------------//
//	CLDAP::FindCachedData.													//
//--------------------------------------------------------------------------//
POSITION
CLDAP::FindCachedData(void)
{
	DWORD dwTick = GetTickCount();
	TRACE_OUT(("Searching for cached data on [%s]", m_szServer));

	POSITION pos = m_listDirCache.GetHeadPosition();
	while (NULL != pos)
	{
		POSITION posSav = pos;
		DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.GetNext(pos);
		ASSERT(NULL != pDirCache);
		if ((0 == lstrcmp(m_szServer, pDirCache->pszServer)) &&
			(pDirCache->dwTickExpire > dwTick))
		{
			return posSav;
		}
	}

	return NULL;

}	//	End of CLDAP::FindCachedData.


//--------------------------------------------------------------------------//
//	CLDAP::ClearServerCache.												//
//--------------------------------------------------------------------------//
void
CLDAP::ClearServerCache(void)
{
	DWORD dwTick = GetTickCount();

	POSITION pos = m_listDirCache.GetHeadPosition();
	while (NULL != pos)
	{
		POSITION posSav = pos;
		DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.GetNext(pos);
		ASSERT(NULL != pDirCache);
		
		if ( (0 == lstrcmp(m_szServer, pDirCache->pszServer)) || (pDirCache->dwTickExpire < dwTick) )
		{
			m_listDirCache.RemoveAt(posSav);
			FreeDirCache(pDirCache);
		}
#ifdef DEBUG
		else
		{
			TRACE_OUT(("Keeping cached data for [%s] , expire=%d",
				pDirCache->pszServer, pDirCache->dwTickExpire));
		}
#endif /* DEBUG */
	}

}	//	End of CLDAP::ClearServerCache.


//--------------------------------------------------------------------------//
//	CLDAP::DisplayDirectory.												//
//--------------------------------------------------------------------------//
void
CLDAP::DisplayDirectory(void)
{
	POSITION pos = FindCachedData();

	if (NULL == pos)
	{
		// no cached information - request new data
		StartSearch();
		return;
	}

	DIRCACHE * pDirCache = (DIRCACHE *) m_listDirCache.GetFromPosition(pos);
	ASSERT(NULL != pDirCache);
	LPTSTR pDirLine = (LPTSTR) pDirCache->pData;

	StopSearch(); // In case the previous server is slow
	CALV::ClearItems();

	m_fIsCacheable = FALSE; // don't bother attempting to re-cache this data

	// Restore the cached server information
	TRACE_OUT(("Restoring cached data for [%s]  expire=%d",
		m_szServer, pDirCache->dwTickExpire));

	SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0 );

	while (NULL != pDirLine)
	{
		DWORD_PTR *pNext	= * (DWORD_PTR * * ) pDirLine; pDirLine += sizeof(DWORD_PTR);
		LPTSTR pszEmail		= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszLast		= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszFirst		= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszLocation	= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		LPTSTR pszComment	= (LPTSTR) pDirLine; pDirLine += lstrlen(pDirLine)+1;
		int iiCall			= (int) * (char *) pDirLine; pDirLine++;
		int iiAudio			= (int) * (char *) pDirLine; pDirLine++;
		int iiVideo			= (int) * (char *) pDirLine;

		lvAddItem( 0, iiCall, iiAudio, iiVideo, pszEmail, pszFirst, pszLast, pszLocation, pszComment );

		pDirLine = (LPTSTR) pNext;
	}

	forceSort();
	SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0 );

}	//	End of CLDAP::DisplayDirectory.


//--------------------------------------------------------------------------//
//	CLDAP::forceSort.														//
//--------------------------------------------------------------------------//
void
CLDAP::forceSort(void)
{
	NM_LISTVIEW	nmlv;

	nmlv.hdr.code		= LVN_COLUMNCLICK;
	nmlv.hdr.hwndFrom	= m_hWnd;
	nmlv.iSubItem		= -1;	//	default sort column...

	SendMessage( GetParent( m_hWnd ), WM_NOTIFY, GetDlgCtrlID( m_hWnd ), (LPARAM) &nmlv );

}	//	End of CLDAP::forceSort.


//--------------------------------------------------------------------------//
//	CLDAP::GetIconId.														//
//--------------------------------------------------------------------------//
int
CLDAP::GetIconId(LPCTSTR psz)
{

	return( CDirectoryManager::isWebDirectory( psz )? II_WEB_DIRECTORY: CALV::GetIconId( NULL ) );

}	//	End of CLDAP::GetIconId.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\makefile.inc ===
#That forces BUILD.EXE to rebuild the rc file when the .rgs files change
conf.rc:  $(O)\NetMeeting.tlb NetMeeting.rgs VideoWindow.rgs NmManager.rgs NmApp.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\ldap.h ===
// File: ldap.h

#ifndef _CLDAP_H_
#define _CLDAP_H_

#include <winldap.h>
#include "oblist.h"
#include "calv.h"


#define LDAP_PORT_W2K		1002			//	Default W2K ldap port (1002)...
#define	DEFAULT_LDAP_PORT	LDAP_PORT_W2K
#define	ALTERNATE_LDAP_PORT	LDAP_PORT


// Generic user data
typedef struct {
	TCHAR szEmail[CCHMAXSZ_EMAIL];
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szFirst[CCHMAXSZ_FIRSTNAME];
	TCHAR szLast[CCHMAXSZ_LASTNAME];
	TCHAR szComment[CCHMAXSZ_COMMENT];
	TCHAR szVersion[CCHMAXSZ_VERSION];
	BOOL  fAudioSend;
	BOOL  fVideoSend;
} LDAPUSERDATA;

typedef struct _dirCache {
	LPTSTR pszServer;         // the server name
	DWORD  dwTickExpire;      // expiration time
	LPBYTE pData;             // pointer to linked list of server data
} DIRCACHE;


class CLDAP : public CALV
{
private:
	LDAP * m_pLdap;
	ULONG  m_ulPort;
	TCHAR  m_szServer[CCHMAXSZ_SERVER];
	TCHAR  m_szAddress[CCHMAXSZ_SERVER];
	HANDLE m_hThread;
	ULONG  m_msgId;
	HWND   m_hWnd;
	HANDLE	m_hSearchMutex;
	bool	m_bSearchCancelled;

public:
	// Constructor and destructor
	CLDAP();
	~CLDAP();

	VOID SetServer(LPCTSTR pcszServer);
	LPCTSTR PszServer(void)   {return m_szServer;}

	BOOL FLoggedOn(void)      {return (NULL != m_pLdap);}
	BOOL FOpenServer(void);
	VOID CloseServer(void);
	HRESULT DoQuery(void);
	VOID AddEntries(LDAPMessage * pResult);
	BOOL FGetUserData(LDAPUSERDATA * pLdapUserData);
	LPTSTR GetNextAttribute(LPCTSTR pszExpect, LPTSTR psz, int cchMax, LPTSTR pszAttrib, LDAPMessage * pEntry, BerElement * pElement);

	VOID StopSearch(void);
	VOID StartSearch(void);
	VOID AsyncSearch(void);
	static DWORD CALLBACK _sAsyncSearchThreadFn(LPVOID pv);
	VOID EnsureThreadStopped(void);

	static DWORD CALLBACK _sAsyncPropertyThreadFn(LPVOID pv);
	VOID ShowProperties(void);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID ClearItems(void);
	BOOL GetSzAddress(LPTSTR psz, int cchMax, int iItem);
	VOID OnCommand(WPARAM wParam, LPARAM lParam);
	VOID CmdProperties(void);
	VOID CmdAddToWab(void);
	virtual RAI * GetAddrInfo(void);
	BOOL GetSzName(LPTSTR psz, int cchMax, int iItem);

	void
	CacheServerData(void);

	int  GetIconId(LPCTSTR psz);

private:

	void
	forceSort(void);

	int
	lvAddItem
	(
		int		item,
		int		iInCallImage,
		int		iAudioImage,
		int		iVideoImage,
		LPCTSTR	address,
		LPCTSTR	firstName,
		LPCTSTR	lastName,
		LPCTSTR	location,
		LPCTSTR	comments
	);

	void
	FreeDirCache
	(
		DIRCACHE *	pDirCache
	);

	void
	DirComplete
	(
		bool	fPostUiUpdate
	);

	POSITION
	FindCachedData(void);

	void
	ClearServerCache(void);

	void
	DisplayDirectory(void);

private:

	int			m_uniqueId;
	BOOL		m_fDirInProgress;
	UINT		m_cTotalEntries;
	UINT		m_cEntries;
	BOOL		m_fHaveRefreshed;
	DWORD		m_dwTickStart;
	BOOL        m_fIsCacheable;   // Data can be cached
	BOOL		m_fNeedsRefresh;
	BOOL		m_fCancelling;
	BOOL        m_fCacheDirectory; // TRUE if directory data should be cached
	DWORD       m_cMinutesExpire;  // Number of minutes before cached data expires
	COBLIST     m_listDirCache;    // list of cached data (DIRCACHE)
};


#endif /* _CLDAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mail.h ===
#ifndef _MAIL_H_
#define _MAIL_H_


// Read win.ini and determine if Simple MAPI is available
BOOL IsSimpleMAPIInstalled(void);
// Check to see if Athena is the default mail client
BOOL IsAthenaDefault(void);

// Send a mail message
VOID SendMailMsg(LPTSTR pszAddr, LPTSTR pszName);

// Are we in the middle of sending a mail message
BOOL IsSendMailInProgress(void);

/* Create a Conference Shortcut and bring up a mail message with */
/* the shortcut included as an attachment. */
BOOL CreateInvitationMail(LPCTSTR pszMailAddr, LPCTSTR pszMailName,
                          LPCTSTR pcszName, LPCTSTR pcszAddress, 
                          DWORD dwTransport, BOOL fMissedYou);

#endif // _MAIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mail.cpp ===
// File: mail.cpp

#include "precomp.h"
#include "resource.h"
#include <mapi.h>
#include <clinkid.h>
#include <clink.h>
#include "mail.h"
#include "ConfUtil.h"

typedef struct _tagMAIL_ADDRESS
{
	LPTSTR pszAddress;
	LPTSTR pszDisplayName;
} MAIL_ADDRESS, *LPMAIL_ADDRESS;


// Send an e-mail message using the default mail provider
HRESULT SendMailMessage(LPMAIL_ADDRESS pmaTo, LPCTSTR pcszSubject,
						LPCTSTR pcszText, LPCTSTR pcszFile);

/* Given an existing Conference Shortcut, bring up a mail message with */
/* it included as an attachment.  The Conference Shortcut should have */
/* been saved to disk prior to this call. */
BOOL SendConfLinkMail(LPMAIL_ADDRESS pmaTo, IConferenceLink* pconflink, LPCTSTR pcszNoteText);



/////////////////////////////////////////////////////////////////////////////////////
// These variables are only used in this module, so we will make them static...
// This keeps it out of the global namespace but more importantly it tells
// the person reading this code that they don't have to worry about any othur
// source file changing the variables directly...
static HANDLE s_hSendMailThread = NULL;
static const TCHAR s_cszWinIniMail[] = _TEXT("Mail");
static const TCHAR s_cszWinIniMAPI[] = _TEXT("MAPI");

// MAPISendMail:
typedef ULONG (FAR PASCAL *LPMSM)(LHANDLE,ULONG,lpMapiMessage,FLAGS,ULONG);

BOOL IsSimpleMAPIInstalled()
{
	return (BOOL) GetProfileInt(s_cszWinIniMail, s_cszWinIniMAPI, 0);
}

BOOL CreateInvitationMail(LPCTSTR pszMailAddr, LPCTSTR pszMailName,
                          LPCTSTR pcszName, LPCTSTR pcszAddress,
                          DWORD dwTransport, BOOL fMissedYou)
{
	BOOL bRet = FALSE;
	TCHAR szTempFile[MAX_PATH];
	WCHAR wszTempFile[MAX_PATH];

	ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
	ASSERT(IS_VALID_STRING_PTR(pcszAddress, CSTR));
	// password not supported yet
	// ASSERT(IS_VALID_STRING_PTR(pcszPassword, CSTR));
	
	LPTSTR pszFileName = NULL;
	if (0 == GetTempPath(MAX_PATH, szTempFile))
	{
		ERROR_OUT(("GetTempPath failed!"));
		return FALSE;
	}

	pszFileName = szTempFile + lstrlen(szTempFile);

	// the +3 is for null terminators
	// append the conference name and the shortcut extension to the temp directory
	if (((lstrlen(pcszName) + lstrlen(szTempFile) + lstrlen(g_cszConfLinkExt) + 3)
			> sizeof(szTempFile)) ||
		(0 == lstrcat(szTempFile, pcszName)) ||
		(0 == lstrcat(szTempFile, g_cszConfLinkExt)))
	{
		ERROR_OUT(("Could not create temp file name!"));
		return FALSE;
	}

	// Filter names to allow only legal filename characters
	SanitizeFileName(pszFileName);

	// convert to UNICODE because IPersistFile interface expects UNICODE
	if (0 == MultiByteToWideChar(CP_ACP,
								0L,
								szTempFile,
								sizeof(szTempFile),
								wszTempFile,
								sizeof(wszTempFile)))
	{
		ERROR_OUT(("Could not create wide temp file string!"));
		return FALSE;
	}

	IUnknown* punk = NULL;
	
	// Create a ConfLink object - try to obtain an IUnknown pointer
	HRESULT hr = CoCreateInstance(	CLSID_ConfLink, 
									NULL,
									CLSCTX_INPROC_SERVER |
										CLSCTX_INPROC_HANDLER |
										CLSCTX_LOCAL_SERVER,
									IID_IUnknown,
									(LPVOID*) &punk);
	if (FAILED(hr))
	{
		ERROR_OUT(("CoCreateInstance ret %lx", (DWORD)hr));
		return FALSE;
	}

		ASSERT(IS_VALID_INTERFACE_PTR(punk, IUnknown));
		
		// Try to obtain a IConferenceLink pointer
		IConferenceLink* pcl = NULL;
		hr = punk->QueryInterface(IID_IConferenceLink, (LPVOID*) &pcl);
		
		if (SUCCEEDED(hr))
		{
			ASSERT(IS_VALID_INTERFACE_PTR(pcl, IConferenceLink));
			
			// Set the conference name and address
			pcl->SetAddress(pcszAddress);
			pcl->SetName(pcszName);
			pcl->SetTransport(dwTransport);
			pcl->SetCallFlags(CRPCF_DEFAULT);

			// Try to obtain a IPersistFile pointer
			IPersistFile* ppf = NULL;
			hr = punk->QueryInterface(IID_IPersistFile, (LPVOID*) &ppf);

			if (SUCCEEDED(hr))
			{
				ASSERT(IS_VALID_INTERFACE_PTR(ppf, IPersistFile));
			
				// Save the object using the filename generated above
				hr = ppf->Save(wszTempFile, TRUE);
				
				// Release the IPersistFile pointer
				ppf->Release();
				ppf = NULL;

				TCHAR szNoteText[512];
				if (fMissedYou)
				{
					TCHAR szFormat[MAX_PATH];
					if (FLoadString(IDS_MISSED_YOU_FORMAT, szFormat, CCHMAX(szFormat)))
					{
						RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
						wsprintf(szNoteText, szFormat, reULS.GetString(REGVAL_ULS_NAME));
					}
				}
				else
				{
					FLoadString(IDS_SEND_MAIL_NOTE_TEXT, szNoteText, CCHMAX(szNoteText));
				}

				MAIL_ADDRESS maDestAddress;
				maDestAddress.pszAddress = (LPTSTR) pszMailAddr;
				maDestAddress.pszDisplayName = (LPTSTR) pszMailName;

				// Send it using MAPI
				bRet = SendConfLinkMail(&maDestAddress, pcl, szNoteText);
			}
			// Release the IConferenceLink pointer
			pcl->Release();
			pcl = NULL;
		}

		// Release the IUnknown pointer
		punk->Release();
		punk = NULL;

	return bRet;
}

// SendConfLinkMail creates a mail message using Simple MAPI and attaches one
// file to it - a Conference Shortcut which is passed in via the IConferenceLink
// interface pointer.

BOOL SendConfLinkMail(LPMAIL_ADDRESS pmaTo, IConferenceLink* pconflink, LPCTSTR pcszNoteText)
{
	ASSERT(IS_VALID_INTERFACE_PTR((PCIConferenceLink)pconflink, IConferenceLink));
	HRESULT hr = E_FAIL;

	// File
	TCHAR szFile[MAX_PATH];
	LPOLESTR	pwszFile = NULL;
	IPersistFile* pPersistFile = NULL;

	if (SUCCEEDED(pconflink->QueryInterface(IID_IPersistFile,
											(LPVOID*) &pPersistFile)))
	{
		
		if (SUCCEEDED(pPersistFile->GetCurFile(&pwszFile)))
		{
#ifndef _UNICODE
			WideCharToMultiByte(CP_ACP,
								0L,
								pwszFile,
								-1,
								szFile,
								sizeof(szFile),
								NULL,
								NULL);

			// Free the string using the Shell Allocator
			LPMALLOC pMalloc = NULL;
			if (SUCCEEDED(SHGetMalloc(&pMalloc)))
			{
				pMalloc->Free(pwszFile);
				pwszFile = NULL;
				pMalloc->Release();
				pMalloc = NULL;
			}

#else  // ndef _UNICODE
#error Unicode not handled here!
#endif // ndef _UNICODE

			hr = SendMailMessage(pmaTo, NULL, pcszNoteText, szFile);
			// BUGBUG: need unique ret val for this case
			// BUGBUG: should we move error UI out of this function?
			if (FAILED(hr))
			{
				::PostConfMsgBox(IDS_CANT_SEND_SENDMAIL_IN_PROGRESS);
			}
		}
		else
		{
			ERROR_OUT(("GetCurFile failed - can't send message!"));
			pPersistFile->Release();
			return FALSE;
		}
		pPersistFile->Release();
	}
	else
	{
		ERROR_OUT(("Did not get IPersistFile pointer - can't send message!"));
		return FALSE;
	}
	
	return SUCCEEDED(hr);
}

//
// BEGIN STOLEN CODE FROM IE 3.0 (sendmail.c) -------------------------------
//

const TCHAR g_cszAthenaV1Name[] = _TEXT("Internet Mail and News");
const TCHAR g_cszAthenaV2Name[] = _TEXT("Outlook Express");
const TCHAR g_cszAthenaV1DLLPath[] = _TEXT("mailnews.dll");

BOOL IsAthenaDefault()
{
	TCHAR szAthena[80];
	LONG cb = ARRAY_ELEMENTS(szAthena);

	return (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, REGVAL_IE_CLIENTS_MAIL, szAthena, &cb)) &&
			((lstrcmpi(szAthena, g_cszAthenaV1Name) == 0) ||
				(lstrcmpi(szAthena, g_cszAthenaV2Name) == 0));
}

HMODULE LoadMailProvider()
{
    TCHAR szMAPIDLL[MAX_PATH];

    if (IsAthenaDefault())
    {
		RegEntry reMailClient(REGVAL_IE_CLIENTS_MAIL, HKEY_LOCAL_MACHINE);
		PTSTR pszMailClient = reMailClient.GetString(NULL);
		if ((NULL != pszMailClient) && (_T('\0') != pszMailClient[0]))
		{
			reMailClient.MoveToSubKey(pszMailClient);
			PTSTR pszDllPath = reMailClient.GetString(REGVAL_MAIL_DLLPATH);
			if ((NULL == pszDllPath) || (_T('\0') == pszDllPath[0]))
			{
				pszDllPath = (PTSTR) g_cszAthenaV1DLLPath;
			}
			return ::LoadLibraryEx(pszDllPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
		}
		else
		{
			ERROR_OUT(("No e-mail client in registry but IsAthenaDefault() returned TRUE"));
		}
	}

    // read win.ini (bogus hu!) for mapi dll provider
    if (GetProfileString(	TEXT("Mail"), TEXT("CMCDLLName32"), TEXT(""),
							szMAPIDLL, ARRAY_ELEMENTS(szMAPIDLL)) <= 0)
        lstrcpy(szMAPIDLL, TEXT("mapi32.dll"));

    return ::LoadLibraryEx(szMAPIDLL, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
}

typedef struct {
	TCHAR szToAddress[MAX_PATH];
	TCHAR szToDisplayName[MAX_PATH];
	TCHAR szSubject[MAX_PATH];
	TCHAR szText[MAX_PATH];
	TCHAR szFile[MAX_PATH];
	BOOL fDeleteFile;
	MapiMessage mm;
	MapiRecipDesc mrd;
	MapiFileDesc mfd;
} MAPI_FILES;

MAPI_FILES* _AllocMapiFiles(LPMAIL_ADDRESS pmaTo, LPCTSTR pcszSubject,
							LPCTSTR pcszText, LPCTSTR pcszFile, BOOL fDeleteFile)
{
	MAPI_FILES* pmf = new MAPI_FILES;
	if (pmf)
	{
		::ZeroMemory(pmf, sizeof(MAPI_FILES));
		pmf->fDeleteFile = fDeleteFile;
		if (NULL != pcszSubject)
		{
			lstrcpyn(pmf->szSubject, pcszSubject, CCHMAX(pmf->szSubject));
		}
		else
		{
			pmf->szSubject[0] = _T('\0');
		}
		if (NULL != pcszText)
		{
			lstrcpyn(pmf->szText, pcszText, CCHMAX(pmf->szText));
		}
		else
		{
			pmf->szText[0] = _T('\0');
		}
		pmf->mm.nFileCount = (NULL != pcszFile) ? 1 : 0;
		if (pmf->mm.nFileCount)
		{
			lstrcpyn(pmf->szFile, pcszFile, CCHMAX(pmf->szFile));
			pmf->mm.lpFiles = &(pmf->mfd);
			pmf->mfd.lpszPathName = pmf->szFile;
			pmf->mfd.lpszFileName = pmf->szFile;
			pmf->mfd.nPosition = (UINT)-1;
		}
		pmf->mm.lpszSubject = pmf->szSubject;
		pmf->mm.lpszNoteText = pmf->szText;

		if( ( NULL != pmaTo ) && !FEmptySz(pmaTo->pszAddress ) )
		{
			pmf->mm.lpRecips = &(pmf->mrd);

			pmf->mrd.ulRecipClass = MAPI_TO;
			pmf->mm.nRecipCount = 1;

			// If we're sending via Athena and a friendly name is specified, 
			// we pass both the friendly name and address.  If we're sending 
			// via Simple MAPI, we pass just the address in the name field.
			// This is necessary so that the email client can do the address 
			// resolution as appropriate for the installed mail system.  This
			// is not necessary for Athena since it assumes that all addresses
			// are SMTP addresses.

			if (IsAthenaDefault() 
				&& NULL != pmaTo->pszDisplayName && _T('\0') != pmaTo->pszDisplayName[0])
			{
				lstrcpyn(
					pmf->szToDisplayName, 
					pmaTo->pszDisplayName,
					CCHMAX(pmf->szToDisplayName));
				pmf->mrd.lpszName = pmf->szToDisplayName;

				lstrcpyn(
					pmf->szToAddress, 
					pmaTo->pszAddress, 
					CCHMAX(pmf->szToAddress));
				pmf->mrd.lpszAddress = pmf->szToAddress;
			}
			else
			{
				lstrcpyn(
					pmf->szToDisplayName, 
					pmaTo->pszAddress, 
					CCHMAX(pmf->szToDisplayName));
				pmf->mrd.lpszName = pmf->szToDisplayName;
				
				pmf->mrd.lpszAddress = NULL;
			}
		}
		else
		{
			// No recepients
			pmf->mm.lpRecips = NULL;
		}
	}
	return pmf;
}

VOID _FreeMapiFiles(MAPI_FILES *pmf)
{
	if (pmf->fDeleteFile)
	{
		::DeleteFile(pmf->szFile);
	}
	delete pmf;
}

STDAPI_(DWORD) MailRecipientThreadProc(LPVOID pv)
{
	DebugEntry(MailRecipientThreadProc);
	MAPI_FILES* pmf = (MAPI_FILES*) pv;
	
	DWORD dwRet = S_OK;

	if (pmf)
	{
		HMODULE hmodMail = LoadMailProvider();
		if (hmodMail)
		{
			LPMSM pfnSendMail;
			if (pfnSendMail = (LPMSM) ::GetProcAddress(hmodMail, "MAPISendMail"))
			{
				dwRet = pfnSendMail(0, 0, &pmf->mm, MAPI_LOGON_UI | MAPI_DIALOG, 0);
			}
			::FreeLibrary(hmodMail);
		}
		_FreeMapiFiles(pmf);
	}
		
		// s_hSendMailThread can't be NULL because we don't resume this thread
		// until s_hSendMailThread is set to a non-null value, so this is a sanity check
	ASSERT(s_hSendMailThread);		

			
	HANDLE hThread = s_hSendMailThread;

	s_hSendMailThread = NULL;
	::CloseHandle(hThread);

	DebugExitULONG(MailRecipientThreadProc, dwRet);
	return dwRet;
}

//
// END STOLEN CODE FROM IE 3.0 (sendmail.c) ---------------------------------
//


VOID SendMailMsg(LPTSTR pszAddr, LPTSTR pszName)
{
	// Create Send Mail structure to pass on
	MAIL_ADDRESS maDestAddress;
	maDestAddress.pszAddress = pszAddr;
	maDestAddress.pszDisplayName = pszName;
    
        // We are adding the callto://pszName link 
        // to the body of the e-mail message
    TCHAR sz[MAX_PATH];
    lstrcpy( sz, RES2T(IDS_NMCALLTOMAILTEXT) );
    lstrcat( sz, pszAddr );
        
        // Only send the text part if pszName is not a NULL string
	HRESULT hr = SendMailMessage(&maDestAddress, NULL, ( *pszAddr ) ? sz : NULL, NULL);
	if (FAILED(hr))
	{
		::PostConfMsgBox(IDS_CANT_SEND_SENDMAIL_IN_PROGRESS);
	}
}


const int MESSAGE_THREAD_SHUTDOWN_TIMEOUT = 5000; // milliseconds

HRESULT SendMailMessage(LPMAIL_ADDRESS pmaTo, LPCTSTR pcszSubject,
						LPCTSTR pcszText, LPCTSTR pcszFile)
{
	DebugEntry(SendMailMessage);
	HRESULT hr = E_FAIL;

	if (NULL != s_hSendMailThread)
	{
		// Athena takes a while to get out of MAPISendMail after the message is closed,
		// so we wait around a few seconds in case you just finished sending a message..
		HCURSOR hCurPrev = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
		::WaitForSingleObject(s_hSendMailThread, MESSAGE_THREAD_SHUTDOWN_TIMEOUT);
		::SetCursor(hCurPrev);
	}

	if (NULL == s_hSendMailThread)
	{
		MAPI_FILES* pmf = _AllocMapiFiles(	pmaTo, pcszSubject, pcszText,
											pcszFile, TRUE);
		if (NULL != pmf)
		{
			DWORD dwThreadID;

				// We create the thread suspended because in the thread fn
				// we call closehandle on s_hSendMailThread...if we create
				// the thread not suspended there is a race condition where
				// s_hSendMailThread may not have been assigned the return
				// value of CreateThread before it is checked in the thread fn

			s_hSendMailThread = ::CreateThread(	NULL,
												0,
												MailRecipientThreadProc,
												pmf,
												CREATE_SUSPENDED,
												&dwThreadID);

				// If the thread was created, we have to call Resume Thread...
			if( s_hSendMailThread )
			{
				if( 0xFFFFFFFF != ResumeThread( s_hSendMailThread ) )
				{
					hr = S_OK;
				}
				else
				{
					// This would indicate an error...
					hr = HRESULT_FROM_WIN32(GetLastError());
				}
			}
			else
			{
				hr = HRESULT_FROM_WIN32(GetLastError());
			}
		}
	}
	else
	{
		WARNING_OUT(("can't send mail - mail thread already in progress"));
	}

	DebugExitHRESULT(SendMailMessage, hr);
	return hr;
}

BOOL IsSendMailInProgress()
{
	return (NULL != s_hSendMailThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\global.h ===
// File: global.h
//
// Global NetMeeting UI definitions

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#define TAPI_CURRENT_VERSION 0x00010004

#ifndef WS_EX_NOINHERIT_LAYOUT
#define WS_EX_NOINHERIT_LAYOUT   0x00100000L // Disable inheritence of mirroring by children
#endif

inline HINSTANCE GetInstanceHandle()	{ return _Module.GetResourceModule(); }

// colors:
#define TOOLBAR_MASK_COLOR                 (RGB(255,   0, 255)) // MAGENTA
#define TOOLBAR_HIGHLIGHT_COLOR	           (RGB(255, 255, 255)) // WHITE

// string constants
const UINT  CCHMAXUINT =         12;

const int CCHMAXSZ =            256;   // Maximum generic string length
const int CCHMAXSZ_ADDRESS =    256;   // Maximum length of an address
const int CCHMAXSZ_SERVER =     128;   // Maximum length of an address

const int CCHMAXSZ_EMAIL =      128;   // Maximum length of an email name
const int CCHMAXSZ_FIRSTNAME =  128;   // Maximum length of a first name
const int CCHMAXSZ_LASTNAME =   128;   // Maximum length of a last name
const int CCHMAXSZ_NAME =       256;   // Maximum user name, displayed (combined first+last name)
const int CCHMAXSZ_LOCATION =   128;   // Maximum length of a Location
const int CCHMAXSZ_PHONENUM =   128;   // Maximum length of a Phone number
const int CCHMAXSZ_COMMENT =    256;   // Maximum length for comments
const int CCHMAXSZ_VERSION =    128;   // Maximum length for version info

const int CCHEXT =                3;   // Maximum CHARACTERS in a filename extension


// defines:
const int MAX_ITEMLEN =                                 256;

// Timers 300-399 are used by the ASMaster class
const int TASKBAR_DBLCLICK_TIMER =			666;

const int IDT_SCROLLBAR_REPEAT =            667;
const int IDT_SCROLLBAR_REPEAT_PERIOD =     250; // 0.25 sec

const int IDT_FLDRBAR_TIMER =               668;
const int IDT_FLDRBAR_TIMER_PERIOD =       1000; // 1 second

const int FRIENDS_REFRESH_TIMER =			681;
const int DIRECTORY_REFRESH_TIMER =			682;

const int WINSOCK_ACTIVITY_TIMER =			683;
const int WINSOCK_ACTIVITY_TIMER_PERIOD =	55000; // 55 seconds

const int AUDIODLG_MIC_TIMER =				69;
const int AUDIODLG_MIC_TIMER_PERIOD =		500; // 0.5 sec

const int POPUPMSG_TIMER =					1000;
const int MOUSE_MOVE_TIP_TIMEOUT =			3000; // 3 seconds
const int SHADOW_ACTIVATE_TIP_TIMEOUT =     5000; // 5 seconds
const int ROSTER_TIP_TIMEOUT =              3000; // 3 seconds

// Help id related constants:
const int MAIN_MENU_POPUP_HELP_OFFSET =     39000;
const int TOOLS_MENU_POPUP_HELP_OFFSET =    39100;
const int HELP_MENU_POPUP_HELP_OFFSET =	    39200;
const int VIEW_MENU_POPUP_HELP_OFFSET =	    39400;
const int MENU_ID_HELP_OFFSET =              2000;

// Indexes for IDB_ICON_IMAGES image list:
const int II_INVALIDINDEX =        -1;
const int II_PERSON_BLUE =          0;     // Blue shirt
const int II_PERSON_RED =           1;     // Red shirt
const int II_PERSON_GREY =          2;     // Person disabled (Grey shirt)
const int II_PEOPLE =               3;     // 2 people
const int II_BLANK =                4;     // 
const int II_BUDDY =                5;     // Buddy List Application
const int II_SPEEDDIAL =            6;     // Speed Dial
const int II_DIRECTORY =            7;     // Directory
const int II_SERVER =               8;     // ILS Server
const int II_WAB =                  9;     // Windows Address Book
const int II_WAB_CARD =            10;     // Contact Card
const int II_COMPUTER =            11;     // Computer (generic)
const int II_IN_A_CALL =           12;     // Computer busy
const int II_NETMEETING =          13;     // NetMeeting World
const int II_HISTORY =             14;     // History
const int II_UNKNOWN =             15;     // ?
const int II_OUTLOOK_WORLD =       16;     // Outlook World
const int II_OUTLOOK_AGENT =       17;     // Outlook Agent
const int II_OUTLOOK_GROUP =       18;     // Outlook Group
const int II_IE =                  19;     // Internet Explorer
const int II_WEB_DIRECTORY =	   20;     // Web View Directory
const int II_AUDIO_CAPABLE =	   21;     // Audio Capable
const int II_VIDEO_CAPABLE =	   22;     // Video Capable
const int II_AUDIO_COLUMN_HEADER = 23;     // Audio Listview Column Header Icon
const int II_VIDEO_COLUMN_HEADER = 24;     // Video Listview Column Header Icon

// Alternate definitions for the small icons
const int II_PERSON =              II_PERSON_BLUE; // Person (generic)
const int II_USER =                II_PERSON_BLUE; // Member (generic)
const int II_GAL =                 II_WAB; // Global Address List

    // MAPI PR_DISPLAY_TYPE types
const int II_DISTLIST =            II_OUTLOOK_GROUP;
const int II_FORUM =               II_OUTLOOK_GROUP;
const int II_AGENT =               II_OUTLOOK_AGENT;
const int II_ORGANIZATION =        II_PEOPLE;
const int II_PRIVATE_DISTLIST =    II_OUTLOOK_GROUP;
const int II_REMOTE_MAILUSER =     II_OUTLOOK_WORLD;


// NavBar measurements
const int DXP_NAVBAR =            78;
const int DXP_NAVBAR_ICON =       32;
const int DYP_NAVBAR_ICON =       32;
const int DXP_NAVBAR_MARGIN =      3;
const int DYP_NAVBAR_MARGIN =      8;
const int DYP_NAVBAR_ICON_SPACING =3;
const int DXP_NAVBAR_ICON_BORDER = 2;
const int DXP_NAVBAR_ICON_ADJUST = 6;

// SplitBar measurements
const int DYP_SPLITBAR_MARGIN =    3;

// TitleBar measurements
const int DXP_TITLE_ICON_ADJUST =  4;
const int DYP_TITLE_ICON_ADJUST =  1;
const int DYP_TITLE_MARGIN     =   1; // almost no border

const int DXP_ICON_SMALL =        16;
const int DYP_ICON_SMALL =        16;

const int DXP_ICON_LARGE =        32;
const int DYP_ICON_LARGE =        32;

const int DYP_TITLEBAR = DYP_NAVBAR_ICON + (DYP_TITLE_ICON_ADJUST*2);  // Height of view title bar
const int DYP_TITLEBAR_LARGE = DYP_NAVBAR_ICON + (DYP_TITLE_ICON_ADJUST*2);
const int DYP_TITLEBAR_SMALL = DYP_ICON_SMALL + (DYP_TITLE_ICON_ADJUST*2);


// General UI measurements
const int UI_SPLITTER_WIDTH =          4;
const int UI_MINIMUM_VIEW_WIDTH =    120;
const int UI_MINIMUM_DIRVIEW_HEIGHT = 90;
const int UI_MINIMUM_VIEW_HEIGHT =    50;
const int UI_TAB_VERTICAL_MARGIN =     4;
const int UI_TAB_HORIZONTAL_MARGIN =   2;
const int UI_TAB_LEFT_MARGIN =         2;
const int UI_TAB_INTERNAL_MARGIN =     4;

// Video Window measurements
const int VIDEO_WIDTH_SQCIF =        128;
const int VIDEO_HEIGHT_SQCIF =        96;
const int VIDEO_WIDTH_QCIF =         176;
const int VIDEO_HEIGHT_QCIF =        144;
const int VIDEO_WIDTH_CIF =          352;
const int VIDEO_HEIGHT_CIF =         288;
const int VIDEO_GRAB_SIZE =           20;

#define VIDEO_WIDTH_DEFAULT 	VIDEO_WIDTH_QCIF
#define VIDEO_HEIGHT_DEFAULT	VIDEO_HEIGHT_QCIF

const int UI_VIDEO_BORDER =            6;


// Window IDs:
const UINT ID_STATUS =              600;
const UINT ID_TOOLBAR =             601;
const UINT ID_LISTVIEW =            602;
const UINT ID_DIR_LISTVIEW =        603;
const UINT ID_REBAR =               604;
const UINT ID_BRAND =               605;
const UINT ID_NAVBAR =              606;
const UINT ID_REBAR_FRAME =         607;
const UINT ID_VIDEO_VIEW =          608;
const UINT ID_FLDRBAR =             609;
const UINT ID_FLOAT_TOOLBAR =		610;
const UINT ID_LOGVIEW_LISTVIEW =	615;
const UINT ID_LOGVIEW_COMBOEX =		616;
const UINT ID_FRIENDSVIEW_LISTVIEW =617;
const UINT ID_AUDIO_BAND =			620;
const UINT ID_TITLE_BAR =           621;
const UINT ID_SPLIT_BAR =           622;
const UINT ID_SCROLL_BAR =          623;
const UINT ID_NAVBARCONTAINER =     624;
const UINT ID_TASKBAR_ICON =        650;
const UINT ID_CHAT_EDIT =           660;
const UINT ID_CHAT_MSG =            661;
const UINT ID_CHAT_LIST =           662;
const UINT ID_CHAT_SEND =           663;
const UINT ID_CHAT_DEST =           664;
const UINT ID_AUDIOLEVEL_BAND =			666;

const UINT ID_FIRST_EDITPANE =		1000;
const UINT ID_BANNER =				1000;
const UINT ID_CHATPANE =			1002;
const UINT ID_LAST_EDITPANE =		2000;

const int ID_AUDIODLG_GROUPBOX =	3300;
const int ID_AUDIODLG_MIC_TRACK =	3301;
const int ID_AUDIODLG_SPKR_TRACK =	3302;

// other id's:
const int MAX_REDIAL_ITEMS =        50;
const int ID_FIRST_REDIAL_ITEM =	31900;
const int ID_LAST_REDIAL_ITEM =     ID_FIRST_REDIAL_ITEM + MAX_REDIAL_ITEMS;

const int ID_EXTENDED_TOOLS_SEP =	32000;
const int ID_EXTENDED_TOOLS_ITEM =	32001;
const int MAX_EXTENDED_TOOLS_ITEMS=	50;

// Misc command ids:
const int ID_POPUPMSG_TIMEOUT =		28000;
const int ID_POPUPMSG_CLICK =		28001;

extern DWORD g_wsLayout;

#endif // ! _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mapimyinfo.h ===
#include "precomp.h"

#define MAPIDLL					"MAPI32.DLL"

#define MAPIINITname			"MAPIInitialize"
#define MAPILOGONEXname			"MAPILogonEx"
#define MAPIFREEBUFFERname		"MAPIFreeBuffer"
#define MAPIUNINITIALIZEname	"MAPIUninitialize"

HRESULT MAPIGetMyInfo();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mapiinit.cpp ===
#include "precomp.h"
#include "MapiInit.h"

    // MAPI32.DLL stuff
DECLARE_PROC_INST( MAPIINITIALIZE, MAPIInitialize );
DECLARE_PROC_INST( MAPIUNINITIALIZE, MAPIUninitialize );
DECLARE_PROC_INST( MAPIALLOCATEBUFFER, MAPIAllocateBuffer );
DECLARE_PROC_INST( MAPIALLOCATEMORE, MAPIAllocateMore );
DECLARE_PROC_INST( MAPIFREEBUFFER, MAPIFreeBuffer );
DECLARE_PROC_INST( MAPILOGONEX, MAPILogonEx );
DECLARE_PROC_INST( FREEPROWS, FreeProws );
DECLARE_PROC_INST( HRQUERYALLROWS, HrQueryAllRows );
DECLARE_PROC_INST( HRGETONEPROP, HrGetOneProp );
DECLARE_PROC_INST( MAPIADMINPROFILES, MAPIAdminProfiles);

    // MAPI Proc Mak
BEGIN_PROC_MAP( MAPI32 )
    PROC_MAP_ENTRY( MAPIInitialize )
    PROC_MAP_ENTRY( MAPIUninitialize )
    PROC_MAP_ENTRY( MAPIAllocateBuffer )
    PROC_MAP_ENTRY( MAPIAllocateMore )
    PROC_MAP_ENTRY( MAPIFreeBuffer )
    PROC_MAP_ENTRY( MAPILogonEx )
	PROC_MAP_ENTRY( MAPIAdminProfiles )
    PROC_MAP_ENTRY_EXPLICIT_NAME( FreeProws, FreeProws@4 )
    PROC_MAP_ENTRY_EXPLICIT_NAME( HrQueryAllRows, HrQueryAllRows@24 )
	PROC_MAP_ENTRY_EXPLICIT_NAME( HrGetOneProp, HrGetOneProp@12 )
END_PROC_MAP

bool LoadMapiFns( HINSTANCE* phInstMapi32DLL ) {
    
    HRESULT hr = LOAD_PROCS(TEXT("MAPI32.DLL"), MAPI32, phInstMapi32DLL );
    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mapiinit.h ===
#ifndef __MapiInit_h__
#define __MapiInit_h__

#include <mapix.h>

// This defines a bunch of macros for pretty GetProcAddress stuff...
    // DECLARE_PFNTYPE is for those functions that are not defined as the example above
#define DECLARE_PFNTYPE( FnName ) typedef FnName FAR* LP##FnName;
#define DECLARE_PFNTYPE_INST( FnName )   LP##FnName lpfn##FnName = NULL;

    // DECLARE_PROC goes in the header file 
#define DECLARE_PROC( FnDecl, FnName ) extern LP##FnDecl lpfn##FnName;
    
    // DECLARE_PROC_INST goes in the .c or .cpp file            
#define DECLARE_PROC_INST( FnDecl, FnName )   LP##FnDecl lpfn##FnName = NULL;

    // This begins a proc map as described at the top of this file
#define BEGIN_PROC_MAP( LibName ) APIFCN LibName##ProcList[] = {

    // Each function that is being loaded has an entry in the proc map
#define PROC_MAP_ENTRY( FnName )    { (LPVOID * ) &lpfn##FnName, #FnName },

    // Some functions we have to give an explicit name
#define PROC_MAP_ENTRY_EXPLICIT_NAME( pFnName, FnName )    { (LPVOID * ) &lpfn##pFnName, #FnName },

    // This is at the end of a proc map
#define END_PROC_MAP     };

    // User calls LOAD_PROCS with the PROC map that they have built....
#define LOAD_PROCS(szDllName, LibName, pHInstance) HrInitLpfn(LibName##ProcList, ARRAY_ELEMENTS(LibName##ProcList), pHInstance, szDllName);

typedef void ( STDAPICALLTYPE FREEPROWS ) ( LPSRowSet lpRows );
typedef FREEPROWS FAR* LPFREEPROWS;


typedef HRESULT( STDAPICALLTYPE HRQUERYALLROWS ) ( 
    LPMAPITABLE lpTable, 
    LPSPropTagArray lpPropTags,
    LPSRestriction lpRestriction,
    LPSSortOrderSet lpSortOrderSet,
    LONG crowsMax,
    LPSRowSet FAR *lppRows
);
typedef HRQUERYALLROWS FAR* LPHRQUERYALLROWS;


typedef HRESULT( STDAPICALLTYPE HRGETONEPROP ) (
	LPMAPIPROP lpMapiProp, 
	ULONG ulPropTag,
    LPSPropValue FAR *lppProp
);
typedef HRGETONEPROP FAR* LPHRGETONEPROP;

    // We are forward declaring them like this so that
    // the fns can be visible from several cpp files....

    // MAPI32.DLL stuff
DECLARE_PROC( MAPIINITIALIZE, MAPIInitialize );
DECLARE_PROC( MAPIUNINITIALIZE, MAPIUninitialize );
DECLARE_PROC( MAPIALLOCATEBUFFER, MAPIAllocateBuffer );
DECLARE_PROC( MAPIALLOCATEMORE, MAPIAllocateMore );
DECLARE_PROC( MAPIFREEBUFFER, MAPIFreeBuffer );
DECLARE_PROC( MAPILOGONEX, MAPILogonEx );
DECLARE_PROC( MAPIADMINPROFILES, MAPIAdminProfiles );
DECLARE_PROC( FREEPROWS, FreeProws );
DECLARE_PROC( HRQUERYALLROWS, HrQueryAllRows );
DECLARE_PROC( HRGETONEPROP, HrGetOneProp );

bool LoadMapiFns( HINSTANCE* phInstMapi32DLL );


#endif // __MapiInit_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mapimyinfo.cpp ===
#include "precomp.h"
#include "confpolicies.h"
#include "MapiMyInfo.h"

#define USES_IID_IMailUser
#define USES_IID_IAddrBook

#define INITGUID
#include <initguid.h>
#include <mapiguid.h>
#include <mapix.h>
#include <mapiutil.h>
#include <mapitags.h>

HRESULT MAPIGetMyInfo()
{
	HRESULT hr = E_FAIL;
	
	enum eProps
	{
		NAME,
		SUR_NAME,
		EMAIL,
		LOCATION,
		PHONENUM,
		COMMENT,
		PROP_COUNT
	};

	typedef struct tagData
	{
		DWORD dwPropVal;
		int   iIndex;
	} PROPDATA;
	
	HMODULE hMapi	= ::LoadLibrary( MAPIDLL );
	if( NULL == hMapi )
	{
		return hr;
	}

	LPMAPIINITIALIZE	pfnMAPIInitialize		= (LPMAPIINITIALIZE)GetProcAddress( hMapi, MAPIINITname );
	LPMAPILOGONEX		pfnMAPILogonEx			= (LPMAPILOGONEX)GetProcAddress( hMapi, MAPILOGONEXname );
	LPMAPIFREEBUFFER	pfnMAPIFreeBuffer		= (LPMAPIFREEBUFFER)GetProcAddress( hMapi, MAPIFREEBUFFERname );
	LPMAPIUNINITIALIZE	pfnMAPIUninitialize		= (LPMAPIUNINITIALIZE)GetProcAddress( hMapi, MAPIUNINITIALIZEname );
	if( !(pfnMAPIInitialize && pfnMAPILogonEx && pfnMAPIFreeBuffer && pfnMAPIUninitialize) )
	{
		return hr;
	}

	PROPDATA PropData[ PROP_COUNT ];
	ZeroMemory( PropData, sizeof( PropData ) );

	PropData[NAME].dwPropVal		= ConfPolicies::GetGALName();
	PropData[SUR_NAME].dwPropVal	= ConfPolicies::GetGALSurName();
	PropData[EMAIL].dwPropVal		= ConfPolicies::GetGALEmail();
	PropData[LOCATION].dwPropVal	= ConfPolicies::GetGALLocation();
	PropData[PHONENUM].dwPropVal	= ConfPolicies::GetGALPhoneNum();
	PropData[COMMENT].dwPropVal		= ConfPolicies::GetGALComment();

	// First four are required, rest are optional
	if( !( PropData[NAME].dwPropVal && PropData[SUR_NAME].dwPropVal && PropData[EMAIL].dwPropVal && PropData[PHONENUM].dwPropVal) )
	{
		ERROR_OUT(("One or more required MAPI property fields are not set"));
		return hr;
	}

	SizedSPropTagArray( PROP_COUNT, SizedPropTagArray );
	LPSPropTagArray	lpSPropTagArray	= (LPSPropTagArray) &SizedPropTagArray;
	ZeroMemory( lpSPropTagArray, sizeof( lpSPropTagArray ) );

	// We can not retrieve the same property from this array twice.  Therefore never insert
	// until we are sure that the value is not there already.
	int insertAt;
	BOOL bPointAtNew = TRUE;
	int iCurPropTagArrayIndex = 0;
	for( int i = 0; i < PROP_COUNT; i++ )
	{
		if( PropData[i].dwPropVal )
		{
			bPointAtNew = TRUE;
			for( insertAt = 0; insertAt < iCurPropTagArrayIndex; insertAt++ )
			{
				if( PropData[insertAt].dwPropVal == PropData[i].dwPropVal )
				{
					bPointAtNew = FALSE;
					break;
				}
			}
			PropData[i].iIndex = insertAt;
			++iCurPropTagArrayIndex;
			lpSPropTagArray->aulPropTag[PropData[i].iIndex] = PROP_TAG( PT_TSTRING, PropData[i].dwPropVal );
			if( bPointAtNew ) 
			{
				lpSPropTagArray->cValues++;
			}
		}
	}

	hr = pfnMAPIInitialize( NULL );
	if( SUCCEEDED( hr ) )
	{
		LPMAILUSER		pMailUser				= NULL;
		LPADRBOOK		pAddrBook				= NULL;
		LPMAPISESSION	pMapiSession			= NULL;

		LPSPropValue	pPropValues				= NULL;
		LPENTRYID		pPrimaryIdentityEntryID	= NULL;

		hr = pfnMAPILogonEx(	NULL, // parent window
								NULL, // profile name
								NULL, // password
								MAPI_USE_DEFAULT | MAPI_NO_MAIL,
								&pMapiSession );
		if( SUCCEEDED( hr ) )
		{
			ULONG cbPrimaryIdentitySize	= 0;		
			hr = pMapiSession->QueryIdentity(	&cbPrimaryIdentitySize,
												&pPrimaryIdentityEntryID );
			if( SUCCEEDED( hr ) )
			{
				hr = pMapiSession->OpenAddressBook(	NULL, // parent window
													NULL, // Get an IAddrBook pointer
													AB_NO_DIALOG, // Supress UI interaction
													&pAddrBook );
				if( SUCCEEDED( hr ) )
				{
					ULONG uEntryType = 0;
					hr = pAddrBook->OpenEntry(	cbPrimaryIdentitySize,
												pPrimaryIdentityEntryID,
												&IID_IMailUser,
												0, // Flags
												&uEntryType,
												(LPUNKNOWN *)&pMailUser );
					if( SUCCEEDED( hr ) )
					{
						if( MAPI_MAILUSER == uEntryType )
						{	
							ULONG	cValues;
							hr = pMailUser->GetProps( lpSPropTagArray,
														fMapiUnicode,
														&cValues,
														&pPropValues );
							if( SUCCEEDED( hr ) ) 
							{
								// Check for full success
								for( i = 0; i < (int)lpSPropTagArray->cValues; i++ )
								{
										// We failed if a prop was specified, but none returned....
									if( ( PT_ERROR == LOWORD( pPropValues[i].ulPropTag ) ) && ( 0 != PropData[i].dwPropVal ) )
									{
										hr = E_FAIL;
										goto cleanup;
									}
								}

								// TODO - are there limitations on the length of this?
								RegEntry reIsapi( ISAPI_CLIENT_KEY, HKEY_CURRENT_USER );

								LPCTSTR pszName = pPropValues[ PropData[NAME].iIndex ].Value.LPSZ;
								if(pszName)
								{
									reIsapi.SetValue( REGVAL_ULS_FIRST_NAME, pszName );	
								}

								LPCTSTR pszSurName = pPropValues[ PropData[SUR_NAME].iIndex ].Value.LPSZ;
								if(pszSurName)
								{
									reIsapi.SetValue( REGVAL_ULS_LAST_NAME, pszSurName );	
								}

								LPCTSTR pszEmail = pPropValues[ PropData[EMAIL].iIndex ].Value.LPSZ;
								if(pszEmail)
								{
									reIsapi.SetValue( REGVAL_ULS_EMAIL_NAME, pszEmail );	
								}
								
								LPCTSTR pszPhoneNum = pPropValues[ PropData[PHONENUM].iIndex ].Value.LPSZ;
								if(pszPhoneNum)
								{
									reIsapi.SetValue( REGVAL_ULS_PHONENUM_NAME, pszPhoneNum );	
								}
								
								if(pszName)
								{
									TCHAR szULSName[ MAX_DCL_NAME_LEN + 1];
									wsprintf(	szULSName, 
												TEXT("%s %s"), 
												pszName,
												pszSurName
											);
									szULSName[ MAX_DCL_NAME_LEN ] = 0;
									reIsapi.SetValue( REGVAL_ULS_NAME, szULSName );
								}
								
								// Set Resolve Name
								LPCTSTR pszServerName = reIsapi.GetString( REGVAL_SERVERNAME );
								if( pszServerName && pszEmail)
								{
									TCHAR szBuffer[ MAX_PATH ];
									wsprintf(	szBuffer,
												TEXT("%s/%s"),
												pszServerName,
												pszEmail );
									szBuffer[ MAX_PATH - 1 ] = 0;
									reIsapi.SetValue( REGVAL_ULS_RES_NAME, szBuffer );
								}


									// Optional properties...
								if( PropData[ COMMENT ].dwPropVal )
								{
									reIsapi.SetValue( REGVAL_ULS_COMMENTS_NAME, pPropValues[ PropData[ COMMENT ].iIndex ].Value.LPSZ );
								}
								else
								{
									reIsapi.DeleteValue( REGVAL_ULS_COMMENTS_NAME );
								}

								if( PropData[LOCATION].dwPropVal )
								{
									reIsapi.SetValue( REGVAL_ULS_LOCATION_NAME, pPropValues[ PropData[LOCATION].iIndex ].Value.LPSZ );
								}
								else
								{
									reIsapi.DeleteValue( REGVAL_ULS_LOCATION_NAME );
								}

								// Generate a cert based on the entered information for secure calls
    							TCHAR szName[ MAX_PATH ];
	    						TCHAR szSurName[ MAX_PATH ];
		    					TCHAR szEmail[ MAX_PATH ];
			    				lstrcpy( szName, reIsapi.GetString( REGVAL_ULS_FIRST_NAME ) );
				    			lstrcpy( szSurName, reIsapi.GetString( REGVAL_ULS_LAST_NAME ) );
					    		lstrcpy( szEmail, reIsapi.GetString( REGVAL_ULS_EMAIL_NAME ) );
						    	MakeCertWrap(szName, szSurName, szEmail, 0);

								hr = S_OK;
							}
						}
					}
				}
			}
		}

cleanup:
		if( NULL != pPropValues )
		{
			pfnMAPIFreeBuffer( pPropValues );
		}

		if( NULL != pPrimaryIdentityEntryID )
		{
			pfnMAPIFreeBuffer( pPrimaryIdentityEntryID );
		}

		if( NULL != pMailUser)
		{
			pMailUser->Release();
		}

		if( NULL != pAddrBook)
		{
			pAddrBook->Release();
		}

		if( NULL != pMapiSession )
		{
			pMapiSession->Release();
		}

		pfnMAPIUninitialize();

		FreeLibrary( hMapi );
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\membercollection.cpp ===
#include "Precomp.h"
#include "MemberCollection.h"
#include "Confroom.h"
#include "Particip.h"
#include "EnumVar.h"

//////////////////////////////////////////////////////////
// Construction / destruction / initialization
//////////////////////////////////////////////////////////

CMemberCollection::~CMemberCollection()
{
	_FreeMemberCollection();
}

//static 
HRESULT CMemberCollection::CreateInstance(CSimpleArray<IMember*>& rMemberObjs, IMemberCollection** ppMemberCollection)
{
	HRESULT hr = S_OK;
		
	CComObject<CMemberCollection>* p = NULL;
	p = new CComObject<CMemberCollection>(NULL);
	if(p)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hr = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if(hr == S_OK)
		{
			hr = p->QueryInterface(IID_IMemberCollection, reinterpret_cast<void**>(ppMemberCollection));
			if(SUCCEEDED(hr))
			{
				hr = p->_Init(rMemberObjs);
			}
		}

		if(FAILED(hr))		
		{
			delete p;
			*ppMemberCollection = NULL;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	return hr;
}

//////////////////////////////////////////////////////////
// IMemberCollection
//////////////////////////////////////////////////////////

STDMETHODIMP CMemberCollection::get_Item(VARIANT Index, IMember** ppMember)
{
	DBGENTRY(CMemberCollection::get_Item);
	HRESULT hr = S_OK;

	USES_CONVERSION;

	if(ppMember)
	{
		*ppMember = NULL;

		switch(Index.vt)
		{
			case VT_BSTR:
				*ppMember = _GetMemberFromName(OLE2T(Index.bstrVal));		
				if(*ppMember)
				{
					(*ppMember)->AddRef();
				}
				else
				{
					hr = E_FAIL;
				}
				break;

			case VT_I2:
				if(m_Members.GetSize() < Index.iVal)
				{
					*ppMember = m_Members[Index.iVal];
					(*ppMember)->AddRef();
				}
				else
				{
					hr = E_INVALIDARG;
				}
				
				break;

			case VT_I4:
				if(m_Members.GetSize() < Index.lVal)
				{
					*ppMember = m_Members[Index.lVal];
					(*ppMember)->AddRef();
				}
				else
				{
					hr = E_INVALIDARG;
				}
				break;

			default:
				hr = E_INVALIDARG;
		}
	}
	else
	{
		hr = E_POINTER;
	}
	

	DBGEXIT_HR(CMemberCollection::get_Item,hr);
	return hr;
}

STDMETHODIMP CMemberCollection::_NewEnum(IUnknown** ppunk)
{
	DBGENTRY(CMemberCollection::_NewEnum);
	HRESULT hr = S_OK;

	
	SAFEARRAY* psa;
	SAFEARRAYBOUND rgsabound[1];
	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = m_Members.GetSize();

	psa = SafeArrayCreate(VT_DISPATCH, m_Members.GetSize(), rgsabound);

	if(psa)
	{
		for(int i = 0; i < m_Members.GetSize(); ++i)
		{
			CComPtr<IDispatch> spDispatch;
			hr = m_Members[i]->QueryInterface(IID_IDispatch, reinterpret_cast<void**>(&spDispatch));
			ASSERT(SUCCEEDED(hr));

			CComVariant var(spDispatch);

			long ix[1] = {i};
			SafeArrayPutElement(psa, ix, &var);
		}

		CEnumVariant* pEnumVar = NULL;
		hr = CEnumVariant::Create(psa, m_Members.GetSize(), &pEnumVar);
		if(SUCCEEDED(hr))
		{
			hr = pEnumVar->QueryInterface(IID_IEnumVARIANT, reinterpret_cast<void**>(ppunk));
		}

		SafeArrayDestroy(psa);
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CMemberCollection::_NewEnum,hr);
	return hr;
}

STDMETHODIMP CMemberCollection::get_Count(LONG * pnCount)
{
	DBGENTRY(CMemberCollection::get_Count);
	HRESULT hr = S_OK;

	if(pnCount)
	{
		*pnCount = m_Members.GetSize();	
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CMemberCollection::get_Count,hr);
	return hr;
}


//////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////
HRESULT CMemberCollection::_Init(CSimpleArray<IMember*>& rMemberObjs)
{
	HRESULT hr = S_OK;
	
	for(int i = 0; i < rMemberObjs.GetSize(); ++i)
	{
		IMember* pMember = rMemberObjs[i];
		pMember->AddRef();
		m_Members.Add(pMember);
	}

	return hr;	
}


void CMemberCollection::_FreeMemberCollection()
{
	for(int i = 0; i < m_Members.GetSize(); ++i)
	{
		m_Members[i]->Release();				
	}

	m_Members.RemoveAll();
}


IMember* CMemberCollection::_GetMemberFromName(LPCTSTR pszName)
{
	IMember* pRet = NULL;
	
	USES_CONVERSION;

	for(int i = 0; i < m_Members.GetSize(); ++i)
	{
		CComBSTR bstrName;
		if(SUCCEEDED(m_Members[i]->get_Name(&bstrName)))
		{
			if(!lstrcmp(OLE2T(bstrName),pszName))
			{
				pRet = m_Members[i];
				break;
			}
		}
	}

	return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\membercollection.h ===
#ifndef __MemberCollection_h__
#define __MemberCollection_h__

class CParticipant;

#include "NetMeeting.h"
#include "ias.h"

class ATL_NO_VTABLE CMemberCollection :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IMemberCollection, &IID_IMemberCollection, &LIBID_NetMeetingLib>
{

protected:
	CSimpleArray<IMember*> m_Members;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CMemberCollection)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMemberCollection)
	COM_INTERFACE_ENTRY(IMemberCollection)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


//////////////////////////////////////////////////////////
// Construction / destruction / initialization
//////////////////////////////////////////////////////////

~CMemberCollection();

static HRESULT CreateInstance(CSimpleArray<IMember*>& rMemberObjs, IMemberCollection** ppMemberCollection);

//////////////////////////////////////////////////////////
// IMemberCollection
//////////////////////////////////////////////////////////
	STDMETHOD(get_Item)(VARIANT Index, IMember** ppMember);
	STDMETHOD(_NewEnum)(IUnknown** ppunk);
    STDMETHOD(get_Count)(LONG * pnCount);

//////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////
	HRESULT _Init(CSimpleArray<IMember*>& rMemberObjs);
	void _FreeMemberCollection();
	IMember* _GetMemberFromName(LPCTSTR pszName);

};


#endif // __MemberCollection_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\memmove.cpp ===
#include "precomp.h"

// In debug mode, we link with CRT, so we don't need this!
#ifndef _DEBUG


	/***
	*memmove.c - contains memmove routine
	*
	*       Copyright (c) 1988-1997, Microsoft Corporation. All right reserved.
	*
	*Purpose:
	*       memmove() copies a source memory buffer to a destination buffer.
	*       Overlapping buffers are treated specially, to avoid propogation.
	*
	*******************************************************************************/

	#if defined (_M_ALPHA)
	#pragma function(memmove)
	#endif  /* defined (_M_ALPHA) */

	/***
	*memmove - Copy source buffer to destination buffer
	*
	*Purpose:
	*       memmove() copies a source memory buffer to a destination memory buffer.
	*       This routine recognize overlapping buffers to avoid propogation.
	*       For cases where propogation is not a problem, memcpy() can be used.
	*
	*Entry:
	*       void *dst = pointer to destination buffer
	*       const void *src = pointer to source buffer
	*       size_t count = number of bytes to copy
	*
	*Exit:
	*       Returns a pointer to the destination buffer
	*
	*Exceptions:
	*******************************************************************************/

	void * __cdecl memmove (
			void * dst,
			const void * src,
			size_t count
			)
	{
			void * ret = dst;

	#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)
			{
			extern void RtlMoveMemory( void *, const void *, size_t count );

			RtlMoveMemory( dst, src, count );
			}
	#else  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */
			if (dst <= src || (char *)dst >= ((char *)src + count)) {
					/*
					 * Non-Overlapping Buffers
					 * copy from lower addresses to higher addresses
					 */
					while (count--) {
							*(char *)dst = *(char *)src;
							dst = (char *)dst + 1;
							src = (char *)src + 1;
					}
			}
			else {
					/*
					 * Overlapping Buffers
					 * copy from higher addresses to lower addresses
					 */
					dst = (char *)dst + count - 1;
					src = (char *)src + count - 1;

					while (count--) {
							*(char *)dst = *(char *)src;
							dst = (char *)dst - 1;
							src = (char *)src - 1;
					}
			}
	#endif  /* defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) */

			return(ret);
	}

#endif // !_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\menuutil.cpp ===
// File: menuutil.cpp

#include "precomp.h"
#include "resource.h"
#include "MenuUtil.h"
#include "cmd.h"
#include "ConfUtil.h"



/****************************************************************************
*
*    FUNCTION: FillInTools()
*
*    PURPOSE:  Fills in the Tools menu from a specified reg key
*
****************************************************************************/

UINT FillInTools(	HMENU hMenu, 
					UINT uIDOffset, 
					LPCTSTR pcszRegKey, 
					CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList)
{
	ASSERT(pcszRegKey);

	RegEntry reToolsKey(pcszRegKey, HKEY_LOCAL_MACHINE);
	if (ERROR_SUCCESS == reToolsKey.GetError())
	{
		BOOL fFirstItem = TRUE;
		RegEnumValues rev(&reToolsKey);
		while (ERROR_SUCCESS == rev.Next())
		{
			TOOLSMENUSTRUCT* ptms = new TOOLSMENUSTRUCT;
			if (NULL != ptms)
			{
				ptms->mods.iImage = 0;
				ptms->mods.hIcon = NULL;
				ptms->mods.hIconSel = NULL;
				ptms->mods.fChecked = FALSE;
				ptms->mods.fCanCheck = FALSE;
				ptms->mods.pszText = (LPTSTR) &(ptms->szDisplayName);
				ptms->uID = ID_EXTENDED_TOOLS_ITEM + uIDOffset;
				if ((REG_SZ == rev.GetType()) && (0 != rev.GetDataLength()))
				{
					lstrcpyn(	ptms->szExeName,
								(LPTSTR) rev.GetData(),
								ARRAY_ELEMENTS(ptms->szExeName));
					SHFILEINFO shfi;
					if (NULL != SHGetFileInfo(
									ptms->szExeName,
									0,
									&shfi,
									sizeof(shfi),
									SHGFI_ICON | SHGFI_SMALLICON))
					{
						ptms->mods.hIcon = shfi.hIcon;
					}
				}
				else
				{
					ptms->szExeName[0] = _T('\0');
				}
				if (NULL == ptms->mods.hIcon)
				{
					// The icon wasn't filled in, so use a default icon
					ptms->mods.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
				}
				lstrcpyn(	ptms->szDisplayName,
							rev.GetName(),
							ARRAY_ELEMENTS(ptms->szDisplayName));

				rToolsList.Add(ptms);

				if (fFirstItem)
				{
					// add a separator first
					::AppendMenu(	hMenu,
									MF_SEPARATOR,
									ID_EXTENDED_TOOLS_SEP,
									NULL);
					fFirstItem = FALSE;
				}
				
				if (::AppendMenu(	hMenu,
									MF_ENABLED | MF_OWNERDRAW,
									ptms->uID,
									(LPCTSTR) ptms))
				{
					uIDOffset++;
				}
			}
		}
	}

	return uIDOffset;
}

/****************************************************************************
*
*    FUNCTION: CleanTools()
*
*    PURPOSE:  Cleans up a tools menu
*
****************************************************************************/

UINT CleanTools(HMENU hMenu, 
				CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList)
{
	DebugEntry(CleanTools);

	if (NULL != hMenu)
	{
		// remove separator
		::RemoveMenu(hMenu, ID_EXTENDED_TOOLS_SEP, MF_BYCOMMAND);
	}
	
	while (0 != rToolsList.GetSize())
	{
		TOOLSMENUSTRUCT* ptms = rToolsList[0];

		if (NULL != ptms)
		{
			if (NULL != ptms->mods.hIcon)
			{
				::DestroyIcon(ptms->mods.hIcon);
			}
			if (NULL != ptms->mods.hIconSel)
			{
				::DestroyIcon(ptms->mods.hIconSel);
			}
			
			if (NULL != hMenu)
			{
				::RemoveMenu(hMenu, ptms->uID, MF_BYCOMMAND);
			}

			delete ptms;
			rToolsList.RemoveAt(0);
		}
	}
	
	DebugExitULONG(CleanTools, 0);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\menuutil.h ===
#ifndef _MENUUTIL_H_
#define _MENUUTIL_H_

const int MENUPOS_CALL			= 0;
const int MENUPOS_VIEW			= 1;
const int MENUPOS_TOOLS			= 2;
const int MENUPOS_HELP			= 3;

const int MENUPOS_TOOLS_VIDEO		= 0;

// Owner Draw Info:
struct MYOWNERDRAWSTRUCT
{
	HICON	hIcon;
	HICON	hIconSel;
	int		iImage;
	PVOID	pvObj;
	BOOL	fCanCheck;
	BOOL	fChecked;
	LPTSTR	pszText;
};
typedef MYOWNERDRAWSTRUCT* PMYOWNERDRAWSTRUCT;

const int MENUICONSIZE = 16;
const int MENUICONGAP = 3;
const int MENUICONSPACE = 3;
const int MENUTEXTOFFSET = MENUICONSIZE + (2 * MENUICONSPACE) + MENUICONGAP;
const int MENUSELTEXTOFFSET = MENUICONSIZE + (2 * MENUICONSPACE) + 1;


struct TOOLSMENUSTRUCT
{
    MYOWNERDRAWSTRUCT   mods;
	UINT				uID;
	TCHAR				szExeName[MAX_PATH];
	TCHAR				szDisplayName[MAX_PATH];
};

UINT FillInTools(	HMENU hMenu, 
					UINT uIDOffset, 
					LPCTSTR pcszRegKey, 
					CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList);

UINT CleanTools(HMENU hMenu, 
				CSimpleArray<TOOLSMENUSTRUCT*>& rToolsList);


#endif // _MENUUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mrulist.cpp ===
// File: MruList.cpp

#include "precomp.h"

#include "MRUList.h"
#include "ConfUtil.h"

CMRUList::CMRUList() :
	m_nValidEntries		(0),
	m_pszRegKey			(NULL),
	m_fDirty			(FALSE)
{
	DebugEntry(CMRUList::CMRUList);

	// Clear out information
	for (int i = 0; i < MRU_MAX_ENTRIES; i++)
	{
		m_szNames[i][0] = _T('\0'); 
	}

	DebugExitVOID(CMRUList::CMRUList);
}

CMRUList::~CMRUList()
{
	DebugEntry(CMRUList::~CMRUList);

	if (m_fDirty)
	{
		Save();
	}
	delete m_pszRegKey;

	DebugExitVOID(CMRUList::~CMRUList);
}

BOOL CMRUList::ShiftEntries(int nSrc, int nDest, int cEntries)
{
	DebugEntry(CMRUList::ShiftEntries);

	BOOL bRet = TRUE;

	ASSERT(m_nValidEntries > 0);
	ASSERT(nSrc >= 0 && nSrc < MRU_MAX_ENTRIES);
	ASSERT(nDest >= 0 && nDest < MRU_MAX_ENTRIES);
	ASSERT(nSrc != nDest);
	
	if ((0 == cEntries) || (cEntries > (MRU_MAX_ENTRIES - nSrc)))
	{
		TRACE_OUT((	"CMRUList::ShiftEntries: Adjusting cEntries from %d to %d", 
					cEntries, 
					(MRU_MAX_ENTRIES - nSrc)));
		cEntries = (MRU_MAX_ENTRIES - nSrc);
	}
	
	if (nSrc > nDest)
	{
		// Copy forwards (first to last)
		
		for (int i = 0; i < cEntries; i++)
		{
			lstrcpy(m_szNames[nDest + i], m_szNames[nSrc + i]);
		}
	}
	else
	{
		// Copy backwards (last to first)
		
		for (int i = (cEntries - 1); i >= 0; i--)
		{
			lstrcpy(m_szNames[nDest + i], m_szNames[nSrc + i]);
		}
	}

	DebugExitBOOL(CMRUList::ShiftEntries, bRet);

	return bRet;
}

BOOL CMRUList::Load(LPCTSTR pcszRegKey)
{
	DebugEntry(CMRUList::Load);
	BOOL bRet = TRUE;

	ASSERT(pcszRegKey);
	delete m_pszRegKey;
	m_pszRegKey = PszAlloc(pcszRegKey);
		
	RegEntry reMRU(pcszRegKey, HKEY_CURRENT_USER);
	int nCount = 0;

	if (ERROR_SUCCESS == reMRU.GetError())
	{
		// Determine how many entries has been saved in the registry:
		nCount = reMRU.GetNumber(REGVAL_MRU_COUNT, 0);
	}

	ASSERT(nCount <= MRU_MAX_ENTRIES);

	for (int i = 0; i < nCount; i++)
	{
		TCHAR szRegName[MAX_PATH];
		LPSTR pStr;

		// Retrieve the name from the registry:
		wsprintf(szRegName, "%s%d", REGVAL_NAME_MRU_PREFIX, i);
		pStr = reMRU.GetString(szRegName);
		lstrcpyn(m_szNames[i], pStr, MRU_MAX_STRING);
	}

	// Set the valid entries member variable:
	m_nValidEntries = nCount;
	
	// Clear the dirty flag since we have just loaded:
	m_fDirty = FALSE;

	DebugExitBOOL(CMRUList::Load, bRet);

	return bRet;
}

BOOL CMRUList::Save()
{
	DebugEntry(CMRUList::Save);

	BOOL bRet = FALSE;

	if (NULL != m_pszRegKey)
	{
		RegEntry reMRU(m_pszRegKey, HKEY_CURRENT_USER);

		if (ERROR_SUCCESS == reMRU.GetError())
		{
			// Save the number of entries to the registry:
			reMRU.SetValue(REGVAL_MRU_COUNT, m_nValidEntries);

			for (int i = 0; i < m_nValidEntries; i++)
			{
				TCHAR szRegName[MAX_PATH];

				// Set the name in the registry:
				wsprintf(szRegName, "%s%d", REGVAL_NAME_MRU_PREFIX, i);
				reMRU.SetValue(szRegName, m_szNames[i]);
			}

			reMRU.FlushKey();
			
			if (ERROR_SUCCESS == reMRU.GetError())
			{
				// Clear the dirty flag since we have just saved:
				m_fDirty = FALSE;
				bRet = TRUE;
			}
		}
	}
	else
	{
		ERROR_OUT(("Can't save MRU info - no reg key stored!"));
	}

	DebugExitBOOL(CMRUList::Save, bRet);

	return bRet;
}

BOOL CMRUList::MoveEntryToTop(int nIndex)
{
	DebugEntry(CMRUList::MoveEntryToTop);

	BOOL bRet = TRUE;
	
	ASSERT(nIndex >= 0 && nIndex < m_nValidEntries);

	if (nIndex < (m_nValidEntries - 1))
	{
		TCHAR	szTempName[MRU_MAX_STRING];
		lstrcpy(szTempName, m_szNames[nIndex]);

		// Move everything down by 1:
		ShiftEntries(nIndex + 1, nIndex, m_nValidEntries - nIndex);

		lstrcpy(m_szNames[m_nValidEntries - 1], szTempName);
	}

	// Set the dirty flag:
	m_fDirty = TRUE;

	DebugExitBOOL(CMRUList::MoveEntryToTop, bRet);

	return bRet;
}


/*  A D D  N E W  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: AddNewEntry

    Return TRUE if the entry is NEW.
-------------------------------------------------------------------------*/
BOOL CMRUList::AddNewEntry(LPCTSTR pcszName)
{
	DebugEntry(CMRUList::AddNewEntry);

	int nExistingEntry = FindEntry(pcszName);
	BOOL bRet = (-1 == nExistingEntry); // bRet = TRUE if this is NEW
	if (!bRet)
	{
		// This entry already exists, move it to the top:
		MoveEntryToTop(nExistingEntry);
	}
	else
	{
		// This entry doesn't exist already, so add it:
		if (MRU_MAX_ENTRIES == m_nValidEntries)
		{
			ShiftEntries(1, 0);

			m_nValidEntries--;
		}
		
		ASSERT(m_nValidEntries < MRU_MAX_ENTRIES);
		
		// Set the index to be one past the last current entry:
		int nCopyIndex = m_nValidEntries;

		lstrcpyn(m_szNames[nCopyIndex], pcszName, MRU_MAX_STRING - 1);

		// Increment the number of valid entries:
		m_nValidEntries++;
		
		// Set the dirty flag:
		m_fDirty = TRUE;
	}

	DebugExitBOOL(CMRUList::AddNewEntry, bRet);

	return bRet;
}


/*  F I N D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: FindEntry

    Performs a case-insensitive search for the string
-------------------------------------------------------------------------*/
int CMRUList::FindEntry(LPCTSTR pcszName)
{
	for (int i = 0; i < m_nValidEntries; i++)
	{
		if (0 == lstrcmpi(m_szNames[i], pcszName))
		{
			return i;
		}
	}

	return -1; // not found
}


//--------------------------------------------------------------------------//
//	CMRUList::DeleteEntry.													//
//--------------------------------------------------------------------------//
bool
CMRUList::DeleteEntry
(
	const TCHAR * const	entry
){
	int		entryIndex	= FindEntry( entry );
	bool	deleted		= (entryIndex != -1);

	if( deleted )
	{
		ShiftEntries( entryIndex + 1, entryIndex );

		m_nValidEntries--;

		m_fDirty = TRUE;
	}

	return( deleted );

}	//	End of CMRUList::DeleteEntry.


//--------------------------------------------------------------------------//
//	CMRUList::ReplaceEntry.													//
//--------------------------------------------------------------------------//
bool
CMRUList::ReplaceEntry
(
	const TCHAR * const	oldEntry,
	const TCHAR * const	newEntry
){
	int		entryIndex	= FindEntry( oldEntry );
	bool	replaced	= (entryIndex != -1);

	if( replaced )
	{
		lstrcpyn( m_szNames[ entryIndex ], newEntry, MRU_MAX_STRING - 1 );

		m_fDirty = TRUE;
	}

	return( replaced );

}	//	End of CMRUList::ReplaceEntry.


//--------------------------------------------------------------------------//
//	CMRUList::AppendEntry.													//
//--------------------------------------------------------------------------//
bool
CMRUList::AppendEntry
(
	const TCHAR * const	entry
){
	DebugEntry( CMRUList::AppendEntry );

	bool	result;
	
	if( (result = (FindEntry( entry ) == -1)) != false )
	{
		//	This entry doesn't already exist so we'll append it on...
		if( m_nValidEntries == MRU_MAX_ENTRIES )
		{
			//	The list is full so we'll replace the last one...
			lstrcpyn( m_szNames[ 0 ], entry, MRU_MAX_STRING - 1 );
		}
		else
		{
			if( m_nValidEntries > 0 )
			{
				ShiftEntries( 0, 1 );
			}

			lstrcpyn( m_szNames[ 0 ], entry, MRU_MAX_STRING - 1 );
			m_nValidEntries++;
		}

		//	Set the dirty flag...
		m_fDirty = TRUE;
	}

	DebugExitBOOL( CMRUList::AppendEntry, result );

	return( result );

}	//	End of CMRUList::AppendEntry.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mixer.h ===
// File: mixer.h

#ifndef _MIXER_H_
#define _MIXER_H_

typedef struct tagMixLVolume
{
	DWORD leftVolume;
	DWORD rightVolume;
}MIXVOLUME;

void NewMixVolume(MIXVOLUME* lpMixVolDest, const MIXVOLUME& mixVolSource, DWORD dwNewVolume);

typedef struct tagMixLine
{
	UINT	ucChannels;
	BOOL	fIdValid;
	DWORD	dwControlId;

	DWORD dwLineId;   // line ID of destination
	DWORD dwCompType; // Component type
	DWORD dwConnections; // number of sources associated with this line

	DWORD dwControls;  // number of sub controls (such as AGC) associated with this line
	BOOL fAgcAvailable;
	DWORD dwAGCID;
} MIXLINE;

class CMixerDevice
{
private:
	HMIXER	 	m_hMixer;
	MIXERCAPS	m_mixerCaps;
	MIXLINE		m_DstLine;
	MIXLINE		m_SrcLine;

	BOOL		Init( HWND hWnd, UINT uWaveDevId, DWORD dwFlags);

	BOOL DetectAGC();


protected:
	CMixerDevice()
	{
		m_hMixer = NULL;
		ZeroMemory (&m_DstLine, sizeof(m_DstLine));
		ZeroMemory (&m_SrcLine, sizeof(m_SrcLine));
	}

public:
	~CMixerDevice()
	{
		if (NULL != m_hMixer)
		{
			mixerClose(m_hMixer);
		}
	}

	BOOL SetVolume (MIXVOLUME * pdwVolume);
	BOOL CanSetVolume () { return m_DstLine.fIdValid || m_SrcLine.fIdValid; }
	BOOL SetMainVolume(MIXVOLUME * pdwVolume);
	BOOL SetSubVolume(MIXVOLUME * pdwVolume);
	BOOL SetAGC(BOOL fOn);
	BOOL GetMainVolume(MIXVOLUME * pdwVolume);
	BOOL GetSubVolume(MIXVOLUME * pdwVolume);
	BOOL GetVolume(MIXVOLUME * pdwVolume);
	BOOL GetAGC(BOOL *pfOn);
	BOOL EnableMicrophone();
	BOOL UnMuteVolume();

	static CMixerDevice* GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mrulist.h ===
// File: mrulist.h

// CMRUList class - a simple class for maintaining the list of
// most recently used items.
//
// Warning: this class doesn't not perform parameter validation
// and is not safe in a multi-threaded environment
//
// FUTURE: This chews up almost 4K for the string data!
//         Allow for generic type.

#ifndef _MRULIST_H_
#define _MRULIST_H_

const int MRU_MAX_ENTRIES = 15;
const int MRU_MAX_STRING  = 256;

class CMRUList
{
private:
	TCHAR	m_szNames[MRU_MAX_ENTRIES][MRU_MAX_STRING];
	BOOL	m_fDirty;
	int		m_nValidEntries;
	LPTSTR	m_pszRegKey;

	BOOL	ShiftEntries(int nSrc, int nDest, int cEntries=0);

public:
			CMRUList();
			~CMRUList();
	BOOL	Load(LPCTSTR pcszRegKey);
	BOOL	Save();
	int		GetNumEntries()						{ return m_nValidEntries; };

	// Note: these functions do not check if a valid index has been passed in
	LPCTSTR	GetNameEntry(int nEntryIndex)		{ return m_szNames[nEntryIndex];		};
	
	LPCTSTR PszEntry(int iItem)   {return m_szNames[(m_nValidEntries-iItem)-1];};


	BOOL	AddNewEntry(LPCTSTR pcszName);
	int		FindEntry(LPCTSTR pcszName);
	BOOL	MoveEntryToTop(int nIndex);

	bool
	DeleteEntry
	(
		const TCHAR * const	entry
	);

	bool
	ReplaceEntry
	(
		const TCHAR * const	oldEntry,
		const TCHAR * const	newEntry
	);

	bool
	AppendEntry
	(
		const TCHAR * const	entry
	);

};

#endif // ! _MRULIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mixer.cpp ===
#include "precomp.h"
#include <mixer.h>

//
// private APIs
//


#define MAX_MICROPHONE_DEVS 10

static MMRESULT mixerGetControlValue ( HMIXER, MIXVOLUME *, DWORD, UINT );
static MMRESULT mixerSetControlValue ( HMIXER, MIXVOLUME *, DWORD, UINT );
static MMRESULT mixerGetControlId ( HMIXER, DWORD *, DWORD, DWORD );
static MMRESULT mixerGetControlByType ( HMIXER, DWORD, DWORD, MIXERCONTROL *pMixerControl);

// used for AGC detection
static const char *szGain =  "gain";
static const char *szBoost = "boost";
static const char *szAGC   = "agc";


struct AGCDetails
{
	WORD wMID; // manufacturer ID
	WORD wPID; // product ID
	DWORD dwAGCID; // AGC ID
};



// we shouldn't have to use this table scheme anymore.
// CMixerDevice::DetectAGC will autodetect the control ID
static const AGCDetails AGCList[] =
{
//  MID    PID   AGCID
    {2,     409,   27},  // Creative Labs
    {21,     42,   13},  // Turtle Beach Tropez
    {132,     3, 2072},  // Crystal MMX
    {384,     7,   28},  // Xitel Storm 3d PCI
    {385,    32,   35}   // Aztech PCI-331
};


static BOOL GetAGCID(WORD wMID, WORD wPID, DWORD *pdwAGCID)
{
	int nIndex;
	int nAGCEntries = sizeof(AGCList) / sizeof(AGCDetails);

	for (nIndex = 0; nIndex < nAGCEntries; nIndex++)
	{
		if ( (AGCList[nIndex].wMID == wMID) &&
		     (AGCList[nIndex].wPID == wPID))
		{
			*pdwAGCID = AGCList[nIndex].dwAGCID;
			return TRUE;
		}
	}
	return FALSE;
}

/********************************************************************************\
*                                                                                *
*  void NewMixVolume(MIXVOLUME* lpMixVolDest, const MIXVOLUME& mixVolSource,     *
*                    DWORD      dwNewVolume)                                     *
*                                                                                *
*  NewMixVolume takes the current mixer value (mixVolSource), and converts it    *
*  to its adjusted value (lpMixVolDest) using the new volume settings            *
*  (dwNewVolume) and the proportionality between the left and right volumes of   *
*  mixVolSource. Note that if mixVolSource's left and right volumes are both     *
*  equal to zero, then their proportionality is set to 1/1.                      *
*                                                                                *
*  March 2001 Matthew Maddin (mmaddin@microsoft)                                 *
*                                                                                *
\********************************************************************************/
void NewMixVolume(MIXVOLUME* lpMixVolDest, const MIXVOLUME& mixVolSource, DWORD dwNewVolume)
{
    // If the source's left volume is the greater than the right volume, 
    // then it is the used to calculate the proportionality.
    if(mixVolSource.leftVolume == max(mixVolSource.leftVolume, mixVolSource.rightVolume))
    {
        // Set the left volume to the new value.
        lpMixVolDest->leftVolume = dwNewVolume;

        // If the left volume is non-zero, then continue with the proportionality calculation.
        if(mixVolSource.leftVolume)
        {
            // Calculate proportionality using the equation: NewRight = OldRight * (NewLeft/OldLeft)
            // where (NewLeft/OldLeft) Is the proportionality.
            lpMixVolDest->rightVolume = (mixVolSource.rightVolume*lpMixVolDest->leftVolume)/mixVolSource.leftVolume;

        }
        // Otherwise we cannot compute the proportionality and reset it to 1/1.
        // Note that 1/1 is not necessarily the 'correct' value. 
        else
        {
            // To maintain a ratio of 1/1 the right volume must equal the left volume.
            lpMixVolDest->rightVolume = lpMixVolDest->leftVolume;

        }

    }
    // Otherwise use the right volume to calculate the proportionality.
    else
    {
        // Set the right volume to the new value.
        lpMixVolDest->rightVolume = dwNewVolume;

        // If the right volume is non-zero, then continue with the proportionality calculation.
        if(mixVolSource.rightVolume)
        {
            // Calculate proportionality using the equation: NewLeft = OldLeft * (NewRight/OldRight)
            // where (NewRight/OldRight) Is the proportionality.
            lpMixVolDest->leftVolume = (mixVolSource.leftVolume*lpMixVolDest->rightVolume)/mixVolSource.rightVolume;

        }
        // Otherwise we cannot compute the proportionality and reset it to 1/1.
        // Note that 1/1 is not necessarily the 'correct' value. 
        else
        {
            // To maintain a ratio of 1/1 the left volume must equal the right volume.
            lpMixVolDest->leftVolume = lpMixVolDest->rightVolume;

        }

    }

}


//
//	Init
//
//	Enumerate all existing mixers in the system. For each mixer,
//	we enumerate all lines with destination Speaker and WaveIn.
//	For each such line, we cache the control id and control value
//	of volume control. An invalid flag will be tagged to any control
//  not supported by this mixer.
//	When an application is finished with all mixers operations,
//	it must call ReleaseAllMixers to free all memory resources and
//	mixers.
//
//	THIS MUST BE THE FIRST API TO CALL TO START MIXER OPERATIONS.
//
//	Input: The handle of the window which will handle all callback
//	messages MM_MIXM_CONTROL_CHANGE and MM_MIXM_LINE_CHANGE.
//
//	Output: TRUE if success; otherwise, FALSE.
//
BOOL CMixerDevice::Init( HWND hWnd, UINT uWaveDevId, DWORD dwFlags)
{
	UINT uMixerIdx, uDstIdx, uSrcIdx, uMixerIdCheck;
	MMRESULT mmr = MMSYSERR_NOERROR;
	MIXERLINE mlDst, mlSrc;
	UINT_PTR nMixers, nWaveInDevs, uIndex;

	//get the mixer device corresponding to the wave device
#ifndef _WIN64
	mmr = mixerGetID((HMIXEROBJ)uWaveDevId, &uMixerIdx, dwFlags);
#else
	mmr = MMSYSERR_NODRIVER;
#endif

	if ((mmr != MMSYSERR_NOERROR) && (mmr != MMSYSERR_NODRIVER)) {
		return FALSE;
	}

	// a simple fix for cheesy sound cards that don't make a
	// direct mapping between waveDevice and mixer device
	// e.g. MWAVE cards and newer SB NT 4 drivers
	// If there is only ONE mixer device  and if no other waveIn device
	// uses it, then it is probably valid.

	if ((mmr == MMSYSERR_NODRIVER) && (dwFlags == MIXER_OBJECTF_WAVEIN))
	{
		nMixers = mixerGetNumDevs();
		nWaveInDevs = waveInGetNumDevs();
		if (nMixers == 1)
		{
			uMixerIdx = 0;
			for (uIndex = 0; uIndex < nWaveInDevs; uIndex++)
			{
				mmr = mixerGetID((HMIXEROBJ)uIndex, &uMixerIdCheck, dwFlags);
				if ((mmr == MMSYSERR_NOERROR) && (uMixerIdCheck == uMixerIdx))
				{
					return FALSE;  // the mixer belongs to another waveIn Device
				}
			}
		}
		else
		{
			return FALSE;
		}
	}


	// open the mixer such that we can get notification messages
	mmr = mixerOpen (
			&m_hMixer,
			uMixerIdx,
			(DWORD_PTR) hWnd,
			0,
			(hWnd ? CALLBACK_WINDOW : 0) | MIXER_OBJECTF_MIXER);
	if (mmr != MMSYSERR_NOERROR) {
		return FALSE;
	}

	// get mixer caps
	mmr = mixerGetDevCaps (uMixerIdx, &(m_mixerCaps), sizeof (MIXERCAPS));
	if ((mmr != MMSYSERR_NOERROR) || (0 == m_mixerCaps.cDestinations)) {
		mixerClose(m_hMixer);
		return FALSE;
	}

	for (uDstIdx = 0; uDstIdx < m_mixerCaps.cDestinations; uDstIdx++)
	{
		ZeroMemory (&mlDst, sizeof (mlDst));
		mlDst.cbStruct = sizeof (mlDst);
		mlDst.dwDestination = uDstIdx;

		// get the mixer line for this destination
		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mlDst,
					MIXER_GETLINEINFOF_DESTINATION | MIXER_OBJECTF_HMIXER);
		if (mmr != MMSYSERR_NOERROR) continue;

		// examine the type of this destination line
		if (((MIXER_OBJECTF_WAVEOUT == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType)) ||
			((MIXER_OBJECTF_WAVEIN == dwFlags) &&
			 (MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType)))
		{
			 // fill in more info about DstLine
			m_DstLine.ucChannels = mlDst.cChannels;
			if (!(mlDst.fdwLine & MIXERLINE_LINEF_DISCONNECTED))
			{
				// get id and value of volume control
				mmr = mixerGetControlId (
						m_hMixer,
						&m_DstLine.dwControlId,
						mlDst.dwLineID,
						MIXERCONTROL_CONTROLTYPE_VOLUME);
				m_DstLine.fIdValid = (mmr == MMSYSERR_NOERROR);

				m_DstLine.dwLineId = mlDst.dwLineID;
				m_DstLine.dwCompType = mlDst.dwComponentType;
				m_DstLine.dwConnections = mlDst.cConnections;

				// -----------------------------------------------------
				// enumerate all sources for this destination
				for (uSrcIdx = 0; uSrcIdx < mlDst.cConnections; uSrcIdx++)
				{
					// get the info of the line with specific src and dst...
					ZeroMemory (&mlSrc, sizeof (mlSrc));
					mlSrc.cbStruct = sizeof (mlSrc);
					mlSrc.dwDestination = uDstIdx;
					mlSrc.dwSource = uSrcIdx;

					mmr = mixerGetLineInfo (
							(HMIXEROBJ)m_hMixer,
							&mlSrc,
							MIXER_GETLINEINFOF_SOURCE | MIXER_OBJECTF_HMIXER);
					if (mmr == MMSYSERR_NOERROR)
					{
						if (((MIXERLINE_COMPONENTTYPE_DST_SPEAKERS == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT == mlSrc.dwComponentType)) ||
							((MIXERLINE_COMPONENTTYPE_DST_WAVEIN == mlDst.dwComponentType) &&
							 (MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE == mlSrc.dwComponentType)))
						{
							// fill in more info about this source
							m_SrcLine.ucChannels = mlSrc.cChannels;

							// get id and value of volume control
							mmr = mixerGetControlId (
									m_hMixer,
									&m_SrcLine.dwControlId,
									mlSrc.dwLineID,
									MIXERCONTROL_CONTROLTYPE_VOLUME);
							m_SrcLine.fIdValid = (mmr == MMSYSERR_NOERROR);

							m_SrcLine.dwLineId = mlSrc.dwLineID;
							m_SrcLine.dwCompType = mlSrc.dwComponentType;
							m_SrcLine.dwConnections = mlSrc.cConnections;
							m_SrcLine.dwControls = mlSrc.cControls;

							DetectAGC();

							break;
						}
					}
				}
			}
			break;
		}
	}
		
    return TRUE;
}

CMixerDevice* CMixerDevice::GetMixerForWaveDevice( HWND hWnd, UINT uWaveDevId, DWORD dwFlags)
{
	CMixerDevice* pMixerDev = new CMixerDevice;
	if (NULL != pMixerDev)
	{
		if (!pMixerDev->Init(hWnd, uWaveDevId, dwFlags))
		{
			delete pMixerDev;
			pMixerDev = NULL;
		}
	}
	return pMixerDev;
}



// general method for setting the volume
// for recording, this will try to set both the master and microphone volume controls
// for playback, it will only set the WaveOut playback line (master line stays put)
BOOL CMixerDevice::SetVolume(MIXVOLUME * pdwVolume)
{
	BOOL fSetMain=FALSE, fSetSub;
	BOOL fMicrophone;
	
	// is this the microphone channel ?
	fMicrophone = ((m_DstLine.dwCompType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN) ||
	               (m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE));

	fSetSub = SetSubVolume(pdwVolume);

	if ((fMicrophone) || (!fSetSub))
	{
		fSetMain = SetMainVolume(pdwVolume);
	}

	return (fSetSub || fSetMain);

}


BOOL CMixerDevice::SetMainVolume(MIXVOLUME * pdwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;

	if (m_DstLine.fIdValid) {
		mmr = mixerSetControlValue (
				m_hMixer,
				pdwVolume,
				m_DstLine.dwControlId,
				2);
	}
	return (mmr == MMSYSERR_NOERROR);
}

BOOL CMixerDevice::SetSubVolume(MIXVOLUME * pdwVolume)
{
	MMRESULT mmr = MMSYSERR_ERROR;

	if (m_SrcLine.fIdValid)
	{
		mmr = mixerSetControlValue (
			m_hMixer,
			pdwVolume,
			m_SrcLine.dwControlId,
			m_SrcLine.ucChannels);
	}
	return (mmr == MMSYSERR_NOERROR);
}

//
// Gets the volume (0 - 65535) of the master volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetMainVolume(MIXVOLUME * pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_DstLine.fIdValid)
	{
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									pdwVolume,
									m_DstLine.dwControlId,
		                            2);
		fRet = (mmr == MMSYSERR_NOERROR);
	}

	return fRet;
}

//
// Gets the volume (0 - 65535) of the sub volume
// returns TRUE if succesful,
// returns FALSE if it fails or if this control is not available
//

BOOL CMixerDevice::GetSubVolume(MIXVOLUME * pdwVolume)
{
	BOOL fRet = FALSE;

	if (m_SrcLine.fIdValid)
	{
		MMRESULT mmr = ::mixerGetControlValue(
									m_hMixer,
									pdwVolume,
									m_SrcLine.dwControlId,
									m_SrcLine.ucChannels);
		fRet = (mmr == MMSYSERR_NOERROR);
	}

	return fRet;
}


BOOL CMixerDevice::GetVolume(MIXVOLUME * pdwVol)
{
	MIXVOLUME dwSub={0,0}, dwMain={0,0};
	BOOL fSubAvail, fMainAvail, fMicrophone;

	// is this the microphone channel ?
	fMicrophone = ((m_DstLine.dwCompType == MIXERLINE_COMPONENTTYPE_DST_WAVEIN) ||
	               (m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE));


	fSubAvail = GetSubVolume(&dwSub);
	fMainAvail = GetMainVolume(&dwMain);

	if ((!fSubAvail) && (!fMainAvail))
	{
		pdwVol->leftVolume = 0;
		pdwVol->rightVolume = 0;
		return FALSE;
	}

	// don't return an average volume in the case of the speaker mixer
	if (fSubAvail && fMainAvail && fMicrophone)
	{
		pdwVol->leftVolume =  dwSub.leftVolume;
		pdwVol->rightVolume = dwSub.rightVolume;
	}

	else if (fSubAvail)
	{
		pdwVol->leftVolume =  dwSub.leftVolume;
		pdwVol->rightVolume = dwSub.rightVolume;
	}

	else
	{
		pdwVol->leftVolume =  dwMain.leftVolume;
		pdwVol->rightVolume = dwMain.rightVolume;
	}

	return TRUE;

}


// Return the value of the Auto Gain Control
// Returns FALSE if the control is not supported.
// pfOn is OUTPUT, OPTIONAL - value of AGC
BOOL CMixerDevice::GetAGC(BOOL *pfOn)
{
	MIXVOLUME dwValue;
	MMRESULT mmr;

	if ((m_SrcLine.fIdValid==FALSE) || (m_SrcLine.fAgcAvailable==FALSE))
	{
		return FALSE;
	}

	mmr = mixerGetControlValue(m_hMixer, &dwValue, m_SrcLine.dwAGCID, 1);
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	if (pfOn)
	{
 		*pfOn = dwValue.leftVolume || dwValue.rightVolume;
	}
	
	return TRUE;
}

/*
	Hack API to turn MIC Auto Gain Control on or off.
	Its a hack because it only works on SB16/AWE32 cards.
*/
BOOL CMixerDevice::SetAGC(BOOL fOn)
{
	MIXVOLUME dwValue;
	MMRESULT mmr;

	if ((m_SrcLine.fIdValid==FALSE) || (m_SrcLine.fAgcAvailable==FALSE))
	{
		return FALSE;
	}

	mmr = mixerGetControlValue(m_hMixer, &dwValue, m_SrcLine.dwAGCID, 1);
	if (mmr != MMSYSERR_NOERROR)
	{
		return FALSE;
	}

	if (dwValue.leftVolume == (DWORD)fOn && dwValue.rightVolume == (DWORD)fOn)
	{
		return TRUE;
	}
	
	dwValue.leftVolume  = fOn;
	dwValue.rightVolume = fOn;
	mmr = mixerSetControlValue(m_hMixer, &dwValue, m_SrcLine.dwAGCID, 1);
	return (mmr == MMSYSERR_NOERROR);
}


// this method tries to determine if an AGC control is available by
// looking for a microphone sub-control that has a corresponding text
// string with the words "gain", "boost", or "agc" in in.
// If it can't  auto-detect it through string compares, it falls
// back to a table lookup scheme.  (Auto-detect will probably not work
// in localized versions of the driver.  But hardly anyone localizes
// their drivers.)
BOOL CMixerDevice::DetectAGC()
{
	MIXERLINECONTROLS mlc;
	MIXERCONTROL *aMC=NULL;
	MIXERCONTROL *pMC;
	MMRESULT mmrQuery;
	DWORD dwIndex;


	if ((m_SrcLine.fIdValid == FALSE) || (m_SrcLine.dwCompType != MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE))
	{
		return FALSE;
	}

	// make sure that dwControls isn't set to something outrageous
	if ((m_SrcLine.dwControls > 0) && (m_SrcLine.dwControls < 30))
	{
		aMC = new MIXERCONTROL[m_SrcLine.dwControls];

		mlc.cbStruct = sizeof(MIXERLINECONTROLS);
		mlc.dwLineID = m_SrcLine.dwLineId;
		mlc.dwControlType = 0; // not set ???
		mlc.cControls = m_SrcLine.dwControls;
		mlc.cbmxctrl = sizeof(MIXERCONTROL);  // set to sizeof 1 MC structure
		mlc.pamxctrl = aMC;


		mmrQuery = mixerGetLineControls((HMIXEROBJ)m_hMixer, &mlc, MIXER_OBJECTF_HMIXER|MIXER_GETLINECONTROLSF_ALL );
		if (mmrQuery == MMSYSERR_NOERROR)
		{
			for (dwIndex = 0; dwIndex < mlc.cControls; dwIndex++)
			{
				pMC = &aMC[dwIndex];

				// make sure we don't get a fader, mute, or some other control
				if ( (!(pMC->dwControlType & MIXERCONTROL_CT_CLASS_SWITCH)) ||
					 (pMC->dwControlType == MIXERCONTROL_CONTROLTYPE_MUTE) )
				{
					continue;
				}

				CharLower(pMC->szName);   // CharLower is a Win32 string function
				CharLower(pMC->szShortName);
				if ( _StrStr(pMC->szName, szGain) || _StrStr(pMC->szName, szBoost) || _StrStr(pMC->szName, szAGC) ||
			         _StrStr(pMC->szShortName, szGain) || _StrStr(pMC->szShortName, szBoost) || _StrStr(pMC->szShortName, szAGC) )
				{
					m_SrcLine.fAgcAvailable = TRUE;
					m_SrcLine.dwAGCID = pMC->dwControlID;
					TRACE_OUT(("CMixerDevice::DetectAGC - Autodetected control ID %d as AGC\r\n", m_SrcLine.dwAGCID));
					break;
				}
			}
		}
	}

	// if we didn't find the mixer dynamically, consult our old list
	if (!m_SrcLine.fAgcAvailable)
	{
		m_SrcLine.fAgcAvailable = GetAGCID(m_mixerCaps.wMid, m_mixerCaps.wPid, &(m_SrcLine.dwAGCID));
	}

	if (aMC)
		delete [] aMC;

	return m_SrcLine.fAgcAvailable;
}



BOOL CMixerDevice::EnableMicrophone()
{
	MIXERLINE mixerLine;
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails, mixerControlDetailsOrig;
	UINT uIndex, numItems, numMics, numMicsSet, fMicFound;
	UINT uMicIndex = 0;
	UINT aMicIndices[MAX_MICROPHONE_DEVS];
	MIXERCONTROLDETAILS_LISTTEXT *aListText = NULL;
	MIXERCONTROLDETAILS_BOOLEAN *aEnableList = NULL;
	MMRESULT mmr;
	BOOL fLoopback=FALSE;
	UINT uLoopbackIndex=0;

	// check to see if component type is valid (which means the line exists!)
	// even if the volume control doesn't exist or isn't slidable,
	// there may still be a select switch
	if ((m_SrcLine.dwCompType != MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE) ||
	    (m_DstLine.dwCompType != MIXERLINE_COMPONENTTYPE_DST_WAVEIN))
	{
		return FALSE;
	}

	// try to find the mixer list
	if (    (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CT_CLASS_LIST, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MIXER, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUX, &mixerControl))
	    &&  (MMSYSERR_NOERROR != mixerGetControlByType(m_hMixer, m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_SINGLESELECT, &mixerControl))
	   )
	{
		TRACE_OUT(("CMixerDevice::EnableMicrophone-Unable to find mixer list!"));

		// if no mixer list, see if there is a "mute" control...
		return UnMuteVolume();

		// note: even though we don't have a mixer mux/select control
		// we could still find a way to mute the loopback line
		// unfortunately, we don't have the code that finds the line id
		// of the loopback control

	}

	ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));

	mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
	mixerControlDetails.dwControlID = mixerControl.dwControlID;
	if (MIXERCONTROL_CONTROLF_UNIFORM & mixerControl.fdwControl)
		mixerControlDetails.cChannels = 1;
	else
		mixerControlDetails.cChannels = m_DstLine.ucChannels;

	if (MIXERCONTROL_CONTROLF_MULTIPLE & mixerControl.fdwControl)
		mixerControlDetails.cMultipleItems = (UINT)mixerControl.cMultipleItems;
	else
		mixerControlDetails.cMultipleItems = 1;

	// weirdness - you have to set cbDetails to the size of a single LISTTEXT item
	// setting it to anything larger will make the call fail
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);


	numItems = mixerControlDetails.cMultipleItems;
	if (m_DstLine.dwConnections > numItems)
		numItems = m_DstLine.dwConnections;

	aListText = new MIXERCONTROLDETAILS_LISTTEXT[numItems];
	aEnableList = new MIXERCONTROLDETAILS_BOOLEAN[numItems];
	if ((aListText == NULL) || (aEnableList == NULL))
	{
		WARNING_OUT(("CMixerDevice::EnableMicrophone-Out of memory"));
		return FALSE;
	}

	ZeroMemory(aListText, sizeof(MIXERCONTROLDETAILS_LISTTEXT)*numItems);
	ZeroMemory(aEnableList, sizeof(MIXERCONTROLDETAILS_BOOLEAN)*numItems);

	mixerControlDetails.paDetails = aListText;

	// preserve the settings, some values will change after this call
	mixerControlDetailsOrig = mixerControlDetails;

	// query for the text of the list
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	                             MIXER_GETCONTROLDETAILSF_LISTTEXT
	                             |MIXER_OBJECTF_HMIXER);

	// some sound cards don't specify CONTROLF_MULTIPLE
	// try doing what sndvol32 does for MUX controls
	if (mmr != MMSYSERR_NOERROR)
	{
		mixerControlDetails = mixerControlDetailsOrig;
		mixerControlDetails.cChannels = 1;
		mixerControlDetails.cMultipleItems = m_DstLine.dwConnections;
		mixerControlDetailsOrig = mixerControlDetails;
		mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_LISTTEXT
		                             |MIXER_OBJECTF_HMIXER);
	}

	if (mmr != MMSYSERR_NOERROR)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// enumerate for the microphone
	numMics = 0;
	fMicFound = FALSE;
	for (uIndex = 0; uIndex < mixerControlDetails.cMultipleItems; uIndex++)
	{
		// dwParam1 of the listText structure is the LineID of the source
		// dwParam2 should be the component type, but unfoturnately not
		// all sound cards obey this rule.
		ZeroMemory (&mixerLine, sizeof(MIXERLINE));
		mixerLine.cbStruct = sizeof(MIXERLINE);
		mixerLine.dwLineID = aListText[uIndex].dwParam1;

		mmr = mixerGetLineInfo ((HMIXEROBJ)m_hMixer, &mixerLine,
					MIXER_GETLINEINFOF_LINEID | MIXER_OBJECTF_HMIXER);

		if ((mmr == MMSYSERR_NOERROR) &&
		    (mixerLine.dwComponentType == m_SrcLine.dwCompType) &&
			 (numMics < MAX_MICROPHONE_DEVS))
		{
			aMicIndices[numMics] = uIndex;
			numMics++;
		}

		if (aListText[uIndex].dwParam1 == m_SrcLine.dwLineId)
		{
			uMicIndex = uIndex;
			fMicFound = TRUE;  // can't rely on uIndex or uNumMics not zero
		}

		if ((mmr == MMSYSERR_NOERROR) &&
		    (mixerLine.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
		{
			fLoopback = TRUE;
			uLoopbackIndex = uIndex;
		}

	}

	if (fMicFound == FALSE)
	{
		delete [] aListText;
		delete [] aEnableList;
		return FALSE;
	}

	// now we know which position in the array to set, let's do it.
	mixerControlDetails = mixerControlDetailsOrig;
	mixerControlDetails.paDetails = aEnableList;
	mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

	// find out what's already marked as set.
	mmr = mixerGetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
	        MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);

	if ( (mmr == MMSYSERR_NOERROR) &&
	     ( (aEnableList[uMicIndex].fValue != 1) || (fLoopback && aEnableList[uLoopbackIndex].fValue == 1) )
	   )
	{
		// how many microphone's are already enabled ?
		// if another microphone is already enabled and if the device is MUX type
		// we won't attempt to turn one on.
		numMicsSet = 0;
		for (uIndex = 0; uIndex < numMics; uIndex++)
		{
			if ((aEnableList[aMicIndices[uIndex]].fValue == 1) &&
			    (uIndex != uMicIndex))
			{
				numMicsSet++;
			}
		}


		if ( (mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_MUX)
		   ||(mixerControl.dwControlType == MIXERCONTROL_CONTROLTYPE_SINGLESELECT))
		{
			ZeroMemory(aEnableList, sizeof(aEnableList)*numItems);
			aEnableList[uMicIndex].fValue = 1;
			if (numMicsSet == 0)
			{
				mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
			                             MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
			}
			else
			{
				mmr = MMSYSERR_ERROR;  // a mike has already been enabled
			}
		}
		else
		{
			mixerControlDetails = mixerControlDetailsOrig;
			mixerControlDetails.paDetails = aEnableList;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

			// enable the microphone
			aEnableList[uMicIndex].fValue = 1;

			mmr = mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
		                             MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);


			// disable the loopback input
			if (fLoopback)
			{
				aEnableList[uLoopbackIndex].fValue = 0;

				mixerSetControlDetails((HMIXEROBJ)m_hMixer, &mixerControlDetails,
			                             MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);

			}

			
		}
	}

	delete []aEnableList;
	delete []aListText;

	return (mmr == MMSYSERR_NOERROR);

}


BOOL CMixerDevice::UnMuteVolume()
{
	MIXERCONTROL mixerControl;
	MIXERCONTROLDETAILS mixerControlDetails;
	MIXERCONTROLDETAILS_BOOLEAN mcdb;
	MMRESULT mmrMaster=MMSYSERR_ERROR, mmrSub=MMSYSERR_ERROR;

	// try to unmute the master volume (playback only)
	if (m_DstLine.dwCompType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)
	{


		mmrMaster = mixerGetControlByType(m_hMixer,
		            m_DstLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
			          &mixerControl);

		if (mmrMaster == MMSYSERR_NOERROR)
		{
			ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
			mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
			mixerControlDetails.dwControlID = mixerControl.dwControlID;

			mixerControlDetails.cChannels = 1;
			mixerControlDetails.cMultipleItems = 0;

			mcdb.fValue = 0;
			mixerControlDetails.paDetails = &mcdb;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

			mmrMaster = mixerSetControlDetails((HMIXEROBJ)m_hMixer,
			            &mixerControlDetails,
			            MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		
		}
	}


	// Unmute the source line
	// this will unmute WaveOut, and possibly the microphone
	// (Use EnableMicrophone() above to handle all the potential microphone cases)

	if ((m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE) ||
		(m_SrcLine.dwCompType == MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT))
	{

	
		mmrSub = mixerGetControlByType(m_hMixer,
		         m_SrcLine.dwLineId, MIXERCONTROL_CONTROLTYPE_MUTE,
			     &mixerControl);

		if (mmrSub == MMSYSERR_NOERROR)
		{
			ZeroMemory(&mixerControlDetails, sizeof(MIXERCONTROLDETAILS));
			mixerControlDetails.cbStruct = sizeof(MIXERCONTROLDETAILS);
			mixerControlDetails.dwControlID = mixerControl.dwControlID;

			mixerControlDetails.cChannels = 1;
			mixerControlDetails.cMultipleItems = 0;

			mcdb.fValue = 0;
			mixerControlDetails.paDetails = &mcdb;
			mixerControlDetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);

			mmrSub =  mixerSetControlDetails((HMIXEROBJ)m_hMixer,
				      &mixerControlDetails,
					  MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_HMIXER);
		}
	}


	return ((mmrSub == MMSYSERR_NOERROR) || (mmrMaster == MMSYSERR_NOERROR));

}



//////////////////////////////////////////////////
//
// The following are private APIs
//

static MMRESULT mixerGetControlValue ( HMIXER hMixer, MIXVOLUME *pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (MIXVOLUME);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerGetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_GETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerSetControlValue ( HMIXER hMixer, MIXVOLUME * pdwValue,
								DWORD dwControlId, UINT ucChannels )
{
	MIXERCONTROLDETAILS mxcd;
	MMRESULT mmr;

	ZeroMemory (&mxcd, sizeof (mxcd));
	mxcd.cbStruct = sizeof (mxcd);
	mxcd.dwControlID = dwControlId;
	mxcd.cChannels = ucChannels;
	mxcd.cbDetails = sizeof (MIXVOLUME);
	mxcd.paDetails = (PVOID) pdwValue;
	mmr = mixerSetControlDetails ((HMIXEROBJ) hMixer, &mxcd,
			MIXER_SETCONTROLDETAILSF_VALUE | MIXER_OBJECTF_HMIXER);
	return mmr;
}


static MMRESULT mixerGetControlId ( HMIXER hMixer, DWORD *pdwControlId,
							 DWORD dwLineId, DWORD dwControlType )
{
	MIXERLINECONTROLS mxlc;
	MIXERCONTROL mxc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (&mxc, sizeof (mxc));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (mxc);
	mxlc.pamxctrl = &mxc;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	*pdwControlId = mxc.dwControlID;
	return mmr;
}


// similar to above, except returns the whole control
static MMRESULT mixerGetControlByType ( HMIXER hMixer, DWORD dwLineId, DWORD dwControlType, MIXERCONTROL *pMixerControl)
{
	MIXERLINECONTROLS mxlc;
	MMRESULT mmr;

	ZeroMemory (&mxlc, sizeof (mxlc));
	ZeroMemory (pMixerControl, sizeof (MIXERCONTROL));
	mxlc.cbStruct = sizeof (mxlc);
	mxlc.dwLineID = dwLineId;
	mxlc.dwControlType = dwControlType;
	mxlc.cControls = 1;
	mxlc.cbmxctrl = sizeof (MIXERCONTROL);
	mxlc.pamxctrl = pMixerControl;
	mmr = mixerGetLineControls ((HMIXEROBJ) hMixer, &mxlc,
				MIXER_GETLINECONTROLSF_ONEBYTYPE | MIXER_OBJECTF_HMIXER);
	
	return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\multistatetoolbar.h ===
#ifndef __MultiStateToolbar_h__
#define __MultiStateToolbar_h__

class CMultiStateToolbar 
: public CWindowImpl< CMultiStateToolbar  >
{

public:

    // Datatypes
    struct ItemStateInfo
    {
        DWORD   dwID;
        BYTE    TbStyle;
        HBITMAP hItemBitmap;
        HBITMAP hItemHotBitmap;
        HBITMAP hItemDisabledBitmap;
    };

    struct BlockItemStateData
    {
        DWORD   dwID;
        DWORD   dwBitmapIndex;
        BYTE    TbStyle;
    };

    struct BlockData
    {
        LPCTSTR             szTitle;
        int                 cbStates;
        BlockItemStateData* pStateData;
    };

    
    struct TBItemStateData
    {
        DWORD  BitmapId;
        DWORD  CommandId;
        DWORD  StringId;
        BYTE   TbStyle;
    };

    struct TBItemData
    {
        int              cStates;
        int              CurrentState;
        TBItemStateData *pStateData;
    };

public:
    // Construction and destruction
    CMultiStateToolbar( void );
    ~CMultiStateToolbar( void );

    // Methods
    HRESULT Create( HWND hWndParent, 
                    DWORD dwID,
                    int cxButton,
                    int cyButton,
	                int cxBtnBitmaps,
                    int cyBtnBitmaps
                  );

    HRESULT Show( BOOL bShow );
    HRESULT InsertItem( int cStates, LPCTSTR szTitle, ItemStateInfo* pItemStates, int* pIndex );

    HRESULT InsertBlock( int nItems, 
                         BlockData* pItemData,
                         HINSTANCE hInstance, 
                         int idTBBitmap,
                         int idTBBitmapHot,
                         int idTBBitmapDisabled,
                         int* pIndexFirst
                       );

    HRESULT EnableItem( DWORD dwCmd, BOOL bEnable = TRUE );
    HRESULT SetItemState( int iIndex, int NewState );
    HRESULT ShowLabels( BOOL bShowLabels );
    HRESULT Resize( RECT& rc );
    HRESULT GetWindow( HWND* phWnd );


BEGIN_MSG_MAP(CMultiStateToolbar)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
END_MSG_MAP()

        // Message handlers
    LRESULT OnDestroy(UINT uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnNcDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
        // This is here in case we change the toolbar to be a CContainedWindow
    HWND _GetToolbarWindow( void ) { return m_hWnd; }
    HRESULT _CreateImageLists( void );
    void _KillAllButtons( void );

    // Data
private:
	int m_cxButton;
    int m_cyButton;
	int m_cxBtnBitmaps;
    int m_cyBtnBitmaps;

    HIMAGELIST m_himlTB;
    HIMAGELIST m_himlTBHot;
    HIMAGELIST m_himlTBDisabled;
};

#endif // __MultiStateToolbar_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mrulist2.h ===
// File: mrulist.h

#ifndef _MRULIST2_H_
#define _MRULIST2_H_

#include "ConfUtil.h"
#include "richaddr.h"

typedef VOID * PMRUE;  // MRU Entries

enum {
	MRUTYPE_SZ = 1,
	MRUTYPE_DW = 2,
};

class CMRUList2
{
private:
	const DWSTR * m_prgDwStr;// {{cCol, pszKey}, {mruType, pszPrefix1}, {mruType, pszPrefix2},...}
	int     m_cCol;       // number of "columns" (data entries in m_prgDwStr)
	int     m_cEntryMax;  // maximum number of entries
	int	    m_cEntry;     // current number of entries
	PMRUE * m_rgpEntry;   // array of pointers to MRU data
	BOOL    m_fDirty;     // TRUE if data was changed
	BOOL    m_fReversed;  // Load/Save data reversed (old style)

	BOOL    FValidCol(int i)    {return ((i >= 0) && (i < m_cCol));}
	BOOL    FValidIndex(int i)  {return ((i >= 0) && (i < m_cEntry));}
	BOOL    FDirty()            {return m_fDirty;}
	BOOL    FReversed()         {return m_fReversed;}

	inline PMRUE GetEntry(int iItem)
	{
		ASSERT(FValidIndex(iItem));
		return m_rgpEntry[iItem];
	}

	inline int MruTypeForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].dw;
	}

	inline LPCTSTR PszPrefixForCol(int iCol)
	{
		ASSERT(FValidCol(iCol));
		return m_prgDwStr[1+iCol].psz;
	}

	inline LPCTSTR PszRegKey(void)
	{
		return m_prgDwStr[0].psz;
	}

	VOID    ShiftEntriesDown(int cItem);

protected:
	virtual int CompareEntry(int iItem, PMRUE pEntry);

public:
	CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReverse = FALSE);
	~CMRUList2();

	int     GetNumEntries()     {return m_cEntry;}
	VOID    SetDirty(BOOL fDirty)     {m_fDirty = fDirty;}

	// Generic functions
	int     FindEntry(PMRUE pEntry);
	VOID    MoveEntryToTop(int iItem);
	PMRUE   LoadEntry(RegEntry * pre, int iItem);
	VOID    StoreEntry(RegEntry * pre, int iItem);
	VOID    DeleteEntry(PMRUE pEntry);
	VOID    DeleteEntry(int iItem);

	void
	DeleteEntry
	(
		const TCHAR * const	primaryString
	);
	 
	HRESULT Save(void);

	LPCTSTR GetString(int iItem, int iCol);
	DWORD GetDWORD(int iItem, int iCol);

	LPCTSTR GetString(PMRUE pEntry, int iCol);
	DWORD GetDWORD(PMRUE pEntry, int iCol);

	HRESULT AddEntry(PMRUE pEntry);
	HRESULT AddEntry(LPCTSTR pcsz);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2);
	HRESULT AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3);
};


#endif /* _MRULIST2_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\multistatetoolbar.cpp ===
#include "precomp.h"
#include "MultiStateToolbar.h"



CMultiStateToolbar::CMultiStateToolbar( void )
: 	m_cxButton( 0 ),
    m_cyButton( 0 ),
	m_cxBtnBitmaps( 0 ),
    m_cyBtnBitmaps( 0 ),
    m_himlTB(NULL),
    m_himlTBHot(NULL),
    m_himlTBDisabled(NULL)
{
    DBGENTRY(CMultiStateToolbar::CMultiStateToolbar);

    DBGEXIT(CMultiStateToolbar::CMultiStateToolbar);
}

CMultiStateToolbar::~CMultiStateToolbar( void )
{
    DBGENTRY(CMultiStateToolbar::~CMultiStateToolbar);

    _KillAllButtons();

    if(m_himlTB) 
    {
        ImageList_Destroy(m_himlTB);
        m_himlTB = NULL;
    }

    if(m_himlTBHot)
    {
        ImageList_Destroy(m_himlTBHot);
        m_himlTBHot = NULL;
    }

    if(m_himlTBDisabled)
    {
        ImageList_Destroy(m_himlTBDisabled);
        m_himlTBDisabled = NULL;
    }

    if( ::IsWindow( m_hWnd ) )
    {
        DestroyWindow();
    }

	m_hWnd = NULL;

    DBGEXIT(CMultiStateToolbar::~CMultiStateToolbar);
}   

HRESULT CMultiStateToolbar::Create( HWND hWndParent, 
                                    DWORD dwID,
                                    int cxButton,
                                    int cyButton,
	                                int cxBtnBitmaps,
                                    int cyBtnBitmaps
 )
{
    DBGENTRY(CMultiStateToolbar::Create);
    HRESULT hr = S_OK;

    m_cxButton = cxButton;
    m_cyButton = cyButton;
    m_cxBtnBitmaps = cxBtnBitmaps;
    m_cyBtnBitmaps = cyBtnBitmaps;

	DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | 
			        TBSTYLE_FLAT | TBSTYLE_TOOLTIPS | TBSTYLE_ALTDRAG |
			        CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NORESIZE;

    HWND hWndToolbar = CreateToolbarEx( hWndParent,
                                        dwStyle,
                                        dwID,
                                        0,              // nBitmaps
										NULL,			// instance
										NULL,			// NO bitmap ID!
										NULL,			// buttons
										0,				// number of buttons
										m_cxButton,     // button sizes
                                        m_cyButton,   
										m_cxBtnBitmaps, // bitmap sizes
                                        m_cyBtnBitmaps,   
										sizeof(TBBUTTON)
                                       );

    if( hWndToolbar )
    {
		DWORD dwStyle = ::SendMessage(hWndToolbar, TB_GETEXTENDEDSTYLE, 0, 0);
		dwStyle |= TBSTYLE_EX_DRAWDDARROWS;
		::SendMessage(hWndToolbar, TB_SETEXTENDEDSTYLE, 0, (LPARAM) dwStyle);

        SubclassWindow( hWndToolbar );
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    DBGEXIT_HR(CMultiStateToolbar::Create,hr);
    return hr;
}


HRESULT CMultiStateToolbar::Show( BOOL bShow )
{
    DBGENTRY(CMultiStateToolbar::Show);
    HRESULT hr = S_OK;

    ShowWindow( bShow ? SW_SHOW : SW_HIDE );
        
    DBGEXIT_HR(CMultiStateToolbar::Show,hr);
    return hr;    
}

HRESULT CMultiStateToolbar::InsertItem( int cStates, LPCTSTR szTitle, ItemStateInfo* pItemStates, int* pIndex )
{
    DBGENTRY(CMultiStateToolbar::InsertItem);
    HRESULT hr = S_OK;

    if( NULL == m_himlTB )
    {
        hr = _CreateImageLists();
    }


    TBItemData* pNewItemData = new TBItemData;
    pNewItemData->CurrentState = 0;
    pNewItemData->cStates = cStates;
    pNewItemData->pStateData = new TBItemStateData[ pNewItemData->cStates ];

    int cImageListItemsBeforeInsertion = ImageList_GetImageCount( m_himlTB );

        // For each state
    for( int iState = 0; iState < cStates; iState++ )
    {
            // Insert the bitmaps
	    if( pItemStates[iState].hItemBitmap )
        {
	        if (-1 != ImageList_AddMasked(m_himlTB, pItemStates[iState].hItemBitmap, TOOLBAR_MASK_COLOR))
	        {
		        SendMessage(TB_SETIMAGELIST, 0, (LPARAM) m_himlTB);
	        }
            else
            {
                hr = E_FAIL;
            }
        }

        if( SUCCEEDED( hr ) )
        {
	        if( pItemStates[iState].hItemHotBitmap )
            {
	            if (-1 != ImageList_AddMasked(m_himlTBHot, pItemStates[iState].hItemHotBitmap, TOOLBAR_MASK_COLOR))
	            {
		            SendMessage(TB_SETHOTIMAGELIST, 0, (LPARAM) m_himlTBHot);
	            }
                else
                {
                    hr = E_FAIL;
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
	        if( pItemStates[iState].hItemDisabledBitmap )
            {
	            if (-1 != ImageList_AddMasked(m_himlTBDisabled, pItemStates[iState].hItemDisabledBitmap, TOOLBAR_MASK_COLOR))
	            {
		            SendMessage(TB_SETDISABLEDIMAGELIST, 0, (LPARAM) m_himlTBDisabled);
	            }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        
        // save the state data

        pNewItemData->pStateData[iState].BitmapId = cImageListItemsBeforeInsertion + iState;
        pNewItemData->pStateData[iState].CommandId = pItemStates[iState].dwID;
        pNewItemData->pStateData[iState].TbStyle = pItemStates[iState].TbStyle;
        pNewItemData->pStateData[iState].StringId = SendMessage( TB_ADDSTRING, 0, reinterpret_cast<LPARAM>( szTitle ) );

    }

    int nButtons = SendMessage(TB_BUTTONCOUNT, 0, 0 );

    // Insert the Item



    TBBUTTON tbi;
    ClearStruct(&tbi);
    tbi.iBitmap = pNewItemData->pStateData[0].BitmapId;
    tbi.idCommand = pNewItemData->pStateData[0].CommandId;
    tbi.fsState = TBSTATE_ENABLED;
    tbi.fsStyle = pNewItemData->pStateData[0].TbStyle;
    tbi.dwData = reinterpret_cast<DWORD>(pNewItemData);
    tbi.iString = pNewItemData->pStateData[0].StringId;
    
    SendMessage(TB_INSERTBUTTON, nButtons, reinterpret_cast<LPARAM>(&tbi));
    
    if( pIndex )
    {
        *pIndex = nButtons;
    }

    DBGEXIT_HR(CMultiStateToolbar::InsertItem,hr);
    return hr;
}




HRESULT CMultiStateToolbar::InsertBlock( int nItems, 
                                         CMultiStateToolbar::BlockData* pAryOfItemData,
                                         HINSTANCE hInstance, 
                                         int idTBBitmap,
                                         int idTBBitmapHot,
                                         int idTBBitmapDisabled,
                                         int* pIndexFirst
                                       )
{
    DBGENTRY(CMultiStateToolbar::InsertBlock);
    HRESULT hr = S_OK;
    
    if( pAryOfItemData )
    {
        if( NULL == m_himlTB )
        {
            hr = _CreateImageLists();
        }

        if( SUCCEEDED( hr ) )
        {
            HBITMAP hBmp = NULL;
            int cImageListItemsBeforeInsertion = ImageList_GetImageCount( m_himlTB );

                // Load the Normal Toolbar Bitmap
	        hBmp = (HBITMAP) LoadImage(hInstance, MAKEINTRESOURCE(idTBBitmap), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);

	        if( hBmp )
            {
	            if (-1 != ImageList_AddMasked(m_himlTB, hBmp, TOOLBAR_MASK_COLOR))
	            {
		            SendMessage(TB_SETIMAGELIST, 0, (LPARAM) m_himlTB);
	            }
                else
                {
                    hr = E_FAIL;
                }

	            DeleteObject(hBmp);
            }

            if( SUCCEEDED( hr ) )
            {
                    // Load the Hot Toolbar Bitmap
	            hBmp = (HBITMAP) LoadImage(hInstance, MAKEINTRESOURCE(idTBBitmapHot), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);

	            if( hBmp )
                {
	                if (-1 != ImageList_AddMasked(m_himlTBHot, hBmp, TOOLBAR_MASK_COLOR))
	                {
		                SendMessage(TB_SETHOTIMAGELIST, 0, (LPARAM) m_himlTBHot);
	                }
                    else
                    {
                        hr = E_FAIL;
                    }

	                DeleteObject(hBmp);
                }
            }

            if( SUCCEEDED( hr ) )
            {
                // Load the Disabled Toolbar Bitmap
	            hBmp = (HBITMAP) LoadImage(hInstance, MAKEINTRESOURCE(idTBBitmapDisabled), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE);

	            if( hBmp )
                {
	                if (-1 != ImageList_AddMasked(m_himlTBDisabled, hBmp, TOOLBAR_MASK_COLOR))
	                {
		                SendMessage(TB_SETDISABLEDIMAGELIST, 0, (LPARAM) m_himlTBDisabled);
	                }
                    else
                    {
                        hr = E_FAIL;
                    }

	                DeleteObject(hBmp);
                }
            }
            
            int nButtons = SendMessage(TB_BUTTONCOUNT, 0, 0 );

            if( pIndexFirst )
            {
                *pIndexFirst = nButtons; 
            }

                // For each button to be inserted...
            for( int iItem = 0; SUCCEEDED( hr ) && ( iItem < nItems ) ; iItem++ )
            {
                TBItemData* pNewItemData = new TBItemData;
                pNewItemData->CurrentState = 0;
                pNewItemData->cStates = pAryOfItemData[iItem].cbStates;
                pNewItemData->pStateData = new TBItemStateData[ pNewItemData->cStates ];
                
                int iStringID = SendMessage( TB_ADDSTRING, 0, reinterpret_cast<LPARAM>( pAryOfItemData[iItem].szTitle ) );
                for( int iState = 0; iState < pAryOfItemData[iItem].cbStates; iState++ )
                {
                    pNewItemData->pStateData[iState].BitmapId = pAryOfItemData[iItem].pStateData[iState].dwBitmapIndex;
                    pNewItemData->pStateData[iState].CommandId = pAryOfItemData[iItem].pStateData[iState].dwID;
                    pNewItemData->pStateData[iState].TbStyle = pAryOfItemData[iItem].pStateData[iState].TbStyle;
                    pNewItemData->pStateData[iState].StringId = iStringID;
                }

                TBBUTTON tbi;
                ClearStruct(&tbi);
                tbi.iBitmap = cImageListItemsBeforeInsertion + pNewItemData->pStateData[0].BitmapId;
                tbi.idCommand = pNewItemData->pStateData[0].CommandId;
                tbi.fsState = TBSTATE_ENABLED;
                tbi.fsStyle = pNewItemData->pStateData[0].TbStyle;
                tbi.dwData = reinterpret_cast<DWORD>(pNewItemData);
                tbi.iString = pNewItemData->pStateData[0].StringId;
                
                if( SendMessage(TB_INSERTBUTTON, nButtons, reinterpret_cast<LPARAM>(&tbi)) )
                {
                    ++nButtons;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
        }
    }
    else
    {
        hr = E_POINTER;

    }
    
    DBGEXIT_HR(CMultiStateToolbar::InsertBlock,hr);
    return hr;
}

HRESULT CMultiStateToolbar::EnableItem( DWORD dwCmd, BOOL bEnable /* = TRUE */)
{
    DBGENTRY(CMultiStateToolbar::EnableItem);
    HRESULT hr = S_OK;

    if( ::IsWindow( _GetToolbarWindow() ) )
    {
        if( !SendMessage(TB_ENABLEBUTTON, dwCmd, bEnable ) )
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    DBGEXIT_HR(CMultiStateToolbar::EnableItem,hr);
    return hr;
}

HRESULT CMultiStateToolbar::SetItemState( int iIndex, int NewState )
{
    DBGENTRY(CMultiStateToolbar::SetItemState);
    HRESULT hr = S_OK;

    if( ::IsWindow( _GetToolbarWindow() ) )
    {
        TBBUTTON tbb;
        ClearStruct(&tbb);
        SendMessage( TB_GETBUTTON, iIndex, reinterpret_cast<LPARAM>(&tbb));

        TBItemData* pItemData = reinterpret_cast<TBItemData*>(tbb.dwData);
        if( pItemData )
        {
            if( NewState < pItemData->cStates )
            {
                if( pItemData->CurrentState != NewState )
                {
                    // We have to change the state
                    TBBUTTONINFO tbbi;
                    ClearStruct(&tbbi);
                    tbbi.cbSize = sizeof( TBBUTTONINFO );
                    tbbi.dwMask = TBIF_IMAGE | TBIF_COMMAND | TBIF_STYLE; 
                    tbbi.idCommand = pItemData->pStateData[NewState].CommandId;
                    tbbi.iImage = pItemData->pStateData[NewState].BitmapId;
                    tbbi.fsStyle = pItemData->pStateData[NewState].TbStyle;

                    // NOTE:  Changing the string stuff is not supported....
                    if( SendMessage( TB_SETBUTTONINFO, pItemData->pStateData[pItemData->CurrentState].CommandId, reinterpret_cast<LPARAM>(&tbbi) ) )
                    {
                        pItemData->CurrentState = NewState;
                    }

                    // force the image to be redrawn
				    RECT rc;
				    SendMessage(TB_GETITEMRECT, iIndex, reinterpret_cast<LPARAM>(&rc));
				    InvalidateRect(&rc);
                    InvalidateRect(NULL, TRUE);


                }
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }



    DBGEXIT_HR(CMultiStateToolbar::SetItemState,hr);
    return hr;
}

HRESULT CMultiStateToolbar::ShowLabels( BOOL bShowLabels)
{
    DBGENTRY(CMultiStateToolbar::ShowLabels);
    HRESULT hr = S_OK;

    if( !bShowLabels )
    {
        SendMessage(TB_SETBUTTONSIZE, 0, MAKELPARAM( m_cxBtnBitmaps, m_cyBtnBitmaps ) );
    }
    else
    {
        SendMessage(TB_SETBUTTONSIZE, 0, MAKELPARAM( m_cxButton, m_cyButton ) );
    }

    SendMessage(TB_SETMAXTEXTROWS, bShowLabels ? 1 : 0, 0);


    DBGEXIT_HR(CMultiStateToolbar::ShowLabels,hr);
    return hr;
}


HRESULT CMultiStateToolbar::Resize( RECT& rc )
{
    DBGENTRY(CMultiStateToolbar::Resize);
    HRESULT hr = S_OK;

	if( !SetWindowPos( NULL, &rc, SWP_NOACTIVATE | SWP_NOZORDER) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    DBGEXIT_HR(CMultiStateToolbar::Resize,hr);
    return hr;
}


HRESULT CMultiStateToolbar::GetWindow( HWND* phWnd )
{
    DBGENTRY(CMultiStateToolbar::GetWindow);
    HRESULT hr = S_OK;
    if( phWnd )
    {
        ASSERT( NULL == *phWnd );

        *phWnd = _GetToolbarWindow();
    }
    else
    {
        hr = E_POINTER;

    }

    DBGEXIT_HR(CMultiStateToolbar::GetWindow,hr);
    return hr;
}



LRESULT CMultiStateToolbar::OnDestroy(UINT uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult )
{
    DBGENTRY(CMultiStateToolbar::OnDestroy);
   
    _KillAllButtons();

    DBGEXIT(CMultiStateToolbar::OnDestroy);
    return 0;
}


LRESULT CMultiStateToolbar::OnNcDestroy(UINT uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult )
{

    // There is a bug in ATL that if you don't handle WM_NCDESTROY,
    // ATL will call CallWindowProc will a NULL hWnd... this causes assertions
    // on Debug Win95 and Bounds Checker reports an error as well..        

    DBGENTRY(CMultiStateToolbar::OnNcDestroy);
   
    DBGEXIT(CMultiStateToolbar::OnNcDestroy);
    return 0;
}


void CMultiStateToolbar::_KillAllButtons( void )
{
    DBGENTRY(CMultiStateToolbar::_KillAllButtons);

    if( ::IsWindow( _GetToolbarWindow() ) )
    {
        int nButtons = SendMessage(TB_BUTTONCOUNT, 0, 0 );
        for( int iButton = 0; iButton < nButtons; iButton++ )
        {
            TBBUTTON tbb;
            ClearStruct(&tbb);

            if( SendMessage( TB_GETBUTTON, 0, reinterpret_cast<LPARAM>(&tbb)) )
            {
                TBItemData* pItemData = reinterpret_cast<TBItemData*>(tbb.dwData);
                if( pItemData )
                {
                    delete [] pItemData->pStateData;
                }

                delete [] pItemData;
            }

            SendMessage( TB_DELETEBUTTON, 0, 0 );
        }
    }

    DBGEXIT(CMultiStateToolbar::_KillAllButtons);
}


HRESULT CMultiStateToolbar::_CreateImageLists( void )
{   
    DBGENTRY(CMultiStateToolbar::_CreateImageLists);
    HRESULT hr = S_OK;        
    
	m_himlTB = ImageList_Create( m_cxBtnBitmaps, 
                                 m_cyBtnBitmaps, 
                                 ILC_COLOR16 | ILC_MASK, 
                                 1,     // Initial size
                                 1      // Grow By
                                );

	m_himlTBHot = ImageList_Create( m_cxBtnBitmaps, 
                                    m_cyBtnBitmaps, 
                                    ILC_COLOR16 | ILC_MASK, 
                                    1,     // Initial size
                                    1      // Grow By
                                  );

	m_himlTBDisabled = ImageList_Create( m_cxBtnBitmaps, 
                                         m_cyBtnBitmaps, 
                                         ILC_COLOR4 | ILC_MASK, 
                                         1,     // Initial size
                                         1      // Grow By
                                        );

    if(! ( m_himlTB && m_himlTBHot && m_himlTBDisabled ) )
    {   // One of the create calls failed
        ASSERT( 0 );
        // I think that this is the only reason ImageList_Create would fail...
        hr = E_OUTOFMEMORY;
    }
    

    DBGEXIT_HR(CMultiStateToolbar::_CreateImageLists,hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\mrulist2.cpp ===
// File: mrulist.cpp

#include "precomp.h"

#include "mrulist2.h"

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
} SZSZ;
typedef SZSZ * PSZSZ;

typedef struct {
	LPTSTR psz1;
	LPTSTR psz2;
	DWORD  dw;
} SZSZDW;
typedef SZSZDW * PSZSZDW;


/*  C  M  R  U  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: CMRUList2
    
-------------------------------------------------------------------------*/
CMRUList2::CMRUList2(const DWSTR * prgDwStr, int cEntryMax, BOOL fReversed) :
	m_prgDwStr   (prgDwStr),
	m_cEntryMax (cEntryMax),
	m_fReversed (fReversed),
	m_cEntry    (0),
	m_rgpEntry  (NULL),
	m_fDirty    (FALSE)
{
	DBGENTRY(CMRUList2::CMRUList2);

	ASSERT(NULL != prgDwStr);
	m_cCol = m_prgDwStr[0].dw;

	int cb = m_cEntryMax * sizeof(PMRUE);
	m_rgpEntry = new PMRUE[cb];
	if (NULL == m_rgpEntry)
	{
		ERROR_OUT(("CMRUList2 - out of memory"));
		return;
	}
	ZeroMemory(m_rgpEntry, cb);

	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return;

	m_cEntry = min(re.GetNumber(REGVAL_MRU_COUNT, 0), m_cEntryMax);
	for (int i = 0; i < m_cEntry; i++)
	{
		m_rgpEntry[i] = LoadEntry(&re, i);
	}
}

CMRUList2::~CMRUList2()
{
	DBGENTRY(CMRUList2::~CMRUList2);

	if (m_fDirty)
	{
		Save();
	}

	for (int i = 0; i < m_cEntry; i++)
	{
		DeleteEntry(m_rgpEntry[i]);
	}
	delete m_rgpEntry;
}


///////////////////////////////////////////////////////////////////////////

PMRUE CMRUList2::LoadEntry(RegEntry * pre, int iItem)
{
	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	PMRUE pEntry = (PMRUE) new PVOID[m_cCol*sizeof(PVOID)];
	if (NULL != pEntry)
	{
		PVOID ** ppv = (PVOID **) pEntry;
		for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
			switch (MruTypeForCol(iCol))
				{
			default:
			case MRUTYPE_SZ:
				* (LPTSTR *)ppv = PszAlloc(pre->GetString(szKey));
				break;
			case MRUTYPE_DW:
				* (DWORD *) ppv = pre->GetNumber(szKey);
				break;
				}
		}
	}

	return pEntry;
}

VOID CMRUList2::StoreEntry(RegEntry * pre, int iItem)
{
	PVOID ** ppv = (PVOID **) GetEntry(iItem);

	if (m_fReversed)
	{
		iItem = (m_cEntry - (iItem+1));
	}

	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		TCHAR szKey[MAX_PATH];
		wsprintf(szKey, TEXT("%s%d"), PszPrefixForCol(iCol), iItem);
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			pre->SetValue(szKey, * (LPCTSTR *)ppv);
			break;
		case MRUTYPE_DW:
			pre->SetValue(szKey, * (ULONG *) ppv);
			break;
			}
	}
}

VOID CMRUList2::DeleteEntry(PMRUE pEntry)
{
	PVOID ** ppv = (PVOID **) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			delete *ppv;
			break;
		case MRUTYPE_DW:
			break;
			}
	}
	delete pEntry;
}

VOID CMRUList2::DeleteEntry(int iItem)
{
	if ((iItem < 0) || (iItem >= m_cEntry))
		return; // nothing to do

	// delete the data
	DeleteEntry(m_rgpEntry[iItem]);

	// decrement the count
	m_cEntry--;

	// shift items up
	for ( ; iItem < m_cEntry; iItem++)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem+1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


//--------------------------------------------------------------------------//
//	CMRUList2::DeleteEntry.													//
//		This DeleteEntry() deletes the first entry it finds thats primary	//
//		string matches the one passed in.									//
//--------------------------------------------------------------------------//
void
CMRUList2::DeleteEntry
(
	const TCHAR * const	primaryString
){
	int	items	= GetNumEntries();

	for( int nn = 0; nn < items; nn++ )
	{
		if( StrCmpI( primaryString, * ((const TCHAR * const * const) m_rgpEntry[ nn ]) ) == 0 )
		{
			DeleteEntry( nn );
			break;
		}
	}

}	//	End of CMRUList2::DeleteEntry.


/*  C O M P A R E  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CompareEntry
    
-------------------------------------------------------------------------*/
int CMRUList2::CompareEntry(int iItem, PMRUE pEntry)
{
	ASSERT(NULL != pEntry);

	int iRet = 0;

	PVOID * ppv1 = (PVOID *) GetEntry(iItem);
	PVOID * ppv2 = (PVOID *) pEntry;
	for (int iCol = 0; iCol < m_cCol; iCol++, ppv1++, ppv2++)
	{
		switch (MruTypeForCol(iCol))
			{
		default:
		case MRUTYPE_SZ:
			iRet = lstrcmpi(* (LPCTSTR *) ppv1, * (LPCTSTR *) ppv2);
			break;
		case MRUTYPE_DW:
			iRet = (* (int *) ppv1) - (* (int *) ppv2);
			break;
			}

		if (0 != iRet)
			break;
	}

	return iRet;
}


/*  F I N D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: FindEntry

     Return -1 if the item is not found.
-------------------------------------------------------------------------*/
int CMRUList2::FindEntry(PMRUE pEntry)
{
	int cItems = GetNumEntries();
	for (int i = 0; i < cItems; i++)
	{
		if (0 == CompareEntry(i, pEntry))
		{
			return i;
		}
	}

	return -1; // not found
}



		
/*  S A V E  */
/*-------------------------------------------------------------------------
    %%Function: Save
    
-------------------------------------------------------------------------*/
HRESULT CMRUList2::Save(void)
{
	DBGENTRY(CMRUList2::Save);

	// Retrieve the data from the registry
	RegEntry re(PszRegKey(), HKEY_CURRENT_USER);
	if (ERROR_SUCCESS != re.GetError())
		return E_FAIL;

	re.SetValue(REGVAL_MRU_COUNT, m_cEntry);
	for (int i = 0; i < m_cEntry; i++)
	{
		StoreEntry(&re, i);
	}

	return S_OK;
}


/*  S H I F T  E N T R I E S  D O W N  */
/*-------------------------------------------------------------------------
    %%Function: ShiftEntriesDown

    Shift the entires down by one slot leaving the first position open.
-------------------------------------------------------------------------*/
VOID CMRUList2::ShiftEntriesDown(int cItem)
{
	if (cItem < 1)
		return; // nothing to do

	int iItem;
	for (iItem = cItem; iItem > 0; iItem--)
	{
		m_rgpEntry[iItem] = m_rgpEntry[iItem-1];
	}

	// the list has been modified
	m_fDirty = TRUE;
}


/*  M O V E  E N T R Y  T O  T O P  */
/*-------------------------------------------------------------------------
    %%Function: MoveEntryToTop
    
-------------------------------------------------------------------------*/
VOID CMRUList2::MoveEntryToTop(int iItem)
{
	DBGENTRY(CMRUList2::MoveEntryToTop);

	if ((iItem < 1) || (iItem >= m_cEntry))
		return; // nothing to do

	PMRUE pEntry = GetEntry(iItem);
	ShiftEntriesDown(iItem);
	m_rgpEntry[0] = pEntry;
}


/*  A D D  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: AddEntry

	Put the entry into the top of the list.
	The data is owned by the list after this.
	
    Returns:
    	S_OK    - added to the head of the list
    	S_FALSE - already in list (item is moved to top)
-------------------------------------------------------------------------*/
HRESULT CMRUList2::AddEntry(PMRUE pEntry)
{
	DBGENTRY(CMRUList2::AddEntry);

	HRESULT ret = S_OK;

	// the list has been modified
	m_fDirty = TRUE;

	int cShift;
	int iItem = FindEntry(pEntry);
	if (-1 != iItem)
	{
		// This entry already exists, delete it so we get the new info
		DeleteEntry(m_rgpEntry[iItem]);
		cShift = iItem;
		ret = S_FALSE; // Success, but already in the list
	}
	else if (m_cEntryMax == m_cEntry)
	{
		// drop the last item
		DeleteEntry(m_rgpEntry[m_cEntry-1]);
		cShift = m_cEntry-1;
	}
	else
	{
		cShift = m_cEntry;
		m_cEntry++;
	}
	ShiftEntriesDown(cShift);

	// add it to the head of the list
	m_rgpEntry[0] = pEntry;

	return ret;
}


HRESULT CMRUList2::AddEntry(LPCTSTR pcsz)
{
	LPTSTR * ppsz = new LPTSTR;
	LPTSTR psz = PszAlloc(pcsz);
	if ((NULL == ppsz) || (NULL == psz))
	{
		delete ppsz;
		delete psz;
		return E_OUTOFMEMORY;
	}

	*ppsz = psz;

	return AddEntry((PMRUE) ppsz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2)
{
	PSZSZ pSzSz = new SZSZ;
	if (NULL == pSzSz)
		return E_OUTOFMEMORY;

	pSzSz->psz1 = PszAlloc(pcsz1);
	pSzSz->psz2 = PszAlloc(pcsz2);
	if ((NULL == pSzSz->psz1) || (NULL == pSzSz->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pSzSz);
		return E_OUTOFMEMORY;
	}
	
	return AddEntry((PMRUE) pSzSz);
}

HRESULT CMRUList2::AddEntry(LPCTSTR pcsz1, LPCTSTR pcsz2, DWORD dw3)
{
	PSZSZDW pData = new SZSZDW;
	if (NULL == pData)
		return E_OUTOFMEMORY;

	pData->psz1 = PszAlloc(pcsz1);
	pData->psz2 = PszAlloc(pcsz2);
	if ((NULL == pData->psz1) || (NULL == pData->psz1))
	{
		// something failed - don't add anything
		DeleteEntry(pData);
		return E_OUTOFMEMORY;
	}
	pData->dw = dw3;
	
	return AddEntry((PMRUE) pData);
}


/*-------------------------------------------------------------------------
    %%Function: GetString

    Return the data associated with the entry
-------------------------------------------------------------------------*/
LPCTSTR CMRUList2::GetString(int iItem, int iCol)
{
	if (!FValidIndex(iItem))
	{
		return(NULL);
	}

	return(GetString(GetEntry(iItem), iCol));
}

DWORD CMRUList2::GetDWORD(int iItem, int iCol)
{
	if (!FValidIndex(iItem))
	{
		return(0);
	}

	return(GetDWORD(GetEntry(iItem), iCol));
}

LPCTSTR CMRUList2::GetString(PMRUE pEntry, int iCol)
{
	if (iCol >= m_cCol
		|| MRUTYPE_SZ != m_prgDwStr[iCol+1].dw
		)
	{
		return(NULL);
	}

	LPTSTR * ppsz = reinterpret_cast<LPTSTR *>(pEntry);
	return * (ppsz+iCol);
}

DWORD CMRUList2::GetDWORD(PMRUE pEntry, int iCol)
{
	if (iCol >= m_cCol
		|| MRUTYPE_DW != m_prgDwStr[iCol+1].dw
		)
	{
		return(0);
	}

	DWORD * ppdw = reinterpret_cast<DWORD *>(pEntry);
	return * (ppdw+iCol);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmcall.cpp ===
#include "precomp.h"

// NetMeeting SDK includes
#include "NmEnum.h"
#include "NmCall.h"
#include "NmApp.h"
#include "NmManager.h"
#include "NmConference.h"
#include "SDKWindow.h"


//////////////////////////////////////////
// Static Data
//////////////////////////////////////////


/*static*/ CSimpleArray<CNmCallObj*>* CNmCallObj::ms_pCallObjList = NULL;


//////////////////////////////////////////
// Construction and destruction
//////////////////////////////////////////

CNmCallObj::CNmCallObj()
:  m_pNmManagerObj(NULL),
   m_State(NM_CALL_INIT)
{
	DBGENTRY(CNmCallObj::CNmCallObj);

	if(ms_pCallObjList)
	{
		CNmCallObj* p = const_cast<CNmCallObj*>(this);			
		ms_pCallObjList->Add(p);
	}
	else
	{
		ERROR_OUT(("ms_pCallObjList is NULL"));
	}

	DBGEXIT(CNmCallObj::CNmCallObj);
}


HRESULT CNmCallObj::FinalConstruct()
{
	DBGENTRY(CNmCallObj::FinalConstruct);
	HRESULT hr = S_OK;
	
	RECT rc;		

	m_dwInteralINmCallAdvise = 0;

	DBGEXIT_HR(CNmCallObj::FinalConstruct,hr);
	return hr;
}

CNmCallObj::~CNmCallObj()
{
	DBGENTRY(CNmCallObj::~CNmCallObj);

	if(ms_pCallObjList)
	{
		CNmCallObj* p = const_cast<CNmCallObj*>(this);			
		ms_pCallObjList->Remove(p);
	}
	else
	{
		ERROR_OUT(("ms_pCallObjList is NULL"));
	}

	DBGEXIT(CNmCallObj::~CNmCallObj);
}


ULONG CNmCallObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInteralINmCallAdvise)
	{
		CComQIPtr<INmCall> spCall = GetUnknown();		

		DWORD dwAdvise = m_dwInteralINmCallAdvise;
		m_dwInteralINmCallAdvise = 0;

		CComPtr<INmCall> spInternalCall = m_spInternalINmCall;
		m_spInternalINmCall = NULL;

		AtlUnadvise(spInternalCall, IID_INmCallNotify2,dwAdvise);
	}

	return m_dwRef;

}


//static 
HRESULT CNmCallObj::CreateInstance(CNmManagerObj* pNmManagerObj, INmCall* pInternalINmCall, INmCall** ppCall)
{
	DBGENTRY(CNmCallObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmCallObj>* p = NULL;
	p = new CComObject<CNmCallObj>(NULL);
	if(p)
	{
		p->m_spInternalINmCall = pInternalINmCall;

		// We don't have to addref because our lifetime is enclosed within the CNmManagerObj
		p->m_pNmManagerObj = pNmManagerObj;

		hr = _CreateInstanceGuts(p, ppCall);
		if(SUCCEEDED(hr))
		{
			hr = AtlAdvise(pInternalINmCall, *ppCall, IID_INmCallNotify2, &p->m_dwInteralINmCallAdvise);
			if(FAILED(hr))		
			{
				delete p;
			}
		}


	}
	else
	{
		hr = E_OUTOFMEMORY;
	}
	
	DBGEXIT_HR(CNmCallObj::CreateInstance,hr);
	return hr;
}

/*static*/
HRESULT CNmCallObj::_CreateInstanceGuts(CComObject<CNmCallObj> *p, INmCall** ppCall)
{
	DBGENTRY(CNmCallObj::_CreateInstanceGuts);
	HRESULT hr = S_OK;

	if(ppCall)
	{
		if(ms_pCallObjList)
		{
			if(p != NULL)
			{
				p->SetVoid(NULL);
				p->InternalFinalConstructAddRef();
				hr = p->FinalConstruct();
				p->InternalFinalConstructRelease();
				if(hr == S_OK)
					hr = p->QueryInterface(IID_INmCall, reinterpret_cast<void**>(ppCall));
				if(FAILED(hr))
				{
					*ppCall = NULL;
					delete p;
				}
			}
			else
			{
				hr = E_UNEXPECTED;
			}
		}
		else
		{
			ERROR_OUT(("You must first call InitSDK!"));
			hr = E_UNEXPECTED;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmCallObj::_CreateInstanceGuts,hr);
	return hr;
			
}



/*static*/ HRESULT CNmCallObj::InitSDK()
{
	DBGENTRY(CNmCallObj::InitSDK);
	HRESULT hr = S_OK;
	if(!ms_pCallObjList)
	{
		ms_pCallObjList = new CSimpleArray<CNmCallObj*>;
		if(!ms_pCallObjList)
		{
			hr = E_OUTOFMEMORY;
		}

	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmCallObj::InitSDK,hr);
	return hr;
}

/*static*/void CNmCallObj::CleanupSDK()
{
	DBGENTRY(CNmCallObj::CleanupSDK);
	
	delete ms_pCallObjList;	
	ms_pCallObjList = NULL;

	DBGEXIT(CNmCallObj::CleanupSDK);
}



//////////////////////////////////////////
// INmCall
//////////////////////////////////////////


STDMETHODIMP CNmCallObj::IsIncoming(void)
{
	DBGENTRY(CNmCallObj::IsIncoming);
	HRESULT hr = S_OK;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->IsIncoming();
	}
	else
	{
		hr = E_UNEXPECTED;
		ERROR_OUT(("Why don't I have an internal INmCall??"));
	}

	DBGEXIT_HR(CNmCallObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetState(NM_CALL_STATE *pState)
{
	DBGENTRY(CNmCallObj::GetState);
	HRESULT hr = S_OK;
	
	if(pState)
	{
		*pState = m_State;
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmCallObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmCallObj::GetName);
	HRESULT hr = E_FAIL;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->GetName(pbstrName);
	}

	DBGEXIT_HR(CNmCallObj::GetName,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE * puType)
{
	DBGENTRY(CNmCallObj::GetAddr);
	HRESULT hr = E_FAIL;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->GetAddr(pbstrAddr, puType);
	}

	DBGEXIT_HR(CNmCallObj::GetAddr,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	DBGENTRY(CNmCallObj::GetUserData);
	HRESULT hr = S_OK;

	if(m_spInternalINmCall)
	{
		hr = m_spInternalINmCall->GetUserData(rguid, ppb, pcb);
	}
	else
	{
		hr = E_UNEXPECTED;
		ERROR_OUT(("Why don't I have an internal INmCall??"));
	}

	DBGEXIT_HR(CNmCallObj::GetUserData,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::GetConference(INmConference **ppConference)
{
	DBGENTRY(CNmCallObj::GetConference);
	HRESULT hr = S_OK;
	
	if(ppConference)
	{
		*ppConference = m_spConference;

		if(*ppConference)
		{
			(*ppConference)->AddRef();
		}
		else
		{
			hr = S_FALSE;
		}
	}
	else
	{
		hr = E_POINTER;
	}
	
	DBGEXIT_HR(CNmCallObj::GetConference,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Accept(void)
{
	DBGENTRY(CNmCallObj::Accept);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = true;

	if(m_spInternalINmCall)
	{
		m_spInternalINmCall->Accept();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmCallObj::Accept,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Reject(void)
{
	DBGENTRY(CNmCallObj::Reject);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = true;

	if(m_spInternalINmCall)
	{
		m_spInternalINmCall->Reject();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmCallObj::Reject,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Cancel(void)
{
	DBGENTRY(CNmCallObj::Cancel);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = true;

	if(m_spInternalINmCall)
	{
		m_spInternalINmCall->Cancel();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmCallObj::Cancel,hr);
	return hr;
}

////////////////////////////////////////////////
// INmCallNotify methods
////////////////////////////////////////////////
STDMETHODIMP CNmCallObj::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmCallObj::NmUI);
	HRESULT hr = S_OK;

	hr = Fire_NmUI(uNotify);

	DBGEXIT_HR(CNmCallObj::NmUI,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::StateChanged(NM_CALL_STATE uState)
{
	DBGENTRY(CNmCallObj::StateChanged);
	HRESULT hr = S_OK;
	
	if(m_State != uState)
	{
		m_State = uState;

		Fire_StateChanged(uState);
		
	}

	DBGEXIT_HR(CNmCallObj::StateChanged,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Failed(ULONG uError)
{
	DBGENTRY(CNmCallObj::Failed);
	HRESULT hr = S_OK;

	hr = Fire_Failed(uError);

	DBGEXIT_HR(CNmCallObj::Failed,hr);
	return hr;
}

STDMETHODIMP CNmCallObj::Accepted(INmConference *pInternalConference)
{
	DBGENTRY(CNmCallObj::Accepted);
	HRESULT hr = E_NOTIMPL;


	if(m_pNmManagerObj)
	{
		INmConference* pSDKConference = m_pNmManagerObj->GetSDKConferenceFromInternalConference(pInternalConference);
		if(pSDKConference)
		{
			pSDKConference->AddRef();
			Fire_Accepted(pSDKConference);
			pSDKConference->Release();
		}
	}

	DBGEXIT_HR(CNmCallObj::Accepted,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////
// IInternalCallObj methods
///////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmCallObj::GetInternalINmCall(INmCall** ppCall)
{
	DBGENTRY(CNmCallObj::GetInternalINmCall);
	HRESULT hr = S_OK;

	ASSERT(ppCall);
	
	*ppCall = m_spInternalINmCall;
	(*ppCall)->AddRef();

	DBGEXIT_HR(CNmCallObj::GetInternalINmCall,hr);
	return hr;
}




////////////////////////////////////////////////
// Helper fns
////////////////////////////////////////////////

HRESULT CNmCallObj::_ReleaseResources()
{
	HRESULT hr = S_OK;

	return hr;
}


//////////////////////////////////////////////////////////////////////
// Notification Firing Fns
/////////////////////////////////////////////////////////////////////


// static 
HRESULT CNmCallObj::StateChanged(INmCall* pInternalNmCall, NM_CALL_STATE uState)
{
	DBGENTRY(CNmCallObj::StateChanged);
	HRESULT hr = S_OK;
	if(ms_pCallObjList)
	{
		hr = E_FAIL;
		for(int i = 0; i < ms_pCallObjList->GetSize(); ++i)
		{
			if(pInternalNmCall == (*ms_pCallObjList)[i]->m_spInternalINmCall)
			{
				(*ms_pCallObjList)[i]->StateChanged(uState);
				break;
			}
		}
	}
	else
	{
		ERROR_OUT(("ms_pCallObjList is null!"));
	}
	
	DBGEXIT_HR(CNmCallObj::StateChanged,hr);
	return hr;		
}


HRESULT CNmCallObj::Fire_NmUI(CONFN uNotify)
{
	DBGENTRY(CNmCallObj::Fire_NmUI);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));
			if(pNotify)
			{
				pNotify->NmUI(uNotify);
			}
		}
	}
	else
	{
		CSDKWindow::PostCallNmUi(this, uNotify);
	}

	DBGEXIT_HR(CNmCallObj::Fire_NmUI,hr);
	return hr;
}

HRESULT CNmCallObj::Fire_StateChanged(NM_CALL_STATE uState)
{
	DBGENTRY(CNmCallObj::Fire_StateChanged);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->StateChanged(uState);
			}
		}
	}
	else
	{
		CSDKWindow::PostCallStateChanged(this, uState);
	}

	DBGEXIT_HR(CNmCallObj::Fire_StateChanged,hr);
	return hr;	
}


HRESULT CNmCallObj::Fire_Failed(ULONG uError)
{
	DBGENTRY(CNmCallObj::Fire_Failed);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->Failed(uError);
			}
		}
	}
	else
	{
		CSDKWindow::PostFailed(this, uError);
	}

	DBGEXIT_HR(CNmCallObj::Fire_Failed,hr);
	return hr;
}

HRESULT CNmCallObj::Fire_Accepted(INmConference* pConference)
{
	DBGENTRY(CNmCallObj::Fire_Accepted);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmCallNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmCallNotify* pNotify = reinterpret_cast<INmCallNotify*>(pCP->m_vec.GetAt(i));
	
			if(pNotify)
			{
				pNotify->Accepted(pConference);
			}
		}
	}
	else
	{
		CSDKWindow::PostAccepted(this, pConference);
	}

	DBGEXIT_HR(CNmCallObj::Fire_Accepted,hr);
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Helper Fns
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmcall.h ===
#ifndef __NmCall_h__
#define __NmCall_h__

#include "NetMeeting.h"
#include "SDKInternal.h"

class CCall;
class CNmManagerObj;

/////////////////////////////////////////////////////////////////////////////
// CNmCallObj
class ATL_NO_VTABLE CNmCallObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmCallObj>,
	public IConnectionPointImpl<CNmCallObj, &IID_INmCallNotify, CComDynamicUnkArray>,
	public INmCall,
	public INmCallNotify2,
	public IInternalCallObj
{

friend HRESULT CreateEnumNmCall(IEnumNmCall** ppEnum);

protected:
		
// data
	static CSimpleArray<CNmCallObj*>* ms_pCallObjList;
	NM_CALL_STATE			m_State;
	CComPtr<INmConference>	m_spConference;
	CComPtr<INmCall>		m_spInternalINmCall;
	DWORD					m_dwInteralINmCallAdvise;
	CNmManagerObj*			m_pNmManagerObj;

public:

	static HRESULT InitSDK();
	static void CleanupSDK();

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmCallObj)

BEGIN_COM_MAP(CNmCallObj)
	COM_INTERFACE_ENTRY(INmCall)
	COM_INTERFACE_ENTRY(IInternalCallObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmCallNotify)
	COM_INTERFACE_ENTRY(INmCallNotify2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmCallObj)
	CONNECTION_POINT_ENTRY(IID_INmCallNotify)
END_CONNECTION_POINT_MAP()


// Construction and destruction

	CNmCallObj();
	~CNmCallObj();

	HRESULT FinalConstruct();
	ULONG InternalRelease();

	//static HRESULT CreateInstance(INmCall* pInternalINmCall, INmCall** ppCall);
	static HRESULT CreateInstance(CNmManagerObj* pNmManagerObj, INmCall* pInternalINmCall, INmCall** ppCall);

	// INmCall methods
	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_CALL_STATE *pState);
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetAddr)(BSTR *pbstrAddr, NM_ADDR_TYPE * puType);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(GetConference)(INmConference **ppConference);
	STDMETHOD(Accept)(void);
	STDMETHOD(Reject)(void);
	STDMETHOD(Cancel)(void);

	// INmCallNotify2 methods
	STDMETHOD(NmUI)(CONFN uNotify);
	STDMETHOD(StateChanged)(NM_CALL_STATE uState);
	STDMETHOD(Failed)(ULONG uError);
	STDMETHOD(Accepted)(INmConference *pInternalConference);

		// We don't care about these...
    STDMETHOD(CallError)(UINT cns) { return S_OK; }
	STDMETHOD(RemoteConference)(BOOL fMCU, BSTR *pwszConfNames, BSTR *pbstrConfToJoin) { return S_OK; }
	STDMETHOD(RemotePassword)(BSTR bstrConference, BSTR *pbstrPassword, BYTE *pb, DWORD cb, BOOL fIsService) { return S_OK; }

	// IInternalCallObj methods
	STDMETHOD(GetInternalINmCall)(INmCall** ppCall);

	static HRESULT StateChanged(INmCall* pInternalNmCall, NM_CALL_STATE uState);

		// INmCallNotify Notification Firing Fns
	HRESULT Fire_NmUI(CONFN uNotify);
	HRESULT Fire_StateChanged(NM_CALL_STATE uState);
	HRESULT Fire_Failed(ULONG uError);
	HRESULT Fire_Accepted(INmConference* pConference);

private:
// Helper Fns
	HRESULT _ReleaseResources();
	static HRESULT _CreateInstanceGuts(CComObject<CNmCallObj> *p, INmCall** ppCall);
};

//HRESULT CreateEnumNmCall(IEnumNmCall** ppEnum);

#endif // __NmCall_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmapp.h ===
#ifndef __NmApp_h__
#define __NmApp_h__

#include "rToolbar.h"
#include "resource.h"       // main symbols
#include "NetMeeting.h"
#include <NetMeetingCP.h>

class CMainUI;

/////////////////////////////////////////////////////////////////////////////
// CNetMeetingObj
class ATL_NO_VTABLE CNetMeetingObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<INetMeeting, &IID_INetMeeting, &LIBID_NetMeetingLib>,
	public CComControl<CNetMeetingObj>,
	public IPersistStreamInitImpl<CNetMeetingObj>,
	public IPersistPropertyBagImpl<CNetMeetingObj>,
	public IOleControlImpl<CNetMeetingObj>,
	public IOleObjectImpl<CNetMeetingObj>,
	public IOleInPlaceActiveObjectImpl<CNetMeetingObj>,
	public IViewObjectExImpl<CNetMeetingObj>,
	public IOleInPlaceObjectWindowlessImpl<CNetMeetingObj>,
	public CComCoClass<CNetMeetingObj, &CLSID_NetMeeting>,
	public IObjectSafetyImpl<CNetMeetingObj, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public IConnectionPointContainerImpl<CNetMeetingObj>,
	public CProxy_INetMeetingEvents<CNetMeetingObj>,
	public IProvideClassInfo2Impl<&CLSID_NetMeeting, &DIID__INetMeetingEvents, &LIBID_NetMeetingLib, NetMeetingLib_Ver_Major, NetMeetingLib_Ver_Minor>
{

// Static Data
	static CSimpleArray<CNetMeetingObj*>* ms_pNetMeetingObjList;

	CMainUI*				m_pMainView;
	CMainUI::CreateViewMode m_CreateMode;

public:

		// So we are not released when we set up our notificatinos sink
DECLARE_PROTECT_FINAL_CONSTRUCT()

	// Because this is in a local server, we are not going to be able to be aggregated...
DECLARE_NOT_AGGREGATABLE(CNetMeetingObj)

	// This is the resource ID for the .rgs file
DECLARE_REGISTRY_RESOURCEID(IDR_NMAPP)

BEGIN_COM_MAP(CNetMeetingObj)
	COM_INTERFACE_ENTRY(INetMeeting)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNetMeetingObj)
	CONNECTION_POINT_ENTRY(DIID__INetMeetingEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROP_MAP(CNetMeetingObj)
END_PROP_MAP()

BEGIN_MSG_MAP(CNetMeetingObj)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()

// Construction / Destruction
CNetMeetingObj();
~CNetMeetingObj();
HRESULT FinalConstruct();

static HRESULT InitSDK();
static void CleanupSDK();

static UINT GetObjectCount() { return ms_pNetMeetingObjList ? ms_pNetMeetingObjList->GetSize() : 0; };

LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

///////////////////////////////////////////////////////////////////////////
// IViewObjectEx stuff
///////////////////////////////////////////////////////////////////////////
DECLARE_VIEW_STATUS(0)


///////////////////////////////////////////////////////////////////////////
// CComControl Stuff
///////////////////////////////////////////////////////////////////////////
  virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

///////////////////////////////////////////////////////////////////////////
// INetMeeting methods
/////////////////////////////////////////////////////////////

	STDMETHOD(Version)(long* pdwBuildNumber);
	STDMETHOD(UnDock)();
	STDMETHOD(IsInConference)(BOOL *pbInConference);
	STDMETHOD(CallTo)(BSTR bstrCallToString);
	STDMETHOD(LeaveConference)();

// IPersistPropertyBag
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);	

// IPersistStreamInit
	STDMETHOD(Load)(LPSTREAM pStm);

/////////////////////////////////////////////////////////////
// IProvideClassInfo2
	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo);

// Events
	static void Broadcast_ConferenceStarted();
	static void Broadcast_ConferenceEnded();


private:
	void CNetMeetingObj::_SetMode(LPCTSTR pszMode);
	STDMETHODIMP _ParseInitString(LPCTSTR *ppszInitString, LPTSTR szName, LPTSTR szValue);

};



#endif //__NmApp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmapp.cpp ===
#include "precomp.h"
#include "NetMeeting.h"
#include "mslablti.h"
#include "nameres.h"
#include "conf.h"
#include "ConfRoom.h"
#include "call.h"
#include "conf.h"
#include "Callto.h"
#include "version.h"

// NetMeeting SDK includes
#include "SdkInternal.h"
#include "NmEnum.h"
#include "NmMember.h"
#include "NmManager.h"
#include "NmConference.h"
#include "NmCall.h"
#include "SDKWindow.h"
#include "NmApp.h"

//////////////////////////////////////////
// Static Data
//////////////////////////////////////////

/*static*/ CSimpleArray<CNetMeetingObj*>* CNetMeetingObj::ms_pNetMeetingObjList = NULL;

///////////////////////////////////////////////////////////////////////////
// Construction / Destruction
/////////////////////////////////////////////////////////////////////////////

static SIZE s_CreateModeSizeMap[] =
{
	{ 244, 410 }, // CMainUI::CreateFull
	{ 244, 158 }, // CMainUI::CreateDataOnly
	{ 196, 200 }, // CMainUI::CreatePreviewOnly
	{ 196, 200 }, // CMainUI::CreateRemoteOnly
	{ 180, 148 }, // CMainUI::CreatePreviewNoPause
	{ 180, 148 }, // CMainUI::CreateRemoteNoPause
	{ 240, 318 }, // CMainUI::CreateTelephone
};



CNetMeetingObj::CNetMeetingObj()
: m_pMainView(NULL),
  m_CreateMode(CMainUI::CreateFull)
{
	DBGENTRY(CNetMeetingObj::CNetMeetingObj);

	m_bAutoSize = true;
	m_bDrawFromNatural = true;
	m_bWindowOnly = true;

	SIZE sizehm;
	AtlPixelToHiMetric(&s_CreateModeSizeMap[m_CreateMode], &m_sizeNatural);
	m_sizeExtent = m_sizeNatural;

	CNetMeetingObj* p = const_cast<CNetMeetingObj*>(this);
	ms_pNetMeetingObjList->Add(p);

	DBGEXIT(CNetMeetingObj::CNetMeetingObj);
}

CNetMeetingObj::~CNetMeetingObj()
{
	DBGENTRY(CNetMeetingObj::~CNetMeetingObj);

	if(m_pMainView)
	{
		m_pMainView->Release();
		m_pMainView = NULL;
	}

	CNetMeetingObj* p = const_cast<CNetMeetingObj*>(this);
	ms_pNetMeetingObjList->Remove(p);

		// If we are the last guy on the block, we should delay unload
	if(0 == _Module.GetLockCount())
	{
		_Module.Lock();
		CSDKWindow::PostDelayModuleUnlock();
	}

	DBGEXIT(CNetMeetingObj::~CNetMeetingObj);
}


LRESULT CNetMeetingObj::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(SIZE_MINIMIZED != wParam)
	{
		if(m_pMainView)
		{
			int nWidth = LOWORD(lParam);  // width of client area
			int nHeight = HIWORD(lParam); // height of client area

			::SetWindowPos(m_pMainView->GetWindow(), NULL, 0, 0, nWidth, nHeight, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
		}
	}

	return 0;	
}

LRESULT CNetMeetingObj::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	BOOL bInConference;		
	if(!_Module.IsUIVisible())
	{
		if(SUCCEEDED(IsInConference(&bInConference)) && bInConference)
		{
			int iRet = ::MessageBox(m_hWnd,
									RES2T(IDS_CONTAINER_GOING_AWAY_BUT_ACVITE_CONFERENCE),
									RES2T(IDS_MSGBOX_TITLE),
									MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION);
			if(IDNO == iRet)
			{
				UnDock();
			}
			else
			{
					// This means that the user wants to close the conference
				ASSERT(g_pConfRoom);
				if(g_pConfRoom)
				{
					g_pConfRoom->LeaveConference();
				}
			}
		}
	}
	else
	{		
		ASSERT(g_pConfRoom);

		if(g_pConfRoom)
		{
				// Bring the window to the front
			g_pConfRoom->BringToFront();
		}
	}

	return 0;
}

HRESULT CNetMeetingObj::FinalConstruct()
{
	HRESULT hr = S_OK;

	if(!g_pInternalNmManager)
	{	

		if(!CheckRemoteControlService())
		{
			return E_FAIL;
		}

		hr = InitConfExe(FALSE);
	}

	return hr;
}


//static
HRESULT CNetMeetingObj::InitSDK()
{
	DBGENTRY(CNetMeetingObj::InitSDK);
	HRESULT hr = S_OK;
	
	ASSERT(NULL == ms_pNetMeetingObjList);

	hr = (ms_pNetMeetingObjList = new CSimpleArray<CNetMeetingObj*>) ? S_OK : E_OUTOFMEMORY;
	
	DBGEXIT_HR(CNetMeetingObj::InitSDK,hr);
	return hr;
}

//static
void CNetMeetingObj::CleanupSDK()
{
	DBGENTRY(CNetMeetingObj::CleanupSDK);

	if(ms_pNetMeetingObjList)
	{
		delete ms_pNetMeetingObjList;
	}

	DBGEXIT(CNetMeetingObj::CleanupSDK);
}


/////////////////////////////////////////////////////////////////////////////
// CComControlBase
/////////////////////////////////////////////////////////////////////////////
HWND CNetMeetingObj::CreateControlWindow(HWND hWndParent, RECT& rcPos)
{
	DBGENTRY(CNetMeetingObj::CreateControlWindow);

	Create(hWndParent, rcPos);

	if(m_hWnd)
	{
		m_pMainView = new CMainUI;
		
		if(m_pMainView)
		{
			m_pMainView->Create(m_hWnd, g_pConfRoom, m_CreateMode, true);

			RECT rcClient = {0, 0, 0, 0};
			GetClientRect(&rcClient);

			::SetWindowPos(m_pMainView->GetWindow(), NULL, 0, 0, rcClient.right, rcClient.bottom, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

			ShowWindow(TRUE);
		}
		else
		{
			ERROR_OUT(("Out of memory, new CMainUI failed"));
		}
	}
	
	DBGEXIT(CNetMeetingObj::CreateControlWindow);
	return m_hWnd;
}


/////////////////////////////////////////////////////////////////////////////
// INetMeeting
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNetMeetingObj::Version(long *pdwVersion)
{
	DBGENTRY(CNetMeetingObj::Version);
	HRESULT hr = E_POINTER;

	if(pdwVersion)
	{
		*pdwVersion = VER_PRODUCTVERSION_DW;
		hr = S_OK;
	}
	
	DBGEXIT_HR(CNetMeetingObj::Version,hr);
	return hr;
}

STDMETHODIMP CNetMeetingObj::UnDock()
{
	DBGENTRY(CNetMeetingObj::UnDock);
	HRESULT hr = S_OK;

	::CreateConfRoomWindow();
	
	DBGEXIT_HR(CNetMeetingObj::UnDock,hr);
	return hr;
}	


STDMETHODIMP CNetMeetingObj::IsInConference(BOOL *pbInConference)
{
	DBGENTRY(CNetMeetingObj::IsInConference);
	HRESULT hr = S_OK;

	*pbInConference = FIsConferenceActive();

	DBGEXIT_HR(CNetMeetingObj::IsInConference,hr);
	return hr;
}


STDMETHODIMP CNetMeetingObj::CallTo(BSTR bstrCallToString)
{
	DBGENTRY( CNetMeetingObj::CallTo );
	USES_CONVERSION;

	HRESULT	hr;
	const TCHAR *pszCallto = bstrCallToString ? OLE2T( bstrCallToString ) : g_cszEmpty;

	ASSERT( g_pCCallto != NULL );

    if(CCallto::DoUserValidation(pszCallto))
    {
    	hr = g_pCCallto->Callto(	pszCallto,					//	pointer to the callto url to try to place the call with...
    								NULL,						//	pointer to the display name to use...
    								NM_ADDR_CALLTO,				//	callto type to resolve this callto as...
    								false,						//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
    								NULL,						//	security preference, NULL for none. must be "compatible" with secure param if present...
    								false,						//	whether or not save in mru...
    								true,						//	whether or not to perform user interaction on errors...
    								NULL,						//	if bUIEnabled is true this is the window to parent error/status windows to...
    								NULL );						//	out pointer to INmCall * to receive INmCall * generated by placing call...
    }

	DBGEXIT_HR(CNetMeetingObj::CallTo,hr);
	return( S_OK );
}


STDMETHODIMP CNetMeetingObj::LeaveConference()
{
	DBGENTRY(CNetMeetingObj::HangUp);
	HRESULT hr = S_OK;

	CConfRoom::HangUp(FALSE);

	DBGEXIT_HR(CNetMeetingObj::HangUp,hr);
	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBag
//////////////////////////////////////////////////////////////////////////////////////

struct CreateModeMapEntry
{
	LPCTSTR					szName;
	CMainUI::CreateViewMode mode;
};


static CreateModeMapEntry s_CreateModeMap[] =
{
		// Note: These are compared with lstrcmpi
	{ _T("Full"), CMainUI::CreateFull },
	{ _T("DataOnly"), CMainUI::CreateDataOnly },
	{ _T("PreviewOnly"), CMainUI::CreatePreviewOnly },
	{ _T("RemoteOnly"), CMainUI::CreateRemoteOnly },
	{ _T("PreviewNoPause"), CMainUI::CreatePreviewNoPause },
	{ _T("RemoteNoPause"), CMainUI::CreateRemoteNoPause },
	{ _T("Telephone"), CMainUI::CreateTelephone },
};

void CNetMeetingObj::_SetMode(LPCTSTR pszMode)
{
	ULONG nEntries = ARRAY_ELEMENTS(s_CreateModeMap);
	for(ULONG i = 0; i < nEntries; ++i)
	{
		if(!lstrcmpi(s_CreateModeMap[i].szName, pszMode))
		{
			m_CreateMode = s_CreateModeMap[i].mode;

			SIZE sizehm;
			AtlPixelToHiMetric(&s_CreateModeSizeMap[m_CreateMode], &m_sizeNatural);
			m_sizeExtent = m_sizeNatural;

			break;
		}
	}


 	//Allow these modes to be sized
 	if (CMainUI::CreatePreviewNoPause == m_CreateMode
 		|| CMainUI::CreateRemoteNoPause == m_CreateMode
 	)
 	{
 		m_bAutoSize = false;
 	}


}


STDMETHODIMP CNetMeetingObj::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
	CComVariant var;
	var.vt = VT_BSTR;

	HRESULT hr = pPropBag->Read(L"MODE", &var, pErrorLog);
	if(SUCCEEDED(hr))
	{
		if(var.vt == VT_BSTR)
		{
			USES_CONVERSION;
			LPCTSTR pszMode = OLE2T(var.bstrVal);

			_SetMode(pszMode);
		}
	}

	return IPersistPropertyBagImpl<CNetMeetingObj>::Load(pPropBag, pErrorLog);
}

STDMETHODIMP CNetMeetingObj::_ParseInitString(LPCTSTR* ppszInitString, LPTSTR szName, LPTSTR szValue)
{
	HRESULT hr = E_FAIL;

	if(**ppszInitString)
	{
		
			// First read the name
		const TCHAR* pCur = *ppszInitString;

			// Skip Whitespace
		while(*pCur == ' ')
		{
			pCur = CharNext(pCur);
		}

		bool bEqFound = false;

		while( *pCur != '=' && *pCur != ' ' && *pCur != '\0')
		{
			*szName = *pCur;
			szName = CharNext(szName);
			pCur = CharNext(pCur);
		}
	
		*szName	= '\0';
		if(*pCur == '=')
		{
			bEqFound = true;
		}

			// Skip over seperator
		pCur = CharNext(pCur);

			// Skip Whitespace
		while(*pCur == ' ')
		{
			pCur = CharNext(pCur);
		}

			// If we have not found the equal sign separator, we have to make sure to skip it...
		if(!bEqFound && ('=' == *pCur))
		{
				// Skip over the equal sign
			pCur = CharNext(pCur);

				// Skip Whitespace
			while(*pCur == ' ')
			{
				pCur = CharNext(pCur);
			}
		}

			// Read the value
		while( *pCur != ' ' && *pCur != '\0')
		{
			if(*pCur == ',')
			{
				if(*CharNext(pCur) == ',')
				{
					pCur = CharNext(pCur);		
				}
				else
				{
					break;
				}
			}

			*szValue = *pCur;
			szValue = CharNext(szValue);
			pCur = CharNext(pCur);
		}
	
		*szValue = '\0';

			// Skip over last seperator
		pCur = CharNext(pCur);

			// Skip Whitespace
		while(*pCur == ' ')
		{
			pCur = CharNext(pCur);
		}

		*ppszInitString = pCur;
		hr = S_OK;
	}

	return hr;
}


// IPersistStreamInit
STDMETHODIMP CNetMeetingObj::Load(LPSTREAM pStm)
{
	HRESULT hr = E_FAIL;
	
	if(pStm)
	{
		STATSTG stat;
		pStm->Stat(&stat, 0);
		BYTE* pb = new BYTE[stat.cbSize.LowPart];
		if(pb)
		{
			USES_CONVERSION;
			ULONG cbRead;
			
			hr = pStm->Read(pb, stat.cbSize.LowPart, &cbRead);

			if(SUCCEEDED(hr))
			{
				TCHAR szName[MAX_PATH];
				TCHAR szValue[MAX_PATH];

				LPCTSTR pszInitString = OLE2T((OLECHAR*)pb);

				while(SUCCEEDED(_ParseInitString(&pszInitString, szName, szValue)))
				{
					if(!lstrcmpi(szName, _T("mode")))
					{
						_SetMode(szValue);
					}
				}
			}

			delete pb;
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
// INetMeeting_Events_Enabled
//////////////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2
//////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNetMeetingObj::GetClassInfo(ITypeInfo** pptinfo)
{
	DBGENTRY(CNetMeetingObj::GetClassInfo);

	CComPtr<IMarshalableTI> spmti;
	HRESULT hr = CoCreateInstance(CLSID_MarshalableTI, NULL, CLSCTX_INPROC, IID_IMarshalableTI, reinterpret_cast<void**>(&spmti));
	if( SUCCEEDED( hr ) )
	{
		if( SUCCEEDED( hr = spmti->Create(CLSID_NetMeeting, LIBID_NetMeetingLib, LANG_NEUTRAL, 1, 0) ) )
		{
			hr = spmti->QueryInterface(IID_ITypeInfo, reinterpret_cast<void**>(pptinfo));			
		}
	}

	DBGEXIT_HR(CNetMeetingObj::GetClassInfo,hr);

	return hr;
}

//////////////////////////////////////////////////////////////////////////////////////
// Helpers
//////////////////////////////////////////////////////////////////////////////////////


//static
void CNetMeetingObj::Broadcast_ConferenceStarted()
{
	DBGENTRY(CNetMeetingObj::Broadcast_ConferenceStarted);
	
	if(ms_pNetMeetingObjList)
	{
		for(int i = 0; i < ms_pNetMeetingObjList->GetSize(); ++i)
		{
			(*ms_pNetMeetingObjList)[i]->Fire_ConferenceStarted();
		}
	}

	DBGEXIT(CNetMeetingObj::Broadcast_ConferenceStarted);
}

//static
void CNetMeetingObj::Broadcast_ConferenceEnded()
{
	DBGENTRY(CNetMeetingObj::Broadcast_ConferenceEnded);

	if(ms_pNetMeetingObjList)
	{
		for(int i = 0; i < ms_pNetMeetingObjList->GetSize(); ++i)
		{
			(*ms_pNetMeetingObjList)[i]->Fire_ConferenceEnded();
		}
	}

	DBGEXIT(CNetMeetingObj::Broadcast_ConferenceEnded);
}
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelappshare.h ===
#ifndef __NmChannelAppShare_h__
#define __NmChannelAppShare_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelAppShareObj
class ATL_NO_VTABLE CNmChannelAppShareObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelAppShareObj>,
	public IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelAppShareNotify, CComDynamicUnkArray>,
	public INmChannelAppShare,
	public INmChannelAppShareNotify,
	public IInternalChannelObj
{
protected:

	CSimpleArray<INmSharableApp*> m_ArySharableApps;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelAppShareObj)

BEGIN_COM_MAP(CNmChannelAppShareObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelAppShare)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelAppShareNotify)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelAppShareObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelAppShareNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelAppShareObj();
	~CNmChannelAppShareObj();

	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel);

	// INmChannelAppShare methods
    STDMETHOD(GetState)(NM_SHARE_STATE *puState);
    STDMETHOD(SetState)(NM_SHARE_STATE uState);
    STDMETHOD(EnumSharableApp)(IEnumNmSharableApp **ppEnum);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// interface INmChannelAppShareNotify methods
	STDMETHOD(StateChanged)(NM_SHAPP_STATE uState,INmSharableApp *pApp);

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_StateChanged(NM_SHAPP_STATE uState, INmSharableApp *pApp);
	void _OnActivate(bool bActive) {;}


	virtual CNmConferenceObj* GetConfObj() = 0;	
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;

	STDMETHOD(Activate)(BOOL bActive);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);

	static HRESULT GetSharableAppName(HWND hWnd, LPTSTR sz, UINT cchMax);

};


#endif // __NmChannelAppShare_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelappshare.cpp ===
#include "Precomp.h"
#include "Resource.h"
#include "confroom.h"
#include "ias.h"
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelAppShare.h"
#include "NmSharableApp.h"
#include "SDKWindow.h"


CNmChannelAppShareObj::CNmChannelAppShareObj()
{
	DBGENTRY(CNmChannelAppShareObj::CNmChannelAppShareObj);

	DBGEXIT(CNmChannelAppShareObj::CNmChannelAppShareObj);
}

CNmChannelAppShareObj::~CNmChannelAppShareObj()
{
	DBGENTRY(CNmChannelAppShareObj::~CNmChannelAppShareObj);

	for(int j = 0; j < m_ArySharableApps.GetSize(); ++j)
	{
		m_ArySharableApps[j]->Release();
	}
	m_ArySharableApps.RemoveAll();


	DBGEXIT(CNmChannelAppShareObj::~CNmChannelAppShareObj);	
}


//static
HRESULT CNmChannelAppShareObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelAppShareObj::CreateInstance);
	HRESULT hr = S_OK;


	typedef CNmChannel<CNmChannelAppShareObj, &IID_INmChannelAppShare, NMCH_SHARE> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{

				
					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;
			}

			if(FAILED(hr))
			{
				delete p;
				*ppChannel = NULL;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CNmChannelAppShareObj::CreateInstance,hr);
	return hr;
}



///////////////////////////////////////////////////////////////////////////////////
// INmChannelAppShare methods
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNmChannelAppShareObj::GetState(NM_SHARE_STATE *puState)
{
	DBGENTRY(CNmChannelAppShareObj::GetState);
	HRESULT hr = E_UNEXPECTED;

	INmMember* pMember = GetConfObj()->GetLocalSDKMember();

	if(pMember)
	{
		hr = pMember->GetShareState(puState);
	}
	
	DBGEXIT_HR(CNmChannelAppShareObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmChannelAppShareObj::SetState(NM_SHARE_STATE uState)
{
	DWORD uf;
	HRESULT hr = S_OK;

	if (!(S_OK == IsActive()))
		return E_FAIL;

	if(!GetConfObj() || !GetConfObj()->GetLocalSDKMember())
	{
		return E_UNEXPECTED;
	}

	if(NM_SHARE_UNKNOWN)
	{
		return E_FAIL;
	}
	else
	{
		if(NM_SHARE_WORKING_ALONE == uState)
		{
			return ::AllowControl(false);
		}

		if(NM_SHARE_COLLABORATING == uState)
		{
			return ::AllowControl(true);

		}

		if(NM_SHARE_IN_CONTROL == uState)
		{
			NM_SHARE_STATE uCurrentState; 
			if(SUCCEEDED(hr = GetState(&uCurrentState)))
			{	
				if(NM_SHARE_COLLABORATING == uCurrentState)
				{	
					// Yank control from the person that is controlling you
					return ::RevokeControl(0);
				}
			}
			else
			{
				return hr;
			}

			return ::AllowControl(true);
		}
	}

	return E_UNEXPECTED;
}


//static 
HRESULT CNmChannelAppShareObj::GetSharableAppName(HWND hWnd, LPTSTR sz, UINT cchMax)
{
	HRESULT hr = S_OK;
	ASSERT(sz);

	::GetWindowText(hWnd, sz, cchMax);
	return hr;
}


static INmSharableApp* _SharableAppAryHasThisHWND(CSimpleArray<INmSharableApp*>& ArySharableApps, HWND hWnd)
{
	for(int i = 0; i < ArySharableApps.GetSize(); ++i)
	{
		HWND h;
		if(SUCCEEDED(ArySharableApps[i]->GetHwnd(&h)))
		{
			if(hWnd == h) return ArySharableApps[i];

		}
	}

	return NULL;
}

STDMETHODIMP CNmChannelAppShareObj::EnumSharableApp(IEnumNmSharableApp **ppEnum)
{
	DBGENTRY(CNmChannelAppShareObj::EnumSharableApp);
	HRESULT hr = E_UNEXPECTED;

	IAS_HWND_ARRAY* pAry;
	hr = ::GetShareableApps(&pAry);
	if(SUCCEEDED(hr))
	{
		for(UINT i = 0; i < pAry->cEntries; ++i)
		{
			HWND hWnd = pAry->aEntries[i].hwnd;
			TCHAR szName[MAX_PATH];

			if(!_SharableAppAryHasThisHWND(m_ArySharableApps, hWnd))
			{
				hr = GetSharableAppName(hWnd, szName, CCHMAX(szName));

				if(FAILED(hr)) goto end;

				INmSharableApp* pApp;
				hr = CNmSharableAppObj::CreateInstance(hWnd, szName, &pApp);
				if(SUCCEEDED(hr))
				{
					m_ArySharableApps.Add(pApp);
				}
			}
		}

		hr = CreateEnumFromSimpleAryOfInterface<IEnumNmSharableApp, INmSharableApp>(m_ArySharableApps, ppEnum);

		FreeShareableApps(pAry);
	}
	
end:

	DBGEXIT_HR(CNmChannelAppShareObj::EnumSharableApp,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelAppShareObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelAppShareObj::GetInternalINmChannel);
	HRESULT hr = S_OK;

	if(ppChannel)
	{
		hr = GetUnknown()->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelAppShareObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelAppShareObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	return hr;
}


// interface INmChannelAppShareNotify methods
STDMETHODIMP CNmChannelAppShareObj::StateChanged(NM_SHAPP_STATE uState,INmSharableApp *pApp)
{
	if(pApp)
	{
		HWND hWnd;
		if(SUCCEEDED(pApp->GetHwnd(&hWnd)))
		{
		
			INmSharableApp* pExistingApp = _SharableAppAryHasThisHWND(m_ArySharableApps, hWnd);
			if(!pExistingApp)
			{
				pExistingApp = pApp;
				pExistingApp->AddRef();
				m_ArySharableApps.Add(pExistingApp);
			}
			
			Fire_StateChanged(uState, pExistingApp);
		}
	}
		
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelAppShareObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelAppShareObj::Fire_MemberChanged);
	HRESULT hr = S_OK;


		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelNotify2
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelAppShareNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAppShareNotify* pNotify2 = reinterpret_cast<INmChannelAppShareNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelAppShareObj::Fire_MemberChanged,hr)
	return hr;
}

extern bool g_bSDKPostNotifications;

HRESULT CNmChannelAppShareObj::Fire_StateChanged(NM_SHAPP_STATE uNotify, INmSharableApp *pApp)
{
	DBGENTRY(CNmChannelAppShareObj::Fire_StateChanged);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmChannelAppShareNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmChannelAppShareObj, &IID_INmChannelAppShareNotify, CComDynamicUnkArray>* pCP2 = this;
		for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
		{
			INmChannelAppShareNotify* pNotify2 = reinterpret_cast<INmChannelAppShareNotify*>(pCP2->m_vec.GetAt(i));

			if(pNotify2)
			{
				pNotify2->StateChanged(uNotify, pApp);
			}
		}
	}
	else
	{
		CSDKWindow::PostStateChanged(this, uNotify, pApp);
	}
	
	DBGEXIT_HR(CNmChannelAppShareObj::Fire_StateChanged,hr)
	return hr;
}

HRESULT CNmChannelAppShareObj::_IsActive()
{
	DBGENTRY(CNmChannelAppShareObj::_IsActive);
	
	return GetbActive() ? S_OK : S_FALSE;
}

HRESULT CNmChannelAppShareObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannel.h ===
#ifndef __NmChannel_h__
#define __NmChannel_h__

#include "imsconf3.h"

class CNmConferenceObj;

template<class T, const IID* piid, DWORD dwCh>
class ATL_NO_VTABLE CNmChannel : public T
{
friend class CNmChannelDataObj;
friend class CNmChannelAudioObj;
friend class CNmChannelVideoObj;
friend class CNmChannelFtObj;
friend class CNmChannelAppShareObj;

	public:	

	CNmChannel() : m_bActive(false), m_pConfObj(NULL) { ; }

	~CNmChannel()
	{
		DBGENTRY(CNmChannel::~CNmChannel);

		RemoveMembers();

		DBGEXIT(CNmChannel::~CNmChannel);
	}


	// INmChannel methods
	STDMETHOD(IsSameAs)(INmChannel *pChannel);
	STDMETHOD(IsActive)(void);
	STDMETHOD(SetActive)(BOOL fActive);
	STDMETHOD(GetConference)(INmConference **ppConference);
	STDMETHOD(GetInterface)(IID *_piid);
	STDMETHOD(GetNmch)(ULONG *puCh);
	STDMETHOD(EnumMember)(IEnumNmMember **ppEnum);
	STDMETHOD(GetMemberCount)(ULONG * puCount);

	// INmChannelNotify
    STDMETHOD(NmUI)(CONFN uNotify);
    STDMETHOD(MemberChanged)(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember);
	STDMETHOD(NotifySinksOfAllMembers)()
	{
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			Fire_MemberChanged(NM_MEMBER_ADDED, m_SDKMemberObjs[i]);
		}

		return S_OK;
	}

	STDMETHOD(NotifySinksOfLocalMember)()
	{
		Fire_MemberChanged(NM_MEMBER_ADDED, GetConfObj()->GetLocalSDKMember());
		return S_OK;
	}

	virtual bool IsChannelValid()
	{
		if(m_pConfObj)
		{
			NM_CONFERENCE_STATE state;
			if(SUCCEEDED(m_pConfObj->GetState(&state)) && (NM_CONFERENCE_IDLE != state))
			{
				return true;
			}
		}
		
		return false;
	}

	virtual CNmConferenceObj* GetConfObj() { return m_pConfObj; }
	virtual BOOL GetbActive() { return m_bActive; }

	virtual void RemoveMembers()
	{

			// Free our conferencing objects
		while(m_SDKMemberObjs.GetSize())
		{
			Fire_MemberChanged(NM_MEMBER_REMOVED, m_SDKMemberObjs[0]);
			CComPtr<INmMember> sp = m_SDKMemberObjs[0];
			m_SDKMemberObjs.RemoveAt(0);
			sp.p->Release();
		}
	}

	STDMETHOD(Activate)(BOOL bActive) 
	{ 
		if(m_bActive != ((bActive) ? TRUE : FALSE))
		{
			m_bActive = ((bActive) ? TRUE : FALSE);
			_OnActivate(bActive ? true : false);
		}

		return S_OK;
	}


	STDMETHOD(SDKMemberAdded)(INmMember* pSDKMember)
	{
		HRESULT hr = S_FALSE;

		if(!_MemberInChannel(pSDKMember))
		{
				// Add the member
			pSDKMember->AddRef();
			m_SDKMemberObjs.Add(pSDKMember);

				// Notify the sinks
			Fire_MemberChanged(NM_MEMBER_ADDED, pSDKMember);
			hr = S_OK;
		}

		return hr;
	}

	STDMETHOD(SDKMemberRemoved)(INmMember* pSDKMember)
	{
		HRESULT hr = S_FALSE;

		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			CComPtr<INmMember> spMember = m_SDKMemberObjs[i];

			if(spMember.IsEqualObject(pSDKMember))
			{
				m_SDKMemberObjs.RemoveAt(i);

				Fire_MemberChanged(NM_MEMBER_REMOVED, spMember);

				spMember.p->Release();

				hr = S_OK;

				break;
			}
		}

		return hr;
	}

	STDMETHOD(SDKMemberChanged)(INmMember* pSDKMember) 
	{
		return Fire_MemberChanged(NM_MEMBER_UPDATED, pSDKMember); 
	}

	void NotifySinkOfMembers(INmChannelNotify* pNotify)
	{
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			pNotify->MemberChanged(NM_MEMBER_ADDED, m_SDKMemberObjs[i]);
		}
	}

	STDMETHOD(FireNotificationsToSyncState)()
	{
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			Fire_MemberChanged(NM_MEMBER_ADDED, m_SDKMemberObjs[i]);
		}

		return S_OK;
	}

protected: // Helper Fns
	INmMember* _GetSDKMemberFromInternalMember(INmMember* pInternalMember);
	HRESULT _RemoveMember(INmMember* pInternalMember);
	virtual bool _MemberInChannel(INmMember* pSDKMember);

private:
	CSimpleArray<INmMember*>	m_SDKMemberObjs;
	CNmConferenceObj*			m_pConfObj;
	BOOL						m_bActive;
};



///////////////////////////////////////////////////////////////////
// INmChannel
///////////////////////////////////////////////////////////////////

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::IsSameAs(INmChannel *pChannel)
{
	DBGENTRY(CNmChannel::IsSameAs);
	HRESULT hr = E_NOTIMPL;
	CComPtr<IUnknown> pUnk(GetUnknown());

	hr = pUnk.IsEqualObject(pChannel) ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmChannel::IsSameAs,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::IsActive(void)
{
	DBGENTRY(CNmChannel::IsActive);

	HRESULT hr = _IsActive();

	DBGEXIT_HR(CNmChannel::IsActive,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::SetActive(BOOL fActive)
{
	DBGENTRY(CNmChannel::SetActive);

	HRESULT hr = _SetActive(fActive);

	DBGEXIT_HR(CNmChannel::SetActive,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetConference(INmConference **ppConference)
{
	DBGENTRY(CNmChannel::GetConference);
	HRESULT hr = S_OK;

	if(m_pConfObj)
	{	
		IUnknown* pUnk = m_pConfObj->GetUnknown();
		if(pUnk)
		{
			hr = pUnk->QueryInterface(IID_INmConference,reinterpret_cast<void**>(ppConference));
		}
		else
		{
			hr = S_FALSE;
		}
	}

	DBGEXIT_HR(CNmChannel::GetConference,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetInterface(IID *_piid)
{
	DBGENTRY(CNmChannel::GetInterface);
	HRESULT hr = S_OK;

	if(piid)
	{
		*_piid = *piid;
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannel::GetInterface,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetNmch(ULONG *puCh)
{
	DBGENTRY(CNmChannel::GetNmch);
	HRESULT hr = S_OK;

	if(puCh)
	{
		*puCh = dwCh;			
	}
	else
	{
		hr = E_POINTER;			
	}		

	DBGEXIT_HR(CNmChannel::GetNmch,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::EnumMember(IEnumNmMember **ppEnum)
{
	DBGENTRY(CNmChannel::EnumMember);
	HRESULT hr = S_OK;

	hr = CreateEnumFromSimpleAryOfInterface<IEnumNmMember, INmMember>(m_SDKMemberObjs, ppEnum);

	DBGEXIT_HR(CNmChannel::EnumMember,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::GetMemberCount(ULONG * puCount)
{
	DBGENTRY(CNmChannel::GetMemberCount);
	HRESULT hr = S_OK;

	if(puCount)
	{
		*puCount = m_SDKMemberObjs.GetSize();
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannel::GetMemberCount,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////
// INmChannelNotify
///////////////////////////////////////////////////////////////////

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmChannel::NmUI);
	HRESULT hr = S_OK;

	DBGEXIT_HR(CNmChannel::NmUI,hr);
	return hr;
}

template<class T, const IID* piid, DWORD dwCh>
STDMETHODIMP CNmChannel<T, piid, dwCh>::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember)
{
	DBGENTRY(CNmChannel::MemberChanged);
	HRESULT hr = S_OK;

	if(pInternalMember && m_pConfObj)
	{
		INmMember* pMember = NULL;

		if(NM_MEMBER_ADDED == uNotify)
		{
				// Only add it if we haven't added it yet
			if(!(pMember = _GetSDKMemberFromInternalMember(pInternalMember)))
			{
				pMember = m_pConfObj->GetSDKMemberFromInternalMember(pInternalMember);
				ASSERT(pMember);

				pMember->AddRef();
				m_SDKMemberObjs.Add(pMember);
			}
			else
			{
					// We already have this member
				goto end;
			}
		}

		if(!pMember)
		{
			pMember = _GetSDKMemberFromInternalMember(pInternalMember);
		}

			// It is possable that the member has already been removed..
		if(pMember)
		{
			if(NM_MEMBER_REMOVED == uNotify)
			{
				_RemoveMember(pInternalMember);
			}
			else
			{
				Fire_MemberChanged(uNotify, pMember);
			}
		}
	}
	else
	{
		ERROR_OUT(("The member is not in the conference yet!!!"));
		hr = E_UNEXPECTED;
	}

end:

	DBGEXIT_HR(CNmChannel::MemberChanged,hr);
	return hr;
}


template<class T, const IID* piid, DWORD dwCh>
INmMember* CNmChannel<T, piid, dwCh>::_GetSDKMemberFromInternalMember(INmMember* pInternalMember)
{
	INmMember* pRet = NULL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalMemberObj> spInternal = m_SDKMemberObjs[i];
		ASSERT(spInternal);

		CComPtr<INmMember> spMember;
		if(SUCCEEDED(spInternal->GetInternalINmMember(&spMember)))
		{
			if(spMember.IsEqualObject(pInternalMember))
			{
				pRet = m_SDKMemberObjs[i];
				break;
			}
		}
	}

	return pRet;
}


template<class T, const IID* piid, DWORD dwCh>
HRESULT CNmChannel<T, piid, dwCh>::_RemoveMember(INmMember* pInternalMember)
{
	HRESULT hr = E_FAIL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalMemberObj> spSDKObj = m_SDKMemberObjs[i];
		CComPtr<INmMember> spSDKMember = m_SDKMemberObjs[i];
		ASSERT(spSDKObj);

		CComPtr<INmMember> spMember;
		if(SUCCEEDED(spSDKObj->GetInternalINmMember(&spMember)))
		{
				// Worst case we return S_FALSE to indicate that there is no such member
			hr = S_FALSE;

			if(spMember.IsEqualObject(pInternalMember))
			{
				m_SDKMemberObjs.RemoveAt(i);

				Fire_MemberChanged(NM_MEMBER_REMOVED, spSDKMember);

				spSDKMember.p->Release();
				hr = S_OK;
				break;
			}
		}
	}

	return hr;	
}

template<class T, const IID* piid, DWORD dwCh>
bool CNmChannel<T, piid, dwCh>::_MemberInChannel(INmMember* pSDKMember)
{
	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		
		CComPtr<INmMember> spMember = m_SDKMemberObjs[i];
		if(spMember.IsEqualObject(pSDKMember))
		{
			return true;
		}
	}

	return false;
}



#endif // __NmChannel_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchanneldata.cpp ===
#include "precomp.h"

// NetMeeting SDK stuff
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelData.h"


CNmChannelDataObj::CNmChannelDataObj()
{
	DBGENTRY(CNmChannelDataObj::CNmChannelDataObj);

	DBGEXIT(CNmChannelDataObj::CNmChannelDataObj);
}

CNmChannelDataObj::~CNmChannelDataObj()
{
	DBGENTRY(CNmChannelDataObj::~CNmChannelDataObj);

	m_spInternalINmChannelData = NULL;

	DBGEXIT(CNmChannelDataObj::~CNmChannelDataObj);	
}


HRESULT CNmChannelDataObj::FinalConstruct()
{
	DBGENTRY(CNmChannelDataObj::FinalConstruct);
	HRESULT hr = S_OK;

	if(m_spInternalINmChannelData)
	{
		if(SUCCEEDED(hr))
		{
			hr = AtlAdvise(m_spInternalINmChannelData, GetUnknown(), IID_INmChannelDataNotify2, &m_dwInternalAdviseCookie);
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmChannelDataObj::FinalConstruct,hr);
	return hr;
}



ULONG CNmChannelDataObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInternalAdviseCookie)
	{
		++m_dwRef;
		DWORD dwAdvise = m_dwInternalAdviseCookie;
		m_dwInternalAdviseCookie = 0;
		AtlUnadvise(m_spInternalINmChannelData, IID_INmChannelDataNotify2, dwAdvise);
		--m_dwRef;
	}

	return m_dwRef;

}
//
HRESULT CNmChannelDataObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel* pInternalINmChannel, INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelDataObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelDataObj, &IID_INmChannelData, NMCH_DATA> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{
				p->m_spInternalINmChannelData = com_cast<INmChannelData>(pInternalINmChannel);
				if(p->m_spInternalINmChannelData)
				{

						// We don't have to RefCount this because our lifetime is
						// contained in the CConf's lifetime
					p->m_pConfObj = pConfObj;

						// We do this so that we don't accidentally Release out of memory
					++p->m_dwRef;
					hr = p->FinalConstruct();
					--p->m_dwRef;
				}
				else
				{
					hr = E_FAIL;
				}
			}

			if(FAILED(hr))
			{
				delete p;
				*ppChannel = NULL;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CNmChannelDataObj::CreateInstance,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelData methods
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::GetGuid(GUID *pguid)
{
	DBGENTRY(CNmChannelDataObj::GetGuid);
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmChannelData)
	{
		hr = m_spInternalINmChannelData->GetGuid(pguid);
	}

	DBGEXIT_HR(CNmChannelDataObj::GetGuid,hr);
	return hr;
}

STDMETHODIMP CNmChannelDataObj::SendData(INmMember *pMember, ULONG uSize, byte *pvBuffer, ULONG uOptions)
{
	DBGENTRY(CNmChannelDataObj::SendData);
	HRESULT hr = S_OK;

	if(m_spInternalINmChannelData)
	{
		CComPtr<INmMember> spInternalMember;

		if(pMember)
		{
			CComPtr<IInternalMemberObj> spMemberObj = com_cast<IInternalMemberObj>(pMember);
			if(spMemberObj)
			{
				hr = spMemberObj->GetInternalINmMember(&spInternalMember);
			}
		}

		if(SUCCEEDED(hr))
		{
			hr = m_spInternalINmChannelData->SendData(spInternalMember, uSize, pvBuffer, uOptions);
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}
		
	DBGEXIT_HR(CNmChannelDataObj::SendData,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelData2 methods
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::RegistryAllocateHandle(ULONG numberOfHandlesRequested)
{
	DBGENTRY(CNmChannelDataObj::RegistryAllocateHandle);
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmChannelData)
	{
		CComPtr<INmChannelData2> spChannel = com_cast<INmChannelData2>(m_spInternalINmChannelData);
		if(spChannel)
		{
			hr = spChannel->RegistryAllocateHandle(numberOfHandlesRequested);
		}
	}


	DBGEXIT_HR(CNmChannelDataObj::RegistryAllocateHandle,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////
//INmChannelDataNotify2
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::DataSent(INmMember *pMember, ULONG uSize,byte *pvBuffer)
{
	DBGENTRY(CNmChannelDataObj::DataSent);
	HRESULT hr = S_OK;

	ASSERT(GetConfObj());
	INmMember* pSDKMember = GetConfObj()->GetSDKMemberFromInternalMember(pMember);

	hr = Fire_DataSent(pSDKMember, uSize, pvBuffer);

	DBGEXIT_HR(CNmChannelDataObj::DataSent,hr);
	return hr;
}

STDMETHODIMP CNmChannelDataObj::DataReceived(INmMember *pInternalMember, ULONG uSize,byte *pvBuffer, ULONG dwFlags)
{
	DBGENTRY(CNmChannelDataObj::DataReceived);
	HRESULT hr = S_OK;

	ASSERT(GetConfObj());
	CComPtr<INmMember> spSDKMember = GetConfObj()->GetSDKMemberFromInternalMember(pInternalMember);

	hr = Fire_DataReceived(spSDKMember, uSize, pvBuffer, dwFlags);

	DBGEXIT_HR(CNmChannelDataObj::DataReceived,hr);
	return hr;
}

STDMETHODIMP CNmChannelDataObj::AllocateHandleConfirm(ULONG handle_value, ULONG chandles)
{
	DBGENTRY(CNmChannelDataObj::AllocateHandleConfirm);
	HRESULT hr = S_OK;

	DBGEXIT_HR(CNmChannelDataObj::AllocateHandleConfirm,hr);
	return hr;
}



///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelDataObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelDataObj::GetInternalINmChannel);
	HRESULT hr = S_OK;

	if(ppChannel)
	{
		hr = m_spInternalINmChannelData->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelDataObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelDataObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	if(m_dwInternalAdviseCookie)
	{
		ASSERT(m_spInternalINmChannelData);
		AtlUnadvise(m_spInternalINmChannelData, IID_INmChannelDataNotify, m_dwInternalAdviseCookie);
		m_dwInternalAdviseCookie = 0;
	}

	m_spInternalINmChannelData = NULL;

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelDataObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelDataObj::Fire_MemberChanged);
	HRESULT hr = S_OK;


		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelDataNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelDataNotify* pNotify2 = reinterpret_cast<INmChannelDataNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}

	DBGEXIT_HR(CNmChannelDataObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelDataObj::Fire_DataSent(INmMember *pSDKMember, ULONG uSize,byte *pvBuffer)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelDataNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelDataNotify* pNotify2 = reinterpret_cast<INmChannelDataNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->DataSent(pSDKMember, uSize, pvBuffer);
		}
	}

	return hr;
}

HRESULT CNmChannelDataObj::Fire_DataReceived(INmMember *pSDKMember, ULONG uSize, byte *pvBuffer, ULONG dwFlags)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelDataNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelDataNotify* pNotify2 = reinterpret_cast<INmChannelDataNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->DataReceived(pSDKMember, uSize, pvBuffer, dwFlags);
		}
	}

	return hr;
}

HRESULT CNmChannelDataObj::_IsActive()
{

	HRESULT hr = E_FAIL;
	
	if(m_spInternalINmChannelData)
	{
		hr = m_spInternalINmChannelData->IsActive();
	}
	
	return hr;
}

HRESULT CNmChannelDataObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelaudio.h ===
#ifndef __NmChannelAudio_h__
#define __NmChannelAudio_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelAudioObj
class ATL_NO_VTABLE CNmChannelAudioObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelAudioObj>,
	public IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>,
	public INmChannelAudio,
	public INmChannelAudioNotify,
	public IInternalChannelObj
{

protected:
	bool m_bIsIncoming;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelAudioObj)

BEGIN_COM_MAP(CNmChannelAudioObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelAudio)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelAudioNotify)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelAudioObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelAudioNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelAudioObj();
	~CNmChannelAudioObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming);

		// InmChannelAudio methods
	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_AUDIO_STATE *puState);
    STDMETHOD(GetProperty)(NM_AUDPROP uID,ULONG_PTR *puValue);
    STDMETHOD(SetProperty)(NM_AUDPROP uID,ULONG_PTR uValue);

	// INmChannelAudioNotify methods
    STDMETHOD(StateChanged)(NM_AUDIO_STATE uState);
	STDMETHOD(PropertyChanged)(DWORD dwReserved);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_StateChanged(NM_AUDIO_STATE uState);
	HRESULT Fire_PropertyChanged(DWORD dwReserved);
	void _OnActivate(bool bActive) {;}

	virtual CNmConferenceObj* GetConfObj() = 0;	
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;
	virtual bool IsChannelValid() = 0;

	STDMETHOD(Activate)(BOOL bActive);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);
};


#endif // __NmChannelAudio_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelft.cpp ===
#include "precomp.h"
#include "resource.h"
#include "ConfUtil.h"
#include "ConfPolicies.h"

// SDK includes
#include "NmEnum.h"
#include "NmConference.h"
#include "SDKInternal.h"
#include "NmMember.h"
#include "NmChannel.h"
#include "NmChannelFt.h"
#include "NmFt.h"
#include "FtHook.h"


CNmChannelFtObj::CNmChannelFtObj()
: m_bSentSinkLocalMember(false)
{
	DBGENTRY(CNmChannelFtObj::CNmChannelFtObj);

	DBGEXIT(CNmChannelFtObj::CNmChannelFtObj);
}

CNmChannelFtObj::~CNmChannelFtObj()
{
	DBGENTRY(CNmChannelFtObj::~CNmChannelFtObj);

	CFt::UnAdvise(this);

		// Free our Ft objects
	for(int i = 0; i < m_SDKFtObjs.GetSize(); ++i)
	{
		m_SDKFtObjs[i]->Release();
	}

	DBGEXIT(CNmChannelFtObj::~CNmChannelFtObj);	
}

//
HRESULT CNmChannelFtObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelFtObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelFtObj, &IID_INmChannelFt, NMCH_FT> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{
					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;
			}

			if(FAILED(hr))
			{
				*ppChannel = NULL;
				delete p;
			}
		}
		else
		{
			hr = E_POINTER;
		}

	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CNmChannelFtObj::CreateInstance,hr);
	return hr;
}



/*  V A L I D A T E  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: ValidateFile

    Verify that a file is a valid to send (it exists, not a folder, etc.)
-------------------------------------------------------------------------*/
HRESULT ValidateFile(LPCTSTR pszFile, DWORD *pdwSizeInBytes)
{
	WIN32_FIND_DATA findData;
	*pdwSizeInBytes = 0;

	HRESULT hr = S_OK;
	if (FEmptySz(pszFile) || (MAX_PATH < lstrlen(pszFile)))
	{
		TRACE_OUT(("SendFile: invalid filename"));
		return E_INVALIDARG;
	}

	// get file information
	HANDLE hFind = FindFirstFile(pszFile, &findData);
	if (INVALID_HANDLE_VALUE == hFind)
	{
		TRACE_OUT(("SendFile: Bad Filename [%s]", pszFile));
		return E_INVALIDARG;
	}
	FindClose(hFind);
	if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
		WARNING_OUT(("SendFile: [%s] is a directory", pszFile));
		return E_INVALIDARG;
	}

	// Check whether we are allowed to send files of this size.
	DWORD dwMaxSendFileSize = ConfPolicies::GetMaxSendFileSize();

	if (dwMaxSendFileSize) {
		DWORD dwFileSizeInK = (findData.nFileSizeLow >> 10) |
						(findData.nFileSizeHigh << (sizeof(DWORD) * 8 - 10));
		if ((dwFileSizeInK >= dwMaxSendFileSize) ||
			((findData.nFileSizeHigh >> 10) > 0)) {
			return NM_E_FILE_TOO_BIG;
		}
	}

	*pdwSizeInBytes = findData.nFileSizeLow;

	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////
// INmChannelFt methods
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNmChannelFtObj::SendFile(INmFt **ppFt, INmMember *pMember, BSTR bstrFile, ULONG uOptions)
{
	DBGENTRY(CNmChannelFtObj::SendFile);
	HRESULT hr = S_OK;

	USES_CONVERSION;
	
	LPCTSTR szFileName = OLE2T(bstrFile);
	DWORD dwSizeInBytes = 0;
	hr = ValidateFile(szFileName,&dwSizeInBytes);
	ULONG gccID = 0;
	MBFTEVENTHANDLE hEvent;
	MBFTFILEHANDLE hFile;


		// We should never be passed NULL because of the marshalling code...
	ASSERT(ppFt);

	if(!GetbActive())
	{
			// We are not active yet!
		hr = E_FAIL;
		goto end;
	}


	if(SUCCEEDED(hr))
	{

		if(pMember)
		{
			// Make sure that this member is valid and in the channel
			if(!_MemberInChannel(pMember))
			{
				hr = E_INVALIDARG;
				goto end;
			}

			hr = pMember->GetID(&gccID);
			if(FAILED(hr)) goto end;
		}

		hr = CFt::SendFile(szFileName,
						   static_cast<T120NodeID>(gccID),
						   &hEvent,
						   &hFile);
		if(SUCCEEDED(hr))
		{
			hr = CNmFtObj::CreateInstance(
				this, 
				hEvent,
				hFile,
				false,			// bIsIncoming
				szFileName,		// FileName
				dwSizeInBytes,	// Size in Bytes of the file
				pMember,
				ppFt
				);

			if(SUCCEEDED(hr))
			{
				(*ppFt)->AddRef();
				m_SDKFtObjs.Add(*ppFt);

				Fire_FtUpdate(CONFN_FT_STARTED, *ppFt);
			}
		}
	}

end:

	DBGEXIT_HR(CNmChannelFtObj::SendFile,hr);
	return hr;
}

STDMETHODIMP CNmChannelFtObj::SetReceiveFileDir(BSTR bstrDir)
{
	DBGENTRY(CNmChannelFtObj::SetReceiveFileDir);
	HRESULT hr = S_OK;
		
	USES_CONVERSION;

	LPTSTR szDir = OLE2T(bstrDir);

	if(bstrDir)
	{
		if(szDir)
		{
			if(FEnsureDirExists(szDir))
			{
				hr = _ChangeRecDir(szDir);
			}
			else
			{
				hr = E_INVALIDARG;
			}
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_INVALIDARG;
	}

	DBGEXIT_HR(CNmChannelFtObj::SetReceiveFileDir,hr);
	return hr;
}

// static
HRESULT CNmChannelFtObj::_ChangeRecDir(LPTSTR pszRecDir)
{
	PSTR  psz;
	TCHAR szPath[MAX_PATH];
	
	HRESULT hr = S_OK;

	RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);

	if (NULL == pszRecDir)
	{
		// NULL directory specified - get info from registry or use default
		psz = reFileXfer.GetString(REGVAL_FILEXFER_PATH);
		if (!FEmptySz(psz))
		{
			lstrcpyn(szPath, psz, CCHMAX(szPath));
		}
		else
		{
			TCHAR szInstallDir[MAX_PATH];
			GetInstallDirectory(szInstallDir);
			FLoadString1(IDS_FT_RECDIR_DEFAULT, szPath, szInstallDir);
		}

		pszRecDir = szPath;
	}

	psz = pszRecDir;

	// Remove trailing backslash, if any
	for (; *psz; psz = CharNext(psz))
	{
		if ((_T('\\') == *psz) && (_T('\0') == *CharNext(psz)) )
		{
			*psz = _T('\0');
			break;
		}
	}

	TRACE_OUT(("ChangeRecDir [%s]", pszRecDir));


	if (!FEnsureDirExists(pszRecDir))
	{
		WARNING_OUT(("ChangeRecDir: FT directory is invalid [%s]", pszRecDir));
		hr = E_FAIL;
	}
	else
	{
		// update the registry
		reFileXfer.SetValue(REGVAL_FILEXFER_PATH, pszRecDir);

	}

	return hr;
}

STDMETHODIMP CNmChannelFtObj::GetReceiveFileDir(BSTR *pbstrDir)
{
	DBGENTRY(CNmChannelFtObj::GetReceiveFileDir);
	HRESULT hr = S_OK;
	
	if(pbstrDir)
	{
		RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);
		*pbstrDir = T2BSTR(reFileXfer.GetString(REGVAL_FILEXFER_PATH));
		if(!*pbstrDir)
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelFtObj::GetReceiveFileDir,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelFtObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelFtObj::GetInternalINmChannel);
	HRESULT hr = S_OK;

	if(ppChannel)
	{
		*ppChannel = NULL;
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmChannelFtObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelFtObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	m_bSentSinkLocalMember = false;


	return hr;
}

void CNmChannelFtObj::_OnActivate(bool bActive)
{
	bActive ? CFt::Advise(this) : CFt::UnAdvise(this);
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelFtObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelFtObj::Fire_MemberChanged);
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		if(NM_MEMBER_ADDED == uNotify)
		{
			if(!m_bSentSinkLocalMember)
			{
				m_bSentSinkLocalMember = true;
				NotifySinksOfLocalMember();
			}
		}

		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelFtNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelFtNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		if(NM_MEMBER_ADDED == uNotify)
		{
			if(!m_bSentSinkLocalMember)
			{
				m_bSentSinkLocalMember = true;
				NotifySinksOfLocalMember();
			}
		}

		INmChannelFtNotify* pNotify2 = reinterpret_cast<INmChannelFtNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelFtObj::Fire_MemberChanged,hr);
	return hr;
}


HRESULT CNmChannelFtObj::Fire_FtUpdate(CONFN uNotify, INmFt* pNmFt)
{
	DBGENTRY(CNmChannelFtObj::Fire_FtUpdate);
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelFtNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelFtNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelFtNotify* pNotify2 = reinterpret_cast<INmChannelFtNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->FtUpdate(uNotify, pNmFt);
		}
	}
	
	DBGEXIT_HR(CNmChannelFtObj::Fire_FtUpdate,hr);
	return hr;
}

void CNmChannelFtObj::_RemoveFt(INmFt* pFt)
{
	INmFt* pRet = NULL;

	for( int i = 0; i < m_SDKFtObjs.GetSize(); ++i)
	{
		CComPtr<INmFt> spFt = m_SDKFtObjs[i];
		if(spFt.IsEqualObject(pFt))
		{	
			m_SDKFtObjs.RemoveAt(i);
			spFt.p->Release();
			break;
		}
	}
}

INmMember* CNmChannelFtObj::GetSDKMemberFromInternalMember(INmMember* pInternalMember)
{
	ASSERT(GetConfObj());
	return GetConfObj()->GetSDKMemberFromInternalMember(pInternalMember);
}

HRESULT CNmChannelFtObj::_IsActive()
{
	return GetbActive() ? S_OK : S_FALSE;
}

HRESULT CNmChannelFtObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}


	// IMbftEvent Interface
STDMETHODIMP CNmChannelFtObj::OnInitializeComplete(void)
{
	// This is handled by the conference object
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnPeerAdded(MBFT_PEER_INFO *pInfo)
{
	// This is handled by the conference object
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnPeerRemoved(MBFT_PEER_INFO *pInfo)
{
	// This is handled by the conference object
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnFileOffer(MBFT_FILE_OFFER *pOffer)
{
	CNmConferenceObj* pConfObj = GetConfObj();

	if(pConfObj)
	{
		CComPtr<INmMember> spMember;

		HRESULT hr = S_OK;

		if(pOffer->NodeID)
		{
			hr = pConfObj->GetMemberFromNodeID(pOffer->NodeID, &spMember);
		}

		if(SUCCEEDED(hr))
		{
			RegEntry reFileXfer(FILEXFER_KEY, HKEY_CURRENT_USER);
			ASSERT(1 == pOffer->uNumFiles);

			CFt::AcceptFileOffer(   pOffer, 
									reFileXfer.GetString(REGVAL_FILEXFER_PATH),
									pOffer->lpFileInfoList[0].szFileName
								);

			CComPtr<INmFt> spFt;

			hr = CNmFtObj::CreateInstance(
				this, 
				pOffer->hEvent,							// hEvent
				0,										// hFile is 0 for now...
				true,									// bIsIncoming
				pOffer->lpFileInfoList[0].szFileName,	// FileName
				pOffer->lpFileInfoList[0].lFileSize,	// Size in Bytes of the file
				spMember,
				&spFt
				);

			if(SUCCEEDED(hr))
			{
				spFt.p->AddRef();
				m_SDKFtObjs.Add(spFt.p);

				Fire_FtUpdate(CONFN_FT_STARTED, spFt);
			}
		}
	}

	return S_OK;
}


INmFt* CNmChannelFtObj::_GetFtFromHEvent(MBFTEVENTHANDLE hEvent)
{
	for(int i = 0; i < m_SDKFtObjs.GetSize(); ++i)
	{
		UINT CurhEvent;
		if(SUCCEEDED(com_cast<IInternalFtObj>(m_SDKFtObjs[i])->GetHEvent(&CurhEvent)) && (hEvent == CurhEvent))
		{
			return m_SDKFtObjs[i];
		}
	}

	return NULL;
}


STDMETHODIMP CNmChannelFtObj::OnFileProgress(MBFT_FILE_PROGRESS *pProgress)
{
	DBGENTRY(CNmChannelFtObj::OnFileProgress);
	HRESULT hr = S_OK;

	INmFt* pFt = _GetFtFromHEvent(pProgress->hEvent);
	if(pFt)
	{
		com_cast<IInternalFtObj>(pFt)->OnFileProgress(pProgress->hFile, pProgress->lFileSize, pProgress->lBytesTransmitted);
		Fire_FtUpdate(CONFN_FT_PROGRESS, pFt);
	}

	DBGEXIT_HR(CNmChannelFtObj::OnFileProgress,hr);
	return hr;
}

STDMETHODIMP CNmChannelFtObj::OnFileEnd(MBFTFILEHANDLE hFile)
{
	// according to Lon, this is bogus
	return S_OK;
	
}

STDMETHODIMP CNmChannelFtObj::OnFileError(MBFT_EVENT_ERROR *pEvent)
{
	DBGENTRY(CNmChannelFtObj::OnFileError);
	HRESULT hr = S_OK;

	INmFt* pFt = _GetFtFromHEvent(pEvent->hEvent);
	if(pFt)
	{
		com_cast<IInternalFtObj>(pFt)->OnError();
	}
	
	DBGEXIT_HR(CNmChannelFtObj::OnFileError,hr);
	return hr;
}

STDMETHODIMP CNmChannelFtObj::OnFileEventEnd(MBFTEVENTHANDLE hEvent)
{
	INmFt* pFt = _GetFtFromHEvent(hEvent);

	if(pFt)
	{
		bool bHasSomeoneCanceled = (S_FALSE == com_cast<IInternalFtObj>(pFt)->FileTransferDone());
		
		Fire_FtUpdate(bHasSomeoneCanceled ? CONFN_FT_CANCELED : CONFN_FT_COMPLETE, pFt);

		_RemoveFt(pFt);
	}
		
	return S_OK;
}

STDMETHODIMP CNmChannelFtObj::OnSessionEnd(void)
{
	CFt::UnAdvise(this);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchanneldata.h ===
#ifndef __NmChannelData_h__
#define __NmChannelData_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelDataObj
class ATL_NO_VTABLE CNmChannelDataObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelDataObj>,
	public IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelDataObj, &IID_INmChannelDataNotify, CComDynamicUnkArray>,
	public INmChannelData2,
	public INmChannelDataNotify2,
	public IInternalChannelObj
{

protected:
	CComPtr<INmChannelData>		m_spInternalINmChannelData;
	DWORD						m_dwInternalAdviseCookie;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelDataObj)

BEGIN_COM_MAP(CNmChannelDataObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelData)
	COM_INTERFACE_ENTRY(INmChannelData2)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelDataNotify)
	COM_INTERFACE_ENTRY(INmChannelDataNotify2)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelDataObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelDataNotify)
END_CONNECTION_POINT_MAP()

		// Construction and destruection
	CNmChannelDataObj();
	~CNmChannelDataObj();
	HRESULT FinalConstruct();
	ULONG InternalRelease();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel* pInternalINmChannel, INmChannel** ppChannel);

	// INmChannelData methods
    STDMETHOD(GetGuid)(GUID *pguid);
    STDMETHOD(SendData)(INmMember *pMember, ULONG uSize, byte *pvBuffer, ULONG uOptions);

	// INmChannelData2 methods
	STDMETHOD(RegistryAllocateHandle)(ULONG numberOfHandlesRequested);

	//INmChannelDataNotify
    STDMETHOD(DataSent)(INmMember *pMember, ULONG uSize,byte *pvBuffer);
    STDMETHOD(DataReceived)(INmMember *pInternalMember,ULONG uSize,byte *pvBuffer, ULONG dwFlags);
    STDMETHOD(AllocateHandleConfirm)(ULONG handle_value, ULONG chandles);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_DataSent(INmMember *pSDKMember, ULONG uSize,byte *pvBuffer);
	HRESULT Fire_DataReceived(INmMember *pSDKMember, ULONG uSize, byte *pvBuffer, ULONG dwFlags);
	void _OnActivate(bool bActive) {;}

	virtual CNmConferenceObj* GetConfObj() = 0;
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);

};


#endif // __NmChannelData_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelaudio.cpp ===
#include "precomp.h"

// NetMeeting gunk
#include "confroom.h"

// Netmeeting SDK stuff
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelAudio.h"


CNmChannelAudioObj::CNmChannelAudioObj()
{
	DBGENTRY(CNmChannelAudioObj::CNmChannelAudioObj);

	DBGEXIT(CNmChannelAudioObj::CNmChannelAudioObj);
}

CNmChannelAudioObj::~CNmChannelAudioObj()
{
	DBGENTRY(CNmChannelAudioObj::~CNmChannelAudioObj);

	DBGEXIT(CNmChannelAudioObj::~CNmChannelAudioObj);	
}

//
HRESULT CNmChannelAudioObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming)
{
	DBGENTRY(CNmChannelAudioObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelAudioObj, &IID_INmChannelAudio, NMCH_AUDIO> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{
					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;
				p->m_bIsIncoming = bIsIncoming;
			}

			if(FAILED(hr))
			{
				delete p;
				*ppChannel = NULL;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CNmChannelAudioObj::CreateInstance,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelAudio2 methods
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelAudioObj::IsIncoming(void)
{
	DBGENTRY(CNmChannelAudioObj::IsIncoming);
	HRESULT hr = E_UNEXPECTED;

	hr = m_bIsIncoming ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmChannelAudioObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::GetState(NM_AUDIO_STATE *puState)
{
	DBGENTRY(CNmChannelAudioObj::GetState);
	HRESULT hr = E_POINTER;

	if(puState)
	{
		hr = S_OK;

		*puState = NM_AUDIO_IDLE;

		if(S_OK == _IsActive())
		{
			if( ((S_OK == IsIncoming()) && IsSpeakerMuted()) || ((S_FALSE == IsIncoming()) && IsMicMuted()))
			{
				*puState = NM_AUDIO_LOCAL_PAUSED;
			}
			else
			{
				*puState = NM_AUDIO_TRANSFERRING;
			}	
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::GetProperty(NM_AUDPROP uID,ULONG_PTR *puValue)
{
	DBGENTRY(CNmChannelAudioObj::GetProperty);
	HRESULT hr = E_POINTER;

	if(puValue)
	{
		hr = E_FAIL;

		if(IsChannelValid())
		{
			switch(uID)
			{
				case NM_AUDPROP_LEVEL:
				{
					HRESULT hIncoming = IsIncoming();

					if(S_OK == hIncoming)
					{ // This is the receive channel
						*puValue = GetSpeakerVolume();
						hr = S_OK;
					}
					else if(S_FALSE == hIncoming)
					{ // This is the send channel
						*puValue = GetRecorderVolume();	
						hr = S_OK;
					}

					break;
				}
					

				case NM_AUDPROP_PAUSE:
				{
					HRESULT hIncoming = IsIncoming();

					if(S_OK == hIncoming)
					{ // This is the receive channel
						*puValue = IsSpeakerMuted() ? 1 : 0;
						hr = S_OK;
					}
					else if(S_FALSE == hIncoming)
					{ // This is the send channel
						*puValue = IsMicMuted() ? 1 : 0;
						hr = S_OK;
					}

					break;
				}
					
				default:
					hr = E_INVALIDARG;
					break;
			}
		}
	}

	DBGEXIT_HR(CNmChannelAudioObj::GetProperty,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::SetProperty(NM_AUDPROP uID,ULONG_PTR uValue)
{
	DBGENTRY(CNmChannelAudioObj::SetProperty);
	HRESULT hr = E_FAIL;

	if(IsChannelValid())
	{
		switch(uID)
		{
			case NM_AUDPROP_LEVEL:
			{
				hr = E_INVALIDARG;

				if(uValue < NM_MAX_AUDIO_LEVEL)
				{
					HRESULT hIncoming = IsIncoming();

					if(S_OK == hIncoming)
					{ // This is the receive channel
						SetSpeakerVolume((ULONG)uValue);
						hr = S_OK;
					}
					else if(S_FALSE == hIncoming)
					{ // This is the send channel
						SetRecorderVolume((ULONG)uValue);	
						hr = S_OK;
					}
				}

				break;
			}

			case NM_AUDPROP_PAUSE:
			{
				HRESULT hIncoming = IsIncoming();

				if(S_OK == hIncoming)
				{ // This is the receive channel
					MuteSpeaker(uValue ? TRUE : FALSE);
					hr = S_OK;
				}
				else if(S_FALSE == hIncoming)
				{ // This is the send channel
					MuteMicrophone(uValue ? TRUE : FALSE);
					hr = S_OK;
				}

				break;
			}
				
			default:
				hr = E_INVALIDARG;
				break;
		}
	}

	DBGEXIT_HR(CNmChannelAudioObj::SetProperty,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////
//INmChannelAudioNotify
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CNmChannelAudioObj::StateChanged(NM_AUDIO_STATE uState)
{
	DBGENTRY(CNmChannelAudioObj::StateChanged);
	HRESULT hr = S_OK;

	Activate(NM_AUDIO_IDLE != uState);

		// The internal GetState is a bit funky at times...
	GetState(&uState);

	hr = Fire_StateChanged(uState);

	DBGEXIT_HR(CNmChannelAudioObj::StateChanged,hr);
	return hr;
}

STDMETHODIMP CNmChannelAudioObj::PropertyChanged(DWORD dwReserved)
{
	DBGENTRY(CNmChannelAudioObj::PropertyChanged);
	HRESULT hr = S_OK;

	hr = Fire_PropertyChanged(dwReserved);

	DBGEXIT_HR(CNmChannelAudioObj::PropertyChanged,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelAudioObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelAudioObj::GetInternalINmChannel);
	HRESULT hr = E_POINTER;

	if(ppChannel)
	{
		*ppChannel = NULL;
		hr = S_OK;
	}

	DBGEXIT_HR(CNmChannelAudioObj::GetInternalINmChannel,hr);

	return hr;
}

HRESULT CNmChannelAudioObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();
	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelAudioObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelAudioObj::Fire_MemberChanged);
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelAudioNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAudioNotify* pNotify2 = reinterpret_cast<INmChannelAudioNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelAudioObj::Fire_StateChanged(NM_AUDIO_STATE uState)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelAudioNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAudioNotify* pNotify2 = reinterpret_cast<INmChannelAudioNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->StateChanged(uState);
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::Fire_MemberChanged,hr)
	return hr;
}

HRESULT CNmChannelAudioObj::Fire_PropertyChanged(DWORD dwReserved)
{

	HRESULT hr = S_OK;
		/////////////////////////////////////////////////////
		// INmChannelAudioNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelAudioObj, &IID_INmChannelAudioNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelAudioNotify* pNotify2 = reinterpret_cast<INmChannelAudioNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->PropertyChanged(dwReserved);
		}
	}
	
	DBGEXIT_HR(CNmChannelAudioObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelAudioObj::_IsActive()
{
	return GetbActive() ? S_OK : S_FALSE;
}

	// We don't support switchable AV anymore
HRESULT CNmChannelAudioObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_OK;

	return E_FAIL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelvideo.cpp ===
#include "precomp.h"
#include "confroom.h"
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmChannel.h"
#include "NmChannelVideo.h"


CNmChannelVideoObj::CNmChannelVideoObj()
{
	DBGENTRY(CNmChannelVideoObj::CNmChannelVideoObj);

	DBGEXIT(CNmChannelVideoObj::CNmChannelVideoObj);
}

CNmChannelVideoObj::~CNmChannelVideoObj()
{
	DBGENTRY(CNmChannelVideoObj::~CNmChannelVideoObj);

	DBGEXIT(CNmChannelVideoObj::~CNmChannelVideoObj);	
}


//
HRESULT CNmChannelVideoObj::CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming)
{
	DBGENTRY(CNmChannelVideoObj::CreateInstance);
	HRESULT hr = S_OK;

	typedef CNmChannel<CNmChannelVideoObj, &IID_INmChannelVideo, NMCH_VIDEO> channel_type;

	channel_type* p = NULL;
	p = new CComObject<channel_type>(NULL);

	if (p != NULL)
	{
		if(ppChannel)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmChannel, reinterpret_cast<void**>(ppChannel));

			if(SUCCEEDED(hr))
			{

				p->m_bIsIncoming = bIsIncoming;

					// We don't have to RefCount this because our lifetime is
					// contained in the CConf's lifetime
				p->m_pConfObj = pConfObj;

			}

			if(FAILED(hr))
			{
				*ppChannel = NULL;
				delete p;
			}
		}
		else
		{
			hr = E_POINTER;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CNmChannelVideoObj::CreateInstance,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
// INmChannelVideo2 methods
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CNmChannelVideoObj::IsIncoming(void)
{
	DBGENTRY(CNmChannelVideoObj::IsIncoming);
	HRESULT hr = E_UNEXPECTED;

	hr = m_bIsIncoming ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmChannelVideoObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::GetState(NM_VIDEO_STATE *puState)
{
	DBGENTRY(CNmChannelVideoObj::GetState);
	HRESULT hr = E_POINTER;

	if(puState)
	{
		if(m_bIsIncoming)
		{
			hr = GetRemoteVideoState(puState);				
		}
		else
		{
			hr = GetLocalVideoState(puState);
		}
	}

	DBGEXIT_HR(CNmChannelVideoObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::GetProperty(NM_VIDPROP uID,ULONG_PTR *puValue)
{
	DBGENTRY(CNmChannelVideoObj::GetProperty);
	HRESULT hr = E_INVALIDARG;
    ULONG ulValue;

	switch(uID)
	{
		case NM_VIDPROP_PAUSE:

			if(m_bIsIncoming)
			{
				*puValue = IsRemoteVideoPaused();
			}
			else
			{
				*puValue = IsLocalVideoPaused();
			}
			hr = S_OK;
			break;

		case NM_VIDPROP_IMAGE_QUALITY:
			hr = GetImageQuality(&ulValue, m_bIsIncoming);
            *puValue = ulValue;
			break;

		case NM_VIDPROP_CAMERA_DIALOG:
			if(m_bIsIncoming)
			{
				return E_FAIL;
			}

			hr = GetCameraDialog(&ulValue);
            *puValue = ulValue;
			break;

		case NM_VIDPROP_WINDOW_AUTO_SIZE:
		case NM_VIDPROP_WINDOW_SIZE:
		case NM_VIDPROP_WINDOW_POSITION:
		case NM_VIDPROP_WINDOW_TOP_MOST:
		case NM_VIDPROP_WINDOW_VISIBLE:
		case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
			hr = E_FAIL;
			break;
	}

	DBGEXIT_HR(CNmChannelVideoObj::GetProperty,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::SetProperty(NM_VIDPROP uID,ULONG_PTR uValue)
{
	DBGENTRY(CNmChannelVideoObj::SetProperty);
	HRESULT hr = E_INVALIDARG;

	switch(uID)
	{
		case NM_VIDPROP_PAUSE:
			if(m_bIsIncoming)
			{
				PauseRemoteVideo((ULONG)uValue);
			}
			else
			{
				PauseLocalVideo((ULONG)uValue);
			}
			hr = S_OK;
			break;

		case NM_VIDPROP_IMAGE_QUALITY:
			hr = SetImageQuality((ULONG)uValue, m_bIsIncoming);
			break;

		case NM_VIDPROP_CAMERA_DIALOG:
			
			if (m_bIsIncoming)
			{
				hr = E_FAIL;
			}
			else
			{	
				hr = E_INVALIDARG;
				if((NM_VIDEO_SOURCE_DIALOG == uValue) || (NM_VIDEO_FORMAT_DIALOG == uValue))
				{
					hr = SetCameraDialog((ULONG)uValue);
				}
			}

			break;

		case NM_VIDPROP_WINDOW_AUTO_SIZE:
		case NM_VIDPROP_WINDOW_SIZE:
		case NM_VIDPROP_WINDOW_POSITION:
		case NM_VIDPROP_WINDOW_TOP_MOST:
		case NM_VIDPROP_WINDOW_VISIBLE:
		case NM_VIDPROP_IMAGE_PREFERRED_SIZE:
			hr = E_FAIL;
			break;
	}

	DBGEXIT_HR(CNmChannelVideoObj::SetProperty,hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////////
//INmChannelVideoNotify2
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CNmChannelVideoObj::StateChanged(NM_VIDEO_STATE uState)
{
	DBGENTRY(CNmChannelVideoObj::StateChanged);
	HRESULT hr = S_OK;

	Activate(NM_VIDEO_IDLE != uState);
		
	hr = Fire_StateChanged(uState);

	DBGEXIT_HR(CNmChannelVideoObj::StateChanged,hr);
	return hr;
}

STDMETHODIMP CNmChannelVideoObj::PropertyChanged(DWORD dwReserved)
{
	DBGENTRY(CNmChannelVideoObj::PropertyChanged);
	HRESULT hr = S_OK;
	
	hr = Fire_PropertyChanged(dwReserved);

	DBGEXIT_HR(CNmChannelVideoObj::PropertyChanged,hr);
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// IInternalChannelObj methods
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChannelVideoObj::GetInternalINmChannel(INmChannel** ppChannel)
{
	DBGENTRY(CNmChannelVideoObj::GetInternalINmChannel);
	HRESULT hr = E_POINTER;

	if(ppChannel)
	{
		*ppChannel = NULL;
		hr = S_OK;
	}

	DBGEXIT_HR(CNmChannelVideoObj::GetInternalINmChannel,hr);

	return hr;
}


HRESULT CNmChannelVideoObj::ChannelRemoved()
{
	HRESULT hr = S_OK;

	RemoveMembers();

	CNmConferenceObj* pConfObj = GetConfObj();

	if(pConfObj)
	{
		hr = pConfObj->Fire_ChannelChanged(NM_CHANNEL_REMOVED, com_cast<INmChannel>(GetUnknown()));
	}
	else
	{
		ERROR_OUT(("ChannelRemoved, but no ConfObject"));
		hr = E_UNEXPECTED;
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Helpers
///////////////////////////////////////////////////////////////////////////////

HRESULT CNmChannelVideoObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmChannelVideoObj::Fire_MemberChanged);
	HRESULT hr = S_OK;


		/////////////////////////////////////////////////////
		// INmChannelNotify
		/////////////////////////////////////////////////////
	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelNotify, CComDynamicUnkArray>* pCP = this;
	for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
	{
		INmChannelNotify* pNotify = reinterpret_cast<INmChannelNotify*>(pCP->m_vec.GetAt(i));

		if(pNotify)
		{
			pNotify->MemberChanged(uNotify, pMember);
		}
	}
		/////////////////////////////////////////////////////
		// INmChannelVideoNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>* pCP2 = this;
	for(i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelVideoNotify* pNotify2 = reinterpret_cast<INmChannelVideoNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->MemberChanged(uNotify, pMember);
		}
	}
	
	DBGEXIT_HR(CNmChannelVideoObj::Fire_MemberChanged,hr)
	return hr;
}


HRESULT CNmChannelVideoObj::Fire_StateChanged(NM_VIDEO_STATE uState)
{
	HRESULT hr = S_OK;

		/////////////////////////////////////////////////////
		// INmChannelVideoNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelVideoNotify* pNotify2 = reinterpret_cast<INmChannelVideoNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->StateChanged(uState);
		}
	}
	
	DBGEXIT_HR(CNmChannelVideoObj::Fire_MemberChanged,hr)
	return hr;
}

HRESULT CNmChannelVideoObj::Fire_PropertyChanged(DWORD dwReserved)
{

	HRESULT hr = S_OK;
		/////////////////////////////////////////////////////
		// INmChannelVideoNotify
		/////////////////////////////////////////////////////

	IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>* pCP2 = this;
	for(int i = 0; i < pCP2->m_vec.GetSize(); ++i )
	{
		INmChannelVideoNotify* pNotify2 = reinterpret_cast<INmChannelVideoNotify*>(pCP2->m_vec.GetAt(i));

		if(pNotify2)
		{
			pNotify2->PropertyChanged(dwReserved);
		}
	}
	
	DBGEXIT_HR(CNmChannelVideoObj::Fire_MemberChanged,hr)
	return hr;
}

HRESULT CNmChannelVideoObj::_IsActive()
{
	return GetbActive() ? S_OK : S_FALSE;
}

HRESULT CNmChannelVideoObj::_SetActive(BOOL bActive)
{
	if (GetbActive() == bActive)
		return S_FALSE;

	return E_FAIL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelft.h ===
#ifndef __NmChannelFt_h__
#define __NmChannelFt_h__

#include "SDKInternal.h"
#include "FtHook.h"

/////////////////////////////////////////////////////////////////////////////
// CNmChannelFtObj
class ATL_NO_VTABLE CNmChannelFtObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelFtObj>,
	public IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelFtObj, &IID_INmChannelFtNotify, CComDynamicUnkArray>,
	public INmChannelFt,
	public IInternalChannelObj,
	public IMbftEvents
{

protected:
	CSimpleArray<INmFt*>		m_SDKFtObjs;
	bool						m_bSentSinkLocalMember;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelFtObj)

BEGIN_COM_MAP(CNmChannelFtObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelFt)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelFtObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelFtNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelFtObj();
	~CNmChannelFtObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel);

	// INmChannelFtMethods
    STDMETHOD(SendFile)(INmFt **ppFt, INmMember *pMember, BSTR bstrFile, ULONG uOptions);
    STDMETHOD(SetReceiveFileDir)(BSTR bstrDir);
    STDMETHOD(GetReceiveFileDir)(BSTR *pbstrDir);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();
	STDMETHOD(Activate)(BOOL bActive);

	// IMbftEvent Interface
	STDMETHOD(OnInitializeComplete)(void);
	STDMETHOD(OnPeerAdded)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnPeerRemoved)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnFileOffer)(MBFT_FILE_OFFER *pOffer);
	STDMETHOD(OnFileProgress)(MBFT_FILE_PROGRESS *pProgress);
	STDMETHOD(OnFileEnd)(MBFTFILEHANDLE hFile);
	STDMETHOD(OnFileError)(MBFT_EVENT_ERROR *pEvent);
	STDMETHOD(OnFileEventEnd)(MBFTEVENTHANDLE hEvent);
	STDMETHOD(OnSessionEnd)(void);

	INmMember* GetSDKMemberFromInternalMember(INmMember* pInternalMember);
	INmFt* GetSDKFtFromInternalFt(INmFt* pInternalFt);
  
	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_FtUpdate(CONFN uNotify, INmFt* pNmFt);
	void _OnActivate(bool bActive);


	virtual CNmConferenceObj* GetConfObj() = 0;
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;
	virtual bool _MemberInChannel(INmMember* pSDKMember) = 0;

	virtual void NotifySinkOfMembers(INmChannelNotify* pNotify) = 0; 

	void _RemoveFt(INmFt* pFt);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);
	
	HRESULT _ChangeRecDir(LPTSTR pszRecDir);

	INmFt* _GetFtFromHEvent(MBFTEVENTHANDLE hEvent);
};


#endif // __NmChannelFt_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmchannelvideo.h ===
#ifndef __NmChannelVideo_h__
#define __NmChannelVideo_h__

/////////////////////////////////////////////////////////////////////////////
// CNmChannelVideoObj
class ATL_NO_VTABLE CNmChannelVideoObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmChannelVideoObj>,
	public IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelNotify, CComDynamicUnkArray>,
	public IConnectionPointImpl<CNmChannelVideoObj, &IID_INmChannelVideoNotify, CComDynamicUnkArray>,
	public INmChannelVideo,
	public INmChannelVideoNotify,
	public IInternalChannelObj
{

protected:
	bool m_bIsIncoming;
public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmChannelVideoObj)

BEGIN_COM_MAP(CNmChannelVideoObj)
	COM_INTERFACE_ENTRY(INmChannel)
	COM_INTERFACE_ENTRY(INmChannelVideo)
	COM_INTERFACE_ENTRY(INmChannelNotify)
	COM_INTERFACE_ENTRY(INmChannelVideoNotify)
	COM_INTERFACE_ENTRY(IInternalChannelObj)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CNmChannelVideoObj)
	CONNECTION_POINT_ENTRY(IID_INmChannelNotify)
	CONNECTION_POINT_ENTRY(IID_INmChannelVideoNotify)
END_CONNECTION_POINT_MAP()


		// Construction and destruection
	CNmChannelVideoObj();
	~CNmChannelVideoObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmChannel** ppChannel, bool bIsIncoming);

	// INmChannelVideo methods
	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_VIDEO_STATE *puState);
    STDMETHOD(GetProperty)(NM_VIDPROP uID,ULONG_PTR *puValue);
    STDMETHOD(SetProperty)(NM_VIDPROP uID,ULONG_PTR uValue);

	// INmChannelVideoNotify methods		
    STDMETHOD(StateChanged)(NM_VIDEO_STATE uState);
	STDMETHOD(PropertyChanged)(DWORD dwReserved);

	// IInternalChannelObj methods
	STDMETHOD(GetInternalINmChannel)(INmChannel** ppChannel);
	STDMETHOD(ChannelRemoved)();

	// Helpers
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_StateChanged(NM_VIDEO_STATE uState);
	HRESULT Fire_PropertyChanged(DWORD dwReserved);
	void _OnActivate(bool bActive) {;}

	virtual CNmConferenceObj* GetConfObj() = 0;	
	virtual void RemoveMembers() = 0;
	virtual BOOL GetbActive() = 0;

	STDMETHOD(Activate)(BOOL bActive);

	HRESULT _IsActive();
	HRESULT _SetActive(BOOL bActive);

};


#endif // __NmChannelVideo_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmconference.h ===
#ifndef __NmConference_h__
#define __NmConference_h__

#include "SDKInternal.h"
#include "FtHook.h"


// Forward decls
class CNmMemberObj;
class CNmManagerObj;

/////////////////////////////////////////////////////////////////////////////
// CNmConferenceObj
class ATL_NO_VTABLE CNmConferenceObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IConnectionPointContainerImpl<CNmConferenceObj>,
	public IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>,
	public INmConference,
	public INmConferenceNotify2,
	public IInternalConferenceObj,
	public IMbftEvents
{

protected:
// Data
	CComPtr<INmConference>		m_spInternalINmConference;
	CSimpleArray<INmMember*>	m_SDKMemberObjs;
	CSimpleArray<INmChannel*>	m_SDKChannelObjs;
	CSimpleArray<GUID>			m_DataChannelGUIDList;
	DWORD						m_dwInternalINmConferenceAdvise;
	CNmManagerObj*				m_pManagerObj;
	NM_CONFERENCE_STATE			m_State;
	bool						m_bFTHookedUp;
	BOOL						m_bLocalVideoActive;
	BOOL						m_bRemoteVideoActive;

public:

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmConferenceObj)

BEGIN_COM_MAP(CNmConferenceObj)
	COM_INTERFACE_ENTRY(INmConference)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmConferenceNotify)
	COM_INTERFACE_ENTRY(INmConferenceNotify2)
	COM_INTERFACE_ENTRY(IInternalConferenceObj)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmConferenceObj)
	CONNECTION_POINT_ENTRY(IID_INmConferenceNotify)
END_CONNECTION_POINT_MAP()

// Construction/destruction
	CNmConferenceObj();
	~CNmConferenceObj();
	HRESULT FinalConstruct();
	ULONG InternalRelease();

	static HRESULT CreateInstance(CNmManagerObj* pManagerObj, INmConference* pInternalINmConferenece, INmConference** ppConference);
	static HRESULT InitSDK();
	static void CleanupSDK();

	// INmConference methods
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetID)(ULONG * puID);
	STDMETHOD(GetState)(NM_CONFERENCE_STATE *pState);
	STDMETHOD(GetNmchCaps)(ULONG *puchCaps);
	STDMETHOD(GetTopProvider)(INmMember **ppMember);
	STDMETHOD(EnumMember)(IEnumNmMember **ppEnum);
	STDMETHOD(GetMemberCount)(ULONG *puCount);
	STDMETHOD(CreateChannel)(INmChannel **ppChannel, ULONG uNmCh, INmMember *pMember);
	STDMETHOD(EnumChannel)(IEnumNmChannel **ppEnum);
	STDMETHOD(GetChannelCount)(ULONG *puCount);
	STDMETHOD(CreateDataChannel)(INmChannelData **ppChannel, REFGUID rguid);
	STDMETHOD(Host)(void);
	STDMETHOD(Leave)(void);
	STDMETHOD(IsHosting)(void);
	STDMETHOD(LaunchRemote)(REFGUID rguid, INmMember *pMember);

	// INmConferenceNotify2 methods:
	//
	STDMETHOD(NmUI)(CONFN uNotify);
	STDMETHOD(StateChanged)(NM_CONFERENCE_STATE uState);
	STDMETHOD(MemberChanged)(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember);
	STDMETHOD(ChannelChanged)(NM_CHANNEL_NOTIFY uNotify, INmChannel *pInternalChannel);
	STDMETHOD(StreamEvent)(NM_STREAMEVENT uEvent, UINT uSubCode,INmChannel *pInternalChannel);

	//IInternalConferenceObj
	STDMETHOD(GetInternalINmConference)(INmConference** ppConference); 
	STDMETHOD(GetMemberFromNodeID)(DWORD dwNodeID, INmMember** ppMember);
	STDMETHOD(RemoveAllMembersAndChannels)();
	STDMETHOD(AppSharingStateChanged)(BOOL bActive);
	STDMETHOD(SharableAppStateChanged)(HWND hWnd, NM_SHAPP_STATE state);
	STDMETHOD(ASLocalMemberChanged)();
	STDMETHOD(ASMemberChanged)(UINT gccID);
	STDMETHOD(FireNotificationsToSyncState)();
	STDMETHOD(AppSharingChannelChanged)();
	STDMETHOD(FireNotificationsToSyncToInternalObject)();
	STDMETHOD(EnsureFTChannel)();
	STDMETHOD(AudioChannelActiveState)(BOOL bActive, BOOL bIsIncoming);
	STDMETHOD(VideoChannelActiveState)(BOOL bActive, BOOL bIsIncoming);
	STDMETHOD(VideoChannelPropChanged)(DWORD dwProp, BOOL bIsIncoming);
	STDMETHOD(VideoChannelStateChanged)(NM_VIDEO_STATE uState, BOOL bIsIncoming);


	// IMbftEvent Interface
	STDMETHOD(OnInitializeComplete)(void);
	STDMETHOD(OnPeerAdded)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnPeerRemoved)(MBFT_PEER_INFO *pInfo);
	STDMETHOD(OnFileOffer)(MBFT_FILE_OFFER *pOffer);
	STDMETHOD(OnFileProgress)(MBFT_FILE_PROGRESS *pProgress);
	STDMETHOD(OnFileEnd)(MBFTFILEHANDLE hFile);
	STDMETHOD(OnFileError)(MBFT_EVENT_ERROR *pEvent);
	STDMETHOD(OnFileEventEnd)(MBFTEVENTHANDLE hEvent);
	STDMETHOD(OnSessionEnd)(void);

		// Notifications
	HRESULT Fire_NmUI(CONFN uNotify);
	HRESULT Fire_StateChanged(NM_CONFERENCE_STATE uState);
	HRESULT Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	HRESULT Fire_ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pInternalChannel);

	INmMember* GetSDKMemberFromInternalMember(INmMember* pInternalMember);
	INmChannel* GetSDKChannelFromInternalChannel(INmChannel* pInternalChannel);
	INmMember* GetLocalSDKMember();

private:
// helper Fns

	static HRESULT _CreateInstanceGuts(CComObject<CNmConferenceObj> *p, INmConference** ppConference);
	HRESULT _RemoveMember(INmMember* pInternalMember);
	HRESULT _RemoveChannel(INmChannel* pSDKChannel);
	void _FreeInternalStuff();
	bool _IsGuidInDataChannelList(GUID& rg);
	HRESULT _AddAppShareChannel();
	HRESULT _AddFileTransferChannel();
	void _EnsureFtChannelAdded();
	void AddMemberToAsChannel(INmMember* pSDKMember);
	void RemoveMemberFromAsChannel(INmMember* pSDKMember);
	void AddMemberToFtChannel(INmMember* pSDKMember);
	void RemoveMemberFromFtChannel(INmMember* pSDKMember);
	INmChannel* _GetAppSharingChannel();
	INmChannel* _GetFtChannel();
	INmChannel* _GetAudioChannel(BOOL bIncoming);
	INmChannel* _GetVideoChannel(BOOL bIncoming);
	HRESULT _ASMemberChanged(INmMember *pSDKMember);
	void _EnsureMemberHasAVChannelsIfNeeded(INmMember* pSDKMember);
	void _EnsureMemberHasAVChannel(ULONG ulch, INmMember* pSDKMember);
	void _EnsureSentConferenceCreatedNotification();

};

#endif // __NmConference_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmconference.cpp ===
#include "precomp.h"
#include "wbguid.h"
#include "confroom.h"

// SDK Includes
#include "NmEnum.h"
#include "SDKInternal.h"
#include "NmManager.h"
#include "NmConference.h"
#include "NmMember.h"
#include "NmCall.h"
#include "SDKWindow.h"
#include "NmChannelData.h"
#include "NmChannelFt.h"
#include "NmChannelAudio.h"
#include "NmChannelVideo.h"
#include "NmChannelAppShare.h"
#include "NmSharableApp.h"
#include "FtHook.h"

extern INmManager2* g_pInternalNmManager;

/////////////////////////////////////////////////////////
// Construction/destruction
/////////////////////////////////////////////////////////


CNmConferenceObj::CNmConferenceObj()
: m_dwInternalINmConferenceAdvise( 0 ),
  m_State(NM_CONFERENCE_IDLE),
  m_bFTHookedUp(false)
{
	DBGENTRY(CNmConferenceObj::CNmConferenceObj);


	DBGEXIT(CNmConferenceObj::CNmConferenceObj);
}

CNmConferenceObj::~CNmConferenceObj()
{
	DBGENTRY(CNmConferenceObj::~CNmConferenceObj);

	CFt::UnAdvise(this);
	m_bFTHookedUp = false;

		// this will protect us form re-deleting ourselves
	++m_dwRef;

	_FreeInternalStuff();

	// We don't have to release because we didn't addref
	// This is safe because our lifetime is contianed in the CNmManageObj's lifetime
	m_pManagerObj = NULL;

	DBGEXIT(CNmConferenceObj::~CNmConferenceObj);
}



HRESULT CNmConferenceObj::FinalConstruct()
{
	DBGENTRY(CNmConferenceObj::FinalConstruct);
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = AtlAdvise(m_spInternalINmConference, GetUnknown(), IID_INmConferenceNotify2, &m_dwInternalINmConferenceAdvise);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmConferenceObj::FinalConstruct,hr);
	return hr;
}



ULONG CNmConferenceObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInternalINmConferenceAdvise)
	{	
		++m_dwRef;
		DWORD dwAdvise = m_dwInternalINmConferenceAdvise;
		CComPtr<INmConference> spConf = m_spInternalINmConference;
		m_spInternalINmConference = NULL;

			// This keeps us from getting here twice!
		m_dwInternalINmConferenceAdvise = 0;
		AtlUnadvise(spConf, IID_INmConferenceNotify2, dwAdvise);
		--m_dwRef;
	}

	return m_dwRef;

}


/*static*/ HRESULT CNmConferenceObj::InitSDK()
{
	DBGENTRY(CNmConferenceObj::InitSDK);
	HRESULT hr = S_OK;

	DBGEXIT_HR(CNmConferenceObj::InitSDK,hr);
	return hr;
}

/*static*/void CNmConferenceObj::CleanupSDK()
{
	DBGENTRY(CNmConferenceObj::CleanupSDK);
	
	DBGEXIT(CNmConferenceObj::CleanupSDK);
}


/*static*/
HRESULT CNmConferenceObj::CreateInstance(CNmManagerObj* pManagerObj, INmConference* pInternalINmConferenece, INmConference** ppConference)
{
	DBGENTRY(CNmConferenceObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmConferenceObj>* p = NULL;
	p = new CComObject<CNmConferenceObj>(NULL);

	if (p != NULL)
	{
		if(SUCCEEDED(hr))
		{
			CNmConferenceObj* pThis = static_cast<CNmConferenceObj*>(p);

			pThis->m_spInternalINmConference = pInternalINmConferenece;
			if(pInternalINmConferenece)
			{
				pInternalINmConferenece->GetState(&pThis->m_State);
			}
				// We don't have to RefCount this because our lifetime is
				// contained in the CNMManageuObj's lifetime
			pThis->m_pManagerObj = pManagerObj;
		}

		hr = _CreateInstanceGuts(p, ppConference);				
	}

	DBGEXIT_HR(CNmConferenceObj::CreateInstance,hr);
	return hr;
}



/*static*/
HRESULT CNmConferenceObj::_CreateInstanceGuts(CComObject<CNmConferenceObj> *p, INmConference** ppConference)
{
	DBGENTRY(CNmConferenceObj::_CreateInstanceGuts);
	HRESULT hr = S_OK;

	if(ppConference)
	{
		if(p != NULL)
		{
			p->SetVoid(NULL);

				// We do this so that we don't accidentally Release out of memory
			++p->m_dwRef;
			hr = p->FinalConstruct();
			--p->m_dwRef;

			if(hr == S_OK)
				hr = p->QueryInterface(IID_INmConference, reinterpret_cast<void**>(ppConference));

			if(FAILED(hr))
			{	*ppConference = NULL;
				delete p;
			}
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}
	else
	{		
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::_CreateInstanceGuts,hr);
	return hr;
			
}


/////////////////////////////////////////////////////////
// INmConference methods
/////////////////////////////////////////////////////////

STDMETHODIMP CNmConferenceObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmConferenceObj::GetName);
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetName(pbstrName);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::GetID(ULONG * puID)
{
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetID(puID);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;

}

STDMETHODIMP CNmConferenceObj::GetState(NM_CONFERENCE_STATE *pState)
{
	DBGENTRY(CNmConferenceObj::GetState);
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetState(pState);
	}
	else
	{
		hr = E_UNEXPECTED;	
	}

	DBGEXIT_HR(CNmConferenceObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::GetNmchCaps(ULONG *puchCaps)
{
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->GetNmchCaps(puchCaps);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::GetTopProvider(INmMember **ppMember)
{
	HRESULT hr = E_FAIL;

	if(ppMember)
	{	*ppMember = NULL;

		if(m_spInternalINmConference)
		{
			INmMember* pInternalMember;
			if(SUCCEEDED(m_spInternalINmConference->GetTopProvider(&pInternalMember)))
			{
				*ppMember = GetSDKMemberFromInternalMember(pInternalMember);

				if(*ppMember)
				{
					(*ppMember)->AddRef();
					hr = S_OK;
				}

					// This is commented out for clairity.
					// the GetTopProvider method in nmcom does not
					// actually addref the pointer (!)
				//pInternalMember->Release
			}
		}
	}
	else
	{
		hr = E_POINTER;
	}
	
	return hr;
}

STDMETHODIMP CNmConferenceObj::EnumMember(IEnumNmMember **ppEnum)
{	
	DBGENTRY(CNmConferenceObj::EnumMember);
	HRESULT hr = S_OK;
			
	if(ppEnum)
	{
		hr = CreateEnumFromSimpleAryOfInterface<IEnumNmMember, INmMember>(m_SDKMemberObjs, ppEnum);
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::EnumMember,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::GetMemberCount(ULONG *puCount)
{
	DBGENTRY(CNmConferenceObj::GetMemberCount);
	HRESULT hr = S_OK;

	if(puCount)
	{
		*puCount = m_SDKMemberObjs.GetSize();
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::GetMemberCount,hr);
	return hr;

}

STDMETHODIMP CNmConferenceObj::CreateChannel(INmChannel **ppChannel, ULONG uNmCh, INmMember *pMember)
{
	ATLTRACENOTIMPL(_T("CNmConferenceObj::GetName"));
}

STDMETHODIMP CNmConferenceObj::EnumChannel(IEnumNmChannel **ppEnum)
{
	DBGENTRY(CNmConferenceObj::EnumChannel);
	HRESULT hr = E_NOTIMPL;

	if(ppEnum)
	{
		hr = CreateEnumFromSimpleAryOfInterface<IEnumNmChannel, INmChannel>(m_SDKChannelObjs, ppEnum);
	}
	else
	{
		hr = E_POINTER;
	}


	DBGEXIT_HR(CNmConferenceObj::EnumChannel,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::GetChannelCount(ULONG *puCount)
{
	DBGENTRY(CNmConferenceObj::GetChannelCount);
	HRESULT hr = S_OK;


	if(puCount)
	{
		*puCount = m_SDKChannelObjs.GetSize();
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmConferenceObj::GetChannelCount,hr);
	return hr;
}


// NetMeeting 2.0 chat guid: {340F3A60-7067-11D0-A041-444553540000}
const GUID g_guidNM2Chat =
{ 0x340f3a60, 0x7067, 0x11d0, { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };

STDMETHODIMP CNmConferenceObj::CreateDataChannel(INmChannelData **ppChannel, REFGUID rguid)
{
	HRESULT hr = S_OK;

	if(m_spInternalINmConference)
	{
		if(!InlineIsEqualGUID(rguid, g_guidNM2Chat))
		{

			GUID g = rguid;
			if(!_IsGuidInDataChannelList(g))
			{
				m_DataChannelGUIDList.Add(g);
			}

			CComPtr<INmChannelData> spInternalDataChannel;
			hr = m_spInternalINmConference->CreateDataChannel(&spInternalDataChannel, rguid);
			if(SUCCEEDED(hr))
			{
				INmChannel* pSDKChannel = GetSDKChannelFromInternalChannel(spInternalDataChannel);

				if(pSDKChannel && ppChannel)
				{
					*ppChannel = com_cast<INmChannelData>(pSDKChannel);
					if(*ppChannel)
					{
						(*ppChannel)->AddRef();
					}
					else
					{
						hr = E_UNEXPECTED;
					}
				}
			}
			else
			{
				m_DataChannelGUIDList.Remove(g);
			}
		}
		else
		{
			hr = NM_E_CHANNEL_ALREADY_EXISTS;
		}
	}
	else
	{
		hr = NM_E_NO_T120_CONFERENCE;
	}

	return hr;	
}

STDMETHODIMP CNmConferenceObj::Host(void)
{
	HRESULT hr =  S_OK;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->Host();
	}
	else
	{
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP CNmConferenceObj::Leave(void)
{
	DBGENTRY(CNmConferenceObj::Leave);
	HRESULT hr = S_OK;
	
	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->Leave();

		_FreeInternalStuff();

		if(!m_pManagerObj->OfficeMode())
		{
			StateChanged(NM_CONFERENCE_IDLE);
		}
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmConferenceObj::Leave,hr);
	return hr;		
}

STDMETHODIMP CNmConferenceObj::IsHosting(void)
{
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmConference)
	{
		hr = m_spInternalINmConference->IsHosting();
	}
	
	return hr;
}

STDMETHODIMP CNmConferenceObj::LaunchRemote(REFGUID rguid, INmMember *pMember)
{
	HRESULT hr = E_UNEXPECTED;

	if(m_spInternalINmConference)
	{
		CComPtr<INmMember> spInternalMember;
		if(pMember)
		{
			CComPtr<IInternalMemberObj> spObj = com_cast<IInternalMemberObj>(pMember);
			ASSERT(spObj);
			spObj->GetInternalINmMember(&spInternalMember);
		}

		hr = m_spInternalINmConference->LaunchRemote(rguid, spInternalMember);
	}
	
	return hr;
}

/////////////////////////////////////////////////
// INmConferenceNotify2 methods:
/////////////////////////////////////////////////
STDMETHODIMP CNmConferenceObj::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmConferenceObj::NmUI);
	HRESULT hr = S_OK;

	hr = Fire_NmUI(uNotify);

	DBGEXIT_HR(CNmConferenceObj::NmUI,hr);
	return hr;
}

void CNmConferenceObj::_EnsureSentConferenceCreatedNotification()
{
	if(m_pManagerObj && !m_pManagerObj->m_bSentConferenceCreated)
	{	
			//	If we have not sent conference created, send it now!
		CComQIPtr<INmConference> spConf(GetUnknown());
		m_pManagerObj->Fire_ConferenceCreated(spConf);
	}
}

STDMETHODIMP CNmConferenceObj::StateChanged(NM_CONFERENCE_STATE uState)
{
	DBGENTRY(CNmConferenceObj::StateChanged);
	HRESULT hr = S_OK;

	if(m_State != uState)
	{	
		m_State = uState;
		if(m_State == NM_CONFERENCE_IDLE)
		{
			if(m_bFTHookedUp)
			{
				CFt::UnAdvise(this);
				m_bFTHookedUp = false;
			}

			if(m_pManagerObj)
			{
				m_pManagerObj->m_bSentConferenceCreated = false;
			}

			_FreeInternalStuff();
		
		}
		else if(NM_CONFERENCE_ACTIVE == m_State)
		{
			EnsureFTChannel();
		}

		hr = Fire_StateChanged(uState);

		if(NM_CONFERENCE_WAITING == m_State)
		{
			_EnsureSentConferenceCreatedNotification();
		}
	}

	DBGEXIT_HR(CNmConferenceObj::StateChanged,hr);
	return hr;
}


void CNmConferenceObj::AddMemberToAsChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetAppSharingChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberAdded(pSDKMember);
	}
}

void CNmConferenceObj::RemoveMemberFromAsChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetAppSharingChannel();
	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberRemoved(pSDKMember);
	}
}

void CNmConferenceObj::AddMemberToFtChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetFtChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberAdded(pSDKMember);
	}
}

void CNmConferenceObj::RemoveMemberFromFtChannel(INmMember* pSDKMember)
{
	INmChannel* pChannel = _GetFtChannel();
	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->SDKMemberRemoved(pSDKMember);
	}
}

STDMETHODIMP CNmConferenceObj::MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pInternalMember)
{
	DBGENTRY(CNmConferenceObj::MemberChanged);
	HRESULT hr = S_OK;

	if(pInternalMember)
	{
		CComPtr<INmMember> spMember;

		if(NM_MEMBER_ADDED == uNotify)
		{
			if(NULL == _GetAppSharingChannel())
			{
					// We don't get notified of this channel, so 
					// we have to add it manually
				_AddAppShareChannel();	
			}

				// We actually get this notification multiple times, so just check to make sure...
			if(!GetSDKMemberFromInternalMember(pInternalMember))
			{
				hr = CNmMemberObj::CreateInstance(this, pInternalMember, &spMember);
				if(SUCCEEDED(hr))
				{
					spMember.p->AddRef();
					m_SDKMemberObjs.Add(spMember.p);
				}
			}
		}

		CComPtr<INmMember> spSDKMember = GetSDKMemberFromInternalMember(pInternalMember);

		if(NM_MEMBER_REMOVED == uNotify)
		{
			_RemoveMember(pInternalMember);
		}

		Fire_MemberChanged(uNotify, spSDKMember);

		if((NM_MEMBER_ADDED == uNotify) || (NM_MEMBER_UPDATED == uNotify))
		{
				// Add the member to the AS Channel iff they have NMCH_DATA
			ASSERT(spSDKMember);

			ULONG uchCaps = 0;
			if(SUCCEEDED(spSDKMember->GetNmchCaps(&uchCaps)))
			{
				if(NMCH_DATA & uchCaps)
				{
						// This method will handle being called multiple times for the same member
					AddMemberToAsChannel(spSDKMember);
				}
			}
		}

		if(SUCCEEDED(hr) && (uNotify != NM_MEMBER_REMOVED))
		{
			ULONG ulGCCid;
			if(SUCCEEDED(spSDKMember->GetID(&ulGCCid)))
			{
				if(CFt::IsMemberInFtSession(static_cast<T120NodeID>(ulGCCid)))
				{		
						// Make sure that the user is in the channel
					AddMemberToFtChannel(spSDKMember);
				}
			}

			_EnsureMemberHasAVChannelsIfNeeded(spSDKMember);
		}
	}
	else
	{
		WARNING_OUT(("Why are we pased a NULL member?"));
	}

	DBGEXIT_HR(CNmConferenceObj::MemberChanged,hr);
	return hr;
}


STDMETHODIMP CNmConferenceObj::FireNotificationsToSyncState()
{
	// this is no longer used...
	ASSERT(0);
	return S_OK;
}


STDMETHODIMP CNmConferenceObj::EnsureFTChannel()
{
	if(m_pManagerObj && m_pManagerObj->FileTransferNotifications())
	{
		if(!m_bFTHookedUp)
		{
				// When the conference is active, we should add ourselves
			CFt::Advise(this);
			_EnsureFtChannelAdded();

			m_bFTHookedUp = true;

			if(CFt::IsFtActive())
			{
				// This means that the channel is Active
				INmChannel* pChannel = _GetFtChannel();

				if(pChannel)
				{
					com_cast<IInternalChannelObj>(pChannel)->Activate(true);

					Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	
	INmChannel* pChannel = _GetAudioChannel(bIsIncoming);

	if(pChannel && ((pChannel->IsActive() == S_OK) != bActive))
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(bActive);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	
	INmChannel* pChannel = _GetVideoChannel(bIsIncoming);

	if(pChannel && ((pChannel->IsActive() == S_OK) != bActive))
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(bActive);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::VideoChannelPropChanged(DWORD dwProp, BOOL bIsIncoming)
{
	INmChannel* pChannel = _GetVideoChannel(bIsIncoming);

	if(pChannel)
	{
		com_cast<INmChannelVideoNotify>(pChannel)->PropertyChanged(dwProp);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming)
{
	INmChannel* pChannel = _GetVideoChannel(bIsIncoming);

	if(pChannel)
	{
		com_cast<INmChannelVideoNotify>(pChannel)->StateChanged(uState);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pInternalChannel)
{
	DBGENTRY(CNmConferenceObj::ChannelChanged);
	HRESULT hr = S_OK;

	if(pInternalChannel)
	{
		if(NM_CHANNEL_ADDED == uNotify)
		{
			ULONG ulCh = NMCH_NONE;
			hr = pInternalChannel->GetNmch(&ulCh);
			if(SUCCEEDED(hr))
			{
				CComPtr<INmChannel> spChannel;
				hr = E_UNEXPECTED;

				switch(ulCh)
				{
					case NMCH_VIDEO:
						// this means that the channel is "Active"
						{
							BOOL bIncoming = (S_OK == com_cast<INmChannelVideo>(pInternalChannel)->IsIncoming());
							INmChannel* pVidChannel = _GetVideoChannel(bIncoming);
							if(pVidChannel)
							{
								com_cast<IInternalChannelObj>(pVidChannel)->Activate(true);
							}
							else
							{
								if(bIncoming)
								{
									m_bRemoteVideoActive = true;
								}
								else
								{
									m_bLocalVideoActive = true;
								}
							}
						}
						break;

					case NMCH_AUDIO:
						// this means that the channel is "Active"
						{
							BOOL bIncoming = (S_OK == com_cast<INmChannelAudio>(pInternalChannel)->IsIncoming());
							INmChannel* pAudioChannel = _GetAudioChannel(bIncoming);
							if(pAudioChannel)
							{
								com_cast<IInternalChannelObj>(pAudioChannel)->Activate(true);
							}
						}

						break;

					case NMCH_DATA:

						if(m_pManagerObj && m_pManagerObj->DataNotifications())
						{
							if(pInternalChannel)
							{
								CComPtr<INmChannelData> spDataChannel = com_cast<INmChannelData>(pInternalChannel);
								GUID g;
								if(spDataChannel && SUCCEEDED(spDataChannel->GetGuid(&g)))
								{
									if(_IsGuidInDataChannelList(g))
									{
											// We only do this if this GUID is in our list
										hr = CNmChannelDataObj::CreateInstance(this, pInternalChannel, &spChannel);
									}
								}
							}
						}
						break;

					case NMCH_FT:
						break;

					case NMCH_SHARE:
						// Currently, we don't get notified of the App Sharing "channel"
					default:
						ERROR_OUT(("Unknown channel type"));
						break;
				}

				if(SUCCEEDED(hr))
				{
					spChannel.p->AddRef();
					m_SDKChannelObjs.Add(spChannel.p);
					Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

						// Add all the members from the internal channel
					CComPtr<IEnumNmMember> spEnumMember;
					if(SUCCEEDED(pInternalChannel->EnumMember(&spEnumMember)))
					{
						INmMember* pMember = NULL;

						ULONG ulFetched = 0;
						while(S_OK == spEnumMember->Next(1, &pMember, &ulFetched))
						{
							
							CComPtr<INmMember> spSDKMember = GetSDKMemberFromInternalMember(pMember);

							if(spSDKMember)
							{
								com_cast<IInternalChannelObj>(spChannel)->SDKMemberAdded(spSDKMember);
							}
							else
							{
								ERROR_OUT(("We should not have members of a channel before they are in the conference"));
							}

							pMember->Release();
							pMember = NULL;
						}
					}

				}
			}
		}
		else
		{
			INmChannel* pChannel = GetSDKChannelFromInternalChannel(pInternalChannel);

			if(SUCCEEDED(hr) && pChannel)
			{
				if(NM_CHANNEL_REMOVED == uNotify)
				{
					_RemoveChannel(pChannel);
				}
				else
				{
					Fire_ChannelChanged(uNotify, pChannel);
				}
			}
		}
	}
	else
	{	
		hr = E_UNEXPECTED;
		ERROR_OUT(("ChannelChanged was passed a NULL INmChannel"));
	}

	DBGEXIT_HR(CNmConferenceObj::ChannelChanged,hr);
	return hr;
}

STDMETHODIMP CNmConferenceObj::StreamEvent(NM_STREAMEVENT uEvent, UINT uSubCode, INmChannel *pInternalChannel)
{
	DBGENTRY(CNmConferenceObj::StreamEvent);
	HRESULT hr = S_OK;
	
	DBGEXIT_HR(CNmConferenceObj::StreamEvent,hr);
	return hr;
}


	// IMbftEvent Interface
STDMETHODIMP CNmConferenceObj::OnInitializeComplete(void)
{
	// This means that the channel is Active
	INmChannel* pChannel = _GetFtChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(true);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnPeerAdded(MBFT_PEER_INFO *pInfo)
{
	CComPtr<INmMember> spMember;
	HRESULT hr = E_FAIL;

	if(CFt::IsMemberInFtSession(pInfo->NodeID))
	{
		hr = GetMemberFromNodeID(pInfo->NodeID, &spMember);

		if(SUCCEEDED(hr))
		{
			AddMemberToFtChannel(spMember);
		}
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::OnPeerRemoved(MBFT_PEER_INFO *pInfo)
{
	CComPtr<INmMember> spMember;

	HRESULT hr = GetMemberFromNodeID(pInfo->NodeID, &spMember);

	if(SUCCEEDED(hr))
	{
		RemoveMemberFromFtChannel(spMember);
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileOffer(MBFT_FILE_OFFER *pOffer)
{
	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileProgress(MBFT_FILE_PROGRESS *pProgress)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileEnd(MBFTFILEHANDLE hFile)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileError(MBFT_EVENT_ERROR *pEvent)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnFileEventEnd(MBFTEVENTHANDLE hEvent)
{

	// The FT Channel and FT Object will handle this
	return S_OK;
}

STDMETHODIMP CNmConferenceObj::OnSessionEnd(void)
{
	// This means that the channel is Active
	INmChannel* pChannel = _GetFtChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(false);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);

		_RemoveChannel(pChannel);
	}

	CFt::UnAdvise(this);
	m_bFTHookedUp = false;

	return S_OK;
}


////////////////////////////////////////////////////////////////////////
//IInternalConferenceObj
////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmConferenceObj::GetInternalINmConference(INmConference** ppConference)
{
	DBGENTRY(CNmConferenceObj::GetInternalINmConference);
	HRESULT hr = S_OK;
	
	ASSERT(ppConference);
	
	*ppConference = m_spInternalINmConference;
	if(*ppConference)
	{
		(*ppConference)->AddRef();
	}

	DBGEXIT_HR(CNmConferenceObj::GetInternalINmConference,hr);
	return hr;
}


STDMETHODIMP CNmConferenceObj::GetMemberFromNodeID(DWORD dwNodeID, INmMember** ppMember)
{
	HRESULT hr = E_POINTER;

	if(ppMember)
	{
		hr = E_FAIL;
		for(int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
		{
			DWORD dwGCCID;
			HRESULT hrRes;
			if(SUCCEEDED(hrRes = m_SDKMemberObjs[i]->GetID(&dwGCCID)))
			{
				if(dwGCCID == dwNodeID)
				{
					*ppMember = m_SDKMemberObjs[i];
					(*ppMember)->AddRef();
					hr = S_OK;
				}
			}
			else hr = hrRes;
		}
	}
	
	return hr;
}


STDMETHODIMP CNmConferenceObj::RemoveAllMembersAndChannels()
{
	HRESULT hr = S_OK;

	_FreeInternalStuff();	

	return hr;
}

STDMETHODIMP CNmConferenceObj::AppSharingChannelChanged()
{

	HRESULT hr = E_UNEXPECTED;

	INmChannel* pChannel = _GetAppSharingChannel();

	if(pChannel)
	{
		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return hr;
}


STDMETHODIMP CNmConferenceObj::FireNotificationsToSyncToInternalObject()
{
	if(m_spInternalINmConference)
	{

			// Add all the members from the internal conference
		CComPtr<IEnumNmMember> spEnumMember;
		if(SUCCEEDED(m_spInternalINmConference->EnumMember(&spEnumMember)))
		{
			INmMember* pMember = NULL;

			ULONG ulFetched = 0;
			while(S_OK == spEnumMember->Next(1, &pMember, &ulFetched))
			{
				MemberChanged(NM_MEMBER_ADDED, pMember);
				pMember->Release();
				pMember = NULL;
			}
		}


			// Fire the CHANNEL_ADDED notifications
		for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
		{
			Fire_ChannelChanged(NM_CHANNEL_ADDED, m_SDKChannelObjs[i]);
				
				// Tell the channel to fire the MEMBER_ADDED notificaitnos, etc.
			com_cast<IInternalChannelObj>(m_SDKChannelObjs[i])->FireNotificationsToSyncState();
		}

		if(0 != m_SDKMemberObjs.GetSize())
		{
			if(NULL == _GetAppSharingChannel())
			{
						// We don't get notified of this channel, so 
						// we have to add it manually
					_AddAppShareChannel();	
			}

			EnsureFTChannel();

			for(i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
			{
				ULONG uchCaps = 0;
				if(SUCCEEDED(m_SDKMemberObjs[i]->GetNmchCaps(&uchCaps)))
				{
					if(NMCH_DATA & uchCaps)
					{
							// This method will handle being called multiple times for the same member
						AddMemberToAsChannel(m_SDKMemberObjs[i]);
					}
				}			
				
				
				ULONG ulGCCid;
				if(SUCCEEDED(m_SDKMemberObjs[i]->GetID(&ulGCCid)))
				{
					if(CFt::IsMemberInFtSession(static_cast<T120NodeID>(ulGCCid)))
					{		
							// Make sure that the user is in the channel
						AddMemberToFtChannel(m_SDKMemberObjs[i]);
					}
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CNmConferenceObj::AppSharingStateChanged(BOOL bActive)
{

	HRESULT hr = E_UNEXPECTED;

	INmChannel* pChannel = _GetAppSharingChannel();

	if(pChannel)
	{
		com_cast<IInternalChannelObj>(pChannel)->Activate(bActive);

		Fire_ChannelChanged(NM_CHANNEL_UPDATED, pChannel);
	}

	return hr;
}


INmChannel* CNmConferenceObj::_GetAppSharingChannel()
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if(NMCH_SHARE == ulch)
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}


INmChannel* CNmConferenceObj::_GetFtChannel()
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if(NMCH_FT == ulch)
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}


INmChannel* CNmConferenceObj::_GetAudioChannel(BOOL bIncoming)
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if((NMCH_AUDIO == ulch) && ((S_OK == com_cast<INmChannelAudio>(m_SDKChannelObjs[i])->IsIncoming()) == bIncoming))
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}

INmChannel* CNmConferenceObj::_GetVideoChannel(BOOL bIncoming)
{
	INmChannel* pChannel = NULL;

	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulch;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulch)))
		{
			if((NMCH_VIDEO == ulch) && ((S_OK == com_cast<INmChannelVideo>(m_SDKChannelObjs[i])->IsIncoming()) == bIncoming))
			{
				pChannel = m_SDKChannelObjs[i];
				break;
			}
		}
	}

	return pChannel;
}


STDMETHODIMP CNmConferenceObj::SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state)
{
	INmChannel* pChannelAs = _GetAppSharingChannel();

	HRESULT hr = S_OK;

	if(pChannelAs)
	{
		CComPtr<INmSharableApp> spSharableApp;

		TCHAR szName[MAX_PATH];

		hr = CNmChannelAppShareObj::GetSharableAppName(hWnd, szName, CCHMAX(szName));

		if(SUCCEEDED(hr))
		{
			hr = CNmSharableAppObj::CreateInstance(hWnd, szName, &spSharableApp);

			if(SUCCEEDED(hr))
			{
				com_cast<INmChannelAppShareNotify>(pChannelAs)->StateChanged(state, spSharableApp);
			}
		}
	}

	return hr;
}

STDMETHODIMP CNmConferenceObj::ASLocalMemberChanged()
{
	return _ASMemberChanged(GetLocalSDKMember());
}

STDMETHODIMP CNmConferenceObj::ASMemberChanged(UINT gccID)
{
	CComPtr<INmMember> spMember;

	HRESULT hr = GetMemberFromNodeID(gccID, &spMember);

	if(SUCCEEDED(hr))
	{
		hr = _ASMemberChanged(spMember);
	}

	return hr;
}

HRESULT CNmConferenceObj::_ASMemberChanged(INmMember *pSDKMember)
{
	if(pSDKMember)
	{
		Fire_MemberChanged(NM_MEMBER_UPDATED, pSDKMember);
		
		INmChannel* pChannel = _GetAppSharingChannel();
		if(pChannel)
		{
			com_cast<IInternalChannelObj>(pChannel)->SDKMemberChanged(pSDKMember);
		}
	}
	else
	{
		return E_UNEXPECTED;
	}

	return S_OK;
}

////////////////////////////////////////////////////////////////////////
// Notifications
////////////////////////////////////////////////////////////////////////


HRESULT CNmConferenceObj::Fire_NmUI(CONFN uNotify)
{
	DBGENTRY(CNmConferenceObj::Fire_NmUI)
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->NmUI(uNotify);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceNmUI(this, uNotify);
	}

	DBGEXIT_HR(CNmConferenceObj::Fire_NmUI,hr);
	return hr;
}

HRESULT CNmConferenceObj::Fire_StateChanged(NM_CONFERENCE_STATE uState)
{
	DBGENTRY(CNmConferenceObj::Fire_StateChanged)
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->StateChanged(uState);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceStateChanged(this, uState);
	}

	DBGEXIT_HR(CNmConferenceObj::Fire_StateChanged,hr);
	return hr;
}

extern bool g_bOfficeModeSuspendNotifications;

HRESULT CNmConferenceObj::Fire_MemberChanged(NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CNmConferenceObj::Fire_MemberChanged);
	HRESULT hr = S_OK;

	if(m_pManagerObj->OfficeMode() && g_bOfficeModeSuspendNotifications)
	{
			// We don't have to notify anyone at all...
		return S_OK;			
	}

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->MemberChanged(uNotify, pMember);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceMemberChanged(this, uNotify, pMember);
	}
	
	DBGEXIT_HR(CNmConferenceObj::Fire_MemberChanged,hr);
	return hr;
}



HRESULT CNmConferenceObj::Fire_ChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	DBGENTRY(CNmConferenceObj::Fire_ChannelChanged);
	HRESULT hr = S_OK;

	if(!g_bSDKPostNotifications)
	{
			/////////////////////////////////////////////////////
			// INmConferenceNotify
			/////////////////////////////////////////////////////

		IConnectionPointImpl<CNmConferenceObj, &IID_INmConferenceNotify, CComDynamicUnkArray>* pCP = this;
		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			INmConferenceNotify* pNotify = reinterpret_cast<INmConferenceNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->ChannelChanged(uNotify, pChannel);
			}
		}
	}
	else
	{
		CSDKWindow::PostConferenceChannelChanged(this, uNotify, pChannel);
	}

	DBGEXIT_HR(CNmConferenceObj::Fire_ChannelChanged,hr);
	return hr;
}


/////////////////////////////////////////////////
// helper Fns
/////////////////////////////////////////////////

INmChannel* CNmConferenceObj::GetSDKChannelFromInternalChannel(INmChannel* pInternalChannel)
{
	DBGENTRY(CNmConferenceObj::GetSDKChannelFromInternalChannel);

	INmChannel* pRet = NULL;

	for( int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalChannelObj> spInternal = m_SDKChannelObjs[i];
		if(spInternal)
		{
			CComPtr<INmChannel> spChannel;
			if(SUCCEEDED(spInternal->GetInternalINmChannel(&spChannel)))
			{
				if(spChannel.IsEqualObject(pInternalChannel))
				{
					pRet = m_SDKChannelObjs[i];
					break;
				}
			}
		}
	}

	DBGEXIT(CNmConferenceObj::GetSDKChannelFromInternalChannel);
	return pRet;
}


INmMember* CNmConferenceObj::GetSDKMemberFromInternalMember(INmMember* pInternalMember)
{
	DBGENTRY(CNmConferenceObj::GetSDKMemberFromInternalMember);

	INmMember* pRet = NULL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalMemberObj> spInternal = m_SDKMemberObjs[i];
		if(spInternal)
		{
			CComPtr<INmMember> spMember;
			if(SUCCEEDED(spInternal->GetInternalINmMember(&spMember)))
			{
				if(spMember.IsEqualObject(pInternalMember))
				{
					pRet = m_SDKMemberObjs[i];
					break;
				}
			}
		}
	}

	DBGEXIT(CNmConferenceObj::GetSDKMemberFromInternalMember);
	return pRet;
}


INmMember* CNmConferenceObj::GetLocalSDKMember()
{
	INmMember* pRet = NULL;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		if(S_OK == m_SDKMemberObjs[i]->IsSelf())
		{
			pRet = m_SDKMemberObjs[i];
			break;
		}
	}

	return pRet;

}


HRESULT CNmConferenceObj::_RemoveMember(INmMember* pInternalMember)
{
	HRESULT hr = S_OK;

	for( int i = 0; i < m_SDKMemberObjs.GetSize(); ++i)
	{
		CComPtr<INmMember> spSDKMember = m_SDKMemberObjs[i];
		CComQIPtr<IInternalMemberObj> spMemberObj = spSDKMember;

		CComPtr<INmMember> spInternal;
		if(SUCCEEDED(spMemberObj->GetInternalINmMember(&spInternal)))
		{
			if(spInternal.IsEqualObject(pInternalMember))
			{
					// Remove the member from each of the channels
				for(int iChan = 0; iChan < m_SDKChannelObjs.GetSize(); ++iChan)
				{
					com_cast<IInternalChannelObj>(m_SDKChannelObjs[iChan])->SDKMemberRemoved(m_SDKMemberObjs[i]);
				}
				
					// Remove our reference to the member
				m_SDKMemberObjs.RemoveAt(i);
				spSDKMember.p->Release();
				break;
			}
		}
	}

	return hr;	
}


HRESULT CNmConferenceObj::_RemoveChannel(INmChannel* pSDKChannel)
{
	HRESULT hr = S_OK;

	for( int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		CComPtr<INmChannel> spChannel = m_SDKChannelObjs[i];

		if(spChannel.IsEqualObject(pSDKChannel))
		{
			m_SDKChannelObjs.RemoveAt(i);

			com_cast<IInternalChannelObj>(spChannel)->ChannelRemoved();

			spChannel.p->Release();

			break;
		}
	}

	return hr;
}

void CNmConferenceObj::_EnsureFtChannelAdded()
{
	if(NULL == _GetFtChannel())
	{
		_AddFileTransferChannel();
	}
}

HRESULT CNmConferenceObj::_AddFileTransferChannel()
{
	HRESULT hr = S_OK;

	if(m_pManagerObj && m_pManagerObj->FileTransferNotifications())
	{
		CComPtr<INmChannel> spChannel;
		hr = CNmChannelFtObj::CreateInstance(this, &spChannel);

		if(SUCCEEDED(hr))
		{
				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);

				// Fire the notification
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);
		}
	}

	return hr;
}



HRESULT CNmConferenceObj::_AddAppShareChannel()
{
	HRESULT hr = S_OK;

	if(m_pManagerObj && m_pManagerObj->AppSharingNotifications())
	{
		CComPtr<INmChannel> spChannel;
		hr = CNmChannelAppShareObj::CreateInstance(this, &spChannel);

		if(SUCCEEDED(hr))
		{
				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);

				// Fire the notification
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

				// If app sharing is arleady active, send the notification
			CConfRoom* pcr = GetConfRoom();

			if(pcr && pcr->FCanShare())
			{
				AppSharingStateChanged(true);
			}
		}
	}

	return hr;
}

void CNmConferenceObj::_FreeInternalStuff()
{

	if(m_dwInternalINmConferenceAdvise)
	{
		AtlUnadvise(m_spInternalINmConference, IID_INmConferenceNotify2, m_dwInternalINmConferenceAdvise);
		m_dwInternalINmConferenceAdvise = 0;
	}

	m_spInternalINmConference = NULL;

	while(m_SDKChannelObjs.GetSize())
	{
		CComPtr<INmChannel> spChannel = m_SDKChannelObjs[0];
		m_SDKChannelObjs[0]->Release();
		m_SDKChannelObjs.RemoveAt(0);

		CComPtr<IInternalChannelObj> spChanObj = com_cast<IInternalChannelObj>(spChannel);
		ASSERT(spChanObj);

		spChanObj->Activate(FALSE);
		Fire_ChannelChanged(NM_CHANNEL_UPDATED, spChannel);

		com_cast<IInternalChannelObj>(spChannel)->ChannelRemoved();
	}

		// Free our Member objects
	while(m_SDKMemberObjs.GetSize())
	{
		INmMember* pMember = m_SDKMemberObjs[0];
		
		m_SDKMemberObjs.RemoveAt(0);

		Fire_MemberChanged(NM_MEMBER_REMOVED, pMember);

		pMember->Release();
	}

	m_SDKMemberObjs.RemoveAll();

	if(m_pManagerObj)
	{
		m_pManagerObj->RemoveConference(com_cast<INmConference>(GetUnknown()));
	}
}

bool CNmConferenceObj::_IsGuidInDataChannelList(GUID& rg)
{
	return -1 != m_DataChannelGUIDList.Find(rg);
}

void CNmConferenceObj::_EnsureMemberHasAVChannelsIfNeeded(INmMember* pSDKMember)
{
	ULONG ulCaps = 0;
	BOOL bIsSelf = (S_OK == pSDKMember->IsSelf());
	if(bIsSelf || SUCCEEDED(pSDKMember->GetNmchCaps(&ulCaps)))
	{
		if(bIsSelf || (NMCH_AUDIO & ulCaps))
		{
			_EnsureMemberHasAVChannel(NMCH_AUDIO, pSDKMember);
		}

		if(bIsSelf || (NMCH_VIDEO & ulCaps))
		{
			_EnsureMemberHasAVChannel(NMCH_VIDEO, pSDKMember);
		}
	}
}

void CNmConferenceObj::_EnsureMemberHasAVChannel(ULONG ulch, INmMember* pSDKMember)
{
	INmChannel* pChannel = NULL;

		// First we have to check to see if the user has this channel
	for(int i = 0; i < m_SDKChannelObjs.GetSize(); ++i)
	{
		ULONG ulchChannel;
		if(SUCCEEDED(m_SDKChannelObjs[i]->GetNmch(&ulchChannel)))
		{
			if(ulch == ulchChannel)
			{
				INmMember *pChannelMember = NULL;
				CComPtr<IEnumNmMember> spEnum;
				if(SUCCEEDED(m_SDKChannelObjs[i]->EnumMember(&spEnum)))
				{
					ULONG cFetched = 0;
					if(S_OK == spEnum->Next(1, &pChannelMember, &cFetched))
					{
						if(CComPtr<INmMember>(pSDKMember).IsEqualObject(pChannelMember))
						{
								// This means that we already have this member in a channel
							pChannelMember->Release();
							return;
						}

						pChannelMember->Release();
					}
				}
			}
		}
	}

	CComPtr<INmChannel> spChannel;
	
		// Now we have to add the channel
	if(NMCH_AUDIO == ulch)
	{
		if(m_pManagerObj && m_pManagerObj->AudioNotifications())
		{
			CNmChannelAudioObj::CreateInstance(this, &spChannel, S_FALSE == pSDKMember->IsSelf());

				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

				// Add the member to the channel
			com_cast<IInternalChannelObj>(spChannel)->SDKMemberAdded(pSDKMember);
			
			spChannel = NULL;
		}
	}

	if(NMCH_VIDEO == ulch)
	{
		if(m_pManagerObj && m_pManagerObj->VideoNotifications())
		{
			CNmChannelVideoObj::CreateInstance(this, &spChannel, S_FALSE == pSDKMember->IsSelf());

				// Add the channel to our list
			spChannel.p->AddRef();
			m_SDKChannelObjs.Add(spChannel.p);
			Fire_ChannelChanged(NM_CHANNEL_ADDED, spChannel);

				// Add the member to the channel
			com_cast<IInternalChannelObj>(spChannel)->SDKMemberAdded(pSDKMember);

		}
	}

		// We activate the video channels if the m_bXXXVideoActive flags are set
	if(spChannel && (NMCH_VIDEO == ulch))
	{
		if(S_OK == pSDKMember->IsSelf())
		{
			if(m_bLocalVideoActive)
			{
					// Add the member to the channel
				com_cast<IInternalChannelObj>(spChannel)->Activate(true);
				Fire_ChannelChanged(NM_CHANNEL_UPDATED, spChannel);
			}
		}
		else
		{
			if(m_bRemoteVideoActive)
			{
					// Add the member to the channel
				com_cast<IInternalChannelObj>(spChannel)->Activate(true);
				Fire_ChannelChanged(NM_CHANNEL_UPDATED, spChannel);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmft.h ===
#ifndef __NmFt_h__
#define __NmFt_h__

class CNmChannelFtObj;

class ATL_NO_VTABLE CNmFtObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public INmFt,
	public IInternalFtObj

{
protected:
	CNmChannelFtObj*	m_pChannelFtObj;
	MBFTEVENTHANDLE		m_hFileEvent;
	MBFTFILEHANDLE		m_hFile;
	bool				m_bIncoming;
	CComBSTR			m_strFileName;
	DWORD				m_dwSizeInBytes;
	CComPtr<INmMember>	m_spSDKMember;
	NM_FT_STATE			m_State;
	DWORD				m_dwBytesTransferred;
	bool				m_bSomeoneCanceled;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmFtObj)

BEGIN_COM_MAP(CNmFtObj)
	COM_INTERFACE_ENTRY(INmFt)
	COM_INTERFACE_ENTRY(IInternalFtObj)
END_COM_MAP()

////////////////////////////////////////////////	
// Construction and destruction

	static HRESULT CreateInstance(
		CNmChannelFtObj* pChannelObj, 
		MBFTEVENTHANDLE hFileEvent,
		MBFTFILEHANDLE hFile,
		bool bIncoming,
		LPCTSTR szFileName,
		DWORD dwSizeInBytes,
		INmMember* pSDKMember,
		INmFt** ppNmFt);

////////////////////////////////////////////////
// INmFt interface

	STDMETHOD(IsIncoming)(void);
	STDMETHOD(GetState)(NM_FT_STATE *puState);
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetSize)(ULONG *puBytes);
	STDMETHOD(GetBytesTransferred)(ULONG *puBytes);
	STDMETHOD(GetMember)(INmMember **ppMember);
	STDMETHOD(Cancel)(void);


////////////////////////////////////////////////
// IInternalFtObj interface

	STDMETHOD(GetHEvent)(UINT *phEvent);
	STDMETHOD(OnFileProgress)(UINT hFile, ULONG lFileSize, ULONG lBytesTransmitted);
	STDMETHOD(FileTransferDone)();
	STDMETHOD(OnError)();

};


#endif // __NmFt_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmft.cpp ===
#include "precomp.h"

#include "NmChannel.h"
#include "NmChannelFt.h"
#include "NmFt.h"


//static 
HRESULT CNmFtObj::CreateInstance(
		CNmChannelFtObj* pChannelObj, 
		MBFTEVENTHANDLE hFileEvent,
		MBFTFILEHANDLE hFile,
		bool bIncoming,
		LPCTSTR szFileName,
		DWORD dwSizeInBytes,
		INmMember* pSDKMember,
		INmFt** ppNmFt)
{	
	DBGENTRY(CNmFtObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmFtObj>* p = NULL;
	p = new CComObject<CNmFtObj>(NULL);
	if(p)
	{
		p->SetVoid(NULL);
		if(hr == S_OK)
		{
			hr = p->QueryInterface(IID_INmFt, reinterpret_cast<void**>(ppNmFt));
			if(SUCCEEDED(hr))
			{
				p->m_pChannelFtObj		= pChannelObj;
				p->m_hFileEvent			= hFileEvent;
				p->m_hFile				= hFile;
				p->m_bIncoming			= bIncoming;
				p->m_strFileName		= szFileName;
				p->m_dwSizeInBytes		= dwSizeInBytes;
				p->m_spSDKMember		= pSDKMember;
				p->m_State				= bIncoming ? NM_FT_RECEIVING : NM_FT_SENDING;
				p->m_dwBytesTransferred = 0;
				p->m_bSomeoneCanceled	= false;
			}
		}

		if(FAILED(hr))		
		{
			delete p;
			*ppNmFt = NULL;
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}	

	DBGEXIT_HR(CNmFtObj::CreateInstance,hr);
	return hr;
}


////////////////////////////////////////////////
// INmFt interface

STDMETHODIMP CNmFtObj::IsIncoming(void)
{
	DBGENTRY(CNmFtObj::IsIncoming);

	HRESULT hr = m_bIncoming ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmFtObj::IsIncoming,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetState(NM_FT_STATE *puState)
{
	DBGENTRY(CNmFtObj::GetState);
	HRESULT hr = S_OK;
	
	*puState = m_State;

	DBGEXIT_HR(CNmFtObj::GetState,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmFtObj::GetName);
	HRESULT hr = S_OK;

	*pbstrName = m_strFileName.Copy();

	DBGEXIT_HR(CNmFtObj::GetName,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetSize(ULONG *puBytes)
{
	DBGENTRY(CNmFtObj::GetSize);
	HRESULT hr = S_OK;

	*puBytes = m_dwSizeInBytes;

	DBGEXIT_HR(CNmFtObj::GetSize,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetBytesTransferred(ULONG *puBytes)
{
	DBGENTRY(CNmFtObj::GetBytesTransferred);
	HRESULT hr = S_OK;

	*puBytes = m_dwBytesTransferred;

	DBGEXIT_HR(CNmFtObj::GetBytesTransferred,hr);
	return hr;
}

STDMETHODIMP CNmFtObj::GetMember(INmMember **ppMember)
{
	DBGENTRY(CNmFtObj::GetMember);
	HRESULT hr = S_OK;

	*ppMember = m_spSDKMember;

	if(*ppMember)
	{
		(*ppMember)->AddRef();
	}

	DBGEXIT_HR(CNmFtObj::GetMember,hr);
	return hr;
}
	

STDMETHODIMP CNmFtObj::Cancel(void)
{
	if((NM_FT_INVALID == m_State) || (NM_FT_COMPLETE == m_State))
	{
		return E_FAIL;
	}

	return CFt::CancelFt(m_hFileEvent, m_hFile);
}


////////////////////////////////////////////////
// IInternalFtObj interface

STDMETHODIMP CNmFtObj::GetHEvent(UINT *phEvent)
{
	ASSERT(phEvent);

	*phEvent = m_hFileEvent;

	return S_OK;
}

STDMETHODIMP CNmFtObj::OnFileProgress(UINT hFile, ULONG lFileSize, ULONG lBytesTransmitted)
{
	m_hFile = hFile;
	m_dwBytesTransferred = lBytesTransmitted;

	return S_OK;
}

STDMETHODIMP CNmFtObj::FileTransferDone()
{
	m_dwBytesTransferred = m_dwSizeInBytes;
	m_State = NM_FT_COMPLETE;

		// Return S_FALSE if someone canceled
	return m_bSomeoneCanceled ? S_FALSE : S_OK;
}

STDMETHODIMP CNmFtObj::OnError()
{
	m_bSomeoneCanceled = true;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmenum.h ===
#ifndef __NmEnum_h__
#define __NmEnum_h__

// This is used to create IEnumXXX objects for CSimpleArray<CComPtr<XXX> > objects
template <class TEnum, class TItf>
HRESULT CreateEnumFromSimpleAryOfInterface(CSimpleArray<TItf*>& rObjArray, TEnum** ppEnum)
{

	DBGENTRY(CreateEnum);

	HRESULT hr = S_OK;
	typedef CComEnum<TEnum, &__uuidof(TEnum), TItf*, _CopyInterface<TItf> > enum_type;
	
	enum_type* pComEnum = new CComObject< enum_type >;	

	if(pComEnum)
	{
		TItf** apInterface = NULL;

		int nItems = rObjArray.GetSize();
		if(nItems)
		{ 
			apInterface = new TItf*[nItems];

			if(apInterface)
			{
				for(int i = 0; i < rObjArray.GetSize(); ++i)
				{
					hr = rObjArray[i]->QueryInterface(__uuidof(TItf), reinterpret_cast<void**>(&apInterface[i]));
					if(FAILED(hr))
					{
						delete [] apInterface;
						goto end;
					}
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}

		TItf** begin = apInterface;
		TItf** end = apInterface + nItems;

		if(begin == end)
		{
			// Hack to get around ATL bug.
			// The problem is that for empty enums ATL returns E_FAIL for Next instead of S_FALSE
			hr = pComEnum->Init(reinterpret_cast<TItf**>(69), reinterpret_cast<TItf**>(69), NULL, AtlFlagNoCopy);
		}
		else
		{
			hr = pComEnum->Init(begin, end, NULL, AtlFlagTakeOwnership);
		}

		if(SUCCEEDED(hr))
		{
			hr = pComEnum->QueryInterface(__uuidof(TEnum), reinterpret_cast<void**>(ppEnum));
		}
	}
	else
	{
		hr = E_NOINTERFACE;
	}
	
	end:
	
	DBGEXIT_HR(CreateEnum,hr);
	return hr;
}

#endif // __NmEnum_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmldap.cpp ===
#include "precomp.h"
#include "resource.h"
#include "pfnwldap.h"
#include "conf.h"
#include "cr.h"
#include <cstring.hpp>
#include <ulsreg.h>
#include "NmLdap.h"
#include "version.h"
#include "call.h"
#include "confapi.h"
#include "confutil.h"
#include "dirutil.h"

// One global instance
CNmLDAP* g_pLDAP = NULL;
CPing*	 g_pPing = NULL;


// This flag indicates weather or not we have loaded the LDAP dll ( WLDAP::Init() )
/*static*/ bool CNmLDAP::ms_bLdapDLLLoaded = false;

////////////////////////////////////////////////////////////////////////////////////////
// Helper Macros

// the ldap_modify function takes an LDAPMod** type
// If it took an array of LDAPMod ( an LDAPMod* type )
// Then life would be easier for us to make static lists
// Unfortunately, this is not how it works, so we have macros
// to pretty things up ( and hopefully not to confuse anyone )

// This is to declare an LDAPMod with one val
#define DECLARE_LDAP_MOD( t, x, y )\
	LPTSTR aVals_##x[] = { y, NULL };\
	LDAPMod LDAPMod_##x = { t, _T(#x), aVals_##x }

// This is to declare an LDAPMod with 2 vals
#define DECLARE_LDAP_MOD2( t, x, y1, y2 )\
	LPTSTR aVals_##x[] = { y1, y2, NULL };\
	LDAPMod LDAPMod_##x = { t, _T(#x), aVals_##x }

#define LDAP_MOD_ENTRY( x ) &LDAPMod_##x
#define LDAP_MOD_ADD_ENTRY( x ) &LDAPMod_add_##x

////////////////////////////////////////////////////////////////////////////////////////
// Some helpful deffinitions

#define LDAP_REFRESH_BASE_DN		_T("objectClass=RTPerson")
#define RESOLVE_USER_SEARCH_FILTER	_T("(&(objectClass=RTPerson)(cn=%s))")


//NOTE: The LDAP_REFRESH_FILTER... notice the sttl=10... aparently, this is how you request the
// server to restart the TTL countdown... the sttl= value can be anything BUT '*' ( the value you would
// expecte it to be... ) This is a link to the "Dynamir Ldap Extension RFC" if you want more info
// http://www.critical-angle.com/ldapworld/draft-ietf-asid-ldapv3ext-04.txt

#define LDAP_REFRESH_FILTER			_T("(&(objectClass=RTPerson)(cn=%s)(sttl=10))")


#define LOGIN_USER_FILTER			_T("c=-,o=Microsoft,cn=%s,objectClass=RTPerson")
#define IP_ADDRESS_ATTR_NAME		_T("sipaddress")
#define STTL_ATTR_NAME				_T("sttl")
#define CNmLDAP_WCNAME				_T("CNmLDAP_WCNAME")

#define LDAP_MODOP_ADDAPP			_T("0")
#define LDAP_MODOP_DELETEAPP		_T("1")
#define LDAP_MODOP_MODIFYUSER		_T("2")
#define LDAP_MODOP_MODIFYAPP		_T("3")

#define LDAP_ATTR_FALSE				_T("0")
#define LDAP_ATTR_TRUE				_T("1")
#define LDAP_ATTR_BUSINESS			_T("2")

	// We are not using the country name anymore, but we can't leave the country
	// field blank ( empty string ), it is just the way that SiteServer is written...
#define LDAP_ATTR_DUMMY_COUNTRYNAME	_T("-")

#define INVALID_MSG_ID				((ULONG) -1)	// same as ldap_****()
#define LDAP_RESULT_ERROR			((ULONG) -1)	
#define LDAP_RESULT_TIMEOUT         0

	// When the bind helper thread function gets the result to bind_s function
	// it passes it to this thread via PostMessage( m_hWndHidder, WM_USER_BIND_COMPLETE, ret, err )
#define WM_USER_BIND_COMPLETE		(WM_APP + 1) // wParam = Return code from bind_s, lParam = GetLastError()
#define WM_NEED_RELOGON             (WM_APP + 2)


CNmLDAP::CNmLDAP()
: m_State(Uninitialized),
  m_pKeepAlive(NULL),
  m_hWndHidden(NULL),
  m_pLdap(NULL),
  m_ResultPollTimer(0),
  m_LogoffTimer(0),
  m_uMsgID(INVALID_MSG_ID),
  m_CurrentOp(Op_NoOp),
  m_bVisible(true),
  m_bDirty(false),
  m_bRefreshAfterBindCompletes(false),
  m_bLogoffAfterBindCompletes(false),
  m_bSendInCallAttrWhenDone(false),
  m_bInCall(false),
  m_hEventWaitForLogoffDone(NULL),
  m_hBindThread(NULL),
  m_iPort(DEFAULT_LDAP_PORT),
  m_bAudioHardware(false),
  m_bVideoHardware(false)


{
	DBGENTRY(CNmLDAP::CNmLDAP);

	SetLoggedOn( false );

	DBGEXIT(CNmLDAP::CNmLDAP);
}

CNmLDAP::~CNmLDAP()
{
	DBGENTRY(CNmLDAP::~CNmLDAP);

    if (NULL != m_pKeepAlive)
    {
        m_pKeepAlive->End(TRUE); // synchronous end
        m_pKeepAlive = NULL;
    }

	if((m_State != Idle) && (m_State != Uninitialized))
	{
			// Make sure that someone at least has already called Logoff()
		ASSERT((LoggingOff == m_State) || (Op_Logoff == m_CurrentOp));

			// We are logging off, but we would like to wait a while to make sure that
			// all of our async operations are completed... We don't want to wait too long,
			// Though... Basically we set a timer to pass a message to us... if we get that
			// message, we signal m_hEventWaitForLogoffDone....  if any of the async operations
			// complete during this time, they will also signal this event....We make sure to
			// hawe a message loop ( AtlWaitWithWessageLoop ) so that our wndproc will be called
		m_hEventWaitForLogoffDone = CreateEvent(NULL,TRUE,FALSE,NULL);

		if(m_hEventWaitForLogoffDone)
		{
			m_LogoffTimer = ::SetTimer(m_hWndHidden, WaitForLogoffTimer, LOGOFF_WAIT_INTERVAL, NULL);
			if(m_LogoffTimer)
			{
				AtlWaitWithMessageLoop(m_hEventWaitForLogoffDone);
			}

			CloseHandle(m_hEventWaitForLogoffDone);
			m_hEventWaitForLogoffDone = NULL;
		}
		else
		{
			ERROR_OUT(("Create Event failed"));
		}

		if( Binding == m_State )
		{
			WARNING_OUT(("Aborting an ldap_bind because we are closing down in ~CNmLDAP"));
			TerminateThread(m_hBindThread, 0);				
			CloseHandle(m_hBindThread);
		}
		else if(Idle != m_State)
		{
			WARNING_OUT(("Aborting pending LDAP operation in ~CNmLDAP"));
			_AbandonAllAndSetToIdle();
		}
	}

	if( NULL != m_hWndHidden )
	{
		DestroyWindow( m_hWndHidden );
		m_hWndHidden = NULL;
	}

	m_State = Uninitialized;

	SetLoggedOn( false );

	DBGEXIT(CNmLDAP::~CNmLDAP);
}

HRESULT CNmLDAP::_bCallChangedHelper()
{
TRACE_OUT(("CNmLDAP::_bCallChangedHelper:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	if( IsLoggedOn() || IsBusy() )
	{
		if(LoggedIn == m_State)
		{	
				// We simply have to bind and call ldap_modify
			m_CurrentOp = Op_Modifying_InCallAttr;
			hr = _BindAsync();
		}
		else if((SettingAppInfo == m_State) ||
				(ModifyingAttrs == m_State) ||
				(AddingUser == m_State)
			   )
		{
			// the other states will be calling ldap_mod( user Attributes ) which will pick up
			// the change to m_bInCall. The states listed above are the ones that occur after
			// the user attributes have been sent to the server... There are  also other states
			// that logoff, so they don't care about sending the update to the user attribute to the server
			m_bSendInCallAttrWhenDone = true;
		}
	}

TRACE_OUT(("CNmLDAP::_bCallChangedHelper:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	return hr;
}

HRESULT CNmLDAP::OnCallStarted()
{

	DBGENTRY(CNmLDAP::OnCallStarted);
TRACE_OUT(("CNmLDAP::OnCallStarted:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( !m_bInCall )
	{
		m_bInCall = true;
		hr = _bCallChangedHelper();
	}

TRACE_OUT(("CNmLDAP::OnCallStarted:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::OnCallStarted,hr);
	return hr;
}

HRESULT CNmLDAP::OnCallEnded()
{
	DBGENTRY(CNmLDAP::OnCallEnded);
TRACE_OUT(("CNmLDAP::OnCallEnded:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( m_bInCall )
	{
		m_bInCall = false;
		hr = _bCallChangedHelper();
	}

TRACE_OUT(("CNmLDAP::OnCallEnded:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::OnCallEnded,hr);
	return hr;
}


bool CNmLDAP::IsLoggedOn() const
{
	DBGENTRY(CNmLDAP::IsLoggedOn);
TRACE_OUT(("CNmLDAP::IsLoggedOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	
	bool bRet =   ( ( LoggedIn == m_State )					||
					( ModifyingAttrs == m_State )			||
					( Op_Refresh_Logoff == m_CurrentOp )	||
					( Op_Modifying_InCallAttr == m_CurrentOp )
				  );

TRACE_OUT(("CNmLDAP::IsLoggedOn:exit(%d):   m_State:%d:   m_currentOp:%d", bRet, m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::IsLoggedOn);

	return bRet;
}

bool CNmLDAP::IsLoggingOn() const
{
	DBGENTRY(CNmLDAP::IsLoggingOn);
TRACE_OUT(("CNmLDAP::IsLoggingOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	bool bRet = ( ( AddingUser == m_State )		||
				  ( UserAdded == m_State )		||
				  ( SettingAppInfo == m_State ) ||
				  ( Op_Logon == m_CurrentOp )
				);

TRACE_OUT(("CNmLDAP::IsLoggingOn:exit(%d):   m_State:%d:   m_currentOp:%d", bRet, m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::IsLoggingOn);

	return bRet;
}

bool CNmLDAP::IsBusy() const
{
	DBGENTRY(CNmLDAP::IsBusy);
TRACE_OUT(("CNmLDAP::IsBusy:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	
	bool bRet = !((LoggedIn == m_State) || ( Idle == m_State ) || (Uninitialized == m_State));

TRACE_OUT(("CNmLDAP::IsBusy:exit(%d):   m_State:%d:   m_currentOp:%d", bRet, m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::IsBusy);

	return bRet;
}


void CNmLDAP::_MakeStatusText(UINT uResID, LPTSTR psz, UINT cch) const
{
	const TCHAR * const	server = CDirectoryManager::get_displayName( m_strCurrentServer );

	LPCTSTR pszFmt = RES2T(uResID);
	LPTSTR pszStr = reinterpret_cast<LPTSTR>(_alloca(lstrlen(pszFmt) + lstrlen(server) - 1));
	if(pszStr)
	{
		wsprintf(pszStr, pszFmt, server);
		lstrcpyn(psz, pszStr, cch);
	}
}


HRESULT CNmLDAP::GetStatusText(LPTSTR psz, int cch, UINT *idIcon ) const
{
	DBGENTRY(CNmLDAP::GetStatusText);

	UINT idDummy;
	if (NULL == idIcon)
	{
		// Just so we don't need to do switches all over the place
		idIcon = &idDummy;
	}

	HRESULT hr = S_OK;

	TRACE_OUT(("m_State = %d", m_State));
TRACE_OUT(("CNmLDAP::GetStatusText:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	if(psz)
	{
		if( cch > 1 )
		{
			switch(m_State)
			{
				case LoggedIn:
				case ModifyingAttrs:
					*idIcon = IDI_NET;
					_MakeStatusText(ID_STATUS_LOGGEDON_FORMAT, psz, cch);
					break;

				case Binding:
				{
					switch(m_CurrentOp)
					{
						case Op_Logon:
							*idIcon = IDS_STATUS_WAITING;
							_MakeStatusText(ID_STATUS_LOGON_FORMAT, psz, cch);
							break;

						case Op_Modifying_InCallAttr:
							*idIcon = IDI_NET;
							_MakeStatusText(ID_STATUS_LOGGEDON_FORMAT, psz, cch);
							break;
							
						case Op_Refresh_Logoff:
							if( lstrcmpi(m_strServer,m_strCurrentServer))
							{
								*idIcon = IDS_STATUS_WAITING;
								_MakeStatusText(ID_STATUS_LOGOFF_FORMAT, psz, cch);
							}
							else
							{
								*idIcon = IDI_NET;
								_MakeStatusText(ID_STATUS_LOGGEDON_FORMAT, psz, cch);
							}
							break;

						case Op_Logoff:
							*idIcon = IDI_NETGRAY;
							lstrcpyn(psz, RES2T(ID_STATUS_LOGGEDOFF), cch);
							break;
					}
					break;
				}

				case AddingUser:
				case UserAdded:
				case SettingAppInfo:
					*idIcon = IDS_STATUS_WAITING;
					_MakeStatusText(ID_STATUS_LOGON_FORMAT, psz, cch);
					break;


				case LoggingOff:
					*idIcon = IDS_STATUS_WAITING;
					_MakeStatusText(ID_STATUS_LOGOFF_FORMAT, psz, cch);
					break;
				
				case Bound:					
				case Idle:
				case Uninitialized:
					*idIcon = IDI_NETGRAY;
					lstrcpyn(psz, RES2T(ID_STATUS_LOGGEDOFF), cch);
					break;

				default:
					ERROR_OUT(("Not a regognized state: %d", m_State));
					break;
			}

		}
		else
		{
			hr = E_INVALIDARG;
		}
	}
	else
	{
		hr = E_POINTER;
	}



TRACE_OUT(("CNmLDAP::GetStatusText:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::GetStatusText,hr);
	return hr;
}

HRESULT CNmLDAP::OnSettingsChanged()
{
	DBGENTRY(CNmLDAP::OnSettingsChanged);
TRACE_OUT(("CNmLDAP::OnSettingsChanged:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;
	ASSERT(ms_bLdapDLLLoaded);

	if(S_OK == _GetUserSettingsFromRegistryAndGlobals())
	{
        hr = OnReLogon();
	}

TRACE_OUT(("CNmLDAP::OnSettingsChanged:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::OnSettingsChanged,hr);
	return hr;
}

HRESULT CNmLDAP::OnReLogon(void)
{
    HRESULT hr = S_OK;
    ASSERT(ms_bLdapDLLLoaded);

	m_bDirty = true;

	if(IsLoggedOn() || IsBusy())
	{
		hr = _RefreshServer();
	}

    return hr;
}

HRESULT CNmLDAP::_RefreshServer()
{
	DBGENTRY(CNmLDAP::_RefreshServer);
TRACE_OUT(("CNmLDAP::_RefreshServer:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( m_bDirty )
	{
		if(Binding == m_State)
		{
			if(Op_Logon == m_CurrentOp) // we are logging on and haven't sent any user information yet
			{	
				// Check to see if we have not changed the server name
				if( !lstrcmpi(m_strServer, CDirectoryManager::get_defaultServer() ) )
				{
						// Simply update the user settings
					_GetUserSettingsFromRegistryAndGlobals();
				}
				else
				{	
						// Since the server has changed, we have to do a logoff(from old)/logon(to new)
					_InternalLogoff(true);
				}
			}
			else if(m_CurrentOp != Op_Logoff)
			{
					// If we are in the middle of a bind operation, which happens
					// in another thread, we just have to wait for it to complete
					// before we go any further
				m_bRefreshAfterBindCompletes = true;
			}
		}
		else if(Idle == m_State)
		{
			_GetUserSettingsFromRegistryAndGlobals();
			LogonAsync();
		}
		else
		{
			_InternalLogoff(true);
		}
	}

TRACE_OUT(("CNmLDAP::_RefreshServer:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_RefreshServer,hr);
	return hr;
}

void CNmLDAP::_AbandonAllAndSetState(eState new_state)
{
TRACE_OUT(("CNmLDAP::_AbandonAllAndSetState:enter:   new_state=%d,  m_State:%d:   m_currentOp:%d", new_state, m_State, m_CurrentOp));
	if(m_ResultPollTimer)
	{
		::KillTimer(m_hWndHidden,m_ResultPollTimer);
		m_ResultPollTimer = 0;
	}

	if(m_pLdap)
	{		
		if( INVALID_MSG_ID != m_uMsgID )
		{
			WLDAP::ldap_abandon(m_pLdap, m_uMsgID);			
		}
	
		WLDAP::ldap_unbind(m_pLdap);
	}
	m_pLdap = NULL;
	m_uMsgID = INVALID_MSG_ID;
	m_State = new_state;
	m_CurrentOp	= Op_NoOp;

	SetLoggedOn( IsLoggedOn() );
TRACE_OUT(("CNmLDAP::_AbandonAllAndSetState:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
}


HRESULT CNmLDAP::_InternalLogoff(bool bRefreshLogoff)
{
	DBGENTRY(CNmLDAP::_InternalLogoff);
TRACE_OUT(("CNmLDAP::_InternalLogoff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_OK;

	ASSERT(ms_bLdapDLLLoaded);

	if( ( LoggingOff != m_State ) && ( Idle != m_State ) )
	{
		if(bRefreshLogoff)
		{
			m_CurrentOp = Op_Refresh_Logoff;

				// If the server names are different, this means
				// that we should display "logging off" XXX
			if( lstrcmpi(m_strServer, m_strCurrentServer) )
			{
				_OnLoggingOff();
			}
		}
		else
		{	
			_OnLoggingOff();
			m_CurrentOp = Op_Logoff;
		}

		if( LoggedIn == m_State )
		{
			hr = _BindAsync();
		}
		else if( Binding == m_State )
		{
			m_bLogoffAfterBindCompletes = true;
		}
		else if( (INVALID_MSG_ID != m_uMsgID ) && (NULL != m_pLdap ))
		{
				// Kill the timer
			ASSERT(m_ResultPollTimer);	
			::KillTimer(m_hWndHidden,m_ResultPollTimer);
			m_ResultPollTimer = 0;
			
				// Abandon the current op
			WLDAP::ldap_abandon(m_pLdap, m_uMsgID);		
			m_uMsgID = INVALID_MSG_ID;
			m_State = Bound;

			SetLoggedOn( IsLoggedOn() );
		}

		if(Bound == m_State)
		{
			ASSERT(m_pLdap);
			_DeleteUser();
		}

	}

TRACE_OUT(("CNmLDAP::_InternalLogoff:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_InternalLogoff,hr);
	return hr;
}
HRESULT CNmLDAP::Logoff()
{
	DBGENTRY(CNmLDAP::Logoff);
TRACE_OUT(("CNmLDAP::Logoff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	HRESULT hr = _InternalLogoff(false);

TRACE_OUT(("CNmLDAP::Logoff:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::Logoff,hr);

	return hr;
}

HRESULT CNmLDAP::Initialize( HINSTANCE hInst )
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmLDAP::Initialize);
TRACE_OUT(("CNmLDAP::Initialize:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	ASSERT( Uninitialized == m_State );

	if( ms_bLdapDLLLoaded || SUCCEEDED( hr = WLDAP::Init()))
	{
		ms_bLdapDLLLoaded = true;
		
////////////////////////////////////////
// Initialize user data
		_GetUserSettingsFromRegistryAndGlobals();

////////////////////////////////////////
// Initialize hidden Window


		WNDCLASS wcHidden =
		{
			0L,
			_sWndProc,
			0,
			0,
			hInst,
			NULL,
			NULL,
			NULL,
			NULL,
			CNmLDAP_WCNAME
		};
		
		if(RegisterClass(&wcHidden))
		{
			m_hWndHidden = ::CreateWindow( CNmLDAP_WCNAME, g_szEmpty, 0, 0, 0, 0, 0, NULL, NULL, hInst, this);

			if( m_hWndHidden )
			{
				m_State = Idle;
				SetLoggedOn( IsLoggedOn() );
			}
			else
			{
				hr = HRESULT_FROM_WIN32(GetLastError());	
			}
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		ERROR_OUT(("WLDAP::Init failed ( could not load wldap32.dll? )"));
	}

TRACE_OUT(("CNmLDAP::Initialize:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::Initialize,hr);

	return hr;	
}

HRESULT CNmLDAP::_GetUserSettingsFromRegistryAndGlobals()
{
	DBGENTRY(CNmLDAP::_GetUserSettingsFromRegistryAndGlobals);
TRACE_OUT(("CNmLDAP::_GetUserSettingsFromRegistryAndGlobals:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	HRESULT hr = S_FALSE;	// this would indicate that nothing changed

	RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);

	if(lstrcmpi(m_strSurName, reULS.GetString(ULS_REGKEY_LAST_NAME)))
	{
		hr = S_OK;
		m_strSurName = reULS.GetString(ULS_REGKEY_LAST_NAME);
	}

	if(lstrcmpi(m_strGivenName, reULS.GetString(ULS_REGKEY_FIRST_NAME)))
	{
		hr = S_OK;
		m_strGivenName = reULS.GetString(ULS_REGKEY_FIRST_NAME);
	}

	if(lstrcmpi(m_strEmailName, reULS.GetString(REGVAL_ULS_EMAIL_NAME)))
	{
		hr = S_OK;
		m_strEmailName = reULS.GetString(REGVAL_ULS_EMAIL_NAME);
	}

	if(lstrcmpi(m_strComment, reULS.GetString(ULS_REGKEY_COMMENTS)))
	{
		hr = S_OK;
		m_strComment = reULS.GetString(ULS_REGKEY_COMMENTS);
	}

	if(lstrcmpi(m_strLocation, reULS.GetString(ULS_REGKEY_LOCATION)))
	{
		hr = S_OK;
		m_strLocation = reULS.GetString(ULS_REGKEY_LOCATION);
	}

	if(lstrcmpi(m_strSecurityToken, reULS.GetString(ULS_REGKEY_CLIENT_ID)))
	{
		hr = S_OK;
		m_strSecurityToken = reULS.GetString(ULS_REGKEY_CLIENT_ID);
	}


	if(*m_strSecurityToken == '\0')
	{	// The string was not found...

			// When we log onto the LDAP server, we pass a fairly unique ID
			// This is passed as the value to the ssecurity attribute
			// In the case that NetMeeting goes away without actually logging
			// off of the ILS server, when NetMeeting tries to log back on,
			// it will pass this unique ID... if the server has not closed the
			// session account for the user, the server uses this ID to "authenticate"
			// that we are the same user as the last session...
		TCHAR szNewClientID[MAX_PATH];
		wsprintf(szNewClientID,"%lu", ::GetTickCount());
		m_strSecurityToken = szNewClientID;
		reULS.SetValue(ULS_REGKEY_CLIENT_ID,szNewClientID);
		hr = S_OK;
	}

	if( lstrcmpi(m_strServer, CDirectoryManager::get_defaultServer()))
	{
		hr = S_OK;
		m_strServer = CDirectoryManager::get_defaultServer();
		m_iPort = DEFAULT_LDAP_PORT;
	}


	if(m_bVisible != (!reULS.GetNumber(ULS_REGKEY_DONT_PUBLISH, REGVAL_ULS_DONT_PUBLISH_DEFAULT)))
	{
		m_bVisible = !reULS.GetNumber(ULS_REGKEY_DONT_PUBLISH, REGVAL_ULS_DONT_PUBLISH_DEFAULT);
		hr = S_OK;
	}

	if(m_bAudioHardware != (0 != (g_uMediaCaps & CAPFLAG_SEND_AUDIO)))
	{
		m_bAudioHardware = (0 != (g_uMediaCaps & CAPFLAG_SEND_AUDIO));
		hr = S_OK;
	}

	if(m_bVideoHardware != (0 != (g_uMediaCaps & CAPFLAG_SEND_VIDEO)))
	{
		m_bVideoHardware = (0 != (g_uMediaCaps & CAPFLAG_SEND_VIDEO));
		hr = S_OK;
	}
	
TRACE_OUT(("CNmLDAP::_GetUserSettingsFromRegistryAndGlobals:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_GetUserSettingsFromRegistryAndGlobals,hr);
	return hr;
}


HRESULT CNmLDAP::LogonAsync( LPCTSTR pcszServer /*=NULL*/)
{
	HRESULT hr = S_OK;
	DBGENTRY(CNmLDAP::LogonAsync);
TRACE_OUT(("CNmLDAP::LogonAsync:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

//		Idle						// Normal logon
		//Binding					
//			Op_Logoff				// Change it to logon refresh
//		Bound						// ldap_umbind-> Logon normal
//		LoggingOff					// Change to Op_Refresh_Logoff
//		Uninitialized		// return error
//		AddingUser					// do nothing
//		UserAdded					// do nothing
//		SettingAppInfo				// do nothing
//		ModifyingAttrs				// do nothing
//		LoggedIn					// do nothing
//		Op_Refresh_Logoff		// Do nothing
//		Op_Modifying_InCallAttr	// Do Nothing
//		Op_Logon				// Do Nothing

	if( Uninitialized != m_State)
	{
		if(Bound == m_State)
		{
			_AbandonAllAndSetToIdle();
		}

		if(Idle == m_State)
		{
			if(pcszServer)
			{
				m_strServer = pcszServer;
				m_iPort = DEFAULT_LDAP_PORT;
			}
			else
			{
				if(!IsLoggedOn())
				{
					_GetUserSettingsFromRegistryAndGlobals();
				}
			}

			m_strCurrentServer = m_strServer;

			g_pCCallto->SetIlsServerName( m_strCurrentServer );

			TCHAR* szDN = new TCHAR[ lstrlen( LOGIN_USER_FILTER ) + lstrlen(m_strEmailName) + 1 ];
			if( szDN )
			{
				wsprintf(szDN, LOGIN_USER_FILTER, m_strEmailName);
				m_strCurrentDN = szDN;

				delete [] szDN;

				m_CurrentOp = Op_Logon;
				hr = _BindAsync();
				if( SUCCEEDED(hr) )
				{
					_OnLoggingOn();
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
			}
		}
		else if((Op_Logoff == m_CurrentOp) || (LoggingOff == m_State))
		{
				m_CurrentOp = Op_Refresh_Logoff;
		}
	}
	else
	{
		hr = E_FAIL;
	}

TRACE_OUT(("CNmLDAP::LogonAsync:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::LogonAsync,hr);
	return hr;
}

HRESULT CNmLDAP::_BindAsync()
{
	DBGENTRY(CNmLDAP::_BindAsync);
TRACE_OUT(("CNmLDAP::_BindAsync:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	ASSERT(( LoggedIn == m_State ) || ( Idle == m_State ));
	ASSERT( m_CurrentOp != Op_NoOp );
	ASSERT(m_hBindThread == NULL);

	HRESULT hr = S_OK;

		// Set our state to Binding
	m_State = Binding;
	SetLoggedOn( IsLoggedOn() );

		// Start the bind in another thread
	DWORD dwBindThreadID = 0;
	m_hBindThread = CreateThread(NULL, 0, _sAsyncBindThreadFn, this, 0, &dwBindThreadID);

	if(NULL == m_hBindThread)
	{
		ERROR_OUT(("CreateThread failed"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_CurrentOp = Op_NoOp;
		m_State = Idle;
	}

	SetLoggedOn( IsLoggedOn() );

TRACE_OUT(("CNmLDAP::_BindAsync:exit(0x%08X):   m_State:%d:   m_currentOp:%d", hr, m_State, m_CurrentOp));
	DBGEXIT_HR(CNmLDAP::_BindAsync,hr);
	return hr;
}


/*static*/
DWORD CNmLDAP::_sAsyncBindThreadFn(LPVOID lpParameter)
{

	DBGENTRY(CNmLDAP::_sAsyncBindThreadFn);

	ASSERT(lpParameter);

	CNmLDAP* pThis = reinterpret_cast<CNmLDAP*>(lpParameter);
	ASSERT(pThis);
	ULONG ulRet = LDAP_OPERATIONS_ERROR;
	ULONG ulErr = ERROR_INVALID_HANDLE;
	if( pThis )
	{		
		WSADATA	wsaData;

		if( WSAStartup( 0x0101, &wsaData ) == 0 )
		{
			if( wsaData.wVersion > 1 )
			{
				pThis->m_pLdap = WLDAP::ldap_init( const_cast<LPTSTR>((LPCTSTR)pThis->m_strCurrentServer), pThis->m_iPort );

				if( pThis->m_pLdap )
				{
					::SetLastError(NO_ERROR);
					ulRet = WLDAP::ldap_bind_s(pThis->m_pLdap, const_cast<LPTSTR>(g_szEmpty), const_cast<LPTSTR>(g_szEmpty), LDAP_AUTH_SIMPLE );

					if( ulRet == LDAP_SUCCESS )
					{
						ulErr = ::GetLastError();
						::SendMessage(pThis->m_hWndHidden, WM_USER_BIND_COMPLETE, ulRet, ulErr);
					}
					else if( pThis->m_iPort == DEFAULT_LDAP_PORT )
					{
						WLDAP::ldap_unbind( pThis->m_pLdap );
						pThis->m_pLdap = WLDAP::ldap_init( const_cast<LPTSTR>((LPCTSTR)pThis->m_strCurrentServer), ALTERNATE_LDAP_PORT);		//	Automatically retry with alternate port...

						if( pThis->m_pLdap != NULL )
						{
							::SetLastError(NO_ERROR);
							ulRet = WLDAP::ldap_bind_s(pThis->m_pLdap, const_cast<LPTSTR>(g_szEmpty), const_cast<LPTSTR>(g_szEmpty), LDAP_AUTH_SIMPLE );

							if( ulRet == LDAP_SUCCESS )
							{
								pThis->m_iPort = ALTERNATE_LDAP_PORT;
							}

							ulErr = ::GetLastError();
							::SendMessage(pThis->m_hWndHidden, WM_USER_BIND_COMPLETE, ulRet, ulErr);
						}		
						else
						{
							TRACE_OUT(("ldap_init failed"));
							pThis->m_State = Idle;
							pThis->m_CurrentOp = Op_NoOp;
						}
					}
				}
				else
				{
					TRACE_OUT(("ldap_init failed"));
					pThis->m_State = Idle;
					pThis->m_CurrentOp = Op_NoOp;
				}
			}

			WSACleanup();
		}
	}

	DBGEXIT(CNmLDAP::_sAsyncBindThreadFn);

	return ulRet;
}


LRESULT CNmLDAP::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lr = TRUE;
	DBGENTRY(CNmLDAP::WndProc);

	switch( uMsg )
	{
		case WM_USER_BIND_COMPLETE:		
			_OnUserBindComplete((INT)wParam, (DWORD)lParam);
			break;

		case WM_TIMER:
			lr = FALSE; // This means that we handle the message
			_OnTimer(wParam);
			break;

        case WM_NEED_RELOGON:
            OnReLogon();
            break;

		default:
			lr = DefWindowProc(hwnd, uMsg, wParam, lParam);
			break;
	}

	DBGEXIT_ULONG(CNmLDAP::WndProc,lr);
	return lr;
}


void CNmLDAP::_OnTimer(UINT_PTR TimerID)
{
	DBGENTRY(CNmLDAP::_OnTimer);
TRACE_OUT(("CNmLDAP::_OnTimer:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	// We check the timer ID values first because we may have killed the timer,
	// and the message couldv be simply vestigal ( that means left over from an earlier time)...

	if(m_LogoffTimer && (WaitForLogoffTimer == TimerID))
	{
			// We are waiting in the distructor for an async operation to complete
			// and we have waited too long... kill the timer and set the m_hEventWaitForLogoffDone event
		::KillTimer(m_hWndHidden, m_LogoffTimer);
		m_LogoffTimer = 0;

		if(m_hEventWaitForLogoffDone)
		{
			SetEvent(m_hEventWaitForLogoffDone);
		}
	}
	else if( (INVALID_MSG_ID != m_uMsgID) && m_ResultPollTimer && (PollForResultTimer == TimerID ))
	{
		ASSERT(m_pLdap);
		::KillTimer( m_hWndHidden, m_ResultPollTimer );
		m_ResultPollTimer = 0;

		LDAPMessage *pMsg = NULL;
		LDAP_TIMEVAL TimeoutVal = { 0, 0 };
		INT res = WLDAP::ldap_result( m_pLdap, m_uMsgID, LDAP_MSG_ALL, &TimeoutVal, &pMsg );
		
		if( 0 == res )
		{
			// ldap_result timedout
			m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );

			if( !m_ResultPollTimer )
			{
				ERROR_OUT(("SetTimer failed!"));
				_AbandonAllAndRecoverState();
			}
		}
		else if( LDAP_RESULT_ERROR == res )
		{
			ERROR_OUT(("ldap_result failed"));
            _AbandonAllAndRecoverState();
		}
		else
		{
				// We got the result, so reset this
			m_uMsgID = INVALID_MSG_ID;

			if( AddingUser == m_State )
			{
				_OnAddingUserResult(pMsg->lm_returncode);
				WLDAP::ldap_msgfree(pMsg);
			}
			else if( ( SettingAppInfo == m_State ) || ( ModifyingAttrs == m_State ) )
			{
				_OnSettingAppInfoOrModifyingAttrsResult(pMsg->lm_returncode);
				WLDAP::ldap_msgfree(pMsg);
			}
			else if( LoggingOff == m_State )
			{	
				_OnLoggingOffResult(pMsg->lm_returncode);
				WLDAP::ldap_msgfree(pMsg);
			}
		}
	}

TRACE_OUT(("CNmLDAP::_OnTimer:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnTimer);
}


void CNmLDAP::_OnUserBindComplete(INT LdapResult, DWORD LastError )
{
	DBGENTRY(CNmLDAP::_OnUserBindComplete);
TRACE_OUT(("CNmLDAP::_OnUserBindComplete:enter(%d):   m_State:%d:   m_currentOp:%d", LdapResult, m_State, m_CurrentOp));

	ASSERT(m_hBindThread);
	ASSERT(Binding == m_State);

	CloseHandle(m_hBindThread);
	m_hBindThread = NULL;

	if(LDAP_SUCCESS == LdapResult)
	{
		m_State = Bound;
		SetLoggedOn( IsLoggedOn() );

		if( m_bRefreshAfterBindCompletes )
		{
				// If a refresh is attempted while
				// the bind operation is in progress
				// we just wait for the bind to complete
				// then we well do the refresh
			m_bRefreshAfterBindCompletes = false;
			_RefreshServer();
		}
		else if( m_bLogoffAfterBindCompletes )
		{
			m_bLogoffAfterBindCompletes = false;
			_DeleteUser();
		}
		else
		{
			if( Op_Logon == m_CurrentOp )
			{
				m_CurrentOp = Op_NoOp;
				_AddUser();
			}
			else if( Op_Logoff == m_CurrentOp )
			{
				m_CurrentOp = Op_NoOp;
				_DeleteUser();
			}
			else if( Op_Refresh_Logoff == m_CurrentOp )
			{	
				_DeleteUser();
			}
			else if( Op_Modifying_InCallAttr == m_CurrentOp )
			{
				m_CurrentOp = Op_NoOp;
				_ModifyInCallAttr();
			}
		}
	}
	else
	{
		eCurrentOp OldOp = m_CurrentOp;
	    _AbandonAllAndRecoverState(OldOp);
		
		if( ( Op_Refresh_Logoff == OldOp ) && ( lstrcmpi( m_strCurrentServer, m_strServer ) ) )
		{
			// If the server names have changed...
			// Suppose that the server you are logged on to
			// goes down and then you change the server that you want
			// to be logged on to ( before you have any indication that
			// the server has gone down... You want to log off the old server
			// But the server is not available... We are basically going to
			// ignore the fact that there was a problem logging off
			// from the server, and we are going to simply log on to the new server
			_OnLoggedOff();
			LogonAsync();
		}
		else if( Op_Logoff == OldOp )
		{
				// We don't have to put up a message box...
			_OnLoggedOff();
		}
		else
		{
			if( (LDAP_SERVER_DOWN == LdapResult) || (LDAP_TIMEOUT == LdapResult) )
			{
                if (Op_Modifying_InCallAttr == OldOp)
                {
				    ERROR_OUT(("ldap_bind for InCallAttr returns server-down or timeout"));
                }
                else
                {
					::PostConfMsgBox(IDS_ULSLOGON_BADSERVER);	
					_OnLoggedOff();
                }
			}
			else
			{
				ERROR_OUT(("ldap_bind returned error 0x%08x LdapResult, GetLastError == 0x%08x", LdapResult, LastError));
			}
		}
	}

TRACE_OUT(("CNmLDAP::_OnUserBindComplete:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnUserBindComplete);
}

void CNmLDAP::_OnLoggingOffResult(int Result)
{
	DBGENTRY(CNmLDAP::_OnLoggingOffResult);
TRACE_OUT(("CNmLDAP::_OnLoggingOffResult:enter(%d):   m_State:%d:   m_currentOp:%d", Result, m_State, m_CurrentOp));
	
	if( (LDAP_SUCCESS == Result) || (LDAP_NO_SUCH_OBJECT == Result) || (LDAP_SERVER_DOWN == Result))
	{
			// We are waiting in the destructor for the ldap logof operations to complete
			// Now that it has, we hawe to signal the destructor unblocks
		if(m_hEventWaitForLogoffDone)
		{
			SetEvent(m_hEventWaitForLogoffDone);
		}

		_OnLoggedOff();
	}
	else
	{
		ERROR_OUT(("Ldap Error 0x%08x", Result));
	}


	WLDAP::ldap_unbind(m_pLdap);
	m_State = Idle;
	m_pLdap = NULL;
	SetLoggedOn( IsLoggedOn() );

	if( Op_Refresh_Logoff == m_CurrentOp )
	{
		m_CurrentOp = Op_NoOp;
		LogonAsync();
	}

TRACE_OUT(("CNmLDAP::_OnLoggingOffResult:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggingOffResult);
}


void CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult(int Result)
{
	DBGENTRY(CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult);
TRACE_OUT(("CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult:enter(%d):   m_State:%d:   m_currentOp:%d", Result, m_State, m_CurrentOp));
	
	if( LDAP_SUCCESS == Result)
	{
	    // start the keep alive thread
        if (NULL != m_pKeepAlive)
        {
            m_pKeepAlive->Start();
        }

		if(SettingAppInfo == m_State)
		{
			m_State = LoggedIn;
			SetLoggedOn( IsLoggedOn() );
			_OnLoggedOn();
		}
		else
		{
			m_State = LoggedIn;
			SetLoggedOn( IsLoggedOn() );
		}

		if( m_bSendInCallAttrWhenDone )
		{
			m_bSendInCallAttrWhenDone = false;
			_ModifyInCallAttr();
		}
		else
		{
			WLDAP::ldap_unbind(m_pLdap);

			if(m_ResultPollTimer)
			{
				::KillTimer(m_hWndHidden,m_ResultPollTimer);
				m_ResultPollTimer = 0;
			}

			m_uMsgID = INVALID_MSG_ID;

			m_pLdap = NULL;
			m_State = LoggedIn;
			SetLoggedOn( IsLoggedOn() );
		}
	}
	else
	{
		ERROR_OUT( ("Ldap Error 0x%08x, DN=%s", Result, m_strCurrentDN) );
		if (ModifyingAttrs == m_State && NULL != m_pKeepAlive)
		{
    		_AbandonAllAndRecoverState();
    		if(LDAP_NO_SUCH_OBJECT == Result)
    		{			
        		_OnLoggedOff();
    			LogonAsync();
    		}
		}
		else
		{
    		_AbandonAllAndSetToIdle();
    		_OnLoggedOff();

    		if(LDAP_NO_SUCH_OBJECT == Result)
    		{			
    			LogonAsync();
    		}
        }
	}

TRACE_OUT(("CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnSettingAppInfoOrModifyingAttrsResult);
}


void CNmLDAP::_OnAddingUserResult( int Result)
{
	DBGENTRY(CNmLDAP::_OnAddingUserResult);	
TRACE_OUT(("CNmLDAP::_OnAddingUserResult:enter(%d):   m_State:%d:   m_currentOp:%d", Result, m_State, m_CurrentOp));

	if( LDAP_SUCCESS == Result )
	{
		m_State = UserAdded;
		SetLoggedOn( IsLoggedOn() );
		_SetAppInfo();
	}
	else
	{
		UINT	uStringID;

		switch( Result )
		{
			case LDAP_ALREADY_EXISTS:
				uStringID = IDS_ULSLOGON_DUPLICATE;
				break;

			case LDAP_NAMING_VIOLATION:
				uStringID = IDS_ULSLOGON_WORD_FILTER;
				break;

			case LDAP_UNWILLING_TO_PERFORM:
				uStringID = IDS_ILLEGALEMAILNAME;
				break;

			case LDAP_UNDEFINED_TYPE:
			case LDAP_SERVER_DOWN:
				// W2K server returns this under heavy load situations...
				uStringID = IDS_ULSLOGON_ERROR;
				break;

			default:
				uStringID = IDS_ULSLOGON_ERROR;
				ERROR_OUT( ("Ldap Error 0x%08x, DN=%s", Result, m_strCurrentDN) );
				break;
		}

		::PostConfMsgBox( uStringID );
		_OnLoggedOff();

		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
		SetLoggedOn( IsLoggedOn() );
	}

TRACE_OUT(("CNmLDAP::_OnAddingUserResult:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnAddingUserResult);	
}


/*static*/
LRESULT CNmLDAP::_sWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LRESULT lr = 0;

	if( WM_NCCREATE != uMsg )
	{
		CNmLDAP* pNmLdap = reinterpret_cast<CNmLDAP*>( ::GetWindowLongPtr( hwnd, GWLP_USERDATA ) );
		
		if( pNmLdap )
		{
			lr = pNmLdap->WndProc( hwnd, uMsg, wParam, lParam );
		}
	}
	else
	{
		lr = TRUE; // This means to continue creating the window
		CREATESTRUCT* pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
		if( pCreateStruct )
		{
			::SetWindowLongPtr( hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams));
		}
	}

	return lr;
}

void CNmLDAP::_SetAppInfo()
{
	DBGENTRY(CNmLDAP::_SetInfo);
TRACE_OUT(("CNmLDAP::_SetInfo:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	ASSERT(NULL != m_pLdap);
	ASSERT(UserAdded == m_State);
	ASSERT(INVALID_MSG_ID == m_uMsgID);

		// These are the app attribute vals
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, smodop, LDAP_MODOP_ADDAPP);
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sappid, _T("ms-netmeeting"));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, smimetype, _T("text/iuls"));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sappguid, _T("008aff194794cf118796444553540000"));
	DECLARE_LDAP_MOD2(LDAP_MOD_ADD, sprotid, _T("t120"), _T("h323"));
	DECLARE_LDAP_MOD2(LDAP_MOD_ADD, sprotmimetype, _T("text/t120"), _T("text/h323"));
	DECLARE_LDAP_MOD2(LDAP_MOD_ADD, sport, _T("1503"), _T("1720"));

		// This is the app mod array
	LDAPMod *apModApp[] =
	{
		LDAP_MOD_ENTRY(smodop),
		LDAP_MOD_ENTRY(sappid),
		LDAP_MOD_ENTRY(smimetype),
		LDAP_MOD_ENTRY(sappguid),
		LDAP_MOD_ENTRY(sprotid),
		LDAP_MOD_ENTRY(sprotmimetype),
		LDAP_MOD_ENTRY(sport),
		NULL
	};

	m_uMsgID = WLDAP::ldap_modify( m_pLdap, const_cast<LPTSTR>((LPCTSTR)m_strCurrentDN), apModApp );

	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );

		ASSERT(m_ResultPollTimer);

		m_State = SettingAppInfo;
	}
	else
	{
		DWORD dwErr;
		ERROR_OUT(("ldap_modify returned error 0x%08x", (WLDAP::ldap_get_option(m_pLdap, LDAP_OPT_ERROR_NUMBER, &dwErr), dwErr)));
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
	}

	SetLoggedOn( IsLoggedOn() );
TRACE_OUT(("CNmLDAP::_SetInfo:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_SetInfo);
}


void CNmLDAP::_ModifyInCallAttr()
{
TRACE_OUT(("CNmLDAP::_ModifyInCallAttr:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DECLARE_LDAP_MOD(LDAP_MOD_REPLACE, smodop, LDAP_MODOP_MODIFYUSER);
	DECLARE_LDAP_MOD(LDAP_MOD_REPLACE, ilsA26214430, m_bInCall ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE);

	LDAPMod *apMod[] =
	{
		LDAP_MOD_ENTRY(smodop),
		LDAP_MOD_ENTRY(ilsA26214430),
		NULL
	};

	TRACE_OUT(("About to modify InCallAttrs for this person: %s", m_strCurrentDN));
	m_uMsgID = WLDAP::ldap_modify( m_pLdap, const_cast<LPTSTR>((LPCTSTR)m_strCurrentDN), apMod );

	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );
		
		ASSERT(m_ResultPollTimer);

		m_State = ModifyingAttrs;
	}
	else
	{
		DWORD dwErr;
		ERROR_OUT(("ldap_modify returned error 0x%08x", (WLDAP::ldap_get_option(m_pLdap, LDAP_OPT_ERROR_NUMBER, &dwErr), dwErr)));
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = (NULL != m_pKeepAlive) ? LoggedIn : Idle; // restore the state
	}

	SetLoggedOn( IsLoggedOn() );
TRACE_OUT(("CNmLDAP::_ModifyInCallAttr:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

}


void CNmLDAP::_DeleteUser()
{
	DBGENTRY(CNmLDAP::_DeleteUser);
TRACE_OUT(("CNmLDAP::_DeleteUser:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

    // end the keep alive thread
    if (NULL != m_pKeepAlive)
    {
        m_pKeepAlive->End();
        m_pKeepAlive = NULL;
    }

	ASSERT(NULL != m_pLdap);
	ASSERT(Bound == m_State);
	ASSERT(INVALID_MSG_ID == m_uMsgID);

	m_uMsgID = WLDAP::ldap_delete(m_pLdap, const_cast<LPTSTR>((LPCTSTR)(m_strCurrentDN)));
	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_State = LoggingOff;
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );
		ASSERT(m_ResultPollTimer);
	}
	else
	{
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
	}

	SetLoggedOn( IsLoggedOn() );

TRACE_OUT(("CNmLDAP::_DeleteUser:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_DeleteUser);
}

void CNmLDAP::_AddUser()
{
	DBGENTRY(CNmLDAP::_AddUser);
TRACE_OUT(("CNmLDAP::_AddUser:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	ASSERT(NULL != m_pLdap);
	ASSERT(Bound == m_State);
	ASSERT(INVALID_MSG_ID == m_uMsgID);

		// These are the user attribute values
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, cn, const_cast<LPTSTR>((LPCTSTR)m_strEmailName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, givenname, const_cast<LPTSTR>((LPCTSTR)m_strGivenName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, surname, const_cast<LPTSTR>((LPCTSTR)m_strSurName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, rfc822mailbox, const_cast<LPTSTR>((LPCTSTR)m_strEmailName));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, location, const_cast<LPTSTR>((LPCTSTR)m_strLocation));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, comment, const_cast<LPTSTR>((LPCTSTR)m_strComment));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sflags, m_bVisible ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA26214430, m_bInCall ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA32833566, m_bAudioHardware ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA32964638, m_bVideoHardware ? LDAP_ATTR_TRUE : LDAP_ATTR_FALSE );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA39321630, LDAP_ATTR_BUSINESS );
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ssecurity, const_cast<LPTSTR>((LPCTSTR)m_strSecurityToken));
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, c, LDAP_ATTR_DUMMY_COUNTRYNAME);

		// We have to get IP address dynamically
	TCHAR szIpAddr[MAX_PATH];
	szIpAddr[0] = _T('\0');

    DWORD dwLocalIPAddress = INADDR_NONE;
	_GetIpAddressOfLdapSession( szIpAddr, CCHMAX(szIpAddr), &dwLocalIPAddress );

	DECLARE_LDAP_MOD(LDAP_MOD_ADD, sipaddress, szIpAddr);
		
		// We store the version info on the server
	TCHAR szVer[MAX_PATH];
	wsprintf(szVer,"%lu",VER_PRODUCTVERSION_DW);
	DECLARE_LDAP_MOD(LDAP_MOD_ADD, ilsA26279966, szVer);

		// This is the user mod array
	LDAPMod *apModUser[] =
	{
		LDAP_MOD_ENTRY(cn),
		LDAP_MOD_ENTRY(givenname),
		LDAP_MOD_ENTRY(surname),
		LDAP_MOD_ENTRY(rfc822mailbox),
		LDAP_MOD_ENTRY(location),
		LDAP_MOD_ENTRY(comment),
		LDAP_MOD_ENTRY(c),
		LDAP_MOD_ENTRY(sipaddress),
		LDAP_MOD_ENTRY(sflags),
		LDAP_MOD_ENTRY(ssecurity),
		LDAP_MOD_ENTRY(ilsA26214430),
		LDAP_MOD_ENTRY(ilsA26279966),
		LDAP_MOD_ENTRY(ilsA32833566),
		LDAP_MOD_ENTRY(ilsA32964638),
		LDAP_MOD_ENTRY(ilsA39321630),
		NULL
	};

	TCHAR* szDN = new TCHAR[ lstrlen(LOGIN_USER_FILTER) + lstrlen(m_strEmailName) + 1 ];
	if( szDN )
	{
		wsprintf(szDN, LOGIN_USER_FILTER, m_strEmailName);
		m_strCurrentDN = szDN;
		delete [] szDN;
	}

	TCHAR* szRefresh = new TCHAR[ lstrlen(LDAP_REFRESH_FILTER) + lstrlen(m_strEmailName) + 1 ];
	if( szRefresh )
	{
		wsprintf(szRefresh, LDAP_REFRESH_FILTER, m_strEmailName);
	}

	m_uMsgID = WLDAP::ldap_add( m_pLdap, const_cast<LPTSTR>((LPCTSTR)m_strCurrentDN), apModUser );

	if( INVALID_MSG_ID != m_uMsgID )
	{
		m_State = AddingUser;
		m_ResultPollTimer = ::SetTimer( m_hWndHidden, PollForResultTimer, RESULT_POLL_INTERVAL, NULL );
		ASSERT(m_ResultPollTimer);

		// create the keep alive object
		if (NULL != m_pKeepAlive)
		{
            m_pKeepAlive->End();
            m_pKeepAlive = NULL;
		}
		BOOL fRet = FALSE;
	    m_pKeepAlive = new CKeepAlive(&fRet,
	                                  m_hWndHidden,
	                                  dwLocalIPAddress,
	                                  m_strCurrentServer, m_iPort,
	                                  szRefresh);
	    ASSERT(NULL != m_pKeepAlive && fRet);
	}
	else
	{
		WLDAP::ldap_unbind(m_pLdap);
		m_pLdap = NULL;
		m_State = Idle;
	}

    delete [] szRefresh;

	SetLoggedOn( IsLoggedOn() );

TRACE_OUT(("CNmLDAP::_AddUser:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_AddUser);
}

void CNmLDAP::_OnLoggedOn()
{
	DBGENTRY(CNmLDAP::_OnLoggedOn);
TRACE_OUT(("CNmLDAP::_OnLoggedOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	
	
TRACE_OUT(("CNmLDAP::_OnLoggedOn:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggedOn);
}

void CNmLDAP::_OnLoggedOff()
{
	DBGENTRY(CNmLDAP::_OnLoggedOff);
TRACE_OUT(("CNmLDAP::_OnLoggedOff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	

TRACE_OUT(("CNmLDAP::_OnLoggedOff:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggedOff);
}


void CNmLDAP::_OnLoggingOn()
{
	DBGENTRY(CNmLDAP::_OnLoggingOn);
TRACE_OUT(("CNmLDAP::_OnLoggingOn:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	

TRACE_OUT(("CNmLDAP::_OnLoggingOn:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggingOn);
}


void CNmLDAP::_OnLoggingOff()
{
	DBGENTRY(CNmLDAP::_OnLoggingOff);
TRACE_OUT(("CNmLDAP::_OnLoggingOff:enter:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));

	::UpdateUI(CRUI_STATUSBAR | CRUI_CALLANIM, TRUE);	

TRACE_OUT(("CNmLDAP::_OnLoggingOff:exit:   m_State:%d:   m_currentOp:%d", m_State, m_CurrentOp));
	DBGEXIT(CNmLDAP::_OnLoggingOff);
}

void CNmLDAP::_GetIpAddressOfLdapSession( LPTSTR szIpAddr, int cchMax, DWORD *pdwIPAddr )
{
	DBGENTRY(CNmLDAP::_GetIpAddressOfLdapSession);

    if (NULL != szIpAddr)
    {
	    szIpAddr[0] = _T('\0');
	}
	SOCKET s = INVALID_SOCKET;

	if( LDAP_SUCCESS == WLDAP::ldap_get_option(m_pLdap, LDAP_OPT_DESC, &s ))
	{
		SOCKADDR_IN addr;
		int NameLen = sizeof(addr);
		if(0 == getsockname(s, reinterpret_cast<SOCKADDR*>(&addr), &NameLen))
		{
		    if (NULL != szIpAddr)
		    {
			    wsprintf(szIpAddr, "%u", addr.sin_addr.s_addr);
			}
			if (NULL != pdwIPAddr)
			{
			    *pdwIPAddr = addr.sin_addr.s_addr;
			}
		}
	}

	DBGEXIT(CNmLDAP::_GetIpAddressOfLdapSession);
}


void InitNmLdapAndLogon()
{
	ASSERT( NULL == g_pLDAP );

	g_pLDAP = new CNmLDAP;

	if(g_pLDAP)
	{
						// Initialize the LDAP object...
		if( SUCCEEDED(g_pLDAP->Initialize( _Module.GetModuleInstance())))
		{
			g_pLDAP->LogonAsync();
		}
		else
		{
			delete g_pLDAP;
			g_pLDAP = NULL;
		}
	}
	else
	{
		ERROR_OUT(("new CNmLDAP returned NULL"));
	}
}



/////////////////////////////////////////////////////////
//
// CKeepAlive
//


void CALLBACK KeepAliveTimerProc(HWND, UINT, UINT_PTR, DWORD)
{
    // doing nothing at all
}


DWORD KeepAliveThreadProc(LPVOID pParam)
{
    // make sure we have a valid socket
	WSADATA	wsaData;
    int iRet = ::WSAStartup(0x0101, &wsaData);
    ASSERT(! iRet);
    if (! iRet)
    {
        CKeepAlive *pKeepAlive = (CKeepAlive *) pParam;
        ASSERT(NULL != pKeepAlive);

        // translate server name into ip address
        if (pKeepAlive->SetServerIPAddress())
        {
            // start the timer
            UINT nKeepAliveInterval = INITIAL_REFRESH_INTERVAL_MINUTES;
            UINT_PTR nTimerID = ::SetTimer(NULL, 0, nKeepAliveInterval * 60 * 1000, KeepAliveTimerProc);
            ASSERT(nTimerID);

            // watch for the timer message
            MSG msg, msg2;
            while (::GetMessage(&msg, NULL, 0, 0))
            {
                msg2 = msg; // keep a copy of this message

                // dispatch messages
                ::DispatchMessage(&msg);

                // intercept the WM_TIMER message thru msg2
                if (WM_TIMER == msg2.message && nTimerID == msg2.wParam)
                {
                    BOOL fRetry = TRUE;

                    // kill the timer to avoid timer overrun
                    ::KillTimer(NULL, nTimerID);
                    nTimerID = 0;

                    // ping the server in case of dialup networking
                    if (pKeepAlive->Ping())
                    {
                        // connect to the server
                        LDAP *ld = WLDAP::ldap_open(pKeepAlive->GetServerName(),
                                                    pKeepAlive->GetServerPortNumber());
                        if (NULL != ld)
                        {
                            if (pKeepAlive->Bind(ld))
                            {
                                if (pKeepAlive->KeepAlive(ld, &nKeepAliveInterval))
                                {
                                    // successfully send a keep alive
                                    fRetry = FALSE;

                                    DWORD dwLocalIPAddress = pKeepAlive->GetLocalIPAddress(ld);
                                    if (INADDR_NONE != dwLocalIPAddress)
                                    {
                                        if (pKeepAlive->GetLocalIPAddress() != dwLocalIPAddress)
                                        {
                                            pKeepAlive->SetLocalIPAddress(dwLocalIPAddress);
                                            pKeepAlive->UpdateIPAddressOnServer();
                                        }
                                    }
                                }
                            }
                            WLDAP::ldap_unbind(ld);
                        }
                    }

                    // start the new timer based on the new internal
                    nTimerID = ::SetTimer(NULL, 0,
                                          fRetry ? (15 * 1000) : (nKeepAliveInterval * 60 * 1000),
                                          KeepAliveTimerProc);
                    ASSERT(nTimerID);
                } // if wm timer
            } // while get message

            if (nTimerID)
            {
                ::KillTimer(NULL, nTimerID);
            }
        }

        delete pKeepAlive;
        ::WSACleanup();
    }
    return 0;
}


CKeepAlive::CKeepAlive
(
    BOOL               *pfRet,
    HWND                hwndMainThread,
    DWORD               dwLocalIPAddress,
    const TCHAR * const pcszServerName,
    UINT                nPort,
    LPTSTR              pszKeepAliveFilter
)
:
    m_hwndMainThread(hwndMainThread),
    m_dwLocalIPAddress(dwLocalIPAddress),
    m_dwServerIPAddress(INADDR_NONE),
    m_pszServerName(NULL),
    m_nPort(nPort),
    m_pszKeepAliveFilter(NULL),
    m_hThread(NULL),
    m_dwThreadID(0),
    m_fAborted(FALSE)
{
    *pfRet = FALSE; // assume failure

    // sanity check
    ASSERT(NULL != hwndMainThread);
    ASSERT(INADDR_NONE != dwLocalIPAddress && 0 != dwLocalIPAddress);
    ASSERT(nPort);

    // create the server name
    ASSERT(NULL != pcszServerName);
    ULONG nStrLen = ::lstrlen(pcszServerName) + 1;
    m_pszServerName = new TCHAR[nStrLen];
    if (NULL != m_pszServerName)
    {
        ::CopyMemory(m_pszServerName, pcszServerName, nStrLen * sizeof(TCHAR));

		TCHAR * const	pszPort	= StrChr( m_pszServerName, ':' );

		if( pszPort != NULL )
		{
			//	Truncate the server name here for dns lookup....
			//	and this port number overrides the nPort parameter...
			*pszPort = '\0';
			HRESULT	hrResult = DecimalStringToUINT( pszPort + 1, m_nPort );
			ASSERT( hrResult == S_OK );
			if( hrResult != S_OK )
			{
				m_nPort = DEFAULT_LDAP_PORT;
			}
		}

        // create the fresh filter
        ASSERT(NULL != pszKeepAliveFilter);
        nStrLen = ::lstrlen(pszKeepAliveFilter) + 1;
        m_pszKeepAliveFilter = new TCHAR[nStrLen];
        if (NULL != m_pszKeepAliveFilter)
        {
            ::CopyMemory(m_pszKeepAliveFilter, pszKeepAliveFilter, nStrLen * sizeof(TCHAR));
            *pfRet = TRUE;
        }
    }
}


CKeepAlive::~CKeepAlive(void)
{
    delete m_pszServerName;
    delete m_pszKeepAliveFilter;
}


BOOL CKeepAlive::Start(void)
{
    if (! m_dwThreadID)
    {
        ASSERT(NULL == m_hThread);

        // create the worker thread
        m_hThread = ::CreateThread(NULL, 0, KeepAliveThreadProc, this, 0, &m_dwThreadID);
    }

    ASSERT(NULL != m_hThread);
    return (NULL != m_hThread);
}


BOOL CKeepAlive::End(BOOL fSync)
{
    DWORD dwRet = WAIT_OBJECT_0;

    // cache thread handle and ID
    HANDLE hThread = m_hThread;
    DWORD dwThreadID = m_dwThreadID;

    // abort any pending operation
    m_fAborted = TRUE;

    // notify the worker thread to go away
    if (m_dwThreadID)
    {
        ASSERT(NULL != m_hThread);
        m_dwThreadID = 0;
        ::PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    }

    // wait for the worker thread exit for 5 seconds
    if (NULL != hThread)
    {
        // need more work to unblock it
        if (fSync)
        {
            dwRet = ::WaitForSingleObject(hThread, 5000); // 5 second timeout
            ASSERT(WAIT_TIMEOUT != dwRet);
        }

        ::CloseHandle(hThread);
    }

    return (WAIT_TIMEOUT != dwRet);
}


BOOL CKeepAlive::SetServerIPAddress(void)
{
    ASSERT(NULL != m_pszServerName);

    // check to see if the server name is a dotted IP address string
    m_dwServerIPAddress = ::inet_addr(m_pszServerName);
    if (INADDR_NONE == m_dwServerIPAddress)
    {
        // it is not a dotted string, it must be a name.
        // get the host entry by name
        PHOSTENT phe = ::gethostbyname(m_pszServerName);
        if (phe != NULL)
        {
            // get info from the host entry
            m_dwServerIPAddress = *(DWORD *) phe->h_addr;
        }
    }

    ASSERT(INADDR_NONE != m_dwServerIPAddress);
    return (INADDR_NONE != m_dwServerIPAddress);
}


BOOL CKeepAlive::Ping(void)
{
    BOOL fRet = TRUE; // assume success
    if (NULL != g_pPing)
    {
        if (g_pPing->IsAutodialEnabled())
        {
            ASSERT(INADDR_NONE != m_dwServerIPAddress);
            HRESULT hr = g_pPing->Ping(m_dwServerIPAddress, PING_TIMEOUT_INTERVAL, PING_RETRIES);
            fRet = (S_OK == hr);
        }
    }
    return fRet;
}


BOOL CKeepAlive::Bind(LDAP *ld)
{
    ASSERT(NULL != ld);

    if (! m_fAborted)
    {
        // anonymous bind
        ULONG nMsgID = WLDAP::ldap_bind(ld, TEXT(""), TEXT(""), LDAP_AUTH_SIMPLE);
        if (INVALID_MSG_ID != nMsgID)
        {
            // poll the result every quarter second
            const ULONG c_nTimeoutInQuarterSecond = 4 * LDAP_TIMEOUT_IN_SECONDS;
            for (ULONG i = 0; (i < c_nTimeoutInQuarterSecond) && (! m_fAborted); i++)
            {
                // no timeout, if no result, return immediately
                LDAP_TIMEVAL TimeVal;
                TimeVal.tv_usec = 0;
                TimeVal.tv_sec = 0;

                // check the result
                LDAPMessage *pMsg = NULL;
                ULONG nResultType = WLDAP::ldap_result(ld, nMsgID, LDAP_MSG_ALL, &TimeVal, &pMsg);
                if (nResultType == LDAP_RES_BIND)
                {
                    ASSERT(NULL != pMsg);
                    WLDAP::ldap_msgfree(pMsg);
                    return TRUE;
                }

                // deal with timeout or error
                if (LDAP_RESULT_TIMEOUT == nResultType)
                {
                    if (! m_fAborted)
                    {
                        ::Sleep(250); // sleep for a quarter second
                        continue;
                    }
                }

                ASSERT(LDAP_RESULT_ERROR != nResultType);
                break;
            }

            // failure, do the cleanup
            WLDAP::ldap_abandon(ld, nMsgID);
        }
    }

    return FALSE;
}


DWORD CKeepAlive::GetLocalIPAddress(LDAP *ld)
{
    SOCKET s = INVALID_SOCKET;
    if (LDAP_SUCCESS == WLDAP::ldap_get_option(ld, LDAP_OPT_DESC, &s))
    {
        SOCKADDR_IN addr;
        int NameLen = sizeof(addr);
        if (0 == ::getsockname(s, (SOCKADDR *) &addr, &NameLen))
        {
            return addr.sin_addr.s_addr;
        }
    }
    return INADDR_NONE;
}


BOOL CKeepAlive::KeepAlive(LDAP *ld, UINT *pnKeepAliveInterval)
{
    LPTSTR aTTLAttr[] = { STTL_ATTR_NAME, NULL };
    UINT nMsgID = WLDAP::ldap_search(ld,
                                     LDAP_REFRESH_BASE_DN,
                                     LDAP_SCOPE_BASE,
                                     m_pszKeepAliveFilter,
                                     aTTLAttr,
                                     FALSE);
    if (INVALID_MSG_ID != nMsgID)
    {
        // poll the result every quarter second
        const ULONG c_nTimeoutInQuarterSecond = 4 * LDAP_TIMEOUT_IN_SECONDS;
        BOOL fError = FALSE;
        for (ULONG i = 0; (i < c_nTimeoutInQuarterSecond) && (! m_fAborted) && (! fError); i++)
        {
            // no timeout, if no result, return immediately
            LDAP_TIMEVAL TimeVal;
            TimeVal.tv_usec = 0;
            TimeVal.tv_sec = 0;

            // check the result
            LDAPMessage *pMsg = NULL;
            ULONG nResultType = WLDAP::ldap_result(ld, nMsgID, LDAP_MSG_ALL, &TimeVal, &pMsg);
            switch (nResultType)
            {
            case LDAP_RESULT_TIMEOUT:
                if (! m_fAborted)
                {
                    ::Sleep(250); // sleep for a quarter second
                }
                break;
            case LDAP_RESULT_ERROR:
                fError = TRUE;
                break;
            default:
                ASSERT(LDAP_RES_SEARCH_ENTRY == nResultType ||
                       LDAP_RES_SEARCH_RESULT == nResultType);
                ASSERT(NULL != pMsg);
                switch (pMsg->lm_returncode)
                {
                case LDAP_SUCCESS:
                    GetNewInterval(ld, pMsg, pnKeepAliveInterval);
                    break;
                case LDAP_NO_SUCH_OBJECT:
                    ReLogon();
                    fError = TRUE;
                    break;
                default:
                    break;
                }
                WLDAP::ldap_msgfree(pMsg);
                return (! fError);
            }
        }

        // failure, do the cleanup
        WLDAP::ldap_abandon(ld, nMsgID);
    }

    return FALSE;
}


void CKeepAlive::GetNewInterval(LDAP *ld, LDAPMessage *pMsg, UINT *pnKeepAliveInterval)
{
    // get the first entry which should contain the new ttl value
    LDAPMessage *pEntry = WLDAP::ldap_first_entry(ld, pMsg);
    if (NULL != pEntry)
    {
        // get the first attribute which should be the new ttl value
        BerElement *pElement = NULL;
        LPTSTR pszAttrib = WLDAP::ldap_first_attribute(ld, pEntry, &pElement);
        if (NULL != pszAttrib)
        {
            // it should be ttl attribute
            ASSERT(! lstrcmpi(STTL_ATTR_NAME, pszAttrib));

            // get the value
            LPTSTR *ppszTTL = WLDAP::ldap_get_values(ld, pEntry, pszAttrib);
            if (NULL != ppszTTL)
            {
                if (NULL != ppszTTL[0])
                {
                    int iRefresh = ::RtStrToInt(ppszTTL[0]) - REFRESH_TIMEOUT_MARGIN;
                    if (iRefresh > 0)
                    {
                        if (iRefresh < MIN_REFRESH_TIMEOUT_INTERVAL_MINUTES)
                        {
                            iRefresh = MIN_REFRESH_TIMEOUT_INTERVAL_MINUTES;
                        }
                        *pnKeepAliveInterval = (UINT) iRefresh;
                    }
                }
                WLDAP::ldap_value_free(ppszTTL);
            }
        }
    }
}


void CKeepAlive::ReLogon(void)
{
    ::PostMessage(m_hwndMainThread, WM_NEED_RELOGON, 0, 0);
}


void CKeepAlive::UpdateIPAddressOnServer(void)
{
    ::PostMessage(m_hwndMainThread, WM_NEED_RELOGON, 0, 0);
}



/////////////////////////////////////////////////////////
//
// ResolveUser
//

typedef struct tagResolveInfo
{
    // given
    DWORD       cchMax;
    LPTSTR      pszIPAddress;
    // created
    LPTSTR      pszSearchFilter;
    LDAP       *ld;
}
    RESOLVE_INFO;


void FreeResolveInfo(RESOLVE_INFO *pInfo)
{
    if (NULL != pInfo)
    {
        delete pInfo->pszSearchFilter;

        if (NULL != pInfo->ld)
        {
            WLDAP::ldap_unbind(pInfo->ld);
        }

        delete pInfo;
    }
}


DWORD ResolveUserThreadProc(LPVOID pParam)
{
    RESOLVE_INFO *pInfo = (RESOLVE_INFO *) pParam;
    ASSERT(NULL != pInfo);

    // send the search request
    TCHAR* attrs[] = { IP_ADDRESS_ATTR_NAME, NULL };
    ULONG nMsgID = WLDAP::ldap_search(pInfo->ld,
                                TEXT("objectClass=RTPerson"),
                                LDAP_SCOPE_BASE,
                                pInfo->pszSearchFilter,
                                attrs,
                                0);
    if (INVALID_MSG_ID != nMsgID)
    {
        LDAPMessage *pMsg = NULL;
        LDAP_TIMEVAL SearchTimeout = { LDAP_TIMEOUT_IN_SECONDS, 0 };
        ULONG nResultType = WLDAP::ldap_result(pInfo->ld,
                                         nMsgID,
                                         LDAP_MSG_ALL,
                                         &SearchTimeout,
                                         &pMsg);
        switch (nResultType)
        {
        case LDAP_RESULT_TIMEOUT:
        case LDAP_RESULT_ERROR:
            WLDAP::ldap_abandon(pInfo->ld, nMsgID);
            break;
        default:
            {
                ASSERT(LDAP_RES_SEARCH_ENTRY == nResultType ||
                       LDAP_RES_SEARCH_RESULT == nResultType);
                ASSERT(NULL != pMsg);

                // get the first entry
                LDAPMessage *pEntry = WLDAP::ldap_first_entry(pInfo->ld, pMsg);
                if (NULL != pEntry)
                {
                    BerElement *pElement = NULL;

                    // get the first attribute
                    LPTSTR pszAttrib = WLDAP::ldap_first_attribute(pInfo->ld, pEntry, &pElement);
                    if (NULL != pszAttrib)
                    {
                        ASSERT(! lstrcmpi(IP_ADDRESS_ATTR_NAME, pszAttrib));

                        // get the value
                        LPTSTR *ppszIPAddress = WLDAP::ldap_get_values(pInfo->ld, pEntry, pszAttrib);
                        if (NULL != ppszIPAddress)
                        {
                            if (NULL != ppszIPAddress[0])
                            {
                                BYTE temp[sizeof(DWORD)];
                                *(DWORD *) &temp[0] = ::RtStrToInt(ppszIPAddress[0]);
                                ::wsprintf(pInfo->pszIPAddress, TEXT("%u.%u.%u.%u"),
                                            (UINT) temp[0], (UINT) temp[1],
                                            (UINT) temp[2], (UINT) temp[3]);
                            }

                            WLDAP::ldap_value_free(ppszIPAddress);
                        }
                    } // if attribute
                } // if entry

                WLDAP::ldap_msgfree(pMsg);
            }
            break;
        } // switch
    } // if msg id

    return 0;
}


/*static*/
HRESULT CNmLDAP::ResolveUser( LPCTSTR pcszName, LPCTSTR pcszServer, LPTSTR pszIPAddress, DWORD cchMax, int port )
{
    HRESULT hr = E_OUTOFMEMORY;
    RESOLVE_INFO *pInfo = NULL;

    // clean up the return buffer
    *pszIPAddress = TEXT('\0');

    // make sure the wldap32.dll is loaded
    if( ms_bLdapDLLLoaded || SUCCEEDED( hr = WLDAP::Init()))
    {
        ms_bLdapDLLLoaded = true;

        // create a resolve info which exchanges info between this thread and a background thread.
        pInfo = new RESOLVE_INFO;
        if (NULL != pInfo)
        {
            // cleanup
            ::ZeroMemory(pInfo, sizeof(*pInfo));

            // remember return buffer and its size
            pInfo->pszIPAddress = pszIPAddress;
            pInfo->cchMax = cchMax;

            // create search filter
            ULONG cbFilterSize = ::lstrlen(RESOLVE_USER_SEARCH_FILTER) + ::lstrlen(pcszName) + 2;
            pInfo->pszSearchFilter = new TCHAR[cbFilterSize];
            if (NULL != pInfo->pszSearchFilter)
            {
                // construct search filter
                ::wsprintf(pInfo->pszSearchFilter, RESOLVE_USER_SEARCH_FILTER, pcszName);

                // create ldap block that is NOT connected to server yet.
                pInfo->ld = WLDAP::ldap_init(const_cast<LPTSTR>(pcszServer), port);

				if( pInfo->ld != NULL )
				{
					ULONG ulResult = WLDAP::ldap_bind_s(pInfo->ld, TEXT(""), TEXT(""), LDAP_AUTH_SIMPLE);

					if( (ulResult != LDAP_SUCCESS) && (port == DEFAULT_LDAP_PORT) )
					{
						WLDAP::ldap_unbind(pInfo->ld);
						pInfo->ld = WLDAP::ldap_init(const_cast<LPTSTR>(pcszServer), ALTERNATE_LDAP_PORT);		//	Automatically retry with alternate port...

						if( pInfo->ld != NULL )
						{
							ulResult = WLDAP::ldap_bind_s(pInfo->ld, TEXT(""), TEXT(""), LDAP_AUTH_SIMPLE);
		
							if( ulResult != LDAP_SUCCESS )
							{
								WLDAP::ldap_unbind(pInfo->ld);
								pInfo->ld = NULL;
							}
						}
					}
				}

                ASSERT(NULL != pInfo->ld);
                if (NULL != pInfo->ld)
                {
                    DWORD dwThreadID = 0;
                    HANDLE hThread = ::CreateThread(NULL, 0, ResolveUserThreadProc, pInfo, 0, &dwThreadID);
                    if (NULL != hThread)
                    {
                        // wait for the thread to exit
                        hr = ::WaitWithMessageLoop(hThread);
                        DWORD dwIPAddr = ::inet_addr(pszIPAddress);
                        hr = (dwIPAddr && INADDR_NONE != dwIPAddr) ? S_OK : E_FAIL;

                        // close thread
                        ::CloseHandle(hThread);
                    }
                } // if ld
            } // if search filter
        } // if new resolve info
    } // if init

    ::FreeResolveInfo(pInfo);
    return  hr;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmmanager.cpp ===
#include "precomp.h"

// NetMeeting stuff

#include "AtlExeModule.h" 
#include "ConfUtil.h"
#include "NmLdap.h"
#include "call.h"
#include "common.h"
#include "ConfMan.h"
#include "cmd.h"
#include "conf.h"
#include "iAppLdr.h"
#include "confroom.h"
#include "ConfPolicies.h"
#include "cmd.h"
#include "ConfWnd.h"
#include "Taskbar.h"
#include "certui.h"

// NetMeeting SDK includes
#include "NmEnum.h"
#include "NmManager.h"
#include "NmConference.h"
#include "NmCall.h"
#include "SDKWindow.h"
#include "dlgCall2.h"

bool g_bSDKPostNotifications;
extern BOOL g_fLoggedOn;
extern INmSysInfo2 * g_pNmSysInfo;
extern GUID g_csguidSecurity;

//static
CSimpleArray<CNmManagerObj*>* CNmManagerObj::ms_pManagerObjList = NULL;
bool g_bOfficeModeSuspendNotifications = false;
DWORD CNmManagerObj::ms_dwID = 1;

BOOL InitAppletSDK(void);
void CleanupAppletSDK(void);


///////////////////////////////////////////////
// Construction\Destruction
///////////////////////////////////////////////


CNmManagerObj::CNmManagerObj() 
: m_bInitialized(false), 
  m_chCaps(NMCH_NONE), 
  m_bNmActive(false),
  m_bSentConferenceCreated(false),
  m_dwID(0),
  m_dwSysInfoID(0),
  m_uOptions(0)

{
	DBGENTRY(CNmManagerObj::CNmManagerObj);

	CNmManagerObj* p = const_cast<CNmManagerObj*>(this);
	ms_pManagerObjList->Add(p);
	
	DBGEXIT(CNmManagerObj::CNmManagerObj);
}

CNmManagerObj::~CNmManagerObj()
{
	DBGENTRY(CNmManagerObj::~CNmManagerObj);

	CNmManagerObj* p = const_cast<CNmManagerObj*>(this);
	ms_pManagerObjList->Remove(p);

		// Free our conferencing objects
	while(m_SDKConferenceObjs.GetSize())
	{
		CComPtr<INmConference> sp = m_SDKConferenceObjs[0];
		m_SDKConferenceObjs.RemoveAt(0);
		sp.p->Release();
	}

		// Free our conferencing objects
	while(m_SDKCallObjs.GetSize())
	{
		CComPtr<INmCall> sp = m_SDKCallObjs[0];
		m_SDKCallObjs.RemoveAt(0);
		sp.p->Release();
	}

	m_spInternalNmManager = NULL;

	DBGEXIT(CNmManagerObj::~CNmManagerObj);
}

HRESULT CNmManagerObj::FinalConstruct()
{
	DBGENTRY(CNmManagerObj::FinalContstruct);
	HRESULT hr = S_OK;		

	m_bInitialized = false;
	m_dwInternalNmManagerAdvise = 0;

	DBGEXIT_HR(CNmManagerObj::FinalContstruct,hr);
	return hr;
}


ULONG CNmManagerObj::InternalRelease()
{
	ATLASSERT(m_dwRef > 0);

	--m_dwRef;

	if((1 == m_dwRef) && m_dwInternalNmManagerAdvise)
	{
		++m_dwRef;
		DWORD dwAdvise = m_dwInternalNmManagerAdvise;
		m_dwInternalNmManagerAdvise = 0;
		AtlUnadvise(m_spInternalNmManager, IID_INmManagerNotify, dwAdvise);
		--m_dwRef;
	}

	return m_dwRef;

}


void CNmManagerObj::FinalRelease()
{
	DBGENTRY(CNmManagerObj::FinalRelease);
	
	if(m_bInitialized)
	{
		switch(m_uOptions)
		{
			case NM_INIT_CONTROL:
					// Even though we have the NM_INIT_CONTROL flag set here
					// We may not me in INIT_CONTROL mode. NetMeeting may have 
					// already been up when we initialized.  In that case the UI is active
				if(_Module.InitControlMode())
				{
						// If we are the last NmManager object with NM_INIT_CONTROL, then
						// we should switch the UI mode away from InitControl
					if((GetManagerCount(NM_INIT_CONTROL) == 1))
					{
						if(!_Module.IsSDKCallerRTC())
						{
							_Module.SetInitControlMode(FALSE);
							::AddTaskbarIcon(::GetHiddenWindow());
						}
					}
				}
				break;

			case NM_INIT_OBJECT:
				// Check to see if this is the last "office" client
				if (GetManagerCount(NM_INIT_OBJECT) == 1)
				{
					CConfMan::AllowAV(TRUE);					
				}
				break;

			default:
				break;
		}
	}

	DBGEXIT(CNmManagerObj::FinalRelease);
}

/*static*/ HRESULT CNmManagerObj::InitSDK()
{
	DBGENTRY(CNmManagerObj::InitSDK);
	HRESULT hr = S_OK;

	g_bSDKPostNotifications = false;

	ms_pManagerObjList = new CSimpleArray<CNmManagerObj*>;
	if(!ms_pManagerObjList)
	{
		hr = E_OUTOFMEMORY;
	}

    ::InitAppletSDK();
    InitPluggableTransportSDK();

	DBGEXIT_HR(CNmManagerObj::InitSDK,hr);
	return hr;
}

/*static*/void CNmManagerObj::CleanupSDK()
{
	DBGENTRY(CNmManagerObj::CleanupSDK);

    ::CleanupAppletSDK();
    CleanupPluggableTransportSDK();

	delete ms_pManagerObjList;

	DBGEXIT(CNmManagerObj::CleanupSDK);
}


///////////////////////////////////////////////
// INmManager methods
///////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::Initialize( ULONG * puOptions, ULONG *puchCaps)
{
	DBGENTRY(CNmManagerObj::Initialize);
	HRESULT hr = S_OK;

		// If the remote control service is running, this will bring up a dialog
		// that the user can choose weather or not to kill the remote control session
		// If they do want to kill the session then the mananger object will initialize properly
	if(!CheckRemoteControlService())
	{
		return E_FAIL;
	}

	m_uOptions = puOptions ? *puOptions : NM_INIT_NORMAL;

	if(puOptions && (*puOptions > NM_INIT_BACKGROUND))
	{
		hr = E_INVALIDARG;
		goto end;
	}

	if(!m_bInitialized)
	{
		bool bStartedNetMeeting = false;

		if(!g_pInternalNmManager)
		{
			if(NM_INIT_NO_LAUNCH == m_uOptions)
			{
					// We don't launch NetMeeting in this case...
				m_bNmActive = false;
				goto end;
			}

			if (NM_INIT_CONTROL == m_uOptions)
			{
				_Module.SetInitControlMode(TRUE);
			}
			
			hr = InitConfExe(NM_INIT_NORMAL == m_uOptions);

			bStartedNetMeeting = SUCCEEDED(hr);
		}

		if(SUCCEEDED(hr))
		{
			if(NM_INIT_OBJECT == m_uOptions)
			{
				if (!_Module.IsUIVisible())
				{
					CConfMan::AllowAV(FALSE);
				}
			}

			m_bNmActive = true;

			CFt::EnsureLoadFtApplet();

			m_spInternalNmManager = g_pInternalNmManager;

				// The old NetMeeting ignored this param...
				// for the time being, we are ignoring it too.

			//m_chCaps = puchCaps ? *puchCaps : NMCH_ALL;
			m_chCaps = NMCH_ALL;

			hr = AtlAdvise(m_spInternalNmManager,GetUnknown(),IID_INmManagerNotify, &m_dwInternalNmManagerAdvise);	
		}
	}
	else
	{
		hr = E_FAIL;
	}

end:

	m_bInitialized = SUCCEEDED(hr);
	if(m_bInitialized)
	{
		INmConference2* pConf = ::GetActiveConference();
	
		if(pConf)
		{
			ConferenceCreated(pConf);
				
				// If there is no manager notify hooked in, we simply 
				// sync up with the Internal conference object state
			IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;
			if((0 == pCP->m_vec.GetSize()) && !m_bSentConferenceCreated)
			{
					// It must be the first conference, because we are newly-initialized
				ASSERT(m_SDKConferenceObjs[0]);

					// Sinc up the channels, etc.
				com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[0])->FireNotificationsToSyncToInternalObject();
			}
		}
	}

	DBGEXIT_HR(CNmManagerObj::Initialize,hr);
	return hr;
}

	// This is not guarenteed to work if called from conf.exe's process!!!
STDMETHODIMP CNmManagerObj::GetSysInfo(INmSysInfo **ppSysInfo)
{	
	DBGENTRY(CNmManagerObj::GetSysInfo);
	HRESULT hr = S_OK;

	hr = CoCreateInstance(CLSID_NmSysInfo, NULL, CLSCTX_ALL, IID_INmSysInfo, reinterpret_cast<void**>(ppSysInfo));

	if(*ppSysInfo)
	{
		m_dwID = ++ms_dwID;
		com_cast<IInternalSysInfoObj>(*ppSysInfo)->SetID(m_dwID);
	}

	DBGEXIT_HR(CNmManagerObj::GetSysInfo,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::CreateConference(INmConference **ppConference, BSTR bstrName, BSTR bstrPassword, ULONG uchCaps)
{
	DBGENTRY(CNmManagerObj::CreateConference);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(m_bNmActive)
		{
			if(ppConference)
			{
				if(m_spInternalNmManager)
				{
					switch(ConfPolicies::GetSecurityLevel())
					{
						case REQUIRED_POL_SECURITY:
							m_chCaps = uchCaps | NMCH_SECURE;
							break;
						case DISABLED_POL_SECURITY:
							m_chCaps = uchCaps & ~NMCH_SECURE;
							break;
						default:
							m_chCaps = uchCaps;
							break;
					}


					if(OfficeMode()) g_bOfficeModeSuspendNotifications = true;

					CComPtr<INmConference> spInternalINmConference;
					hr = m_spInternalNmManager->CreateConference(&spInternalINmConference, bstrName, bstrPassword, m_chCaps);
					if(SUCCEEDED(hr))
					{
							// This was created by the previous call
						*ppConference = GetSDKConferenceFromInternalConference(spInternalINmConference);

						if(*ppConference)
						{
							(*ppConference)->AddRef();
						}
						else
						{
							hr = E_UNEXPECTED;
						}
					}

					if(OfficeMode()) g_bOfficeModeSuspendNotifications = false;
				}
				else
				{
					hr = E_UNEXPECTED;
				}
			}
			else
			{
				hr = E_POINTER;
			}
		}
		else
		{
			hr = NM_E_NOT_ACTIVE;
		}
	}
	else
	{
		hr = NM_E_NOT_INITIALIZED;
	}

	DBGEXIT_HR(CNmManagerObj::CreateConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::EnumConference(IEnumNmConference **ppEnum)
{
	DBGENTRY(CNmManagerObj::EnumConference);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(m_bNmActive)
		{
			hr = CreateEnumFromSimpleAryOfInterface<IEnumNmConference, INmConference>(m_SDKConferenceObjs, ppEnum);
		}
		else
		{
			hr = NM_E_NOT_ACTIVE;
		}
	}
	else
	{		
		hr = NM_E_NOT_INITIALIZED;
	}	


	DBGEXIT_HR(CNmManagerObj::EnumConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::CreateCall(INmCall **ppCall, NM_CALL_TYPE callType, NM_ADDR_TYPE addrType, BSTR bstrAddr, INmConference *pConference)
{
	DBGENTRY(CNmManagerObj::CreateCall);
	HRESULT hr = S_OK;

	
	if(!m_bInitialized)
	{
		hr = NM_E_NOT_INITIALIZED;
		goto end;
	}

	if(!m_bNmActive)
	{
		hr = NM_E_NOT_ACTIVE;
		goto end;
	}

	if(m_spInternalNmManager)
	{
		if(!pConference)
		{   // Get the active conference
			pConference = _GetActiveConference();

			if(!pConference)
			{ // There is no active conf, so create a new one

				CComPtr<INmConference> spInternalINmConference;						

				ULONG           ulCaps = NMCH_AUDIO | NMCH_VIDEO | NMCH_DATA | NMCH_SHARE | NMCH_FT;
				LPTSTR          szAddr = NULL;
				CCalltoParams   params;
				bool            bSecure = FALSE;

				if(SUCCEEDED(BSTR_to_LPTSTR(&szAddr, bstrAddr)))
				{
				    ASSERT(NULL != szAddr);
				    
                    params.SetParams(szAddr);
                    bSecure	= params.GetBooleanParam(TEXT("secure"), bSecure);

                    if(ConfPolicies::OutgoingSecurityPreferred() ||	bSecure)
                    {
                    	ulCaps |= NMCH_SECURE;
                    }

                    delete [] szAddr;
				}

				hr = m_spInternalNmManager->CreateConference(&spInternalINmConference, NULL, NULL, ulCaps);
				if(SUCCEEDED(hr))
				{
						// the above call to CreateConference generates a callback, so we have this object now!
					pConference = GetSDKConferenceFromInternalConference(spInternalINmConference);
				}
			}
		}

		CComPtr<INmCall> spInternalINmCall;

		if(SUCCEEDED(hr))
		{
		
			if(addrType == NM_ADDR_CALLTO)
			{
				ASSERT( g_pCCallto != NULL );

				if(NM_CALL_DEFAULT == callType)
				{
					USES_CONVERSION;

					hr = g_pCCallto->Callto(	OLE2T( bstrAddr ),		//	pointer to the callto url to try to place the call with...
												NULL,					//	pointer to the display name to use...
												NM_ADDR_CALLTO,			//	callto type to resolve this callto as...
												false,					//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
												NULL,					//	security preference, NULL for none. must be "compatible" with secure param if present...
												false,					//	whether or not save in mru...
												false,					//	whether or not to perform user interaction on errors...
												NULL,					//	if bUIEnabled is true this is the window to parent error/status windows to...
												&spInternalINmCall );	//	out pointer to INmCall * to receive INmCall * generated by placing call...
				}
				else
				{
					hr = E_INVALIDARG;
					goto end;
				}
			}
			else
			{
				hr = SdkPlaceCall(callType, addrType, bstrAddr, NULL, NULL, &spInternalINmCall);
			}

			if(SUCCEEDED(hr))
			{
				CallCreated(spInternalINmCall);

				if(ppCall)
				{
					*ppCall = GetSDKCallFromInternalCall(spInternalINmCall);
					if(*ppCall)
					{
						(*ppCall)->AddRef();
					}
				}
			}
		}
	}
	else
	{
		hr = E_UNEXPECTED;
		ERROR_OUT(("Why don't we have a manager object"));
	}

end:
	DBGEXIT_HR(CNmManagerObj::CreateCall,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::CallConference(INmCall **ppCall, NM_CALL_TYPE callType, NM_ADDR_TYPE addrType, BSTR bstrAddr, BSTR bstrConferenceName, BSTR bstrPassword)
{
	DBGENTRY(CNmManagerObj::CallConference);
	HRESULT hr = S_OK;
	
	if(!m_bInitialized)
	{
		hr = NM_E_NOT_INITIALIZED;
		goto end;
	}

	if(!m_bNmActive)
	{
		hr = NM_E_NOT_ACTIVE;
		goto end;
	}

	{
		CComPtr<INmCall> spInternalINmCall;

		hr = SdkPlaceCall(callType, addrType, bstrAddr, bstrConferenceName, bstrPassword, &spInternalINmCall);
				
		if(SUCCEEDED(hr))
		{
			CallCreated(spInternalINmCall);
			*ppCall = GetSDKCallFromInternalCall(spInternalINmCall);
			if(*ppCall)
			{
				(*ppCall)->AddRef();
			}
		}
	}

end:
	DBGEXIT_HR(CNmManagerObj::CallConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::EnumCall(IEnumNmCall **ppEnum)
{
	DBGENTRY(CNmManagerObj::EnumCall);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(m_bNmActive)
		{
			hr = CreateEnumFromSimpleAryOfInterface<IEnumNmCall, INmCall>(m_SDKCallObjs, ppEnum);
		}
		else
		{
			hr = NM_E_NOT_ACTIVE;
		}
	}
	else
	{
		hr = NM_E_NOT_INITIALIZED;
	}

	DBGEXIT_HR(CNmManagerObj::EnumCall,hr);
	return hr;
}

///////////////////////////////////////////////
// INmObject methods
///////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::CallDialog(long hwnd, int cdOptions)
{
	DBGENTRY(CNmManagerObj::CallDialog);
	HRESULT hr = S_OK;

	CFindSomeone::findSomeone(GetConfRoom());

	g_bSDKPostNotifications = true;

	if(OfficeMode() && !m_bSentConferenceCreated)
	{
		Fire_ConferenceCreated(m_SDKConferenceObjs[0]);
	}

	g_bSDKPostNotifications = false;

	DBGEXIT_HR(CNmManagerObj::CallDialog,hr);
	return hr;

}

extern "C" { BOOL WINAPI StartStopOldWB(LPCTSTR lpsz); }

STDMETHODIMP CNmManagerObj::ShowLocal(NM_APPID id)
{
	if(!m_bInitialized)
	{
		return NM_E_NOT_INITIALIZED;
	}

	if(!m_bNmActive)
	{
		return NM_E_NOT_ACTIVE;
	}

	switch (id)
		{
	case NM_APPID_WHITEBOARD:
		StartStopOldWB(NULL);
		return S_OK;

	case NM_APPID_T126_WHITEBOARD:
		return (T120_NO_ERROR == ::T120_LoadApplet(APPLET_ID_WB, TRUE , 0, FALSE, NULL)) ? S_OK : E_FAIL;

	case NM_APPID_CHAT:
		return (T120_NO_ERROR == T120_LoadApplet(APPLET_ID_CHAT, TRUE , 0, FALSE, NULL)) ? S_OK : E_FAIL;

	case NM_APPID_FILE_TRANSFER:
		return CFt::ShowFtUI();

	case NM_APPID_APPSHARING:
		if(g_pConfRoom && g_pConfRoom->IsSharingAllowed())
		{
			g_pConfRoom->CmdShowSharing();
			return S_OK;
		}
	
		return NM_E_SHARING_NOT_AVAILABLE;

	default:
		ERROR_OUT(("Unknown flag passed to ShowLocal"));
		break;
		}

	return E_INVALIDARG;
}

STDMETHODIMP CNmManagerObj::VerifyUserInfo(UINT_PTR hwnd, NM_VUI options)
{
	ASSERT(0);
	return E_UNEXPECTED;
}


////////////////////////////////////////////////////////////
// IInternalConfExe
////////////////////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::LoggedIn()
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::LoggedIn);
	HRESULT hr = g_fLoggedOn ? S_OK : S_FALSE;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::LoggedIn,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::IsRunning()
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::IsRunning);
	HRESULT hr = g_pInternalNmManager ? S_OK : S_FALSE;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::IsRunning,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::InConference()
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::InConference);
	HRESULT hr = ::FIsConferenceActive() ? S_OK : S_FALSE;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::InConference,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::LDAPLogon(BOOL bLogon)
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::LDAPLogon);
	HRESULT hr = S_OK;

	if(g_pLDAP)
	{
		hr = bLogon ? g_pLDAP->LogonAsync() : g_pLDAP->Logoff();
	}
	else
	{
		hr = E_FAIL;
	}

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::LDAPLogon,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::GetLocalCaps(DWORD* pdwLocalCaps)
{
	DBGENTRY(STDMETHODIMP CNmManagerObj::);
	HRESULT hr = S_OK;

	*pdwLocalCaps = g_uMediaCaps;

	DBGEXIT_HR(STDMETHODIMP CNmManagerObj::,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::IsNetMeetingRunning()
{
	return g_pInternalNmManager ? S_OK : S_FALSE;
}


STDMETHODIMP CNmManagerObj::GetActiveConference(INmConference** ppConf)
{
	if(ppConf && ms_pManagerObjList && m_dwSysInfoID)
	{
		for(int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			if((*ms_pManagerObjList)[i]->m_dwID == m_dwSysInfoID)
			{
				if((*ms_pManagerObjList)[i]->m_SDKConferenceObjs.GetSize() != 0)
				{
					*ppConf = (*ms_pManagerObjList)[i]->m_SDKConferenceObjs[0];
					(*ppConf)->AddRef();
					return S_OK;
				}
			}
		}
	}

	return E_FAIL;
}


//--------------------------------------------------------------------------//
//	CNmManagerObj::ShellCalltoProtocolHandler.								//
//--------------------------------------------------------------------------//
STDMETHODIMP
CNmManagerObj::ShellCalltoProtocolHandler
(
	BSTR	url,
	BOOL	bStrict
){
	ASSERT( g_pCCallto != NULL );

	HRESULT result = S_OK;
	
	if(!g_pInternalNmManager)
	{
		if(!CheckRemoteControlService())
		{
			return E_FAIL;
		}

		result = InitConfExe();
	}

	if( SUCCEEDED( result ) )
	{
		USES_CONVERSION;
		TCHAR *pszURL = OLE2T(url);

		if(CCallto::DoUserValidation(pszURL))
		{

    		result = g_pCCallto->Callto(	pszURL,	        //	pointer to the callto url to try to place the call with...
    										NULL,			//	pointer to the display name to use...
    										NM_ADDR_CALLTO,	//	callto type to resolve this callto as...
    										false,			//	the pszCallto parameter is to be interpreted as a pre-unescaped addressing component vs a full callto...
    										NULL,			//	security preference, NULL for none. must be "compatible" with secure param if present...
    										false,			//	whether or not save in mru...
    										true,			//	whether or not to perform user interaction on errors...
    										NULL,			//	if bUIEnabled is true this is the window to parent error/status windows to...
    										NULL );			//	out pointer to INmCall * to receive INmCall * generated by placing call...
		}
	}

	return( result );

}	//	End of CNmManagerObj::ShellCalltoProtocolHandler.

//--------------------------------------------------------------------------//
//	CNmManagerObj::Launch.													//
//--------------------------------------------------------------------------//
STDMETHODIMP
CNmManagerObj::Launch()
{
	if(_Module.InitControlMode()) 
	{	
		return E_FAIL;
	}
	else
	{
		if(!g_pInternalNmManager)
		{
			if(!CheckRemoteControlService())
			{
				return E_FAIL;
			}

			InitConfExe();
		}
		else
		{
			::CreateConfRoomWindow();
		}
	}

	return S_OK;

}	//	End of CNmManagerObj::Launch.


LPTSTR StripDoubleQuotes(LPTSTR sz)
{
	BOOL    fSkippedQuote = FALSE;

	if (sz)
	{
		int     cchLength;

		// Skip past first quote
		if (fSkippedQuote = (*sz == '"'))
			sz++;

		cchLength = lstrlen(sz);

		//
		// NOTE:
		// There may be DBCS implications with this.  Hence we check to see
		// if we skipped the first quote; we assume that if the file name
		// starts with a quote it must end with one also.  But we need to check
		// it out.
		//
		// Strip last quote
		if (fSkippedQuote && (cchLength > 0) && (sz[cchLength - 1] == '"'))
		{
			BYTE * pLastQuote = (BYTE *)&sz[cchLength - 1];
			*pLastQuote = '\0';
		}
	}

	return sz;
}


STDMETHODIMP CNmManagerObj::LaunchApplet(NM_APPID appid, BSTR strCmdLine)
{
	USES_CONVERSION;

	if(!g_pInternalNmManager)
	{
		if(!CheckRemoteControlService())
		{
			return E_FAIL;
		}

		InitConfExe();
	}

	switch(appid)
	{
		case NM_APPID_WHITEBOARD:
			CmdShowOldWhiteboard(strCmdLine ? StripDoubleQuotes(OLE2T(strCmdLine)) : NULL);
			break;

		case NM_APPID_T126_WHITEBOARD:
			::CmdShowNewWhiteboard(strCmdLine ? StripDoubleQuotes(OLE2T(strCmdLine)) : NULL);
			break;

		case NM_APPID_CHAT:
			CmdShowChat();
			break;
	}

	return S_OK;
}


STDMETHODIMP CNmManagerObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	if(g_pNmSysInfo)
	{
		return g_pNmSysInfo->GetUserData(rguid, ppb, pcb);
	}

	return NM_E_NOT_ACTIVE;
}

STDMETHODIMP CNmManagerObj::SetUserData(REFGUID rguid, BYTE *pb, ULONG cb)
{
	//
	// Special case this guid to allow changing cert via SetUserData
	//
	if ( g_csguidSecurity == rguid )
	{
		return SetCertFromCertInfo ( (PCERT_INFO) pb );
	}
	if(g_pNmSysInfo)
	{
		return g_pNmSysInfo->SetUserData(rguid, pb, cb);
	}

	return NM_E_NOT_ACTIVE;
}

STDMETHODIMP CNmManagerObj::DisableH323(BOOL bDisableH323)
{
	if(!g_pInternalNmManager)
	{
		_Module.SetSDKDisableH323(bDisableH323);
		return S_OK;
	}

	return NM_E_ALREADY_RUNNING;
}

STDMETHODIMP CNmManagerObj::SetCallerIsRTC (BOOL bCallerIsRTC)
{
	if(!g_pInternalNmManager)
	{
		_Module.SetSDKCallerIsRTC(bCallerIsRTC);
		return S_OK;
	}

	return NM_E_ALREADY_RUNNING;
}

STDMETHODIMP CNmManagerObj::DisableInitialILSLogon(BOOL bDisable)
{
	if(!g_pInternalNmManager)
	{
		_Module.SetSDKDisableInitialILSLogon(bDisable);
		return S_OK;
	}

	return NM_E_ALREADY_RUNNING;
}

///////////////////////////////////////////////
// INmManagerNotify methods:
///////////////////////////////////////////////

STDMETHODIMP CNmManagerObj::NmUI(CONFN uNotify)
{
	DBGENTRY(CNmManagerObj::NmUI);
	HRESULT hr = S_OK;

		// We should not be sending other notifactions
	ASSERT(CONFN_NM_STARTED == uNotify);
	hr = Fire_NmUI(uNotify);

	DBGEXIT_HR(CNmManagerObj::NmUI,hr);
	return hr;
}

STDMETHODIMP CNmManagerObj::ConferenceCreated(INmConference *pInternalConference)
{
	DBGENTRY(CNmManagerOebj::ConferenceCreated);
	HRESULT hr = S_OK;

	CComPtr<INmConference> spConf;

	hr = CNmConferenceObj::CreateInstance(this, pInternalConference, &spConf);

	if(SUCCEEDED(hr))
	{
		spConf.p->AddRef();
		m_SDKConferenceObjs.Add(spConf.p);
		Fire_ConferenceCreated(spConf);

		if(!CFt::IsFtActive() && FileTransferNotifications())
		{
			CFt::StartNewConferenceSession();
		}
	}

	DBGEXIT_HR(CNmManagerObj::ConferenceCreated,hr);
	return hr;
}


STDMETHODIMP CNmManagerObj::CallCreated(INmCall *pInternalCall)
{
	DBGENTRY(CNmManagerObj::CallCreated);
	HRESULT hr = S_OK;

	if(m_bInitialized)
	{
		if(NULL == GetSDKCallFromInternalCall(pInternalCall))
		{	
			// First we make sure that we don't have the call object yet
			CComPtr<INmCall> spCall;
			hr = CNmCallObj::CreateInstance(this, pInternalCall, &spCall);		

			if(SUCCEEDED(hr))
			{
				spCall.p->AddRef();
				m_SDKCallObjs.Add(spCall.p);
				Fire_CallCreated(spCall);
			}
		}
	}

	DBGEXIT_HR(CNmManagerObj::CallCreated,hr);
	return hr;
}


///////////////////////////////////////////////
// Notifications
///////////////////////////////////////////////

HRESULT CNmManagerObj::Fire_ConferenceCreated(INmConference *pConference)
{
	DBGENTRY(CNmManagerObj::Fire_ConferenceCreated);
	HRESULT hr = S_OK;

		// Som SDK clients need this to come in at a specific time....
	if(m_bSentConferenceCreated || OfficeMode() && g_bOfficeModeSuspendNotifications)
	{
			// We don't have to notify anyone at all...
		return S_OK;			
	}

	if(!g_bSDKPostNotifications)
	{
		IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;

		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			m_bSentConferenceCreated = true;

			INmManagerNotify* pNotify = reinterpret_cast<INmManagerNotify*>(pCP->m_vec.GetAt(i));

			if(pNotify)
			{
				pNotify->ConferenceCreated(pConference);

							// Sinc up the channels, etc.
				com_cast<IInternalConferenceObj>(pConference)->FireNotificationsToSyncToInternalObject();

			}
		}
	}
	else
	{
		hr = CSDKWindow::PostConferenceCreated(this, pConference);
	}

	DBGEXIT_HR(CNmManagerObj::Fire_ConferenceCreated,hr);
	return hr;		
}

HRESULT CNmManagerObj::Fire_CallCreated(INmCall* pCall)
{
	DBGENTRY(CNmManagerObj::Fire_CallCreated);
	HRESULT hr = S_OK;

		// Always send Outgoing call notifications
		// Only send incoming call notifications to INIT CONTROL clients.
	if((S_OK != pCall->IsIncoming()) || _Module.InitControlMode())
	{
		if(!g_bSDKPostNotifications)
		{
			IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;

			for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
			{
				INmManagerNotify* pNotify = reinterpret_cast<INmManagerNotify*>(pCP->m_vec.GetAt(i));

				if(pNotify)
				{
					pNotify->CallCreated(pCall);
				}
			}
		}
		else
		{
			hr = CSDKWindow::PostCallCreated(this, pCall);	
		}
	}

	DBGEXIT_HR(CNmManagerObj::Fire_CallCreated,hr);
	return hr;		
}


HRESULT CNmManagerObj::Fire_NmUI(CONFN uNotify)
{
	DBGENTRY(CNmManagerObj::Fire_NmUI);
	HRESULT hr = S_OK;

		// notice the InSendMessage statement.
		// The problem is that we can get this notificaiton in
		// response to the taskbar icon being clicked. In that case
		// an inter-thread SendMessage is occuring.  If we try to make
		// the NmUi call, we will get RPC_E_CANTCALLOUT_INPUTSYNCCALL
	if(!g_bSDKPostNotifications && !InSendMessage())
	{
		IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>* pCP = this;

		for(int i = 0; i < pCP->m_vec.GetSize(); ++i )
		{
			
			INmManagerNotify* pNotify = reinterpret_cast<INmManagerNotify*>(pCP->m_vec.GetAt(i));
			if(pNotify)
			{
				pNotify->NmUI(uNotify);
			}
		}
	}
	else
	{
		hr = CSDKWindow::PostManagerNmUI(this, uNotify);
	}

	DBGEXIT_HR(CNmManagerObj::Fire_NmUI,hr);
	return hr;		
}



///////////////////////////////////////////////
// Helper Fns
///////////////////////////////////////////////

INmConference* CNmManagerObj::_GetActiveConference()
{
	INmConference* pConf = NULL;

	if(m_SDKConferenceObjs.GetSize())
	{
		pConf = m_SDKConferenceObjs[0];
	}

	return pConf;
}
	


INmCall* CNmManagerObj::GetSDKCallFromInternalCall(INmCall* pInternalCall)
{

	INmCall* pRet = NULL;

	for( int i = 0; i < m_SDKCallObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalCallObj> spInternal = m_SDKCallObjs[i];
		ASSERT(spInternal);

		CComPtr<INmCall> spCall;
		if(SUCCEEDED(spInternal->GetInternalINmCall(&spCall)))
		{
			if(spCall.IsEqualObject(pInternalCall))
			{
				pRet = m_SDKCallObjs[i];
				break;
			}
		}
	}

	return pRet;
}

INmConference* CNmManagerObj::GetSDKConferenceFromInternalConference(INmConference* pInternalConference)
{

	INmConference* pRet = NULL;

	for( int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		CComQIPtr<IInternalConferenceObj> spInternal = m_SDKConferenceObjs[i];
		ASSERT(spInternal);

		CComPtr<INmConference> spConference;
		if(SUCCEEDED(spInternal->GetInternalINmConference(&spConference)))
		{
			if(spConference.IsEqualObject(pInternalConference))
			{
				pRet = m_SDKConferenceObjs[i];
				break;
			}
		}
	}

	return pRet;
}

HRESULT CNmManagerObj::RemoveCall(INmCall* pSDKCallObj)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < m_SDKCallObjs.GetSize(); ++i)
	{
		CComPtr<INmCall> spSDKCallObj = m_SDKCallObjs[i];
		if(spSDKCallObj.IsEqualObject(pSDKCallObj))
		{
			m_SDKCallObjs.RemoveAt(i);
			spSDKCallObj.p->Release();
		}
	}

	return hr;
}


HRESULT CNmManagerObj::RemoveConference(INmConference* pSDKConferenceObj)
{
	HRESULT hr = S_OK;
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		CComPtr<INmConference> spSDKConferenceObj = m_SDKConferenceObjs[i];
		if(spSDKConferenceObj.IsEqualObject(pSDKConferenceObj))
		{
			m_SDKConferenceObjs.RemoveAt(i);
			spSDKConferenceObj.p->Release();
		}
	}

	return hr;
}

bool CNmManagerObj::AudioNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_AUDIO);
}

bool CNmManagerObj::VideoNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_VIDEO);
}

bool CNmManagerObj::DataNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_DATA);
}

bool CNmManagerObj::FileTransferNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_FT);
}

bool CNmManagerObj::AppSharingNotifications()
{
	return m_bInitialized && (m_chCaps & NMCH_SHARE);
}



//static 
void CNmManagerObj::NetMeetingLaunched()
{
	ASSERT(ms_pManagerObjList);

	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->Fire_NmUI(CONFN_NM_STARTED);
		}
	}
}


//static 
void CNmManagerObj::SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_SharableAppStateChanged(hWnd, state);
		}
	}
}


void CNmManagerObj::_SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state)
{
		// Free our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->SharableAppStateChanged(hWnd, state);
	}
}

//static 
void CNmManagerObj::AppSharingChannelChanged()
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_AppSharingChannelChanged();
		}
	}
}

void CNmManagerObj::_AppSharingChannelChanged()
{
		// Free our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->AppSharingChannelChanged();
	}
}

//static 
void CNmManagerObj::AppSharingChannelActiveStateChanged(bool bActive)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_AppSharingChannelActiveStateChanged(bActive);
		}
	}
}


void CNmManagerObj::_AppSharingChannelActiveStateChanged(bool bActive)
{
		// Free our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->AppSharingStateChanged(bActive);
	}
}

//static 
void CNmManagerObj::ASLocalMemberChanged()
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_ASLocalMemberChanged();
		}
	}
}

void CNmManagerObj::_ASLocalMemberChanged()
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->ASLocalMemberChanged();
	}	
}

//static
void CNmManagerObj::ASMemberChanged(UINT gccID)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_ASMemberChanged(gccID);
		}
	}
}

void CNmManagerObj::_ASMemberChanged(UINT gccID)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->ASMemberChanged(gccID);
	}	
}

// static
void CNmManagerObj::AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_AudioChannelActiveState(bActive, bIsIncoming);
		}
	}
}

void CNmManagerObj::_AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->AudioChannelActiveState(bActive ? TRUE : FALSE, bIsIncoming);
	}	
}

// static
void CNmManagerObj::VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_VideoChannelActiveState(bActive, bIsIncoming);
		}
	}
}

void CNmManagerObj::_VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->VideoChannelActiveState(bActive ? TRUE : FALSE, bIsIncoming);
	}	
}

// static
void CNmManagerObj::VideoPropChanged(DWORD dwProp, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_VideoPropChanged(dwProp, bIsIncoming);
		}
	}
}

void CNmManagerObj::_VideoPropChanged(DWORD dwProp, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->VideoChannelPropChanged(dwProp, bIsIncoming);
	}	
}

// static
void CNmManagerObj::VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming)
{
	if(ms_pManagerObjList)
	{
		for( int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
		{
			(*ms_pManagerObjList)[i]->_VideoChannelStateChanged(uState, bIsIncoming);
		}
	}
}

void CNmManagerObj::_VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming)
{
		// notify our conferencing objects
	for(int i = 0; i < m_SDKConferenceObjs.GetSize(); ++i)
	{
		com_cast<IInternalConferenceObj>(m_SDKConferenceObjs[i])->VideoChannelStateChanged(uState, bIsIncoming);
	}	
}

UINT CNmManagerObj::GetManagerCount(ULONG uOption)
{
	UINT nMgrs = 0;
	for(int i = 0; i < ms_pManagerObjList->GetSize(); ++i)
	{
		if(uOption == (*ms_pManagerObjList)[i]->m_uOptions)
		{
			nMgrs++;
		}
	}
	return nMgrs;
}

void CNmManagerObj::OnShowUI(BOOL fShow)
{
	_Module.SetUIVisible(fShow);

	if (fShow)
	{
		CConfMan::AllowAV(TRUE);
	}
	else
	{
		if(0 != GetManagerCount(NM_INIT_OBJECT))
		{
			CConfMan::AllowAV(FALSE);
		}
	}
}

HRESULT CNmManagerObj::SdkPlaceCall(NM_CALL_TYPE callType,
						 NM_ADDR_TYPE addrType,
						 BSTR bstrAddr,
						 BSTR bstrConf,
						 BSTR bstrPw,
						 INmCall **ppInternalCall)
{
	USES_CONVERSION;

	HRESULT hr;

	DWORD dwFlags = MapNmCallTypeToCallFlags(callType, addrType, g_uMediaCaps);
	if (0 == dwFlags)
	{
		hr = NM_CALLERR_MEDIA;
		goto end;
	}

	{
		if(NM_ADDR_T120_TRANSPORT == addrType)
		{
			//
			// Check if  "+secure=true" parameter was passed
			//
			LPTSTR          szAddr = NULL;
			CCalltoParams   params;
			bool            bSecure = FALSE;

		    if(SUCCEEDED(BSTR_to_LPTSTR(&szAddr, bstrAddr)))
		    {
		        ASSERT(NULL != szAddr);
		        
    			params.SetParams(szAddr);
    			bSecure = params.GetBooleanParam(TEXT("secure"), bSecure);

    			//
    			// Yes it was in the parameters.
    			// Now make sure to remove it
    			// The addre now is like "111.222.333.444+secure=true"
    			// The call will only work if we pass the ip address only
    			//
    			if(bSecure)
    			{

    				// Get the syze of the bstr
    				int cch = SysStringByteLen(bstrAddr);
    				BYTE *pByte = (BYTE *) bstrAddr;

    				for(int i = 0; i < cch;i++)
    				{
    					// Null terminate the string
    					if(*pByte == '+')
    					{
    						*pByte = '\0';
    						break;
    					}
    					pByte++;
    				}
    				
    				
    				dwFlags |= CRPCF_SECURE;
    			}

    			delete [] szAddr;
		    }
		}
		
		CCallResolver  CallResolver(OLE2T(bstrAddr), addrType);
		hr = CallResolver.Resolve();
		if (FAILED(hr))
		{
			goto end;
		}

		CCall* pCall = new CCall(CallResolver.GetPszAddr(), OLE2T(bstrAddr), NM_ADDR_CALLTO, FALSE, FALSE);

		if(NULL == pCall)
		{
			goto end;
		}

		pCall->AddRef();
		switch(CallResolver.GetAddrType())
		{
			case NM_ADDR_ULS:
			case NM_ADDR_IP:
			case NM_ADDR_MACHINENAME:
			case NM_ADDR_H323_GATEWAY:
				ASSERT(FIpAddress(CallResolver.GetPszAddrIP()));
				/////////////////////////////////////////////
				// !!!!! HEY RYAN, WERE FALLING THROUGH !!!!!
				/////////////////////////////////////////////
			case NM_ADDR_T120_TRANSPORT:
				hr = pCall->PlaceCall(
						dwFlags, // dwFlags
						CallResolver.GetAddrType(), // addrType
						NULL,	// szSetup
						(NM_ADDR_T120_TRANSPORT == CallResolver.GetAddrType()) ?
							CallResolver.GetPszAddr() :
							CallResolver.GetPszAddrIP(), // szDestination
						CallResolver.GetPszAddr(),// szAlias
						NULL,				// szURL
						OLE2T(bstrConf),	// szConference
						OLE2T(bstrPw),		// szPassword
						NULL);				// szUserData
				break;

			default:
				ERROR_OUT(("Don't know this call type"));
				ASSERT(0);
				break;
		}

		if( FAILED(hr) && (pCall->GetState() == NM_CALL_INVALID ) )
		{
			// just release the call to free the data
			// otherwise wait for the call state to be changed
			pCall->Release();
		}

		if(ppInternalCall && SUCCEEDED(hr))
		{
			*ppInternalCall = pCall->GetINmCall();
			(*ppInternalCall)->AddRef();
		}

		pCall->Release();
	}

end:

	if( FAILED( hr ) && _Module.IsUIActive() )
	{
		DisplayCallError( hr, OLE2T( bstrAddr ) );
	}

	return hr;
}


DWORD CNmManagerObj::MapNmCallTypeToCallFlags(NM_CALL_TYPE callType, NM_ADDR_TYPE addrType, UINT uCaps)
{
	DWORD dwFlags = 0;
    BOOL fForceSecure = FALSE;

	// Check global conference status
	if (INmConference *pConf = ::GetActiveConference())
	{
		// We are in a conference.  Use the conference security setting.
		DWORD dwCaps;

		if ((S_OK == pConf->GetNmchCaps(&dwCaps)) &&
			(NMCH_SECURE & dwCaps))
		{
			fForceSecure = TRUE;
		}
	}
	else
	{
	    fForceSecure = (REQUIRED_POL_SECURITY == ConfPolicies::GetSecurityLevel());
	}

	switch(addrType)
	{
		case NM_ADDR_T120_TRANSPORT:
			dwFlags = CRPCF_T120 | CRPCF_DATA;

			if(ConfPolicies::OutgoingSecurityPreferred() || fForceSecure)
			{
				dwFlags |= CRPCF_SECURE;
			}

			break;

		default:
			switch (callType)
			{
				case NM_CALL_T120:
					if (fForceSecure)
					{
						dwFlags = CRPCF_T120 | CRPCF_DATA | CRPCF_SECURE;
					}
					else
					{
						dwFlags = CRPCF_T120 | CRPCF_DATA;
					}
					break;

				case NM_CALL_H323:
					if (!fForceSecure)
					{
						dwFlags = CRPCF_H323CC;
						if (uCaps & (CAPFLAG_RECV_AUDIO | CAPFLAG_SEND_AUDIO))
							dwFlags |= CRPCF_AUDIO;
						if (uCaps & (CAPFLAG_RECV_VIDEO | CAPFLAG_SEND_VIDEO))
							dwFlags |= CRPCF_VIDEO;
					}
					break;

				case NM_CALL_DEFAULT:
					if (fForceSecure)
					{
						dwFlags = CRPCF_T120 | CRPCF_DATA | CRPCF_SECURE;
					}
					else
					{
						dwFlags = CRPCF_DEFAULT;
						// strip AV if policies prohibit
						if((uCaps & (CAPFLAG_RECV_AUDIO |CAPFLAG_SEND_AUDIO)) == 0)
						{
							dwFlags &= ~CRPCF_AUDIO;
						}
						if((uCaps & (CAPFLAG_RECV_VIDEO |CAPFLAG_SEND_VIDEO)) == 0)
						{
							dwFlags &= ~CRPCF_VIDEO;
						}
					}
					break;

				default:
					dwFlags = 0;
					break;
			}
	}

	return dwFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmmanager.h ===
#ifndef __NmManager_h__
#define __NmManager_h__

#include "resource.h"       // main symbols
#include "SDKInternal.h"
#include "ias.h"
#include "iplgxprt.h"
#include "it120xprt.h"

extern bool g_bSDKPostNotifications;


/////////////////////////////////////////////////////////////////////////////
// CNmManagerObj
class ATL_NO_VTABLE CNmManagerObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmManagerObj, &CLSID_NmManager>,
	public IConnectionPointContainerImpl<CNmManagerObj>,
	public IConnectionPointImpl<CNmManagerObj, &IID_INmManagerNotify, CComDynamicUnkArray>,
	public INmManager,
	public INmObject,
	public INmManagerNotify,
	public IInternalConfExe,
	public IPluggableTransport

{
	friend class CNmConferenceObj;
// Datatypes and constants
	CONSTANT(MSECS_PER_SEC_CPU_USAGE = 900);

// Static Data
	static CSimpleArray<CNmManagerObj*>*	ms_pManagerObjList;
	static DWORD							ms_dwID;

// Member Data
	bool									m_bNmActive;
	bool									m_bInitialized;
	ULONG									m_uOptions;
	ULONG									m_chCaps;
	CSimpleArray<INmConference*>			m_SDKConferenceObjs;
	CSimpleArray<INmCall*>					m_SDKCallObjs;
	CComPtr<INmManager2>					m_spInternalNmManager;
	DWORD									m_dwInternalNmManagerAdvise;
	bool									m_bSentConferenceCreated;
	DWORD									m_dwID;
	DWORD									m_dwSysInfoID;


	CComBSTR	m_bstrConfName;

    static IT120PluggableTransport          *ms_pT120Transport;
	
public:

#ifdef ENABLE_UPDATE_CONNECTION
    static IPluggableTransportNotify        *ms_pPluggableTransportNotify;
#endif

	static HRESULT InitSDK();
	static void CleanupSDK();

// Because this is in a local server, we are not going to be able to be aggregated...
DECLARE_NOT_AGGREGATABLE(CNmManagerObj)

// This is the resource ID for the .rgs file
DECLARE_REGISTRY_RESOURCEID(IDR_NMMANAGER)

BEGIN_COM_MAP(CNmManagerObj)
	COM_INTERFACE_ENTRY(INmManager)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(INmObject)
	COM_INTERFACE_ENTRY(INmManagerNotify)
	COM_INTERFACE_ENTRY(IInternalConfExe)
	COM_INTERFACE_ENTRY(IPluggableTransport)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmManagerObj)
	CONNECTION_POINT_ENTRY(IID_INmManagerNotify)
END_CONNECTION_POINT_MAP()


///////////////////////////////////////////////
// Construction and destruction

	CNmManagerObj();
	~CNmManagerObj();

	HRESULT FinalConstruct();
	void FinalRelease();

	ULONG InternalRelease();

///////////////////////////////////////////////
// INmManager

	STDMETHOD(Initialize)( ULONG * puOptions, ULONG * puchCaps);
	STDMETHOD(GetSysInfo)(INmSysInfo **ppSysInfo);
	STDMETHOD(CreateConference)(INmConference **ppConference, BSTR bstrName, BSTR bstrPassword, ULONG uchCaps);
	STDMETHOD(EnumConference)(IEnumNmConference **ppEnum);
	STDMETHOD(CreateCall)(INmCall **ppCall, NM_CALL_TYPE callType,NM_ADDR_TYPE addrType, BSTR bstrAddr, INmConference *pConference);
	STDMETHOD(CallConference)(INmCall **ppCall, NM_CALL_TYPE callType,NM_ADDR_TYPE uType, BSTR bstrAddr, BSTR bstrConferenceName, BSTR bstrPassword);
	STDMETHOD(EnumCall)(IEnumNmCall **ppEnum);

// INmObject
	STDMETHOD(CallDialog)(long hwnd, int cdOptions);
	STDMETHOD(ShowLocal)(NM_APPID id);
	STDMETHOD(VerifyUserInfo)(UINT_PTR hwnd, NM_VUI options);

// IInternalConfExe
	STDMETHOD(LoggedIn)();
	STDMETHOD(IsRunning)();
	STDMETHOD(InConference)();
	STDMETHOD(LDAPLogon)(BOOL bLogon);
	STDMETHOD(GetLocalCaps)(DWORD* pdwLocalCaps);
	STDMETHOD(IsNetMeetingRunning)();
	STDMETHOD(GetActiveConference)(INmConference** ppConf);
	STDMETHOD(ShellCalltoProtocolHandler)(BSTR url, BOOL bStrict);
	STDMETHOD(Launch)();
	STDMETHOD(LaunchApplet)(NM_APPID appid, BSTR strCmdLine);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
    STDMETHOD(SetUserData)(REFGUID rguid, BYTE *pb, ULONG cb);
	STDMETHOD(SetSysInfoID)(DWORD dwID) { m_dwSysInfoID = dwID; return S_OK; }
	STDMETHOD(DisableH323)(BOOL bDisableH323);
	STDMETHOD(SetCallerIsRTC)(BOOL bCallerIsRTC);
	STDMETHOD(DisableInitialILSLogon)(BOOL bDisableH323);

//
// INmManagerNotify methods:
//
    STDMETHOD(NmUI)(CONFN uNotify);
    STDMETHOD(ConferenceCreated)(INmConference *pInternalConference);
    STDMETHOD(CallCreated)(INmCall *pInternalCall);

//
// IPluggableTransport
//
    STDMETHOD(CreateConnection)(
                    BSTR               *pbstrConnectionID,      // For placing a call and closing connection
                    PLUGXPRT_CALL_TYPE  eCaller,                // Caller or Callee
                    DWORD               dwProcessID,            // Used for DuplicateHandle
                    HCOMMDEV            hCommLink,              // Handle to communications file handle
                    HEVENT              hevtDataAvailable,      // Ready To Read event ( data avail )
                    HEVENT              hevtWriteReady,         // Ready To Write event 
                    HEVENT              hevtConnectionClosed,   // Connection closed ( unexpectedly???) 
                    PLUGXPRT_FRAMING    eFraming,               // framing of bits sent on link
                    PLUGXPRT_PARAMETERS *pParams                // OPTIONAL framing specific parameters
                );

#ifdef ENABLE_UPDATE_CONNECTION
    STDMETHOD(UpdateConnection)(
                    BSTR                bstrConnectionID,
                    DWORD               dwProcessID,            // Used for DuplicateHandle
                    HCOMMDEV            hCommLink               // Handle to communications file handle
                    ); 
#endif

    STDMETHOD(CloseConnection)(BSTR bstrConnectionID); 

    STDMETHOD(EnableWinsock)(void); 

    STDMETHOD(DisableWinsock)(void);

#ifdef ENABLE_UPDATE_CONNECTION
    STDMETHOD(AdvisePluggableTransport)(IPluggableTransportNotify *, DWORD *pdwCookie);

    STDMETHOD(UnAdvisePluggableTransport)(DWORD dwCookie);
#endif

//
// Notifications
//
	HRESULT Fire_NmUI(CONFN uNotify);
    HRESULT Fire_ConferenceCreated(INmConference *pConference);
	HRESULT Fire_CallCreated(INmCall* pCall);


	INmConference* GetSDKConferenceFromInternalConference(INmConference* pInternalConference);
	INmCall* GetSDKCallFromInternalCall(INmCall* pInternalCall);

	HRESULT RemoveCall(INmCall* pSDKCallObj);
	HRESULT RemoveConference(INmConference* pSDKConferenceObj);

	bool AudioNotifications();
	bool VideoNotifications();
	bool DataNotifications();
	bool FileTransferNotifications();
	bool AppSharingNotifications();
	bool OfficeMode() const  { return m_bInitialized && (NM_INIT_OBJECT == m_uOptions); }

	static void NetMeetingLaunched();

	static void AppSharingChannelChanged();
	void _AppSharingChannelChanged();

	static void AppSharingChannelActiveStateChanged(bool bActive);
	void _AppSharingChannelActiveStateChanged(bool bActive);

	static void SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state);
	void _SharableAppStateChanged(HWND hWnd, NM_SHAPP_STATE state);

	static void ASLocalMemberChanged();
	void _ASLocalMemberChanged();

	static void ASMemberChanged(UINT gccID);
	void _ASMemberChanged(UINT gccID);

	static void NM211_CONF_NM_STARTED(bool bConfStarted);

	static void AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming);
	void _AudioChannelActiveState(BOOL bActive, BOOL bIsIncoming);

	static void VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming);
	void _VideoChannelActiveState(BOOL bActive, BOOL bIsIncoming);

	static void OnShowUI(BOOL fShow);

	static UINT GetManagerCount() { return ms_pManagerObjList->GetSize(); };
	static UINT GetManagerCount(ULONG uOption);

	static void VideoPropChanged(DWORD dwProp, BOOL bIsIncoming);
	void _VideoPropChanged(DWORD dwProp, BOOL bIsIncoming);

	static void VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming);
	void _VideoChannelStateChanged(NM_VIDEO_STATE uState, BOOL bIsIncoming);

private:
///////////////////////////////////////////////
// Helper Fns

	INmConference* _GetActiveConference();

    void EnsureTransportInterface(void);
    static BOOL InitPluggableTransportSDK(void);
    static void CleanupPluggableTransportSDK(void);

	DWORD MapNmCallTypeToCallFlags(NM_CALL_TYPE callType,
				NM_ADDR_TYPE addrType, UINT uCaps);
	HRESULT SdkPlaceCall(NM_CALL_TYPE callType,
						 NM_ADDR_TYPE addrType,
						 BSTR bstrAddr,
						 BSTR bstrConf,
						 BSTR bstrPw,
						 INmCall **ppInternalCall);
};

#endif //__NmManager_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmldap.h ===
#ifndef __NmLdap_h__
#define __NmLdap_h__

#include <cstring.hpp>
#include	"ldap.h"

class CKeepAlive;


class CNmLDAP
{

private:

	typedef CSTRING string_type;

	enum eState {
		Uninitialized,
		Idle,			// Idle means we are not logged in, or connected
		Binding,		// We are waiting for bind_s to complete in helper thread
		Bound,			// The bind operation is complete
		AddingUser,		// We are waiting for the result to ldap_add
		UserAdded,		// ldap_add completed successfully
		SettingAppInfo, // We are waiting for result to ldap_modify( app attributes )
		ModifyingAttrs,	// We are waiting for result to ldap_modify( some attrs )
		LoggedIn,		// We are logged in to ldap server and m_ldap session is closed ( we are connectionless )
		LoggingOff		// We are waiting for result to ldap_delete
	};

	enum eCurrentOp {
		Op_NoOp,				// We are not in the middle of multi-state operation
		Op_Logon,				// Logon is: ldap_bind, ldap_add, ldap_modify
		Op_Logoff,				// Logoff is ldap_bind, ldap_delete
		Op_Refresh_Logoff,		// Refresh is ldap_bind, ldap_delete, ldap_unbind, Op_Logon
		Op_Modifying_InCallAttr,// Modify in-call attrs is ldap_bind, ldap_modify
	};

	enum eTimerEvent {
		PollForResultTimer = 666,	// This is the timer ID passed to WM_TIMER
		WaitForLogoffTimer
	};

	enum { RESULT_POLL_INTERVAL = 1000 };				// We poll ldap_result for this many milliseconds
	enum { LOGOFF_WAIT_INTERVAL = 5000 };				// Max amound of time we will wait for logof to complete in the destructor...
	
/////////////////////////////////////////////////
/// Data

    CKeepAlive *m_pKeepAlive;

	// This indicates weather we have loaded wldap32.dll and the ldap functions
	static bool ms_bLdapDLLLoaded;
	HWND		m_hWndHidden;			// Hidden window for handling WM_TIMER and custom messages
	eState		m_State;				// The current state we are in
	eCurrentOp	m_CurrentOp;			// The current multi-state operation we are performing
	LDAP*		m_pLdap;				// The current ldap session ( kept for multi-state and multi-state operations )
	INT			m_uMsgID;				// Current async operation message id ( or INVALID_MSG_ID )
	UINT_PTR	m_ResultPollTimer;	    // Timer ID given to us by SetTimer
	UINT_PTR	m_LogoffTimer;			
	HANDLE		m_hEventWaitForLogoffDone;	// We attempt to logoff asynchronously
	HANDLE		m_hBindThread;

	string_type m_strCurrentServer;		// If we are logged in, we are logged in to this server
	string_type m_strCurrentDN;			// If we are logged in, this is our current DN

		// User attributes
	string_type m_strServer;
	string_type m_strSurName;
	string_type m_strGivenName;
	string_type m_strEmailName;
	string_type m_strComment;
	string_type m_strLocation;
	string_type m_strSecurityToken;
	bool		m_bVisible;
	bool		m_bAudioHardware;
	bool		m_bVideoHardware;
	bool		m_bInCall;
	bool		m_bDirty;
	bool		m_bRefreshAfterBindCompletes;
	bool		m_bLogoffAfterBindCompletes;
	bool		m_bSendInCallAttrWhenDone;
	int			m_iPort;

public:

	CNmLDAP();
	~CNmLDAP();

	HRESULT Initialize(HINSTANCE hInst);				// Initialize the CNmLDAP object
	HRESULT LogonAsync(LPCTSTR pcszServer = NULL);		// Logon to the specified server ( or default if NULL )
	HRESULT Logoff();									// Logoff from the current surver
	HRESULT OnSettingsChanged();						// Refresh our information on the server
	HRESULT OnCallStarted();							// Update server information about our call state
	HRESULT OnCallEnded();								// Update server information about our call state
	bool IsLoggedOn() const;							// Are we logged on?
	bool IsLoggingOn() const;							// Are we logged on?
	bool IsBusy() const;								// Are we in the middle of an async operation?
	HRESULT GetStatusText(LPTSTR psz, int cch, UINT *idIcon=NULL) const;	// Status text for status bar for example

	// Static fns used for resolving users, etc.
	static HRESULT ResolveUser(LPCTSTR pcszName, LPCTSTR pcszServer, LPTSTR pszIPAddr, DWORD cchMax, int port = DEFAULT_LDAP_PORT);
	static bool IsInitialized() { return ms_bLdapDLLLoaded; }

private:

		// Window Procedure and helpers
	LRESULT WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static LRESULT _sWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	static DWORD _sAsyncBindThreadFn(LPVOID lpParameter);

	void _AddUser();
	void _DeleteUser();
	void _SetAppInfo();
	void _ModifyInCallAttr();
	HRESULT _BindAsync();
	HRESULT _bCallChangedHelper();
	HRESULT _GetUserSettingsFromRegistryAndGlobals();
	void _OnLoggedOn();
	void _OnLoggedOff();
	void _OnLoggingOn();
	void _OnLoggingOff();
	void _AbandonAllAndSetState(eState new_state);
	void _AbandonAllAndSetToIdle() { _AbandonAllAndSetState(Idle); }
    void _AbandonAllAndRecoverState(void) { _AbandonAllAndSetState((ModifyingAttrs == m_State && NULL != m_pKeepAlive) ? LoggedIn : Idle); }
    void _AbandonAllAndRecoverState(eCurrentOp op) { _AbandonAllAndSetState((Op_Modifying_InCallAttr == op && NULL != m_pKeepAlive) ? LoggedIn : Idle); }

	void _MakeStatusText(UINT uResID, LPTSTR psz, UINT cch) const;
	HRESULT _InternalLogoff(bool bRefreshLogoff);
	HRESULT _RefreshServer();
	void _OnAddingUserResult(int Result);
	void _OnSettingAppInfoOrModifyingAttrsResult(int Result);
	void _OnLoggingOffResult(int Result);
	void _OnUserBindComplete(INT LdapResult, DWORD LastError );
	void _OnTimer(UINT_PTR TimerID);
	void _GetIpAddressOfLdapSession( LPTSTR szIpAddr, int cchMax, DWORD *pdwIPAddr );

	static HRESULT _LoadLdapDLL();

    HRESULT OnReLogon(void);
};


void InitNmLdapAndLogon();

extern CNmLDAP* g_pLDAP;
extern CPing*	g_pPing;





enum { INITIAL_REFRESH_INTERVAL_MINUTES = 2 };		// Initial time before we send a message to the server to reset the TTL
enum { MIN_REFRESH_TIMEOUT_INTERVAL_MINUTES = 1 };	// Minimum timeout interval
enum { REFRESH_TIMEOUT_MARGIN = 2 };				// We send a refresh REFRESH_TIMEOUT_MARGIN minutes before the server TTL

enum { PING_TIMEOUT_INTERVAL = (10 * 1000) };		
enum { PING_RETRIES = 9 };

enum { LDAP_TIMEOUT_IN_SECONDS = 45 };


class CKeepAlive
{
    friend DWORD KeepAliveThreadProc(LPVOID);

public:

    // called in the main thread
    CKeepAlive(BOOL *pfRet, HWND hwndMainThread,
               DWORD dwLocalIPAddress,
               const TCHAR * const pcszServerName, UINT nPort,
               LPTSTR pszKeepAliveFilter);

    BOOL Start(void);
    BOOL End(BOOL fSync = FALSE);

protected:

    // called in the worker thread
    ~CKeepAlive(void);
    BOOL SetServerIPAddress(void);
    DWORD GetLocalIPAddress(LDAP *ld);
    BOOL Ping(void);
    BOOL Bind(LDAP *ld);
    BOOL KeepAlive(LDAP *ld, UINT *pnRefreshInterval);
    DWORD GetLocalIPAddress(void) { return m_dwLocalIPAddress; }
    void SetLocalIPAddress(DWORD dwLocalIPAddress) { m_dwLocalIPAddress = dwLocalIPAddress; }
    LPTSTR GetServerName(void) { return m_pszServerName; }
    DWORD GetServerIPAddress(void) { return m_dwServerIPAddress; }
    UINT GetServerPortNumber(void) { return m_nPort; }
    void UpdateIPAddressOnServer(void);

private:

    // called in the worker thread
    void GetNewInterval(LDAP *ld, LDAPMessage *pMsg, UINT *pnRefreshInternval);
    void ReLogon(void);

private:

    HWND        m_hwndMainThread;
    DWORD       m_dwLocalIPAddress;
    DWORD       m_dwServerIPAddress;
    LPTSTR      m_pszServerName;
    UINT        m_nPort;
    LPTSTR      m_pszKeepAliveFilter;
    HANDLE      m_hThread;
    DWORD       m_dwThreadID;
    BOOL        m_fAborted;
};


#endif // __NmLdap_h__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmres.h ===
// File: nmres.h

// Why isn't this defined in winres.h or winresrc.h?
#ifndef ACS_TIMER
#define ACS_TIMER 0x08
#endif


// this is only defined in the NT 5 build environment
#ifndef WS_EX_NOINHERIT_LAYOUT  
#define WS_EX_NOINHERIT_LAYOUT   0x00100000L
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmsharableapp.h ===
#ifndef __NmSharableApp_h__
#define __NmSharableApp_h__

class ATL_NO_VTABLE CNmSharableAppObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public INmSharableApp
{

protected:

		// Data
	HWND			m_hWnd;

public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmSharableAppObj)

BEGIN_COM_MAP(CNmSharableAppObj)
	COM_INTERFACE_ENTRY(INmSharableApp)
END_COM_MAP()

////////////////////////////////////////////////	
// Construction and destruction

	static HRESULT CreateInstance(HWND hWnd, 
								  LPCTSTR szName,
								  INmSharableApp** ppNmSharableApp);

    STDMETHOD(GetName)(BSTR *pbstrName);

    STDMETHOD(GetHwnd)(HWND * phwnd);

    STDMETHOD(GetState)(NM_SHAPP_STATE *puState);

    STDMETHOD(SetState)(NM_SHAPP_STATE uState);

};

#endif // __NmSharableApp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmsharableapp.cpp ===
#include "precomp.h"
#include "Confroom.h"

// SDK includes
#include "SDKInternal.h"
#include "NmChannel.h"
#include "NmChannelAppShare.h"
#include "NmSharableApp.h"

HRESULT CNmSharableAppObj::CreateInstance(HWND hWnd, 
										  LPCTSTR szName,
										  INmSharableApp** ppNmSharableApp)
{

	HRESULT hr = S_OK;

	CComObject<CNmSharableAppObj>* p = NULL;
	p = new CComObject<CNmSharableAppObj>(NULL);

	if (p != NULL)
	{
		if(SUCCEEDED(hr))
		{
			p->m_hWnd = hWnd;
		}

		if(ppNmSharableApp)
		{
			p->SetVoid(NULL);

			hr = p->QueryInterface(IID_INmSharableApp, reinterpret_cast<void**>(ppNmSharableApp));

			if(FAILED(hr))
			{
				delete p;
				*ppNmSharableApp = NULL;
			}
		}
		else
		{
			delete p;
			hr = E_POINTER;
		}
		
	}

	return hr;
}


STDMETHODIMP CNmSharableAppObj::GetName(BSTR *pbstrName)
{
	HRESULT hr = E_POINTER;

	if(pbstrName) 
	{
		TCHAR szName[MAX_PATH];
		hr = CNmChannelAppShareObj::GetSharableAppName(m_hWnd, szName, CCHMAX(szName));
		if(SUCCEEDED(hr))
		{
			*pbstrName = CComBSTR(szName).Copy();

			if(*pbstrName)
			{
				hr = S_OK;
			}
			else
			{
				hr = E_OUTOFMEMORY;	
			}

		}
	}
	return hr;	
}

STDMETHODIMP CNmSharableAppObj::GetHwnd(HWND * phwnd)
{
	HRESULT hr = E_POINTER;

	if(phwnd)
	{
		*phwnd = m_hWnd;
		hr = S_OK;
	}

	return hr;

}

STDMETHODIMP CNmSharableAppObj::GetState(NM_SHAPP_STATE *puState)
{
	HRESULT hr = E_POINTER;
	if(puState)
	{
		hr = ::GetWindowState(puState, m_hWnd);
	}
	
	return hr;

}

extern bool g_bSDKPostNotifications;

STDMETHODIMP CNmSharableAppObj::SetState(NM_SHAPP_STATE uState)
{
	HRESULT hr = E_UNEXPECTED;

	g_bSDKPostNotifications = true;

	if(NM_SHAPP_SHARED == uState)
	{
		hr = ::ShareWindow(m_hWnd);
	}
	else if(NM_SHAPP_NOT_SHARED == uState)
	{
		hr = ::UnShareWindow(m_hWnd);
	}

	g_bSDKPostNotifications = false;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmmember.h ===
#ifndef __NmMember_h__
#define __NmMember_h__

#include "NetMeeting.h"
class CNmConferenceObj;

/////////////////////////////////////////////////////////////////////////////
// CNmMemberObj
class ATL_NO_VTABLE CNmMemberObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public INmMember,
	public IInternalMemberObj
{

	CComPtr<INmMember>		m_spInternalINmMember;
	CNmConferenceObj*		m_pConferenceObj;
	bool					m_bIsSelf;


public:

DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNmMemberObj)

BEGIN_COM_MAP(CNmMemberObj)
	COM_INTERFACE_ENTRY(INmMember)
	COM_INTERFACE_ENTRY(IInternalMemberObj)
END_COM_MAP()


	CNmMemberObj();
	~CNmMemberObj();
	static HRESULT CreateInstance(CNmConferenceObj* pConfObj, INmMember* pInternalINmMember, INmMember** ppMember);


	// INmMember methods
	STDMETHOD(GetName)(BSTR *pbstrName);
	STDMETHOD(GetID)(ULONG * puID);
	STDMETHOD(GetNmVersion)(ULONG *puVersion);
	STDMETHOD(GetAddr)(BSTR *pbstrAddr, NM_ADDR_TYPE *puType);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(GetConference)(INmConference **ppConference);
	STDMETHOD(GetNmchCaps)(ULONG *puchCaps);
	STDMETHOD(GetShareState)(NM_SHARE_STATE *puState);
	STDMETHOD(IsSelf)(void);
	STDMETHOD(IsMCU)(void);
	STDMETHOD(Eject)(void);

	// IInternalMemberObj methods		
	STDMETHOD(GetInternalINmMember)(INmMember** ppMember);


};


#endif // __NmMember_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nr_ip.h ===
#ifndef NR_IP_INCLUDED
#define NR_IP_INCLUDED

#include "winsock.h"
#include "regentry.h"
#include "confreg.h"
#include "nrcommon.h"

// Below definitions from NetNameValidate for computer names
/*** Internal definitions ***/
/* NOTE - These should be defined globally */
#define CTRL_CHARS_STR	CTRL_CHARS_0 CTRL_CHARS_1 CTRL_CHARS_2 CTRL_CHARS_3
#define	CNLEN	15

#define CTRL_CHARS_0	    "\001\002\003\004\005\006\007"
#define CTRL_CHARS_1	"\010\011\012\013\014\015\016\017"
#define CTRL_CHARS_2	"\020\021\022\023\024\025\026\027"
#define CTRL_CHARS_3	"\030\031\032\033\034\035\036\037"

#define ILLEGAL_NAME_CHARS_STR	"\"/\\[]:|<>+=;,?" CTRL_CHARS_STR

extern DWORD ResolveIpName ( LPCSTR szName, LPBYTE lpResult,
	LPDWORD lpdwResult, LPSTR lpszDisplayName, LPDWORD lpdwDisplayName,
	BOOL fTypeKnown, DWORD dwFlags, LPUINT puRequest, PASR pAsr );

extern DWORD CheckIpName ( LPCSTR szName );

extern DWORD InitializeIp ( VOID );

extern DWORD DeinitializeIp ( VOID );

extern BOOL NEAR IsDottedDecimalIpAddress ( LPCSTR szName, LPSTR szOut );
extern BOOL NEAR IsDottedDNSAddress ( LPCSTR szName, LPSTR szOut );

#endif // NR_IP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nmmember.cpp ===
#include "precomp.h"
#include "confroom.h"

// NetMeeting SDK stuff
#include "SDKInternal.h"
#include "NmConference.h"
#include "NmMember.h"


/////////////////////////////////////////////////////////////////////////
// Construction and Destruction
/////////////////////////////////////////////////////////////////////////




CNmMemberObj::CNmMemberObj(): m_bIsSelf(false)
{
	DBGENTRY(CNmMemberObj::CNmMemberObj);
	DBGEXIT(CNmMemberObj::CNmMemberObj);
}

CNmMemberObj::~CNmMemberObj()
{
	DBGENTRY(CNmMemberObj::~CNmMemberObj);

	DBGEXIT(CNmMemberObj::~CNmMemberObj);
}

//static
HRESULT CNmMemberObj::CreateInstance(CNmConferenceObj* pConfObj, INmMember* pInternalINmMember, INmMember** ppMember)
{
	DBGENTRY(CNmMemberObj::CreateInstance);
	HRESULT hr = S_OK;

	CComObject<CNmMemberObj>* p = NULL;
	p = new CComObject<CNmMemberObj>(NULL);

	if (p != NULL)
	{
		if(SUCCEEDED(hr))
		{
			CNmMemberObj* pThis = static_cast<CNmMemberObj*>(p);

			pThis->m_spInternalINmMember = pInternalINmMember;
			pThis->m_pConferenceObj = pConfObj;

			pThis->m_bIsSelf = (pInternalINmMember && (S_OK == pInternalINmMember->IsSelf()));

			if(pThis != NULL)
			{
				pThis->SetVoid(NULL);

					// We do this so that we don't accidentally Release out of memory
				++pThis->m_dwRef;
				hr = pThis->FinalConstruct();
				--pThis->m_dwRef;

				if(hr == S_OK)
					hr = pThis->QueryInterface(IID_INmMember, reinterpret_cast<void**>(ppMember));
				if(FAILED(hr))
				{
					delete pThis;
				}
			}
			else
			{
				hr = E_UNEXPECTED;
			}

		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CNmMemberObj::CreateInstance,hr);
	return hr;
}


/////////////////////////////////////////////////////////////////////////
// INmMember methods
/////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmMemberObj::GetName(BSTR *pbstrName)
{
	DBGENTRY(CNmMemberObj::GetName);
	HRESULT hr = S_OK;
	
	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetName(pbstrName);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetName,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetID(ULONG * puID)
{
	DBGENTRY(CNmMemberObj::GetID);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetID(puID);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetID,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetNmVersion(ULONG *puVersion)
{
	DBGENTRY(CNmMemberObj::GetNmVersion);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		m_spInternalINmMember->GetNmVersion(puVersion);
	}
	else
	{
		hr = E_UNEXPECTED;
	}


	DBGEXIT_HR(CNmMemberObj::GetNmVersion,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetAddr(BSTR *pbstrAddr, NM_ADDR_TYPE *puType)
{
	DBGENTRY(CNmMemberObj::GetAddr);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetAddr(pbstrAddr, puType);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetAddr,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetUserData(REFGUID rguid, BYTE **ppb, ULONG *pcb)
{
	DBGENTRY(CNmMemberObj::GetUserData);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		m_spInternalINmMember->GetUserData(rguid, ppb, pcb);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetUserData,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetConference(INmConference **ppConference)
{
	DBGENTRY(CNmMemberObj::GetConference);
	HRESULT hr = S_OK;

	if(ppConference)
	{
		hr = E_FAIL;

		if(m_pConferenceObj)
		{
			IUnknown * pUnk = m_pConferenceObj->GetUnknown();
			if(SUCCEEDED(pUnk->QueryInterface(IID_INmConference, reinterpret_cast<void**>(ppConference))))
			{
				hr = S_OK;
			}
		}
	}
	else
	{
		hr = E_POINTER;
	}

	DBGEXIT_HR(CNmMemberObj::GetConference,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetNmchCaps(ULONG *puchCaps)
{
	DBGENTRY(CNmMemberObj::GetNmchCaps);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->GetNmchCaps(puchCaps);
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::GetNmchCaps,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::GetShareState(NM_SHARE_STATE *puState)
{
	DBGENTRY(CNmMemberObj::GetShareState);
	HRESULT hr = E_POINTER;

	if(puState)
	{		
		ULONG ulGCCId;
		hr = GetID(&ulGCCId);

		if(SUCCEEDED(hr))
		{
			hr = ::GetShareState(ulGCCId, puState);
		}
	}

	DBGEXIT_HR(CNmMemberObj::GetShareState,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::IsSelf(void)
{
	DBGENTRY(CNmMemberObj::IsSelf);
	HRESULT hr = S_OK;

	hr = m_bIsSelf ? S_OK : S_FALSE;

	DBGEXIT_HR(CNmMemberObj::IsSelf,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::IsMCU(void)
{
	DBGENTRY(CNmMemberObj::IsMCU);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->IsMCU();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::IsMCU,hr);
	return hr;
}

STDMETHODIMP CNmMemberObj::Eject(void)
{
	DBGENTRY(CNmMemberObj::Eject);
	HRESULT hr = S_OK;

	if(m_spInternalINmMember)
	{
		hr = m_spInternalINmMember->Eject();
	}
	else
	{
		hr = E_UNEXPECTED;
	}

	DBGEXIT_HR(CNmMemberObj::Eject,hr);
	return hr;
}

/////////////////////////////////////////////////////////////////////////
// IInternalMemberObj methods
/////////////////////////////////////////////////////////////////////////
STDMETHODIMP CNmMemberObj::GetInternalINmMember(INmMember** ppMember)
{
	DBGENTRY(CNmMemberObj::GetInternalINmMember);
	HRESULT hr = S_OK;

	ASSERT(ppMember);

	*ppMember = m_spInternalINmMember;
	(*ppMember)->AddRef();

	DBGEXIT_HR(CNmMemberObj::GetInternalINmMember,hr);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\nr_uls.h ===
#ifndef NR_ULS_INCLUDED
#define NR_ULS_INCLUDED

#include "nrcommon.h"

DWORD ResolveULSName ( LPCSTR szName, LPBYTE lpResult,
	LPDWORD lpdwResult, LPSTR lpszDisplayName, LPDWORD lpdwDisplayName,
	BOOL fTypeKnown, DWORD dwFlags, LPUINT puRequest, PASR pAsr );

DWORD CheckULSName ( LPCSTR szName );

DWORD InitializeULSNameRes();

#endif // NR_ULS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\particip.cpp ===
// File: particip.cpp

#include "precomp.h"
#include "resource.h"
#include "dshowdlg.h"

#include "rostinfo.h"
#include "upropdlg.h"  // for CmdProperties()
#include "confroom.h"  // for FTopProvider()
#include "cmd.h"
#include "particip.h"
#include "..\..\core\imember.h"   // for CNmMember (remove ASAP)
#include "certui.h"
#include "wabutil.h"
#include "ulswizrd.h"

GUID g_csguidSecurity = GUID_SECURITY;
GUID g_csguidMeetingSettings = GUID_MTGSETTINGS;

extern BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwCallFlags = CRPCF_DEFAULT,
			LPCTSTR pcszRemoteConfName = NULL, LPCTSTR pcszPassword = NULL,
			LPCTSTR pcszPathPrefix = NULL);

/*  C  P A R T I C I P A N T  */
/*-------------------------------------------------------------------------
    %%Function: CParticipant
    
-------------------------------------------------------------------------*/
CParticipant::CParticipant(INmMember * pMember) :
    m_pMember (pMember),
    m_pszName (NULL),
    m_dwGccId (0),
    m_fLocal  (FALSE),
    m_fAudio  (FALSE),
    m_fVideo  (FALSE),
    m_fData   (FALSE),
    RefCount  (NULL)
{
    HRESULT hr;
    ASSERT(NULL != m_pMember);
    m_pMember->AddRef();

    // Get the member's display name
    BSTR  bstr;
    hr = m_pMember->GetName(&bstr);
    if (SUCCEEDED(hr))
    {
        hr = BSTR_to_LPTSTR(&m_pszName, bstr);
        SysFreeString(bstr);
    }

    if (FEmptySz(m_pszName))
    {
        delete m_pszName;
        m_pszName = PszLoadString(IDS_UNKNOWN);
    }

    // These bits should never change
    m_fLocal = (m_pMember->IsSelf() == S_OK);
    m_fMcu = (m_pMember->IsMCU() == S_OK);

    // update all other fields
    Update();

    DbgMsg(iZONE_OBJECTS, "Obj: %08X created CParticipant", this);
}

CParticipant::~CParticipant()
{
    delete m_pszName;
    ASSERT(NULL != m_pMember);
    m_pMember->Release();

    DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CParticipant", this);
}

ULONG STDMETHODCALLTYPE CParticipant::AddRef(void)
{
    return RefCount::AddRef();
}
    
ULONG STDMETHODCALLTYPE CParticipant::Release(void)
{
    return RefCount::Release();
}


/*  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: Update

    Update the cached information about the participant
-------------------------------------------------------------------------*/
VOID CParticipant::Update(void)
{
    HRESULT hr = m_pMember->GetID(&m_dwGccId);
    ASSERT(SUCCEEDED(hr));

    ULONG nmchCaps;
    hr = m_pMember->GetNmchCaps(&nmchCaps);
    ASSERT(SUCCEEDED(hr));

    DWORD dwFlags = GetDwFlags();
    m_fData = dwFlags & PF_T120;
    m_fH323  = dwFlags & PF_H323;
    m_fAudio = dwFlags & PF_MEDIA_AUDIO;
    m_fVideo = dwFlags & PF_MEDIA_VIDEO;

    DWORD uCaps = GetDwCaps();
    m_fAudioBusy = uCaps & CAPFLAG_AUDIO_IN_USE;
    m_fVideoBusy = uCaps & CAPFLAG_VIDEO_IN_USE;
    m_fHasAudio = uCaps & CAPFLAG_SEND_AUDIO;
    m_fHasVideo = uCaps & CAPFLAG_SEND_VIDEO;
    m_fCanRecVideo = uCaps & CAPFLAG_RECV_VIDEO;

}

DWORD CParticipant::GetDwFlags(void)
{
    CNmMember * pMember = (CNmMember *) m_pMember;
    ASSERT(NULL != pMember);

    return pMember->GetDwFlags();
}

DWORD CParticipant::GetDwCaps(void)
{
    CNmMember * pMember = (CNmMember *) m_pMember;
    ASSERT(NULL != pMember);

    return pMember->GetCaps();
}


/*  E X T R A C T  U S E R  D A T A  */
/*-------------------------------------------------------------------------
    %%Function: ExtractUserData

    Extract the user data associated with the tag.
    Note: This function can be called with a length of 0 to determine
    if the data exists.
-------------------------------------------------------------------------*/
HRESULT CParticipant::ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey)
{
    CRosterInfo ri;
    HRESULT hr = ri.Load(((CNmMember *) m_pMember)->GetUserInfo());
    if (FAILED(hr))
        return hr;

    hr = ri.ExtractItem(NULL, pwszKey, psz, cchMax);
    return hr;
}

HRESULT CParticipant::GetIpAddr(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszIPTag);
}

HRESULT CParticipant::GetUlsAddr(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULSTag);
}

HRESULT CParticipant::GetEmailAddr(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULS_EmailTag);
}

HRESULT CParticipant::GetPhoneNum(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULS_PhoneNumTag);
}

HRESULT CParticipant::GetLocation(LPTSTR psz, UINT cchMax)
{
    return ExtractUserData(psz, cchMax, (PWSTR) g_cwszULS_LocationTag);
}


///////////////////////////////////////////////////////////////////////////
// Participant Commands

VOID CParticipant::OnCommand(HWND hwnd, WORD wCmd)
{
    switch (wCmd)
        {
    case IDM_POPUP_EJECT:
        CmdEject();
        break;

    case IDM_POPUP_PROPERTIES:
        CmdProperties(hwnd);
        break;

    case IDM_POPUP_SPEEDDIAL:
        CmdCreateSpeedDial();
        break;

    case IDM_POPUP_ADDRESSBOOK:
        CmdCreateWabEntry(hwnd);
        break;

    case IDM_POPUP_GIVECONTROL:
        CmdGiveControl();
        break;

    case IDM_POPUP_CANCELGIVECONTROL:
        CmdCancelGiveControl();
        break;

    default:
        ERROR_OUT(("CParticipant::OnCommand - Unknown command %08X", wCmd));
        break;
        } /* switch (wCmd) */
}


/*  C M D  E J E C T  */
/*-------------------------------------------------------------------------
    %%Function: CmdEject
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdEject(void)
{
    ASSERT(NULL != m_pMember);
    m_pMember->Eject();
}

BOOL CParticipant::FEnableCmdEject(void)
{
    if (FLocal())
        return FALSE; // can't eject ourselves

    if (!FData())
        return TRUE; // allow ejecting a/v-only users

    if (!::FTopProvider())
        return FALSE; // we must be the top provider

    return TRUE;
}



/*  C M D  S E N D  F I L E  */
/*-------------------------------------------------------------------------
    %%Function: CmdSendFile
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdSendFile(void)
{
}

BOOL CParticipant::FEnableCmdSendFile(void)
{
    // can't send to ourselves, an mcu, or someone without data caps
    if (FLocal() || FMcu() || !FData())
        return FALSE;

    return TRUE;
}



/*  C M D  C R E A T E  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: CmdCreateSpeedDial
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdCreateSpeedDial(void)
{
    TCHAR szAddr[MAX_PATH];
    HRESULT hr = GetUlsAddr(szAddr, CCHMAX(szAddr));
    if (FAILED(hr))
    {
        WARNING_OUT(("CParticipant::CmdCreateSpeedDial - Unable to obtain ULS address"));
        return;
    }

    ::FCreateSpeedDial(m_pszName, szAddr, NM_ADDR_ULS, CRPCF_DEFAULT, NULL, NULL, NULL);
}

BOOL CParticipant::FEnableCmdCreateSpeedDial(void)
{
    if (FLocal())
        return FALSE;

    return SUCCEEDED(GetUlsAddr(NULL, 0));
}


/*  C M D  C R E A T E  W A B  E N T R Y  */
/*-------------------------------------------------------------------------
    %%Function: CmdCreateWabEntry
    
-------------------------------------------------------------------------*/
void CParticipant::CmdCreateWabEntry(HWND hwnd)
{
	// get the email address
	TCHAR szEmail[MAX_EMAIL_NAME_LENGTH];
	if (S_OK != GetEmailAddr(szEmail, CCHMAX(szEmail)))
	{
		return;
	}

	// get the server/email address
	TCHAR szULS[MAX_EMAIL_NAME_LENGTH + MAX_SERVER_NAME_LENGTH + 1];
	if (S_OK != GetUlsAddr(szULS, CCHMAX(szULS)))
	{
		return;
	}

	// get the location
	TCHAR szLocation[MAX_LOCATION_NAME_LENGTH] = "";
	GetLocation(szLocation, CCHMAX(szLocation));

	// get the phone number
	TCHAR szPhone[MAX_PHONENUM_LENGTH] = "";
	GetPhoneNum(szPhone, CCHMAX(szPhone));

	CWABUTIL WabUtil;
	WabUtil.CreateWabEntry(hwnd, GetPszName(), szEmail,
				szLocation, szPhone, szULS);
}

BOOL CParticipant::FEnableCmdCreateWabEntry(void)
{
    if (FLocal())
        return FALSE;

    return SUCCEEDED(GetUlsAddr(NULL, 0));
}


/*  C M D  C O N T R O L  */
//
// CalcControlCmd()
//
// This puts the right string in the popup, and enables/disables the command
//
VOID CParticipant::CalcControlCmd(HMENU hPopup)
{
    UINT            iPos;
    UINT            cmd;
    UINT            flags;
    TCHAR           szItem[256];
    CConfRoom *     pcr;

    // Our item should 3rd to last.
    iPos = GetMenuItemCount(hPopup);
    ASSERT(iPos >= 3);
    iPos -= 3;

    cmd = GetMenuItemID(hPopup, iPos);
    ASSERT((cmd == IDM_POPUP_GIVECONTROL) || (cmd == IDM_POPUP_CANCELGIVECONTROL));

    flags = MF_GRAYED;
    cmd   = IDM_POPUP_GIVECONTROL;

    //
    // If we, the local dude, are a controllable host, then enable the command
    // if this person is in the share and of course not ourselves.
    //
    pcr = GetConfRoom();
    if (!m_fLocal && pcr && pcr->FIsControllable())
    {
        IAS_PERSON_STATUS status;

        // Get this person's share status
        pcr->GetPersonShareStatus(m_dwGccId, &status);

        if (status.InShare && (status.Version >= IAS_VERSION_30))
        {
            flags = MF_ENABLED;

            // Get local person's share status
            pcr->GetPersonShareStatus(0, &status);
            if (status.ControlledByPending == m_dwGccId)
            {
                cmd = IDM_POPUP_CANCELGIVECONTROL;
            }
        }
    }

    flags |= MF_STRING | MF_BYPOSITION;

    LoadString(::GetInstanceHandle(),
        ((cmd == IDM_POPUP_GIVECONTROL) ? IDS_COMMAND_GIVECONTROL : IDS_COMMAND_CANCELGIVECONTROL),
        szItem, CCHMAX(szItem));

    ModifyMenu(hPopup, iPos, flags, cmd, szItem);
}


//
// CmdGiveControl()
//
VOID CParticipant::CmdGiveControl(void)
{
    CConfRoom * pcr;

    if (pcr = GetConfRoom())
    {
        pcr->GiveControl(m_dwGccId);
    }
}


//
// CmdCancelGiveControl()
//
VOID CParticipant::CmdCancelGiveControl(void)
{
    CConfRoom * pcr;

    if (pcr = GetConfRoom())
    {
        pcr->CancelGiveControl(m_dwGccId);
    }
}



/*  C M D  P R O P E R T I E S  */
/*-------------------------------------------------------------------------
    %%Function: CmdProperties
    
-------------------------------------------------------------------------*/
VOID CParticipant::CmdProperties(HWND hwnd)
{
    CNmMember * pMember = (CNmMember *) m_pMember;
    ULONG uCaps = pMember->GetCaps();

    TCHAR szEmail[MAX_PATH];
    TCHAR szLocation[MAX_PATH];
    TCHAR szPhoneNum[MAX_PATH];
    TCHAR szVideo[256];
    TCHAR szAudio[256];
    TCHAR szSharing[256];
    TCHAR szControlFmt[256];
    TCHAR szControl[MAX_PATH];
    TCHAR szT[256];
    PCCERT_CONTEXT      pCert = NULL;
    CConfRoom *         pcr;
    IAS_PERSON_STATUS   status;
    UINT                ids;

    UPROPDLGENTRY rgUPDE[] = 
    {
        { IDS_UPROP_EMAIL,      szEmail },
        { IDS_UPROP_LOCATION,   szLocation },
        { IDS_UPROP_PHONENUM,   szPhoneNum },
        { IDS_UPROP_VIDEO,      szVideo },
        { IDS_UPROP_AUDIO,      szAudio },
        { IDS_UPROP_SHARING,    szSharing },
        { IDS_UPROP_CONTROL,    szControl }
    };

    szEmail[0] = _T('\0');
    szLocation[0] = _T('\0');
    szPhoneNum[0] = _T('\0');
    

    ::LoadString(::GetInstanceHandle(),
        (CAPFLAG_SEND_VIDEO & uCaps) ? IDS_HARDWARE_DETECTED : IDS_NO_HARDWARE_DETECTED,
        szVideo, CCHMAX(szVideo));

    ::LoadString(::GetInstanceHandle(),
        (CAPFLAG_SEND_AUDIO & uCaps) ? IDS_HARDWARE_DETECTED : IDS_NO_HARDWARE_DETECTED,
        szAudio, CCHMAX(szAudio));

    ExtractUserData(szEmail,   CCHMAX(szEmail),   (PWSTR) g_cwszULS_EmailTag);
    ExtractUserData(szLocation,    CCHMAX(szLocation),    (PWSTR) g_cwszULS_LocationTag);
    ExtractUserData(szPhoneNum, CCHMAX(szPhoneNum), (PWSTR) g_cwszULS_PhoneNumTag);

    //
    // Get sharing, control info.
    //
    ZeroMemory(&status, sizeof(status));
    status.cbSize = sizeof(status);
    if (pcr = GetConfRoom())
    {
        pcr->GetPersonShareStatus(m_dwGccId, &status);
    }

    //
    // Sharing
    //
    szSharing[0] = _T('\0');
    if (status.InShare)
    {
        if (status.AreSharing == IAS_SHARING_APPLICATIONS)
        {
            ids = IDS_SHARING_APPS;
        }
        else if (status.AreSharing == IAS_SHARING_DESKTOP)
        {
            ids = IDS_SHARING_DESKTOP;
        }
        else
        {
            ids = IDS_SHARING_NOTHING;
        }
    
        ::LoadString(::GetInstanceHandle(), ids, szSharing, CCHMAX(szSharing));
    }

    //
    // Control
    //
    szControl[0] = _T('\0');
    if (status.InShare)
    {
        if ((status.InControlOf) || (status.ControlledBy))
        {
            UINT            gccID;
            CParticipant *  pPart = NULL;

            if (status.InControlOf)
            {
                gccID = status.InControlOf;
                ids = IDS_CONTROL_INCONTROLOF;
            }
            else
            {
                gccID = status.ControlledBy;
                ids = IDS_CONTROL_CONTROLLEDBY;
            }

            if (pcr)
            {
                CSimpleArray<CParticipant*>& memberList = pcr->GetParticipantList();
                for (int i = 0; i < memberList.GetSize(); ++i)
                {
                    ASSERT(memberList[i]);
                    if (memberList[i]->GetGccId() == gccID)
                    {
                        pPart = memberList[i];
                        break;
                    }
                }
            }

            if (pPart)
            {
                lstrcpy(szT, pPart->GetPszName());
            }
            else
            {
                ::LoadString(::GetInstanceHandle(), IDS_UNKNOWN, szT, CCHMAX(szT));
            }

            ::LoadString(::GetInstanceHandle(), ids, szControlFmt, CCHMAX(szControlFmt));
            wsprintf(szControl, szControlFmt, szT);
        }
        else if (status.Controllable)
        {
            ::LoadString(::GetInstanceHandle(), IDS_CONTROL_CONTROLLABLE,
                szControl, CCHMAX(szControl));
        }
        else if (status.AreSharing)
        {
            ::LoadString(::GetInstanceHandle(), IDS_CONTROL_NOTCONTROLLABLE,
                szControl, CCHMAX(szControl));
        }
    }


    PBYTE pb = NULL;
    ULONG cb = 0;

    //
    // Certificate
    //
    if (pMember->GetUserData(g_csguidSecurity,&pb,&cb) == S_OK) {
        ASSERT(pb);
        ASSERT(cb);

        pCert = CertCreateCertificateContext ( X509_ASN_ENCODING, pb, cb);

        if ( NULL == pCert )
        {
            ERROR_OUT(("Error creating cert context from user data"));
        }
        CoTaskMemFree(pb);
    }


    CUserPropertiesDlg dlgUserProp(hwnd, IDI_LARGE);
    dlgUserProp.DoModal(rgUPDE, ARRAY_ELEMENTS(rgUPDE), m_pszName, pCert);
    if ( pCert )
        CertFreeCertificateContext ( pCert );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\passdlg.h ===
/****************************************************************************
*
*    FILE:     PassDlg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 1-25-96
*
****************************************************************************/

#ifndef _PASSDLG_H_
#define _PASSDLG_H_

#include <cstring.hpp>

class CPasswordDlg
{
protected:
	HWND		m_hwndParent;
	HWND		m_hwnd;

	CSTRING		m_strConfName;
	CSTRING		m_strPassword;
        CSTRING     m_strCert;
        BOOL        m_fRemoteIsRDS;

        static CSTRING *m_pstrUser;
        static CSTRING *m_pstrDomain;

	BOOL		ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

	// Handlers:
	BOOL		OnOk();

public:
	// Properties:

	LPCTSTR		GetPassword() { return (LPCTSTR) m_strPassword; };
	
	// Methods:
				CPasswordDlg(HWND hwndParent, LPCTSTR pcszConfName, LPCTSTR pCertText, BOOL fIsService);
	//			~CPasswordDlg();
	INT_PTR	DoModal();

	static INT_PTR CALLBACK PasswordDlgProc(	HWND hDlg,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);
        static BOOL          Init();
        static VOID          Cleanup();
};

#endif // _PASSDLG_H_








=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\particip.h ===
#ifndef _PARTICIP_H_
#define _PARTICIP_H_

#include "SDKInternal.h"

// BUGBUG:
// This is defined as 128 because the RNC_ROSTER structure has the
// same limitation.  Investigate what the appropriate number is.
const int MAX_PARTICIPANT_NAME = 128;

struct PARTICIPANT
{
	UINT	uID;
	UINT	uCaps;
	DWORD	dwFlags;
	PWSTR	pwszUserInfo;
	TCHAR	szName[MAX_PARTICIPANT_NAME];
};
typedef PARTICIPANT* PPARTICIPANT;



class CParticipant : public RefCount
{
private:
	INmMember * m_pMember;
	
	LPTSTR m_pszName;    // Display Name
	DWORD  m_dwGccId;    // GCC UserId
	BOOL   m_fLocal;     // True if local user
	BOOL   m_fMcu;       // True if local user
	BOOL   m_fAudio;     // audio is active
	BOOL   m_fVideo;     // video is active
	BOOL   m_fData;      // In T.120 connection
	BOOL   m_fH323;      // In H323 connection
	BOOL   m_fAudioBusy;   // CAPFLAG_AUDIO_IN_USE
	BOOL   m_fVideoBusy;   // CAPFLAG_VIDEO_IN_USE
	BOOL   m_fHasAudio;    // CAPFLAG_SEND_AUDIO
	BOOL   m_fHasVideo;    // CAPFLAG_SEND_VIDEO
	BOOL   m_fCanRecVideo; // CAPFLAG_RECV_VIDEO

public:
	CParticipant(INmMember * pMember);
	~CParticipant();

	// IUnknown methods
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

	VOID    Update(void);
	DWORD   GetDwFlags(void);
	DWORD   GetDwCaps(void);

	// Internal methods
	INmMember * GetINmMember()   {return m_pMember;}
	LPTSTR  GetPszName()         {return m_pszName;}
	BOOL    FLocal()             {return m_fLocal;}
	BOOL    FAudio()             {return m_fAudio;}
	BOOL    FVideo()             {return m_fVideo;}
	BOOL    FData()              {return m_fData;}
	BOOL    FMcu()               {return m_fMcu;}
	BOOL    FH323()              {return m_fH323;}
	BOOL	FAudioBusy()         {return m_fAudioBusy;}
	BOOL	FVideoBusy()         {return m_fVideoBusy;}
	BOOL	FHasAudio()          {return m_fHasAudio;}
	BOOL	FCanSendVideo()      {return m_fHasVideo;}
	BOOL    FCanRecVideo()       {return m_fCanRecVideo;}
	DWORD   GetGccId()           {return m_dwGccId;}

	HRESULT ExtractUserData(LPTSTR psz, UINT cchMax, PWSTR pwszKey);

	HRESULT GetIpAddr(LPTSTR psz, UINT cchMax);
	HRESULT GetUlsAddr(LPTSTR psz, UINT cchMax);
	HRESULT GetEmailAddr(LPTSTR psz, UINT cchMax);
	HRESULT GetPhoneNum(LPTSTR psz, UINT cchMax);
	HRESULT GetLocation(LPTSTR psz, UINT cchMax);

	VOID    OnCommand(HWND hwnd, WORD wCmd);

	// Commands
	VOID    CmdSendFile(void);
	BOOL    FEnableCmdSendFile(void);

	VOID    CmdEject(void);
	BOOL    FEnableCmdEject(void);

	VOID    CmdCreateSpeedDial(void);
	BOOL    FEnableCmdCreateSpeedDial(void);

	VOID    CmdCreateWabEntry(HWND hwnd);
	BOOL    FEnableCmdCreateWabEntry(void);

    VOID    CalcControlCmd(HMENU hPopup);
    VOID    CmdGiveControl(void);
    VOID    CmdCancelGiveControl(void);

	VOID    CmdProperties(HWND hwnd);
};

#endif // _PARTICIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfndrawd.h ===
// File: pfndrawd.h

#ifndef _PFNDRAWD_H_
#define _PFNDRAWD_H_

#include <vfw.h>

typedef HDRAWDIB (VFWAPI * PFN_DRAWDIBOPEN) ();

typedef BOOL (VFWAPI * PFN_DRAWDIBCLOSE) (HDRAWDIB hdd);

typedef BOOL (VFWAPI * PFN_DRAWDIBDRAW) (HDRAWDIB hdd,
	HDC hdc, int xDst, int yDst, int dxDst, int dyDst,
	LPBITMAPINFOHEADER lpbi, LPVOID lpBits,
	int xSrc, int ySrc, int dxSrc, int dySrc, UINT wFlags);

typedef BOOL (VFWAPI * PFN_DRAWDIBSETPALETTE) (HDRAWDIB hdd, HPALETTE hpal);


class DRAWDIB
{
private:
	static HINSTANCE m_hInstance;

protected:
	DRAWDIB() {};
	~DRAWDIB() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_DRAWDIBDRAW	     DrawDibDraw;
	static PFN_DRAWDIBOPEN	     DrawDibOpen;
	static PFN_DRAWDIBCLOSE      DrawDibClose;
	static PFN_DRAWDIBSETPALETTE DrawDibSetPalette;
};

#endif /* _PFNDRAWD_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\passdlg.cpp ===
// File: passdlg.cpp

#include "precomp.h"
#include "resource.h"
#include "PassDlg.h"
#include "help_ids.h"

#define USERSIZE        20
#define DOMAINSIZE      15
#define PASSWDSIZE      256

static const DWORD aHelpIdsPassword[] = {
	IDC_EDIT_PASSWORD,  IDH_ADV_PASSWORD,
	0, 0   // terminator
};


/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   CPasswordDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CPasswordDlg::CPasswordDlg(HWND hwndParent, LPCTSTR pcszConfName, LPCTSTR pCertText, BOOL fIsService):
	m_hwndParent(hwndParent),
        m_strConfName((LPCTSTR) pcszConfName),
        m_hwnd(NULL),
	m_fRemoteIsRDS(fIsService),
	m_strCert(pCertText)
{
	DebugEntry(CPasswordDlg::CPasswordDlg);

	DebugExitVOID(CPasswordDlg::CPasswordDlg);
}


/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CPasswordDlg::DoModal()
{
	DebugEntry(CPasswordDlg::DoModal);

	INT_PTR nRet = DialogBoxParam(	::GetInstanceHandle(),
                                        m_fRemoteIsRDS ? MAKEINTRESOURCE(IDD_PASSWORD_RDS): MAKEINTRESOURCE(IDD_PASSWORD),
                                        m_hwndParent,
                                        CPasswordDlg::PasswordDlgProc,
                                        (LPARAM) this);

	DebugExitINT_PTR(CPasswordDlg::DoModal, nRet);

	return nRet;
}

/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   PasswordDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CPasswordDlg::PasswordDlgProc(HWND hDlg,
                                            UINT uMsg,
                                            WPARAM wParam,
                                            LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;

	// uMsg may be any value.
	// wparam may be any value.
	// lparam may be any value.

	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				((CPasswordDlg*) lParam)->m_hwnd = hDlg;
				SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				// Set the conference name
                                if (((CPasswordDlg*) lParam)->m_fRemoteIsRDS)
                                {
                                    ::SetDlgItemText( hDlg, IDC_EDIT_RDS_CERT, ((CPasswordDlg*) lParam)->m_strCert);
                                    ::SendDlgItemMessage( hDlg, IDC_EDIT_USERNAME, EM_LIMITTEXT, (WPARAM) USERSIZE, 0);
                                    ::SendDlgItemMessage( hDlg, IDC_EDIT_PASSWORD, EM_LIMITTEXT, (WPARAM) PASSWDSIZE, 0);
                                    ::SendDlgItemMessage( hDlg, IDC_EDIT_DOMAIN, EM_LIMITTEXT, (WPARAM) DOMAINSIZE, 0);
                                    ::SetDlgItemText( hDlg, IDC_EDIT_USERNAME, *(m_pstrUser));
                                    ::SetDlgItemText( hDlg, IDC_EDIT_DOMAIN, *(m_pstrDomain));
                                }
                                else
                                {
                                    ::SetDlgItemText( hDlg, IDC_STATIC_CONFNAME, ((CPasswordDlg*) lParam)->m_strConfName);
                                }

				// Bring it to the foreground
				::SetForegroundWindow(hDlg);
			}

			bMsgHandled = TRUE;
			break;
		}

		default:
		{
			CPasswordDlg* ppd = (CPasswordDlg*) GetWindowLongPtr(	hDlg,
																DWLP_USER);

			if (NULL != ppd)
			{
				bMsgHandled = ppd->ProcessMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CPasswordDlg
*
*    MEMBER:   ProcessMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CPasswordDlg::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
		
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					bRet = OnOk();
					break;
				}

				case IDCANCEL:
				{
					EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

				case IDC_EDIT_PASSWORD:
				{
					if (!m_fRemoteIsRDS && EN_CHANGE == HIWORD(wParam))
					{
                                            BOOL fEnable = 0 != ::GetWindowTextLength(
                                                GetDlgItem(m_hwnd, IDC_EDIT_PASSWORD));
                                            ::EnableWindow(GetDlgItem(m_hwnd, IDOK), fEnable);
					}
					break;
				}

				case IDC_EDIT_USERNAME:
				{
					if (EN_CHANGE == HIWORD(wParam))
					{
						BOOL fEnable = 0 != ::GetWindowTextLength(
                                                    GetDlgItem(m_hwnd, IDC_EDIT_USERNAME));
						::EnableWindow(GetDlgItem(m_hwnd, IDOK), fEnable);
					}
					break;
				}
			}
			break;
		}
			
		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, aHelpIdsPassword);
			break;

		case WM_HELP:
			DoHelp(lParam, aHelpIdsPassword);
			break;

		default:
			break;
	}

	return bRet;
}

BOOL CPasswordDlg::OnOk()
{
	// BUGBUG: how long can a password be? - Remember to limit the edit control text
        TCHAR szBuf[256];
        TCHAR szUser[USERSIZE+1];
        TCHAR szDomain[DOMAINSIZE+1];

        if (m_fRemoteIsRDS)
        {
            if ( 0!= GetDlgItemText(m_hwnd, IDC_EDIT_USERNAME, szUser, CCHMAX(szUser)))
            {
                ASSERT(strlen(szUser));
                m_strPassword = szUser; // add user name
                m_strPassword += ":";
                if ( 0 != GetDlgItemText(m_hwnd, IDC_EDIT_DOMAIN, szDomain, CCHMAX(szDomain)))
                {
                    m_strPassword += szDomain;
                }
                else
                {
                    m_strPassword += ".";
                }
                m_strPassword += ":";
            }
            else
            {
                ERROR_OUT(("CPasswordDlg::OnOk - unable to get username"));
            }
            *(CPasswordDlg::m_pstrUser) = szUser;
            *(CPasswordDlg::m_pstrDomain) = szDomain;
        }

	if (0 != GetDlgItemText(m_hwnd, IDC_EDIT_PASSWORD, szBuf, CCHMAX(szBuf)))
	{
            m_strPassword += szBuf;    // add password
	}

        EndDialog(m_hwnd, IDOK);
	return TRUE;
}

BOOL CPasswordDlg::Init()
{
    if (0 == m_pstrDomain)
    {
        m_pstrDomain = new CSTRING;
        m_pstrUser = new CSTRING;
        if (NULL == m_pstrUser || NULL == m_pstrDomain)
        {
            ERROR_OUT(("CPassword::Init() -- failed to allocate memory"));
            return FALSE;
        }
    }
    return TRUE;
}

VOID CPasswordDlg::Cleanup()
{
    if (m_pstrDomain)
        delete m_pstrDomain;
    if (m_pstrUser)
        delete m_pstrUser;
}

CSTRING *CPasswordDlg::m_pstrDomain = NULL;
CSTRING *CPasswordDlg::m_pstrUser = NULL;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnsetupapi.h ===
// File: pfnsetupapi.h

#ifndef _PFNSETUPAPI_H_
#define _PFNSETUPAPI_H_

#include "setupapi.h"

typedef BOOL ( *PFN_SET_INSTALL)(HWND, HINF, LPCTSTR, UINT, HKEY, LPCTSTR, UINT, PSP_FILE_CALLBACK, PVOID, HDEVINFO, PSP_DEVINFO_DATA );
typedef HINF ( *PFN_SET_OPFILE)( LPCTSTR, LPCTSTR, DWORD, PUINT );
typedef VOID ( *PFN_SET_CLFILE)(  HINF );

class SETUPAPI
{
private:
	static HINSTANCE m_hInstance;

protected:
	SETUPAPI() {};
	~SETUPAPI() {};
	
public:
	static HRESULT Init(void);
	static void DeInit(void);
	
	static PFN_SET_INSTALL		SetupInstallFromInfSection;
	static PFN_SET_OPFILE	    SetupOpenInfFile;
	static PFN_SET_CLFILE		SetupCloseInfFile;
};

#endif /* _PFNSETUPAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfndrawd.cpp ===
// File: pfndrawd.cpp

#include "precomp.h"
#include "pfndrawd.h"

PFN_DRAWDIBDRAW	      DRAWDIB::DrawDibDraw = NULL;
PFN_DRAWDIBOPEN	      DRAWDIB::DrawDibOpen = NULL;
PFN_DRAWDIBCLOSE      DRAWDIB::DrawDibClose = NULL;
PFN_DRAWDIBSETPALETTE DRAWDIB::DrawDibSetPalette = NULL;

HINSTANCE DRAWDIB::m_hInstance = NULL;
#define DRAWDIB_APIFCN_ENTRY(pfn)  {(PVOID *) &DRAWDIB::##pfn, #pfn}

APIFCN s_apiFcnDrawDib[] = {
	DRAWDIB_APIFCN_ENTRY(DrawDibDraw),
	DRAWDIB_APIFCN_ENTRY(DrawDibOpen),
	DRAWDIB_APIFCN_ENTRY(DrawDibClose),
	DRAWDIB_APIFCN_ENTRY(DrawDibSetPalette),
};

HRESULT DRAWDIB::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnDrawDib, ARRAY_ELEMENTS(s_apiFcnDrawDib), &m_hInstance, TEXT("MSVFW32.DLL"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnsetupapi.cpp ===
// File: pfnsetupapi.cpp

#include "precomp.h"
#include "pfnsetupapi.h"

PFN_SET_INSTALL		SETUPAPI::SetupInstallFromInfSection = NULL;
PFN_SET_OPFILE	    SETUPAPI::SetupOpenInfFile = NULL;
PFN_SET_CLFILE		SETUPAPI::SetupCloseInfFile = NULL;
	
HINSTANCE SETUPAPI::m_hInstance = NULL;


#define SETUPAPI_APIFCN_ENTRYA(pfn)  {(PVOID *) &SETUPAPI::##pfn, #pfn ## "A"}
#define SETUPAPI_APIFCN_ENTRYW(pfn)  {(PVOID *) &SETUPAPI::##pfn, #pfn ## "A"}
#define SETUPAPI_APIFCN_ENTRYNONE(pfn)  {(PVOID *) &SETUPAPI::##pfn, #pfn }

#ifdef UNICODE
#define SETUPAPI_APIFCN_ENTRY SETUPAPI_APIFCN_ENTRYW
#else
#define SETUPAPI_APIFCN_ENTRY SETUPAPI_APIFCN_ENTRYA
#endif

APIFCN s_apiFcnSETUPAPI[] = {
	SETUPAPI_APIFCN_ENTRY(SetupInstallFromInfSection),
	SETUPAPI_APIFCN_ENTRY(SetupOpenInfFile),
	SETUPAPI_APIFCN_ENTRYNONE(SetupCloseInfFile)
};

HRESULT SETUPAPI::Init(void)
{
	if (NULL != SETUPAPI::m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnSETUPAPI, ARRAY_ELEMENTS(s_apiFcnSETUPAPI), &SETUPAPI::m_hInstance, TEXT("SETUPAPI.DLL"));
}

void SETUPAPI::DeInit(void)
{
	// TODO - why does the main thread die when I unload this?
	if( NULL != SETUPAPI::m_hInstance )
		FreeLibrary( SETUPAPI::m_hInstance );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnver.cpp ===
// File: pfnver.cpp

#include "precomp.h"
#include "pfnver.h"

#ifdef DEBUG

HINSTANCE DLLVER::m_hInstance = NULL;

PFN_GETVERINFOSIZE DLLVER::GetFileVersionInfoSize = NULL;
PFN_GETVERINFO     DLLVER::GetFileVersionInfo = NULL;
PFN_VERQUERYVAL    DLLVER::VerQueryValue = NULL;

#define DLLVER_APIFCN_ENTRY(pfn)  {(PVOID *) &DLLVER::##pfn, #pfn}

APIFCN s_apiFcnDllVer[] = {
	DLLVER_APIFCN_ENTRY(GetFileVersionInfoSize),
	DLLVER_APIFCN_ENTRY(GetFileVersionInfo),
	DLLVER_APIFCN_ENTRY(VerQueryValue),
};

HRESULT DLLVER::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnDllVer, ARRAY_ELEMENTS(s_apiFcnDllVer), &m_hInstance, TEXT("VERSION.dll"));
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnwldap.h ===
// File: pfnwldap.h

#ifndef _PFNWLDAP_H_
#define _PFNWLDAP_H_

#include <winldap.h>

// Why aren't these in winldap.h ?

typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_ABANDON)(LDAP *ld, ULONG msgid);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_BIND_S)(LDAP *ld, PCHAR dn, PCHAR cred, ULONG method);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_BIND)(LDAP *ld, PCHAR dn, PCHAR cred, ULONG method);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_ADD) (LDAP *ld, PCHAR dn, LDAPMod *attrs[]);


typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_SIMPLE_BIND_S)(LDAP *ld, PCHAR dn, PCHAR passwd);
typedef WINLDAPAPI PCHAR * (LDAPAPI * PFN_LDAP_GET_VALUES)(LDAP *ld, LDAPMessage *entry, PCHAR attr);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_MSGFREE)(LDAPMessage *res);
typedef WINLDAPAPI LDAP *  (LDAPAPI * PFN_LDAP_OPEN)(PCHAR HostName, ULONG PortNumber);
typedef WINLDAPAPI LDAP *  (LDAPAPI * PFN_LDAP_INIT)(PCHAR HostName, ULONG PortNumber);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_RESULT)(LDAP *ld, ULONG msgid, ULONG all, struct l_timeval *timeout, LDAPMessage **res);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_SET_OPTION)(LDAP *ld, int option, void *invalue);

typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_UNBIND)(LDAP *ld);
typedef WINLDAPAPI ULONG   (LDAPAPI * PFN_LDAP_VALUE_FREE)(PCHAR *vals);

typedef WINLDAPAPI LDAPMessage * (LDAPAPI * PFN_LDAP_FIRST_ENTRY)(LDAP *ld, LDAPMessage *res);
typedef WINLDAPAPI LDAPMessage * (LDAPAPI * PFN_LDAP_NEXT_ENTRY) (LDAP *ld, LDAPMessage *entry);

typedef WINLDAPAPI PCHAR (LDAPAPI * PFN_LDAP_FIRST_ATTRIBUTE)(LDAP *ld, LDAPMessage *entry, BerElement **ptr);
typedef WINLDAPAPI PCHAR (LDAPAPI * PFN_LDAP_NEXT_ATTRIBUTE) (LDAP *ld, LDAPMessage *entry, BerElement *ptr);

typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_SEARCH)  (LDAP *ld, PCHAR base, ULONG scope, PCHAR filter, PCHAR attrs[], ULONG attrsonly);
typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_SEARCH_S)(LDAP *ld, PCHAR base, ULONG scope, PCHAR filter, PCHAR attrs[], ULONG attrsonly, LDAPMessage **res);
typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_MODIFY)  (LDAP *ld, PCHAR dn, LDAPMod *mods[]);
typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_DELETE)  (LDAP *ld, PCHAR dn);

typedef WINLDAPAPI ULONG (LDAPAPI * PFN_LDAP_GET_OPTION)  ( LDAP *ld, int option, void *outvalue );


class WLDAP
{
private:
	static HINSTANCE m_hInstance;

protected:
	WLDAP() {};
	~WLDAP() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_LDAP_ABANDON         ldap_abandon;
	static PFN_LDAP_BIND_S          ldap_bind_s;
	static PFN_LDAP_BIND			ldap_bind;
	static PFN_LDAP_ADD				ldap_add;
	static PFN_LDAP_FIRST_ATTRIBUTE ldap_first_attribute;
	static PFN_LDAP_FIRST_ENTRY     ldap_first_entry;
	static PFN_LDAP_GET_VALUES      ldap_get_values;
	static PFN_LDAP_MSGFREE         ldap_msgfree;
	static PFN_LDAP_NEXT_ATTRIBUTE  ldap_next_attribute;
	static PFN_LDAP_NEXT_ENTRY      ldap_next_entry;
	static PFN_LDAP_OPEN            ldap_open;
	static PFN_LDAP_INIT            ldap_init;
	static PFN_LDAP_RESULT          ldap_result;
	static PFN_LDAP_SEARCH          ldap_search;
	static PFN_LDAP_SEARCH_S        ldap_search_s;
	static PFN_LDAP_SET_OPTION      ldap_set_option;
	static PFN_LDAP_SIMPLE_BIND_S   ldap_simple_bind_s;
	static PFN_LDAP_UNBIND          ldap_unbind;
	static PFN_LDAP_VALUE_FREE      ldap_value_free;
	static PFN_LDAP_MODIFY			ldap_modify;
	static PFN_LDAP_DELETE			ldap_delete;
	static PFN_LDAP_GET_OPTION		ldap_get_option;
};


#endif /* _PFNWLDAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnwldap.cpp ===
// File: pfnwldap.cpp

#include "precomp.h"
#include "pfnwldap.h"

static const TCHAR * s_pcszWldap32 = TEXT("wldap32.dll");

HINSTANCE WLDAP::m_hInstance = NULL;

PFN_LDAP_ABANDON         WLDAP::ldap_abandon = NULL;
PFN_LDAP_BIND_S          WLDAP::ldap_bind_s = NULL;
PFN_LDAP_BIND			 WLDAP::ldap_bind = NULL;
PFN_LDAP_ADD		     WLDAP::ldap_add = NULL;
PFN_LDAP_SIMPLE_BIND_S   WLDAP::ldap_simple_bind_s = NULL;
PFN_LDAP_FIRST_ATTRIBUTE WLDAP::ldap_first_attribute = NULL;
PFN_LDAP_FIRST_ENTRY     WLDAP::ldap_first_entry = NULL;
PFN_LDAP_GET_VALUES      WLDAP::ldap_get_values = NULL;
PFN_LDAP_MSGFREE         WLDAP::ldap_msgfree = NULL;
PFN_LDAP_NEXT_ATTRIBUTE  WLDAP::ldap_next_attribute = NULL;
PFN_LDAP_NEXT_ENTRY      WLDAP::ldap_next_entry = NULL;
PFN_LDAP_OPEN            WLDAP::ldap_open = NULL;
PFN_LDAP_OPEN            WLDAP::ldap_init = NULL;
PFN_LDAP_RESULT          WLDAP::ldap_result = NULL;
PFN_LDAP_SEARCH          WLDAP::ldap_search = NULL;
PFN_LDAP_SEARCH_S        WLDAP::ldap_search_s = NULL;
PFN_LDAP_SET_OPTION      WLDAP::ldap_set_option = NULL;
PFN_LDAP_UNBIND          WLDAP::ldap_unbind = NULL;
PFN_LDAP_VALUE_FREE      WLDAP::ldap_value_free = NULL;
PFN_LDAP_MODIFY			 WLDAP::ldap_modify = NULL;
PFN_LDAP_DELETE			 WLDAP::ldap_delete = NULL;
PFN_LDAP_GET_OPTION		WLDAP::ldap_get_option = NULL;


#define WLDAP_APIFCN_ENTRY(pfn)  {(PVOID *) &WLDAP::##pfn, #pfn}

APIFCN s_apiFcnWldap[] = {
	WLDAP_APIFCN_ENTRY(ldap_abandon),
	WLDAP_APIFCN_ENTRY(ldap_bind_s),
	WLDAP_APIFCN_ENTRY(ldap_bind),
	WLDAP_APIFCN_ENTRY(ldap_add),
	WLDAP_APIFCN_ENTRY(ldap_first_attribute),
	WLDAP_APIFCN_ENTRY(ldap_first_attribute),
	WLDAP_APIFCN_ENTRY(ldap_first_entry),
	WLDAP_APIFCN_ENTRY(ldap_get_values),
	WLDAP_APIFCN_ENTRY(ldap_msgfree),
	WLDAP_APIFCN_ENTRY(ldap_next_attribute),
	WLDAP_APIFCN_ENTRY(ldap_next_entry),
	WLDAP_APIFCN_ENTRY(ldap_open),
	WLDAP_APIFCN_ENTRY(ldap_init),
	WLDAP_APIFCN_ENTRY(ldap_result),
	WLDAP_APIFCN_ENTRY(ldap_search),
	WLDAP_APIFCN_ENTRY(ldap_search_s),
	WLDAP_APIFCN_ENTRY(ldap_set_option),
	WLDAP_APIFCN_ENTRY(ldap_simple_bind_s),
	WLDAP_APIFCN_ENTRY(ldap_unbind),
	WLDAP_APIFCN_ENTRY(ldap_value_free),
	WLDAP_APIFCN_ENTRY(ldap_modify),
	WLDAP_APIFCN_ENTRY(ldap_delete),
	WLDAP_APIFCN_ENTRY(ldap_get_option)
};

HRESULT WLDAP::Init(void)
{
	if (NULL != m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnWldap, ARRAY_ELEMENTS(s_apiFcnWldap), &m_hInstance, s_pcszWldap32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnwininet.h ===
// File: pfnwininet.h

#ifndef _PFNWININET_H_
#define _PFNWININET_H_

#include <wininet.h>

#define HINTERNETKILL( hInternet ) if( hInternet ) { WININET::InternetCloseHandle( hInternet ); hInternet = NULL; }

typedef HINTERNET (*PFN_IOPEN)( LPCSTR, DWORD, LPCSTR, LPCSTR, DWORD);
typedef INTERNET_STATUS_CALLBACK (*PFN_ISETCALLBACK)( HINTERNET, INTERNET_STATUS_CALLBACK);
typedef HINTERNET (*PFN_IOPENURL)( HINTERNET, LPCSTR, LPCSTR, DWORD, DWORD, DWORD );
typedef BOOL (*PFN_IREADFILE)(HINTERNET, LPVOID, DWORD, LPDWORD );
typedef BOOL (*PFN_IQUERYDATA)( HINTERNET, LPDWORD, DWORD, DWORD );
typedef BOOL (*PFN_ICLOSEHAN)( HINTERNET );
//typedef BOOL (*PFN_IREADFILEEX)(HINTERNET, LPINTERNET_BUFFERS, DWORD, DWORD);

class WININET
{
private:
	static HINSTANCE m_hInstance;

protected:
	WININET() {};
	~WININET() {};
	
public:
	static HRESULT Init(void);
	static void DeInit(void);
	
	static PFN_IOPEN			InternetOpen;
	static PFN_ISETCALLBACK	    InternetSetStatusCallback;
	static PFN_IOPENURL			InternetOpenUrl;
	static PFN_IREADFILE		InternetReadFile;
	static PFN_IQUERYDATA		InternetQueryDataAvailable;
	static PFN_ICLOSEHAN		InternetCloseHandle;
//	static PFN_IREADFILEEX		InternetReadFileEx;
};

#endif /* _PFNWININET_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnver.h ===
// File: pfnver.h

#ifndef _PFNVER_H_
#define _PFNVER_H_

// from version.dll
typedef DWORD (WINAPI * PFN_GETVERINFOSIZE) (LPTSTR, LPDWORD);
typedef BOOL  (WINAPI * PFN_GETVERINFO)     (LPTSTR, DWORD, DWORD, LPVOID);
typedef BOOL  (WINAPI * PFN_VERQUERYVAL)    (const LPVOID, LPTSTR, LPVOID *, PUINT);

class DLLVER
{
private:
	static HINSTANCE m_hInstance;

protected:
	DLLVER() {};
	~DLLVER() {};
	
public:
	static HRESULT Init(void);
	
	static PFN_GETVERINFOSIZE GetFileVersionInfoSize;
	static PFN_GETVERINFO     GetFileVersionInfo;
	static PFN_VERQUERYVAL    VerQueryValue;
};

#endif /* _PFNVER_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\popupmsg.cpp ===
// File: popupmsg.cpp

#include "precomp.h"
#include "resource.h"
#include "PopupMsg.h"

#include "conf.h"
#include "call.h"
#include "certui.h"

const int POPUPMSG_LEFT_MARGIN        =   2;
const int POPUPMSG_TOP_MARGIN         =   2;
const int POPUPMSG_CLIENT_MARGIN      =   5;
const int POPUPMSG_ICON_GAP           =   3;
const int POPUPMSG_WIDTH              = 350;
const int POPUPMSG_HEIGHT             =  32;
const int POPUPMSG_DLG_DEF_TEXT_WIDTH = 100;


const TCHAR g_cszTrayWndClass[]       = _TEXT("Shell_TrayWnd");
const TCHAR g_cszTrayNotifyWndClass[] = _TEXT("TrayNotifyWnd");

extern GUID g_csguidSecurity;
///////////////////////////////////////////////////////////////////////////

UINT CPopupMsg::m_uVisiblePixels = 0;
/*static*/ CSimpleArray<CPopupMsg*>*	CPopupMsg::m_splstPopupMsgs = NULL;

CPopupMsg::CPopupMsg(PMCALLBACKPROC pcp, LPVOID pContext):
	m_pCallbackProc		(pcp),
	m_pContext			(pContext),
	m_fRing				(FALSE),
	m_hwnd				(NULL),
	m_hIcon				(NULL),
	m_fAutoSize			(FALSE),
	m_hInstance			(NULL),
	m_nWidth			(0),
	m_nHeight			(0),
	m_nTextWidth		(POPUPMSG_DLG_DEF_TEXT_WIDTH)
{
	TRACE_OUT(("Constructing CPopupMsg"));

	if (NULL != m_splstPopupMsgs)
	{
		CPopupMsg* p = const_cast<CPopupMsg*>(this);
		m_splstPopupMsgs->Add(p);
	}
}

CPopupMsg::~CPopupMsg()
{
	TRACE_OUT(("Destructing CPopupMsg"));
	
	if (NULL != m_hIcon)
	{
		DestroyIcon(m_hIcon);
	}
	
	if (NULL != m_hwnd)
	{
		KillTimer(m_hwnd, POPUPMSG_TIMER);
		KillTimer(m_hwnd, POPUPMSG_RING_TIMER);
		
		DestroyWindow(m_hwnd);
		if (m_fAutoSize)
		{
			m_uVisiblePixels -= m_nHeight;
		}
	}

	if (NULL != m_splstPopupMsgs)
	{
		CPopupMsg* p = const_cast<CPopupMsg*>(this);			
		if( !m_splstPopupMsgs->Remove(p) )
		{
			TRACE_OUT(("CPopupMsg object is not in the list"));
		}
	}
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   PlaySound()
*
*    PURPOSE:  Plays the sound or beeps the system speaker
*
****************************************************************************/

VOID CPopupMsg::PlaySound()
{
	if (FALSE == ::PlaySound(m_szSound, NULL,
			SND_APPLICATION | SND_ALIAS | SND_ASYNC | SND_NOWAIT))
	{
		// Use the computer speaker to beep:
		TRACE_OUT(("PlaySound() failed, trying MessageBeep()"));
		::MessageBeep(0xFFFFFFFF);
	}
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Change(LPCTSTR)
*
*    PURPOSE:  Changes the text on an existing popup message
*
****************************************************************************/

BOOL CPopupMsg::Change(LPCTSTR pcszText)
{
	BOOL bRet = FALSE;
	
	// BUGBUG: doesn't handle dialog message
	
	if (NULL != m_hwnd)
	{
		bRet = ::SetWindowText(m_hwnd, pcszText);
	}

	return bRet;
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Init()
*
*    PURPOSE:  Allocates a static list of these objects
*
****************************************************************************/

BOOL CPopupMsg::Init()
{
	ASSERT(NULL == m_splstPopupMsgs);
	return (NULL != (m_splstPopupMsgs = new CSimpleArray<CPopupMsg*>));
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Cleanup()
*
*    PURPOSE:  Removes all of the objects of this type
*
****************************************************************************/

VOID CPopupMsg::Cleanup()
{
	if (NULL != m_splstPopupMsgs)
	{
		for( int i = 0; i < m_splstPopupMsgs->GetSize(); ++i )
		{	
			ASSERT( (*m_splstPopupMsgs)[i] != NULL);
			CPopupMsg *pThis = (*m_splstPopupMsgs)[i];
			delete pThis;
		}

		delete m_splstPopupMsgs;
		m_splstPopupMsgs = NULL;
	}
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   PMWndProc(HWND, unsigned, WORD, LONG)
*
*    PURPOSE:
*
****************************************************************************/

LRESULT CALLBACK CPopupMsg::PMWndProc(
	HWND hWnd,                /* window handle                   */
	UINT message,             /* type of message                 */
	WPARAM wParam,            /* additional information          */
	LPARAM lParam)            /* additional information          */
{
	CPopupMsg* ppm;
	LPCREATESTRUCT lpcs;

	switch (message)
	{
		case WM_CREATE:
		{
			TRACE_OUT(("PopupMsg Window created"));
			
			lpcs = (LPCREATESTRUCT) lParam;
			ppm = (CPopupMsg*) lpcs->lpCreateParams;
			ASSERT(ppm && "NULL object passed in WM_CREATE!");
			SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) ppm);

			// Create a timer to make the window time-out and disappear:
			::SetTimer(hWnd, POPUPMSG_TIMER, ppm->m_uTimeout, NULL);
			
			// For now, if you pass a callback, you get ringing.
			// If not, there is no ring
			if (NULL != ppm->m_fPlaySound)
			{
				ppm->PlaySound();
				
				if (NULL != ppm->m_fRing)
				{
					// Create a timer to make the ringer start:
					::SetTimer(hWnd, POPUPMSG_RING_TIMER, POPUPMSG_RING_INTERVAL, NULL);
				}
			}

			break;
		}

		case WM_TIMER:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if (POPUPMSG_TIMER == wParam)
			{
				// Message timed out:
				if (NULL != ppm)
				{
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL;
						pCallback(ppm->m_pContext, PMF_CANCEL | PMF_TIMEOUT);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
			}
			else if (POPUPMSG_RING_TIMER == wParam)
			{
				if (NULL != ppm)
				{
					ppm->PlaySound();
				}
				
				// Create a timer to make it ring again:
				::SetTimer(	hWnd,
							POPUPMSG_RING_TIMER,
							POPUPMSG_RING_INTERVAL,
							NULL);
			}
				
			break;
		}

		case WM_LBUTTONUP:
		{
			// Clicked on the message:
			ppm = (CPopupMsg*) GetWindowLongPtr(hWnd, GWLP_USERDATA);
			if (NULL != ppm)
			{
				::PlaySound(NULL, NULL, 0); // stop playing the ring sound
				::KillTimer(ppm->m_hwnd, POPUPMSG_TIMER);
				::KillTimer(ppm->m_hwnd, POPUPMSG_RING_TIMER);
				
				PMCALLBACKPROC pCallback;
				if (NULL != (pCallback = ppm->m_pCallbackProc))
				{
					ppm->m_pCallbackProc = NULL;
					pCallback(ppm->m_pContext, PMF_OK);
				}
				
				// Self-destruct:
				if (NULL != ppm->m_hwnd)
				{
					// NULL out the object pointer:
					SetWindowLongPtr(hWnd, GWLP_USERDATA, 0L);
					delete ppm;
				}
			}
			break;
		}

		case WM_PAINT:
		{
			// Handle painting:
			PAINTSTRUCT ps;
			HDC hdc;
			int nHorizTextOffset = POPUPMSG_LEFT_MARGIN;
			
			if (hdc = ::BeginPaint(hWnd, &ps))
			{
				// Start by painting the icon (if needed)
				ppm = (CPopupMsg*) ::GetWindowLongPtr(hWnd, GWLP_USERDATA);
				if ((NULL != ppm) &&
					(NULL != ppm->m_hIcon))
				{
					if (::DrawIconEx(	hdc,
										POPUPMSG_LEFT_MARGIN,
										POPUPMSG_TOP_MARGIN,
										ppm->m_hIcon,
										POPUPMSG_ICON_WIDTH,
										POPUPMSG_ICON_HEIGHT,
										0,
										NULL,
										DI_NORMAL))
					{
						// We painted an icon, so make sure the text is shifted
						// to the right by the right amount:
						nHorizTextOffset += (POPUPMSG_ICON_WIDTH + POPUPMSG_ICON_GAP);
					}
				}
				
				// Draw the text with a transparent background:
				int bkOld = ::SetBkMode(hdc, TRANSPARENT);
				COLORREF crOld = ::SetTextColor(hdc, ::GetSysColor(COLOR_WINDOWTEXT));
				HFONT hFontOld = (HFONT) ::SelectObject(hdc, g_hfontDlg);
				
				TCHAR szWinText[POPUPMSG_MAX_LENGTH];
				szWinText[0] = _T('\0');
				
				::GetWindowText(hWnd, szWinText, sizeof(szWinText));

				RECT rctClient;
				if (::GetClientRect(hWnd, &rctClient))
				{
					rctClient.left += nHorizTextOffset;
					
					::DrawText(	hdc, szWinText, -1, &rctClient,
								DT_SINGLELINE | DT_NOCLIP | DT_VCENTER | DT_NOPREFIX);
				}

				::SetBkMode(hdc, bkOld);
				::SetTextColor(hdc, crOld);
				::SelectObject(hdc, hFontOld);
				
				::EndPaint(hWnd, &ps);
			}
			break;
		}

		default:
		{
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
	}
	return(FALSE);
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   PMDlgProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Handles messages associated with the incoming call dialog
*
****************************************************************************/

INT_PTR CALLBACK CPopupMsg::PMDlgProc(	HWND hDlg,
									UINT uMsg,
									WPARAM wParam,
									LPARAM lParam)
{
	CPopupMsg* ppm;

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			TRACE_OUT(("PopupMsg Window created"));

			AddModelessDlg(hDlg);
	
			ppm = (CPopupMsg*) lParam;
			ASSERT(ppm && "NULL object passed in WM_INITDIALOG!");
			::SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) ppm);

			TRACE_OUT(("CPopupMsg m_nTextWidth=%d in WM_INITDIALOG", ppm->m_nTextWidth));

			// If the dialog is too big, then resize the text width.
			RECT rctDlg;
			RECT rctDesk;
			HWND hwndDesk;
			if (::GetWindowRect(hDlg, &rctDlg) &&
				(hwndDesk = ::GetDesktopWindow()) &&
				::GetWindowRect(hwndDesk, &rctDesk))
			{
				int nDlgWidth = rctDlg.right - rctDlg.left;
				ppm->m_nTextWidth -= max(	0,
											nDlgWidth + ppm->m_nTextWidth -
												(rctDesk.right - rctDesk.left));
			}

			RECT rctCtrl;
			// Move the "Authenticate" button, if it's there
			HWND hwndAuth = ::GetDlgItem(hDlg, IDB_AUTH);
			if ((NULL != hwndAuth) && ::GetWindowRect(hwndAuth, &rctCtrl)) {
				// Turn rctCtrl's top and left into client coords:
				::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
				::SetWindowPos(	hwndAuth,
								NULL,
								rctCtrl.left + ppm->m_nTextWidth,
								rctCtrl.top,
								0, 0,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);

			}
			// Move the "Accept" button (IDOK)
			HWND hwndOK = ::GetDlgItem(hDlg, IDOK);
			if ((NULL != hwndOK) && ::GetWindowRect(hwndOK, &rctCtrl))
			{
				// Turn rctCtrl's top and left into client coords:
				::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
				::SetWindowPos(	hwndOK,
								NULL,
								rctCtrl.left + ppm->m_nTextWidth,
								rctCtrl.top,
								0, 0,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);
			}
			// Move the "Ignore" button (IDCANCEL)
			HWND hwndCancel = ::GetDlgItem(hDlg, IDCANCEL);
			if ((NULL != hwndCancel) && ::GetWindowRect(hwndCancel, &rctCtrl))
			{
				// Turn rctCtrl's top and left into client coords:
				::MapWindowPoints(NULL, hDlg, (LPPOINT) &rctCtrl, 1);
				::SetWindowPos(	hwndCancel,
								NULL,
								rctCtrl.left + ppm->m_nTextWidth,
								rctCtrl.top,
								0, 0,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE | SWP_NOREDRAW);
			}
			// Stretch the text field:
			HWND hwndText = ::GetDlgItem(hDlg, IDC_MSG_STATIC);
			if ((NULL != hwndText) && ::GetWindowRect(hwndText, &rctCtrl))
			{
				::SetWindowPos(	hwndText,
								NULL,
								0, 0,
								ppm->m_nTextWidth,
								rctCtrl.bottom - rctCtrl.top,
								SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);

				// and set the font
				::SendMessage(hwndText, WM_SETFONT, (WPARAM) g_hfontDlg, 0);
			}

			// Create a timer to make the window time-out and disappear:
			::SetTimer(hDlg, POPUPMSG_TIMER, ppm->m_uTimeout, NULL);
			
			// For now, if you pass a callback, you get ringing.
			// If not, there is no ring
			if (NULL != ppm->m_fPlaySound)
			{
				ppm->PlaySound();
				
				if (NULL != ppm->m_fRing)
				{
					// Create a timer to make the ringer start:
					::SetTimer(hDlg, POPUPMSG_RING_TIMER, POPUPMSG_RING_INTERVAL, NULL);
				}
			}
			return TRUE;
		}

		case WM_TIMER:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			if (POPUPMSG_TIMER == wParam)
			{
				// Message timed out:
				if (NULL != ppm)
				{
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL;
						// hide the dialog in case the callback doesn't
						// return immediately
						::ShowWindow(ppm->m_hwnd, SW_HIDE);
						pCallback(ppm->m_pContext, PMF_CANCEL | PMF_TIMEOUT);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
			}
			else if (POPUPMSG_RING_TIMER == wParam)
			{
				if (NULL != ppm)
				{
					ppm->PlaySound();
				}
				
				// Create a timer to make it ring again:
				::SetTimer(	hDlg,
							POPUPMSG_RING_TIMER,
							POPUPMSG_RING_INTERVAL,
							NULL);
			}
				
			return TRUE;
		}

		case WM_COMMAND:
		{
			// Clicked on one of the buttons:
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			if (NULL != ppm)
			{
				// stop playing the ring sound
				::PlaySound(NULL, NULL, 0);
				::KillTimer(ppm->m_hwnd, POPUPMSG_RING_TIMER);
				::KillTimer(ppm->m_hwnd, POPUPMSG_TIMER);
				
				PMCALLBACKPROC pCallback;
				if (NULL != (pCallback = ppm->m_pCallbackProc))
				{
					ppm->m_pCallbackProc = NULL; // prevent this from firing twice
					// hide the dialog in case the callback doesn't
					// return immediately
					::ShowWindow(ppm->m_hwnd, SW_HIDE);
					pCallback(ppm->m_pContext,
						(IDB_AUTH == LOWORD(wParam)) ? PMF_AUTH : (IDOK == LOWORD(wParam)) ? PMF_OK : PMF_CANCEL);
				}
				
				// Self-destruct:
				if (NULL != ppm->m_hwnd)
				{
					// NULL out the object pointer:
					SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
					delete ppm;
				}
			}
			return TRUE;
		}

		case WM_DESTROY:
		{
			::RemoveModelessDlg(hDlg);
			break;
		}

		default:
			break;
	} /* switch (uMsg) */

	return FALSE;
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   SecurePMDlgProc(HWND, UINT, WPARAM, LPARAM)
*
*    PURPOSE:  Handles messages associated with the incoming call dialog
*
****************************************************************************/

INT_PTR CALLBACK CPopupMsg::SecurePMDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam)
{
	CPopupMsg* ppm;

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			TRACE_OUT(("PopupMsg Window created"));

			AddModelessDlg(hDlg);
	
			ppm = (CPopupMsg*) lParam;
			ASSERT(ppm && "NULL object passed in WM_INITDIALOG!");
			::SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) ppm);

			TRACE_OUT(("CPopupMsg m_nTextWidth=%d in WM_INITDIALOG", ppm->m_nTextWidth));

			RegEntry re(UI_KEY, HKEY_CURRENT_USER);
			if (1 == re.GetNumber(REGVAL_SHOW_SECUREDETAILS, DEFAULT_SHOW_SECUREDETAILS)) {				
				ExpandSecureDialog(hDlg,ppm);
			}
			// Create a timer to make the window time-out and disappear:
			::SetTimer(hDlg, POPUPMSG_TIMER, ppm->m_uTimeout, NULL);
			
			// For now, if you pass a callback, you get ringing.
			// If not, there is no ring
			if (NULL != ppm->m_fPlaySound)
			{
				ppm->PlaySound();
				
				if (NULL != ppm->m_fRing)
				{
					// Create a timer to make the ringer start:
					::SetTimer(hDlg, POPUPMSG_RING_TIMER, POPUPMSG_RING_INTERVAL, NULL);
				}
			}
			return TRUE;
		}

		case WM_TIMER:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			if (POPUPMSG_TIMER == wParam)
			{
				// Message timed out:
				if (NULL != ppm)
				{
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL;
						// hide the dialog in case the callback doesn't
						// return immediately
						::ShowWindow(ppm->m_hwnd, SW_HIDE);
						pCallback(ppm->m_pContext, PMF_CANCEL | PMF_TIMEOUT);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
			}
			else if (POPUPMSG_RING_TIMER == wParam)
			{
				if (NULL != ppm)
				{
					ppm->PlaySound();
				}
				
				// Create a timer to make it ring again:
				::SetTimer(	hDlg,
							POPUPMSG_RING_TIMER,
							POPUPMSG_RING_INTERVAL,
							NULL);
			}
				
			return TRUE;
		}

		case WM_COMMAND:
		{
			ppm = (CPopupMsg*) GetWindowLongPtr(hDlg, GWLP_USERDATA);
			switch (LOWORD(wParam)) {
			case IDOK:
			case IDCANCEL:
				// Clicked on one of the buttons:

				if (NULL != ppm)
				{
					// stop playing the ring sound
					::PlaySound(NULL, NULL, 0);
					::KillTimer(ppm->m_hwnd, POPUPMSG_RING_TIMER);
					::KillTimer(ppm->m_hwnd, POPUPMSG_TIMER);
					
					PMCALLBACKPROC pCallback;
					if (NULL != (pCallback = ppm->m_pCallbackProc))
					{
						ppm->m_pCallbackProc = NULL; // prevent this from firing twice
						// hide the dialog in case the callback doesn't
						// return immediately
						::ShowWindow(ppm->m_hwnd, SW_HIDE);
						pCallback(ppm->m_pContext, (IDOK == LOWORD(wParam)) ? PMF_OK : PMF_CANCEL);
					}
					
					// Self-destruct:
					if (NULL != ppm->m_hwnd)
					{
						// NULL out the object pointer:
						SetWindowLongPtr(hDlg, GWLP_USERDATA, 0L);
						delete ppm;
					}
				}
				break;
			case IDB_DETAILS:
				RegEntry re(UI_KEY, HKEY_CURRENT_USER);
				if (1 == re.GetNumber(REGVAL_SHOW_SECUREDETAILS,DEFAULT_SHOW_SECUREDETAILS)) {
					// Currently expanded, so shrink
					re.SetValue(REGVAL_SHOW_SECUREDETAILS,(DWORD)0);
					ShrinkSecureDialog(hDlg);
				}
				else {
					// Currently shrunk, so expand
					re.SetValue(REGVAL_SHOW_SECUREDETAILS,1);
					ExpandSecureDialog(hDlg,ppm);
				}
				break;
			}
			return TRUE;
		}

		case WM_DESTROY:
		{
			::RemoveModelessDlg(hDlg);
			break;
		}

		default:
			break;
	} /* switch (uMsg) */

	return FALSE;
}

/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   Create()
*
*    PURPOSE:  Creates a popup message window
*
****************************************************************************/

HWND CPopupMsg::Create(	LPCTSTR pcszText, BOOL fRing, LPCTSTR pcszIconName,
						HINSTANCE hInstance, UINT uIDSoundEvent,
						UINT uTimeout, int xCoord, int yCoord)
{
	ASSERT(pcszText);
	
	m_fRing = fRing;
	m_fPlaySound = (BOOL) uIDSoundEvent;
	m_uTimeout = uTimeout;
	// First try to load the icon:
	m_hInstance = hInstance;
	if ((NULL != m_hInstance) && (NULL != pcszIconName))
	{
		m_hIcon = (HICON) LoadImage(m_hInstance,
									pcszIconName,
									IMAGE_ICON,
									POPUPMSG_ICON_WIDTH,
									POPUPMSG_ICON_HEIGHT,
									LR_DEFAULTCOLOR);
	}
	else
	{
		m_hIcon = NULL;
	}

	if ((NULL == m_hInstance) ||
		(!::LoadString(	m_hInstance,
						uIDSoundEvent,
						m_szSound,
						CCHMAX(m_szSound))))
	{
		m_szSound[0] = _T('\0');
	}

	// initialize window size with default values:
	m_nWidth = POPUPMSG_WIDTH;
	m_nHeight = POPUPMSG_HEIGHT;

	HWND hwndDesktop = GetDesktopWindow();
	if (NULL != hwndDesktop)
	{
		RECT rctDesktop;
		::GetWindowRect(hwndDesktop, &rctDesktop);
		HDC hdc = GetDC(hwndDesktop);
		if (NULL != hdc)
		{
			HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
			SIZE size;
			if (GetTextExtentPoint32(hdc, pcszText, lstrlen(pcszText), &size))
			{
				// don't make it wider than the desktop
				m_nWidth = min(	rctDesktop.right - rctDesktop.left,
								size.cx + (2 * POPUPMSG_CLIENT_MARGIN));
				m_nHeight = size.cy + (2 * POPUPMSG_CLIENT_MARGIN);
				
				// If we have succesfully loaded an icon, make size
				// adjustments:
				if (NULL != m_hIcon)
				{
					m_nWidth += POPUPMSG_ICON_WIDTH + POPUPMSG_ICON_GAP;
					if (size.cy < POPUPMSG_ICON_HEIGHT)
					{
						m_nHeight = POPUPMSG_ICON_HEIGHT +
										(2 * POPUPMSG_CLIENT_MARGIN);
					}
				}
			}

			// Reselect old font
			SelectObject(hdc, hFontOld);
			ReleaseDC(hwndDesktop, hdc);
		}
	
		POINT pt;
		GetIdealPosition(&pt, xCoord, yCoord);

		m_hwnd = CreateWindowEx(WS_EX_PALETTEWINDOW,
									g_szPopupMsgWndClass,
									pcszText,
									WS_POPUP | /* WS_VISIBLE |*/ WS_DLGFRAME,
									pt.x, pt.y,
									m_nWidth, m_nHeight,
									NULL,
									NULL,
									::GetInstanceHandle(),
									(LPVOID) this);
		if (m_fAutoSize)
		{
			m_uVisiblePixels += m_nHeight;
		}

		// Show, but don't activate
		::ShowWindow(m_hwnd, SW_SHOWNA);
		// Repaint
    	::UpdateWindow(m_hwnd);

		return m_hwnd;
	}

	// Something went wrong
	return NULL;
}


/****************************************************************************
*
*    CLASS:    CPopupMsg
*
*    MEMBER:   CreateDlg()
*
*    PURPOSE:  Creates a popup dialog message window
*
****************************************************************************/

HWND CPopupMsg::CreateDlg(	LPCTSTR pcszText, BOOL fRing, LPCTSTR pcszIconName,
							HINSTANCE hInstance, UINT uIDSoundEvent,
							UINT uTimeout, int xCoord, int yCoord)
{
	ASSERT(pcszText);
	
	m_fRing = fRing;
	m_fPlaySound = (BOOL) uIDSoundEvent;
	m_uTimeout = uTimeout;
	// First try to load the icon:
	m_hInstance = hInstance;
	if ((NULL != m_hInstance) && (NULL != pcszIconName))
	{
		m_hIcon = (HICON) LoadImage(m_hInstance,
									pcszIconName,
									IMAGE_ICON,
									POPUPMSG_ICON_WIDTH,
									POPUPMSG_ICON_HEIGHT,
									LR_DEFAULTCOLOR);
	}
	else
	{
		m_hIcon = NULL;
	}

	if ((NULL == m_hInstance) ||
		(!::LoadString(	m_hInstance,
						uIDSoundEvent,
						m_szSound,
						sizeof(m_szSound))))
	{
		m_szSound[0] = _T('\0');
	}

	// init with large defaults in case getwindowrect fails
	RECT rctDesktop = { 0x0000, 0x0000, 0xFFFF, 0xFFFF };
	HWND hwndDesktop = GetDesktopWindow();
	if (NULL != hwndDesktop)
	{
		::GetWindowRect(hwndDesktop, &rctDesktop);
		HDC hdc = GetDC(hwndDesktop);
		if (NULL != hdc)
		{
			HFONT hFontOld = (HFONT) SelectObject(hdc, g_hfontDlg);
			SIZE size;
			if (::GetTextExtentPoint32(hdc, pcszText, lstrlen(pcszText), &size))
			{
				m_nTextWidth = size.cx;
			}
			::SelectObject(hdc, hFontOld);
			::ReleaseDC(hwndDesktop, hdc);
		}
	}

	KillScrnSaver();

	INmCall * pCall = NULL;
	PBYTE pb = NULL;
	ULONG cb = 0;

	int id;
	
	if (m_pContext != NULL) {
		pCall = ((CCall *)m_pContext)->GetINmCall();
	}
	if (NULL != pCall && S_OK == pCall->GetUserData(g_csguidSecurity,&pb,&cb)) {
		// This is an encrypted call
		CoTaskMemFree(pb);
		id = IDD_SECURE_INCOMING_CALL;
		m_hwnd = ::CreateDialogParam(m_hInstance, MAKEINTRESOURCE(id),
			::GetMainWindow(),CPopupMsg::SecurePMDlgProc,(LPARAM) this);

	}
	else {
		id = IDD_INCOMING_CALL;
		m_hwnd = ::CreateDialogParam(m_hInstance, MAKEINTRESOURCE(id),
			::GetMainWindow(),CPopupMsg::PMDlgProc,(LPARAM) this);
	}
		
	if (NULL != m_hwnd)
	{
		::SetDlgItemText(m_hwnd, IDC_MSG_STATIC, pcszText);

		RECT rctDlg;
		::GetWindowRect(m_hwnd, &rctDlg);

		// Stretch the width to fit the person's name,
		// but not wider than the desktop.
		// int nDeskWidth = rctDesktop.right - rctDesktop.left;

		// Resize the non-secure dialog
		m_nWidth = (rctDlg.right - rctDlg.left) + ((IDD_INCOMING_CALL == id) ? m_nTextWidth : 0);
		// if (m_nWidth > nDeskWidth)
		// {
		//	m_nTextWidth -= (m_nWidth - nDeskWidth);
		//	m_nWidth = nDeskWidth;
		// }
		m_nHeight = rctDlg.bottom - rctDlg.top;
		
		POINT pt;
		GetIdealPosition(&pt, xCoord, yCoord);

		// Show, move, make topmost, but don't activate
		::SetWindowPos(	m_hwnd,
						HWND_TOPMOST,
						pt.x,
						pt.y,
						m_nWidth,
						m_nHeight,
						SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_DRAWFRAME);
		
		if (m_fAutoSize)
		{
			m_uVisiblePixels += m_nHeight;
		}
	}

	return m_hwnd;
}

BOOL CPopupMsg::GetIdealPosition(LPPOINT ppt, int xCoord, int yCoord)
{
	ASSERT(ppt);

	BOOL bRet = FALSE;
	HWND hwndDesktop = GetDesktopWindow();
	RECT rctDesktop;

	if (NULL != hwndDesktop)
	{
		int yBottomofTrayRect = 0;
	
		if ((-1 == xCoord) && (-1 == yCoord))
		{
			m_fAutoSize = TRUE;
			// BUGBUG: We search for the tray notification window by looking for
			// hard coded window class names.  This is safe if we're running
			// Win 95 build 950.6, but maybe not otherwise...

			HWND hwndTray = FindWindowEx(NULL, NULL, g_cszTrayWndClass, NULL);
			if (NULL != hwndTray)
			{
				HWND hwndTrayNotify = FindWindowEx(hwndTray, NULL, g_cszTrayNotifyWndClass, NULL);

				if (NULL != hwndTrayNotify)
				{
					RECT rctTrayNotify;
					
					if (GetWindowRect(hwndTrayNotify, &rctTrayNotify))
					{
						xCoord = rctTrayNotify.right;
						yCoord = rctTrayNotify.top;
						yBottomofTrayRect = rctTrayNotify.bottom;
					}
				}
			}
		}

		if (GetWindowRect(hwndDesktop, &rctDesktop))
		{
			// Make sure that xCoord and yCoord are on the screen (bugs 1817,1819):
			xCoord = min(rctDesktop.right, xCoord);
			xCoord = max(rctDesktop.left, xCoord);
			
			yCoord = min(rctDesktop.bottom, yCoord);
			yCoord = max(rctDesktop.top, yCoord);
			
			// First attempt will be to center the toolbar horizontally
			// with respect to the mouse position and place it directly
			// above vertically.

			ppt->x = xCoord - (m_nWidth / 2);
			// Make the window higher if there are exisiting visible messages
			ppt->y = yCoord - m_uVisiblePixels - m_nHeight;

			// If we are too high on the screen (the taskbar is probably
			// docked on top), then use the click position as the top of
			// where the toolbar will appear.
			
			if (ppt->y < 0)
			{
				ppt->y = yCoord;
				
				// Even better, if we have found the tray rect and we know that
				// we have docked on top, then use the bottom of the rect instead
				// of the top
				if (0 != yBottomofTrayRect)
				{
					ppt->y = yBottomofTrayRect;
					// Make the window lower if there are
					// exisiting visible messages
					ppt->y += m_uVisiblePixels;
				}
			}

			// Repeat the same logic for the horizontal position
			if (ppt->x < 0)
			{
				ppt->x = xCoord;
			}

			// If the toolbar if off the screen to the right, then right-justify it
			if (ppt->x > (rctDesktop.right - m_nWidth))
			{
				ppt->x = max(0, xCoord - m_nWidth);
			}

			bRet = TRUE;
		}
	}

	return bRet;
}

VOID CPopupMsg::ExpandSecureDialog(HWND hDlg,CPopupMsg * ppm)
{
	RECT rect, editrect;
	// Change the dialog to the expanded version.

	if (GetWindowRect(hDlg,&rect) &&
		GetWindowRect(GetDlgItem(hDlg,IDC_SECURE_CALL_EDIT),&editrect)) {

		int nHeight = rect.bottom - rect.top;
		int nWidth = rect.right - rect.left;
		//
		// Grow by height of edit control plus 7 dialog unit margin as
		// given by edit control offset within control:
		//
		int deltaHeight = ( editrect.bottom - editrect.top ) +
							( editrect.left - rect.left );

		SetWindowPos(hDlg,NULL,
		rect.left,(rect.top - deltaHeight > 0 ? rect.top - deltaHeight : 0),
			nWidth,nHeight + deltaHeight, SWP_NOZORDER);
			
		// Make the edit box visible.
		HWND hEditBox = GetDlgItem(hDlg, IDC_SECURE_CALL_EDIT);
		if (hEditBox != NULL) {
			ShowWindow(hEditBox,SW_SHOW);
			EnableWindow(hEditBox, TRUE);
			// Get security information, if any.
			if (NULL != ppm) {
				INmCall * pCall = NULL;
				PBYTE pb = NULL;
				ULONG cb = 0;
				
				if (NULL != ppm->m_pContext) {
					pCall = ((CCall *)ppm->m_pContext)->GetINmCall();
				}
				if (NULL != pCall && S_OK == pCall->GetUserData(g_csguidSecurity,&pb,&cb)) {
					ASSERT(pb);
					ASSERT(cb);
					if ( TCHAR * pCertText = FormatCert( pb, cb )) {
						SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
						delete pCertText;
					}
					else {
						ERROR_OUT(("FormatCert failed"));
					}
					CoTaskMemFree(pb);
				}
			}
		}

		// Move the buttons southward.
		HWND hButton = GetDlgItem(hDlg, IDOK);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top + deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDCANCEL);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top + deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDB_DETAILS);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top + deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);

			// Change text on Details button
			TCHAR lpButtonString[MAX_PATH];
			::FLoadString(IDS_SECURITY_NODETAILS, lpButtonString, MAX_PATH);
			SetDlgItemText(hDlg,IDB_DETAILS,lpButtonString);	
		}

	}
}

VOID CPopupMsg::ShrinkSecureDialog(HWND hDlg)
{
	RECT rect,editrect;
	// Change the dialog to the normal version.
	if (GetWindowRect(hDlg,&rect) &&
		GetWindowRect(GetDlgItem(hDlg,IDC_SECURE_CALL_EDIT),&editrect)) {
		int nHeight = rect.bottom - rect.top;
		int nWidth = rect.right - rect.left;
		//
		// Grow by height of edit control plus 7 dialog unit margin as
		// given by edit control offset within control:
		//
		int deltaHeight = ( editrect.bottom - editrect.top ) +
							( editrect.left - rect.left );

		SetWindowPos(hDlg,NULL,
		rect.left,(rect.top - deltaHeight > 0 ? rect.top + deltaHeight : 0),
			nWidth,nHeight - deltaHeight,SWP_NOZORDER);
			
		// Make the edit box invisible.
		HWND hEditBox = GetDlgItem(hDlg, IDC_SECURE_CALL_EDIT);
		if (hEditBox != NULL) {
			ShowWindow(hEditBox,SW_HIDE);
			EnableWindow(hEditBox,FALSE);
		}

		// Move the buttons northward.
		HWND hButton = GetDlgItem(hDlg, IDOK);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top - deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDCANCEL);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top - deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);
		}
		hButton = GetDlgItem(hDlg, IDB_DETAILS);
		if (hButton && GetWindowRect(hButton,&rect)) {
			MapWindowPoints(HWND_DESKTOP,hDlg,(LPPOINT)&rect,2);
			SetWindowPos(hButton,NULL,rect.left,rect.top - deltaHeight,0,0,
				SWP_NOZORDER | SWP_NOSIZE);

			TCHAR lpButtonString[MAX_PATH];
			::FLoadString(IDS_SECURITY_DETAILS, lpButtonString, MAX_PATH);
			SetDlgItemText(hDlg,IDB_DETAILS,lpButtonString);	

		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\pfnwininet.cpp ===
// File: pfnwininet.cpp

#include "precomp.h"
#include "pfnwininet.h"

PFN_IOPEN				WININET::InternetOpen = NULL;
PFN_ISETCALLBACK	    WININET::InternetSetStatusCallback = NULL;
PFN_IOPENURL			WININET::InternetOpenUrl = NULL;
PFN_IREADFILE			WININET::InternetReadFile = NULL;
PFN_IQUERYDATA			WININET::InternetQueryDataAvailable = NULL;
PFN_ICLOSEHAN			WININET::InternetCloseHandle = NULL;
//PFN_IREADFILEEX			WININET::InternetReadFileEx = NULL;
	
HINSTANCE WININET::m_hInstance = NULL;


#define WININET_APIFCN_ENTRYA(pfn)  {(PVOID *) &WININET::##pfn, #pfn ## "A"}
#define WININET_APIFCN_ENTRYW(pfn)  {(PVOID *) &WININET::##pfn, #pfn ## "A"}
#define WININET_APIFCN_ENTRYNONE(pfn)  {(PVOID *) &WININET::##pfn, #pfn }

#ifdef UNICODE
#define WININET_APIFCN_ENTRY WININET_APIFCN_ENTRYW
#else
#define WININET_APIFCN_ENTRY WININET_APIFCN_ENTRYA
#endif

APIFCN s_apiFcnWinInet[] = {
	WININET_APIFCN_ENTRYA(InternetOpen),
	WININET_APIFCN_ENTRYNONE(InternetSetStatusCallback),
	WININET_APIFCN_ENTRY(InternetOpenUrl),
	WININET_APIFCN_ENTRYNONE(InternetReadFile),
	WININET_APIFCN_ENTRYNONE(InternetQueryDataAvailable),
	WININET_APIFCN_ENTRYNONE(InternetCloseHandle)
};

HRESULT WININET::Init(void)
{
	if (NULL != WININET::m_hInstance)
		return S_OK;

	return HrInitLpfn(s_apiFcnWinInet, ARRAY_ELEMENTS(s_apiFcnWinInet), &WININET::m_hInstance, TEXT("WININET.DLL"));
}

void WININET::DeInit(void)
{
	// TODO - why does the main thread die when I unload this?
	if( NULL != WININET::m_hInstance )
		FreeLibrary( WININET::m_hInstance );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\precomp.cpp ===
#include "precomp.h"


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\precomp.h ===
// File: precomp.h


// Windows SDK Preprocessor macros
#define OEMRESOURCE

// Standard Windows SDK includes
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <winsock.h>
#include <commdlg.h>
#include <cderr.h>
#include <winldap.h>
#include <wincrypt.h>
#include <time.h>

// ATL preprocessor macros

// If _ATL_NO_FORCE_LIBS is not present, ATL will force inclusion of
// several lib files via #pragma comment( lib, XXX )... this is here to
// save us from confusion in the future...
#define _ATL_NO_FORCE_LIBS

// We should really only put this in for w2k
#define _ATL_NO_DEBUG_CRT


// This makes the ATL Host window use a NoLock creator class, so we don't
// Lock the local server. We have to make sure to close ATL host windows before
// We exit, though!
#define _ATL_HOST_NOLOCK

#if 1
	#define ATL_TRACE_LEVEL 0
#else
	#define ATL_TRACE_LEVEL 4
	#define _ATL_DEBUG_INTERFACES
	#define _ATL_DEBUG_QI
#endif

#define _ATL_APARTMENT_THREADED

// This overrides ATLTRACE and ATLTRACE2 to use our debugging libraries and output stuff.
#include <ConfDbg.h>

// We should really only put this in for w2k
#define _ASSERTE(expr) ASSERT(expr)

#include "ConfAtlTrace.h"

// ATL includes
#include <atlbase.h>
// #include <winres.h>
#ifdef SubclassWindow
        // SubclassWindow definition from windowsx.h screws up ATL's CContainedWindow::SubclassWindow
        // as well as CWindowImplBase::SubclassWindow in atlwin.h
    #undef SubclassWindow
#endif

#include <atlconv.h>
#include <atlbase.h>
#include "AtlExeModule.h"
#include <atlcom.h>
#include <atlctl.h>
#include <atlwin.h>
#include <atlhost.h>

// Standard NetMeeting includes
#include <NmStd.h>
#include <standrd.h>
#include <ping.h>
#include <capflags.h>
#include <debspew.h>
#include <RegEntry.h>
#include <ConfReg.h>
#include <oprahcom.h>
#include <dllutil.h>
#include <nmhelp.h>

// Global Object definitions
#include "refcount.h"

// Global NetMeeting UI defintions
#include "global.h"
#include "strings.h"
#include "syspol.h"

#include <ConfEvt.h>
#include <mtgset.h>

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\popupmsg.h ===
/****************************************************************************
*
*    FILE:     PopupMsg.h
*
*    CREATED:  Chris Pirich (ChrisPi) 1-3-96
*
****************************************************************************/

#ifndef _POPUPMSG_H_
#define _POPUPMSG_H_

const DWORD PMF_OK =				0x00000001;
const DWORD PMF_CANCEL =			0x00000002;
const DWORD PMF_TIMEOUT =			0x00000004;
const DWORD PMF_AUTH =				0x00000008;
const DWORD PMF_KILLED =			0x00000010;

typedef VOID (CALLBACK* PMCALLBACKPROC)(LPVOID, DWORD);
const int POPUPMSG_MAX_SOUNDNAME =	64;
const int POPUPMSG_TIMEOUT =		20000;	// 20 seconds
const int POPUPMSG_RING_INTERVAL =	4000;	// 4 seconds
const int POPUPMSG_ICON_HEIGHT =	16;
const int POPUPMSG_ICON_WIDTH =		16;
const int POPUPMSG_RING_TIMER =		1001;
const int POPUPMSG_MAX_LENGTH =		256;

class CPopupMsg
{
private:
	static UINT		m_uVisiblePixels;
	static CSimpleArray<CPopupMsg*>*	m_splstPopupMsgs;
	BOOL			m_fAutoSize;
	HICON			m_hIcon;
	HINSTANCE		m_hInstance;
	PMCALLBACKPROC	m_pCallbackProc;
	LPVOID			m_pContext;
	BOOL			m_fRing;
	BOOL			m_fPlaySound;
	TCHAR			m_szSound[POPUPMSG_MAX_SOUNDNAME];
	
	UINT			m_uTimeout;
	int				m_nWidth;
	int				m_nHeight;
	int				m_nTextWidth;

	BOOL			GetIdealPosition(LPPOINT ppt, int xCoord, int yCoord);
	VOID			PlaySound();

public:
	HWND			m_hwnd;

	// Methods:
					CPopupMsg(PMCALLBACKPROC pcp, LPVOID pContext=NULL);
					~CPopupMsg();
	BOOL			Change(LPCTSTR pcszText);
	HWND			Create(	LPCTSTR pcszText,
							BOOL fRing=FALSE,
							LPCTSTR pcszIconName=NULL,
							HINSTANCE hInstance=NULL,
							UINT uIDSoundEvent=0,
							UINT uTimeout=POPUPMSG_TIMEOUT,
							int xPos = -1,
							int yPos = -1);
	HWND			CreateDlg(	LPCTSTR pcszText,
								BOOL fRing=FALSE,
								LPCTSTR pcszIconName=NULL,
								HINSTANCE hInstance=NULL,
								UINT uIDSoundEvent=0,
								UINT uTimeout=POPUPMSG_TIMEOUT,
								int xPos = -1,
								int yPos = -1);

	static VOID		ExpandSecureDialog(HWND hDlg,CPopupMsg * ppm);
	static VOID		ShrinkSecureDialog(HWND hDlg);

	static BOOL		Init();
	static VOID		Cleanup();
	static LRESULT CALLBACK	PMWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK	PMDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK	SecurePMDlgProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
};

#endif // ! _POPUPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\progressbar.cpp ===
// File: Progressbar.cpp

#include "precomp.h"

#include "ProgressBar.h"
#include "GenControls.h"

#define SIGNAL_STATUS_TRANSMIT  0x01  // data is being received/sent
#define SIGNAL_STATUS_JAMMED    0x02  // wave dev failed to open


CProgressBar::CProgressBar()
{
	for (int i=0; i<ARRAY_ELEMENTS(m_hbs); ++i)
	{
		m_hbs[i] = NULL;
	}
}

CProgressBar::~CProgressBar()
{
	for (int i=0; i<ARRAY_ELEMENTS(m_hbs); ++i)
	{
		if (NULL != m_hbs[i])
		{
			DeleteObject(m_hbs[i]);
			m_hbs[i] = NULL;
		}
	}
}

BOOL CProgressBar::Create(
	HBITMAP hbFrame,	// The outside (static) part of the progress bar
	HBITMAP hbBar,		// The inside part of the progress bar that jumps around
	HWND hWndParent		// The parent of the toolbar window
	)
{
	ASSERT(NULL!=hbFrame && NULL!=hbBar);

	SetFrame(hbFrame);
	SetBar(hbBar);

	if (!CGenWindow::Create(hWndParent, 0, g_szEmpty, 0, 0))
	{
		return(FALSE);
	}

	return(TRUE);
}

void CProgressBar::GetDesiredSize(SIZE *ppt)
{
	CGenWindow::GetDesiredSize(ppt);

	if (NULL == GetFrame())
	{
		return;
	}

	SIZE sizeBitmap;
	CBitmapButton::GetBitmapSizes(&m_hbs[Frame], &sizeBitmap, 1);
	ppt->cx += sizeBitmap.cx;
	ppt->cy += sizeBitmap.cy;
}

LRESULT CProgressBar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_PAINT, OnPaint);
	}

	return(CGenWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

void CProgressBar::OnPaint(HWND hwnd)
{
	if (NULL == GetFrame() || NULL == GetBar() || 0 == GetMaxValue())
	{
		FORWARD_WM_PAINT(hwnd, CGenWindow::ProcessMessage);
		return;
	}

	PAINTSTRUCT ps;
	HDC hdc = BeginPaint(hwnd, &ps);

	HDC hdcTemp = CreateCompatibleDC(hdc);
	if (NULL != hdcTemp)
	{
		HPALETTE hPal = GetPalette();
		HPALETTE hOld = NULL;
		if (NULL != hPal)
		{
			hOld = SelectPalette(hdc, hPal, TRUE);
			RealizePalette(hdc);
			SelectPalette(hdcTemp, hPal, TRUE);
			RealizePalette(hdcTemp);
		}

		SIZE sizes[NumBitmaps];
		CBitmapButton::GetBitmapSizes(m_hbs, sizes, NumBitmaps);

		// BUGBUG georgep: This is going to flicker, so I will need to fix that

		SelectObject(hdcTemp, GetFrame());
		BitBlt(hdc, 0, 0, sizes[Frame].cx, sizes[Frame].cy, hdcTemp, 0, 0, SRCCOPY);

		// BUGBUG georgep: We should clean out the "uncovered" area here

		UINT cur = GetCurrentValue();
		UINT max = GetMaxValue();
		if (cur > max)
		{
			cur = max;
		}

		SelectObject(hdcTemp, GetBar());
		// Center the bitmap, but only display to the current percentage
		BitBlt(hdc, (sizes[Frame].cx-sizes[Bar].cx)/2, (sizes[Frame].cy-sizes[Bar].cy)/2,
			(sizes[Bar].cx*cur)/max, sizes[Bar].cy, hdcTemp, 0, 0, SRCCOPY);

		// This is where we should attempt to alpha blend the inner onto the
		// outer for a few pixels in either direction

		// Clean up
		DeleteDC(hdcTemp);

		if (NULL != hPal)
		{
			SelectPalette(hdc, hOld, TRUE);
		}
	}

	EndPaint(hwnd, &ps);
}

// Change the max value displayed by this progress bar
void CProgressBar::SetMaxValue(UINT maxVal)
{
	m_maxVal = maxVal;
	InvalidateRect(GetWindow(), NULL, FALSE);
}

// Change the current value displayed by this progress bar
void CProgressBar::SetCurrentValue(UINT curVal)
{
	m_curVal = curVal;
	InvalidateRect(GetWindow(), NULL, FALSE);
}





static const int DefWidth = 170;
static const int DefHeight = 23;

CProgressTrackbar::CProgressTrackbar() :
	m_nValChannel(0)
{
	m_desSize.cx = DefWidth;
	m_desSize.cy = DefHeight;
}

CProgressTrackbar::~CProgressTrackbar()
{
}

BOOL CProgressTrackbar::Create(
	HWND hWndParent,	// The parent of the toolbar window
	INT_PTR nId,			// The ID of the control
	IScrollChange *pNotify	// Object to notify of changes
	)
{
	if (!CFillWindow::Create(
		hWndParent,
		nId,
		"NMTrackbar",
		0,
		WS_EX_CONTROLPARENT
		))
	{
		return(FALSE);
	}

	// Create the Win32 button
	CreateWindowEx(0, TRACKBAR_CLASS, g_szEmpty,
		TBS_HORZ|TBS_NOTICKS|TBS_BOTH
		|WS_CLIPSIBLINGS|WS_TABSTOP|WS_VISIBLE|WS_CHILD,
		0, 0, 10, 10,
		GetWindow(), reinterpret_cast<HMENU>(nId), _Module.GetModuleInstance(), NULL);

	m_pNotify = pNotify;
	if (NULL != m_pNotify)
	{
		m_pNotify->AddRef();
	}

	return(TRUE);
}

void CProgressTrackbar::GetDesiredSize(SIZE *ppt)
{
	*ppt = m_desSize;
}

void CProgressTrackbar::SetDesiredSize(SIZE *psize)
{
	m_desSize = *psize;
	OnDesiredSizeChanged();
}

LRESULT CProgressTrackbar::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
		HANDLE_MSG(hwnd, WM_NOTIFY        , OnNotify);
		HANDLE_MSG(hwnd, WM_HSCROLL       , OnScroll);
		HANDLE_MSG(hwnd, WM_VSCROLL       , OnScroll);
		HANDLE_MSG(hwnd, WM_CTLCOLORSTATIC, OnCtlColor);
		HANDLE_MSG(hwnd, WM_NCDESTROY     , OnNCDestroy);
	}

	return(CFillWindow::ProcessMessage(hwnd, message, wParam, lParam));
}

HBRUSH CProgressTrackbar::OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type)
{
	return(GetBackgroundBrush());
}

LRESULT CProgressTrackbar::PaintChannel(LPNMCUSTOMDRAW pCustomDraw)
{
	static const int NUM_RECTANGLES_MAX = 16;
	static const int NUM_RECTANGLES_MIN = 6;
	static const int g_nAudMeterHeight = 7;

	static const int BorderWidth = 1;

	HDC hdc = pCustomDraw->hdc;
	BOOL bGotDC = FALSE;
	DWORD dwVolume = m_nValChannel;
	bool bTransmitting;

	bTransmitting = HIWORD(dwVolume) & SIGNAL_STATUS_TRANSMIT;
	dwVolume = LOWORD(dwVolume);

	if (!hdc)
	{
		hdc = GetDC(GetWindow());
		bGotDC = TRUE;
	}

	// rectangle leading is 1

	UINT max = GetMaxValue();
	if (dwVolume > max)
	{
		dwVolume = max;
	}

	RECT rect = pCustomDraw->rc;

	int nVuWidth = rect.right - rect.left - 2*BorderWidth;
	if (nVuWidth < (NUM_RECTANGLES_MIN*2))
		return(0);


	// "rect" represents the edges of the meter's outer rectangle

	// compute the number of individual rectangles to use
	// we do the computation this way so that sizing the rebar band
	// makes the size changes consistant
	int nRectsTotal;
	nRectsTotal = (nVuWidth + (g_nAudMeterHeight - 1)) / g_nAudMeterHeight;
	nRectsTotal = min(nRectsTotal, NUM_RECTANGLES_MAX);
	nRectsTotal = max(nRectsTotal, NUM_RECTANGLES_MIN);

	// nRectangleWidth - width of colored rectangle - no leading
	int nRectangleWidth = (nVuWidth/nRectsTotal) - 1;

	// nVuWidth - width of entire VU meter including edges
	nVuWidth = (nRectangleWidth + 1)*nRectsTotal;

	// re-adjust meter size to be an integral number of rects
	int nDiff = (rect.right - rect.left) - (nVuWidth + 2*BorderWidth);

	// Subtract 1 since there is no border on the last one
	rect.right = rect.left + nVuWidth + 2*BorderWidth - 1;

	// center vu-meter across whole channel area so that the
	// slider's thumb is always covering some portion of the channel
	rect.left += (nDiff/2);
	rect.right += (nDiff/2);

	// the background color may change on us!
	COLORREF GreyColor = GetSysColor(COLOR_3DFACE);
	static const COLORREF RedColor = RGB(255,0,0);
	static const COLORREF YellowColor = RGB(255,255,0);
	static const COLORREF GreenColor = RGB(0,255,0);

	COLORREF ShadowColor = GetSysColor(COLOR_3DSHADOW);
	COLORREF HiLiteColor = GetSysColor(COLOR_3DHIGHLIGHT);
	COLORREF LiteColor = GetSysColor(COLOR_3DLIGHT);
	COLORREF DkShadowColor = GetSysColor(COLOR_3DDKSHADOW);

	HBRUSH hGreyBrush = CreateSolidBrush(GreyColor);

	HPEN hShadowPen = CreatePen(PS_SOLID, 0, ShadowColor);

	HBRUSH hRedBrush = CreateSolidBrush (RedColor);
	HBRUSH hGreenBrush = CreateSolidBrush(GreenColor);
	HBRUSH hYellowBrush = CreateSolidBrush(YellowColor);

	RECT rectDraw = rect;

	// draw the 3D frame border
	// HACKHACK georgep: draw outside the rect they gave us
	++rect.bottom;
	DrawEdge(hdc, &rect, BDR_RAISEDINNER, BF_RECT);

	HPEN hOldPen = reinterpret_cast<HPEN>(SelectObject(hdc, hShadowPen));

	// the top and left of the meter has a 2 line border
	// the bottom and right of the meter has a 2 line border
	rectDraw.top    += 1;
	rectDraw.left   += 1;
	rectDraw.right  = rectDraw.left + nRectangleWidth;


	// how many colored rectangles do we draw ?
	int nRects = (dwVolume * nRectsTotal) / max;

	// not transmitting - don't show anything
	if ((false == bTransmitting))
		nRects = 0;

	// transmitting or receiving something very quiet - 
	// light up at least one rectangle
	else if ((bTransmitting) && (nRects == 0))
		nRects = 1;
	
	HBRUSH hCurrentBrush = hGreenBrush;

	POINT ptOld;
	MoveToEx(hdc, 0, 0, &ptOld);

	for (int nIndex = 0; nIndex < nRectsTotal; nIndex++)
	{
		// far left fourth of the bar is green
		// right fourth of the bar is red
		// middle is yellow
		if (nIndex > ((nRectsTotal*3)/4))
			hCurrentBrush = hRedBrush;
		else if (nIndex >= nRectsTotal/2)
			hCurrentBrush = hYellowBrush;

		if (nIndex >= nRects)
			hCurrentBrush = hGreyBrush;

		FillRect(hdc, &rectDraw, hCurrentBrush);

		if (nIndex != (nRectsTotal-1))
		{
			MoveToEx(hdc, rectDraw.left + nRectangleWidth, rectDraw.top, NULL);
			LineTo(hdc, rectDraw.left + nRectangleWidth, rectDraw.bottom);
		}

		rectDraw.left += nRectangleWidth + 1;  // +1 for the leading
		rectDraw.right = rectDraw.left + nRectangleWidth;
	}

	MoveToEx(hdc, ptOld.x, ptOld.y, NULL);
	SelectObject (hdc, hOldPen);

	if (bGotDC)
	{
		ReleaseDC(GetWindow(), hdc);
	}

	DeleteObject(hGreyBrush);

	DeleteObject(hShadowPen);

	DeleteObject(hRedBrush);
	DeleteObject(hGreenBrush);
	DeleteObject(hYellowBrush);

	return(CDRF_SKIPDEFAULT);
}

LRESULT CProgressTrackbar::PaintThumb(LPNMCUSTOMDRAW pCustomDraw)
{
	return(0);

#if FALSE // {
	HBITMAP hbThumb = GetThumb();
	ASSERT(NULL != hbThumb);

	// Draw in the upper left
	HDC hdcDraw = pCustomDraw->hdc;
	HDC hdcTemp = CreateCompatibleDC(hdcDraw);

	if (NULL != hdcTemp)
	{
		HPALETTE hPal = GetPalette();
		HPALETTE hOld = NULL;
		if (NULL != hPal)
		{
			hOld = SelectPalette(hdcDraw, hPal, TRUE);
			RealizePalette(hdcDraw);
			SelectPalette(hdcTemp, hPal, TRUE);
			RealizePalette(hdcTemp);
		}

		SIZE sizeBitmap[NumBitmaps];
		CBitmapButton::GetBitmapSizes(m_hbs, sizeBitmap, NumBitmaps);

		HBITMAP hbThumb = GetThumb();
		if (NULL != SelectObject(hdcTemp, hbThumb))
		{
			RECT rc = pCustomDraw->rc;

			StretchBlt(hdcDraw,
				rc.left, rc.top,
				rc.right-rc.left, rc.bottom-rc.top,
				hdcTemp,
				0, 0, sizeBitmap[Thumb].cx, sizeBitmap[Thumb].cy,
				SRCCOPY);

			// BUGBUG georgep: We should clear any "uncovered" area here
		}

		DeleteDC(hdcTemp);

		if (NULL != hPal)
		{
			SelectPalette(hdcDraw, hOld, TRUE);
		}
	}

	return(CDRF_SKIPDEFAULT);
#endif // FALSE }
}

LRESULT CProgressTrackbar::OnNotify(HWND hwnd, int id, NMHDR *pHdr)
{
	if (NM_CUSTOMDRAW != pHdr->code)
	{
		return(FORWARD_WM_NOTIFY(hwnd, id, pHdr, CGenWindow::ProcessMessage));
	}

	LPNMCUSTOMDRAW pCustomDraw = reinterpret_cast<LPNMCUSTOMDRAW>(pHdr);

	switch (pCustomDraw->dwDrawStage)
	{
		case CDDS_PREPAINT:
			return(CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT);
			break;

		case CDDS_ITEMPREPAINT:
			switch (pCustomDraw->dwItemSpec)
			{
			case TBCD_CHANNEL:
				return(PaintChannel(pCustomDraw));

			case TBCD_THUMB:
				return(PaintThumb(pCustomDraw));
			}

		default:
			break;

	}

	return(FORWARD_WM_NOTIFY(hwnd, id, pHdr, CGenWindow::ProcessMessage));
}

void CProgressTrackbar::OnScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->OnScroll(this, code, pos);
		return;
	}

	// Translate the hwndCtl and let the parent handle the message
	FORWARD_WM_HSCROLL(GetParent(hwnd), GetWindow(), code, pos, SendMessage);
}

void CProgressTrackbar::OnNCDestroy(HWND hwnd)
{
	if (NULL != m_pNotify)
	{
		m_pNotify->Release();
		m_pNotify = NULL;
	}

	FORWARD_WM_NCDESTROY(hwnd, CFillWindow::ProcessMessage);
}

// Change the max value displayed by this progress bar
void CProgressTrackbar::SetMaxValue(UINT maxVal)
{
	HWND hwnd = GetChild();

	::SendMessage(	hwnd,
					TBM_SETRANGE,
					FALSE,
					MAKELONG(0, maxVal));
}

// Return the max value displayed by this progress bar
UINT CProgressTrackbar::GetMaxValue()
{
	HWND hwnd = GetChild();

	return(static_cast<UINT>(::SendMessage(	hwnd,
					TBM_GETRANGEMAX,
					0,
					0)));
}

// Change the current value displayed by this progress bar
void CProgressTrackbar::SetTrackValue(UINT curVal)
{
	HWND hwnd = GetChild();

	::SendMessage(	hwnd,
					TBM_SETPOS,
					TRUE,
					curVal);
}


// Return the current value displayed by this progress bar
UINT CProgressTrackbar::GetTrackValue()
{
	HWND hwnd = GetChild();

	return(static_cast<UINT>(::SendMessage(	hwnd,
					TBM_GETPOS,
					0,
					0)));
}

// Change the current value displayed by this progress bar
void CProgressTrackbar::SetProgressValue(UINT curVal)
{
	if (curVal != m_nValChannel)
	{
		m_nValChannel = curVal;
		SchedulePaint();
	}
}


// Return the current value displayed by this progress bar
UINT CProgressTrackbar::GetProgressValue()
{
	return(m_nValChannel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\progressbar.h ===
// File: Progressbar.h

#ifndef _PROGRESSBAR_H_
#define _PROGRESSBAR_H_

#include "GenWindow.h"
#include "GenContainers.h"

// A progress window class. This uses an outer and inner bitmap to show the progress
class // DECLSPEC_UUID("")
CProgressBar : public CGenWindow
{
public:
	// Default constructor; inits a few intrinsics
	CProgressBar();

	// Create the toolbar window; this object now owns the bitmaps passed in
	BOOL Create(
		HBITMAP hbOuter,	// The outside (static) part of the progress bar
		HBITMAP hbInner,	// The inside part of the progress bar that jumps around
		HWND hWndParent		// The parent of the toolbar window
		);

#if FALSE
	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CProgressBar) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}
#endif // FALSE

	virtual void GetDesiredSize(SIZE *ppt);

	// Change the max value displayed by this progress bar
	void SetMaxValue(UINT maxVal);

	// Return the max value displayed by this progress bar
	UINT GetMaxValue() { return(m_maxVal); }

	// Change the current value displayed by this progress bar
	void SetCurrentValue(UINT curVal);

	// Return the current value displayed by this progress bar
	UINT GetCurrentValue() { return(m_curVal); }

protected:
	virtual ~CProgressBar();

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	enum BitmapParts
	{
		Frame,	// The bitmap that displays the control when at 0%
		Bar,	// The bitmap that gets blasted onto the outer bitmap up to the desired percentage
		NumBitmaps
	} ;

	// The bitmaps that make up the progress bar
	HBITMAP m_hbs[NumBitmaps];
	// The max progress value
	UINT m_maxVal;
	// The current progress value
	UINT m_curVal;

	// Get/set the outer bitmap
	void SetFrame(HBITMAP hbFrame) { m_hbs[Frame] = hbFrame; }
	HBITMAP GetFrame() { return(m_hbs[Frame]); }

	// Get/set the inner bitmap
	void SetBar(HBITMAP hbBar) { m_hbs[Bar] = hbBar; }
	HBITMAP GetBar() { return(m_hbs[Bar]); }

	// Specialized painting function
	void OnPaint(HWND hwnd);
} ;

class CProgressTrackbar;

interface IScrollChange : IUnknown
{
	virtual void OnScroll(CProgressTrackbar *pTrackbar, UINT code, int pos) = 0;
} ;

// A progress window class. This uses an outer and inner bitmap to show the progress
class // DECLSPEC_UUID("")
CProgressTrackbar : public CFillWindow
{
public:
	// Default constructor; inits a few intrinsics
	CProgressTrackbar();

	// Create the toolbar window; this object now owns the bitmaps passed in
	BOOL Create(
		HWND hWndParent,	// The parent of the toolbar window
		INT_PTR nId=0,			// The ID of the control
		IScrollChange *pNotify=NULL	// Object to notify of changes
		);

#if FALSE
	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CProgressTrackbar) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CGenWindow::QueryInterface(riid, ppv));
	}
#endif // FALSE

	virtual void GetDesiredSize(SIZE *ppt);

	// Sets the desired size for this control
	void SetDesiredSize(SIZE *psize);

	// Change the max value displayed by this progress bar
	void SetMaxValue(UINT maxVal);

	// Return the max value displayed by this progress bar
	UINT GetMaxValue();

	// Change the current position of the thumb
	void SetTrackValue(UINT curVal);

	// Return the current position of the thumb
	UINT GetTrackValue();

	// Change the current value displayed by the channel
	void SetProgressValue(UINT curVal);

	// Return the current value displayed by the channel
	UINT GetProgressValue();

protected:
	virtual ~CProgressTrackbar();

	// Forward WM_COMMAND messages to the parent window
	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

	void SchedulePaint()
	{
		// HACK: SETRANGEMAX is the only way to force the slider to update itself...
		SendMessage(GetChild(), TBM_SETRANGEMAX, TRUE, GetMaxValue());
	}

private:
	// The desired size for the control; defaults to (170,23)
	SIZE m_desSize;
	// The current channel value
	UINT m_nValChannel;
	// The object ot notify of changes
	IScrollChange *m_pNotify;

	// Notify handler for custom draw
	LRESULT OnNotify(HWND hwnd, int id, NMHDR *pHdr);
	// Send scroll messages to the parent
	void OnScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
	// Set the correct background color
	HBRUSH OnCtlColor(HWND hwnd, HDC hdc, HWND hwndChild, int type);
	// Free the listener
	void OnNCDestroy(HWND hwnd);

	// Paint the parts of the slider
	LRESULT PaintChannel(LPNMCUSTOMDRAW pCustomDraw);
	LRESULT PaintThumb(LPNMCUSTOMDRAW pCustomDraw);
} ;

#endif // _PROGRESSBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\refcount.cpp ===
// File: refcount.cpp
//
// RefCount class

#include "precomp.h"
#include "ConfUtil.h"


/*  R E F  C O U N T  */
/*-------------------------------------------------------------------------
    %%Function: Init
    
-------------------------------------------------------------------------*/
void RefCount::Init(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	ASSERT((!ObjectDestroyed) ||
		IS_VALID_CODE_PTR(ObjectDestroyed, OBJECTDESTROYEDPROC));

	m_ulcRef = 1;
	m_ObjectDestroyed = ObjectDestroyed;
	DbgMsgRefCount("Ref: %08X c=%d (created)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
#ifdef DEBUG
	m_fTrack = FALSE;
#endif
}

/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount()
{
	Init(NULL);
}

/*-------------------------------------------------------------------------
    %%Function: RefCount
    
-------------------------------------------------------------------------*/
RefCount::RefCount(OBJECTDESTROYEDPROC ObjectDestroyed)
{
	Init(ObjectDestroyed);
}


RefCount::~RefCount(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	// m_ulcRef may be any value.
	DbgMsgRefCount("Ref: %08X c=%d (destroyed)", this, m_ulcRef);

	if (m_ObjectDestroyed)
	{
		m_ObjectDestroyed();
		m_ObjectDestroyed = NULL;
	}

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));
}


ULONG STDMETHODCALLTYPE RefCount::AddRef(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	ASSERT(m_ulcRef < ULONG_MAX);
	m_ulcRef++;
	DbgMsgRefCount("Ref: %08X c=%d (AddRef)", this, m_ulcRef);

	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (AddRef)  *** Tracking", this, m_ulcRef);
	}
#endif
	return m_ulcRef;
}


ULONG STDMETHODCALLTYPE RefCount::Release(void)
{
	ASSERT(IS_VALID_STRUCT_PTR(this, CRefCount));

	if (m_ulcRef > 0)
	{
		m_ulcRef--;
	}

#ifdef DEBUG
	if (m_fTrack)
	{
		DbgMsg(iZONE_OBJECTS, "Obj: %08X c=%d (Release) *** Tracking", this, m_ulcRef);
	}
#endif

	ULONG ulcRef = m_ulcRef;
	DbgMsgRefCount("Ref: %08X c=%d (Release)", this, m_ulcRef);

	if (! ulcRef)
	{
		delete this;
	}

	return ulcRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\rdswiz.cpp ===
// File: rdswiz.cpp

#include "precomp.h"
#include "confcpl.h"
#include "conf.h"
#include "nmremote.h"

#define NUM_RDSPAGES 4

VOID EnableRDS(BOOL fEnabledRDS);
INT_PTR CALLBACK RemotePasswordDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
extern int MessageBoxResource(HWND hwnd, UINT uMessage, UINT uTitle, UINT uFlags);

INT_PTR CALLBACK RDSWizard0Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RDSWizard1Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RDSWizard2Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK RDSWizard3Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

typedef struct _RDSWIZINFO
{
    BOOL fEnabledRDS;
    PBYTE pbHashedPassword;
    DWORD cbHashedPassword;
    CHash* pHash;
} RDSWIZINFO, *PRDSWIZINFO;

BOOL IntCreateRDSWizard(HWND hwndOwner)
{
    UINT uNumPages = 0;
    LPPROPSHEETPAGE ppsp = new PROPSHEETPAGE[NUM_RDSPAGES];
    if (NULL == ppsp)
    {
        ERROR_OUT(("IntCreateRDSWizard: fail to allocate memory"));
        return FALSE;
    }
    CHash hashObject;
    RDSWIZINFO rdsconfig = { FALSE, NULL, 0, &hashObject };

    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_INTRO, RDSWizard0Proc, (LPARAM) &rdsconfig);
    FillInPropertyPage(&ppsp[uNumPages++], ::IsWindowsNT() ? IDD_RDSWIZ_NTPASSWORDS : IDD_RDSWIZ_W98PASSWORD, RDSWizard1Proc, (LPARAM) &rdsconfig);
    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_SCRNSVR, RDSWizard2Proc, (LPARAM) &rdsconfig);
    FillInPropertyPage(&ppsp[uNumPages++], IDD_RDSWIZ_CONGRATS, RDSWizard3Proc, (LPARAM) &rdsconfig);

    PROPSHEETHEADER psh;
    InitStruct(&psh);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.nPages = uNumPages;
    psh.ppsp = ppsp;

    INT_PTR iRet = PropertySheet(&psh);
    if (-1 == iRet)
    {
        ERROR_OUT(("IntCreateRDSWizard: fail to create PropertySheet"));
        return FALSE;
    }

    delete []ppsp;
    return TRUE;
}

INT_PTR CALLBACK RDSWizard0Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static PRDSWIZINFO prds;
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO ) ((PROPSHEETPAGE *)lParam)->lParam;
            ASSERT(prds);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    break;
                }
                case PSN_WIZNEXT:
                {
                    prds->fEnabledRDS = TRUE;
                    break;
                }
                default:
                {
                    break;
                }
            }
            break;
        }
    }
    return FALSE;
}

const int MAXPASSWORDLENGTH = 36;
const int MINPASSWORDLENGTH = 7;

INT_PTR CALLBACK RDSWizard1Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hOldPasswordText, hNewPasswordText, hVerificationText;
    int nOldPasswordLength, nNewPasswordLength, nVerificationLength;
    CHAR lpOldPassword[MAXPASSWORDLENGTH], lpNewPassword[MAXPASSWORDLENGTH], lpVerification[MAXPASSWORDLENGTH];
    WCHAR lpwszOldPassword[MAXPASSWORDLENGTH], lpwszNewPassword[MAXPASSWORDLENGTH];
    PBYTE pbRegPassword;
    DWORD cbRegPassword;

    static PRDSWIZINFO prds;
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO )((PROPSHEETPAGE*)lParam)->lParam;
            if (!::IsWindowsNT())
            {
                ASSERT(prds->pHash);
                RegEntry reLM(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                cbRegPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword);

                if (0 == cbRegPassword)
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORDO), FALSE);
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORD));
                }
                SendDlgItemMessage(hDlg, IDC_EDIT_RDSPASSWORDO, EM_LIMITTEXT,MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_RDSPASSWORD, EM_LIMITTEXT,MAXPASSWORDLENGTH - 1, 0);
                SendDlgItemMessage(hDlg, IDC_EDIT_RDSPASSWORDV, EM_LIMITTEXT,MAXPASSWORDLENGTH - 1, 0);
            }
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;
                }
                case PSN_WIZNEXT:
                {
                    if (!::IsWindowsNT())
                    {
                        PBYTE pbHashedPassword = NULL;
                        DWORD cbHashedPassword = 0;

                        RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);

                        hOldPasswordText = GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORDO);
                        hNewPasswordText = GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORD);
                        hVerificationText = GetDlgItem(hDlg, IDC_EDIT_RDSPASSWORDV);

                        nOldPasswordLength = GetWindowText(hOldPasswordText,lpOldPassword,MAXPASSWORDLENGTH);
                        MultiByteToWideChar(CP_ACP, 0, lpOldPassword, -1, lpwszOldPassword, MAXPASSWORDLENGTH);
            cbRegPassword = reLM.GetBinary(REMOTE_REG_PASSWORD, (void **)&pbRegPassword);
            cbHashedPassword = prds->pHash->GetHashedData((LPBYTE)lpwszOldPassword,
                                                                    sizeof(WCHAR)*strlen(lpOldPassword),
                                                                    (void **)&pbHashedPassword);

            if (0 != cbRegPassword && !(cbHashedPassword == cbRegPassword && 0 == memcmp(pbHashedPassword,pbRegPassword,cbHashedPassword)))
                        {
                            // Error Case - Old password incorrect.
                            MessageBoxResource(hDlg,IDS_REMOTE_OLD_PASSWORD_WRONG_TEXT,IDS_REMOTE_OLD_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hOldPasswordText,NULL);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hOldPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
            }
                        nNewPasswordLength = GetWindowText(hNewPasswordText,lpNewPassword,MAXPASSWORDLENGTH);
                        nVerificationLength = GetWindowText(hVerificationText,lpVerification,MAXPASSWORDLENGTH);

                        if (0 != lstrcmp(lpNewPassword, lpVerification))
                        {
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_WRONG_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        if (nNewPasswordLength < MINPASSWORDLENGTH)
                        {
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_LENGTH_TEXT,IDS_REMOTE_NEW_PASSWORD_LENGTH_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        if (!lstrlen(lpVerification)) {
                            // Don't allow empty password
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_EMPTY,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        if (!FAnsiSz(lpNewPassword)) {
                            // Error Case - T.120 can't handle UNICODE passwords
                            MessageBoxResource(hDlg,IDS_REMOTE_NEW_PASSWORD_INVALID_TEXT,IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE,MB_OK | MB_ICONERROR);
                            SetWindowText(hNewPasswordText,NULL);
                            SetWindowText(hVerificationText,NULL);
                            SetFocus(hNewPasswordText);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            break;
                        }
                        MultiByteToWideChar(CP_ACP, 0, lpNewPassword, -1, lpwszNewPassword, MAXPASSWORDLENGTH);
                        prds->cbHashedPassword = prds->pHash->GetHashedData((LPBYTE)lpwszNewPassword, sizeof(WCHAR)*lstrlen(lpNewPassword), (void **)&prds->pbHashedPassword);

                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
                    }
                    break;
                }

                default:
                {
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
                    break;
                }
            }
            return TRUE;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK RDSWizard2Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static PRDSWIZINFO prds;

    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO )((PROPSHEETPAGE*)lParam)->lParam;
            SendDlgItemMessage(hDlg, IDC_SCRSAVER_NOW, BM_SETCHECK, 1, 0);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    break;
                }

                case PSN_WIZNEXT:
                {
                    if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_SCRSAVER_NOW))
                    {
                        WinExec("Rundll32.exe shell32.dll,Control_RunDLL desk.cpl,,1", SW_SHOWDEFAULT);
                    }
                    break;
                }
            }
            break;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK RDSWizard3Proc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    static PRDSWIZINFO prds;
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            prds = (PRDSWIZINFO ) ((PROPSHEETPAGE*)lParam)->lParam;
            PropSheet_SetWizButtons(hDlg, PSWIZB_FINISH);
            return TRUE;
        }

        case WM_NOTIFY:
        {
            switch (((NMHDR FAR *) lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;
                }
                case PSN_WIZFINISH:
                {
                    ASSERT(prds->fEnabledRDS);
                    EnableRDS(prds->fEnabledRDS);
                    if (!::IsWindowsNT())
                    {
                        ASSERT(prds->pbHashedPassword);
                        ASSERT(prds->cbHashedPassword);
                        RegEntry reLM(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                        reLM.SetValue(REMOTE_REG_PASSWORD,prds->pbHashedPassword,prds->cbHashedPassword);
                    }
                    break;
                }
            }
            break;
        }
    }
    return FALSE;
}

INT_PTR CALLBACK RDSSettingDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    switch(iMsg)
    {
        case WM_INITDIALOG:
        {
            if (::IsWindowsNT())
            {
                ShowWindow(GetDlgItem(hDlg, IDC_RDS_PASSWORD), SW_HIDE);
            }

            RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
            if (reLM.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE))
            {
                SendDlgItemMessage(hDlg, IDC_RDS_RUNRDS, BM_SETCHECK, 1, 0);
            }

            return TRUE;
        }

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    EnableRDS(BST_CHECKED==IsDlgButtonChecked(hDlg, IDC_RDS_RUNRDS));
                    EndDialog(hDlg, 1);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;

                case IDC_RDS_PASSWORD:
                    DialogBox(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_REMOTE_PASSWORD), hDlg, RemotePasswordDlgProc);
                    break;

                case IDC_BUTTON_RDSWIZ:
                {
                    IntCreateRDSWizard(hDlg);
                    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                    SendDlgItemMessage(hDlg, IDC_RDS_RUNRDS, BM_SETCHECK, reLM.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE) ? 1 : 0, 0);
                    break;
                }
                default:
                    break;
            }
            break;
        }
        default:
            break;
    }
    return FALSE;
}

VOID EnableRDS(BOOL fEnabledRDS)
{
    //
    // Can RDS be touched?  Check policies and app sharing state.
    //
    if (ConfPolicies::IsRDSDisabled())
        return;

    if (::IsWindowsNT())
    {
        if (!g_fNTDisplayDriverEnabled)
            return;
    }
    else
    {
        if (ConfPolicies::IsRDSDisabledOnWin9x())
            return;
    }

    {
        RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
        reLM.SetValue(REMOTE_REG_RUNSERVICE, fEnabledRDS ? 1 : 0);
        reLM.SetValue(REMOTE_REG_ACTIVATESERVICE, (ULONG)0);
        if (::IsWindowsNT())
        {
            SC_HANDLE hSCManager = NULL;
            SC_HANDLE hRemoteControl = NULL;
            SERVICE_STATUS serviceStatus;

            hSCManager = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
            hRemoteControl = OpenService(hSCManager,REMOTE_CONTROL_NAME,SERVICE_ALL_ACCESS);

            if (hSCManager)
            {
                if (hRemoteControl)
                {
                    ChangeServiceConfig(hRemoteControl,
                                        SERVICE_NO_CHANGE,
                                        fEnabledRDS ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
                                        SERVICE_NO_CHANGE,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
                    BOOL fSuccess = QueryServiceStatus(hRemoteControl, &serviceStatus);
                    if (fEnabledRDS)
                    {
                        if (fSuccess && SERVICE_STOPPED == serviceStatus.dwCurrentState)
                            StartService(hRemoteControl,0,NULL);
                    }
                    else
                    {
                        if (fSuccess && SERVICE_PAUSED == serviceStatus.dwCurrentState)
                        {
                            if (!ControlService(hRemoteControl,
                                    SERVICE_CONTROL_STOP, &serviceStatus))
                            {
                                WARNING_OUT(("EnableRDS: ControlService failed %d (%x)",
                                    GetLastError(), GetLastError() ));
                            }
                        }
                    }
                    CloseServiceHandle(hRemoteControl);
                }
                else
                {
                    WARNING_OUT(("EnableRDS: OpenService failed %x", GetLastError() ));
                }
                CloseServiceHandle(hSCManager);
            }
            else
            {
                ERROR_OUT(("EnableRDS: OpenSCManager failed: %x", GetLastError() ));
            }
        }
        else
        {
            RegEntry reServiceKey(WIN95_SERVICE_KEY, HKEY_LOCAL_MACHINE);
            HANDLE hServiceEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SERVICE_STOP_EVENT);

            if ( fEnabledRDS )
            {
                TCHAR szSystemDir[MAX_PATH];
                if (GetSystemDirectory(szSystemDir,MAX_PATH)) {
                    // Only append '\' if system dir is not root
                    if ( lstrlen(szSystemDir) > 3 )
                        lstrcat(szSystemDir, _T("\\"));
                    lstrcat(szSystemDir,WIN95_SERVICE_APP_NAME);
                    reServiceKey.SetValue(REMOTE_REG_RUNSERVICE,
                                          szSystemDir);
                }
                if (NULL == hServiceEvent)
                    WinExec(WIN95_SERVICE_APP_NAME,SW_SHOWNORMAL);
            }
            else
            {
                reServiceKey.DeleteValue(REMOTE_REG_RUNSERVICE);
                if (hServiceEvent)
                {
                    SetEvent(hServiceEvent);
                }
            }
            CloseHandle(hServiceEvent);
        }
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\refcount.h ===
// File: refcount.h

#ifndef _REFCOUNT_H_
#define _REFCOUNT_H_

// RefCount destructor callback function
typedef void (*OBJECTDESTROYEDPROC)(void);
VOID STDMETHODCALLTYPE DLLObjectDestroyed(void);
VOID DllLock(void);


//////////////////////////////////////////////////////////////////////////


class RefCount
{
private:
	ULONG m_ulcRef;
	OBJECTDESTROYEDPROC m_ObjectDestroyed;

#ifdef DEBUG
	BOOL m_fTrack;
#endif

	void Init(OBJECTDESTROYEDPROC ObjectDestroyed);

public:
	RefCount();
	RefCount(OBJECTDESTROYEDPROC ObjectDestroyed);
	// Virtual destructor defers to destructor of derived class.
	virtual ~RefCount(void);

	// IUnknown
	ULONG STDMETHODCALLTYPE AddRef(void);
	ULONG STDMETHODCALLTYPE Release(void);

#ifdef DEBUG
	VOID SetTrack(BOOL fTrack)  {m_fTrack = fTrack;}
#endif
};
DECLARE_STANDARD_TYPES(RefCount);


// Special version of the above that calls our standard Dll locking functions
class DllRefCount : public RefCount
{
public:
	DllRefCount() : RefCount(&DLLObjectDestroyed) {DllLock();}
	~DllRefCount(void) {};
};

#endif /* _REFCOUNT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\redial.cpp ===
// File: redial.cpp

#include <precomp.h>
#include "resource.h"

// from confroom.cpp
VOID PlaceCall(LPCTSTR pcszName, LPCTSTR pcszAddress, NM_ADDR_TYPE addrType);


/*  B U I L D  R E D I A L  L I S T  M E N U  */
/*-------------------------------------------------------------------------
    %%Function: BuildRedialListMenu
    
-------------------------------------------------------------------------*/
BOOL BuildRedialListMenu(HMENU hPopupMenu, RegEntry * pRe)
{
	ASSERT(NULL != hPopupMenu);

	MENUITEMINFO mmi;
	InitStruct(&mmi);
	mmi.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
	mmi.wID = ID_FIRST_REDIAL_ITEM;
	mmi.fType = MFT_STRING;

	int cItem = pRe->GetNumber(REGVAL_MRU_COUNT, 0);
	if (0 == cItem)
	{
		// Insert a "stub" item
		TCHAR szMenuText[MAX_PATH];
		if (FLoadString(IDS_REDIAL_EMPTY, szMenuText, CCHMAX(szMenuText)))
		{
			mmi.fState = MFS_DISABLED;
			mmi.dwTypeData = szMenuText;
			mmi.cch = lstrlen(mmi.dwTypeData);
			InsertMenuItem(hPopupMenu, 0, TRUE, &mmi);;
		}
	}
	else
	{
		mmi.fState = MFS_ENABLED;

		for (int iItem = 0; iItem < cItem; iItem++)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), REGVAL_NAME_MRU_PREFIX, iItem);
			mmi.dwTypeData = (LPTSTR) pRe->GetString(szKey);
			mmi.cch = lstrlen(mmi.dwTypeData);
			InsertMenuItem(hPopupMenu, iItem, TRUE, &mmi);;
			mmi.wID++;
		}
	}

	return TRUE;
}


/*  D I S P L A Y  R E D I A L  L I S T  P O P U P  */
/*-------------------------------------------------------------------------
    %%Function: DisplayRedialListPopup
    
-------------------------------------------------------------------------*/
int DisplayRedialListPopup(HMENU hPopupMenu, RECT const *rc)
{
	TPMPARAMS tpm;
	tpm.cbSize = sizeof(tpm);

	tpm.rcExclude = *rc;

	// Popup the menu (making sure it doesn't cover the button)
	int id = ::TrackPopupMenuEx(hPopupMenu,
				TPM_VERTICAL | TPM_TOPALIGN | TPM_RETURNCMD,
				tpm.rcExclude.left, tpm.rcExclude.bottom,
				::GetMainWindow(), &tpm);
	return (0 == id) ? -1 :  id -= ID_FIRST_REDIAL_ITEM;
}



/*  D O  T B  R E D I A L  L I S T  */
/*-------------------------------------------------------------------------
    %%Function: DoTbRedialList
    
-------------------------------------------------------------------------*/
VOID DoTbRedialList(HWND hwndRedial, RECT const *prcExclude)
{
	RECT rcExclude;

	ASSERT(NULL != hwndRedial);

	if (NULL == prcExclude)
	{
		GetClientRect(hwndRedial, &rcExclude);
	}
	else
	{
		rcExclude = *prcExclude;
	}
	::MapWindowPoints(hwndRedial, NULL, (LPPOINT)&rcExclude, 2);

	HMENU hPopupMenu = CreatePopupMenu();
	if (NULL == hPopupMenu)
		return;

	RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);

	if (BuildRedialListMenu(hPopupMenu, &re))
	{
		int iItem = DisplayRedialListPopup(hPopupMenu, &rcExclude);
		if (-1 != iItem)
		{
			TCHAR szKey[MAX_PATH];
			wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_ADDR_MRU_PREFIX, iItem);

			TCHAR szAddress[CCHMAXSZ_ADDRESS];
			lstrcpyn(szAddress, re.GetString(szKey), CCHMAX(szAddress));
			if (!FEmptySz(szAddress))
			{
				wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_TYPE_MRU_PREFIX, iItem);
				NM_ADDR_TYPE addrType = (NM_ADDR_TYPE) re.GetNumber(szKey);

				wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_NAME_MRU_PREFIX, iItem);
				PlaceCall(re.GetString(szKey), szAddress, addrType);
			}
		}
	}
	::DestroyMenu(hPopupMenu);
}


VOID DoTbRedialList(HWND hwndToolbar, UINT uCmd)
{
	RECT rcShow;

	// Determine which toolbar button was pressed:
	int nIndex = SendMessage(hwndToolbar, TB_COMMANDTOINDEX, uCmd, 0);
	// Get it's position
	::SendMessage(hwndToolbar, TB_GETITEMRECT, nIndex, (LPARAM) &rcShow);
	DoTbRedialList(hwndToolbar, &rcShow);
}



/*  G E T  R E D I A L  H E L P  T E X T  */
/*-------------------------------------------------------------------------
    %%Function: GetRedialHelpText
    
-------------------------------------------------------------------------*/
VOID GetRedialHelpText(LPTSTR psz, int cchMax, int id)
{
	TCHAR szKey[MAX_PATH];
	TCHAR szName[CCHMAXSZ_NAME];
	TCHAR szAddress[CCHMAXSZ_ADDRESS];
	TCHAR szUsing[MAX_PATH];
	TCHAR szFormat[MAX_PATH];

	SetEmptySz(psz);

	RegEntry re(DLGCALL_MRU_KEY, HKEY_CURRENT_USER);
	wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_NAME_MRU_PREFIX, id);
	lstrcpyn(szName, re.GetString(szKey), CCHMAX(szName));
	if (FEmptySz(szName))
		return;

	if (!FLoadString(IDS_REDIAL_FORMAT, szFormat, CCHMAX(szFormat)))
		return;

	wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_TYPE_MRU_PREFIX, id);
	int idsUsing;
	switch (re.GetNumber(szKey))
		{
	case NM_ADDR_IP:
	case NM_ADDR_MACHINENAME:
		idsUsing = IDS_CALLUSING_IP;
		break;
	case NM_ADDR_H323_GATEWAY:
		idsUsing = IDS_CALLUSING_PHONE;
		break;
	case NM_ADDR_ULS:
		idsUsing = IDS_CALLUSING_ILS;
		break;
	case NM_ADDR_ALIAS_ID:
	case NM_ADDR_ALIAS_E164:
		idsUsing = IDS_CALLUSING_GK;
		break;
	default:
		idsUsing = 0;
		break;
		}

	if (0 == idsUsing)
	{
		SetEmptySz(szUsing);
	}
	else if (!FLoadString(idsUsing, szUsing, CCHMAX(szUsing)))
	{
		return;
	}
	
	wsprintf(szKey, TEXT("%s%d"), REGVAL_DLGCALL_ADDR_MRU_PREFIX, id);
	lstrcpyn(szAddress, re.GetString(szKey), CCHMAX(szAddress));

	if ((lstrlen(szAddress) + lstrlen(szFormat) + lstrlen(szUsing) + lstrlen(szName)) > cchMax)
	{
		// Just display the address if it won't fit
		lstrcpyn(psz, szAddress, cchMax);
		return;
	}

	wsprintf(psz, szFormat, szName, szUsing, szAddress);
	ASSERT(lstrlen(psz) < cchMax);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\richaddr.h ===
// File richaddr.h
//
// RichAddress definitions

#ifndef _RICH_ADDR_H_
#define _RICH_ADDR_H_

#include "SDKInternal.h"

typedef struct  DWSTR
    {
    DWORD dw;
    LPTSTR psz;
}	DWSTR;


typedef struct  RichAddressInfo
{
	TCHAR szName[ 256 ];
	int cItems;
	DWSTR rgDwStr[ 1 ];
} RichAddressInfo, RAI;

interface IEnumRichAddressInfo
{
public:
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;

	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

    virtual HRESULT STDMETHODCALLTYPE GetAddress( 
        long index,
        RichAddressInfo **ppAddr) = 0;
};

inline
bool
hasValidUserInfo
(
	const RichAddressInfo * const	rai
){
	return( (rai != NULL) && (rai->cItems > 0) && (rai->rgDwStr[ 0 ].psz != NULL) && (rai->rgDwStr[ 0 ].psz[ 0 ] != '\0') );
}

#endif /* _RICH_ADDR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\rostinfo.cpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/

//
//	File:		RostInfo.cpp
//	Created:	ChrisPi		6/17/96
//	Modified:
//
//	The CRosterInfo class is implemented, which is used for adding user
//  information to the T.120 roster
//

#include "precomp.h"
#include <RostInfo.h>

GUID g_csguidRostInfo = GUID_ROSTINFO;

static const HROSTINFO g_cshriEOList = (HROSTINFO)((LONG_PTR)-1);

CRosterInfo::~CRosterInfo()
{
	DebugEntry(CRosterInfo::~CRosterInfo);

	while (FALSE == m_ItemList.IsEmpty())
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.RemoveHead();
		ASSERT(pwszItem);
		delete pwszItem;
	}
	delete m_pvSaveData;

	DebugExitVOID(CRosterInfo::~CRosterInfo);
}

HRESULT CRosterInfo::AddItem(PCWSTR pcwszTag, PCWSTR pcwszData)
{
	DebugEntry(CRosterInfo::AddItem);
	ASSERT(pcwszTag);
	ASSERT(pcwszData);
	HRESULT hr = E_OUTOFMEMORY;

	int nTagLength = lstrlenW(pcwszTag);
	int nDataLength = lstrlenW(pcwszData);

	// +1 for tag sep, +1 for rost info sep
	PWSTR pwszNewItem = new WCHAR[nTagLength + 1 + nDataLength + 1];
	if (NULL != pwszNewItem)
	{
		::CopyMemory(	(PVOID) pwszNewItem,
						pcwszTag,
						sizeof(WCHAR) * nTagLength);
		pwszNewItem[nTagLength] = g_cwchRostInfoTagSeparator;
		::CopyMemory(	(PVOID) &(pwszNewItem[nTagLength + 1]),
						pcwszData,
						sizeof(WCHAR) * nDataLength);
		pwszNewItem[nTagLength + 1 + nDataLength] = g_cwchRostInfoSeparator;
		m_ItemList.AddTail(pwszNewItem);
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::AddItem, hr);
	return hr;
}

HRESULT CRosterInfo::ExtractItem(	PHROSTINFO phRostInfo,
									PCWSTR pcwszTag,
									LPTSTR pszBuffer,
									UINT cbLength)
{
	DebugEntry(CRosterInfo::ExtractItem);
	ASSERT(pcwszTag);
	HRESULT hr = E_FAIL;
	
	USES_CONVERSION;
	
	POSITION pos;
	if ((NULL == phRostInfo) ||
		(NULL == *phRostInfo))
	{
		pos = m_ItemList.GetHeadPosition();
	}
	else
	{
		pos = *phRostInfo;
	}

	if (g_cshriEOList != pos)
	{
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			if (NULL != phRostInfo)
			{
				*phRostInfo = (NULL != pos) ? pos : g_cshriEOList;
			}
			ASSERT(pwszItem);
			int nItemLength = lstrlenW(pwszItem);
			int nTagLength = lstrlenW(pcwszTag);
			
			// NOTE: CRT is used for memcmp
			if ((nItemLength > nTagLength) &&
				(0 == memcmp(	pcwszTag,
								pwszItem,
								sizeof(WCHAR) * nTagLength)) &&
				(g_cwchRostInfoTagSeparator == pwszItem[nTagLength]))
			{
				if (NULL != pszBuffer)
				{
					lstrcpyn(pszBuffer, W2T(&(pwszItem[nTagLength + 1])), cbLength);
				}

				hr = S_OK;
				break;
			}
		}
	}

	DebugExitHRESULT(CRosterInfo::ExtractItem, hr);
	return hr;
}

HRESULT CRosterInfo::Load(PVOID pData)
{
	DebugEntry(CRosterInfo::Load);
	HRESULT hr = E_FAIL;

	PWSTR pwszUserInfo = (PWSTR) pData;
	if (NULL != pwszUserInfo)
	{
		hr = S_OK;
		while (L'\0' != pwszUserInfo[0])
		{
			// this includes the null terminator
			int nItemLenNT = lstrlenW(pwszUserInfo) + 1;
			PWSTR pwszNewItem = new WCHAR[nItemLenNT];
			if (NULL != pwszNewItem)
			{
				::CopyMemory(	pwszNewItem,
								pwszUserInfo,
								sizeof(WCHAR) * nItemLenNT);
				m_ItemList.AddTail(pwszNewItem);
				// Skip past this item and the n.t.
				pwszUserInfo += nItemLenNT;
			}
			else
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}
	}
	else
	{
		TRACE_OUT(("CRosterInfo::Load() called with NULL pData"));
	}

	DebugExitHRESULT(CRosterInfo::Load, hr);
	return hr;
}

UINT CRosterInfo::GetSize()
{
	UINT uSize = sizeof(WCHAR); // for last separator

	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		uSize += sizeof(WCHAR) * (lstrlenW(pwszItem) + 1);
	}

	return uSize;
}

HRESULT CRosterInfo::Save(PVOID* ppvData, PUINT pcbLength)
{
	DebugEntry(CRosterInfo::Save);
	ASSERT(ppvData);
	ASSERT(pcbLength);
	HRESULT hr = E_FAIL;

	*pcbLength = GetSize();
	delete m_pvSaveData;
	m_pvSaveData = new BYTE[*pcbLength];
	if (NULL != m_pvSaveData)
	{
		PWSTR pwszDest = (PWSTR) m_pvSaveData;
		POSITION pos = m_ItemList.GetHeadPosition();
		while (NULL != pos)
		{
			PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
			ASSERT(pwszItem);
			::CopyMemory(	pwszDest,
							pwszItem,
							sizeof(WCHAR) * (lstrlenW(pwszItem) + 1));
			pwszDest += (lstrlenW(pwszItem) + 1);
		}
		int nLastSepPos = (*pcbLength / sizeof(WCHAR)) - 1;
		((PWSTR)m_pvSaveData)[nLastSepPos] = g_cwchRostInfoSeparator;
		*ppvData = m_pvSaveData;
		hr = S_OK;
	}

	DebugExitHRESULT(CRosterInfo::Save, hr);
	return hr;
}

#ifdef DEBUG
VOID CRosterInfo::Dump()
{
	POSITION pos = m_ItemList.GetHeadPosition();
	while (NULL != pos)
	{
		PWSTR pwszItem = (PWSTR) m_ItemList.GetNext(pos);
		ASSERT(pwszItem);
		TRACE_OUT(("\t%ls", pwszItem));
	}
}
#endif // DEBUG

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\roomlist.cpp ===
// File: roomlist.cpp

#include "precomp.h"
#include "resource.h"
#include "ConfRoom.h"
#include "RoomList.h"
#include "RToolbar.h"
#include "VidView.h"
#include "RostInfo.h"
#include "particip.h"


static const int RL_NUM_ICON_COLUMNS =		0;


/*  C  R O O M  L I S T  V I E W  */
/*-------------------------------------------------------------------------
    %%Function: CRoomListView

-------------------------------------------------------------------------*/
CRoomListView::CRoomListView():
	// m_iSortColumn		(0),
	m_lUserData(0),
	m_fSortAscending	(TRUE)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CRoomListView", this);
}

CRoomListView::~CRoomListView()
{
	ListView_DeleteAllItems(m_hWnd);

	if(IsWindow())
	{
		DestroyWindow();		
	}

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CRoomListView", this);
}

CParticipant * CRoomListView::GetParticipant(void)
{
	LPARAM lParam = GetSelectedLParam();
	return (CParticipant *) lParam;
}

//////////////////////////////////////////////////////////////////////////
// CRoomListView::CView

VOID CRoomListView::Show(BOOL fVisible)
{
	if (NULL != m_hWnd)
	{
		::ShowWindow(m_hWnd, fVisible ? SW_SHOW : SW_HIDE);
	}
}

VOID CRoomListView::ShiftFocus(HWND hwndCur, BOOL fForward)
{
	if ((NULL == hwndCur) && (NULL != m_hWnd))
	{
		::SetFocus(m_hWnd);
	}
}

VOID CRoomListView::Redraw(void)
{
	if (NULL == m_hWnd)
		return;

	// Invalidate entire client area and force erase:
	::InvalidateRect(m_hWnd, NULL, TRUE);

	// Force an immediate repaint:
	::UpdateWindow(m_hWnd);
}

VOID CRoomListView::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// Pass all messages to the list view window:
	if (NULL != m_hWnd)
	{
		::SendMessage(m_hWnd, uMsg, wParam, lParam);
	}
}



BOOL CRoomListView::Create(HWND hwndParent)
{
	DBGENTRY(CRoomListView::FCreate);

	RECT rcPos;
	SetRect( &rcPos, 0, 0, 0, 0 );
	DWORD dwStyle = WS_CHILD | WS_TABSTOP | LVS_REPORT | LVS_SINGLESEL | LVS_AUTOARRANGE | LVS_SHAREIMAGELISTS;
	DWORD dwExStyle = WS_EX_CLIENTEDGE;
	
	CWindowImpl<CRoomListView>::Create( hwndParent, rcPos, g_szEmpty, dwStyle, dwExStyle, ID_LISTVIEW );

	if (NULL == m_hWnd)
		return FALSE;

	// initialize the list view window

	// Associate the image list with the list view
	ListView_SetImageList(m_hWnd, g_himlIconSmall, LVSIL_SMALL);

	// Now initialize the columns we will need
	// Initialize the LV_COLUMN structure
	// the mask specifies that the .fmt, .ex, width, and .subitem members
	// of the structure are valid,

	LV_COLUMN lvC;			// List View Column structure
	ClearStruct(&lvC);
	TCHAR pszText[256];		// place to store some text

	lvC.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvC.fmt = LVCFMT_LEFT;

	SIZE size;
	GetDesiredSize(&size);
	int iWidth = size.cx;

	// default width of the non-icon columns (-1 to prevent creating a scrollbar)
	int iIconColWidth = ::GetSystemMetrics(SM_CXSMICON) + 7; // 7 additional pixels
	int iTextColWidth = ((iWidth - (RL_NUM_ICON_COLUMNS * iIconColWidth))
							/ (NUM_COLUMNS - RL_NUM_ICON_COLUMNS)) - 1;
	lvC.pszText = pszText;

	// Add the columns.
    for (int index = 0; index < NUM_COLUMNS; index++)
	{
		HD_ITEM hdi;
		hdi.mask = HDI_IMAGE | HDI_FORMAT;
		hdi.fmt = HDF_IMAGE;
		lvC.iSubItem = index;
		switch (index)
		{
			case COLUMN_INDEX_NAME:
			default:
			{
				// These are text or text&icon columns
				hdi.iImage = -1;
				lvC.cx = iTextColWidth;
				break;
			}
		}
		LoadString(::GetInstanceHandle(),
					IDS_COLUMN_NAME + index,
					pszText,
					CCHMAX(pszText));
		if (-1 != ListView_InsertColumn(m_hWnd, index, &lvC))
		{
			if (-1 != hdi.iImage)
			{
				ASSERT(ListView_GetHeader(m_hWnd));
				Header_SetItem(ListView_GetHeader(m_hWnd), index, &hdi);
			}
		}
		else
		{
			WARNING_OUT(("Could not insert column %d in list view", index));
		}
	}
	ASSERT(ListView_GetHeader(m_hWnd));
	Header_SetImageList(ListView_GetHeader(m_hWnd), g_himlIconSmall);

	// set the style to do drag and drop headers and full row select
	dwExStyle = ListView_GetExtendedListViewStyle(m_hWnd);
	dwExStyle |= (LVS_EX_SUBITEMIMAGES | LVS_EX_HEADERDRAGDROP);
	ListView_SetExtendedListViewStyle(m_hWnd, dwExStyle);
	
	return TRUE;
}

LRESULT CRoomListView::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	int cx = LOWORD(lParam);

	HWND hwndHeader = ListView_GetHeader(m_hWnd);
	if (NULL != hwndHeader)
	{
		// This check is to avoid a RIP in debug windows
		ListView_SetColumnWidth(m_hWnd, 0, cx);
	}

	bHandled = FALSE;
	return(0);
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   Add(int iPosition, LPARAM lParam)
*
*    PURPOSE:  Adds a item to the list view
*
****************************************************************************/

BOOL CRoomListView::Add(int iPosition, CParticipant * pPart)
{
	DebugEntry(CRoomListView::Add);
	BOOL bRet = FALSE;

	int nPrevCount = ListView_GetItemCount(m_hWnd);
	LV_ITEM lvI;        // List view item structure

	// Fill in the LV_ITEM structure
	// The mask specifies the the .pszText, .iImage, .lParam and .state
	// members of the LV_ITEM structure are valid.
	lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
	lvI.state = (0 == nPrevCount) ? LVIS_FOCUSED : 0;
	lvI.stateMask = LVIS_FOCUSED;
	lvI.iItem = iPosition;
	lvI.iSubItem = 0;

	// The parent window is responsible for storing the text. The List view
	// window will send a LVN_GETDISPINFO when it needs the text to display
	lvI.pszText = LPSTR_TEXTCALLBACK;
	lvI.cchTextMax = MAX_ITEMLEN;
	lvI.iImage = I_IMAGECALLBACK;
	lvI.lParam = (LPARAM) pPart;

	if (-1 != ListView_InsertItem(m_hWnd, &lvI))
	{
		pPart->AddRef(); // the ListView keeps a reference on this

		// set the text for each of the columns for report view
		for (int iSubItem = 1; iSubItem < NUM_COLUMNS; iSubItem++)
		{
			ListView_SetItemText(	m_hWnd,
									iPosition,
									iSubItem,
									LPSTR_TEXTCALLBACK);
		}
		ListView_SortItems( m_hWnd,
							CRoomListView::RoomListViewCompareProc,
							(LPARAM)(this));
	}
	
	DebugExitBOOL(CRoomListView::Add, bRet);
	return bRet;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   LParamToPos(LPARAM lParam)
*
*    PURPOSE:  Returns the position index associated with the lParam value
*
****************************************************************************/

int CRoomListView::LParamToPos(LPARAM lParam)
{
	// Note: retuns -1 on failure
	
	LV_FINDINFO lvF;
	lvF.flags = LVFI_PARAM;
	lvF.lParam = lParam;

	return ListView_FindItem(m_hWnd, -1, &lvF);
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   GetSelectedLParam()
*
*    PURPOSE:  Returns the lParam of the selected item or NULL (no sel.)
*
****************************************************************************/

LPARAM CRoomListView::GetSelectedLParam()
{
	LPARAM lRet = NULL;

	if (::GetFocus() == m_hWnd)
	{
		// The list view has the focus, so find the selected item (if any)
		int iItem = ListView_GetNextItem(m_hWnd, -1, LVNI_ALL | LVNI_SELECTED);
		if (-1 != iItem)
		{
			LV_ITEM lvi;
			lvi.iItem = iItem;
			lvi.iSubItem = 0;
			lvi.mask = LVIF_PARAM;
			if (ListView_GetItem(m_hWnd, &lvi))
			{
				lRet = lvi.lParam;
			}
		}
	}

	return lRet;
}

/*  R E M O V E  */
/*-------------------------------------------------------------------------
    %%Function: Remove

	Removes an item from the list view
-------------------------------------------------------------------------*/
VOID CRoomListView::Remove(LPARAM lParam)
{
	DBGENTRY(CRoomListView::Remove);

	int iPosition = LParamToPos(lParam);
	if (-1 == iPosition)
		return;

	ListView_DeleteItem(m_hWnd, iPosition);
}


/*  O N  C H A N G E  P A R T I C I P A N T  */
/*-------------------------------------------------------------------------
    %%Function: OnChangeParticipant

    Updates the user's status information
-------------------------------------------------------------------------*/
VOID CRoomListView::OnChangeParticipant(CParticipant * pPart, NM_MEMBER_NOTIFY uNotify)
{
	DBGENTRY(CRoomListView::OnChangeParticipant);


	switch (uNotify)
		{
	case NM_MEMBER_ADDED:
	{
		// Add the new member to the start of the list
		Add(0, pPart);
		break;
	}

	case NM_MEMBER_REMOVED:
	{
		// Remove the member from the list
		Remove((LPARAM) pPart);
		break;
	}

	case NM_MEMBER_UPDATED:
	{
		int iPos = LParamToPos((LPARAM) pPart);
		if (-1 == iPos)
			return;

		ListView_RedrawItems(m_hWnd, iPos, iPos);
		ListView_SortItems(m_hWnd, CRoomListView::RoomListViewCompareProc, (LPARAM)(this));
		break;
	}

	default:
		break;
		}
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   OnNotify(WPARAM, LPARAM)
*
*    PURPOSE:  Handles WM_NOTIFY messages sent to the list view
*
****************************************************************************/

LRESULT	CRoomListView::OnNotify(WPARAM wParam, LPARAM lParam)
{
	LRESULT lRet = 0L;
	
	LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
	ASSERT(pLvdi);
	
	if (ID_LISTVIEW == wParam)
	{
		switch(pLvdi->hdr.code)
		{
			case NM_DBLCLK:
			case NM_RETURN:
			{
				if (0x8000 & ::GetKeyState(VK_MENU))
				{
					::PostMessage(::GetMainWindow(), WM_COMMAND, IDM_POPUP_PROPERTIES, 0);
				}
				break;
			}
			
			case NM_CLICK:
			case NM_RCLICK:
			{
				LV_HITTESTINFO lvhi;
				::GetCursorPos(&(lvhi.pt));
				::MapWindowPoints(NULL, m_hWnd, &(lvhi.pt), 1);
				ListView_SubItemHitTest(m_hWnd, &lvhi);
				if (LVHT_ONITEMICON | lvhi.flags)
				{
					lRet = OnClick(&lvhi, (NM_CLICK == pLvdi->hdr.code));
				}
				break;
			}

			case LVN_DELETEITEM:
			{
				NM_LISTVIEW  * pnmv = (NM_LISTVIEW *) lParam;
				CParticipant * pPart = (CParticipant *) pnmv->lParam;

				ASSERT(pPart);

				if (pPart)
				{
					pPart->Release();
				}

				break;
			}

			case LVN_GETDISPINFO:
			{
				GetDispInfo(pLvdi);
				break;
			}

			case LVN_COLUMNCLICK:
			{
				// The user clicked on one of the column headings - sort by
				// this column.
				TRACE_OUT(("CRoomListView::OnNotify called (NM_COLUMNCLICK)"));
				NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
				ASSERT(pNm);

				if (pNm->iSubItem == m_iSortColumn)
				{
					m_fSortAscending = !m_fSortAscending;
				}
				else
				{
					m_fSortAscending = TRUE;
				}
				// m_iSortColumn = pNm->iSubItem;
				ListView_SortItems( pNm->hdr.hwndFrom,
									CRoomListView::RoomListViewCompareProc,
									(LPARAM)(this));
				break;
			}

			default:
				break;
		}
	}

	return lRet;
}

/*  G E T  D I S P  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetDispInfo

    Get the display information for a participant
-------------------------------------------------------------------------*/
VOID CRoomListView::GetDispInfo(LV_DISPINFO * pLvdi)
{
	CParticipant * pPart = (CParticipant *) (pLvdi->item.lParam);
	if (NULL == pPart)
		return;

	// Get the text
	if (pLvdi->item.mask & LVIF_TEXT)
	{
		switch (pLvdi->item.iSubItem)
			{
		case COLUMN_INDEX_NAME:
		{
			lstrcpyn(pLvdi->item.pszText, pPart->GetPszName(), pLvdi->item.cchTextMax);
			break;
		}

		default:
			break;
			}
	}

	// Get the Image
	if (pLvdi->item.mask & LVIF_IMAGE)
	{
		switch (pLvdi->item.iSubItem)
			{
		case COLUMN_INDEX_NAME:
		{
			pLvdi->item.iImage = II_USER;
			break;
		}
		default:
			break;
			}
	}
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   LoadColumnInfo(RegEntry* pre)
*
*    PURPOSE:  Loads the column position info in the registry
*
****************************************************************************/

BOOL CRoomListView::LoadSettings(RegEntry* pre)
{
	DebugEntry(CRoomListView::LoadColumnInfo);

	// BUGBUG georgep: Using a fixed initial width for now; should take a max
	// of longest name and the window width
	ListView_SetColumnWidth(m_hWnd, 0, 300);

	DebugExitBOOL(CRoomListView::LoadColumnInfo, TRUE);
	return TRUE;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   OnClick(LV_HITTESTINFO*, BOOL)
*
*    PURPOSE:  Handles creating a popup menu when clicking on some icons
*
****************************************************************************/

/*  O N  C L I C K  */
/*-------------------------------------------------------------------------
    %%Function: OnClick

	Handles creating a popup menu when clicking on some icons
-------------------------------------------------------------------------*/
LRESULT CRoomListView::OnClick(LV_HITTESTINFO* plvhi, BOOL fLeftClick)
{
	ASSERT(NULL != plvhi);

	// Select the item:
	ListView_SetItemState(m_hWnd, plvhi->iItem,
			LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

	switch (plvhi->iSubItem)
	{
		case COLUMN_INDEX_NAME:
		{
			if (fLeftClick)
				return 0; // selection
			break;
		}

		default:
			return 0;
	}

	// convert back to screen coords
	::MapWindowPoints(m_hWnd, NULL, &(plvhi->pt), 1);
	OnPopup(plvhi->pt);

	return 1;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   OnPopup(POINT)
*
*    PURPOSE:  Handles popup menu
*
****************************************************************************/

BOOL CRoomListView::OnPopup(POINT pt)
{
	CParticipant * pPart = GetParticipant();
	if (NULL == pPart)
		return FALSE;
	
	// Get the menu for the popup from the resource file.
	HMENU hMenu = LoadMenu(::GetInstanceHandle(), MAKEINTRESOURCE(IDR_USER_POPUP));
	if (NULL == hMenu)
		return FALSE;

	// Get the first menu in it which we will use for the call to
	// TrackPopup(). This could also have been created on the fly using
	// CreatePopupMenu and then we could have used InsertMenu() or
	// AppendMenu.
	HMENU hMenuTrackPopup = GetSubMenu(hMenu, 0);
	ASSERT(NULL != hMenuTrackPopup);

	::EnableMenuItem(hMenuTrackPopup, IDM_POPUP_SPEEDDIAL,
				pPart->FEnableCmdCreateSpeedDial() ? MF_ENABLED : MF_GRAYED);

	::EnableMenuItem(hMenuTrackPopup, IDM_POPUP_ADDRESSBOOK,
				pPart->FEnableCmdCreateWabEntry() ? MF_ENABLED : MF_GRAYED);

	::EnableMenuItem(hMenuTrackPopup, IDM_POPUP_EJECT,
				pPart->FEnableCmdEject() ? MF_ENABLED : MF_GRAYED);

    // GiveControl/CancelGiveControl()
    pPart->CalcControlCmd(hMenuTrackPopup);


	BOOL fShowMenu = TRUE;
	// Check to see if we have "special" coordinates that signify
	// that we entered here as a result of a keyboard click
	// instead of a mouse click - and if so, get some default coords
	if ((0xFFFF == pt.x) && (0xFFFF == pt.y))
	{
		int iPos = LParamToPos((LPARAM)pPart);
		RECT rctIcon;
		if ((-1 == iPos) ||
			(FALSE == ListView_GetItemRect(	m_hWnd,
											iPos,
											&rctIcon,
											LVIR_ICON)))
		{
			fShowMenu = FALSE;
		}
		else
		{
			// Convert from client coords to screen coords
			::MapWindowPoints(m_hWnd, NULL, (LPPOINT)&rctIcon, 2);
			pt.x = rctIcon.left + ((rctIcon.right - rctIcon.left) / 2);
			pt.y = rctIcon.top + ((rctIcon.bottom - rctIcon.top) / 2);
		}
	}

	if (fShowMenu)
	{
		HWND hwnd = ::GetMainWindow();

		// Draw and track the "floating" popup
		int cmd = TrackPopupMenu(	hMenuTrackPopup,
						TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
						pt.x,
						pt.y,
						0,
						hwnd,
						NULL);

		// Get this again since we just ended a message loop
		pPart = GetParticipant();

		if (0 != cmd && NULL != pPart)
		{
			pPart->OnCommand(hwnd, (WORD)cmd);
		}
	}

	// We are finished with the menu now, so destroy it
	DestroyMenu(hMenu);

	return TRUE;
}

/****************************************************************************
*
*    CLASS:    CRoomListView
*
*    MEMBER:   Callback used for sorting the list view
*
****************************************************************************/

int CALLBACK CRoomListView::RoomListViewCompareProc(LPARAM lParam1,
													LPARAM lParam2,
													LPARAM lParamSort)
{
	DebugEntry(RoomListViewCompareProc);

	CParticipant * pPart1 = (CParticipant *)lParam1;
	CParticipant * pPart2 = (CParticipant *)lParam2;

	CRoomListView* prlv = (CRoomListView*) lParamSort;
	ASSERT(prlv);
	int iResult = 0;

	if (pPart1 && pPart2)
	{
		switch (prlv->m_iSortColumn)
		{
			case COLUMN_INDEX_NAME:
			{
				LPTSTR lpStr1 = pPart1->GetPszName();
				LPTSTR lpStr2 = pPart2->GetPszName();
				iResult = lstrcmpi(lpStr1, lpStr2);
				break;
			}

			default:
			{
				ERROR_OUT(("Sorting by unknown label"));
				break;
			}
		}

	}

	if (!prlv->m_fSortAscending)
	{
		iResult = -iResult;
	}
	
	DebugExitINT(RoomListViewCompareProc, iResult);
	return iResult;
}


VOID TileBltWatermark(UINT x, UINT y, UINT cx, UINT cy, UINT xOff, UINT yOff, HDC hdcDst, HDC hdcSrc,
	UINT cxWatermark, UINT cyWatermark)
{
	DBGENTRY(CRoomListView::TileBltWatermark)

	int cxPart, cyPart;
	BOOL fxTile, fyTile;
ReCheck:
	fxTile = ((xOff + cx) > cxWatermark);
	fyTile = ((yOff + cy) > cyWatermark);

	if (!fxTile && !fyTile)
	{
		// no tiling needed -- blt and leave
		BitBlt(hdcDst, x, y, cx, cy, hdcSrc, xOff, yOff, SRCCOPY);
		DBGEXIT(CRoomListView::TileBltWatermark)
		return;
	}

	if (!fxTile)
	{
		// vertically tile
		cyPart = cyWatermark - yOff;
		BitBlt(hdcDst, x, y, cx, cyPart, hdcSrc, xOff, yOff, SRCCOPY);
		y += cyPart;
		cy -= cyPart;
		yOff = 0;
		goto ReCheck;
	}

	if (!fyTile)
	{
		// horizontally tile
		cxPart = cxWatermark - xOff;
		BitBlt(hdcDst, x, y, cxPart, cy, hdcSrc, xOff, yOff, SRCCOPY);
		x += cxPart;
		cx -= cxPart;
		xOff = 0;
		goto ReCheck;
	}

	// tile both ways
	cyPart = cyWatermark - yOff;
	TileBltWatermark(x, y, cx, cyPart, xOff, yOff, hdcDst, hdcSrc, cxWatermark, cyWatermark);
	y += cyPart;
	cy -= cyPart;
	yOff = 0;
	goto ReCheck;
}

void CRoomListView::GetDesiredSize(SIZE *ppt)
{
	// BUGBUG georgep: faking these numbers; should use something dependent on the font size
	ppt->cx = 200;
	ppt->cy = 100;
}


// a quick but simple function to convert the "unicode" characters
// from the H.245 roster info struct to ascii
int Unicode4ToAsciiOEM009(char *szIn, char *szOut)
{
	while (*szIn)
	{
		*szOut = (*szIn) - 4;
		szIn++;
		szOut++;
	}

	*szOut = '\0';
	return 0;

}










=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Conf.rc
//
#define IDC_ONDESKTOP                   0
#define IDC_ONQUICKLAUNCH               1
#define IDI_CONFROOM                    2
#define IDB_SHOWDBG                     3
#define IDS_LICENSEDTO                  8
#define IDS_COPYRIGHT                   9
#define IDB_INTROWIZ                    10
#define IDS_ABOUT_COPYRIGHT             10
#define IDS_DIRLIST_STATIC_WIDTH        13
#define IDS_SPLASHFONT                  13
#define IDS_SPLASHFONTSIZE              14
#define IDS_REMOTE_VIDEO_TITLE          18
#define IDS_MYVIDEO                     19
#define IDS_SPEEDDIAL_FOLDER            20
#define IDS_NONHOST_TOOLS               21
#define IDS_NONHOST_YOUACCEPT           22
#define IDS_NONHOST_YOUINVITE           23
#define IDS_TOOLBAR_TEXTROWS            35
#define IDS_TOOLBAR_BUTTON_WIDTH        36
#define IDS_DEFAULT_LAYOUT              42
#define IDS_UPROP_EMAIL                 71
#define IDS_UPROP_CITY                  72
#define IDS_UPROP_COUNTRY               73
#define IDS_UPROP_STATUS                74
#define IDS_UPROP_RECEIVED              75
#define IDS_UPROP_ADDRESS               76
#define IDS_UPROP_VIDEO                 77
#define IDS_UPROP_AUDIO                 78
#define IDS_UPROP_COMMENTS              79
#define IDS_UPROP_SECURITY              80
#define IDS_UPROP_SHARING               81
#define IDS_UPROP_CONTROL               82
#define IDS_UPROP_VERSION               83
#define IDS_CANT_START_NM_BECAUSE_SDK_APP_OWNS_NM 84
#define IDS_CONTAINER_GOING_AWAY_BUT_ACVITE_CONFERENCE 85
#define IDI_HOSTMEET                    90
#define IDI_SM_WORLD                    91
#define IDR_NETMEETING                  92
#define IDR_VIDEOWINDOW                 93
#define IDR_NMMANAGER                   95
#define IDR_NMAPP                       96
#define IDR_NMAPPLET                    97
#define IDD_PASSWORD                    101
#define IDB_TOOLBAR                     102
#define IDD_PAGE_SERVER                 102
#define IDR_CONFROOM_MENU               103
#define IDD_OPTIONS                     103
#define IDB_CONFROOM_TOOLBAR            104
#define IDM_CONNECT                     104
#define IDR_USERPOPUP                   105
#define IDM_ALISTEN                     105
#define IDR_TASKBAR_POPUP               105
#define IDR_USER_POPUP                  107
#define IDD_SECURITY                    107
#define IDB_POPUPBAR                    108
#define IDD_RDSWIZ_W98PASSWORD          108
#define IDD_RDSWIZ_NTPASSWORDS          109
#define IDS_HARDWARE_DETECTED           110
#define IDD_RDSWIZ_CONGRATS             110
#define IDS_NO_HARDWARE_DETECTED        111
#define IDI_SPKERROR                    111
#define IDI_MICERROR                    112
#define IDD_PASSWORD_RDS                113
#define IDI_MICEMPTY                    114
#define IDD_CALL                        115
#define IDI_SPKEMPTY                    116
#define IDB_DIRECTORY                   119
#define IDB_CALL_UP                     120
#define IDB_WHITEBOARD                  120
#define IDB_CALL_DOWN                   121
#define IDD_INTROWIZ                    121
#define IDB_DIAL                        121
#define IDD_ADV_CALL                    122
#define IDB_HANGUP                      122
#define IDB_SHARE                       123
#define IDR_ACCELERATORS                124
#define IDB_CHAT                        124
#define IDS_SHARING_NOTHING             126
#define IDS_SHARING_APPS                127
#define IDS_SHARING_DESKTOP             128
#define IDS_CONTROL_CONTROLLEDBY        129
#define IDS_CONTROL_INCONTROLOF         130
#define IDS_CONTROL_CONTROLLABLE        131
#define IDS_CONTROL_NOTCONTROLLABLE     132
#define IDD_CHOOSECONF                  134
#define IDI_NET                         135
#define IDC_CALL_ANIMATION              136
#define IDA_CALL_ANIMATION              137
#define IDB_CALL                        138
#define IDB_PLAYPAUSE                   139
#define IDB_AUDIO                       141
#define IDB_PIP                         142
#define IDD_HOST_SETTINGS               143
#define IDD_USER_PROPERTIES             144
#define IDB_ADDRESSBAR                  145
#define IDB_CONFROOM_TOOLBAR_HOT        146
#define IDD_DBG_VERSION                 147
#define IDD_DBG_OPTIONS                 148
#define IDI_SPEAKER                     148
#define IDI_MICFONE                     149
#define IDI_SIGNAL_LEVEL                150
#define IDD_INCOMING_CALL               151
#define IDD_ABOUT_BOX                   152
#define IDD_CALL_PROGRESS               153
#define IDD_DONT_SHOW_ME                154
#define IDB_SHOWAV                      155
#define IDI_USER_WATCHING               156
#define IDB_DIALSTAR                    156
#define IDI_USER_WORKING_ALONE          157
#define IDB_DIAL1                       157
#define IDD_USER_CREDENTIALS            158
#define IDB_DIAL2                       158
#define IDB_DIAL3                       159
#define IDI_CHECKON                     160
#define IDB_DIAL4                       160
#define IDI_CHECKOFF                    161
#define IDB_DIAL5                       161
#define IDB_DIAL6                       162
#define IDD_CREATE_SPEED_DIAL           163
#define IDB_DIAL7                       163
#define IDB_DIAL8                       164
#define IDB_DIAL9                       165
#define IDB_DIALPOUND                   166
#define IDC_STIDERC                     167
#define IDB_DIAL0                       167
#define IDB_SPLASH                      173
#define IDB_DIR_TOOLBAR                 174
#define IDB_DIR_TOOLBAR_HOT             175
#define IDB_ICON_IMAGES                 175
#define IDR_CALL                        180
#define IDB_COOLBAR_BACK                182
#define IDD_SECURE_INCOMING_CALL        183
#define IDB_FILE_TRANSFER               183
#define IDS_NO_USER_CERTS               184
#define IDD_VIDEOWIZ                    185
#define IDD_RDSWIZ_INTRO                185
#define IDI_NETGRAY                     185
#define IDD_VIDEOWIZ_NO_CAMERA          186
#define IDD_SHRTCUTWIZ                  186
#define IDD_VIDEOWIZ_NO_PENTIUM         187
#define IDB_VIDEO_LOGO_SMALL            187
#define IDR_VIDEO_POPUP                 188
#define IDI_DIRECTORY                   188
#define IDR_MAINUI                      189
#define IDI_WEBVIEW                     190
#define IDI_HELP                        191
#define IDI_REFRESH                     192
#define IDI_VIDEO_OUT                   193
#define IDD_BANDWIDTH                   193
#define IDD_OPT_GENERAL                 194
#define IDI_NO_AUDIO                    195
#define IDI_NEWHTMLWINDOW               195
#define IDI_DELETE                      196
#define IDI_NO_VIDEO                    197
#define IDM_AUDIO_CUSTOM                200
#define IDD_EDIT                        201
#define IDD_TEXT                        202
#define IDEC_EMAIL                      202
#define IDB_VIDEO_LOGO                  202
#define IDEC_SERVER                     203
#define IDC_DRAG_HAND                   203
#define IDRC_YES                        204
#define IDS_UNKNOWN                     205
#define IDRC_NO                         205
#define IDD_HOSTNAME                    206
#define IDEC_FIRSTNAME                  206
#define IDD_LBALIAS                     207
#define IDEC_LASTNAME                   207
#define IDD_LBADDR                      208
#define IDS_NAME_ORDER                  209
#define IDI_AUDIO_OPTIONS               211
#define IDEC_PHONENUM                   211
#define IDI_DIR_OPTIONS                 213
#define IDI_GEN_OPT                     217
#define IDI_GEN_OPT2                    218
#define IDI_GEN_OPT3                    219
#define IDS_LOGGED_ON                   220
#define IDI_MY_INF_OPT                  220
#define IDS_NOT_LOGGED_ON               221
#define IDS_FINDING                     222
#define IDS_DISCONNECTED                223
#define IDI_VID_OPT3                    223
#define IDI_MEDIUM                      224
#define IDI_LARGE                       225
#define IDI_SMALL                       227
#define IDI_LOW_QUAL                    229
#define IDI_HIGH_QUAL                   230
#define IDI_CALL_OPTIONS                231
#define IDS_COMMAND_GIVECONTROL         232
#define IDS_COMMAND_CANCELGIVECONTROL   233
#define IDD_APPSHARINGWIZ_NEEDSP        235
#define IDD_APPSHARINGWIZ_HAVESP        237
#define IDD_VIDWIZ                      238
#define IDD_REMOTE                      245
#define IDD_REMOTE_PASSWORD             246
#define IDD_SERVICE_RUNNING             250
#define IDI_SECURITY                    254
#define IDI_CERT                        256
#define IDS_RELEASE_NOTES_MISSING       260
#define IDS_NEED_RESTART                280
#define IDS_NEED_NEXTCALL               282
#define IDS_WONT_SUSPEND                287
#define IDM_AUDFORMAT                   300
#define IDS_INVITE_PERMISSION           300
#define IDS_MSGBOX_TITLE                301
#define IDS_CLOSEWINDOW_PERMISSION      302
#define IDS_JOIN_ATTEMPT                303
#define IDS_JOIN_PERMISSION             304
#define IDS_INVITE_COULD_NOT_CONNECT    305
#define IDS_COULD_NOT_CONNECT           305
#define IDS_INVITE_DENIED               306
#define IDS_HANGUP_ATTEMPT              307
#define IDS_CALL_MISSING_ADDRESS        308
#define IDS_JOIN_DENIED                 309
#define IDS_CLOSE_DISCONNECT_PERMISSION 311
#define IDS_UNKNOWN_PERSON              312
#define IDS_ERROR_BAD_ADMIN_SETTINGS    313
#define IDS_RESOLVE_FAILED              314
#define IDS_COULD_NOT_INVITE            315
#define IDS_CONNECT_REMOTE_NO_SECURITY  316
#define IDS_CONNECT_REMOTE_DOWNLEVEL_SECURITY 317
#define IDS_INVITE_CONF_ENDED           318
#define IDS_CONNECT_SECURITY_FAILED     319
#define IDS_CONNECT_AUTHENTICATION_FAILED 320
#define IDS_ALREADY_CALLING             321
#define IDS_CONFERENCE_ENDED_BEFORE_JOIN 322
#define IDS_GK_CALLEE_NOT_REGISTERED    323
#define IDS_GK_TIMEOUT                  324
#define IDS_GK_REJECTED                 325
#define IDS_GK_NOT_REGISTERED           326
#define IDS_CONNECT_REMOTE_REQUIRE_SECURITY 327
#define IDS_INVITE_DENIED_REMOTE_CONF   328
#define IDS_ERRMSG_HOST                 330
#define IDS_TRANSPORT_UNAVAILABLE       331
#define IDS_CALL_LOOPBACK               332
#define IDS_AUDIO_IN_USE_REMOTE_AFTER_DATA 333
#define IDS_AUDIO_IN_USE_REMOTE         334
#define IDS_AUDIO_IN_USE_LOCAL_AFTER_DATA 335
#define IDS_AUDIO_IN_USE_LOCAL          336
#define IDS_INCALL_JOIN_FAILED          338
#define IDS_CONFERENCE_DOES_NOT_EXIST   342
#define IDS_REMOTE_MEDIA_ERROR          343
#define IDS_CANT_INVITE_MCU             344
#define IDS_NMCALLTOMAILTEXT            345
#define IDS_CLOSEWINDOW_PERMISSION_FT   346
#define IDS_CLOSE_DISCONNECT_PERMISSION_FT 347
#define IDS_HANGUP_ATTEMPT_FT           348
#define IDS_REMOTE_PLACING_CALL         349
#define IDS_BACKLEVEL_LOADED            363
#define IDS_CANT_START                  364
#define IDS_T120_ALREADY_INITIALIZED    366
#define IDS_AUDIO_CONNECT_FAILED        370
#define IDS_AUDIO_FAILED_AFTER_DATA     371
#define IDS_AUDIO_NOT_AVAILABLE         372
#define IDS_NO_CALL_LOG_INFO            380
#define IDS_BROWSER_ADDRESS_STATIC      390
#define IDS_MEDIAPHONE_TITLE            400
#define IDS_MEDIAPHONE_INCALL           401
#define IDS_MEDIAPHONE_NOTINCALL        402
#define IDS_MEDIAPHONE_INAUDIOCALL      403
#define IDS_MEDIAPHONE_INCALL_ONE       403
#define IDS_ABOUT_TITLE                 410
#define IDS_ABOUT_OTHER                 411
#define IDS_DEFAULT_CONF_NAME           420
#define IDS_LOGOFF_ULS                  430
#define IDS_LOGOFF_ULS_FORMAT           430
#define IDS_LOGON_ULS                   431
#define IDS_LOGON_ULS_FORMAT            431
#define IDS_LOGGED_OFF_CONFIRM          432
#define IDS_ULS_CHANGED_PROMPT          434
#define IDS_CALL_CANCELED_FORMAT        439
#define IDS_FMTBUFFER                   440
#define IDS_CERTERR_NOISSUER            441
#define IDS_CERTERR_SIG                 442
#define IDS_CERTERR_EXPIRED             443
#define IDS_CERTERR_REVOKED             444
#define IDS_CERT_VERIFIED               445
#define IDS_CERTERR_SELFISSUED          446
#define IDS_GATEWAY_DISPLAY_NAME        463
#define IDS_FAVORITES_ITEM_HELP         501
#define IDS_FT_RECDIR_DEFAULT           566
#define IDS_STATUS_FINDING              603
#define IDS_STATUS_SETTING_UP           604
#define IDS_STATUS_WAITING              606
#define IDS_STATUS_IN_CALL              607
#define IDS_STATUS_NOT_IN_CALL          608
#define IDS_STATUS_SENDFILE             609
#define IDS_STATUS_RECEIVEFILE          610
#define IDS_STATUS_IN_SECURE_CALL       611
#define IDS_STATUS_DO_NOT_DISTURB       613
#define IDI_DO_NOT_DISTURB              613
#define IDS_NEW                         658
#define IDS_OPEN                        659
#define IDS_SAVE                        660
#define IDS_CUT                         661
#define IDS_COPY                        662
#define IDS_PASTE                       663
#define IDS_PRINT                       664
#define IDS_ABOUT                       665
#define IDS_CALL_TT                     700
#define IDS_START_SERVER                701
#define IDS_STOP_SERVER                 702
#define IDS_HOST_WARNING                703
#define IDS_DO_NOT_DISTURB_WARNING      704
#define IDS_MACHINENAMEWARNING          713
#define IDS_UNRESOLVED_MESSAGE          720
#define IDS_UNRESOLVED_CAPTION          721
#define IDS_CALLERR_E_BAD_PHONE_NUMBER  800
#define IDS_CALLERR_E_NO_PHONE_SUPPORT  801
#define IDS_CALLERR_E_BAD_IPADDRESS     802
#define IDS_CALLERR_E_BAD_HOSTNAME      803
#define IDS_CALLERR_E_NO_ILS            804
#define IDS_CALLERR_E_ILS_RESOLUTION_FAILED 805
#define IDS_CALLERR_E_NO_ADDRESS        806
#define IDS_CALLERR_E_INVALID_ADDRESS   807
#define IDS_CALLERR_E_NO_GATEKEEPER     808
#define IDS_CALLERR_E_NO_GATEWAY        809
#define IDS_CALLERR_E_PARAM_ERROR       810
#define IDS_CALLERR_E_SECURITY_MISMATCH 811
#define IDS_CALLERR_E_UNESCAPE_ERROR    812
#define IDS_ULSLOGON_BADSERVER          950
#define IDS_ULSLOGON_OLDCLIENT          951
#define IDS_ULSLOGON_ERROR              952
#define IDS_ULSLOGON_DUPLICATE          954
#define IDS_ULSLOGON_OUTOFMEMORY        955
#define IDS_ULSLOGON_UNRECOVERABLE      956
#define IDS_ULSLOGON_BADPROP            957
#define IDS_ULSLOGON_REFUSED            958
#define IDS_ULSLOGON_TIMEOUT            959
#define IDS_ULSLOGON_WORD_FILTER        960
#define IDC_UP_CRED                     971
#define IDS_ULS_DEFAULT                 998
#define IDC_CALL                        1000
#define IDC_EDIT_PASSWORD               1000
#define IDC_ATW_SLIDER1                 1000
#define IDC_SEC_SECURECALL              1000
#define IDC_SCRSAVER_NOW                1000
#define IDA_DLGCALL                     1000
#define IDM_DLGCALL                     1000
#define IDM_DLGCALL_ENTER               1000
#define IDC_DELAY                       1001
#define IDC_NAMECOMBO                   1001
#define IDC_CHECK_SAVE_PASSWORD         1001
#define IDC_CONFNAME_EDIT               1001
#define IDC_UPROP_ICON                  1001
#define IDC_BUTTON_ATW_TEST             1001
#define IDC_CHECK_USE_GATEWAY           1001
#define IDC_SCRSAVER_LATER              1001
#define IDL_DLGCALL_LIST                1001
#define IDC_ATCOMBO                     1002
#define IDC_STATIC_CONFNAME             1002
#define IDC_CHECK_USE_PHONE_NUMBERS     1002
#define IDC_ENABLE_RDS                  1002
#define IDL_DLGCALL_LISTOWNERDATA       1002
#define IDC_NAMESTATIC                  1003
#define IDC_CONFNAME_LISTVIEW           1003
#define IDC_ATW_PROGRESS                1003
#define IDC_CHECK_USE_ACCOUNT           1003
#define IDC_EDIT_RDSPASSWORDV           1003
#define IDC_BUTTON_RDSWIZ               1003
#define IDL_DLGCALL_ILS_LISTVIEW        1003
#define IDC_ATSTATIC                    1004
#define IDC_UPROP_SHARING               1004
#define IDC_ATW_SLIDER2                 1004
#define IDC_STATIC_SERVER_NAME          1004
#define IDL_DLGCALL_WEB_VIEW            1004
#define IDC_UP_VALUE1                   1005
#define IDC_ATPROPERTIES                1005
#define IDC_STATIC_GATEWAY_NAME         1005
#define IDC_MCU                         1006
#define IDC_UPROP_EMAIL                 1006
#define IDC_ANSWERING_AUTOANSWER        1006
#define IDC_UP_VALUE2                   1006
#define IDC_STATIC_PHONE_NUMBER         1006
#define IDC_UPROP_CITY                  1007
#define IDC_AUTOACCEPT                  1007
#define IDC_UP_VALUE3                   1007
#define IDC_VUMETER                     1007
#define IDC_SECURE_CALL_MSG             1007
#define IDC_STATIC_GATEKEEPER_NAME      1007
#define IDC_UPROP_COUNTRY               1008
#define IDC_UP_VALUE4                   1008
#define IDC_SECURE_CALL_EDIT            1008
#define IDC_RADIO1                      1008
#define IDC_STATIC_PROXY_NAME           1008
#define IDC_UPROP_COMMENTS              1009
#define IDC_ANSWERING_NRINGS            1009
#define IDC_UP_VALUE5                   1009
#define IDC_EDIT_MEETING_NAME           1009
#define IDG_GKMODE                      1009
#define IDC_CONFERENCING_CONFNAME       1010
#define IDC_UP_VALUE6                   1010
#define IDC_CHECK_ONLY_ALLOW_INVITEES   1010
#define IDC_UP_VALUE7                   1011
#define IDC_EDIT_MEETING_PASSWORD       1011
#define IDC_STATIC_ADDRESS              1011
#define IDC_DLGCALL_COMBO               1011
#define IDC_UP_VALUE8                   1012
#define IDC_CHECK_MEETING_IS_PASSWORD_PROTECTED 1012
#define IDC_EDIT_NEW_INVITEE            1012
#define IDC_STATIC_CALLUSING            1012
#define IDC_UPROP_NAME                  1013
#define IDC_BUTTON_BROWSE_FOR_INVITEE   1013
#define IDC_EDIT_USERNAME               1013
#define IDE_CALLOPT_GK_PHONE_NUMBER     1013
#define IDC_BUTTON_REMOVE_USER          1014
#define IDC_EDIT_DOMAIN                 1014
#define IDC_VIDEO_MIRROR                1014
#define IDC_BUTTON_MODIFY_USER          1015
#define IDC_EDIT_RDS_CERT               1015
#define IDC_LIST_MEETING_INVITEES       1016
#define IDC_EDIT_RDSPASSWORD            1016
#define IDC_BUTTON_ADD_USER             1017
#define IDC_EDIT_RDSPASSWORDO           1017
#define IDC_REMOTECTL_ALLOW             1018
#define IDC_RADIO_VIEW_MODIFY_ACCESS_PRIVS 1018
#define IDC_IP_ADDRESS                  1018
#define IDC_REMOTECTL_PASSWORD          1019
#define IDC_RADIO_VIEW_MODIFY_MEETING_DOCUMENT_LINKS 1019
#define IDC_IPADDR_STATIC               1019
#define IDC_RADIO_GENERAL_MEETING_SETTINGS 1020
#define IDC_BANDWIDTH                   1020
#define IDC_ADV_CONF_EDIT               1021
#define IDE_DLGCALL_NAME                1021
#define IDC_ALWAYS_RUNNING              1021
#define IDC_RADIO_GENERAL_MEETING_SETTINGS2 1022
#define IDC_CHECK_USE_PROXY             1023
#define IDC_ADV_ADDRESS_COMBO           1025
#define IDC_ADV_USING_COMBO             1026
#define IDC_ANSWERING_AUTO              1027
#define IDE_CALLOPT_PROXY_SERVER        1028
#define IDC_AUDIO_MOST                  1029
#define IDC_AUDIO_MODERATE              1030
#define IDC_AUDIO_SOME                  1031
#define IDC_AUDIO_LEAST                 1032
#define IDC_FULLDUPLEX                  1033
#define IDC_AUTOANSWER                  1034
#define IDC_CSD_SAVE_DESKTOP_RADIO      1035
#define IDC_AUTOACCEPTJOIN              1035
#define IDC_DIALINGLOCATION             1037
#define IDC_CSD_SPEEDDIAL_LIST_RADIO    1037
#define IDC_DIALINGPROPERTIES           1038
#define IDL_DBG_VERINFO                 1042
#define IDC_DBG_VER_OPRAH               1044
#define IDC_DBG_TRACE_CALL              1045
#define IDC_USER_NAME                   1045
#define IDC_USER_EMAIL                  1046
#define IDC_DBG_TRACE_FILE              1047
#define IDC_DBG_VER_WINDOWS             1047
#define IDC_USER_LASTNAME               1047
#define IDC_DBG_ASSERT_BREAK            1048
#define IDC_DBG_VER_AUDIO               1048
#define IDC_USER_LOCATION               1048
#define IDC_USER_INTERESTS              1050
#define IDC_MSG_STATIC                  1051
#define IDC_ABOUT_VERSION_STATIC        1052
#define IDC_ADVANCED_CALL_OPTS          1053
#define IDC_DONT_SHOW_ME_CHECK          1054
#define IDC_USER_PUBLISH                1054
#define IDC_TEXT_STATIC                 1055
#define IDC_NAMESERVER                  1055
#define IDC_ICON_STATIC                 1056
#define IDL_DEBUG                       1056
#define IDC_CSD_CALL_USING_COMBO        1059
#define IDE_HOST_GENERAL                1059
#define IDC_CSD_ADDRESS_EDIT            1060
#define IDC_DESCRIPTION_TEXT            1060
#define IDE_HOST_SETTINGS               1060
#define IDE_HOST_PASSWORD               1061
#define IDE_HOST_YOUACCEPT              1062
#define IDE_HOST_YOUINVITE              1063
#define IDE_HOST_TOOLS                  1064
#define IDC_SHOWHELPMESSAGES            1064
#define IDE_HOST_TOOLS2                 1065
#define IDC_USEULS                      1065
#define IDC_START_AUDIO_WIZ             1066
#define IDC_WEBVIEW2                    1066
#define IDC_AUTOGAIN                    1067
#define IDC_AUTOMIX                     1068
#define IDC_CALIBPROGRESS               1069
#define IDC_FULLDUPLEXCAP               1069
#define IDC_WIZARD_BMP                  1070
#define IDC_WIZBMP                      1070
#define IDC_STATIC_SPEED_DIAL_INSTRUCTIONS 1071
#define IDC_WIZARD_BMP2                 1071
#define IDC_CALIBTIMELEFT               1072
#define IDC_WAVEIN                      1072
#define IDC_AUDIOCHECKREASON            1073
#define IDC_VIDEO_SEND                  1074
#define IDC_DUPLEX                      1074
#define IDC_VIDEO_RECEIVE               1075
#define IDC_VIDEOAVAIL                  1076
#define IDC_RECVOLUME                   1076
#define IDC_TRK_MIC                     1077
#define IDC_MICSENSE_MANUAL             1078
#define IDC_MICSENSE_AUTO               1079
#define IDC_ERRTITLE                    1079
#define IDC_ERRTEXT                     1080
#define IDC_SHOWONTASKBAR               1080
#define IDC_ERRWIZICON                  1081
#define IDC_RESTOREAPPONCALL            1081
#define IDC_RADIO144KBS                 1082
#define IDC_RADIO288KBS                 1083
#define IDC_PROPERTIES                  1083
#define IDS_ERROR_SECURITY_AND_GATEKEEPER_ENABLED 1083
#define IDC_RADIOMOREKBS                1084
#define IDC_RADIOISDN                   1085
#define IDC_WAVEOUT                     1085
#define IDC_START                       1086
#define IDC_RADIOBWCODEC                1088
#define IDC_RADIOMANUALCODEC            1089
#define IDC_ADVANCEDCODEC               1090
#define IDC_COMBOBW                     1091
#define IDC_COMBOCAP                    1092
#define IDC_CHECKDEFAULT                1093
#define IDS_UPROP_LOCATION              1094
#define IDC_CODECLIST                   1095
#define IDS_UPROP_PHONENUM              1095
#define IDC_CODECUP                     1096
#define IDC_CODECDOWN                   1097
#define IDC_CODECDEFAULT                1098
#define IDC_MENUPROPERTIES              1099
#define IDS_MISSED_YOU_FORMAT           1100
#define IDC_MYINFO_GROUP                1103
#define IDC_MYINFO_GROUP2               1104
#define IDC_VIDEO_AUTOSEND              1107
#define IDC_VIDEO_AUTORECEIVE           1108
#define IDC_VIDEO_CLOSELOCAL            1109
#define IDS_SPEED_DIAL_SAVED_ON_DESKTOP 1110
#define IDC_VIDEO_CLOSEREMOTE           1110
#define IDS_SPEED_DIAL_SAVE_ERROR       1111
#define IDC_VIDEO_SOURCE                1111
#define IDC_VIDEO_FORMAT                1112
#define IDC_LOGON_TO_SERVER             1113
#define IDC_UNLISTED                    1114
#define IDC_VIDEO_SQCIF                 1115
#define IDC_VIDEO_QCIF                  1116
#define IDC_VIDEO_CIF                   1117
#define IDC_VIDEO_QUALITY               1119
#define IDC_VIDEO_QUALITY_DESC          1120
#define IDC_VIDEO_QUALITY_LOW           1121
#define IDC_VIDEO_QUALITY_HIGH          1122
#define IDC_VIDEO_OPENLOCAL             1123
#define IDC_VIDEO_SEND_NOTE             1124
#define IDC_NEVER                       1133
#define IDC_ASKME                       1134
#define IDC_AUTOMATIC                   1135
#define IDC_WARNME                      1136
#define IDC_WARNCOUNT                   1137
#define IDC_CODECMANUAL                 1138
#define IDC_FRIENDS_REFRESH_AT_START    1138
#define IDC_CODECLISTLABEL              1139
#define IDC_ABOUT_COPYRIGHT             1141
#define IDC_PSD_AUTOMATIC_CHECK         1142
#define IDC_MSD_ICON                    1143
#define IDC_MSD_WARNME_CHECKBOX         1144
#define IDC_MSD_WARNCOUNT_EDIT          1145
#define IDC_PSD_STATIC                  1146
#define IDC_PSD_ICON                    1150
#define IDC_CSD_CREATE_GROUPBOX         1151
#define IDC_CSD_SD_INFO_GROUP           1152
#define IDC_CATEGORY_GROUP              1158
#define IDC_GENERAL_GROUP               1162
#define IDC_UP_PROP1                    1163
#define IDC_MICSENSE_GROUP              1164
#define IDC_UP_PROP2                    1164
#define IDC_UP_PROP3                    1165
#define IDC_SENDRECEIVE_GROUP           1166
#define IDC_UP_PROP4                    1166
#define IDC_QUALITY_GROUP               1167
#define IDC_UP_PROP5                    1167
#define IDC_CAMERA_GROUP                1168
#define IDC_UP_PROP6                    1168
#define IDC_MSD_EXPLANATION_STATIC      1168
#define IDC_ADDFRIENDS_GROUP            1169
#define IDC_VWCOMBO                     1169
#define IDC_UP_PROP7                    1169
#define IDC_DIRECTORY_GROUP             1170
#define IDL_DBG_LIST                    1170
#define IDC_UP_PROP8                    1170
#define IDC_GROUP_VOLUME                1171
#define IDC_ATW_PLAYTEXT                1172
#define IDC_ATW_PLAYBACK_ERROR          1173
#define IDC_ATW_RECORD_ERROR            1174
#define IDS_WEB_PAGE_FORMAT_WEBVIEW     1174
#define IDS_WEB_PAGE_FORMAT_FREE        1175
#define IDS_WEB_PAGE_FORMAT_NEWS        1176
#define IDS_WEB_PAGE_FORMAT_FAQ         1177
#define IDE_HOST_NAME                   1177
#define IDS_WEB_PAGE_FORMAT_FEEDBACK    1178
#define IDS_WEB_PAGE_FORMAT_BEST        1179
#define ID_OK                           1179
#define IDS_WEB_PAGE_FORMAT_SEARCH      1180
#define ID_CANCEL                       1180
#define IDS_WEB_PAGE_FORMAT_MSHOME      1181
#define IDC_EDITOLDPASSWORD             1181
#define ID_START_CONF                   1181
#define IDS_WEB_PAGE_FORMAT_SUPPORT     1182
#define ID_EXIT                         1182
#define IDS_WEB_PAGE_FORMAT_GETCAMERA   1183
#define IDC_AUTH_EDIT                   1184
#define IDC_VERIFICATION                1185
#define IDC_AUTH_GROUP                  1185
#define IDC_EDITVERIFICATION            1186
#define IDC_DIRECTSOUND                 1186
#define IDC_PASSWORD                    1187
#define IDC_SEC_GENERAL                 1189
#define IDC_SEC_INCOMING                1190
#define IDC_SEC_OUTGOING                1191
#define IDC_SEC_GEN_TEXT                1193
#define IDC_OLDPASSWORD                 1194
#define IDC_SEC_CRED                    1194
#define IDC_NEWPASSWORD                 1195
#define IDC_SEC_CRED_TEXT               1195
#define IDC_EDITNEWPASSWORD             1196
#define IDC_COMBO1                      1196
#define IDC_SEC_CERTLIST                1196
#define IDC_COMBO_CODEC                 1196
#define IDC_SEC_VIEWCREDS               1197
#define IDC_SEC_CHANGECERT              1198
#define IDS_AUDIO_WAVE_DEVICE_IN_USE    1200
#define IDE_HOST_SECURE                 1202
#define IDC_SEC_PRIVACY_ONLY            1203
#define IDC_SEC_PRIVACY_AUTH            1204
#define IDE_HOST_YOUSHARE               1205
#define IDE_HOST_YOUWB                  1206
#define IDE_HOST_YOUCHAT                1207
#define IDE_HOST_YOUFT                  1208
#define IDE_HOST_YOUAUDIO               1209
#define IDE_HOST_YOUVIDEO               1210
#define IDS_INVITE_SOUND                1300
#define IDS_JOIN_SOUND                  1301
#define IDS_PERSON_JOINED_SOUND         1302
#define IDS_PERSON_LEFT_SOUND           1303
#define IDD_ACD                         1400
#define IDS_HISTORY_NO_ADDRESS          1401
#define IDB_ACD_ADDRESS                 1401
#define IDS_HISTORY_ACCEPTED            1402
#define IDL_ACD_ADDRESS                 1402
#define IDS_HISTORY_IGNORED             1403
#define IDL_ACD_ADDR_TYPE               1403
#define IDS_HISTORY_NOT_ANSWERED        1404
#define IDC_ACD_USING_STATIC            1405
#define IDC_ACD_DIRECTORY               1406
#define IDS_INCOMING_CALL_LOG           1430
#define IDS_COLUMN_NAME                 1500
#define IDS_COLUMN_CONNECTION           1501
#define IDS_COLUMN_AUDIO                1501
#define IDS_CONNECTION                  1502
#define IDS_COLUMN_VIDEO                1502
#define IDS_SPEED                       1503
#define IDS_COLUMN_DATA                 1503
#define IDS_PERMISSIONS                 1504
#define IDB_AUTH                        1533
#define IDB_DETAILS                     1533
#define IDS_TT_TB_NEW_CALL              1600
#define IDS_TT_TB_SHARING               1601
#define IDS_TT_TB_CHAT                  1602
#define IDS_TT_TB_NEWWHITEBOARD         1603
#define IDS_TT_TB_FILETRANSFER          1604
#define IDS_TT_FILE_HANGUP              1605
#define IDS_TT_TB_DIRECTORY             1606
#define IDS_TT_TB_SHOWAVTB              1607
#define IDS_TT_TB_PLAYPAUSE             1608
#define IDS_TT_TB_PICINPIC              1609
#define IDS_TT_TB_AUDIOTUNING           1610
#define IDS_TT_DIALPAD                  1611
#define IDS_TT_ADDRESS_BAR              1612
#define IDS_TT_MUTE_MIC                 1613
#define IDS_TT_ADJUST_MIC               1614
#define IDS_TT_MUTE_SPK                 1615
#define IDS_TT_ADJUST_SPK               1616
#define IDS_TT_TB_SHOWROSTER            1617
#define IDS_TT_TB_HIDEAVTB              1618
#define IDS_TT_TB_PAUSE                 1619
#define IDS_TT_NEWWINDOW                1624
#define IDS_TT_REFRESH                  1625
#define IDS_TT_HELP                     1626
#define IDS_TT_DELETE_ILS               1627
#define IDS_MUTE                        1700
#define IDS_AUTO_DET_SILENCE            1701
#define IDS_SPEAKER                     1702
#define IDS_MICROPHONE                  1703
#define IDC_SECURE_CALL                 2000
#define IDG_CALLOPT                     2101
#define IDG_DIRECTMODE                  2101
#define IDE_CALLOPT_GW_SERVER           2104
#define IDC_CALLOPT_GK_USE              2105
#define IDE_CALLOPT_GK_SERVER           2106
#define IDE_CALLOPT_GK_ACCOUNT          2110
#define IDS_STATIC_ACCOUNT              2111
#define IDS_LOCAL_VIDEO_TITLE           3000
#define IDS_VIDEO_CLOSE_WARNING         3002
#define IDS_VIDEO_OPEN_WARNING          3003
#define IDS_VIDEO_NO_CAMERA             3004
#define IDS_VIDEO_NOT_IN_CALL           3005
#define IDS_VIDEO_NOT_SENDING           3006
#define IDS_VIDEO_NOT_RECEIVING         3007
#define IDS_VIDEO_UNDOCKED              3008
#define IDS_VIDEO_PAUSED                3009
#define IDS_VIDEO_DISABLED              3010
#define IDS_VIDEO_STATE_IDLE            3011
#define IDS_VIDEO_STATE_PREVIEWING      3012
#define IDS_VIDEO_STATE_SENDING         3013
#define IDS_VIDEO_STATE_RECEIVING       3014
#define IDS_VIDEO_STATE_PAUSED          3015
#define IDS_VIDEO_STATE_NOTSENDING      3016
#define IDS_VIDEO_STATE_NOTRECEIVING    3017
#define IDS_VIDEO_STATE_REMOTEPAUSED    3018
#define LVS_OWNERDATA                   0x1000
#define IDM_DLGCALL_PROPERTIES          4101
#define IDM_DLGCALL_CALL                4102
#define IDM_DLGCALL_DELETE              4103
#define IDM_DLGCALL_SPEEDDIAL           4104
#define IDM_DLGCALL_WAB                 4105
#define IDM_DLGCALL_ALWAYS_ENABLED      4150
#define IDM_DLGCALL_STOP                4150
#define IDM_DLGCALL_REFRESH             4151
#define IDM_DLGCALL_NEWWINDOW           4152
#define IDM_DLGCALL_DELETE_ILS          4153
#define IDC_SPLASHPIC                   5061
#define IDC_STATIC_MYINFO               6000
#define IDC_RDS_RUNRDS                  6001
#define IDC_SEC_RDS                     6002
#define IDC_RDS_PASSWORD                6003
#define ID_STATUS_LOGON_FORMAT          8500
#define ID_STATUS_LOGOFF_FORMAT         8501
#define ID_STATUS_LOGGEDON_FORMAT       8502
#define ID_STATUS_LOGGEDOFF             8503
#define ID_STATUS_ULSDISCONNECT_FORMAT  8504
#define ID_STATUS_LOGGED_ONTO_GATEKEEPER 8505
#define IDS_NEEDPHONENUM                8506
#define ID_STATUS_LOGING_ONTO_GATEKEEPER 8509
#define ID_STATUS_NOT_LOGGED_ON_TO_GATEKEEPER 8510
#define IDS_ERR_GK_LOGON_TIMEOUT        8511
#define IDS_ERR_GK_LOGON_REJECTED       8512
#define IDS_ERR_GK_NOT_FOUND            8513
#define IDS_ERR_CANT_CALL_NOT_LOGGED_ONTO_GATEKEEPER 8514
#define IDS_PHONENUM                    9000
#define IDS_FORMAT_VERSION              9001
#define IDS_NAME                        9002
#define IDS_ADDRESS                     9003
#define IDS_DLGCALL_HISTORY             9005
#define IDS_DLGCALL_WAB                 9006
#define IDS_DLGCALL_GAL                 9007
#define IDS_DLGCALL_BL                  9008
#define IDS_DLGCALL_SPEEDDIAL           9009
#define IDS_DLGCALL_TITLE               9010
#define IDS_DLGCALL_HDR                 9011
#define IDS_DLGCALL_CALL                9012
#define IDS_DLGCALL_CLOSE               9013
#define IDS_DLGCALL_EDIT_TOOLTIP        9014
#define IDS_DLGCALL_EDIT_HDR            9015
#define IDS_DLGCALL_COMBO_TOOLTIP       9016
#define IDS_SECURITY_CHECKBOX           9017
#define IDS_ACD_CT_AUTOMATIC            9018
#define IDS_ACD_CT_IP                   9019
#define IDS_ACD_CT_ILS                  9020
#define IDS_ACD_CT_PHONE                9021
#define IDS_ACD_CT_ALIAS                9022
#define IDS_ACD_CTF_IP                  9023
#define IDS_ACD_CTF_ILS                 9024
#define IDS_ACD_CTF_PHONE               9025
#define IDS_ACD_CTF_ALIAS               9026
#define IDS_ERR_CALLTO                  9027
#define IDS_NO_DIRECTORY_SERVICES_OR_ADDRESS_BOOKS 9028
#define IDS_DIR_COLUMN_FIRST            9040
#define IDS_DIR_COLUMN_AUDIO            9040
#define IDS_DIR_COLUMN_VIDEO            9041
#define IDS_DIR_COLUMN_LAST_NAME        9042
#define IDS_DIR_COLUMN_FIRST_NAME       9043
#define IDS_DIR_COLUMN_EMAIL            9044
#define IDS_DIR_COLUMN_LOCATION         9045
#define IDS_DIR_COLUMN_COMMENTS         9046
#define IDS_RECEIVED                    9047
#define IDS_DLGCALL_CONFIRM_DELETE_ILS  9050
#define IDS_DLGCALL_CANT_DELETE_DEFAULT_ILS 9051

#define	IDS_323_TYPE			12345
#define	IDS_SPEED_DIAL_TYPE 	12346
#define IDS_INTEL_PHONE_TYPE  12347
#define IDS_INFO_TIP          12348

#define IDS_CPLNAME                     20001
#define IDS_CPLDESCRIPTION              20002
#define IDS_BADPATH                     20004
#define IDS_BROWSETITLE                 20005
#define IDS_NOUSERDETAILS               20006
#define IDS_NOSAVEUSERDETAILS           20007
#define IDS_MICROPHONEVOL               20009
#define IDS_OFMAXVOL                    20010
#define IDS_UNSUPPORTEDCARD             20011
#define IDS_NORECVOLCNTRL               20012
#define IDS_NEEDUSERNAME                20013
#define IDS_CANTOPENWAVE                20014
#define IDS_QUITPROGRAM                 20015
#define IDS_CANCELANDRETRY              20017
#define IDS_ALLPAGESDISABLED            20018
#define IDS_KBS                         20019
#define IDS_BW144KBS                    20020
#define IDS_BW288KBS                    20021
#define IDS_BWMOREKBS                   20022
#define IDS_CODECNAME                   20023
#define IDS_MAXBITRATE                  20024
#define IDS_CPUUTIL                     20025
#define IDS_FATAL_AUDIO_ERROR           20026
#define IDS_AUDIO_ERROR                 20027
#define IDS_ILLEGAL_GATEKEEPERSERVER_NAME 20031
#define IDS_ILLEGALEMAILNAME            20032
#define IDS_NO_MICROPHONE               20033
#define IDS_NO_MICWARNING               20034
#define IDS_NOAUDIOTUNING               20035
#define IDS_BWISDN                      20036
#define IDS_ILLEGAL_GATEWAY_NAME        20037
#define IDS_BAD_ADMINISTRATOR_SETTINGS_GK_LOGON_INFORMATION 20038
#define IDS_ILLEGAL_PHONE_NUMBER        20039
#define IDS_NO_ILS_SERVER               20040
#define IDS_ILLEGAL_PROXY_NAME          20041
#define IDS_ILLEGAL_WEBDIR_DISPLAYNAME  20042
#define IDS_ILLEGAL_WEBDIR_ILS          20043
#define IDS_ILLEGAL_WEBDIR_URL          20044
#define IDS_ENABLEAPPSHARING_NEEDNTSP   20070
#define IDS_ENABLEAPPSHARING_INSTALL_CONFIRM 20071
#define IDS_ENABLEAPPSHARING_INSTALL_FAILURE 20072
#define IDS_ENABLEAPPSHARING_INSTALL_COMPLETE 20073
#define IDS_NMDD_DISPLAYNAME            20074
#define IDS_NMDD_INFNAME                20075
#define IDS_RWSWARNING                  20076
#define IDS_RDSWARNING                  20077
#define IDD_ANSWERING                   20102
#define IDD_FILEXFER                    20105
#define IDD_AUDIO                       20107
#define IDD_USERINFO                    20108
#define IDR_TOOLBAR                     20109
#define IDD_AUDIOCALIBWIZ0              20110
#define IDD_AUDIOCALIBWIZ1              20111
#define IDD_AUDIOCALIBWIZ2              20112
#define IDD_AUDIOCALIBWIZ3              20113
#define IDD_AUDIOCALIBWIZ4              20114
#define IDD_DETSOUNDCARDWIZ             20115
#define IDI_SOUNDERROR                  20116
#define IDD_AUDIOCALIBERRWIZ            20117
#define IDI_AUDIOCALIBERROR             20118
#define IDD_BANDWIDTHWIZ                20119
#define IDD_ADVANCEDCODEC               20122
#define IDD_VIDEO                       20123
#define IDD_PAGE_USER                   20124
#define IDD_CALLOPT                     20126
#define IDD_DBG_LIST                    20128
#define IDD_HOST                        20129
#define IDD_HOSTWIZ_INTRO               20130
#define IDD_RDSWIZ_ENABLE               20130
#define IDD_HOSTWIZ_INTRO_GENERAL       20131
#define IDD_RDSWIZ_SCRNSVR              20131
#define IDD_HOSTWIZ_GENERAL             20132
#define IDD_RDS_SETTINGS                20132
#define IDD_HOSTWIZ_INTRO_INVITEES      20133
#define IDD_HOSTWIZ_INVITEES            20134
#define IDD_HOSTWIZ_INTRO_ADVANCED      20135
#define IDD_HOSTWIZ_ADVANCED            20136
#define IDD_HOSTWIZ_INTRO_ACCESS_PRIVS  20137
#define IDD_HOSTWIZ_INTRO_DOCLINK       20138
#define IDD_HOSTWIZ_INTRO_ADVANCED_GENERAL 20139
#define IDD_HOSTWIZ_INTRO_AUTOSHARE     20140
#define ID_CTRL_TAB                     27001
#define ID_CTRL_SHIFT_TAB               27002
#define ID_TOGGLE_FOCUS                 27003
#define IDS_CALL_HELP                   39000
#define IDS_VIEW_HELP                   39001
#define IDS_TOOLS_HELP                  39002
#define IDS_HELP_HELP                   39003
#define IDS_SYSTEM_HELP                 39010
#define IDS_VIDEO_HELP                  39100
#define IDS_MS_ON_WEB_HELP              39202
#define IDS_TBSUBMENU_HELP              39400
#define IDM_FLDR_DROPDOWN               40003
#define ID_TOOLS_RDSWIZARD              40003
#define IDM_VIEW_DATAONLY               40005
#define IDM_VIEW_ONTOP                  40006
#define IDM_VIDEO_GETACAMERA            40009
#define ID_VIEW_STATUSBAR               40010
#define ID_NAV_SHIFT_TAB                40011
#define ID_NAV_TAB                      40012
#define ID_AUTOACCEPT                   40012
#define ID_TOOLS_OPTIONS                40016
#define ID_HELP_HELPTOPICS              40022
#define ID_HELP_ABOUTOPRAH              40023
#define IDM_VIEW_TOOLBAR                40027
#define IDM_VIEW_STATUSBAR              40028
#define IDM_CALL_MEETINGSETTINGS        40031
#define IDM_POPUP_ADDRESSBOOK           40032
#define IDM_POPUP_CANCELGIVECONTROL     40033
#define IDM_POPUP_SPEEDDIAL             40034
#define IDM_POPUP_PROPERTIES            40035
#define IDM_POPUP_GIVECONTROL           40036
#define IDM_VIEW_COMPACT                40037
#define IDM_VIEW_DIALPAD                40039
#define ID_TB_SHARING                   40040
#define ID_TB_CHAT                      40041
#define ID_TB_FILETRANSFER              40042
#define ID_TB_NEWWHITEBOARD             40043
#define ID_TB_WHITEBOARD                40044
#define ID_TOOLS_AUDIOMUTE              40048
#define IDM_EDIT_FIND                   40050
#define IDM_FILE_EXIT                   40052
#define ID_TOOLS_MUTESPEAKER            40056
#define IDM_TBPOPUP_OPEN                40057
#define IDM_TBPOPUP_STOP                40058
#define IDM_VIEW_CALLDLG                40063
#define IDM_FILE_HANGUP                 40064
#define ID_TOOLS_STOPSHARINGPROGRAM     40071
#define ID_TB_NEW_CALL                  40075
#define ID_TB_REDIAL                    40076
#define ID_TB_PICINPIC                  40077
#define ID_TB_DIRECTORY                 40078
#define ID_TB_INCOMING                  40079
#define ID_TB_REJECT                    40080
#define ID_TB_CREDENTIALS               40081
#define ID_TB_AUDIOTUNING               40082
#define ID_TB_SHOWAVTB                  40083
#define ID_TB_DIAL0                     40085
#define ID_TB_DIAL1                     40086
#define ID_TB_DIAL2                     40087
#define ID_TB_DIAL3                     40088
#define ID_TB_DIAL4                     40089
#define ID_TB_DIAL5                     40090
#define ID_TB_DIAL6                     40091
#define ID_TB_DIAL7                     40092
#define ID_TB_DIAL8                     40093
#define ID_TB_DIAL9                     40094
#define ID_TB_DIALSTAR                  40095
#define ID_TB_DIALPOUND                 40096
#define ID_TB_TUNEMIC_LEFT              40102
#define ID_TB_TUNEMIC_CENTER            40103
#define ID_TB_TUNEMIC_RIGHT             40104
#define ID_TB_TUNEMIC_UNMUTE            40105
#define ID_TB_TUNESPEAKER_LEFT          40106
#define ID_TB_TUNESPEAKER_CENTER        40107
#define ID_TB_TUNESPEAKER_RIGHT         40108
#define ID_TB_TUNESPEAKER_UNMUTE        40109
#define ID_TOOLS_SENDFILE               40110
#define ID_TB_PLAYPAUSE                 40111
#define ID_FILE_CONF_HOST               40112
#define ID_TB_HELP                      40113
#define IDM_FILE_DIRECTORY              40119
#define ID_TOOLS_CANCEL_SEND            40125
#define ID_TOOLS_CANCEL_RECEIVE         40126
#define ID_TOOLS_AUDIO_WIZARD           40127
#define ID_PRIVATE_TAB                  40128
#define ID_PRIVATE_SHIFTTAB             40129
#define ID_FILE_CREATE_SPEED_DIAL       40136
#define ID_FILE_DO_NOT_DISTURB          40137
#define IDM_FILE_LAUNCH_WEB_PAGE        40140
#define IDM_FILE_LOGON_ULS              40142
#define ID_PRIVATE_ENTER                40143
#define IDM_POPUP_EJECT                 40172
#define ID_HELP_RELEASE_NOTES           40173
#define IDM_DIRPOPUP_PROPERTIES         40174
#define ID_HELP_WEB_FREE                40175
#define ID_HELP_WEB_NEWS                40176
#define ID_HELP_WEB_FAQ                 40177
#define ID_HELP_WEB_FEEDBACK            40178
#define ID_HELP_WEB_MSHOME              40181
#define ID_HELP_WEB_SUPPORT             40182
#define ID_PRIVATE_UPDATE_UI            40185
#define ID_TOOLS_SENDVIDEO              40211
#define ID_TOOLS_RECEIVEVIDEO           40212
#define ID_TOOLS_UNDOCKLOCAL            40213
#define ID_TOOLS_UNDOCKREMOTE           40214
#define IDM_VIEW_UNDOCKLOCAL            40215
#define IDM_VIEW_UNDOCKREMOTE           40216
#define ID_STOP                         40229
#define ID_TOOLS_ENABLEAPPSHARING       40231
#define ID_FILE_EXIT_ACTIVATERDS        40232
#define IDM_VIDEO_COPY                  40600
#define IDM_VIDEO_FREEZE                40601
#define IDM_VIDEO_ZOOM1                 40603
#define IDM_VIDEO_ZOOM2                 40604
#define IDM_VIDEO_ZOOM3                 40605
#define IDM_VIDEO_ZOOM4                 40606
#define IDM_VIDEO_ALWAYSONTOP           40608
#define IDM_VIDEO_SOURCE                40611
#define IDM_VIDEO_FORMAT                40612
#define IDM_VIDEO_FRAMESIZE1            40617
#define IDM_VIDEO_FRAMESIZE2            40618
#define IDM_VIDEO_FRAMESIZE3            40619
#define IDM_VIDEO_PROPERTIES            40624
#define IDM_VIDEO_HIDE                  40627
#define IDM_VIDEO_DOCK                  40628
#define IDM_VIDEO_PLAY                  40629
#define IDM_VIDEO_PAUSE                 40630
#define IDM_VIDEO_UNDOCK                40631
#define ID_FILE_SAVEAS                  40635
#define IDS_TOOLS_RDSWIZARD_HELP        42003
#define IDS_VIEW_DATAONLY               42005
#define IDS_VIEW_ONTOP                  42006
#define IDS_HELP_GETACAMERA             42008
#define IDS_VIEW_LARGEICONS_HELP        42011
#define IDS_VIEW_DETAILS_HELP           42014
#define IDS_TOOLS_OPTIONS_HELP          42016
#define IDS_HELP_HELPTOPICS_HELP        42022
#define IDS_HELP_ABOUTOPRAH_HELP        42023
#define IDS_VIEW_STATUSBAR_HELP         42028
#define IDS_CALL_MEETINGSETTINGS        42031
#define IDS_POPUP_ADDRESSBOOK           42032
#define IDS_POPUP_CANCELGIVECONTROL     42033
#define IDS_POPUP_SPEEDDIAL             42034
#define IDS_POPUP_PROPERTIES            42035
#define IDS_POPUP_GIVECONTROL           42036
#define IDS_VIEW_COMPACT_HELP           42037
#define IDS_VIEW_DIALPAD_HELP           42039
#define IDS_TB_SHARING                  42040
#define IDS_TB_CHAT                     42041
#define IDS_TB_FILETRANSFER             42042
#define IDS_TB_NEWWHITEBOARD            42043
#define IDS_TB_WHITEBOARD               42044
#define IDS_FILE_EXIT_HELP              42052
#define IDS_VIEW_CALLDLG_HELP           42063
#define IDS_FILE_HANGUP_HELP            42064
#define IDS_FILE_PLACE_CALL_HELP        42067
#define IDS_FILE_NEW_DIALING_SHORTCUT_HELP 42069
#define IDS_FILE_ADVANCED_PLACE_CALL_HELP 42075
#define IDS_TB_PICINPIC                 42077
#define IDS_FILE_CONF_HOST              42112
#define IDS_FILE_CONF_PARTICIPANT       42113
#define IDS_VIEW_AUDIO                  42117
#define IDS_FILE_DIRECTORY              42119
#define IDS_TOOLS_CANCEL_SEND_HELP      42125
#define IDS_TOOLS_CANCEL_RECEIVE_HELP   42126
#define IDS_TOOLS_AUDIO_WIZARD_HELP     42127
#define IDS_FILE_CANCEL_CALL_HELP       42130
#define IDS_FILE_CREATE_SPEED_DIAL      42136
#define IDS_FILE_DO_NOT_DISTURB         42137
#define IDS_FILE_LAUNCH_WEB_PAGE        42140
#define IDS_FILE_ULS                    42142
#define IDS_POPUP_EJECT                 42172
#define IDS_HELP_RELEASE_NOTES          42173
#define IDS_DIRPOPUP_PROPERTIES         42174
#define IDS_HELP_WEB_FREE               42175
#define IDS_HELP_WEB_NEWS               42176
#define IDS_HELP_WEB_FAQ                42177
#define IDS_HELP_WEB_FEEDBACK           42178
#define IDS_HELP_WEB_BEST               42179
#define IDS_HELP_WEB_SEARCH             42180
#define IDS_HELP_WEB_MSHOME             42181
#define IDS_HELP_WEB_SUPPORT            42182
#define IDS_TOOLS_SENDVIDEO_HELP        42211
#define IDS_TOOLS_RECEIVEVIDEO_HELP     42212
#define IDS_TOOLS_UNDOCKLOCAL_HELP      42213
#define IDS_TOOLS_UNDOCKREMOTE_HELP     42214
#define IDS_VIEW_UNDOCKLOCAL_HELP       42215
#define IDS_VIEW_UNDOCKREMOTE_HELP      42216
#define IDS_STOP_HELP                   42229
#define IDS_TOOLS_ENABLEAPPSHARING_HELP 42231
#define IDS_FILE_EXIT_ACTIVATERDS_HELP  42232
#define IDS_CERT_FAILED                 42241
#define IDS_SECURITY_DETAILS            42243
#define IDS_SECURITY_NODETAILS          42244
#define IDS_GENERIC_NMDC_TEXT           42246
#define IDS_VIDEO_ZOOM1                 42603
#define IDS_VIDEO_ZOOM2                 42604
#define IDS_VIDEO_ZOOM3                 42605
#define IDS_VIDEO_ZOOM4                 42606
#define IDS_VIDEO_UNDOCK                42631
#define IDS_COUNTRY_DEFAULT             42990
#define IDS_SIZE_HELP                   61440
#define IDS_MOVE_HELP                   61456
#define IDS_MINIMIZE_HELP               61472
#define IDS_MAXIMIZE_HELP               61488
#define IDS_CLOSE_HELP                  61536
#define IDS_RESTORE_HELP                61728
#define IDS_ATW_PLAYBACK                61729
#define IDS_ATW_PLAYBACK_NOMIX          61730
#define IDS_PLAYBACK_ERROR              61731
#define IDS_PLAYBACK_ERROR2             61732
#define IDS_RECORD_ERROR                61733
#define IDS_TESTBUTTON_TEXT             61734
#define IDS_STOPBUTTON_TEXT             61735
#define IDS_REMOTE_NEW_PASSWORD_INVALID_TEXT 61743
#define IDS_REMOTE_OLD_PASSWORD_WRONG_TEXT 61744
#define IDS_REMOTE_OLD_PASSWORD_WRONG_TITLE 61745
#define IDS_REMOTE_NEW_PASSWORD_WRONG_TEXT 61746
#define IDS_REMOTE_NEW_PASSWORD_WRONG_TITLE 61747
#define IDS_REMOTE_PASSWORD_CHANGED_TEXT 61748
#define IDS_REMOTE_PASSWORD_CHANGED_TITLE 61749
#define IDS_AUTOCONF_SERVERNAME_MISSING 61750
#define IDS_AUTOCONF_FAILED             61751
#define IDS_AUTOCONF_NO_WININET         61752
#define IDS_AUTOCONF_NEED_SETUPAPIS     61753
#define IDS_AUTOCONF_PARSE_ERROR        61754
#define IDS_REMOTE_NEW_PASSWORD_EMPTY   61757
#define IDS_MS_INTERNET_DIRECTORY       61758
#define IDS_ILLEGAL_GK_MODE             61761
#define IDS_ILLEGAL_ACCOUNT             61762
#define IDS_REMOTE_NEW_PASSWORD_LENGTH_TITLE 61763
#define IDS_REMOTE_NEW_PASSWORD_LENGTH_TEXT 61764



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        196
#define _APS_NEXT_COMMAND_VALUE         40013
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\roomlist.h ===
// File: roomlist.h

#ifndef _ROOMLIST_H_
#define _ROOMLIST_H_

#include "GenWindow.h"

class CParticipant;

void TileBltWatermark(UINT x, UINT y, UINT cx, UINT cy, UINT xOff, UINT yOff, HDC hdcDst, HDC hdcSrc,
	UINT cxWatermark, UINT cyWatermark);

class CRoomListView : public CWindowImpl<CRoomListView>, public IGenWindow
{
private:
	enum
	{
		COLUMN_INDEX_NAME = 0,
		NUM_COLUMNS
	};

	// Member Variables:
	enum { m_iSortColumn = COLUMN_INDEX_NAME };

	BOOL m_fSortAscending;
	LPARAM m_lUserData;

	LRESULT     OnClick(LV_HITTESTINFO* plvhi, BOOL fLeftClick);

	// static methods
	static int CALLBACK RoomListViewCompareProc(LPARAM lParam1,
												LPARAM lParam2,
												LPARAM lParamSort);
	LPARAM	GetSelectedLParam();
	VOID    GetDispInfo(LV_DISPINFO * pLvdi);
	int		LParamToPos(LPARAM lParam);

	BOOL    Add(int iPosition, CParticipant * pPart);
	VOID    Remove(LPARAM lParam);

public:
	// Methods:
			CRoomListView();
			~CRoomListView();

	// begin IGenWindow interface
	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID iid, LPVOID *pObj)
	{ return(E_NOTIMPL); }
	virtual ULONG STDMETHODCALLTYPE AddRef(void) { return(3); }
	virtual ULONG STDMETHODCALLTYPE Release(void) { return(2); }

	virtual void GetDesiredSize(SIZE *ppt);
	virtual HBRUSH GetBackgroundBrush() { return(NULL); }
	virtual HPALETTE GetPalette() { return(NULL); }
	virtual void OnDesiredSizeChanged() {}

	// Get the LPARAM of user data
	virtual LPARAM GetUserData() { return(m_lUserData); }

	// end IGenWindow interface

	void SetUserData(LPARAM lUserData) { m_lUserData = lUserData; }

	// CView
	BOOL    Create(HWND hwndParent);
	VOID    Show(BOOL fVisible);
	VOID    ShiftFocus(HWND hwndCur, BOOL fForward);
	VOID    Redraw(void);
	VOID    SaveSettings(RegEntry * pre) {}
	BOOL	LoadSettings(RegEntry * pre);

	HWND	GetHwnd()       const {return m_hWnd;}
	BOOL	IsChildWindow(HWND hwnd)
			{
				return ((hwnd == m_hWnd) || ::IsChild(m_hWnd, hwnd));
			}

	VOID    ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
	BOOL    OnPopup(POINT pt);

	VOID    OnChangeParticipant(CParticipant * pPart, NM_MEMBER_NOTIFY uNotify);

	CParticipant * GetParticipant();

	// Handlers:
	LRESULT	OnNotify(WPARAM wParam, LPARAM lParam);

//////////////////////////////////
// ATLWin stuff 

	// This is a superclass of a SysListTreeView32
DECLARE_WND_SUPERCLASS(NULL,_T("SysListView32"))

	// Message map
BEGIN_MSG_MAP(CComponentWnd)
	MESSAGE_HANDLER(c_msgFromHandle,OnFromHandle)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
END_MSG_MAP()

private:
		// Message Map Handlers
	LRESULT OnFromHandle(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return(reinterpret_cast<LRESULT>(static_cast<IGenWindow*>(this)));
	}

	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		CGenWindow::SetHotControl(NULL);
		bHandled = FALSE;
		return(0);
	}

	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

#endif // _ROOMLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\rtoolbar.cpp ===
// File: rtoolbar.cpp

#include "precomp.h"

#include "RToolbar.h"
#include "GenContainers.h"
#include "GenControls.h"
#include "Conf.h"
#include "ConfRoom.h"
#include "RoomList.h"
#include "particip.h"
#include "VidView.h"
#include "ProgressBar.h"
#include "AudioCtl.h"
#include "CallingBar.h"
#include "resource.h"
#include "topWindow.h"
#include "dlgCall2.h"
#include "ulswizrd.h"
#include "audiowiz.h"
#include "sdialdlg.h"

#include	"callto.h"

#define ZeroArray(_a) ZeroMemory(_a, sizeof(_a))

static void ShiftFocus(HWND hwndTop, BOOL bForward);

class CRemoteVideo : public CVideoWindow
{
public:
	CRemoteVideo(BOOL bEmbedded = FALSE) :
		CVideoWindow(REMOTE, bEmbedded)
	{
	}

	// Stick the child in the lower-right corner of the window
	virtual void Layout()
	{
		CVideoWindow::Layout();

		HWND hwnd = GetWindow();

		HWND hwndLocal = GetFirstChild(hwnd);

		if (NULL != hwndLocal)
		{
			RECT rcRemote;
			GetClientRect(hwnd, &rcRemote);

			int left = rcRemote.right  *5/8;
			int top  = rcRemote.bottom *5/8;

			SetWindowPos(hwndLocal, NULL, left, top,
				rcRemote.right-left, rcRemote.bottom-top, SWP_NOZORDER);
		}
	}
} ;

// This just exists to send WM_NOTIFY messages back to the Roster
class CRosterParent : public CFillWindow
{
private:
	CRoomListView *m_pRoster;

	void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos)
	{
		POINT pt = { xPos, yPos };

		CRoomListView *pView = GetRoster();
		if ((NULL != pView) && (pView->GetHwnd() == hwndContext))
		{
			pView->OnPopup(pt);
		}

		FORWARD_WM_CONTEXTMENU(hwnd, hwndContext, xPos, yPos, CFillWindow::ProcessMessage);
	}

	inline LRESULT RosterNotify(CRoomListView *pRoster, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		return(pRoster->OnNotify(wParam, lParam));
	}

	// Just forward to the Roster
	LRESULT OnNotify(HWND hwnd, int id, NMHDR *pHdr)
	{
		// pass on all notifications:
		if (ID_LISTVIEW == pHdr->idFrom)
		{
			CRoomListView *pView = GetRoster();
			if (NULL != pView)
			{
				// Forward to the roster
				return(FORWARD_WM_NOTIFY(pView, id, pHdr, RosterNotify));
			}
		}

		return(FORWARD_WM_NOTIFY(hwnd, id, pHdr, CFillWindow::ProcessMessage));
	}


protected:
	~CRosterParent()
	{
		// delete can handle NULL
		delete m_pRoster;
	}

	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch (uMsg)
		{
			HANDLE_MSG(hwnd, WM_NOTIFY, OnNotify);
			HANDLE_MSG(hwnd, WM_CONTEXTMENU, OnContextMenu);

		case WM_DESTROY:
			delete m_pRoster;
			m_pRoster = NULL;
			break;
		}

		return(CFillWindow::ProcessMessage(hwnd, uMsg, wParam, lParam));
	}

public:
	CRosterParent() : m_pRoster(NULL) {}

	BOOL Create(HWND hwndParent)
	{
		m_pRoster = new CRoomListView();
		if (NULL == m_pRoster)
		{
			return(FALSE);
		}

		if (!CFillWindow::Create(hwndParent, 0))
		{
			return(FALSE);
		}

		return(m_pRoster->Create(GetWindow()));
	}

	CRoomListView *GetRoster() const
	{
		return(m_pRoster);
	}
} ;

CToolbar *CreateToolbar(
	CGenWindow *pParent,
	const Buttons buttons[]=NULL,
	int nButtons=0,
	LPARAM lHideModes=0,
	DWORD dwExStyle=0
	);

#define ReleaseIt(pUnk) if (NULL != (pUnk)) { (pUnk)->Release(); (pUnk) = NULL; }

enum CheckStates
{
	Unchecked = 0,
	Checked = 1,
} ;

const static int MainHMargin = 8;
const static int MainVMargin = 5;
const static int MainGap = 4;

const static int SunkenHMargin = 8;
const static int SunkenVMargin = 2;

const static int ButtonsGap = 12;

const static int AudioMax = 100;
const static int AudioVolMax = 0xffff;
const static int AudioBump = 10;

enum MainTimers
{
	IDT_AUDIO = 1,
} ;

// Set these bits in the hide mode to hide in certain situations
enum HideModes
{
	Inherit			= 0x0000,

	Normal			= 0x0001,
	Compact			= 0x0002,
	DataOnly		= 0x0004,
	NoAVTB			= 0x0008,
	Roster			= 0x0010,
	AudioTuning		= 0x0020,
	Dialing			= 0x0040,
	Receiving		= 0x0080,
	ReceivingWPiP	= 0x0100,
	Previewing		= 0x0200,
	Video			= Receiving|ReceivingWPiP|Previewing,

	Ignore			= 0x4000,
	IfNoChildren	= 0x8000,
} ;

// Sets the hide mode bits on a window
static inline void SetHideModes(CGenWindow *pWin, LPARAM modes)
{
	if (NULL != pWin)
	{
		pWin->SetUserData(modes);
	}
}

// Gets the hide mode bits on a window
static inline LPARAM GetHideModes(IGenWindow *pWin)
{
	return(pWin->GetUserData());
}

CMainUI::CMainUI() :
	m_hbBack(NULL),
	m_eViewMode(ViewNormal),
	m_pLocalVideo(NULL),
	m_pRemoteVideo(NULL),
	m_pAudioMic(NULL),
	m_pAudioSpeaker(NULL),
	m_pRoster(NULL),
	m_pCalling(NULL),
	m_bDialing(FALSE),
	m_bAudioTuning(FALSE),
	m_bPreviewing(TRUE),
	m_bPicInPic(FALSE),
	m_bStateChanged(FALSE),
	m_bShowAVTB(FALSE)
{
}

CMainUI::~CMainUI()
{
	if (NULL != m_hbBack)
	{
		DeleteObject(m_hbBack);
		m_hbBack = NULL;
	}

	ReleaseIt(m_pLocalVideo);
	ReleaseIt(m_pRemoteVideo);
	ReleaseIt(m_pAudioMic);
	ReleaseIt(m_pAudioSpeaker);
	ReleaseIt(m_pRoster);
	ReleaseIt(m_pCalling);
}

void SplitBitmap(UINT nCols, UINT nRows, HBITMAP hbmSrc, HBITMAP hbmDst[])
{
	BITMAP bm;
	GetObject(hbmSrc, sizeof(bm), &bm);
	int nWid = bm.bmWidth  / nCols;
	int nHgt = bm.bmHeight / nRows;

	HDC hdcScreen = GetDC(NULL);
	HDC hdcSrc = CreateCompatibleDC(hdcScreen);
	HDC hdcDst = CreateCompatibleDC(hdcScreen);
	ReleaseDC(NULL, hdcScreen);

	if (NULL != hdcSrc && NULL != hdcDst)
	{
		SelectObject(hdcSrc, hbmSrc);

		for(UINT i=0; i<nRows; ++i)
		{
			for (UINT j=0; j<nCols; ++j)
			{
				HBITMAP hbmTemp = CreateCompatibleBitmap(hdcSrc, nWid, nHgt);
				if (NULL != hbmTemp)
				{
					SelectObject(hdcDst, hbmTemp);
					BitBlt(hdcDst, 0, 0, nWid, nHgt, hdcSrc, j*nWid, i*nHgt, SRCCOPY);
				}
				hbmDst[i*nCols + j] = hbmTemp;
			}
		}
	}

	DeleteDC(hdcSrc);
	DeleteDC(hdcDst);
}

// Helper function for adding a bunch of buttons to a parent window
void AddButtons(
	CGenWindow *pParent,		// The parent window
	const Buttons buttons[],	// Array of structures describing the buttons
	int nButtons,				// Number of buttons to create
	BOOL bTranslateColors,		// Use system background colors
	CGenWindow *pCreated[],		// Created CGenWindow's will be put here
	IButtonChange *pNotify		// Notification of clicks
	)
{
	if (NULL == buttons)
	{
		// Nothing to do
		return;
	}

	HWND hwnd = pParent->GetWindow();

	for (int i=0; i<nButtons; ++i)
	{
		if (NULL != pCreated)
		{
			// Init in case of error
			pCreated[i] = NULL;
		}

		CBitmapButton *pButton;

		pButton = new CBitmapButton();
		if (NULL == pButton)
		{
			continue;
		}

		// Create the actual window
		if (!pButton->Create(hwnd, buttons[i].idCommand, _Module.GetModuleInstance(),
			buttons[i].idbStates, bTranslateColors,
			buttons[i].nInputStates, buttons[i].nCustomStates, pNotify))
		{
			pButton->Release();
			continue;
		}

		// Save off the created button if requested
		if (NULL != pCreated)
		{
			// HACKHACK georgep: Not AddRef'ing; will let caller do that if interested
			pCreated[i] = pButton;
		}

		if (0 != buttons[i].idTooltip)
		{
			pButton->SetTooltip(RES2T(buttons[i].idTooltip));
		}

		// By default, do not hide individual buttons
		SetHideModes(pButton, Ignore);

		// Release our reference to the button
		pButton->Release();
	}
}

CToolbar *CreateToolbar(
	CGenWindow *pParent,
	const Buttons buttons[],
	int nButtons,
	LPARAM lHideModes,
	DWORD dwExStyle
	)
{
	CToolbar *ret;

	ret = new CToolbar();
	if (NULL == ret)
	{
		return(NULL);
	}
	if (!ret->Create(pParent->GetWindow(), dwExStyle))
	{
		ret->Release();
		return(NULL);
	}

	SetHideModes(ret, lHideModes);
	AddButtons(ret, buttons, nButtons, TRUE);

	return(ret);
}

void CMainUI::CreateDialTB(CGenWindow *pParent)
{
	// Create the toolbar
	m_pCalling = new CCallingBar();
	if (NULL != m_pCalling)
	{
		SetHideModes(m_pCalling, Compact);

		m_pCalling->Create(pParent, m_pConfRoom);

		// m_pCalling->Release();
	}
}

void CMainUI::CreateAppsTB(CGenWindow *pParent)
{
	const static int AppsHMargin = 5;
	const static int AppsVMargin = 0;
	const static int AppsHGap = 11;

	static const Buttons appButtons[] =
	{
		{ IDB_SHARE         , CBitmapButton::Disabled+1, 1, ID_TB_SHARING       , IDS_TT_TB_SHARING       , },
		{ IDB_CHAT          , CBitmapButton::Disabled+1, 1, ID_TB_CHAT          , IDS_TT_TB_CHAT          , },
		{ IDB_WHITEBOARD    , CBitmapButton::Disabled+1, 1, ID_TB_NEWWHITEBOARD , IDS_TT_TB_NEWWHITEBOARD , },
		{ IDB_FILE_TRANSFER , CBitmapButton::Disabled+1, 1, ID_TB_FILETRANSFER  , IDS_TT_TB_FILETRANSFER  , },
	} ;

	// Create the "data" buttons toolbar
	CToolbar *pApps = CreateToolbar(pParent, appButtons, ARRAY_ELEMENTS(appButtons), Compact);
	if (NULL != pApps)
	{
		// HACKHACK georgep: These numbers make it appear about right
		pApps->m_hMargin = AppsHMargin;
		pApps->m_vMargin = AppsVMargin;
		pApps->m_gap = AppsHGap;

		// pApps->m_bMinDesiredSize = TRUE;

		pApps->Release();
	}
}

void CMainUI::CreateVideoAndAppsTB(CGenWindow *pParent, CreateViewMode eMode, BOOL bEmbedded)
{
	CLayeredView::LayoutStyle lVidDialStyle = CLayeredView::Center;

	switch (eMode)
	{
	case CreateFull:
	case CreatePreviewOnly:
	case CreateRemoteOnly:
	case CreateTelephone:
		break;

	case CreatePreviewNoPause:
	case CreateRemoteNoPause:
		lVidDialStyle = CLayeredView::Fill;
		break;

	default:
		return;
	}

	// Create the toolbar
	CBorderWindow *pVideoAndCalling = new CBorderWindow();
	if (NULL != pVideoAndCalling)
	{
		if (pVideoAndCalling->Create(pParent->GetWindow()))
		{
			SetHideModes(pVideoAndCalling, DataOnly);

			pVideoAndCalling->m_hGap = 4;
			pVideoAndCalling->m_vGap = 4;

			// This is the center part of the border window
			CLayeredView *pVidAndDial = new CLayeredView();
			if (NULL != pVidAndDial)
			{
				if (pVidAndDial->Create(pVideoAndCalling->GetWindow()))
				{
					pVideoAndCalling->m_uParts |= CBorderWindow::Center;

					pVidAndDial->m_lStyle = lVidDialStyle;

					CGenWindow *pLocalParent = pVidAndDial;

					if (CreateFull == eMode
						|| CreateTelephone == eMode
						)
					{
						CreateDialingWindow(pVidAndDial);
					}

					if (CreateFull == eMode
						|| CreateRemoteOnly == eMode
						|| CreateRemoteNoPause == eMode
						)
					{
						// Create the remote video window
						m_pRemoteVideo = new CRemoteVideo(bEmbedded);
						if (NULL != m_pRemoteVideo)
						{
							SetHideModes(m_pRemoteVideo, Dialing|Previewing|DataOnly);

							m_pRemoteVideo->Create(pVidAndDial->GetWindow(), GetPalette(), this);

							pLocalParent = m_pRemoteVideo;
						}
					}

					if (CreateFull == eMode
						|| CreatePreviewOnly == eMode
						|| CreatePreviewNoPause == eMode
						)
					{
						// Create the local video window, even though we don't show it yet
						m_pLocalVideo = new CVideoWindow(CVideoWindow::LOCAL, bEmbedded);
						if (NULL != m_pLocalVideo)
						{
							SetHideModes(m_pLocalVideo, Dialing|Receiving|DataOnly);

							m_pLocalVideo->Create(pLocalParent->GetWindow(), GetPalette(), this);
							ShowWindow(m_pLocalVideo->GetWindow(), SW_HIDE);
						}
					}
				}

				pVidAndDial->Release();
			}

			if (CreateFull == eMode
				|| CreateTelephone == eMode
				)
			{
				// create the toolbar
				static const Buttons abOsr2Calling[] =
				{
					{ IDB_DIAL     , CBitmapButton::Disabled+1,    1, ID_TB_NEW_CALL , IDS_TT_TB_NEW_CALL , },
					{ IDB_HANGUP   , CBitmapButton::Disabled+1,    1, IDM_FILE_HANGUP, IDS_TT_FILE_HANGUP, },
					{ IDB_DIRECTORY, CBitmapButton::Disabled+1,    1, ID_TB_DIRECTORY, IDS_TT_TB_DIRECTORY, },
					{ IDB_SHOWAV   , CBitmapButton::Hot+1, Checked+1, ID_TB_SHOWAVTB , IDS_TT_TB_SHOWAVTB , },
				} ;
				CGenWindow *agwOsr2Calling[ARRAY_ELEMENTS(abOsr2Calling)];

				// This is the right-hand part of the border window
				CToolbar *ptbOsr2Calling = CreateToolbar(pVideoAndCalling, NULL, 0, DataOnly);
				if (NULL != ptbOsr2Calling)
				{
					pVideoAndCalling->m_uParts |= CBorderWindow::Right;

					ptbOsr2Calling->m_bVertical = TRUE;
					ptbOsr2Calling->m_nAlignment = Center;

					ZeroArray(agwOsr2Calling);
					AddButtons(ptbOsr2Calling, abOsr2Calling, ARRAY_ELEMENTS(abOsr2Calling),
						TRUE, agwOsr2Calling);

					SetHideModes(agwOsr2Calling[0], Normal);
					SetHideModes(agwOsr2Calling[3], Normal);

					ptbOsr2Calling->m_uRightIndex = 3;

					ptbOsr2Calling->Release();
				}
			}

			// This is the bottom part of the border window
			CreateAVTB(pVideoAndCalling, eMode);
			pVideoAndCalling->m_uParts |= CBorderWindow::Bottom;
		}

		pVideoAndCalling->Release();
	}
}

void CMainUI::CreateAVTB(CGenWindow *pParent, CreateViewMode eMode)
{
	switch (eMode)
	{
	case CreateFull:
	case CreatePreviewOnly:
	case CreateRemoteOnly:
		break;

	default:
		return;
	}

	const static int AVHMargin = 10;
	const static int AVVMargin = 2;
	const static int AVHGap = ButtonsGap;

	// create the toolbar
	static const Buttons avButtons[] =
	{
		{ IDB_PLAYPAUSE, CBitmapButton::Disabled+1,         2, ID_TB_PLAYPAUSE  , IDS_TT_TB_PLAYPAUSE  , },
		{ IDB_PIP      , CBitmapButton::Disabled+1,         1, ID_TB_PICINPIC   , IDS_TT_TB_PICINPIC   , },
		{ IDB_AUDIO    , CBitmapButton::Disabled+1, Checked+1, ID_TB_AUDIOTUNING, IDS_TT_TB_AUDIOTUNING, },
	} ;

	int nButtons = eMode == CreateFull ? ARRAY_ELEMENTS(avButtons) : 1;

	CToolbar *pAV = CreateToolbar(pParent, NULL, 0, NoAVTB|DataOnly);
	if (NULL != pAV)
	{
		CGenWindow *aButtons[ARRAY_ELEMENTS(avButtons)];
		ZeroArray(aButtons);
		AddButtons(pAV, avButtons, nButtons, TRUE, aButtons);

		CGenWindow *pAT;
        
        //
        // If video is completely disabled by policy, disable video buttons
        //
        if (!FIsSendVideoAllowed() && !FIsReceiveVideoAllowed())
        {
            pAT = aButtons[0];
            if (NULL != pAT)
            {
                EnableWindow(pAT->GetWindow(), FALSE);
            }

            pAT = aButtons[1];
            if (NULL != pAT)
            {
                EnableWindow(pAT->GetWindow(), FALSE);
            }
        }

        //
        // If audio is completely disabled by policy, disable audio buttons
        //
        pAT = aButtons[2];
		if (NULL != pAT)
		{
			ASSERT(ID_TB_AUDIOTUNING == GetDlgCtrlID(pAT->GetWindow()));

			if (!FIsAudioAllowed())
			{
				EnableWindow(pAT->GetWindow(), FALSE);
			}
		}

		pAV->m_hMargin = AVHMargin;
		pAV->m_vMargin = AVVMargin;
		pAV->m_gap     = AVHGap;
		pAV->Release();
	}
}

#if FALSE // {
void CMainUI::CreateCallsTB(CGenWindow *pParent)
{
	// create the toolbar
	static const Buttons callsButtons[] =
	{
		{ IDB_INCOMING   , CBitmapButton::Hot+1, 1, ID_TB_INCOMING   , IDS_TT_TB_INCOMING   , },
		{ IDB_HANGUP     , CBitmapButton::Hot+1, 1, IDM_FILE_HANGUP  , IDS_TT_FILE_HANGUP  , },
		{ IDB_CREDENTIALS, CBitmapButton::Hot+1, 1, ID_TB_CREDENTIALS, IDS_TT_TB_CREDENTIALS, },
	} ;

	CToolbar *pCalls = CreateToolbar(pParent, callsButtons, ARRAY_ELEMENTS(callsButtons),
		Compact);
	if (NULL != pCalls)
	{
		pCalls->Release();
	}
}
#endif // FALSE }

void CMainUI::CreateDialingWindow(
	CGenWindow *pParent	// The parent window
	)
{
	const static int DialHMargin = 17;
	const static int DialVMargin = 4;
	const static int DialHGap = 5;
	const static int DialVGap = 0;

	CEdgedWindow *pEdge = new CEdgedWindow();
	if (NULL == pEdge)
	{
		return;
	}
	SetHideModes(pEdge, Video|DataOnly);

	if (pEdge->Create(pParent->GetWindow()))
	{
		CToolbar *pDialing = CreateToolbar(pEdge, NULL, 0, Ignore);
		if (NULL != pDialing)
		{
			pDialing->m_bVertical = TRUE;
			pDialing->m_gap = DialVGap;
			pDialing->m_hMargin = DialHMargin;
			pDialing->m_vMargin = DialVMargin;

			static const Buttons dialButtons[] =
			{
				{ IDB_DIAL1    , CBitmapButton::Hot+1, 1, ID_TB_DIAL1    , IDS_TT_DIALPAD, },
				{ IDB_DIAL2    , CBitmapButton::Hot+1, 1, ID_TB_DIAL2    , IDS_TT_DIALPAD, },
				{ IDB_DIAL3    , CBitmapButton::Hot+1, 1, ID_TB_DIAL3    , IDS_TT_DIALPAD, },
				{ IDB_DIAL4    , CBitmapButton::Hot+1, 1, ID_TB_DIAL4    , IDS_TT_DIALPAD, },
				{ IDB_DIAL5    , CBitmapButton::Hot+1, 1, ID_TB_DIAL5    , IDS_TT_DIALPAD, },
				{ IDB_DIAL6    , CBitmapButton::Hot+1, 1, ID_TB_DIAL6    , IDS_TT_DIALPAD, },
				{ IDB_DIAL7    , CBitmapButton::Hot+1, 1, ID_TB_DIAL7    , IDS_TT_DIALPAD, },
				{ IDB_DIAL8    , CBitmapButton::Hot+1, 1, ID_TB_DIAL8    , IDS_TT_DIALPAD, },
				{ IDB_DIAL9    , CBitmapButton::Hot+1, 1, ID_TB_DIAL9    , IDS_TT_DIALPAD, },
				{ IDB_DIALSTAR , CBitmapButton::Hot+1, 1, ID_TB_DIALSTAR , IDS_TT_DIALPAD, },
				{ IDB_DIAL0    , CBitmapButton::Hot+1, 1, ID_TB_DIAL0    , IDS_TT_DIALPAD, },
				{ IDB_DIALPOUND, CBitmapButton::Hot+1, 1, ID_TB_DIALPOUND, IDS_TT_DIALPAD, },
			} ;

			for (int row=0; row<4; ++row)
			{
				CToolbar *pRowTB = CreateToolbar(pDialing);
				if (NULL != pRowTB)
				{
					pRowTB->m_gap = DialHGap;

					AddButtons(pRowTB, &dialButtons[row*3], 3, TRUE, NULL, this);
					pRowTB->Release();
				}
			}

			pDialing->Release();
		}
	}

	pEdge->Release();
}

// Creates the audio-tuning window
void CMainUI::CreateAudioTuningWindow(
	CGenWindow *pParent	// The parent window
	)
{
	static const int ATHMargin = 8;
	static const int ATVMargin = 6;

	static const int ATControlWidth = 170;

	CToolbar *pATWindow = CreateToolbar(pParent, NULL, 0, NoAVTB|Roster|DataOnly);
	if (NULL != pATWindow)
	{
		pATWindow->m_bVertical = TRUE;
		pATWindow->m_nAlignment = Fill;

		pATWindow->m_gap = MainGap;

		CEdgedWindow *pEdge;

		pEdge = new CEdgedWindow();
		if (NULL != pEdge)
		{
			pEdge->m_hMargin = ATHMargin;
			pEdge->m_vMargin = ATVMargin;

			if (pEdge->Create(pATWindow->GetWindow()))
			{
				SetHideModes(pEdge, Ignore);

				CButton *pButton = new CButton();
				if (NULL != pButton)
				{
					pButton->Create(pEdge->GetWindow(), ID_TB_TUNEMIC_UNMUTE, NULL,
						BS_CHECKBOX|BS_ICON|WS_TABSTOP, this);
					pButton->SetTooltip(RES2T(IDS_TT_MUTE_MIC));

					HICON hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetModuleInstance(),
						MAKEINTRESOURCE(IDI_MICFONE),
						IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
						LR_DEFAULTCOLOR));
					pButton->SetIcon(hIcon);

					pEdge->SetHeader(pButton);

					pButton->Release();
				}
				UpdateMuteState(FALSE, pButton);

				m_pAudioMic = new CProgressTrackbar();
				if (NULL != m_pAudioMic)
				{
					if (m_pAudioMic->Create(pEdge->GetWindow(), 0, this))
					{
						m_pAudioMic->SetTooltip(RES2T(IDS_TT_ADJUST_MIC));

						m_pAudioMic->SetMaxValue(AudioMax);

						SIZE size;
						m_pAudioMic->GetDesiredSize(&size);
						size.cx = ATControlWidth;
						m_pAudioMic->SetDesiredSize(&size);
					}

					// m_pAudioMic->Release();
				}
			}

			pEdge->Release();
		}


		pEdge = new CEdgedWindow();
		if (NULL != pEdge)
		{
			pEdge->m_hMargin = ATHMargin;
			pEdge->m_vMargin = ATVMargin;

			if (pEdge->Create(pATWindow->GetWindow()))
			{
				SetHideModes(pEdge, Ignore);

				CButton *pButton = new CButton();
				if (NULL != pButton)
				{
					pButton->Create(pEdge->GetWindow(), ID_TB_TUNESPEAKER_UNMUTE, NULL,
						BS_CHECKBOX|BS_ICON|WS_TABSTOP, this);
					pButton->SetTooltip(RES2T(IDS_TT_MUTE_SPK));

					HICON hIcon = reinterpret_cast<HICON>(LoadImage(_Module.GetModuleInstance(),
						MAKEINTRESOURCE(IDI_SPEAKER),
						IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
						LR_DEFAULTCOLOR));
					pButton->SetIcon(hIcon);

					pEdge->SetHeader(pButton);

					pButton->Release();
				}
				UpdateMuteState(TRUE, pButton);

				m_pAudioSpeaker = new CProgressTrackbar();
				if (NULL != m_pAudioSpeaker)
				{
					if (m_pAudioSpeaker->Create(pEdge->GetWindow(), 0, this))
					{
						m_pAudioSpeaker->SetTooltip(RES2T(IDS_TT_ADJUST_SPK));

						m_pAudioSpeaker->SetMaxValue(AudioMax);

						SIZE size;
						m_pAudioSpeaker->GetDesiredSize(&size);
						size.cx = ATControlWidth;
						m_pAudioSpeaker->SetDesiredSize(&size);
					}

					// m_pAudioSpeaker->Release();
				}
			}

			pEdge->Release();
		}

		pATWindow->Release();
	}

	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		// Force an update of the controls
		OnAudioLevelChange(TRUE , pAudioControl->GetSpeakerVolume());
		OnAudioLevelChange(FALSE, pAudioControl->GetRecorderVolume());
	}
}

void CMainUI::CreateRosterArea(CGenWindow *pParent, CreateViewMode eMode)
{
	switch (eMode)
	{
	case CreateFull:
	case CreateDataOnly:
	case CreateTelephone:
		break;

	default:
		return;
	}

	CLayeredView *pView = new CLayeredView();
	if (NULL == pView)
	{
		// Pretty bad
		return;
	}

	if (pView->Create(pParent->GetWindow()))
	{
		SetHideModes(pView, IfNoChildren);

		pView->m_lStyle = CLayeredView::Fill;

		if (eMode != CreateDataOnly)
		{
			CreateAudioTuningWindow(pView);
		}

		if (eMode != CreateTelephone)
		{
			CToolbar *pRosterAndCall = CreateToolbar(pView);
			if (NULL != pRosterAndCall)
			{
				pRosterAndCall->m_nAlignment = CToolbar::Fill;

				m_pRoster = new CRosterParent();
				if (NULL != m_pRoster)
				{
					m_pRoster->Create(pRosterAndCall->GetWindow());

					// HACKHACK georgep: Just calling SetUserData directly for now
					SetHideModes(m_pRoster, Compact|AudioTuning);
				}

				if (CreateDataOnly != eMode)
				{
					CToolbar *pCalling = CreateToolbar(pRosterAndCall);
					if (NULL != pCalling)
					{
						SetHideModes(pCalling, Normal|Compact);

						pCalling->m_bVertical = TRUE;

						static const Buttons abCalling[] =
						{
							{ IDB_HANGUP   , CBitmapButton::Disabled+1, 1, IDM_FILE_HANGUP, IDS_TT_FILE_HANGUP, },
							{ IDB_DIRECTORY, CBitmapButton::Disabled+1, 1, ID_TB_DIRECTORY, IDS_TT_TB_DIRECTORY, },
						} ;
						AddButtons(pCalling, abCalling, ARRAY_ELEMENTS(abCalling),
							TRUE, NULL, this);

						pCalling->Release();
					}
				}

				pRosterAndCall->m_uRightIndex = 1;
				pRosterAndCall->m_bHasCenterChild = TRUE;

				pRosterAndCall->Release();
			}
		}
	}

	pView->Release();
}

BOOL CMainUI::Create(
	HWND hwndParent,
	CConfRoom *pConfRoom,
	CreateViewMode eMode,
	BOOL bEmbedded
	)
{
	// Store this away so we can call some methods in it later
	m_pConfRoom = pConfRoom;
	ASSERT(m_pConfRoom);

	if (NULL == m_pConfRoom)
	{
		return(FALSE);
	}

	// Create the window
	if (!CToolbar::Create(hwndParent))
	{
		return(FALSE);
	}

	// Try to remain a little bit abstract
	CToolbar *pMain = this;

	m_pConfRoom->AddConferenceChangeHandler(this);

	// A vertical toolbar that fills all its area
	pMain->m_hMargin = MainHMargin;
	pMain->m_vMargin = MainVMargin;
	pMain->m_gap     = MainGap;

	if (CreateRemoteNoPause == eMode
		|| CreatePreviewNoPause == eMode
		)
	{
		pMain->m_hMargin = 0;
		pMain->m_vMargin = 0;

		pMain->m_bHasCenterChild = TRUE;

		//HACKHACK This only works because all these views have only 1 window
		pMain->m_uRightIndex = 1;
	}

	pMain->m_bVertical = TRUE;
	pMain->m_nAlignment = Fill;

	m_hbBack = CGenWindow::GetStandardBrush();

	// Create all the sub toolbars
	if (CreateFull == eMode
		|| CreateTelephone == eMode
		)
	{
		CreateDialTB(pMain);
	}

	CreateVideoAndAppsTB(pMain, eMode, bEmbedded);
	CreateRosterArea(pMain, eMode);

	if (CreateFull == eMode
		|| CreateDataOnly == eMode
		)
	{
		CreateAppsTB(pMain);
	}

	// Now we need to update to the current state of the conference
	if (m_pConfRoom->FIsConferenceActive())
	{
		OnCallStarted();

		CSimpleArray<CParticipant*>& lMembers = m_pConfRoom->GetParticipantList();
		for (int i=lMembers.GetSize()-1; i>=0; --i)
		{
			OnChangeParticipant(lMembers[i], NM_MEMBER_ADDED);
		}

		// Need to tell everybody what the active channels are
		INmConference2 *pNmConf = m_pConfRoom->GetActiveConference();
		if (NULL != pNmConf)
		{
			// Just in case
			pNmConf->AddRef();

			IEnumNmChannel *pEnumCh;
			if (SUCCEEDED(pNmConf->EnumChannel(&pEnumCh)))
			{
				INmChannel *pChannel;
				ULONG uGot;
				while (S_OK == pEnumCh->Next(1, &pChannel, &uGot) && 1 == uGot)
				{
					OnVideoChannelChanged(NM_CHANNEL_ADDED, pChannel);
					pChannel->Release();
				}

				pEnumCh->Release();
			}

			pNmConf->Release();
		}
	}

	if (CreateDataOnly == eMode)
	{
		SetDataOnly(TRUE);
	}

	if (CreateTelephone == eMode)
	{
		SetDialing(TRUE);
		SetAudioTuning(TRUE);
	}

	OnChangePermissions();

	UpdateViewState();

	UpdatePlayPauseState();

	return(TRUE);
}

HBRUSH CMainUI::GetBackgroundBrush()
{
	return(m_hbBack);
}

// REVIEW georgep: Should this loop until it gets an IGenWindow?
HPALETTE CMainUI::GetPalette()
{
	return(m_pConfRoom->GetPalette());
}

// Recursive function to hide/show windows for the current view
// Returns whether any of the children are visible
BOOL ShowWindows(
	HWND hwndParent,	// The parent window to start from
	LPARAM lDefMode,	// The hide mode to use if Inherit
	LPARAM hideMode		// The current hide mode
	)
{
	BOOL bRet = FALSE;

	for (HWND hwndChild=::GetWindow(hwndParent, GW_CHILD); NULL!=hwndChild;
		hwndChild=::GetWindow(hwndChild, GW_HWNDNEXT))
	{
		IGenWindow *pChild = IGenWindow::FromHandle(hwndChild);
		if (NULL == pChild)
		{
			continue;
		}

		LPARAM lMode = GetHideModes(pChild);
		if (Ignore == lMode)
		{
			if ((GetWindowStyle(hwndChild)&WS_VISIBLE) != 0)
			{
				bRet = TRUE;
			}

			continue;
		}
		if (Inherit == lMode)
		{
			lMode = lDefMode;
		}

		// recurse to child windows first to avoid flicker
		LPARAM lNoChildren = ShowWindows(hwndChild, lMode, hideMode) ? 0 : IfNoChildren;

		// If any of the hide mode bits are set, then hide the window
		// otherwise show it
		BOOL bShow = ((lMode&(hideMode|lNoChildren)) == 0);
		if (bShow)
		{
			bRet = TRUE;
		}

		ShowWindow(hwndChild, bShow ? SW_SHOW : SW_HIDE);
	}

	return(bRet);
}

BOOL CMainUI::CanPreview()
{
	HWND hwndLocal = GetVideoWindow(TRUE);

	return(NULL!=hwndLocal && GetLocalVideo()->IsXferAllowed());
}

void CMainUI::UpdateViewState()
{
	// Put together all the modes we ARE in, and hide any windows that want
	// to be hidden while in one of those modes
	// The default mode
	LPARAM hideModes;

	if (IsCompact())
	{
		hideModes = Compact;

		if (!IsShowAVTB())
		{
			hideModes |= NoAVTB;
		}
	}
	else if (IsDataOnly())
	{
		hideModes = DataOnly;
	}
	else
	{
		hideModes = Normal;
	}

	if (IsDialing())
	{
		hideModes |= Dialing;
	}
	else
	{
		// hwndRemote will be NULL for PreviewOnly mode
		HWND hwndRemote = GetVideoWindow(FALSE);
		if (NULL == hwndRemote)
		{
			hideModes |= Previewing;
		}
		else
		{
			HWND hwndLocal = GetVideoWindow(TRUE);

			BOOL bPreviewing = IsPreviewing();

			HWND parent = NULL;
			BOOL bZoomable;
			LONG style = GetWindowLong(hwndLocal, GWL_EXSTYLE);
			if (bPreviewing)
			{
				hideModes |= Previewing;
				parent = GetParent(hwndRemote);
				style |= WS_EX_CLIENTEDGE;
				bZoomable = TRUE;
			}
			else
			{
				hideModes |= (m_bPicInPic && CanPreview()) ? ReceivingWPiP : Receiving;
				parent = hwndRemote;
				style &= ~WS_EX_CLIENTEDGE;
				bZoomable = FALSE;
			}

			if (GetParent(hwndLocal) != parent)
			{
				SetWindowLong(hwndLocal, GWL_EXSTYLE, style);
				SetParent(hwndLocal, parent);
				SetWindowPos(hwndLocal, HWND_BOTTOM, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);

				CVideoWindow *pVideo = GetLocalVideo();
				if (NULL != pVideo)
				{
					pVideo->SetZoomable(bZoomable);
				}
			}
		}
	}

	// Enable/disable the PiP window
	IGenWindow *pPiP = FindControl(ID_TB_PICINPIC);
	if (NULL != pPiP)
	{
		CComPtr<CGenWindow> spButton = com_cast<CGenWindow>(pPiP);

		BOOL bEnable = !IsPreviewing() && CanPreview() && !IsDialing();
		EnableWindow(spButton->GetWindow(), bEnable);
	}

	hideModes |= IsAudioTuning() && !IsDataOnly() ? AudioTuning : Roster;

	HWND hwnd = GetWindow();

	ShowWindows(hwnd, 0, hideModes);

	// If the focus is on a child window which is now not visible, but we are,
	// then change the focus to this window
	if (!IsWindowVisible(GetFocus()) && IsWindowActive(hwnd) && IsWindowVisible(hwnd))
	{
		SetFocus(hwnd);
	}

	IGenWindow *pButton = FindControl(ID_TB_AUDIOTUNING);
	CComPtr<CBitmapButton> spButton = com_cast<CBitmapButton>(pButton);
	if (spButton)
	{
		BOOL bAudioTuning = IsAudioTuning() && !IsCompact();
		spButton->SetCustomState(bAudioTuning ? Checked : Unchecked);
		spButton->SetTooltip(RES2T(bAudioTuning ? IDS_TT_TB_SHOWROSTER : IDS_TT_TB_AUDIOTUNING));
	}

	OnDesiredSizeChanged();
}

void CMainUI::SetCompact(BOOL bCompact)
{
	bCompact = bCompact != FALSE;
	if (IsCompact() == bCompact)
	{
		// Nothing to do
		return;
	}

	m_eViewMode = bCompact ? ViewCompact : ViewNormal;

	UpdateViewState();
}

void CMainUI::SetDataOnly(BOOL bDataOnly)
{
	bDataOnly = bDataOnly != FALSE;
	if (IsDataOnly() == bDataOnly)
	{
		// Nothing to do
		return;
	}

	m_eViewMode = bDataOnly ? ViewDataOnly : ViewNormal;

	UpdateViewState();
}

void CMainUI::SetDialing(BOOL bDialing)
{
	bDialing = bDialing != FALSE;
	if (IsDialing() == bDialing)
	{
		// Nothing to do
		return;
	}

	m_bDialing = bDialing;

	UpdateViewState();
}

void CMainUI::SetPicInPic(BOOL bPicInPic)
{
	bPicInPic = bPicInPic != FALSE;
	if (IsPicInPic() == bPicInPic)
	{
		// Nothing to do
		return;
	}

	m_bPicInPic = bPicInPic;

	UpdateViewState();
}

BOOL CMainUI::IsPicInPicAllowed()
{
	return(!IsDataOnly() && !m_bPreviewing && CanPreview());
}

void CMainUI::SetAudioTuning(BOOL bAudioTuning)
{
	if ((IsAudioTuning() && bAudioTuning) || (!IsAudioTuning() && !bAudioTuning))
	{
		// Nothing to do
		return;
	}

	m_bAudioTuning = bAudioTuning;

	if (IsAudioTuning())
	{
		SetTimer(GetWindow(), IDT_AUDIO, AUDIODLG_MIC_TIMER_PERIOD, NULL);
	}
	else
	{
		KillTimer(GetWindow(), IDT_AUDIO);
	}

	UpdateViewState();
}

void CMainUI::SetShowAVTB(BOOL bShowAVTB)
{
	if ((IsShowAVTB() && bShowAVTB) || (!IsShowAVTB() && !bShowAVTB))
	{
		// Nothing to do
		return;
	}

	m_bShowAVTB = bShowAVTB;

	UpdateViewState();
}

LRESULT CMainUI::ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	static const UINT c_uMsgMSWheel = ::IsWindowsNT() ? WM_MOUSEWHEEL :
						::RegisterWindowMessage(_TEXT("MSWHEEL_ROLLMSG"));

	switch (message)
	{
		HANDLE_MSG(hwnd, WM_TIMER      , OnTimer);
		HANDLE_MSG(hwnd, WM_DESTROY    , OnDestroy);

	case WM_CREATE:
	{
		// Allow dialog-like keyboard support
		HACCEL hAccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_MAINUI));
		if (NULL != hAccel)
		{
			m_pAccel = new CTranslateAccelTable(hwnd, hAccel);
			if (NULL != m_pAccel)
			{
				AddTranslateAccelerator(m_pAccel);
			}
		}
		break;
	}

	case WM_SETFOCUS:
		ShiftFocus(GetWindow(), TRUE);
		break;

	default:
		if (message == c_uMsgMSWheel)
		{
			CRoomListView *pView = GetRoster();
			if (NULL != pView)
			{
				::SendMessage(pView->GetHwnd(), message, wParam, lParam);
			}
			break;
		}

		break;
	}

	return(CToolbar::ProcessMessage(hwnd, message, wParam, lParam));
}

void CMainUI::OnScroll(CProgressTrackbar *pTrackbar, UINT code, int pos)
{
	BOOL bSpeaker = FALSE;

	if (m_pAudioSpeaker == pTrackbar)
	{
		bSpeaker = TRUE;
	}
	else if (m_pAudioMic == pTrackbar)
	{
	}
	else
	{
		// I don't think we should get here
		return;
	}

	// Can't trust the pos passed in
	pos = pTrackbar->GetTrackValue();

	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL == pAudioControl)
	{
		return;
	}

	DWORD dwVolume = (pos*AudioVolMax + AudioMax/2)/AudioMax;
	dwVolume = min(max(dwVolume, 0), AudioVolMax);

	if (bSpeaker)
	{
		pAudioControl->SetSpeakerVolume(dwVolume);
	}
	else
	{
		pAudioControl->SetRecorderVolume(dwVolume);
	}
}

HWND CMainUI::GetVideoWindow(BOOL bLocal)
{
	CVideoWindow *pVideo = bLocal ? GetLocalVideo() : GetRemoteVideo();
	return(NULL == pVideo ? NULL : pVideo->GetWindow());
}

void CMainUI::ToggleMute(BOOL bSpeaker)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		BOOL bMuted = bSpeaker ? pAudioControl->IsSpkMuted() : pAudioControl->IsRecMuted();
		pAudioControl->MuteAudio(bSpeaker, !bMuted);
	}
}

void CMainUI::UpdateMuteState(BOOL bSpeaker, CButton *pButton)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		BOOL bMuted = bSpeaker ? pAudioControl->IsSpkMuted() : pAudioControl->IsRecMuted();

		pButton->SetChecked(!bMuted);
	}
}

void CMainUI::BumpAudio(BOOL bSpeaker, int pct)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		int dwVolume = static_cast<int>(bSpeaker ?
			pAudioControl->GetSpeakerVolume() : pAudioControl->GetRecorderVolume());
		dwVolume += (pct*AudioVolMax/100);
		dwVolume = min(max(dwVolume, 0), AudioVolMax);

		if (bSpeaker)
		{
			pAudioControl->SetSpeakerVolume(dwVolume);
		}
		else
		{
			pAudioControl->SetRecorderVolume(dwVolume);
		}
	}
}

void CMainUI::SetAudioProperty(BOOL bSpeaker, NM_AUDPROP uID, ULONG uValue)
{
	CAudioControl *pAudioControl = GetAudioControl();
	if (NULL != pAudioControl)
	{
		pAudioControl->SetProperty(bSpeaker, uID, uValue);
	}
}

// IButtonChange
void CMainUI::OnClick(CButton *pButton)
{
	HWND hwndCtl = pButton->GetWindow();

	OnCommand(GetWindow(), GetWindowLong(hwndCtl, GWL_ID), hwndCtl, BN_CLICKED);
}

void CMainUI::OnInitMenu(HMENU hMenu)
{
	CVideoWindow *pVideo = IsPreviewing() ? GetLocalVideo() : GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->UpdateVideoMenu(hMenu);

		pVideo = GetLocalVideo();
		EnableMenuItem(hMenu, IDM_VIDEO_UNDOCK,
			MF_BYCOMMAND|(NULL != pVideo && pVideo->IsXferAllowed() ? MF_ENABLED : MF_GRAYED|MF_DISABLED));
	}
}

static void AppendText(CCallingBar *pCalling, TCHAR cAdd)
{
	if (NULL != pCalling)
	{
		// I don't want to change a string that you can't see
		if (IsWindowVisible(pCalling->GetWindow()))
		{
			TCHAR szText[] = TEXT("0");
			szText[0] = cAdd;

			TCHAR szTemp[MAX_PATH];

			int nLen = pCalling->GetText(szTemp, ARRAY_ELEMENTS(szTemp));
			if (nLen + lstrlen(szText) <= ARRAY_ELEMENTS(szTemp) - 1)
			{
				lstrcat(szTemp, szText);
				pCalling->SetText(szTemp);
			}
		}
	}
}

static BOOL ShouldTry(HWND child)
{
	// REVIEW georgep: I could look at WS_EX_CONTROLPARENT also
	return((WS_VISIBLE) == (GetWindowStyle(child) & (WS_DISABLED|WS_VISIBLE)));
}

static BOOL IsTabbable(HWND child)
{
	return((WS_TABSTOP|WS_VISIBLE) == (GetWindowStyle(child) & (WS_TABSTOP|WS_DISABLED|WS_VISIBLE)));
}

// BUGBUG georgep: I should move this into CGenWindow
// Determine the next control in the tab order
static HWND NextControl(HWND hwndTop, HWND hwndFocus)
{
	// Loop detection stuff
	BOOL bGotToTop = FALSE;

	// We'll loop to avoid really deep recursion
	while (TRUE)
	{
		// First try the children of hwndFocus
		if (hwndFocus == hwndTop || ShouldTry(hwndFocus))
		{
			HWND next = GetFirstChild(hwndFocus);
			if (NULL != next)
			{
				if (IsTabbable(next))
				{
					return(next);
				}

				hwndFocus = next;
				continue;
			}
		}

		if (hwndFocus == hwndTop)
		{
			// Apparently hwndTop has no children
			return(NULL);
		}

		HWND next;
		while (NULL == (next = GetNextSibling(hwndFocus)))
		{
			hwndFocus = GetParent(hwndFocus);
			if (NULL == hwndFocus)
			{
				// Invalid params
				return(NULL);
			}

			if (hwndTop == hwndFocus)
			{
				break;
			}
		}

		if (hwndTop == hwndFocus)
		{
			// Detect if we have looped back to the top again
			if (bGotToTop)
			{
				return(NULL);
			}

			bGotToTop = TRUE;
			continue;
		}

		if (IsTabbable(next))
		{
			return(next);
		}

		hwndFocus = next;
	}

	// We looped back to the beginning, so I guess nobody can take the focus
	return(NULL);
}

// Determine the previous control in the tab order
static HWND PrevControl(HWND hwndTop, HWND hwndFocus)
{
	// LAZYLAZY georgep: It's hard to do this directly, so I'll just loop
	// on the NextControl. It should be fast enough.

	// In case hwndFocus is not focusable for some reason, we still need to
	// detect the loop
	HWND hwndStart = NextControl(hwndTop, hwndFocus);

	// HACK for combo boxes: go from the edit control to the combo box control
	while (NULL != hwndFocus
		&& hwndTop != hwndFocus
		&& !IsTabbable(hwndFocus)
		)
	{
		hwndFocus = GetParent(hwndFocus);
	}

	HWND ret = hwndStart;
	while (TRUE)
	{
		HWND next = NextControl(hwndTop, ret);
		if (NULL == next)
		{
			// Oops!
			return(NULL);
		}

		if (hwndFocus == next
			|| hwndStart == next
			)
		{
			break;
		}

		ret = next;
	}

	return(ret);
}

static void ShiftFocus(HWND hwndTop, BOOL bForward)
{
	HWND hwndFocus = GetFocus();

	if (!IsWindowActive(hwndTop))
	{
		hwndFocus = hwndTop;
	}

	HWND next = bForward ? NextControl(hwndTop, hwndFocus) : PrevControl(hwndTop, hwndFocus);
	if (NULL != next)
	{
		SetFocus(next);
	}
	else
	{
		MessageBeep(MB_ICONHAND);
	}
}

void CMainUI::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
	switch (id)
	{
	case ID_NAV_TAB:
		ShiftFocus(hwnd, TRUE);
		break;

	case ID_NAV_SHIFT_TAB:
		ShiftFocus(hwnd, FALSE);
		break;

	case IDM_VIEW_DIALPAD:
		SetDialing(!IsDialing());
		break;

	case ID_TB_PICINPIC:
		SetPicInPic(!IsPicInPic());
		break;

	case ID_TB_REJECT:
	case ID_TB_CREDENTIALS:
		break;

	case ID_TB_AUDIOTUNING:
	{
		m_bStateChanged = TRUE;

		SetAudioTuning(!IsAudioTuning());
		break;
	}

	case ID_TB_SHOWAVTB:
	{
		m_bStateChanged = TRUE;

		SetShowAVTB(!IsShowAVTB());
		CComPtr<CBitmapButton> spButton = com_cast<CBitmapButton>(IGenWindow::FromHandle(hwndCtl));
		if (spButton)
		{
			BOOL bShow = IsShowAVTB();

			spButton->SetCustomState(bShow ? Checked : Unchecked);
			spButton->SetTooltip(RES2T(bShow ? IDS_TT_TB_HIDEAVTB : IDS_TT_TB_SHOWAVTB));
		}
		break;
	}

	case ID_TB_TUNEMIC_UNMUTE:
		ToggleMute(FALSE);
		break;

	case ID_TB_TUNESPEAKER_UNMUTE:
		ToggleMute(TRUE);
		break;

	case ID_TB_DIAL0:
	case ID_TB_DIAL1:
	case ID_TB_DIAL2:
	case ID_TB_DIAL3:
	case ID_TB_DIAL4:
	case ID_TB_DIAL5:
	case ID_TB_DIAL6:
	case ID_TB_DIAL7:
	case ID_TB_DIAL8:
	case ID_TB_DIAL9:
		SetAudioProperty(FALSE, NM_AUDPROP_DTMF_DIGIT, id-ID_TB_DIAL0);
		AppendText(m_pCalling, '0'+id-ID_TB_DIAL0);
		break;

	case ID_TB_DIALSTAR:
		SetAudioProperty(FALSE, NM_AUDPROP_DTMF_DIGIT, 10);
		AppendText(m_pCalling, '*');
		break;

	case ID_TB_DIALPOUND:
		SetAudioProperty(FALSE, NM_AUDPROP_DTMF_DIGIT, 11);
		AppendText(m_pCalling, '#');
		break;

	case ID_TB_DIRECTORY:
	{
		CFindSomeone::findSomeone(m_pConfRoom);
	}
	break;

	case ID_TB_PLAYPAUSE:
		TogglePlayPause();
		break;

	case IDM_VIDEO_ZOOM1:
	case IDM_VIDEO_ZOOM2:
	case IDM_VIDEO_ZOOM3:
	case IDM_VIDEO_ZOOM4:
	case IDM_VIDEO_UNDOCK:
	case IDM_VIDEO_GETACAMERA:
	{
		CVideoWindow *pVideo = IsPreviewing() ? GetLocalVideo() : GetRemoteVideo();
		if (NULL != pVideo)
		{
			pVideo->OnCommand(id);
		}
		break;
	}

	case IDM_POPUP_EJECT:
	case IDM_POPUP_PROPERTIES:
	case IDM_POPUP_SPEEDDIAL:
	case IDM_POPUP_ADDRESSBOOK:
    case IDM_POPUP_GIVECONTROL:
    case IDM_POPUP_CANCELGIVECONTROL:
	{
		CRoomListView *pView = GetRoster();
		if (NULL != pView)
		{
			CParticipant * pPart = pView->GetParticipant();
			if (NULL != pPart)
			{
				pPart->OnCommand(hwnd, (WORD)id);
			}
		}
		break;
	}

	case ID_FILE_CREATE_SPEED_DIAL:
	{
		TCHAR szAddress[MAX_EMAIL_NAME_LENGTH + MAX_SERVER_NAME_LENGTH + 1];
		LPCTSTR pszAddress = NULL;
		CRoomListView *pView = GetRoster();
		if (NULL != pView)
		{
			CParticipant * pPart = pView->GetParticipant();
			if (NULL != pPart)
			{
				if (S_OK == pPart->GetUlsAddr(szAddress, CCHMAX(szAddress)))
				{
					pszAddress = szAddress;
				}
			}
		}

		CSpeedDialDlg sdd(hwnd, NM_ADDR_ULS);
		sdd.DoModal(pszAddress);
		break;
	}

	case ID_TB_CHAT:
	case ID_TB_NEWWHITEBOARD:
    case ID_TB_SHARING:
	case ID_TB_NEW_CALL:
	default:
		m_pConfRoom->OnCommand(hwnd, id, hwndCtl, codeNotify);
		break;
	}
}

void CMainUI::OnDestroy(HWND hwnd)
{
	if (NULL != m_pConfRoom)
	{
		m_pConfRoom->RemoveConferenceChangeHandler(this);
	}

	if (NULL != m_pAccel)
	{
		RemoveTranslateAccelerator(m_pAccel);
		m_pAccel->Release();
		m_pAccel = NULL;
	}
}

BOOL CMainUI::OnQueryEndSession()
{
	CMainUI::OnClose();

	return(TRUE);
}

void CMainUI::OnClose()
{
	CVideoWindow *pLocal = GetLocalVideo();
	if (NULL != pLocal)
	{
		pLocal->Pause(TRUE);
	}
}

VOID CMainUI::SaveSettings()
{
	CVideoWindow *pVideo;
	pVideo = GetLocalVideo();
	if (NULL != pVideo)
	{
		pVideo->SaveSettings();
	}
	pVideo = GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->SaveSettings();
	}
}

VOID CMainUI::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CVideoWindow *pVideo;
	pVideo = GetLocalVideo();
	if (NULL != pVideo)
	{
		pVideo->ForwardSysChangeMsg(uMsg, wParam, lParam);
	}
	pVideo = GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->ForwardSysChangeMsg(uMsg, wParam, lParam);
	}

	CRoomListView *pView = GetRoster();
	if (NULL != pView)
	{
		pView->ForwardSysChangeMsg(uMsg, wParam, lParam);
	}

	switch (uMsg)
	{
	case WM_PALETTECHANGED:
		::RedrawWindow(GetWindow(), NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN);
		break;
	}
}

void CMainUI::OnTimer(HWND hwnd, UINT id)
{
	if (IDT_AUDIO == id)
	{
		CAudioControl *pAudioControl = GetAudioControl();
		if (NULL != pAudioControl)
		{
			DWORD dwLevel;

			dwLevel = pAudioControl->GetAudioSignalLevel(FALSE /*fSpeaker*/);	// This level ranges from 0-100
			m_pAudioMic->SetProgressValue(dwLevel);

			dwLevel = pAudioControl->GetAudioSignalLevel(TRUE /*fSpeaker*/);	// This level ranges from 0-100
			m_pAudioSpeaker->SetProgressValue(dwLevel);
		}
	}
}

// Get the associated audion control object
CAudioControl *CMainUI::GetAudioControl()
{
	return(m_pConfRoom->GetAudioControl());
}

static void EnableControl(IGenWindow *pControl, BOOL bEnable)
{
	if (NULL == pControl)
	{
		return;
	}

	CComPtr<CGenWindow> spControl = com_cast<CGenWindow>(pControl);
	if (spControl)
	{
		HWND hwnd = spControl->GetWindow();
		if (NULL != hwnd)
		{
			EnableWindow(hwnd, bEnable);
		}
	}
}

void CMainUI::OnChangePermissions()
{
    EnableControl(FindControl(ID_TB_NEW_CALL     ), m_pConfRoom->IsNewCallAllowed());
	EnableControl(FindControl(ID_TB_SHARING      ), m_pConfRoom->IsSharingAllowed());
	EnableControl(FindControl(ID_TB_CHAT         ), m_pConfRoom->IsChatAllowed());
	EnableControl(FindControl(ID_TB_NEWWHITEBOARD), m_pConfRoom->IsNewWhiteboardAllowed());
	EnableControl(FindControl(ID_TB_FILETRANSFER ), m_pConfRoom->IsFileTransferAllowed());
}

void CMainUI::OnCallStarted()
{
	m_bPreviewing = FALSE;
	UpdateViewState();
	UpdatePlayPauseState();
}

void CMainUI::OnCallEnded()
{
	m_bPreviewing = TRUE;
	UpdateViewState();
	UpdatePlayPauseState();
}

void CMainUI::OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume)
{
	CProgressTrackbar *pBar = fSpeaker ? m_pAudioSpeaker : m_pAudioMic;
	if (NULL != pBar)
	{
		pBar->SetTrackValue((dwVolume*AudioMax + AudioVolMax/2) / AudioVolMax);
	}
}

void CMainUI::OnAudioMuteChange(BOOL fSpeaker, BOOL fMute)
{
	IGenWindow *pButton = FindControl(fSpeaker ? ID_TB_TUNESPEAKER_UNMUTE : ID_TB_TUNEMIC_UNMUTE);
	if (NULL != pButton)
	{
		CComPtr<CButton> spButton = com_cast<CButton>(pButton);
		if (spButton)
		{
			UpdateMuteState(fSpeaker, spButton);
		}
	}
}

BOOL CMainUI::GetPlayPauseState()
{
	BOOL bMuted = TRUE;

	// We're just going to show the state for the "big" window
	if (IsPreviewing())
	{
		if (NULL != m_pLocalVideo)
		{
			bMuted = bMuted && m_pLocalVideo->IsPaused();
		}
	}
	else
	{
		if (NULL != m_pRemoteVideo)
		{
			bMuted = bMuted && m_pRemoteVideo->IsPaused();
		}
	}

	return(bMuted);
}

void CMainUI::UpdatePlayPauseState()
{
	BOOL bMuted = GetPlayPauseState();

	IGenWindow *pButton = FindControl(ID_TB_PLAYPAUSE);
	if (NULL != pButton)
	{
		CComPtr<CBitmapButton> spButton = com_cast<CBitmapButton>(pButton);
		if (spButton)
		{
			spButton->SetCustomState(bMuted ? 0 : 1);
			spButton->SetTooltip(RES2T(bMuted ? IDS_TT_TB_PLAYPAUSE : IDS_TT_TB_PAUSE));
		}
	}
}

void CMainUI::TogglePlayPause()
{
	// We're going to apply the current state to both videos
	BOOL bMute = !GetPlayPauseState();

	if (NULL != m_pRemoteVideo)
	{
		m_pRemoteVideo->Pause(bMute);
	}
	if (NULL != m_pLocalVideo)
	{
		m_pLocalVideo->Pause(bMute);
	}

	UpdatePlayPauseState();
}

void CMainUI::OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify)
{
	CRoomListView *pView = GetRoster();

	if (NULL != pView)
	{
		pView->OnChangeParticipant(pPart, uNotify);
	}
}

void CMainUI::OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	// BUGBUG georgep: This really should only go to one or the other,
	// depending on if it is incoming, but I'm sending to both
	CVideoWindow *pVideo;
	pVideo = GetRemoteVideo();
	if (NULL != pVideo)
	{
		pVideo->OnChannelChanged(uNotify, pChannel);
	}
	pVideo = GetLocalVideo();
	if (NULL != pVideo)
	{
		pVideo->OnChannelChanged(uNotify, pChannel);
	}
}

void CMainUI::StateChange(CVideoWindow *pVideo, NM_VIDEO_STATE uState)
{
	UpdatePlayPauseState();
}

CFrame *CMainUI::s_pVideoFrame = NULL;

class CVideoFrame : public CFrame
{
protected:
	virtual LRESULT ProcessMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		switch (uMsg)
		{
		case WM_DESTROY:
		{
			RECT rc;
			::GetWindowRect(hwnd, &rc);

			RegEntry reVideo( VIDEO_LOCAL_KEY, HKEY_CURRENT_USER );

			reVideo.SetValue(REGVAL_VIDEO_XPOS, rc.left);
			reVideo.SetValue(REGVAL_VIDEO_YPOS, rc.top);
			break;
		}
		}

		return(CFrame::ProcessMessage(hwnd, uMsg, wParam, lParam));
	}
} ;

BOOL CMainUI::NewVideoWindow(CConfRoom *pConfRoom)
{
	if (NULL == s_pVideoFrame)
	{
		s_pVideoFrame = new CVideoFrame();
		if (NULL == s_pVideoFrame)
		{
			// Could not initialize
			return(FALSE);
		}
	}

	HWND hwnd = s_pVideoFrame->GetWindow();
	if (NULL != hwnd)
	{
		return(s_pVideoFrame->SetForeground());
	}

	TCHAR szTitle[256];
	LoadString(::GetInstanceHandle(), IDS_MYVIDEO, szTitle, ARRAY_ELEMENTS(szTitle));
	HICON hiBig = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_CONFROOM));

	if (!s_pVideoFrame->Create(
		NULL,			// Window owner
		szTitle,	// Window name
		(WS_OVERLAPPEDWINDOW&~(WS_THICKFRAME|WS_MAXIMIZEBOX)),			// Window style
		0,		// Extended window style
		0,					// Window pos: x
		0,					// Window pos: y
		500,				// Window size: width
		500,			// Window size: height
		_Module.GetModuleInstance(),		// The hInstance to create the window on
		hiBig,		// The icon for the window
		NULL		// Window menu
		))
	{
		return(FALSE);
	}

	BOOL bRet = FALSE;

	CMainUI *pMainUI = new CMainUI();
	if (NULL != pMainUI)
	{
		if (pMainUI->Create(s_pVideoFrame->GetWindow(), pConfRoom, CreatePreviewOnly))
		{
			// Make sure it is the right size before showing the window
			s_pVideoFrame->Resize();

			RegEntry reVideo( VIDEO_LOCAL_KEY, HKEY_CURRENT_USER );
			int x = reVideo.GetNumber(
					REGVAL_VIDEO_XPOS, 0x7fff );
			int y = reVideo.GetNumber(
					REGVAL_VIDEO_YPOS, 0x7fff );

			s_pVideoFrame->MoveEnsureVisible(x, y);

			bRet = s_pVideoFrame->SetForeground();
		}
		pMainUI->Release();
	}

	if (!bRet)
	{
		DestroyWindow(s_pVideoFrame->GetWindow());
	}
	return(bRet);
}

void CMainUI::CleanUpVideoWindow()
{
	if (NULL != s_pVideoFrame)
	{
		HWND hwnd = s_pVideoFrame->GetWindow();
		if (NULL != hwnd)
		{
			DestroyWindow(hwnd);
		}

		s_pVideoFrame->Release();
		s_pVideoFrame = NULL;
	}
}

CRoomListView *CMainUI::GetRoster() const
{
	return(NULL == m_pRoster ? NULL : m_pRoster->GetRoster());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\rtoolbar.h ===
/****************************************************************************
*
*    FILE:     RToolbar.h
*
*    CREATED:  Chris Pirich (ChrisPi) 7-27-95
*
****************************************************************************/

#ifndef _RTOOLBAR_H_
#define _RTOOLBAR_H_

#include "GenContainers.h"
#include "GenControls.h"

#include "ConfRoom.h"
#include "imsconf3.h"
#include "ProgressBar.h"
#include "VidView.h"

// Forward declarations
class CVideoWindow;
class CRoomListView;
class CProgressTrackbar;
class CAudioControl;
class CButton;
class CRosterParent;
class CCallingBar;

// The NetMeeting main ui window
class DECLSPEC_UUID("{00FF7C0C-D831-11d2-9CAE-00C04FB17782}")
CMainUI : public CToolbar,
	public IConferenceChangeHandler,
	public IScrollChange,
	public IVideoChange,
	public IButtonChange
{
public:
	// NMAPP depends on the order of these
	enum CreateViewMode
	{
		CreateFull = 0,
		CreateDataOnly,
		CreatePreviewOnly,
		CreateRemoteOnly,
		CreatePreviewNoPause,
		CreateRemoteNoPause,
		CreateTelephone,
	} ;

	// Methods:
	CMainUI();

	BOOL Create(
		HWND hwndParent,		// The parent window for this one
		CConfRoom *pConfRoom,	// The main conference room class for
								// implementing some features

		CreateViewMode eMode = CreateFull,
		BOOL bEmbedded = FALSE
		);

	// Leaving these for now in case I need them later
	VOID		UpdateButtons() {}
	VOID		ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
	VOID		SaveSettings();

	HRESULT STDMETHODCALLTYPE QueryInterface(REFGUID riid, LPVOID *ppv)
	{
		if (__uuidof(CMainUI) == riid)
		{
			*ppv = this;
			AddRef();
			return(S_OK);
		}
		return(CToolbar::QueryInterface(riid, ppv));
	}

	ULONG STDMETHODCALLTYPE AddRef()
	{ return(CToolbar::AddRef()); }
	ULONG STDMETHODCALLTYPE Release()
	{ return(CToolbar::Release()); }

	// IGenWindow stuff
	virtual HBRUSH GetBackgroundBrush();
	virtual HPALETTE GetPalette();

	// IConferenceChangeHandler stuff
	virtual void OnCallStarted();
	virtual void OnCallEnded();

	virtual void OnAudioLevelChange(BOOL fSpeaker, DWORD dwVolume);
	virtual void OnAudioMuteChange(BOOL fSpeaker, BOOL fMute);

	virtual void OnChangeParticipant(CParticipant *pPart, NM_MEMBER_NOTIFY uNotify);
	virtual void OnChangePermissions();

	virtual void OnVideoChannelChanged(NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);

	virtual void StateChange(CVideoWindow *pVideo, NM_VIDEO_STATE uState);

	// Change to/from compact view
	void SetCompact(
		BOOL bCompact	// TRUE if going to compact view
		);
	// Returns TRUE if we are currently in compact view
	BOOL IsCompact() { return(m_eViewMode == ViewCompact); }

	// Change to/from data-only view
	void SetDataOnly(
		BOOL bDataOnly	// TRUE if going to data-only view
		);
	// Returns TRUE if we are currently in compact view
	BOOL IsDataOnly() { return(m_eViewMode == ViewDataOnly); }

	// Change to/from dialing view
	void SetDialing(
		BOOL bDialing	// TRUE if going to dialing view
		);
	// Returns TRUE if we are currently in dialing view
	BOOL IsDialing() { return(m_bDialing != FALSE); }
	// Returns TRUE if you can change dialing mode
	BOOL IsDialingAllowed() { return(m_eViewMode != ViewDataOnly); }

	// Change to/from Picture-in-picture view
	void SetPicInPic(
		BOOL bPicInPic	// TRUE if going to Picture-in-picture view
		);
	// Returns TRUE if we are currently in Picture-in-picture view
	BOOL IsPicInPic() { return(m_bPicInPic != FALSE); }
	// Returns TRUE if you can change Picture-in-picture mode
	BOOL IsPicInPicAllowed();

	// Change to/from compact view
	void SetAudioTuning(
		BOOL bTuning	// TRUE if going to audio tuning view
		);
	// Returns TRUE if we are currently in audio tuning view
	BOOL IsAudioTuning() { return(m_bAudioTuning != FALSE); }

	// Accessor for the local video window
	CVideoWindow* GetLocalVideo() { return(m_pLocalVideo); }
	// Accessor for the remote video window
	CVideoWindow* GetRemoteVideo() { return(m_pRemoteVideo); }
	// Get the roster window
	CRoomListView *GetRoster() const;

	// Init menu items
	void OnInitMenu(HMENU hMenu);
	// Public function for sending commands to this window
	void OnCommand(int id) { OnCommand(GetWindow(), id, NULL, 0); }

	// IScrollChange
	virtual void OnScroll(CProgressTrackbar *pTrackbar, UINT code, int pos);

	// IButtonChange
	virtual void OnClick(CButton *pButton);

	BOOL OnQueryEndSession();
	void OnClose();

	// Get the ConfRoom for this object
	CConfRoom *GetConfRoom() { return(m_pConfRoom); }

	static BOOL NewVideoWindow(CConfRoom *pConfRoom);
	static void CleanUpVideoWindow();

protected:
	virtual ~CMainUI();

	virtual LRESULT ProcessMessage(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

private:
	enum TempViewMode
	{
		ViewNormal = 0,
		ViewCompact,
		ViewDataOnly,
	} ;

	static CFrame *s_pVideoFrame;

	// Implements some features
	CConfRoom	*m_pConfRoom;
	// The background brush
	HBRUSH m_hbBack;
	// Local video window
	CVideoWindow *m_pLocalVideo;
	// Remote video window
	CVideoWindow *m_pRemoteVideo;
	// Audio output (microphone) level
	CProgressTrackbar * m_pAudioMic;
	// Audio input (speaker) level
	CProgressTrackbar * m_pAudioSpeaker;
	// The roster window
	CRosterParent *m_pRoster;
	// The roster window
	CCallingBar *m_pCalling;
	// The accelerator table for this window
	CTranslateAccelTable *m_pAccel;

	// The current view mode
	TempViewMode m_eViewMode : 4;
	// Whether we are currently in dialing mode
	BOOL m_bDialing : 1;
	// Whether we are currently in audio tuning mode
	BOOL m_bAudioTuning : 1;
	// Whether we are previewing the local video
	BOOL m_bPreviewing : 1;
	// Whether we are showing the PiP window
	BOOL m_bPicInPic : 1;
	// Whether we are currently showing the AV toolbar
	BOOL m_bShowAVTB : 1;
	// Whether anybody changed the view state
	BOOL m_bStateChanged : 1;

	// Creates the calling toolbar
	void CreateDialTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the "band" with the video window and "data" buttons
	void CreateVideoAndAppsTB(
		CGenWindow *pParent,	// The parent window
		CreateViewMode eMode,			// The view mode
		BOOL bEmbedded
		);
	// Creates the A/V toolbar
	void CreateAVTB(
		CGenWindow *pParent,	// The parent window
		CreateViewMode eMode			// The view mode
		);
	// Creates the answering toolbar
	void CreateCallsTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the "data" toolbar
	void CreateAppsTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the video and showAV button
	void CreateVideoAndShowAVTB(
		CGenWindow *pParent	// The parent window
		);
	// Creates the dialing window
	void CreateDialingWindow(
		CGenWindow *pParent	// The parent window
		);
	// Creates the audio-tuning window
	void CreateAudioTuningWindow(
		CGenWindow *pParent	// The parent window
		);

	void CreateRosterArea(
		CGenWindow *pParent,	// The parent window
		CreateViewMode eMode	// The view mode
		);

	// Update the visible state of all the windows
	void UpdateViewState();

public:
	// Change to/from compact view
	void SetShowAVTB(
		BOOL bShow	// TRUE if showing the AV toolbar
		);

	// Returns TRUE if we are currently showing the AV toolbar in compact mode
	BOOL IsShowAVTB() { return(m_bShowAVTB != FALSE); }

	BOOL IsStateChanged() { return(m_bStateChanged != FALSE); }

private:
	// Get the associated audio control object
	CAudioControl *GetAudioControl();

	// Handles some commands and forwards the rest to the parent
	void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
	// Timer message for audio levels
	void OnTimer(HWND hwnd, UINT id);
	// Unadvise the IConferenceChangeHandler
	void OnDestroy(HWND hwnd);
	// Roster context menu
	void OnContextMenu(HWND hwnd, HWND hwndContext, UINT xPos, UINT yPos);

	// Toggle the mic/speaker mute mode
	void ToggleMute(BOOL bSpeaker);
	// Update the control state to reflect the mute state
	void UpdateMuteState(BOOL bSpeaker, CButton *pButton);
	// Update the state of the Play/Pause button
	BOOL GetPlayPauseState();
	// Update the state of the Play/Pause button
	void UpdatePlayPauseState();
	// Toggle the pause state of all I/O devices
	void TogglePlayPause();
	// Change the audio level by the given percent (up or down)
	void BumpAudio(BOOL bSpeaker, int pct);
	// Set a property on the audio channel
	void SetAudioProperty(BOOL bSpeaker, NM_AUDPROP uID, ULONG uValue);

	// Get the video HWND
	HWND GetVideoWindow(BOOL bLocal);
	// Returns TRUE if you can preview
	BOOL CanPreview();
	// Are we currently in preview mode?
	BOOL IsPreviewing() { return((m_bPreviewing || NULL == GetVideoWindow(FALSE)) && CanPreview()); }
};

// Private structure for defining a button
struct Buttons
{
	int idbStates;		// Bitmap ID for the states
	UINT nInputStates;	// Number of input states in the bitmap
	UINT nCustomStates;	// Number of custom states in the bitmap
	int idCommand;		// Command ID for WM_COMMAND messages
	UINT idTooltip;		// String ID for the tooltip
} ;

// Helper function for adding a bunch of buttons to a parent window
void AddButtons(
	CGenWindow *pParent,			// The parent window
	const Buttons buttons[],		// Array of structures describing the buttons
	int nButtons,					// Number of buttons to create
	BOOL bTranslateColors = TRUE,	// Use system background colors
	CGenWindow *pCreated[] = NULL,	// Created CGenWindow's will be put here
	IButtonChange *pNotify=NULL		// Notification of clicks
	);

#endif // _RTOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\sdialdlg.cpp ===
// File: sdialdlg.cpp
//
// Speed Dials (Friends)

#include "precomp.h"
#include "resource.h"
#include "sdialdlg.h"
#include "call.h"
#include "cmd.h"
#include "ConfUtil.h"
#include "help_ids.h"

extern BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwCallFlags = CRPCF_DEFAULT,
			LPCTSTR pcszRemoteConfName = NULL, LPCTSTR pcszPassword = NULL,
			LPCTSTR pcszPathPrefix = NULL);


static const DWORD _rgHelpIdsSpeedDial[] = {
	IDC_STATIC_SPEED_DIAL_INSTRUCTIONS, IDH_STATIC_SPEED_DIAL_INSTRUCTIONS,
	IDC_CSD_SD_INFO_GROUP,				IDH_CSD_SD_INFO_GROUP,
	IDC_STATIC_ADDRESS, 				IDH_CSD_ADDRESS_EDIT,
	IDC_CSD_ADDRESS_EDIT,				IDH_CSD_ADDRESS_EDIT,
	IDC_STATIC_CALLUSING,				IDH_CSD_CALL_USING_COMBO,
	IDC_CSD_CALL_USING_COMBO,			IDH_CSD_CALL_USING_COMBO,
	IDC_CSD_CREATE_GROUPBOX,			IDH_CSD_CREATE_GROUPBOX,
	IDC_CSD_SPEEDDIAL_LIST_RADIO,		IDH_CSD_SPEEDDIAL_LIST_RADIO,
	IDC_CSD_SAVE_DESKTOP_RADIO, 		IDH_CSD_SAVE_DESKTOP_RADIO,
	0, 0   // terminator
};

CSpeedDialDlg::CSpeedDialDlg(HWND hwndParent, NM_ADDR_TYPE addrType) :
	m_hwndParent	(hwndParent),
	m_pszAddress	(NULL),
	m_addrType      (addrType),
	m_hwnd			(NULL)
{
	DBGENTRY(CSpeedDialDlg::CSpeedDialDlg);
}

CSpeedDialDlg::~CSpeedDialDlg()
{
	DBGENTRY(CSpeedDialDlg::~CSpeedDialDlg);

	// Free all strings
	delete m_pszAddress;
}

/****************************************************************************
*
*    CLASS:    CSpeedDialDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CSpeedDialDlg::DoModal(LPCTSTR pcszAddress)
{
	DBGENTRY(CSpeedDialDlg::DoModal);

	if (NULL != pcszAddress)
	{
		ASSERT(NULL == m_pszAddress);
		m_pszAddress = PszAlloc(pcszAddress);
	}

	INT_PTR nRet = DialogBoxParam(	::GetInstanceHandle(),
								MAKEINTRESOURCE(IDD_CREATE_SPEED_DIAL),
								m_hwndParent,
								CSpeedDialDlg::SpeedDialDlgProc,
								(LPARAM) this);

	DebugExitINT_PTR(CSpeedDialDlg::DoModal, nRet);
	return nRet;
}

/****************************************************************************
*
*    CLASS:    CSpeedDialDlg
*
*    MEMBER:   SpeedDialDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CSpeedDialDlg::SpeedDialDlgProc(	HWND hDlg,
												UINT uMsg,
												WPARAM wParam,
												LPARAM lParam)
{
	BOOL bMsgHandled = FALSE;
	ASSERT(IS_VALID_HANDLE(hDlg, WND));

	switch (uMsg)
	{
		case WM_INITDIALOG:
		{
			if (NULL != lParam)
			{
				((CSpeedDialDlg*) lParam)->m_hwnd = hDlg;
				::SetWindowLongPtr(hDlg, DWLP_USER, lParam);

				bMsgHandled = ((CSpeedDialDlg*) lParam)->OnInitDialog();
			}
			break;
		}

		default:
		{
			CSpeedDialDlg* psdd = (CSpeedDialDlg*) ::GetWindowLongPtr(hDlg,
																 DWLP_USER);

			if (NULL != psdd)
			{
				bMsgHandled = psdd->ProcessMessage(uMsg, wParam, lParam);
			}
		}
	}

	return bMsgHandled;
}


BOOL CSpeedDialDlg::AddAddressType(NM_ADDR_TYPE addrType, LPCTSTR lpcszDispName)
{
	int index = (int)::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
				CB_ADDSTRING, 0, (LPARAM) lpcszDispName);

	if (CB_ERR == index)
		return FALSE;

	// Set the item data:
	::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
				CB_SETITEMDATA, index,addrType);

	if (addrType == m_addrType)
	{
		// Select the transport:
		::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
								CB_SETCURSEL, index, 0);
	}
	return TRUE;
}

BOOL CSpeedDialDlg::AddAddressType(NM_ADDR_TYPE addrType, UINT uStringID)
{
	TCHAR sz[MAX_PATH];

	if (!FLoadString(uStringID, sz, CCHMAX(sz)))
		return FALSE;

	return AddAddressType(addrType, sz);
}


BOOL CSpeedDialDlg::OnInitDialog(void)
{
	::CheckDlgButton(m_hwnd, IDC_CSD_SPEEDDIAL_LIST_RADIO, BST_CHECKED);

	// Fill in the "Call Using" list:
	AddAddressType(NM_ADDR_IP, IDS_ACD_CT_IP);
	AddAddressType(NM_ADDR_ULS, IDS_ACD_CT_ILS);
	if (FH323GatewayEnabled())
	{
		AddAddressType(NM_ADDR_H323_GATEWAY, IDS_GATEWAY_DISPLAY_NAME);
	}

	int iSelected = (int)::SendDlgItemMessage(m_hwnd,
					IDC_CSD_CALL_USING_COMBO, CB_GETCURSEL, 0, 0);
	if (CB_ERR == iSelected)
	{
		// The transport that we wanted to select was not available, so
		// we will select the first one that we added to the list:
		::SendDlgItemMessage(m_hwnd,
					IDC_CSD_CALL_USING_COMBO, CB_SETCURSEL, 0, 0);
		m_addrType = (NM_ADDR_TYPE) ::SendDlgItemMessage(m_hwnd,
					IDC_CSD_CALL_USING_COMBO, CB_GETITEMDATA, 0, 0);
	}

	if (!FEmptySz(m_pszAddress))
	{
		::SetDlgItemText(m_hwnd, IDC_CSD_ADDRESS_EDIT, m_pszAddress);
	}
	else if (NM_ADDR_ULS == m_addrType)
	{
		RegEntry re(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
		::SetDlgItemText(m_hwnd, IDC_CSD_ADDRESS_EDIT,
							re.GetString(REGVAL_ULS_RES_NAME));
	}

	Edit_LimitText(GetDlgItem(m_hwnd, IDC_CSD_ADDRESS_EDIT), CCHMAXSZ_ADDRESS - 1);

	RefreshOkButton();

	return TRUE;
}

/****************************************************************************
*
*    CLASS:    CSpeedDialDlg
*
*    MEMBER:   ProcessMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CSpeedDialDlg::ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	BOOL bRet = FALSE;
	ASSERT(m_hwnd);
	
	switch (uMsg)
	{
		case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
				case IDOK:
				{
					bRet = OnOk();
					break;
				}

				case IDCANCEL:
				{
					::EndDialog(m_hwnd, LOWORD(wParam));
					bRet = TRUE;
					break;
				}

				case IDC_CSD_ADDRESS_EDIT:
				{
					if (EN_CHANGE == HIWORD(wParam))
					{
						RefreshOkButton();
					}
					break;
				}
			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, _rgHelpIdsSpeedDial);
			break;

		case WM_HELP:
			DoHelp(lParam, _rgHelpIdsSpeedDial);
			break;
		}
	}

	return bRet;
}

NM_ADDR_TYPE CSpeedDialDlg::GetCurAddrType(void)
{
	int iIndex = (int)::SendDlgItemMessage(m_hwnd, IDC_CSD_CALL_USING_COMBO,
										CB_GETCURSEL, 0, 0);

	if (CB_ERR == iIndex)
		return NM_ADDR_UNKNOWN;
		

	return (NM_ADDR_TYPE) ::SendDlgItemMessage(m_hwnd,
				IDC_CSD_CALL_USING_COMBO, CB_GETITEMDATA, iIndex, 0);
}

BOOL CSpeedDialDlg::OnOk(void)
{
	m_addrType = GetCurAddrType();
	BOOL fSaveDesktop = (BST_CHECKED == ::IsDlgButtonChecked(m_hwnd,
												IDC_CSD_SAVE_DESKTOP_RADIO));

	TCHAR szBuf[MAX_PATH];
	if (0 != ::GetDlgItemText(	m_hwnd,
								IDC_CSD_ADDRESS_EDIT,
								szBuf,
								ARRAY_ELEMENTS(szBuf)))
	{
		// Copy address into the address:
		delete m_pszAddress;
		m_pszAddress = PszAlloc(szBuf);
	}

	::EndDialog(m_hwnd, IDOK);

	TRACE_OUT(("Creating Speed Dial:"));
	TRACE_OUT(("\tTransport ID: %d", GetAddrType()));
	TRACE_OUT(("\tAddress:      \"%s\"", GetAddress()));
	TRACE_OUT(("\tSaveDesktop:  %s", ::GetBOOLString(fSaveDesktop)));

	NM_ADDR_TYPE addrType = GetAddrType();
	DWORD crpcf = (NM_ADDR_H323_GATEWAY == addrType) ?
		(CRPCF_AUDIO | CRPCF_VIDEO) : CRPCF_DEFAULT;

	if (fSaveDesktop)
	{
		// Save on desktop
		BOOL fSavedOk = FALSE;
		
		LPITEMIDLIST pidl = NULL;
		TCHAR szPathPrefix[MAX_PATH];
		szPathPrefix[0] = _T('\0');

		if (NMGetSpecialFolderPath(NULL, szPathPrefix, CSIDL_DESKTOP, TRUE))
		{
			fSavedOk = ::FCreateSpeedDial(
							GetAddress(),	// pcszName
							GetAddress(),	// pcszAddress
							addrType,		// addrType
							crpcf,			// dwCallFlags
							NULL,			// pcszRemoteConfName
							NULL,			// pcszPassword
							szPathPrefix);	// pcszPathPrefix
		}
		else
		{
			ERROR_OUT(("NMGetSpecialFolderPath failed!"));
		}

		::ConfMsgBox(	m_hwnd,	(LPCTSTR) (fSavedOk ?
							(UINT_PTR)IDS_SPEED_DIAL_SAVED_ON_DESKTOP :
							(UINT_PTR)IDS_SPEED_DIAL_SAVE_ERROR));
	}
	else
	{
		::FCreateSpeedDial(
				GetAddress(),	// pcszName
				GetAddress(),	// pcszAddress
				addrType,		// addrType
				crpcf,			// dwCallFlags
				NULL,			// pcszRemoteConfName
				NULL,			// pcszPassword
				NULL);	// pcszPathPrefix
	}

	return TRUE;
}

VOID CSpeedDialDlg::RefreshOkButton()
{
	::EnableWindow(	GetDlgItem(m_hwnd, IDOK),
	 				0 != ::GetWindowTextLength(::GetDlgItem(m_hwnd, IDC_CSD_ADDRESS_EDIT)));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\sdialdlg.h ===
// File: sdialdlg.h

#ifndef _SDIALDLG_H_
#define _SDIALDLG_H_

#include "SDKInternal.h"

class CSpeedDialDlg
{
protected:
	HWND		m_hwndParent;
	HWND		m_hwnd;

	LPTSTR		m_pszAddress;
	LPTSTR		m_pszConfName;
	NM_ADDR_TYPE m_addrType;

	VOID		RefreshOkButton();
	BOOL		ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
	NM_ADDR_TYPE GetCurAddrType(void);
	BOOL		AddAddressType(NM_ADDR_TYPE addrType, LPCTSTR lpcszDispName);
	BOOL		AddAddressType(NM_ADDR_TYPE addrType, UINT uStringID);

	// Handlers:
	BOOL		OnTransportChanged();
	BOOL		OnOk();

public:
	// Properties:
	LPTSTR       GetAddress()       {return m_pszAddress;}
	NM_ADDR_TYPE GetAddrType()      {return m_addrType;}
	
	// Methods:
				CSpeedDialDlg(HWND hwndParent, NM_ADDR_TYPE addrType);
				~CSpeedDialDlg();
	INT_PTR	DoModal(LPCTSTR pcszAddress);

	static INT_PTR CALLBACK SpeedDialDlgProc(	HWND hDlg,
											UINT uMsg,
											WPARAM wParam,
											LPARAM lParam);

	// Handlers:
	BOOL		OnInitDialog();
};

#endif // _SDIALDLG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\setupdd.h ===
#ifndef _SETUPDD_H_
#define _SETUPDD_H_

/*
 * SETUPDD.H
 *
 * Global definitions for clients of the code to install the NM display
 * driver for Windows NT.
 *		
 * Author:
 *		dannygl, 05 Apr 97
 */

extern BOOL CanInstallNTDisplayDriver(void);
extern void OnEnableAppSharing(HWND hWnd);

#endif // _SETUPDD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\sdkwindow.cpp ===
#include "precomp.h"

// Net Meeting SDK includes
#include "NmManager.h"
#include "NmConference.h"
#include "NmCall.h"
#include "NmSharableApp.h"
#include "NmChannelAppShare.h"
#include "SDKWindow.h"



CSDKWindow* CSDKWindow::ms_pSDKWnd = NULL;
int CSDKWindow::ms_NumUnlocks = 0;



/////////////////////////////////////////////////////////////////////////////////
// Construction / destruction / initialization
/////////////////////////////////////////////////////////////////////////////////


//static
HRESULT CSDKWindow::InitSDK()
{
	DBGENTRY(CSDKWindow::InitSDK);
	HRESULT hr = S_OK;

	ASSERT(NULL == ms_pSDKWnd);

	ms_pSDKWnd = new CSDKWindow();
	if(ms_pSDKWnd)
	{
			// Create the window	
		RECT rc;
		ms_pSDKWnd->Create(NULL, rc, NULL, WS_POPUP);
		if(!ms_pSDKWnd->IsWindow())
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
		}
	}
	else
	{
		hr = E_OUTOFMEMORY;
	}

	DBGEXIT_HR(CSDKWindow::InitSDK,hr);
	return hr;

}
//static
void CSDKWindow::CleanupSDK()
{
	if(ms_pSDKWnd && ms_pSDKWnd->IsWindow())
	{
		ms_pSDKWnd->DestroyWindow();
	}

	delete ms_pSDKWnd;
}

//static
HRESULT CSDKWindow::PostDelayModuleUnlock()
{
	if(ms_pSDKWnd)
	{
		if(!ms_pSDKWnd->SetTimer(DELAY_UNLOAD_TIMER, DELAY_UNLOAD_INTERVAL))
		{
			return HRESULT_FROM_WIN32(GetLastError());			
		}

		++ms_NumUnlocks;
		return S_OK;
	}
	
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////////
// INmManagerNotify Posting functions
/////////////////////////////////////////////////////////////////////////////////

//static
HRESULT CSDKWindow::PostConferenceCreated(CNmManagerObj* pMgr, INmConference* pInternalNmConference)
{
	DBGENTRY(CSDKWindow::PostConferenceCreated);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pMgr);

	pMgr->AddRef();

	if(pInternalNmConference)
	{
		pInternalNmConference->AddRef();
	}

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_CREATED, reinterpret_cast<WPARAM>(pMgr), reinterpret_cast<LPARAM>(pInternalNmConference));

	DBGEXIT_HR(CSDKWindow::PostConferenceCreated,hr);
	return hr;
}



//static
HRESULT CSDKWindow::PostCallCreated(CNmManagerObj* pMgr, INmCall* pInternalNmCall)
{
	DBGENTRY(CSDKWindow::PostCallCreated);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pMgr);

	pMgr->AddRef();

	if(pInternalNmCall)
	{
		pInternalNmCall->AddRef();
	}

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CALL_CREATED, reinterpret_cast<WPARAM>(pMgr), reinterpret_cast<LPARAM>(pInternalNmCall));

	DBGEXIT_HR(CSDKWindow::PostCallCreated,hr);
	return hr;
}


//static
HRESULT CSDKWindow::PostManagerNmUI(CNmManagerObj* pMgr, CONFN uNotify)
{
	DBGENTRY(CSDKWindow::PostManagerNmUI);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pMgr);

	pMgr->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_MANAGER_NMUI, reinterpret_cast<WPARAM>(pMgr), uNotify);

	DBGEXIT_HR(CSDKWindow::PostManagerNmUI,hr);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////////
// INmConferenceNotify Posting functions
/////////////////////////////////////////////////////////////////////////////////


HRESULT CSDKWindow::PostConferenceNmUI(CNmConferenceObj* pConf, CONFN uNotify)
{
	DBGENTRY(CSDKWindow::PostConferenceNmUI);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pConf);

	pConf->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_NMUI, reinterpret_cast<WPARAM>(pConf), uNotify);

	DBGEXIT_HR(CSDKWindow::PostConferenceNmUI,hr);
	return hr;
}


//static
HRESULT CSDKWindow::PostConferenceStateChanged(CNmConferenceObj* pConference, NM_CONFERENCE_STATE uState)
{
	DBGENTRY(CSDKWindow::PostConferenceStateChanged);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pConference);

	pConference->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_STATE_CHANGED, reinterpret_cast<WPARAM>(pConference), uState);


	DBGEXIT_HR(CSDKWindow::PostConferenceStateChanged,hr);
	return hr;
}


//static
HRESULT CSDKWindow::PostConferenceMemberChanged(CNmConferenceObj* pConf, NM_MEMBER_NOTIFY uNotify, INmMember *pMember)
{
	DBGENTRY(CSDKWindow::PostConferenceMemberChanged);
	HRESULT hr = S_OK;

	ASSERT(ms_pSDKWnd);
	ASSERT(pConf);

	pConf->AddRef();

	if(pMember)
	{
		pMember->AddRef();
	}

	ConferenceMemberChanged *pParams = new ConferenceMemberChanged;
	pParams->uNotify = uNotify;
	pParams->pMember = pMember;

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_MEMBER_CHANGED, reinterpret_cast<WPARAM>(pConf), reinterpret_cast<LPARAM>(pParams));

	DBGEXIT_HR(CSDKWindow::PostConferenceMemberChanged,hr);
	return hr;
}



//static
HRESULT CSDKWindow::PostConferenceChannelChanged(CNmConferenceObj* pConf, NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel)
{
	DBGENTRY(CSDKWindow::PostConferenceChannelChanged);
	HRESULT hr = S_OK;
	
	ASSERT(ms_pSDKWnd);
	ASSERT(pConf);

	pConf->AddRef();

	if(pChannel)
	{
		pChannel->AddRef();
	}

	ConferenceChannelChanged *pParams = new ConferenceChannelChanged;
	pParams->uNotify = uNotify;
	pParams->pChannel = pChannel;

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CONFERENCE_CHANNEL_CHANGED, reinterpret_cast<WPARAM>(pConf), reinterpret_cast<LPARAM>(pParams));

	DBGEXIT_HR(CSDKWindow::PostConferenceChannelChanged,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostStateChanged(CNmChannelAppShareObj* pAppShareChan, NM_SHAPP_STATE uNotify, INmSharableApp *pApp)
{
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pAppShareChan);
	ASSERT(pApp);

	pAppShareChan->AddRef();
	pApp->AddRef();

	StateChanged* pParams = new StateChanged;
	pParams->uNotify = uNotify;
	pParams->pApp = pApp;

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_STATE_CHANGED, reinterpret_cast<WPARAM>(pAppShareChan), reinterpret_cast<LPARAM>(pParams));

	return hr;
}

/////////////////////////////////////////////////////////////////////////////////
// INmCallNotify Posting functions
/////////////////////////////////////////////////////////////////////////////////



//static
HRESULT CSDKWindow::PostCallStateChanged(CNmCallObj* pCall, NM_CALL_STATE uState)
{
	DBGENTRY(CSDKWindow::PostCallStateChanged);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);

	pCall->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_CALL_STATE_CHANGED, reinterpret_cast<WPARAM>(pCall), uState);


	DBGEXIT_HR(CSDKWindow::PostCallStateChanged,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostCallNmUi(CNmCallObj* pCall, CONFN uNotify)
{
	DBGENTRY(CSDKWindow::PostCallNmUi);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);
	
	pCall->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_NMUI, reinterpret_cast<WPARAM>(pCall), uNotify);

	DBGEXIT_HR(CSDKWindow::PostCallNmUi,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostFailed(CNmCallObj* pCall, ULONG uError)
{
	DBGENTRY(CSDKWindow::PostFailed);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);

	pCall->AddRef();

	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_FAILED, reinterpret_cast<WPARAM>(pCall), uError);

	DBGEXIT_HR(CSDKWindow::PostFailed,hr);
	return hr;
}

//static
HRESULT CSDKWindow::PostAccepted(CNmCallObj* pCall, INmConference* pConference)
{
	DBGENTRY(CSDKWindow::PostAccepted);
	HRESULT hr = S_OK;
	ASSERT(ms_pSDKWnd);
	ASSERT(pCall);

	pCall->AddRef();
	if(pConference)
	{
		pConference->AddRef();
	}	
	
	ms_pSDKWnd->PostMessage(WM_APP_NOTIFY_ACCEPTED, reinterpret_cast<WPARAM>(pCall), reinterpret_cast<LPARAM>(pConference));

	DBGEXIT_HR(CSDKWindow::PostAccepted,hr);
	return hr;
}



/////////////////////////////////////////////////////////////////////////////////
// INmManagerNotify message handling functions
/////////////////////////////////////////////////////////////////////////////////

LRESULT CSDKWindow::_OnMsgConferenceCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceCreated);

	CNmManagerObj* pMgr = reinterpret_cast<CNmManagerObj*>(wParam);
	INmConference* pInternalConf = reinterpret_cast<INmConference*>(lParam);

	pMgr->Fire_ConferenceCreated(pInternalConf);
	pMgr->Release();
	if(pInternalConf)
	{
		pInternalConf->Release();
	}

	DBGEXIT(CSDKWindow::_OnMsgConferenceCreated);
	return 0;
}



LRESULT CSDKWindow::_OnMsgManagerNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgManagerNmUI);

	CNmManagerObj* pMgr = reinterpret_cast<CNmManagerObj*>(wParam);
	CONFN uNotify = static_cast<CONFN>(lParam);

	pMgr->Fire_NmUI(uNotify);
	pMgr->Release();

	DBGEXIT(CSDKWindow::_OnMsgManagerNmUI);
	return 0;
}


LRESULT CSDKWindow::_OnMsgCallCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgCallCreated);

	CNmManagerObj* pMgr = reinterpret_cast<CNmManagerObj*>(wParam);
	INmCall* pInternalCall = reinterpret_cast<INmCall*>(lParam);

	pMgr->Fire_CallCreated(pInternalCall);
	pMgr->Release();
	if(pInternalCall)
	{
		pInternalCall->Release();
	}

	DBGEXIT(CSDKWindow::_OnMsgCallCreated);
	return 0;
}


/////////////////////////////////////////////////////////////////////////////////
// INmConferenceNotify message handling functions
/////////////////////////////////////////////////////////////////////////////////

LRESULT CSDKWindow::_OnMsgConferenceNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceNmUI);

	CNmConferenceObj* pConf = reinterpret_cast<CNmConferenceObj*>(wParam);
	CONFN uNotify = static_cast<CONFN>(lParam);

	pConf->Fire_NmUI(uNotify);
	pConf->Release();

	DBGEXIT(CSDKWindow::_OnMsgConferenceNmUI);
	return 0;
}


LRESULT CSDKWindow::_OnMsgConferenceStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceStateChanged);
	CNmConferenceObj* pConference = reinterpret_cast<CNmConferenceObj*>(wParam);
	NM_CONFERENCE_STATE uState = static_cast<NM_CONFERENCE_STATE>(lParam);

	pConference->Fire_StateChanged(uState);
	pConference->Release();
	
	DBGEXIT(CSDKWindow::_OnMsgConferenceStateChanged);
	return 0;
}

LRESULT CSDKWindow::_OnMsgConferenceMemberChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceMemberChanged);

	CNmConferenceObj* pConf = reinterpret_cast<CNmConferenceObj*>(wParam);
	ConferenceMemberChanged* pParams = reinterpret_cast<ConferenceMemberChanged*>(lParam);

	pConf->Fire_MemberChanged(pParams->uNotify, pParams->pMember);

	pConf->Release();
	if(pParams->pMember)
	{
		pParams->pMember->Release();
	}
	delete pParams;

	DBGEXIT(CSDKWindow::_OnMsgConferenceMemberChanged);
	return 0;
}


LRESULT CSDKWindow::_OnMsgConferenceChannelChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgConferenceChannelChanged);

	CNmConferenceObj* pConf = reinterpret_cast<CNmConferenceObj*>(wParam);
	ConferenceChannelChanged* pParams = reinterpret_cast<ConferenceChannelChanged*>(lParam);

	pConf->Fire_ChannelChanged(pParams->uNotify, pParams->pChannel);

	pConf->Release();
	if(pParams->pChannel)
	{
		pParams->pChannel->Release();
	}
	delete pParams;

	DBGEXIT(CSDKWindow::_OnMsgConferenceChannelChanged);
	return 0;
}

LRESULT CSDKWindow::_OnStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandlede)
{
	CNmChannelAppShareObj* pAppShareChan = reinterpret_cast<CNmChannelAppShareObj*>(wParam);
	StateChanged* pParams = reinterpret_cast<StateChanged*>(lParam);


	pAppShareChan->Fire_StateChanged(pParams->uNotify, pParams->pApp);

	pAppShareChan->Release();
	pParams->pApp->Release();

	delete pParams;

	return 0;
}


/////////////////////////////////////////////////////////////////////////////////
// INmCallNotify message handling functions
/////////////////////////////////////////////////////////////////////////////////


LRESULT CSDKWindow::_OnMsgCallStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgCallStateChanged);
	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	NM_CALL_STATE uState = static_cast<NM_CALL_STATE>(lParam);

	pCall->Fire_StateChanged(uState);
	pCall->Release();
	
	DBGEXIT(CSDKWindow::_OnMsgCallStateChanged);
	return 0;
}

LRESULT CSDKWindow::_OnMsgCallNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnCallMsgNmUI);

	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	CONFN uNotify = static_cast<CONFN>(lParam);

	pCall->Fire_NmUI(uNotify);
	pCall->Release();

	DBGEXIT(CSDKWindow::_OnMsgCallNmUI);
	return 0;
}

LRESULT CSDKWindow::_OnMsgFailed(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgFailed);

	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	ULONG uError = (ULONG)lParam;
	
	pCall->Fire_Failed(uError);
	pCall->Release();

	DBGEXIT(CSDKWindow::_OnMsgFailed);
	return 0;
}

LRESULT CSDKWindow::_OnMsgAccepted(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	DBGENTRY(CSDKWindow::_OnMsgAccepted);

	CNmCallObj* pCall = reinterpret_cast<CNmCallObj*>(wParam);
	INmConference* pConf = reinterpret_cast<INmConference*>(lParam);

	pCall->Fire_Accepted(pConf);
	pCall->Release();
	if(pConf)
	{
		pConf->Release();
	}

	DBGEXIT(CSDKWindow::_OnMsgAccepted);
	return 0;
}

LRESULT CSDKWindow::_OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

	if(DELAY_UNLOAD_TIMER == wParam)
	{
		if(ms_NumUnlocks)
		{
			--ms_NumUnlocks;
			_Module.Unlock();	
		}	
		
		if(!ms_NumUnlocks)
		{
			KillTimer(DELAY_UNLOAD_TIMER);
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\sdkwindow.h ===
#ifndef __SDKWindow_h__
#define __SDKWindow_h__

class CNmChannelAppShareObj;
class CNmCallObj;

class CSDKWindow : public CWindowImpl<CSDKWindow>
{

static CSDKWindow* ms_pSDKWnd;

private:


// Conference Notification Parameter structures
	struct ConferenceMemberChanged 
	{	
		NM_MEMBER_NOTIFY uNotify;
		INmMember *pMember;
	};

	struct ConferenceChannelChanged 
	{	
		NM_CHANNEL_NOTIFY uNotify;
		INmChannel *pChannel;
	};

	struct StateChanged
	{
		NM_SHAPP_STATE uNotify;
		INmSharableApp *pApp;
	};
	

	CONSTANT(DELAY_UNLOAD_TIMER = 123);
	CONSTANT(DELAY_UNLOAD_INTERVAL = 10000);

	static int ms_NumUnlocks;

	// This will prevent soemone creating us other than Init
	CSDKWindow() { ; }

public:

		// NmManagerNotify
	CONSTANT(WM_APP_NOTIFY_MANAGER_NMUI					= (WM_APP + 10));
	CONSTANT(WM_APP_NOTIFY_CALL_CREATED					= (WM_APP + 11));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_CREATED			= (WM_APP + 12));

		//NmConferenceNotify
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_NMUI				= (WM_APP + 20));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_STATE_CHANGED		= (WM_APP + 21));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_MEMBER_CHANGED	= (WM_APP + 22));
	CONSTANT(WM_APP_NOTIFY_CONFERENCE_CHANNEL_CHANGED	= (WM_APP + 23));

		// NmCallNotify
	CONSTANT(WM_APP_NOTIFY_NMUI					= (WM_APP + 31));
	CONSTANT(WM_APP_NOTIFY_CALL_STATE_CHANGED	= (WM_APP + 32));
	CONSTANT(WM_APP_NOTIFY_FAILED				= (WM_APP + 33));
	CONSTANT(WM_APP_NOTIFY_ACCEPTED				= (WM_APP + 34));

	CONSTANT(WM_APP_NOTIFY_STATE_CHANGED		= (WM_APP + 35));


DECLARE_WND_CLASS(NULL);

BEGIN_MSG_MAP(CSDKWindow)
		// Manager Notifications
	MESSAGE_HANDLER(WM_APP_NOTIFY_MANAGER_NMUI, _OnMsgManagerNmUI)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CALL_CREATED, _OnMsgCallCreated)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_CREATED, _OnMsgConferenceCreated)

		// Conference Notify
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_NMUI, _OnMsgConferenceNmUI)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_STATE_CHANGED, _OnMsgConferenceStateChanged)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_MEMBER_CHANGED, _OnMsgConferenceMemberChanged)
	MESSAGE_HANDLER(WM_APP_NOTIFY_CONFERENCE_CHANNEL_CHANGED, _OnMsgConferenceChannelChanged)

		// Call Notifications
	MESSAGE_HANDLER(WM_APP_NOTIFY_CALL_STATE_CHANGED, _OnMsgCallStateChanged)
	MESSAGE_HANDLER(WM_APP_NOTIFY_NMUI, _OnMsgCallNmUI)
	MESSAGE_HANDLER(WM_APP_NOTIFY_FAILED, _OnMsgFailed)
	MESSAGE_HANDLER(WM_APP_NOTIFY_ACCEPTED, _OnMsgAccepted)

	MESSAGE_HANDLER(WM_APP_NOTIFY_STATE_CHANGED, _OnStateChanged);

	MESSAGE_HANDLER(WM_TIMER, _OnTimer)
END_MSG_MAP();


public: 
	// Initialization
	static HRESULT InitSDK();
	static void CleanupSDK();

	static HRESULT PostDelayModuleUnlock();

	// Manager Notificyations
	static HRESULT PostManagerNmUI(CNmManagerObj* pMgr, CONFN uNotify);
	static HRESULT PostCallCreated(CNmManagerObj* pMgr, INmCall* pInternalNmCall);
	static HRESULT PostConferenceCreated(CNmManagerObj* pMgr, INmConference* pInternalNmConference);

	// Conference Notificyations
	static HRESULT PostConferenceNmUI(CNmConferenceObj* pConf, CONFN uNotify);
	static HRESULT PostConferenceStateChanged(CNmConferenceObj* pConf, NM_CONFERENCE_STATE uState);
	static HRESULT PostConferenceMemberChanged(CNmConferenceObj* pConf, NM_MEMBER_NOTIFY uNotify, INmMember *pMember);
	static HRESULT PostConferenceChannelChanged(CNmConferenceObj* pConf, NM_CHANNEL_NOTIFY uNotify, INmChannel *pChannel);

	// Call Notificyations
	static HRESULT PostCallNmUi(CNmCallObj* pCall, CONFN uNotify);
	static HRESULT PostCallStateChanged(CNmCallObj* pCall, NM_CALL_STATE uState);
	static HRESULT PostFailed(CNmCallObj* pCall, ULONG uError);
	static HRESULT PostAccepted(CNmCallObj* pCall, INmConference* pConference);

	static HRESULT PostStateChanged(CNmChannelAppShareObj* pAppShareChan, NM_SHAPP_STATE uNotify, INmSharableApp *pApp);

private: // Helpers 

	// Manager Mssages
	LRESULT _OnMsgManagerNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgCallCreated(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	// Conference message
	LRESULT _OnMsgConferenceNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceMemberChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgConferenceChannelChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

		// Call Messages
	LRESULT _OnMsgCallStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgCallNmUI(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgFailed(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT _OnMsgAccepted(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	
	LRESULT _OnStateChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	
	LRESULT _OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

};

#endif // __SDKWindow_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\setupdd.cpp ===
/*
 * SETUPDD.CPP
 *
 * The code to install the NM display driver for Windows NT.  This was
 * a standalone application launched by Setup that we are now importing
 * into NM itself.
 *		
 * Author:
 *		dannygl, 05 Apr 97
 */

#include "precomp.h"

#include "conf.h"
#include "confwnd.h"
#include "resource.h"
#include "setupdd.h"


// String to identify the DLL and function that we need to call to install
// the display driver on SP3. 
const TCHAR g_pcszDisplayCPLName[] = TEXT("DESK.CPL");
const CHAR g_pcszInstallDriverAPIName[] = "InstallGraphicsDriver";

const WCHAR g_pcwszDefaultModelName[] = L"Microsoft NetMeeting graphics driver";
const WCHAR g_pcwszDefaultINFName[] = L"MNMDD.INF";


// Maxmimum size of the model name string
const int NAME_BUFFER_SIZE = 128;

// Prototype for the function installed by the Display CPL
typedef DWORD (*PFNINSTALLGRAPHICSDRIVER)(
    HWND    hwnd,
    LPCWSTR pszSourceDirectory,
    LPCWSTR pszModel,
    LPCWSTR pszInf
    );


/* 
 * GetInstallDisplayDriverEntryPoint
 *
 * This function loads the DLL containing the display driver installation
 * code and retrieves the entry point for the installation function.  It
 * is used by the below functions as a utility function.
 *
 * It returns TRUE if it is able to load the library and get the entry point,
 * FALSE if either operation fails.  It is returns TRUE, it also returns the 
 * DLL module handle and the function address.
 */

BOOL
GetInstallDisplayDriverEntryPoint(
	HMODULE *phInstallDDDll,
	PFNINSTALLGRAPHICSDRIVER *ppfnInstallDDFunction)
{
	HMODULE hDll;
	PFNINSTALLGRAPHICSDRIVER pfn = NULL;

	ASSERT(NULL != phInstallDDDll
			&& NULL != ppfnInstallDDFunction);

	hDll = LoadLibrary(g_pcszDisplayCPLName);

	if (NULL != hDll)
	{
		pfn = (PFNINSTALLGRAPHICSDRIVER) 
				GetProcAddress(hDll,
								g_pcszInstallDriverAPIName);
	}

	// If the entry point exists, we pass it and the DLL handle back to
	// the caller.  Otherwise, we unload the DLL immediately.
	if (NULL != pfn)
	{
		*phInstallDDDll = hDll;
		*ppfnInstallDDFunction = pfn;

		return TRUE;
	}
	else
	{
		if (NULL != hDll)
		{
			FreeLibrary(hDll);
		}

		return FALSE;
	}
}

/* 
 * CanInstallNTDisplayDriver
 *
 * This function determines whether the entry point for installing the
 * NT display driver is availalble (i.e. NT 4.0 SP3 or later).
 */

BOOL
CanInstallNTDisplayDriver(void)
{
	static BOOL fComputed = FALSE;
	static BOOL fRet = FALSE;
	
	ASSERT(::IsWindowsNT());

	// We verify that the major version number is exactly 4 and either
	// the minor version number is greater than 0 or the service pack
	// number (which is stored in the high byte of the low word of the
	// CSD version) is 3 or greater.
	if (! fComputed)
	{
		LPOSVERSIONINFO lposvi = GetVersionInfo();

		if (4 == lposvi->dwMajorVersion)
		{
			if (0 == lposvi->dwMinorVersion)
			{
				RegEntry re(NT_WINDOWS_SYSTEM_INFO_KEY, HKEY_LOCAL_MACHINE, FALSE);

				DWORD dwCSDVersion = 
					re.GetNumber(REGVAL_NT_CSD_VERSION, 0);

				if (3 <= HIBYTE(LOWORD(dwCSDVersion)))
				{
					// This is NT 4.0, SP 3 or later
					fRet = TRUE;
				}
			}
			else
			{
				// We assume that any future version of Windows NT 4.x (x > 0)
				// will support this.
				fRet = TRUE;
			}
		}

		fComputed = TRUE;
	}
			
	ASSERT(fComputed);

	return fRet;
}

/* 
 * OnEnableAppSharing
 *
 * Invoked when the "Enable Application Sharing" menu item is selected.
 *
 * This function determines whether the entry point for installing the
 * NT display driver is available.  If so, it prompts the user to confirm
 * this operation, proceeds with the installation, and then prompts the 
 * user to restart the computer.
 *
 * If not, it presents a text dialog with information about how to get
 * the necessary NT Service Pack(s).
 */

void
OnEnableAppSharing(
	HWND hWnd)
{
	ASSERT(::IsWindowsNT());
	USES_CONVERSION;

	if (::CanInstallNTDisplayDriver())
	{
		// Confirm the installation with the user
		if (IDYES == ::ConfMsgBox(
							hWnd,
							(LPCTSTR) IDS_ENABLEAPPSHARING_INSTALL_CONFIRM,
							MB_YESNO | MB_ICONQUESTION))
		{
			BOOL fDriverInstallSucceeded = FALSE;
			
			HMODULE hDisplayCPL = NULL;
			PFNINSTALLGRAPHICSDRIVER pfnInstallGraphicsDriver;

			TCHAR pszSourcePath[MAX_PATH];
			LPWSTR pwszSourcePath = NULL;
			LPWSTR pwszSourcePathEnd;
			WCHAR pwszModelNameBuffer[NAME_BUFFER_SIZE];
			LPCWSTR pcwszModelName;
			WCHAR pwszINFNameBuffer[MAX_PATH];
			LPCWSTR pcwszINFName;

			// Get the entry point for display driver installation
			if (! ::GetInstallDisplayDriverEntryPoint(
						&hDisplayCPL,
						&pfnInstallGraphicsDriver))
			{
				ERROR_OUT(("GetInstallDisplayDriverEntryPoint() fails"));
				goto OEAS_AbortInstall;
			}

			// The driver files are located in the NM directory.
			if (! ::GetInstallDirectory(pszSourcePath))
			{
				ERROR_OUT(("GetInstallDirectory() fails"));
				goto OEAS_AbortInstall;
			}
			
			// Convert the install directory to Unicode, if necessary
			pwszSourcePath = T2W(pszSourcePath);

			if (NULL == pwszSourcePath)
			{
				ERROR_OUT(("AnsiToUnicode() fails"));
				goto OEAS_AbortInstall;
			}

			// Strip the trailing backslash that GetInstallDirectory appends
			pwszSourcePathEnd = pwszSourcePath + lstrlenW(pwszSourcePath);

			// Handle X:\, just to be safe
			if (pwszSourcePathEnd - pwszSourcePath > 3)
			{
				ASSERT(L'\\' == *(pwszSourcePathEnd - 1));

				*--pwszSourcePathEnd = L'\0';
			}

			// Read the model name string from the resource file
			if (0 < ::LoadStringW(GetInstanceHandle(), 
								IDS_NMDD_DISPLAYNAME, 
								pwszModelNameBuffer, 
								CCHMAX(pwszModelNameBuffer)))
			{
				pcwszModelName = pwszModelNameBuffer;
			}
			else
			{
				ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
				pcwszModelName = g_pcwszDefaultModelName;
			}

			// Read the INF name string from the resource file
			if (0 < ::LoadStringW(GetInstanceHandle(), 
								IDS_NMDD_INFNAME, 
								pwszINFNameBuffer, 
								CCHMAX(pwszINFNameBuffer)))
			{
				pcwszINFName = pwszINFNameBuffer;
			}
			else
			{
				ERROR_OUT(("LoadStringW() fails, err=%lu", GetLastError()));
				pcwszINFName = g_pcwszDefaultINFName;
			}


			// Now we're set to call the actual installation function
			DWORD dwErr;

			dwErr = (*pfnInstallGraphicsDriver)(hWnd,
												pwszSourcePath,
												pcwszModelName,
												pcwszINFName);

			if (dwErr)
			{
				WARNING_OUT(("InstallGraphicsDriver() fails, err=%lu", dwErr));
			}

			if (ERROR_SUCCESS == dwErr)
			{
				fDriverInstallSucceeded = TRUE;
				g_fNTDisplayDriverEnabled = TRUE;
			}

OEAS_AbortInstall:
			// If we failed to install the driver, we report an error.
			// If we succeeded, we prompt the user to restart the system.
			if (! fDriverInstallSucceeded)
			{
				::ConfMsgBox(
						hWnd,
						(LPCTSTR) IDS_ENABLEAPPSHARING_INSTALL_FAILURE,
						MB_OK | MB_ICONERROR);
			}
			else if (IDYES == ::ConfMsgBox(
									hWnd,
									(LPCTSTR) IDS_ENABLEAPPSHARING_INSTALL_COMPLETE,
									MB_YESNO | MB_ICONQUESTION))
			{
				// Initiate a system restart.  This involves getting the
				// necessary privileges first.
				HANDLE hToken;
				TOKEN_PRIVILEGES tkp;
				BOOL fRet;

				// Get the current process token handle so we can get shutdown 
				// privilege. 
				fRet = OpenProcessToken(
							GetCurrentProcess(), 
							TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
							&hToken);

				// Get the LUID for shutdown privilege.
				if (fRet) 
				{
					fRet = LookupPrivilegeValue(
								NULL, 
								SE_SHUTDOWN_NAME, 
								&tkp.Privileges[0].Luid);
				}
				else
				{
					hToken = NULL;
					WARNING_OUT(("OpenProcessToken() fails (error %lu)", GetLastError())); 
				}

				// Get shutdown privilege for this process. 
				if (fRet)
				{
					tkp.PrivilegeCount = 1; 
					tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 

					fRet = AdjustTokenPrivileges(
								hToken, 
								FALSE, 
								&tkp, 
								0, 
								(PTOKEN_PRIVILEGES) NULL, 
								0);

					// Special-case scenario where call succeeds but not all
					// privileges were set.
					if (fRet && ERROR_SUCCESS != GetLastError())
					{
						fRet = FALSE;
					}
				}
				else
				{
					WARNING_OUT(("LookupPrivilegeValue() fails (error %lu)", GetLastError())); 
				}


				if (! fRet)
				{
					WARNING_OUT(("AdjustTokenPrivileges() fails (error %lu)", GetLastError())); 
				}

				if (NULL != hToken)
				{
					CloseHandle(hToken);
				}

				if (! ::ExitWindowsEx(EWX_REBOOT, 0))
				{
					WARNING_OUT(("ExitWindowsEx() fails (error %lu)", GetLastError()));
				}
			}

			if (NULL != hDisplayCPL)
			{
				FreeLibrary(hDisplayCPL);
			}
		}
	}
	else
	{
		// Tell the user how to get the SP
		::ConfMsgBox(
			hWnd,
			(LPCTSTR) IDS_ENABLEAPPSHARING_NEEDNTSP);
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\seccpl.cpp ===
// File: seccpl.cpp

#include "precomp.h"
#include "conf.h"
#include <tsecctrl.h>
#include <certui.h>
#include <help_ids.h>
#include "ConfPolicies.h"

// Dialog ID to Help ID mapping
static const DWORD rgHelpIdsSecurity[] = {
IDC_SEC_GENERAL,        IDH_SECURITY_SECURITY,
IDC_SEC_GEN_TEXT,       IDH_SECURITY_SECURITY,
IDC_SEC_INCOMING,       IDH_SECURITY_INCOMING,
IDC_SEC_OUTGOING,       IDH_SECURITY_OUTGOING,

IDC_SEC_CRED,           IDH_SECURITY_CERTIFICATE,
IDC_SEC_CRED_TEXT,      IDH_SECURITY_CERTIFICATE,
IDC_SECURE_CALL_EDIT,   IDH_SECURITY_CERTIFICATE_LIST,
IDC_SEC_CHANGECERT,     IDH_SECURITY_CHANGE_CERTIFICATE,
IDC_SEC_PRIVACY_ONLY,   IDH_SECURITY_CERTIFICATE_PRIVACY,
IDC_SEC_PRIVACY_AUTH,   IDH_SECURITY_CERTIFICATE_PRIV_AUTH,
0, 0   // terminator
};


extern INmSysInfo2 * g_pNmSysInfo;

static PBYTE g_pbEncodedCert = NULL;
static DWORD g_cbEncodedCert = 0;


INT_PTR APIENTRY SecurityDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_DESTROY:
            if ( g_pbEncodedCert )
            {
                FreeT120EncodedCert ( g_pbEncodedCert );
                g_pbEncodedCert = NULL;
            }
            break;

        case WM_INITDIALOG:
        {
            int  security;
            BOOL fIncomingOn;
            BOOL fOutgoingOn;
            BOOL fBtnsAlterable;

            //
            // Get the current cert used by T.120
            //

            security = ConfPolicies::GetSecurityLevel();

            switch (security)
            {
                case DISABLED_POL_SECURITY:
                    fBtnsAlterable = FALSE;
                    fIncomingOn = FALSE;
                    fOutgoingOn = FALSE;
                    break;

                case REQUIRED_POL_SECURITY:
                    fBtnsAlterable = FALSE;
                    fIncomingOn = TRUE;
                    fOutgoingOn = TRUE;
                    break;

                default:
                    fBtnsAlterable = TRUE;
                    fIncomingOn = ConfPolicies::IncomingSecurityRequired();
                    fOutgoingOn = ConfPolicies::OutgoingSecurityPreferred();
                    break;
            }

            // Incoming
            ::CheckDlgButton(hDlg, IDC_SEC_INCOMING, fIncomingOn);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_SEC_INCOMING), fBtnsAlterable);

            // Outgoing
            ::CheckDlgButton(hDlg, IDC_SEC_OUTGOING, fOutgoingOn);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_SEC_OUTGOING), fBtnsAlterable);

            //
            // Set privacy versus authentication (cert used for security)
            //
            RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
            BOOL fAuthentication = re.GetNumber(REGVAL_SECURITY_AUTHENTICATION,
                                        DEFAULT_SECURITY_AUTHENTICATION);


            //
            // If the user cert store is empty, reset the choice back
            // to privacy only
            //

            if ( fAuthentication && !NumUserCerts() )
            {
                re.SetValue(REGVAL_SECURITY_AUTHENTICATION, (DWORD)0);
                fAuthentication = 0;
            }

            // Handle certificate combo box.
            if (security != DISABLED_POL_SECURITY)
            {
                if ( !fAuthentication )
                {
                    if ( TCHAR * pCertText = new TCHAR[MAX_PATH] )
                    {
                        FLoadString(IDS_GENERIC_NMDC_TEXT, pCertText, MAX_PATH);
                        SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                        delete pCertText;
                    }
                }
                else
                {
                    if ( GetT120ActiveCert( &g_pbEncodedCert,
                                                    &g_cbEncodedCert ))
                    {
                        if (TCHAR * pCertText = FormatCert(g_pbEncodedCert,
                                                        g_cbEncodedCert))
                        {
                            SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                            delete pCertText;
                        }
                        else
                        {
                            WARNING_OUT(("FormatCert returns NULL"));
                        }
                    }
                    else
                    {
                        WARNING_OUT(("SecurityDlgProc init: no T120 cert"));
                    }
                }
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg,IDC_SECURE_CALL_EDIT), FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT),   FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_PRIVACY_ONLY), FALSE);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_PRIVACY_AUTH), FALSE);
            }

            // Check the appropriate box:

            if (fAuthentication)
            {
                CheckRadioButton(hDlg, IDC_SEC_PRIVACY_ONLY, IDC_SEC_PRIVACY_AUTH,
                    IDC_SEC_PRIVACY_AUTH);
            }
            else
            {
                CheckRadioButton(hDlg, IDC_SEC_PRIVACY_ONLY, IDC_SEC_PRIVACY_AUTH,
                    IDC_SEC_PRIVACY_ONLY);
                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT), FALSE);
            }

            return (TRUE);
        }

        case WM_NOTIFY:
            if (((NMHDR FAR *) lParam)->code == PSN_APPLY)
            {
                //
                // User can only change these settings if no policy
                // disabling security.
                //
                if (ConfPolicies::GetSecurityLevel() != DISABLED_POL_SECURITY)
                {
                    RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);

                    if (ConfPolicies::GetSecurityLevel() == DEFAULT_POL_SECURITY)
                    {
                        // Incoming
                        re.SetValue(REGVAL_SECURITY_INCOMING_REQUIRED,
                            (::IsDlgButtonChecked(hDlg, IDC_SEC_INCOMING) != FALSE));


                        // Outgoing
                        re.SetValue(REGVAL_SECURITY_OUTGOING_PREFERRED,
                            (::IsDlgButtonChecked(hDlg, IDC_SEC_OUTGOING) != FALSE));
                    }

                    BOOL fAuth = (::IsDlgButtonChecked(hDlg,
                                    IDC_SEC_PRIVACY_AUTH) != FALSE);

                    if ( fAuth )
                    {
                        if ( !SetT120ActiveCert ( FALSE, g_pbEncodedCert,
                                                        g_cbEncodedCert ))
                        {
                            //
                            // Did the new cert fail? if so put
                            // up an error dialog.

                            ConfMsgBox(hDlg, (LPCSTR)IDS_CERT_FAILED);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                            return PSNRET_INVALID_NOCHANGEPAGE;
                        }
                        else
                        {
                            SetT120CertInRegistry ( g_pbEncodedCert,
                                                    g_cbEncodedCert );
                        }
                    }
                    else
                    {
                        SetT120ActiveCert( TRUE, NULL, 0);
                    }

                    re.SetValue(REGVAL_SECURITY_AUTHENTICATION, fAuth );
                }
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDC_SEC_CHANGECERT:
                if (ChangeCertDlg(hDlg, ::GetInstanceHandle(),
                                    &g_pbEncodedCert, &g_cbEncodedCert ))
                {
                    TCHAR * pCertText = FormatCert(g_pbEncodedCert,
                                                    g_cbEncodedCert);
                    if (pCertText)
                    {
                        SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                        delete pCertText;
                    }
                    else
                    {
                        ERROR_OUT(("SEC_CHANGECERT: FormatCert failed"));
                    }
                }
                break;

            case IDC_SEC_PRIVACY_AUTH:
                if (!NumUserCerts())
                {
                    if ( SendDlgItemMessage(hDlg, IDC_SEC_PRIVACY_AUTH,
                                            BM_GETCHECK, 0, 0 ))
                    {
                        // Force setting back
                        CheckRadioButton(hDlg, IDC_SEC_PRIVACY_ONLY,
                            IDC_SEC_PRIVACY_AUTH, IDC_SEC_PRIVACY_ONLY);
                        SetFocus(GetDlgItem(hDlg, IDC_SEC_PRIVACY_ONLY));

                        // Bring up message box that this won't work:
                        ConfMsgBox(hDlg, (LPCSTR)IDS_NO_USER_CERTS);
                    }
                    return (TRUE);
                }

                if ( !g_pbEncodedCert )
                {
                    if ( !GetDefaultSystemCert( &g_pbEncodedCert,
                                            &g_cbEncodedCert ))
                    {
                        WARNING_OUT(("GetDefaultSystemCert failed"));
                    }
                }

                if ( g_pbEncodedCert )
                {
                    if (TCHAR * pCertText = FormatCert(g_pbEncodedCert,
                                                    g_cbEncodedCert))
                    {
                        SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                        delete pCertText;
                    }
                    else
                    {
                        WARNING_OUT(("FormatCert returns NULL"));
                    }
                }
                else
                {
                    WARNING_OUT(("SecurityDlgProc init: no T120 cert"));
                }

                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT), TRUE);

                break;


            case IDC_SEC_PRIVACY_ONLY:

                if ( TCHAR * pCertText = new TCHAR[MAX_PATH] )
                {
                    FLoadString(IDS_GENERIC_NMDC_TEXT, pCertText, MAX_PATH);
                    SetDlgItemText(hDlg,IDC_SECURE_CALL_EDIT,pCertText);
                    delete pCertText;
                }

                EnableWindow(GetDlgItem(hDlg,IDC_SEC_CHANGECERT), FALSE);
                break;
            }
            break;

        case WM_CONTEXTMENU:
            DoHelpWhatsThis(wParam, rgHelpIdsSecurity);
            break;

        case WM_HELP:
            DoHelp(lParam, rgHelpIdsSecurity);
            break;

    }
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\splash.h ===
// File: splash.h

VOID StartSplashScreen ( HWND hwnd );
VOID StopSplashScreen ( VOID );
VOID UpdateSplashScreen ( VOID );

extern class CFrame *g_pSplashScreen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\speedial.h ===
// File: speedial.h

#ifndef _SPEEDIAL_H_
#define _SPEEDIAL_H_

#include "confevt.h"
#include "calv.h"

class CSPEEDDIAL : public CALV
{
private:
	TCHAR  m_szFile[MAX_PATH*2];  // large buffer for full path name to file
	LPTSTR m_pszFileName;         // pointer into m_szFile for filename
	int    m_cchFileNameMax;      // maximum length of filename

public:
	CSPEEDDIAL();
	~CSPEEDDIAL();

	VOID CmdDelete(void);
	BOOL FGetSelectedFilename(LPTSTR pszFile);

	// CALV methods
	VOID ShowItems(HWND hwnd);
	VOID OnCommand(WPARAM wParam, LPARAM lParam);
	RAI * GetAddrInfo(void);
};

// Utility routines
BOOL FGetSpeedDialFolder(LPTSTR pszBuffer, UINT cchMax, BOOL fCreate = FALSE);
BOOL FExistingSpeedDial(LPCTSTR pcszAddress, NM_ADDR_TYPE addrType);
BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType = NM_ADDR_UNKNOWN, DWORD dwCallFlags = CRPCF_DEFAULT,
			LPCTSTR pcszRemoteConfName = NULL, LPCTSTR pcszPassword = NULL,
			LPCTSTR pcszPathPrefix = NULL);

#endif /* _SPEEDIAL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\speedial.cpp ===
// File: speedial.cpp

#include "precomp.h"
#include "resource.h"

#include "dirutil.h"
#include "speedial.h"
#include "nameres.h" // for old transports
#include "callto.h"

static const TCHAR g_cszConfLinkExt[] = TEXT(".cnf");
static const TCHAR g_cszConfLinkFilter[] = TEXT("*.cnf");

static const TCHAR g_cszConferenceShortcutSection[] = TEXT("ConferenceShortcut");
static const TCHAR g_cszNameKey[]            = TEXT("ConfName");
static const TCHAR g_cszAddressKey[]         = TEXT("Address");
static const TCHAR g_cszTransportKey[]       = TEXT("Transport");
static const TCHAR g_cszRemoteConfNameKey[]  = TEXT("RemoteConfName");
static const TCHAR g_cszCallFlagsKey[]       = TEXT("CallFlags");
static const TCHAR g_cszPasswordKey[]        = TEXT("Password");

static const int _rgIdMenu[] = {
	IDM_DLGCALL_DELETE,
	0
};

inline VOID DwToSz(DWORD dw, LPTSTR psz)
{
	wsprintf(psz, TEXT("%d"), dw);
}

/*  C  S  P  E  E  D  D  I  A  L  */
/*-------------------------------------------------------------------------
    %%Function: CSPEEDDIAL

-------------------------------------------------------------------------*/
CSPEEDDIAL::CSPEEDDIAL() :
	CALV(IDS_DLGCALL_SPEEDDIAL, II_SPEEDDIAL, _rgIdMenu)
{
	DbgMsg(iZONE_OBJECTS, "CSPEEDDIAL - Constructed(%08X)", this);

	// Check the path to the speed dial folder
	if (!FGetSpeedDialFolder(m_szFile, CCHMAX(m_szFile)))
		return;

	int cchSpeedDialFolder = lstrlen(m_szFile);
	m_szFile[cchSpeedDialFolder++] = _T('\\');
	m_pszFileName = &m_szFile[cchSpeedDialFolder];
	m_cchFileNameMax = CCHMAX(m_szFile) - cchSpeedDialFolder;
	ASSERT(m_cchFileNameMax >= MAX_PATH);
	lstrcpyn(m_pszFileName, g_cszConfLinkFilter, m_cchFileNameMax);

	WIN32_FIND_DATA wfd;
	HANDLE hFind = ::FindFirstFile(m_szFile, &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		return;
	::FindClose(hFind);

	SetAvailable(TRUE);  // we found at least one file
}

CSPEEDDIAL::~CSPEEDDIAL()
{
	DbgMsg(iZONE_OBJECTS, "CSPEEDDIAL - Destroyed(%08X)", this);
}


///////////////////////////////////////////////////////////////////////////
// CALV methods


/*  S H O W  I T E M S  */
/*-------------------------------------------------------------------------
    %%Function: ShowItems

-------------------------------------------------------------------------*/
VOID CSPEEDDIAL::ShowItems(HWND hwnd)
{
	CALV::SetHeader(hwnd, IDS_ADDRESS);

	if (!FAvailable())
		return;

	lstrcpyn(m_pszFileName, g_cszConfLinkFilter, m_cchFileNameMax);

	WIN32_FIND_DATA wfd;
	HANDLE hFind = ::FindFirstFile(m_szFile, &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		return;

	for ( ; ; )
	{
		lstrcpyn(m_pszFileName, wfd.cFileName, m_cchFileNameMax);

		TCHAR szAddress[CCHMAXSZ_ADDRESS];
		if (0 != GetPrivateProfileString(g_cszConferenceShortcutSection,
				g_cszAddressKey, g_cszEmpty, szAddress, CCHMAX(szAddress), m_szFile))
		{
			TCHAR szName[MAX_PATH];
			lstrcpyn(szName, wfd.cFileName, lstrlen(wfd.cFileName) - CCHEXT); // no .cnf extension

			DlgCallAddItem(hwnd, szName, szAddress, II_COMPUTER);
		}

		if (FALSE == ::FindNextFile(hFind, &wfd))
		{
			::FindClose(hFind);
			break;
		}
	}
}


VOID CSPEEDDIAL::OnCommand(WPARAM wParam, LPARAM lParam)
{
	switch (GET_WM_COMMAND_ID(wParam, lParam))
		{
	case IDM_DLGCALL_DELETE:
		CmdDelete();
		break;
	default:
		CALV::OnCommand(wParam, lParam);
		break;
		}
}

BOOL CSPEEDDIAL::FGetSelectedFilename(LPTSTR pszFile)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return FALSE;

	if (!FGetSpeedDialFolder(pszFile, MAX_PATH))
		return FALSE;
	LPTSTR psz = pszFile + lstrlen(pszFile);
	*psz++ = _T('\\');

	int cchMax = (INT)(MAX_PATH - (CCHMAX(g_cszConfLinkExt) + psz - pszFile));
	if (!GetSzData(psz, cchMax, iItem, IDI_DLGCALL_NAME))
		return FALSE;

	lstrcat(pszFile, g_cszConfLinkExt);
	return TRUE;
}


VOID CSPEEDDIAL::CmdDelete(void)
{
	int iItem = GetSelection();
	if (-1 == iItem)
		return;

	TCHAR szFile[MAX_PATH];
	if (!FGetSelectedFilename(szFile))
		return;

	if (::DeleteFile(szFile))
	{
		DeleteItem(iItem);
	}
}


/*  G E T  A D D R  I N F O  */
/*-------------------------------------------------------------------------
    %%Function: GetAddrInfo

-------------------------------------------------------------------------*/
RAI * CSPEEDDIAL::GetAddrInfo(void)
{
	TCHAR szFile[MAX_PATH];
	if (!FGetSelectedFilename(szFile))
		return NULL;

	NM_ADDR_TYPE addrType;
	int iTransport = GetPrivateProfileInt(g_cszConferenceShortcutSection,
				g_cszTransportKey, NAMETYPE_UNKNOWN, szFile);
	switch (iTransport)
		{
	case NAMETYPE_IP:       addrType = NM_ADDR_IP;           break;
	case NAMETYPE_PSTN:     addrType = NM_ADDR_PSTN;         break;
	case NAMETYPE_ULS:      addrType = NM_ADDR_ULS;          break;
	case NAMETYPE_H323GTWY: addrType = NM_ADDR_H323_GATEWAY; break;

	case NAMETYPE_UNKNOWN:  addrType = NM_ADDR_ULS;          break;

	default:                addrType = NM_ADDR_UNKNOWN;      break;
		}

	RichAddressInfo *	pRai	= CALV::GetAddrInfo( addrType );

	if( hasValidUserInfo( pRai ) && (addrType == NM_ADDR_IP) )
	{
		unsigned long	ulDestination;

		if( GetIpAddress( pRai->rgDwStr[0].psz, ulDestination ) != S_OK )
		{
			pRai->rgDwStr[0].dw = NM_ADDR_MACHINENAME;
		}
	}

	return( pRai );
}




/*  F  C R E A T E  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: FCreateSpeedDial

    Return TRUE if a new speed dial was created.

    If pcszPathPrefix is NULL the file will be created only if necessary.
-------------------------------------------------------------------------*/
BOOL FCreateSpeedDial(LPCTSTR pcszName, LPCTSTR pcszAddress,
			NM_ADDR_TYPE addrType, DWORD dwCallFlags,
			LPCTSTR pcszRemoteConfName, LPCTSTR pcszPassword,
			LPCTSTR pcszPathPrefix)
{
	TCHAR sz[MAX_PATH];
	TCHAR szFileName[MAX_PATH*2];
	if (FEmptySz(pcszPathPrefix))
	{
		if (FExistingSpeedDial(pcszAddress, addrType))
		{
			WARNING_OUT(("Duplicate SpeedDial already exists - not creating"));
			return FALSE;
		}

		if (!FGetSpeedDialFolder(szFileName, CCHMAX(szFileName), TRUE))
		{
			ERROR_OUT(("FGetSpeedDialFolder failed!"));
			return FALSE;
		}
	}
	else
	{
		lstrcpyn(szFileName, pcszPathPrefix, CCHMAX(szFileName));
	}

	if (!FCreateNewFile(szFileName, pcszName, g_cszConfLinkExt, szFileName, CCHMAX(szFileName)))
	{
		return FALSE;
	}

	// Write the data to the file
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszNameKey, pcszName, szFileName);
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszAddressKey, pcszAddress, szFileName);
	
	// Call Flags (normally CRPCF_DEFAULT)
	DwToSz(dwCallFlags, sz);
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszCallFlagsKey, sz, szFileName);

	// Transports
	DWORD dwTransport;
	switch (addrType)
		{
	case NM_ADDR_IP:
		dwTransport = NAMETYPE_IP;
		break;

	case NM_ADDR_PSTN:
		dwTransport = NAMETYPE_PSTN;
		break;

	case NM_ADDR_ULS:
		dwTransport = NAMETYPE_ULS;
		break;

	case NM_ADDR_H323_GATEWAY:
		dwTransport = NAMETYPE_H323GTWY;
		break;

	case NM_ADDR_UNKNOWN:
	default:
		dwTransport = NAMETYPE_UNKNOWN;
		break;
		}
	DwToSz(dwTransport, sz);
	WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszTransportKey, sz, szFileName);

	// Remote conference name
	if (!FEmptySz(pcszRemoteConfName))
	{
		WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszRemoteConfNameKey,
			pcszName, pcszRemoteConfName);

		// Remote conference name
		if (!FEmptySz(pcszPassword))
		{
			WritePrivateProfileString(g_cszConferenceShortcutSection, g_cszPasswordKey,
				pcszName, pcszPassword);
		}
	}

	return TRUE;
}



/*  F  E X I S T I N G  S P E E D  D I A L  */
/*-------------------------------------------------------------------------
    %%Function: FExistingSpeedDial

-------------------------------------------------------------------------*/
BOOL FExistingSpeedDial(LPCTSTR pcszAddress, NM_ADDR_TYPE addrType)
{
	TCHAR szFile[MAX_PATH*2];
	if (!FGetSpeedDialFolder(szFile, CCHMAX(szFile)))
		return FALSE;

	lstrcat(szFile, "\\");
	int cchMax = lstrlen(szFile);
	LPTSTR pszFileName = &szFile[cchMax];      // points to the filename
	lstrcpy(pszFileName, g_cszConfLinkFilter);
	cchMax = CCHMAX(szFile) - cchMax;          // The max length of a filename

	WIN32_FIND_DATA wfd;
	HANDLE hFind = ::FindFirstFile(szFile, &wfd);
	if (INVALID_HANDLE_VALUE == hFind)
		return FALSE;

	BOOL fFound = FALSE;
	for ( ; ; )
	{
		lstrcpyn(pszFileName, wfd.cFileName, cchMax);

		TCHAR szAddress[CCHMAXSZ_ADDRESS];
		if (0 != GetPrivateProfileString(g_cszConferenceShortcutSection,
				g_cszAddressKey, g_cszEmpty, szAddress, CCHMAX(szAddress), szFile))
		{
			if (0 == lstrcmp(szAddress, pcszAddress))
			{
				fFound = TRUE;
				break;
			}
		}

		if (!FindNextFile(hFind, &wfd))
			break;
	}

	::FindClose(hFind);
	return fFound;
}


/*-------------------------------------------------------------------------
    %%Function: GetSpeedDialFolderName

-------------------------------------------------------------------------*/
bool GetSpeedDialFolderName(LPTSTR pszBuffer, int cbLength)
{
	ASSERT( pszBuffer != NULL );
	ASSERT( cbLength > 0 );

	RegEntry	re( CONFERENCING_KEY, HKEY_LOCAL_MACHINE );

	LPTSTR		pszFolder	= re.GetString( REGVAL_SPEED_DIAL_FOLDER );
	bool		bResult		= !FEmptySz( pszFolder );

	if( !bResult )
	{
		TCHAR	szNewFolder[ MAX_PATH ];

		if( GetInstallDirectory( szNewFolder ) )
		{
			TCHAR	szSDFolder[ MAX_PATH ];

			FLoadString( IDS_SPEEDDIAL_FOLDER, szSDFolder, CCHMAX( szSDFolder ) );

			ASSERT( (lstrlen( szNewFolder) + lstrlen( szSDFolder )) < CCHMAX( szNewFolder ) );

			lstrcat( szNewFolder, szSDFolder );

			pszFolder	= szNewFolder;
			bResult		= true;
	
			// Set the registry entry
			RegEntry	re( CONFERENCING_KEY, HKEY_LOCAL_MACHINE );
			
			re.SetValue( REGVAL_SPEED_DIAL_FOLDER, szNewFolder );
		}
	}

	if( bResult )
	{
		lstrcpyn( pszBuffer, pszFolder, cbLength );
	}

	return( bResult );

}


/*  C R E A T E  S P E E D  D I A L  F O L D E R  */
/*-------------------------------------------------------------------------
    %%Function: CreateSpeedDialFolder

-------------------------------------------------------------------------*/
BOOL CreateSpeedDialFolder(LPTSTR pszBuffer, int cbLength)
{
	BOOL	bResult	= FALSE;

	if( GetSpeedDialFolderName( pszBuffer, cbLength ) )
	{
		bResult = ::FEnsureDirExists( pszBuffer );
	}

	return( bResult );

}


/*  F  G E T  S P E E D  D I A L  F O L D E R  */
/*-------------------------------------------------------------------------
    %%Function: FGetSpeedDialFolder

-------------------------------------------------------------------------*/
BOOL FGetSpeedDialFolder(LPTSTR pszBuffer, UINT cchMax, BOOL fCreate)
{
	bool	bResult	= false;

	if( GetSpeedDialFolderName( pszBuffer, cchMax ) )
	{
		if( ::FDirExists( pszBuffer ) )
		{
			bResult = true;
		}
		else if( fCreate )
		{
			bResult = (CreateSpeedDialFolder( pszBuffer, cchMax ) != FALSE);
		}
	}

	return( (BOOL) bResult );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\stiderc.cpp ===
/* ----------------------------------------------------------------------

	Copyright (c) 1996, Microsoft Corporation
	All rights reserved

	stiderc.c

  ---------------------------------------------------------------------- */

#include "precomp.h"

#include "global.h"
#include "dirlist.h"

UINT gfOprahMode = 0;


VOID static _GetPsz(LPTSTR * ppsz, PTCHAR pszDest)
{
	PTCHAR pch = *ppsz;

	while (_T('\0') != *pch)
	{
		*pszDest++ = (*pch++)-1;
	}
	*pszDest = _T('\0');
	*ppsz = pch+1;
}


PTCHAR static _NextWord(PTCHAR pch)
{
	pch = (PTCHAR) _StrChr(pch, _T(','));
	if (NULL != pch)
	{
		*pch = _T('\0');
		pch++;
	}
	return pch;
}


HRESULT OprahDirectory(CDirListView* pdlv)
{
	HRSRC hRes;
	PVOID pData;
	LPTSTR psz;
	PTCHAR pch;
	TCHAR szEmail[32];
	TCHAR szCity[32];
	TCHAR szCountry[128];
	TCHAR rgsz[4][32];

	if (NULL == (hRes = FindResource(GetInstanceHandle(), MAKEINTRESOURCE(IDC_STIDERC), "CDAT")) ||
		(NULL == (psz = (LPTSTR) LockResource(LoadResource(GetInstanceHandle(), hRes))) ) )
	{
		return E_FAIL;
	}

	_GetPsz(&psz, szEmail);
	_GetPsz(&psz, szCity);
	_GetPsz(&psz, rgsz[0]);
	_GetPsz(&psz, rgsz[1]);
	_GetPsz(&psz, rgsz[2]);
	_GetPsz(&psz, rgsz[3]);

	for ( ; ; )
	{
		TCHAR szRow[MAX_PATH];

		UINT   bFlags;
		LPTSTR pszFirst;
		LPTSTR pszLast;
		LPTSTR pszComments;
		LPTSTR pszCity;
		LPTSTR pszCountry;

		_GetPsz(&psz, szRow);
		if (FEmptySz(szRow))
			break;

		pch = szRow;
		bFlags = (*pch) - _T('\0');
		pch++;

		pszFirst = pch;
		pch = _NextWord(pch);

		pszLast = pch;
		pch = _NextWord(pch);

		pszComments = pch;
		pch++;
		switch (*pch)
			{
		case _T(','):
			pch++;
		case _T('\0'):
			pszComments = rgsz[*pszComments-_T('1')];
			break;
		default:
			pch = _NextWord(pch);
			break;
			}

		if (FEmptySz(pch))
		{
			pszCity = szCity;
			pszCountry = TEXT("US");
		}
		else
		{
			pszCity = pch;
			pszCountry = _NextWord(pch);
		}

		if ((_T('\0') != pszCountry[0]) &&
			(_T('\0') != pszCountry[1]) &&
			(_T('\0') == pszCountry[2]))
		{
			if (pdlv->FFindCountry(szCountry, pszCountry))
			{
				pszCountry = szCountry;
			}
		}

		pdlv->Add(szEmail, pszFirst, pszLast, pszCity, pszCountry, pszComments,
			(bFlags & 0x04) ? II_IN_CALL : II_NOT_IN_CALL,
			(bFlags & 0x01) ? II_AUDIO_CAPABLE : 0,
			(bFlags & 0x02) ? II_VIDEO_CAPABLE : 0);
	}

	FreeResource(hRes);

	pdlv->CancelDirectory();

	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\statbar.h ===
// File: statbar.h

#ifndef _STATBAR_H_
#define _STATBAR_H_

#include "ConfRoom.h"

class CConfStatusBar
{
protected:
	static CConfStatusBar * m_pStatusBar;
public:
	static CConfStatusBar * GetInstance()   { return m_pStatusBar; }
	
private:
	enum StatIcon
	{
		StatConnect = 0,
		StatLogin,
		StatIconCount
	} ;

	HWND	m_hwnd;
	HWND	m_hwndLoginTT;					// The tooltip window
	HICON	m_hIconStatus[StatIconCount];	// handle to status bar icon
	DWORD   m_idIconStatus[StatIconCount];	// id of current status bar icon
	CConfRoom*	m_pcrParent;
	TCHAR	m_szULSStatus[MAX_PATH];

	BOOL    m_fVisible : 1;			// TRUE if status bar displayed

	VOID	SetIcon(StatIcon eIcon, DWORD dwId);
	VOID	SetText(UINT uID, LPCTSTR sz);
	void	SetTooltip(StatIcon eIcon, LPCTSTR szTip);

public:
			CConfStatusBar(CConfRoom* pcr);
			~CConfStatusBar();

	VOID	Update();
	int		GetHeight();
	BOOL	Create(HWND hwndParent);
	VOID	Show(BOOL fShow);
	VOID	ResizeParts();
	VOID	Resize(WPARAM wParam, LPARAM lParam);
	BOOL	OnDraw(LPDRAWITEMSTRUCT pdis);
	VOID	RemoveHelpText();
	VOID	SetHelpText(LPCTSTR pcszText);
	BOOL    FVisible()              { return (m_fVisible != FALSE); }
	HWND    GetHwnd()               { return m_hwnd; }
	VOID    ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#endif // _STATBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\splash.cpp ===
// File: splash.cpp

#include "precomp.h"
#include "resource.h"
#include "conf.h"

#include "GenWindow.h"
#include "GenContainers.h"
#include "GenControls.h"

static const int DXP_LOGO_LEFT      = 182;
static const int DYP_LOGO_COPYRIGHT = 24;
static const int LogoBorder         = 10;

CFrame *g_pSplashScreen = NULL;

HPALETTE PaletteFromBitmap(HINSTANCE hInst, LPCTSTR pszRes)
{
	HRSRC hFind = FindResource(hInst, pszRes, RT_BITMAP);
	if (NULL == hFind)
	{
		return(NULL);
	}
	HGLOBAL hRsrc = LoadResource(_Module.GetModuleInstance(), hFind);
	if (NULL == hRsrc)
	{
		return(NULL);
	}

	HPALETTE hRet = NULL;
	LPVOID pRsrc = LockResource(hRsrc);
	if (NULL != pRsrc)
	{
		BITMAPINFO *pbmi = reinterpret_cast<BITMAPINFO*>(pRsrc);
		BITMAPINFOHEADER &bmih = pbmi->bmiHeader;

		ASSERT(1 == bmih.biPlanes);

		if (8 >= bmih.biBitCount)
		{
			RGBQUAD *rgb = pbmi->bmiColors;

			struct
			{
				LOGPALETTE pal;
				PALETTEENTRY palPalEntry[256];
			} myPal;
			myPal.pal.palVersion = 0x300;
			myPal.pal.palNumEntries = LOWORD(bmih.biClrUsed);
			if (0 == myPal.pal.palNumEntries)
			{
				myPal.pal.palNumEntries = 1 << bmih.biBitCount;
			}
			ASSERT(myPal.pal.palNumEntries <= 1 << bmih.biBitCount);

			for (int i=myPal.pal.palNumEntries-1; i>=0; --i)
			{
				PALETTEENTRY &pe = myPal.pal.palPalEntry[i];

				pe.peRed   = rgb[i].rgbRed;
				pe.peGreen = rgb[i].rgbGreen;
				pe.peBlue  = rgb[i].rgbBlue;
				pe.peFlags = PC_NOCOLLAPSE;
			}

			hRet = CreatePalette(&myPal.pal);
		}

		UnlockResource(hRsrc);
	}

	FreeResource(hRsrc);

	return(hRet);
}

class CSplashFrame : public CFrame
{
public:
	CSplashFrame() : m_hPal(NULL) {}

	HPALETTE m_hPal;

	virtual HPALETTE GetPalette()
	{
		return(m_hPal);
	}

protected:
	~CSplashFrame()
	{
		if (NULL != m_hPal)
		{
			DeleteObject(m_hPal);
		}
	}
} ;

static HBITMAP LoadSplashBitmap()
{
	HBITMAP hBmp = (HBITMAP) LoadImage(::GetInstanceHandle(), MAKEINTRESOURCE(IDB_SPLASH),
			IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_CREATEDIBSECTION);

	if (NULL == hBmp)
	{
		ERROR_OUT(("Error loading splash screen bitmap"));
		return(NULL);
	}

	BITMAP bmp;
	GetObject(hBmp, sizeof(BITMAP), (LPVOID)&bmp);

	// Create a DC
	HDC hdc = CreateCompatibleDC(NULL);
	if (NULL == hdc)
	{
		return(hBmp);
	}

	// Use the dialog font but make sure it's the right size
	// it better be a scalable truetype font!
	LOGFONT logFont;
	::GetObject((HFONT)GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &logFont );

	// Look for a string resource which sets the font size
	// and set the font size to this value if present
	lstrcpy(logFont.lfFaceName, RES2T(IDS_SPLASHFONT));
	if ('\0' == logFont.lfFaceName[0])
	{
		lstrcpy(logFont.lfFaceName, TEXT("Arial"));
	}
	logFont.lfHeight = - LoadResInt(IDS_SPLASHFONTSIZE, 11);

	HFONT hFont = CreateFontIndirect (&logFont);
	if (NULL != hFont)
	{
		SelectObject(hdc, hFont);
	}
	SelectObject(hdc, hBmp);

	::SetTextColor(hdc, RGB(0, 0, 0)); // black

	// The following code assumes the bitmap is
	// a certain size, so assert on that here.
	// If this assertion doesn't hold the text positions
	// have to be adjusted.
	ASSERT(bmp.bmWidth == 398);
	ASSERT(bmp.bmHeight == 245);

	SetBkMode(hdc, TRANSPARENT);

	// Do the Copyright message (multiple lines)
	TCHAR sz[400]; // must be large enuf for owner+company and copyright text
	FLoadString(IDS_COPYRIGHT, sz, CCHMAX(sz));

	RECT rc ={
		DXP_LOGO_LEFT, DYP_LOGO_COPYRIGHT,
		bmp.bmWidth - LogoBorder, bmp.bmHeight - LogoBorder
	};
	DrawText(hdc, sz, -1, &rc, DT_LEFT | DT_NOPREFIX | DT_WORDBREAK);

//#define FINAL
#ifndef FINAL  // Don't just delete this - compile with FINAL defined!
		{
		COLORREF bkColor = SetTextColor(hdc, RGB(0xFF, 0, 0));
		HFONT hFontBig = CreateFont(-28, 0, 0, 0, FW_BOLD,
			FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_TT_PRECIS,
			CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
			DEFAULT_PITCH | FF_DONTCARE,
			TEXT("Arial"));

		FLoadString(IDS_ABOUT_OTHER, sz, CCHMAX(sz));
		if (NULL != hFontBig)
		{
			HFONT hOldFont = (HFONT)SelectObject (hdc, hFontBig);

			SetRect(&rc, 280, 151, bmp.bmWidth, bmp.bmHeight);
			DrawText(hdc, sz, lstrlen(sz), &rc,
				DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX);
			SelectObject(hdc, hOldFont);
			DeleteObject(hFontBig);
		}
		SetTextColor(hdc, bkColor);
	}
#endif /* FINAL */
#undef FINAL

	DeleteDC(hdc);

	if (NULL != hFont)
	{
		DeleteObject(hFont);
	}

	return(hBmp);
}

VOID UpdateSplashScreen ( VOID );

/*  S T A R T  S P L A S H  S C R E E N */
/*----------------------------------------------------------------------------
    %%Function: StartSplashScreen
 
----------------------------------------------------------------------------*/
VOID StartSplashScreen(HWND hwndParent)
{
	if (NULL != g_pSplashScreen)
	{
		return;
	}

	CSplashFrame *pFrame = new CSplashFrame();
	g_pSplashScreen = pFrame;
	if (NULL != pFrame)
	{
		if (!g_fHiColor)
		{
			pFrame->m_hPal = PaletteFromBitmap(_Module.GetModuleInstance(),
				MAKEINTRESOURCE(IDB_SPLASH));
		}

		if (pFrame->Create(hwndParent, g_szEmpty, WS_POPUP | WS_BORDER,
			WS_EX_TOOLWINDOW | g_wsLayout, -1000, -1000, 10, 10,
			_Module.GetModuleInstance()))
		{
			CBitmapButton *pButton = new CBitmapButton();
			if (NULL != pButton)
			{
				HBITMAP hBmp = LoadSplashBitmap();

				pButton->Create(pFrame->GetWindow(), 0, hBmp, 1);

				pFrame->Resize();

				pFrame->Layout();
				pButton->Layout();

				pFrame->MoveEnsureVisible(-1000, -1000);

				ShowWindow(pFrame->GetWindow(), SW_SHOW);

				UpdateSplashScreen();

				pButton->Release();
			}
		}
	}
}

/*  S T O P  S P L A S H  S C R E E N */
/*----------------------------------------------------------------------------
    %%Function: StopSplashScreen
 
----------------------------------------------------------------------------*/
VOID StopSplashScreen ( VOID )
{
	if (NULL != g_pSplashScreen)
	{
		HWND hwnd = g_pSplashScreen->GetWindow();
		if (NULL != hwnd)
		{
			DestroyWindow(hwnd);
		}

		g_pSplashScreen->Release();
		g_pSplashScreen = NULL;
	}
}

/*  U P D A T E  S P L A S H  S C R E E N */
/*----------------------------------------------------------------------------
    %%Function: UpdateSplashScreen
 
----------------------------------------------------------------------------*/
VOID UpdateSplashScreen ( VOID )
{
	if (NULL != g_pSplashScreen)
	{
		HWND hwnd = g_pSplashScreen->GetWindow();
		if (NULL != hwnd)
		{
			RedrawWindow(hwnd, NULL, NULL, RDW_ALLCHILDREN|RDW_UPDATENOW);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\statbar.cpp ===
/****************************************************************************
*
*    FILE:     StatBar.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 3-25-96
*
*    CONTENTS: CConfStatusBar object
*
****************************************************************************/

#include "precomp.h"
#include "resource.h"
#include "statbar.h"
#include "NmLdap.h"
#include "call.h"
#include "cr.h"
#include "confwnd.h"
#include "ConfPolicies.h"

static inline void TT_AddToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_ADDTOOL, 0, reinterpret_cast<LPARAM>(pti));
}

static inline void TT_GetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_GETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti));
}

static inline void TT_SetToolInfo(HWND hwnd, TOOLINFO *pti)
{
	SendMessage(hwnd, TTM_SETTOOLINFO, 0, reinterpret_cast<LPARAM>(pti));
}

// Status Bar area indexes
enum
{
	ID_SBP_TEXT,
	// ID_SBP_ULS,
	ID_SBP_ICON,
	NUM_STATUSBAR_WELLS
} ;

// Status Bar area measurements (pixels)
static const UINT DXP_SB_PROG =          96;
static const UINT DXP_SB_ULS =          0; // 220;
static const UINT DXP_SB_ICON =          22;
static const UINT DXP_SB_DEF_ICON =      40;

static const int IconBorder = 2;
static const int StatSepBorder = 2;

CConfStatusBar * CConfStatusBar::m_pStatusBar = NULL;

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   CConfStatusBar
*
*    PURPOSE:  Constructs object
*
****************************************************************************/

CConfStatusBar::CConfStatusBar(CConfRoom* pcr) :
	m_pcrParent		(pcr),
	m_fVisible		(FALSE),
	m_hwnd			(NULL)
{
	DebugEntry(CConfStatusBar::CConfStatusBar);

	ASSERT(NULL == m_pStatusBar);
	m_pStatusBar = this;

	m_szULSStatus[0] = _T('\0');

	for (int i=0; i<StatIconCount; ++i)
	{
		m_hIconStatus[i] = NULL;
		m_idIconStatus[i] = 0;
	}

	DebugExitVOID(CConfStatusBar::CConfStatusBar);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   !CConfStatusBar
*
*    PURPOSE:  Destructs object
*
****************************************************************************/

CConfStatusBar::~CConfStatusBar()
{
	DebugEntry(CConfStatusBar::~CConfStatusBar);
	
	if (NULL != m_hwnd)
	{
		::DestroyWindow(m_hwnd);
	}

	m_pStatusBar = NULL;

	for (int i=0; i<StatIconCount; ++i)
	{
		if (NULL != m_hIconStatus[i])
		{
			DestroyIcon(m_hIconStatus[i]);
		}
	}

	DebugExitVOID(CConfStatusBar::~CConfStatusBar);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   OnDraw(LPDRAWITEMSTRUCT pdis)
*
*    PURPOSE:  Handles drawing the status bar icon
*
****************************************************************************/

BOOL CConfStatusBar::OnDraw(LPDRAWITEMSTRUCT pdis)
{
	ASSERT(pdis);
	if (NULL != (pdis->itemData))
	{
		int nLeft = pdis->rcItem.left;
		int nTop = pdis->rcItem.top;
		int xSmIcon = ::GetSystemMetrics(SM_CXSMICON);
		int ySmIcon = ::GetSystemMetrics(SM_CYSMICON);

		int nWidth = xSmIcon;
		int nHeight = pdis->rcItem.bottom - pdis->rcItem.top;
		if (nHeight > ySmIcon)
		{
			nTop += (nHeight - ySmIcon) / 2;
			nHeight = ySmIcon;
		}

		for (int i=0; i<StatIconCount; ++i)
		{
			nLeft += IconBorder;

			if (NULL != m_hIconStatus[i])
			{
				::DrawIconEx(	pdis->hDC, 
								nLeft, 
								nTop, 
								m_hIconStatus[i],
								nWidth,
								nHeight,
								0,
								NULL,
								DI_NORMAL);
			}

			nLeft += xSmIcon;
		}
	}
	
	return TRUE;
}

VOID CConfStatusBar::ForwardSysChangeMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (NULL == m_hwnd)
		return;

	::SendMessage(m_hwnd, uMsg, wParam, lParam);
}


/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   Resize(WPARAM wParam, LPARAM lParam)
*
*    PURPOSE:  Handles window resizing
*
****************************************************************************/
VOID CConfStatusBar::Resize(WPARAM wParam, LPARAM lParam)
{
	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, WM_SIZE, wParam, lParam);
		ResizeParts();
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   Create(HWND hwndParent)
*
*    PURPOSE:  Creates the status bar window
*
****************************************************************************/

BOOL CConfStatusBar::Create(HWND hwndParent)
{
	DebugEntry(CConfStatusBar::Create);

	BOOL bRet = FALSE;
	
	m_hwnd = CreateStatusWindow(WS_CHILD | WS_BORDER,
								g_szEmpty,
								hwndParent,
								ID_STATUS);
	if (NULL != m_hwnd)
	{
		// Create the ToolTip
		m_hwndLoginTT = CreateWindowEx(0,
											TOOLTIPS_CLASS, 
											(LPSTR) NULL, 
											0, // styles 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											CW_USEDEFAULT, 
											m_hwnd, 
											(HMENU) NULL, 
											::GetInstanceHandle(), 
											NULL); 

		// Add the ToolTips for the 2 icons
		if (NULL != m_hwndLoginTT)
		{
			TOOLINFO ti;

			ti.cbSize = sizeof(TOOLINFO);
			ti.hwnd = m_hwnd;
			ti.hinst = ::GetInstanceHandle();
			ti.lpszText = const_cast<LPTSTR>(g_szEmpty);
			SetRect(&ti.rect, 0, 0, 0, 0);

			for (UINT i=0; i<StatIconCount; ++i)
			{
				ti.uId = i;
				ti.uFlags = TTF_SUBCLASS;
				TT_AddToolInfo(m_hwndLoginTT, &ti);
			}
		}

		// create progress meter window
		ResizeParts();
		Update();
		bRet = TRUE;
	}
	else
	{
		WARNING_OUT(("CConfStatusBar::Create - Unable to create status window"));
	}

	DebugExitBOOL(CConfStatusBar::Create, bRet);

	return bRet;
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    FUNCTION: ResizeParts()
*
*    PURPOSE:  Calculates the correct size of the status bar parts
*
****************************************************************************/

VOID CConfStatusBar::ResizeParts()
{
	ASSERT(m_hwnd);

	int xSmIcon = ::GetSystemMetrics(SM_CXSMICON);

#ifdef RESIZEABLE_WINDOW
	UINT uIconPartWidth = DXP_SB_DEF_ICON;
	NONCLIENTMETRICS ncm;
	ncm.cbSize = sizeof(ncm);
	if (::SystemParametersInfo(	SPI_GETNONCLIENTMETRICS,
								0,
								&ncm,
								0))
	{
		m_nScrollWidth = ncm.iScrollWidth;
		uIconPartWidth = DXP_SB_ICON + m_nScrollWidth;
	}
#else // RESIZEABLE_WINDOW
	// Room for 2 icons
	UINT uIconPartWidth = StatSepBorder + IconBorder + xSmIcon
		+ IconBorder + xSmIcon + IconBorder + StatSepBorder;
#endif // RESIZEABLE_WINDOW

	// re-calculate positions of each tray part
	RECT rc;
	::GetWindowRect(m_hwnd, &rc);
	DWORD dxp = rc.right - rc.left;
	if (dxp > uIconPartWidth)
	{
		DWORD rgPos[NUM_STATUSBAR_WELLS];  // right edge positions for each part
		rgPos[ID_SBP_TEXT] = dxp - (DXP_SB_ULS + uIconPartWidth);
		// rgPos[ID_SBP_ULS] = dxp - uIconPartWidth;
		rgPos[ID_SBP_ICON] = (DWORD) -1;
		::SendMessage(	m_hwnd,
						SB_SETPARTS,
						(WPARAM) ARRAY_ELEMENTS(rgPos),
						(LPARAM) &rgPos);

		if (m_hwndLoginTT)
		{
			TCHAR szTitle[MAX_PATH];
			TOOLINFO ti;
			ti.cbSize = sizeof(TOOLINFO); 
			ti.hwnd = m_hwnd;

			int nIconsLeft = dxp - uIconPartWidth + StatSepBorder + IconBorder;

			for (UINT i=0; i<StatIconCount; ++i)
			{
				ti.uId = i;
				ti.lpszText = szTitle;
				TT_GetToolInfo(m_hwndLoginTT, &ti);

				// HACKHACK georgep: Just setting the height to a large number, since
				// I don't know exactly where the icon will be drawn until it is drawn
				SetRect(&ti.rect, nIconsLeft, 0, nIconsLeft + xSmIcon, 1000);

				ti.uFlags = TTF_SUBCLASS;
				TT_SetToolInfo(m_hwndLoginTT, &ti);

				nIconsLeft += xSmIcon + IconBorder;
			}
		}
	}
}

void CConfStatusBar::SetTooltip(StatIcon eIcon, LPCTSTR szTip)
{
	TCHAR szTitle[MAX_PATH];
	TOOLINFO ti;
	ti.cbSize = sizeof(TOOLINFO); 
	ti.hwnd = m_hwnd;
	ti.lpszText = szTitle;

	ti.uId = eIcon;
	TT_GetToolInfo(m_hwndLoginTT, &ti);

	ti.lpszText = const_cast<LPTSTR>(szTip);
	ti.uFlags = TTF_SUBCLASS;
	TT_SetToolInfo(m_hwndLoginTT, &ti);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   RemoveHelpText()
*
*    PURPOSE:  Removes the status bar help text
*
****************************************************************************/
VOID CConfStatusBar::RemoveHelpText()
{
	// Taking status bar out of simple mode
	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, SB_SIMPLE, FALSE, 0);
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   SetHelpText(LPCTSTR pcszText)
*
*    PURPOSE:  Sets the status bar help text
*
****************************************************************************/

VOID CConfStatusBar::SetHelpText(LPCTSTR pcszText)
{
	// Putting status bar into simple mode
	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, SB_SIMPLE, TRUE, 0);
	
		// 255 means simple mode - only 1 pane
		::SendMessage(	m_hwnd,
						SB_SETTEXT,
						255 | SBT_NOBORDERS,
						(LPARAM) pcszText);
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   Show(BOOL fShow)
*
*    PURPOSE:  Handles the toggling of the status bar window
*
****************************************************************************/

VOID CConfStatusBar::Show(BOOL fShow)
{
	DebugEntry(CConfStatusBar::Show);
	
	fShow = fShow != FALSE;
	if (m_fVisible != fShow)
	{
		m_fVisible = fShow;

		if (NULL != m_hwnd)
		{
			::ShowWindow(m_hwnd, m_fVisible ? SW_SHOW : SW_HIDE);
		}

		// Force a resize
		ResizeParts();
	}
	
	DebugExitVOID(CConfStatusBar::Show);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   GetHeight()
*
*    PURPOSE:  Returns the height in pixels of the status bar
*
****************************************************************************/

int CConfStatusBar::GetHeight()
{
	RECT rc = {0, 0, 0, 0};

	if (m_fVisible && (NULL != m_hwnd))
	{
		GetWindowRect(m_hwnd, &rc);
	}
	return (rc.bottom - rc.top);
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   SetIcon(DWORD dwId)
*
*    PURPOSE:  Set the status bar icon
*
****************************************************************************/

VOID CConfStatusBar::SetIcon(StatIcon eIcon, DWORD dwId)
{
	DWORD &idIconStatus = m_idIconStatus[eIcon];
	HICON &hIconStatus  = m_hIconStatus [eIcon];

	if ((NULL != m_hwnd) && (dwId != idIconStatus))
	{
		TRACE_OUT(("Changing Icon from %d to %d", m_idIconStatus, dwId));
		// REVIEW: what happens to old m_hIconStatus?
		HICON hIcon = (HICON) ::LoadImage(::GetInstanceHandle(),
									MAKEINTRESOURCE(dwId),
									IMAGE_ICON,
									::GetSystemMetrics(SM_CXSMICON),
									::GetSystemMetrics(SM_CYSMICON),
									LR_DEFAULTCOLOR);
		if (NULL != hIcon)
		{
			idIconStatus = dwId;
			if (NULL != hIconStatus)
			{
				::DestroyIcon(hIconStatus);
			}
			hIconStatus = hIcon;
			::SendMessage(	m_hwnd,
							SB_SETTEXT, 
							ID_SBP_ICON | SBT_OWNERDRAW,
							(LPARAM) hIconStatus);
		}
		else
		{
			WARNING_OUT(("Unable to load status bar icon id=%d", dwId));
		}
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    MEMBER:   SetText(UINT uID, LPCTSTR pcszText)
*
*    PURPOSE:  Set the status bar text
*
****************************************************************************/

VOID CConfStatusBar::SetText(UINT uID, LPCTSTR pcszText)
{
	lstrcpyn( m_szULSStatus, pcszText, CCHMAX(m_szULSStatus) );

	if (NULL != m_hwnd)
	{
		::SendMessage(m_hwnd, SB_SETTEXT, uID, (LPARAM) pcszText);
	}
}

/****************************************************************************
*
*    CLASS:    CConfStatusBar
*
*    FUNCTION: Update()
*
*    PURPOSE:  Updates the status bar
*
****************************************************************************/

VOID CConfStatusBar::Update()
{
	DBGENTRY(CConfStatusBar::Update);

	ASSERT(m_pcrParent);

	if (!m_fVisible)
		return;

	TCHAR	szCallStatus[ MAX_PATH * 3 ];	//	Call status is status + url and url can be 512 by itself...
	UINT    uCallIcon = 0;
	DWORD	dwCallTick = 0;

	if (0 == dwCallTick)
	{
		// no current calls - check if switching a/v
		dwCallTick = GetCallStatus(szCallStatus, CCHMAX(szCallStatus), &uCallIcon);
	}
	
	// if a call was started more recently than any other action, OR nothing is going on
	// (in which case all ticks should equal zero), use the conference / call status
	if (dwCallTick == 0)
	{
		// All ticks are zero - Get the default conference status bar info
		m_pcrParent->GetConferenceStatus(szCallStatus, CCHMAX(szCallStatus), &uCallIcon);
	}

	SetText(ID_SBP_TEXT, szCallStatus);
	SetIcon(StatConnect, uCallIcon);
	SetTooltip(StatConnect, szCallStatus);

	TCHAR szOldULSStatus[ARRAY_ELEMENTS(m_szULSStatus)];
	lstrcpy(szOldULSStatus, m_szULSStatus);

	switch( g_GkLogonState )
	{
		case NM_GK_IDLE:
			uCallIcon = IDI_NETGRAY;
			lstrcpy(m_szULSStatus, RES2T(ID_STATUS_NOT_LOGGED_ON_TO_GATEKEEPER));
			break;

		case NM_GK_LOGGING_ON:
			uCallIcon = IDS_STATUS_WAITING;
			lstrcpy(m_szULSStatus, RES2T(ID_STATUS_LOGING_ONTO_GATEKEEPER));
			break;

		case NM_GK_LOGGED_ON:
			uCallIcon = IDI_NET;
			lstrcpy(m_szULSStatus, RES2T(ID_STATUS_LOGGED_ONTO_GATEKEEPER));
			break;

		default:				
			uCallIcon = IDI_NETGRAY;
			if(ConfPolicies::CallingMode_Direct == ConfPolicies::GetCallingMode())
			{
				if(g_pLDAP)
				{
					g_pLDAP->GetStatusText(m_szULSStatus, CCHMAX(m_szULSStatus), &uCallIcon);
				}
				else
				{
					lstrcpy(m_szULSStatus, RES2T(ID_STATUS_LOGGEDOFF));
				}
			}
			else
			{
				lstrcpy(m_szULSStatus, RES2T(ID_STATUS_NOT_LOGGED_ON_TO_GATEKEEPER));
			}
			break;
	}

	if (lstrcmp(szOldULSStatus, m_szULSStatus))
	{
		SetTooltip(StatLogin, m_szULSStatus);
	}
	SetIcon(StatLogin, uCallIcon);

	::UpdateWindow(m_hwnd);
}



/*  F O R C E  S T A T U S  B A R  U P D A T E  */
/*-------------------------------------------------------------------------
    %%Function: ForceStatusBarUpdate

    Force an update of the status bar.
    This can be called from any thread.
    All main UI updates should be done from the main thread.
-------------------------------------------------------------------------*/
VOID ForceStatusBarUpdate(void)
{
	CConfRoom * pcr = ::GetConfRoom();
	if (NULL != pcr)
	{
		PostMessage(pcr->GetTopHwnd(), WM_STATUSBAR_UPDATE, 0, 0);
	}
}

///////////////////////////////////////////////////////////////////////////

/*  C M D  V I E W  S T A T U S  B A R  */
/*-------------------------------------------------------------------------
    %%Function: CmdViewStatusBar
    
-------------------------------------------------------------------------*/
VOID CmdViewStatusBar(void)
{
	CConfStatusBar * pStatusBar = CConfStatusBar::GetInstance();
	if (NULL == pStatusBar)
		return;

	CConfRoom * pcr = ::GetConfRoom();
	if (NULL == pcr)
		return;
	HWND hwnd = pcr->GetTopHwnd();

	// Turn off redraws:
	::SendMessage(hwnd, WM_SETREDRAW, FALSE, 0);

	// Toggle visibility
	pStatusBar->Show(!pStatusBar->FVisible());
	::SendMessage(hwnd, WM_SETREDRAW, TRUE, 0);

	pcr->ForceWindowResize();

	UpdateUI(CRUI_STATUSBAR);
}


/*  C H E C K  M E N U _  V I E W  S T A T U S  B A R  */
/*-------------------------------------------------------------------------
    %%Function: CheckMenu_ViewStatusBar
    
-------------------------------------------------------------------------*/
BOOL CheckMenu_ViewStatusBar(HMENU hMenu)
{
	BOOL fCheck = FALSE;
	CConfStatusBar * pStatusBar = CConfStatusBar::GetInstance();
	if (NULL != pStatusBar)
	{
		fCheck = pStatusBar->FVisible();
		if (NULL != hMenu)
		{
			::CheckMenuItem(hMenu, IDM_VIEW_STATUSBAR,
				fCheck ? MF_CHECKED : MF_UNCHECKED);
		}
	}

	return fCheck;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\strings.h ===
// File: strings.h

#ifndef _STRINGS_H_
#define _STRINGS_H_

// Non-localizable strings

extern const TCHAR g_szEmpty[];
extern const TCHAR g_cszBackgroundSwitch[];

// Window Class Names
extern const TCHAR g_szButton[];
extern const TCHAR g_szEdit[];

extern const TCHAR g_szNMWindowClass[];
extern const TCHAR g_szConfRoomClass[];
extern const TCHAR g_szFloatWndClass[];
extern const TCHAR g_szPopupMsgWndClass[];
extern const TCHAR g_szRebarFrameClass[];
extern const TCHAR g_szAudioBandClass[];
extern const TCHAR g_szAudioLevelBandClass[];
extern const TCHAR g_szViewWndClass[];

extern const TCHAR g_cszSysListView[];       // SysListView32

extern const TCHAR g_cszHelpFileName[];      // conf.hlp
extern const TCHAR g_cszConfLinkExt[];       // .cnf

// Common strings from confreg.h (compiler can't pool strings across .obj files)

#undef CONFERENCING_KEY
#define CONFERENCING_KEY g_szConferencingKey
extern TCHAR * g_szConferencingKey;

#undef UI_KEY
#define UI_KEY g_szUiKey
extern TCHAR * g_szUiKey;

#undef AUDIO_KEY
#define AUDIO_KEY g_szAudioKey
extern TCHAR * g_szAudioKey;

#undef ISAPI_CLIENT_KEY
#define ISAPI_CLIENT_KEY g_szIlsKey
extern TCHAR * g_szIlsKey;

// Non-localizable strings
extern const TCHAR * g_cszEmpty;

extern const TCHAR * g_cszCallTo;           // callto:
extern const TCHAR * g_cszConfExeName;      // conf.exe

extern const TCHAR * g_cszListView;
extern const TCHAR * g_cszButton;
extern const TCHAR * g_cszEdit;
extern const TCHAR * g_cszComboBox;
extern const TCHAR * g_cszComboBoxEx;
extern const TCHAR * g_cszStatic;

#endif /* _STRINGS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\strings.cpp ===
// File: strings.cpp

#include "precomp.h"

// Non-localizable strings

const TCHAR g_szEmpty[]   = _TEXT("");
const TCHAR g_cszBackgroundSwitch[] = _TEXT("Background");

// Window Class Names
const TCHAR g_szButton[]           = _TEXT("button");
const TCHAR g_szEdit[]             = _TEXT("edit");

const TCHAR g_szNMWindowClass[]    = _TEXT("NMWindowClass");
const TCHAR g_szConfRoomClass[]    = _TEXT("MPWClass");
const TCHAR g_szFloatWndClass[]    = _TEXT("MPFloatWClass");
const TCHAR g_szPopupMsgWndClass[] = _TEXT("MPPopupMsgWClass");
const TCHAR g_szRebarFrameClass[]  = _TEXT("ConfRebarFrameClass");
const TCHAR g_szAudioBandClass[]   = _TEXT("ConfAudioBandClass");
const TCHAR g_szAudioLevelBandClass[]   = _TEXT("ConfAudioLevelBandClass");

const TCHAR g_cszSysListView[]     = TEXT("SysListView32");
//
const TCHAR g_cszHelpFileName[]    = TEXT("conf.hlp");

// Frequently used registry keys (from confreg.h)
TCHAR * g_szConferencingKey        = _TEXT("SOFTWARE\\Microsoft\\Conferencing");
TCHAR * g_szUiKey                  = _TEXT("SOFTWARE\\Microsoft\\Conferencing\\UI");
TCHAR * g_szAudioKey               = _TEXT("SOFTWARE\\Microsoft\\Conferencing\\Audio Control");
TCHAR * g_szIlsKey                 = _TEXT("Software\\Microsoft\\User Location Service\\Client");


// moved over from api/nminf
// should be merged with above strings

const TCHAR * g_cszEmpty           = TEXT("");

const TCHAR * g_cszCallTo          = TEXT("callto:");
const TCHAR * g_cszConfExeName     = TEXT("conf.exe");

const TCHAR * g_cszListView        = TEXT("SysListView32");
const TCHAR * g_cszButton          = TEXT("Button");
const TCHAR * g_cszEdit            = TEXT("Edit");
const TCHAR * g_cszComboBox        = TEXT("ComboBox");
const TCHAR * g_cszComboBoxEx      = TEXT("ComboBoxEx32");
const TCHAR * g_cszStatic          = TEXT("STATIC");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\syspol.h ===
// File: syspol.h

#ifndef _SYSPOL_H_
#define _SYSPOL_H_


class SysPol
{
protected:
	static HKEY m_hkey;

	SysPol()  {ASSERT(FALSE);}; // This isn't a normal class
	~SysPol() {};

private:
	static bool  FEnsureKeyOpen(void);
	static DWORD GetNumber(LPCTSTR pszName, DWORD dwDefault = 0);

public:
	static void CloseKey(void);

	static bool AllowDirectoryServices(void);
	static bool AllowAddingServers(void);

	static bool NoAudio(void);
	static bool NoVideoSend(void);
	static bool NoVideoReceive(void);

	static UINT GetMaximumBandwidth();  // returns 0 if no policy key
};


#endif /* _SYSPOL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\syspol.cpp ===
// File: syspol.cpp
//
// System policies
//
// This class tries to be efficient by only opening the key once
// and using KEY_QUERY_VALUE.
//
// Normally the policy keys don't exist, so the default setting is very important.

#include "precomp.h"
#include "syspol.h"

HKEY SysPol::m_hkey = NULL;


/*  F  E N S U R E  K E Y  O P E N  */
/*-------------------------------------------------------------------------
    %%Function: FEnsureKeyOpen
    
-------------------------------------------------------------------------*/
bool SysPol::FEnsureKeyOpen(void)
{
	if (NULL == m_hkey)
	{
		long lErr = ::RegOpenKeyEx(HKEY_CURRENT_USER, POLICIES_KEY, 0, KEY_QUERY_VALUE, &m_hkey);
		if (ERROR_SUCCESS != lErr)
		{
			WARNING_OUT(("FEnsureKeyOpen: problem opening system policy key. Err=%08X", lErr));
			return false;
		}
	}

	return true;
}

void SysPol::CloseKey(void)
{
	if (NULL != m_hkey)
	{
		::RegCloseKey(m_hkey);
		m_hkey = NULL;
	}
}


/*  G E T  N U M B E R  */
/*-------------------------------------------------------------------------
    %%Function: GetNumber
    
-------------------------------------------------------------------------*/
DWORD SysPol::GetNumber(LPCTSTR pszName, DWORD dwDefault)
{
	if (FEnsureKeyOpen())
	{
		DWORD dwType = REG_BINARY;
		DWORD dwValue = 0L;
		DWORD dwSize = sizeof(dwValue);
		long  lErr = ::RegQueryValueEx(m_hkey, pszName, 0, &dwType, (LPBYTE)&dwValue, &dwSize);
	
		if ((lErr == ERROR_SUCCESS) &&
		   ((REG_DWORD == dwType) ||  ((REG_BINARY == dwType) && (sizeof(dwValue) == dwSize))) )
		{
			dwDefault = dwValue;
		}
	}

	return dwDefault;
}


//////////////////////
// Positive Settings

bool SysPol::AllowDirectoryServices(void)
{
	return (0 == GetNumber(REGVAL_POL_NO_DIRECTORY_SERVICES, DEFAULT_POL_NO_DIRECTORY_SERVICES));
}

bool SysPol::AllowAddingServers(void)
{
	if (!AllowDirectoryServices())
		return FALSE;

	return (0 == GetNumber(REGVAL_POL_NO_ADDING_NEW_ULS, DEFAULT_POL_NO_ADDING_NEW_ULS));
}


//////////////////////
// Negative Settings


bool SysPol::NoAudio(void)
{
	return (0 != GetNumber(REGVAL_POL_NO_AUDIO, DEFAULT_POL_NO_AUDIO));
}

bool SysPol::NoVideoSend(void)
{
	return (0 != GetNumber(REGVAL_POL_NO_VIDEO_SEND, DEFAULT_POL_NO_VIDEO_SEND));
}

bool SysPol::NoVideoReceive(void)
{
	return (0 != GetNumber(REGVAL_POL_NO_VIDEO_RECEIVE, DEFAULT_POL_NO_VIDEO_RECEIVE));
}



UINT SysPol::GetMaximumBandwidth()
{
	UINT uRet;

	RegEntry re(POLICIES_KEY, HKEY_CURRENT_USER, FALSE);
	uRet = re.GetNumberIniStyle(REGVAL_POL_MAX_BANDWIDTH, 0);

	return uRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\t120app.cpp ===
#include "precomp.h"
#include "t120app.h"


BOOL InitAppletSDK(void)
{
    CheckStructCompatible();
    return TRUE;
}


void CleanupAppletSDK(void)
{
}


void CALLBACK T120AppletSessionCallback
(
    T120AppletSessionMsg    *pMsg
)
{
    CNmAppletSession *pSession = (CNmAppletSession *) pMsg->pSessionContext;
    if (NULL != pSession)
    {
        pSession->T120Callback(pMsg);
    }
}


void CALLBACK T120AppletCallback
(
    T120AppletMsg           *pMsg
)
{
    CNmAppletObj *pApplet = (CNmAppletObj *) pMsg->pAppletContext;
    if (NULL != pApplet)
    {
        pApplet->T120Callback(pMsg);
    }
}


//////////////////////////////////////////////////
//
//  CNmAppletSession
//

CNmAppletSession::CNmAppletSession
(
    CNmAppletObj           *pApplet,
    IT120AppletSession     *pSession,
    BOOL                    fAutoJoin
)
:
    m_cRef(1),
    m_pApplet(pApplet),
    m_pT120SessReq(NULL),
    m_pT120Session(pSession),
    m_pNotify(NULL),
    m_fAutoJoin(fAutoJoin)
{
    m_pApplet->AddRef();
    pSession->Advise(T120AppletSessionCallback, m_pApplet, this);
}


CNmAppletSession::~CNmAppletSession(void)
{
    ASSERT(0 == m_cRef);

    m_pApplet->Release();

    if (NULL != m_pT120Session)
    {
        m_pT120Session->ReleaseInterface();
        m_pT120Session = NULL;
    }
}


//////////////////////////////////////////////////
//
// IUnknown @ CNmAppletSession
//

HRESULT CNmAppletSession::QueryInterface
(
    REFIID          riid,
    void          **ppv
)
{
    if (NULL != ppv)
    {
        *ppv = NULL;

        if (riid == IID_IAppletSession || riid == IID_IUnknown)
        {
            *ppv = (IAppletSession *) this;
            AddRef();
            return S_OK;
        }

        return E_NOINTERFACE;
    }

    return E_POINTER;
}


ULONG CNmAppletSession::AddRef(void)
{
    ::InterlockedIncrement(&m_cRef);
    return (ULONG) m_cRef;
}


ULONG CNmAppletSession::Release(void)
{
    ASSERT(m_cRef > 0);

    if (::InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return (ULONG) m_cRef;
}


//////////////////////////////////////////////////
//
// Basic Info @ CNmAppletSession
//

HRESULT CNmAppletSession::GetConfID
(
    AppletConfID        *pnConfID
)
{
    if (NULL != m_pT120Session)
    {
        *pnConfID = m_pT120Session->GetConfID();

        return S_OK;
    }

    return APPLET_E_NO_SERVICE;
}


HRESULT CNmAppletSession::IsThisNodeTopProvider
(
    BOOL            *pfTopProvider
)
{
    if (NULL != m_pT120Session)
    {
        *pfTopProvider = m_pT120Session->IsThisNodeTopProvider();

        return S_OK;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Join Conference @ CNmAppletSession
//

HRESULT CNmAppletSession::Join
(
    AppletSessionRequest    *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            if (NULL == m_pT120SessReq)
            {
                m_pT120SessReq = ::AllocateJoinSessionRequest(pRequest);
                if (NULL != m_pT120SessReq)
                {
                    T120Error rc = m_pT120Session->Join(m_pT120SessReq);
                    ASSERT(T120_NO_ERROR == rc);

                    if (T120_NO_ERROR == rc)
                    {
                        return S_OK;
                    }

                    ::FreeJoinSessionRequest(m_pT120SessReq);
                    m_pT120SessReq = NULL;

                    return APPLET_E_SERVICE_FAIL;
                }

                return APPLET_E_INVALID_JOIN_REQUEST;
            }

            return APPLET_E_ALREADY_JOIN;
        }

        return APPLET_E_NO_SERVICE;

    }
    return APPLET_E_NOT_ADVISED;
}


HRESULT CNmAppletSession::Leave(void)
{
    if (NULL != m_pT120Session)
    {
        if (m_fAutoJoin)
        {
            m_pT120Session->Leave();
            m_fAutoJoin = FALSE;

            return S_OK;
        }
        else
        if (NULL != m_pT120SessReq)
        {
            m_pT120Session->Leave();

            ::FreeJoinSessionRequest(m_pT120SessReq);
            m_pT120SessReq = NULL;

            return S_OK;
        }

        return APPLET_E_NOT_JOINED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Send Data @ CNmAppletSession
//

HRESULT CNmAppletSession::SendData
(
    BOOL               fUniformSend,
    AppletChannelID    nChannelID,
    AppletPriority     ePriority,
    ULONG              cbBufSize,
    BYTE              *pBuffer // size_is(cbBufSize)
)
{
    if (NULL != m_pT120Session)
    {
        if (cbBufSize && NULL != pBuffer)
        {
            T120Error rc = m_pT120Session->SendData(
                                    fUniformSend ? UNIFORM_SEND_DATA : NORMAL_SEND_DATA,
                                    nChannelID,
                                    ePriority,
                                    pBuffer,
                                    cbBufSize,
                                    APP_ALLOCATION);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return E_INVALIDARG;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Invoke Applet @ CNmAppletSession
//

HRESULT CNmAppletSession::InvokeApplet
(
    AppletRequestTag      *pnReqTag,
    AppletProtocolEntity  *pAPE,
    ULONG                  cNodes,
    AppletNodeID           aNodeIDs[] // size_is(cNodes)
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            if (NULL != pAPE && NULL != pnReqTag)
            {
                // set up node list
                GCCSimpleNodeList NodeList;
                NodeList.cNodes = cNodes;
                NodeList.aNodeIDs = aNodeIDs;

                // set up ape list
                GCCAppProtEntityList APEList;
                APEList.cApes = 1;
                APEList.apApes = (T120APE **) &pAPE;

                T120Error rc = m_pT120Session->InvokeApplet(&APEList, &NodeList, pnReqTag);
                ASSERT(T120_NO_ERROR == rc);

                return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
            }

            return E_POINTER;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Inquiry @ CNmAppletSession
//

HRESULT CNmAppletSession::InquireRoster
(
    AppletSessionKey    *pSessionKey
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120Error rc = m_pT120Session->InquireRoster((T120SessionKey *) pSessionKey);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Registry Services @ CNmAppletSession
//

HRESULT CNmAppletSession::RegistryRequest
(
    AppletRegistryRequest   *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120RegistryRequest reg_req;
            ::AppletRegistryRequestToT120One(pRequest, &reg_req);

            T120Error rc = m_pT120Session->RegistryRequest(&reg_req);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Channel Services @ CNmAppletSession
//

HRESULT CNmAppletSession::ChannelRequest
(
    AppletChannelRequest    *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120Error rc = m_pT120Session->ChannelRequest((T120ChannelRequest *) pRequest);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Token Services @ CNmAppletSession
//

HRESULT CNmAppletSession::TokenRequest
(
    AppletTokenRequest      *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Session)
        {
            T120Error rc = m_pT120Session->TokenRequest((T120TokenRequest *) pRequest);
            ASSERT(T120_NO_ERROR == rc);

            return (T120_NO_ERROR == rc) ? S_OK : APPLET_E_SERVICE_FAIL;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


//////////////////////////////////////////////////
//
// Notification @ CNmAppletSession
//

HRESULT CNmAppletSession::Advise
(
    IAppletSessionNotify    *pNotify,
    DWORD                   *pdwCookie
)
{
    if (NULL != m_pT120Session)
    {
        if (NULL == m_pNotify)
        {
            if (NULL != pNotify && NULL != pdwCookie)
            {
                pNotify->AddRef();
                m_pNotify = pNotify;
                m_pSessionObj = this;
                *pdwCookie = 1;

                return S_OK;
            }

            return E_POINTER;
        }

        return APPLET_E_ALREADY_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


HRESULT CNmAppletSession::UnAdvise
(
    DWORD           dwCookie
)
{
    if (NULL != m_pT120Session)
    {
        if (NULL != m_pNotify)
        {
            if (dwCookie == 1 && m_pSessionObj == this)
            {
                m_pNotify->Release();
                m_pNotify = NULL;

                return S_OK;
            }

            return APPLET_E_INVALID_COOKIE;
        }

        return APPLET_E_NOT_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// T120 Applet Session Callback @ CNmAppletSession
//

void CNmAppletSession::T120Callback
(
    T120AppletSessionMsg    *pMsg
)
{
    HRESULT hrNotify;
    HRESULT hrResult;
    IAppletSession *pAppletSession;
    T120ChannelID *aChannelIDs;
    AppletOctetString ostr;
    AppletRegistryCommand eRegistryCommand;
    AppletTokenCommand eTokenCommand;
    AppletRegistryItem RegItem;
    AppletRegistryItem *pRegItem;
    AppletRegistryEntryOwner EntryOwner;

    if (NULL != m_pNotify)
    {
        switch (pMsg->eMsgType)
        {
        //
        // Join Session
        //
        case T120_JOIN_SESSION_CONFIRM:
            hrResult = APPLET_E_SERVICE_FAIL;
            pAppletSession = NULL;
            aChannelIDs = NULL;
            if (T120_RESULT_SUCCESSFUL == pMsg->JoinSessionConfirm.eResult &&
                T120_NO_ERROR          == pMsg->JoinSessionConfirm.eError)
            {
                hrResult = S_OK;
                if (pMsg->JoinSessionConfirm.cResourceReqs)
                {
                    aChannelIDs = new T120ChannelID[pMsg->JoinSessionConfirm.cResourceReqs];
                    if (NULL != aChannelIDs)
                    {
                        for (ULONG i = 0; i < pMsg->JoinSessionConfirm.cResourceReqs; i++)
                        {
                            aChannelIDs[i] = pMsg->JoinSessionConfirm.aResourceReqs[i].nChannelID;
                        }
                    }
                    else
                    {
                        ASSERT(NULL != aChannelIDs);
                        hrResult = E_OUTOFMEMORY;
                    }
                }
            }
            if (S_OK == hrResult)
            {
                hrNotify = m_pNotify->JoinSessionConfirm(
                                hrResult,
                                pMsg->JoinSessionConfirm.uidMyself,
                                pMsg->JoinSessionConfirm.nidMyself,
                                pMsg->JoinSessionConfirm.sidMyself,
                                pMsg->JoinSessionConfirm.eidMyself,
                                pMsg->JoinSessionConfirm.cResourceReqs,
                                aChannelIDs);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                hrNotify = m_pNotify->JoinSessionConfirm(hrResult, 0, 0, 0, 0, 0, NULL);
                ASSERT(SUCCEEDED(hrNotify));
            }
            delete [] aChannelIDs;
            break;

        //
        // Detach User
        //
        case MCS_DETACH_USER_INDICATION:
            hrNotify = m_pNotify->LeaveSessionIndication(::GetAppletReason(pMsg->DetachUserInd.eReason),
                                              pMsg->DetachUserInd.nUserID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Send Data
        //
        case MCS_SEND_DATA_INDICATION:
        case MCS_UNIFORM_SEND_DATA_INDICATION:
            ostr.cbStrSize = pMsg->SendDataInd.user_data.length;
            ostr.pbValue = pMsg->SendDataInd.user_data.value;
            hrNotify = m_pNotify->SendDataIndication(MCS_UNIFORM_SEND_DATA_INDICATION == pMsg->eMsgType,
                                          pMsg->SendDataInd.initiator,
                                          pMsg->SendDataInd.channel_id,
                                          (AppletPriority) pMsg->SendDataInd.data_priority,
                                          ostr);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Roster
        //
        case GCC_APP_ROSTER_REPORT_INDICATION:
            hrNotify = m_pNotify->RosterReportIndication((ULONG) pMsg->AppRosterReportInd.cRosters,
                                              (AppletRoster **) pMsg->AppRosterReportInd.apAppRosters);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case GCC_APP_ROSTER_INQUIRE_CONFIRM:
            hrNotify = m_pNotify->InquireRosterConfirm(::GetHrResult(pMsg->AppRosterInquireConfirm.nResult),
                                            (ULONG) pMsg->AppRosterInquireConfirm.cRosters,
                                            (AppletRoster **) pMsg->AppRosterInquireConfirm.apAppRosters);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Applet Invoke
        //
        case GCC_APPLICATION_INVOKE_CONFIRM:
            hrNotify = m_pNotify->InvokeAppletConfirm(pMsg->AppInvokeConfirm.nReqTag,
                                           ::GetHrResult(pMsg->AppInvokeConfirm.nResult));
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Registry
        //
        case GCC_REGISTER_CHANNEL_CONFIRM:
            eRegistryCommand = APPLET_REGISTER_CHANNEL;
          RegistryCommon_1:
            if (NULL != pMsg->RegistryConfirm.pRegItem)
            {
                pRegItem = (AppletRegistryItem *) pMsg->RegistryConfirm.pRegItem;
            }
            else
            {
                ::ZeroMemory(&RegItem, sizeof(RegItem));
                pRegItem = &RegItem;
            }
            hrNotify = m_pNotify->RegistryConfirm(eRegistryCommand,
                                       ::GetHrResult(pMsg->RegistryConfirm.nResult),
                                        (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                        pRegItem,
                                        (AppletRegistryEntryOwner *) &pMsg->RegistryConfirm.EntryOwner,
                                        pMsg->RegistryConfirm.eRights);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
            eRegistryCommand = APPLET_ASSIGN_TOKEN;
            goto RegistryCommon_1;

        case GCC_SET_PARAMETER_CONFIRM:
            eRegistryCommand = APPLET_SET_PARAMETER;
            goto RegistryCommon_1;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
            hrResult = ::GetHrResult(pMsg->RegistryConfirm.nResult);
            if (GCC_RESULT_SUCCESSFUL == pMsg->RegistryConfirm.nResult)
            {
                if (NULL != pMsg->RegistryConfirm.pRegItem)
                {
                    pRegItem = (AppletRegistryItem *) pMsg->RegistryConfirm.pRegItem;
                }
                else
                {
                    ::ZeroMemory(&RegItem, sizeof(RegItem));
                    pRegItem = &RegItem;
                }
                hrNotify = m_pNotify->RegistryConfirm(APPLET_RETRIEVE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           pRegItem,
                                           (AppletRegistryEntryOwner *) &pMsg->RegistryConfirm.EntryOwner,
                                           pMsg->RegistryConfirm.eRights);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                ::ZeroMemory(&RegItem, sizeof(RegItem));
                ::ZeroMemory(&EntryOwner, sizeof(EntryOwner));
                hrNotify = m_pNotify->RegistryConfirm(APPLET_RETRIEVE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           &RegItem,
                                           &EntryOwner,
                                           APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED);
                ASSERT(SUCCEEDED(hrNotify));
            }
            break;

        case GCC_DELETE_ENTRY_CONFIRM:
            hrResult = ::GetHrResult(pMsg->RegistryConfirm.nResult);
            if (GCC_RESULT_INDEX_ALREADY_OWNED == pMsg->RegistryConfirm.nResult)
            {
                if (NULL != pMsg->RegistryConfirm.pRegItem)
                {
                    pRegItem = (AppletRegistryItem *) pMsg->RegistryConfirm.pRegItem;
                }
                else
                {
                    ::ZeroMemory(&RegItem, sizeof(RegItem));
                    pRegItem = &RegItem;
                }
                hrNotify = m_pNotify->RegistryConfirm(APPLET_DELETE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           pRegItem,
                                           (AppletRegistryEntryOwner *) &pMsg->RegistryConfirm.EntryOwner,
                                           pMsg->RegistryConfirm.eRights);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                ::ZeroMemory(&RegItem, sizeof(RegItem));
                ::ZeroMemory(&EntryOwner, sizeof(EntryOwner));
                hrNotify = m_pNotify->RegistryConfirm(APPLET_DELETE_ENTRY,
                                           hrResult,
                                           (AppletRegistryKey *) pMsg->RegistryConfirm.pRegKey,
                                           &RegItem,
                                           &EntryOwner,
                                           APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED);
                ASSERT(SUCCEEDED(hrNotify));
            }
            break;

        case GCC_ALLOCATE_HANDLE_CONFIRM:
            hrNotify = m_pNotify->AllocateHandleConfirm(::GetHrResult(pMsg->RegAllocHandleConfirm.nResult),
                                             pMsg->RegAllocHandleConfirm.nFirstHandle,
                                             pMsg->RegAllocHandleConfirm.cHandles);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Channel
        //
        case MCS_CHANNEL_JOIN_CONFIRM:
            hrNotify = m_pNotify->ChannelConfirm(APPLET_JOIN_CHANNEL,
                                      ::GetHrResult(pMsg->ChannelConfirm.eResult),
                                      pMsg->ChannelConfirm.nChannelID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_CONVENE_CONFIRM:
            hrNotify = m_pNotify->ChannelConfirm(APPLET_CONVENE_CHANNEL,
                                      ::GetHrResult(pMsg->ChannelConfirm.eResult),
                                      pMsg->ChannelConfirm.nChannelID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_LEAVE_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_LEAVE_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         ::GetAppletReason(pMsg->ChannelInd.eReason),
                                         0);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_DISBAND_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_DISBAND_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         ::GetAppletReason(pMsg->ChannelInd.eReason),
                                         0);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_ADMIT_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_ADMIT_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         APPLET_R_UNSPECIFIED,
                                         pMsg->ChannelInd.nManagerID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_CHANNEL_EXPEL_INDICATION:
            hrNotify = m_pNotify->ChannelIndication(APPLET_EXPEL_CHANNEL,
                                         pMsg->ChannelInd.nChannelID,
                                         ::GetAppletReason(pMsg->ChannelInd.eReason),
                                         0);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        //
        // Token
        //
        case MCS_TOKEN_GRAB_CONFIRM:
            eTokenCommand = APPLET_GRAB_TOKEN;
        Token_Common_1:
            hrNotify = m_pNotify->TokenConfirm(eTokenCommand,
                                    ::GetHrResult(pMsg->TokenConfirm.eResult),
                                    pMsg->TokenConfirm.nTokenID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_INHIBIT_CONFIRM:
            eTokenCommand = APPLET_INHIBIT_TOKEN;
            goto Token_Common_1;

        case MCS_TOKEN_GIVE_CONFIRM:
            eTokenCommand = APPLET_GIVE_TOKEN;
            goto Token_Common_1;

        case MCS_TOKEN_RELEASE_CONFIRM:
            eTokenCommand = APPLET_RELEASE_TOKEN;
            goto Token_Common_1;

        case MCS_TOKEN_TEST_CONFIRM:
            hrNotify = m_pNotify->TestTokenConfirm(pMsg->TokenConfirm.nTokenID,
                                        pMsg->TokenConfirm.eTokenStatus);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_GIVE_INDICATION:
            hrNotify = m_pNotify->TokenIndication(APPLET_GIVE_TOKEN,
                                       APPLET_R_UNSPECIFIED,
                                       pMsg->TokenInd.nTokenID,
                                       pMsg->TokenInd.nUserID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_PLEASE_INDICATION:
            hrNotify = m_pNotify->TokenIndication(APPLET_PLEASE_TOKEN,
                                       APPLET_R_UNSPECIFIED,
                                       pMsg->TokenInd.nTokenID,
                                       pMsg->TokenInd.nUserID);
            ASSERT(SUCCEEDED(hrNotify));
            break;

        case MCS_TOKEN_RELEASE_INDICATION:
            hrNotify = m_pNotify->TokenIndication(APPLET_RELEASE_TOKEN,
                                       ::GetAppletReason(pMsg->TokenInd.eReason),
                                       pMsg->TokenInd.nTokenID,
                                       0);
            ASSERT(SUCCEEDED(hrNotify));
            break;
        } // switch
    } // if
}


HRESULT GetHrResult(T120Result rc)
{
    HRESULT hrResult;
    switch (rc)
    {
    case T120_RESULT_SUCCESSFUL:
        hrResult = S_OK;
        break;
    case GCC_RESULT_ENTRY_ALREADY_EXISTS:
        hrResult = APPLET_E_ENTRY_ALREADY_EXISTS;
        break;
    case GCC_RESULT_ENTRY_DOES_NOT_EXIST:
        hrResult = APPLET_E_ENTRY_DOES_NOT_EXIST;
        break;
    case GCC_RESULT_INDEX_ALREADY_OWNED:
        hrResult = APPLET_E_NOT_OWNER;
        break;
    default:
        hrResult = APPLET_E_SERVICE_FAIL;
        break;
    }
    return hrResult;
}


AppletReason GetAppletReason(T120Reason rc)
{
    AppletReason eAppletReason;
    switch (rc)
    {
    case REASON_USER_REQUESTED:
        eAppletReason = APPLET_R_USER_REJECTED;
        break;
    case REASON_DOMAIN_DISCONNECTED:
    case REASON_PROVIDER_INITIATED:
        eAppletReason = APPLET_R_CONFERENCE_GONE;
        break;
    case REASON_TOKEN_PURGED:
    case REASON_CHANNEL_PURGED:
        eAppletReason = APPLET_R_RESOURCE_PURGED;
        break;
    default:
        eAppletReason = APPLET_R_UNSPECIFIED;
        break;
    }
    return eAppletReason;
}


//////////////////////////////////////////////////
//
// CNmAppletObj
//

CNmAppletObj::CNmAppletObj(void)
:
    m_cRef(0),
    m_pT120Applet(NULL),
    m_pT120AutoJoinReq(NULL),
    m_pNotify(NULL),
    m_nPendingConfID(0)
{
}


CNmAppletObj::~CNmAppletObj(void)
{
    ASSERT(0 == m_cRef);

    if (NULL != m_pT120Applet)
    {
        m_pT120Applet->ReleaseInterface();
        m_pT120Applet = NULL;
    }

    ::FreeJoinSessionRequest(m_pT120AutoJoinReq);
}


HRESULT CNmAppletObj::Initialize(void)
{
    T120Error rc = ::T120_CreateAppletSAP(&m_pT120Applet);
    if (T120_NO_ERROR == rc)
    {
        m_pT120Applet->Advise(T120AppletCallback, this);
        return S_OK;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Auto Join @ CNmAppletObj
//

HRESULT CNmAppletObj::RegisterAutoJoin
(
    AppletSessionRequest    *pRequest
)
{
    if (NULL != m_pNotify)
    {
        if (NULL != m_pT120Applet)
        {
            if (NULL != pRequest)
            {
                if (NULL == m_pT120AutoJoinReq)
                {
                    m_pT120AutoJoinReq = ::AllocateJoinSessionRequest(pRequest);
                    if (NULL != m_pT120AutoJoinReq)
                    {
                        T120Error rc = m_pT120Applet->RegisterAutoJoin(m_pT120AutoJoinReq);
                        ASSERT(T120_NO_ERROR == rc);

                        if (T120_NO_ERROR == rc)
                        {
                            return S_OK;
                        }

                        ::FreeJoinSessionRequest(m_pT120AutoJoinReq);
                        m_pT120AutoJoinReq = NULL;

                        return APPLET_E_SERVICE_FAIL;
                    }

                    return APPLET_E_INVALID_JOIN_REQUEST;
                }

                return APPLET_E_ALREADY_REGISTERED;
            }

            return E_POINTER;
        }

        return APPLET_E_NO_SERVICE;
    }

    return APPLET_E_NOT_ADVISED;
}


HRESULT CNmAppletObj::UnregisterAutoJoin(void)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL != m_pT120AutoJoinReq)
        {
            m_pT120Applet->UnregisterAutoJoin();

            ::FreeJoinSessionRequest(m_pT120AutoJoinReq);
            m_pT120AutoJoinReq = NULL;

            return S_OK;
        }

        return APPLET_E_NOT_REGISTERED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Session @ CNmAppletObj
//

HRESULT CNmAppletObj::CreateSession
(
    IAppletSession    **ppSession,
    AppletConfID        nConfID
)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL != ppSession)
        {
            *ppSession = NULL;

            if (nConfID)
            {
                IT120AppletSession *pT120Session = NULL;
                T120Error rc = m_pT120Applet->CreateSession(&pT120Session, nConfID);
                if (T120_NO_ERROR == rc)
                {
                    *ppSession = (IAppletSession *) new CNmAppletSession(this, pT120Session);
                    if (NULL != *ppSession)
                    {
                        return S_OK;
                    }

                    pT120Session->ReleaseInterface();
                    return E_OUTOFMEMORY;
                }

                return APPLET_E_SERVICE_FAIL;
            }

            return APPLET_E_INVALID_CONFERENCE;
        }

        return E_POINTER;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// Notification @ CNmAppletObj
//

HRESULT CNmAppletObj::Advise
(
    IAppletNotify       *pNotify,
    DWORD               *pdwCookie
)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL == m_pNotify)
        {
            if (NULL != pNotify && NULL != pdwCookie)
            {
                pNotify->AddRef();
                m_pNotify = pNotify;
                m_pAppletObj = this;
                *pdwCookie = 1;

                if (m_nPendingConfID)
                {
                    m_pNotify->PermitToJoinSessionIndication(m_nPendingConfID, TRUE);
                    m_nPendingConfID = 0;
                }

                return S_OK;
            }

            return E_POINTER;
        }

        return APPLET_E_ALREADY_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


HRESULT CNmAppletObj::UnAdvise
(
    DWORD               dwCookie
)
{
    if (NULL != m_pT120Applet)
    {
        if (NULL != m_pNotify)
        {
            if (dwCookie == 1 && m_pAppletObj == this)
            {
                m_pNotify->Release();
                m_pNotify = NULL;

                return S_OK;
            }

            return APPLET_E_INVALID_COOKIE;
        }

        return APPLET_E_NOT_ADVISED;
    }

    return APPLET_E_NO_SERVICE;
}


//////////////////////////////////////////////////
//
// T120 Applet @ CNmAppletObj
//

void CNmAppletObj::T120Callback
(
    T120AppletMsg           *pMsg
)
{
    HRESULT hrNotify;
    HRESULT hrResult;
    IAppletSession *pAppletSession;
    T120ChannelID *aChannelIDs;

    if (NULL != m_pNotify)
    {
        switch (pMsg->eMsgType)
        {
        case GCC_PERMIT_TO_ENROLL_INDICATION:
            ASSERT(0 == m_nPendingConfID);
            hrNotify = m_pNotify->PermitToJoinSessionIndication(
                                pMsg->PermitToEnrollInd.nConfID,
                                pMsg->PermitToEnrollInd.fPermissionGranted);
            ASSERT(SUCCEEDED(hrNotify));
            break;
        case T120_JOIN_SESSION_CONFIRM:
            hrResult = APPLET_E_SERVICE_FAIL;
            pAppletSession = NULL;
            aChannelIDs = NULL;
            if (T120_RESULT_SUCCESSFUL == pMsg->AutoJoinSessionInd.eResult &&
                T120_NO_ERROR          == pMsg->AutoJoinSessionInd.eError)
            {
                hrResult = S_OK;
                if (pMsg->AutoJoinSessionInd.cResourceReqs)
                {
                    aChannelIDs = new T120ChannelID[pMsg->AutoJoinSessionInd.cResourceReqs];
                    if (NULL != aChannelIDs)
                    {
                        for (ULONG i = 0; i < pMsg->AutoJoinSessionInd.cResourceReqs; i++)
                        {
                            aChannelIDs[i] = pMsg->AutoJoinSessionInd.aResourceReqs[i].nChannelID;
                        }
                    }
                    else
                    {
                        ASSERT(NULL != aChannelIDs);
                        hrResult = E_OUTOFMEMORY;
                    }
                }

                if (S_OK == hrResult)
                {
                    ASSERT(NULL != pMsg->AutoJoinSessionInd.pIAppletSession);
                    pAppletSession = new CNmAppletSession(this, pMsg->AutoJoinSessionInd.pIAppletSession, TRUE);
                    ASSERT(NULL != pAppletSession);

                    hrResult = (NULL != pAppletSession) ? S_OK : E_OUTOFMEMORY;
                }
            }

            if (S_OK == hrResult)
            {
                hrNotify = m_pNotify->AutoJoinSessionIndication(
                                pAppletSession,
                                hrResult,
                                pMsg->AutoJoinSessionInd.uidMyself,
                                pMsg->AutoJoinSessionInd.nidMyself,
                                pMsg->AutoJoinSessionInd.sidMyself,
                                pMsg->AutoJoinSessionInd.eidMyself,
                                pMsg->AutoJoinSessionInd.cResourceReqs,
                                aChannelIDs);
                ASSERT(SUCCEEDED(hrNotify));
            }
            else
            {
                hrNotify = m_pNotify->AutoJoinSessionIndication(NULL, hrResult, 0, 0, 0, 0, 0, NULL);
                ASSERT(SUCCEEDED(hrNotify));

                if (NULL != pMsg->AutoJoinSessionInd.pIAppletSession)
                {
                    pMsg->AutoJoinSessionInd.pIAppletSession->ReleaseInterface();
                }
            }

            delete [] aChannelIDs;
            break;
        } // switch
    }
    else
    {
        // free memory for unwanted message
        if (T120_JOIN_SESSION_CONFIRM == pMsg->eMsgType &&
            T120_RESULT_SUCCESSFUL    == pMsg->AutoJoinSessionInd.eResult &&
            T120_NO_ERROR             == pMsg->AutoJoinSessionInd.eError)
        {
            if (NULL != pMsg->AutoJoinSessionInd.pIAppletSession)
            {
                pMsg->AutoJoinSessionInd.pIAppletSession->ReleaseInterface();
            }
        }
        else
        if (GCC_PERMIT_TO_ENROLL_INDICATION == pMsg->eMsgType)
        {
            if (pMsg->PermitToEnrollInd.fPermissionGranted)
            {
                m_nPendingConfID = pMsg->PermitToEnrollInd.nConfID;
            }
            else
            {
                if (m_nPendingConfID == pMsg->PermitToEnrollInd.nConfID)
                {
                    m_nPendingConfID = 0;
                }
            }
        }
    }
}


//////////////////////////////////////////////////
//
// Join Session Request
//

T120JoinSessionRequest * AllocateJoinSessionRequest
(
    AppletSessionRequest    *pAppletRequest
)
{
    T120JoinSessionRequest *pT120One = new T120JoinSessionRequest;
    if (NULL != pT120One)
    {
        ::ZeroMemory(pT120One, sizeof(*pT120One));

        ULONG i;

        pT120One->dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS;

        if (! ::DuplicateSessionKey(&pT120One->SessionKey, (T120SessionKey *) &pAppletRequest->SessionKey))
        {
            goto MyError;
        }

        pT120One->fConductingCapable = FALSE;

        pT120One->nStartupChannelType = pAppletRequest->nStartupChannelType;

        if (::ConvertNonCollapsedCaps(&pT120One->apNonCollapsedCaps,
                                      pAppletRequest->apNonCollapsedCaps,
                                      pAppletRequest->cNonCollapsedCaps))
        {
            pT120One->cNonCollapsedCaps = pAppletRequest->cNonCollapsedCaps;
        }
        else
        {
            goto MyError;
        }

        if (::ConvertCollapsedCaps(&pT120One->apCollapsedCaps,
                                   pAppletRequest->apCollapsedCaps,
                                   pAppletRequest->cCollapsedCaps))
        {
            pT120One->cCollapsedCaps = pAppletRequest->cCollapsedCaps;
        }
        else
        {
            goto MyError;
        }

        if (0 != (pT120One->cStaticChannels = pAppletRequest->cStaticChannels))
        {
            pT120One->aStaticChannels = new T120ChannelID[pT120One->cStaticChannels];
            if (NULL != pT120One->aStaticChannels)
            {
                ::CopyMemory(pT120One->aStaticChannels,
                             pAppletRequest->aStaticChannels,
                             pT120One->cStaticChannels * sizeof(T120ChannelID));
            }
            else
            {
                goto MyError;
            }
        }

        if (0 != (pT120One->cResourceReqs = pAppletRequest->cDynamicChannels))
        {
            if (NULL != (pT120One->aResourceReqs = new T120ResourceRequest[pT120One->cResourceReqs]))
            {
                ::ZeroMemory(pT120One->aResourceReqs, pT120One->cResourceReqs * sizeof(T120ResourceRequest));
                for (i = 0; i < pT120One->cResourceReqs; i++)
                {
                    pT120One->aResourceReqs[i].eCommand = APPLET_JOIN_DYNAMIC_CHANNEL;
                    if (! ::DuplicateRegistryKey(&pT120One->aResourceReqs[i].RegKey,
                                                 (T120RegistryKey *) &pAppletRequest->aChannelRegistryKeys[i]))
                    {
                        goto MyError;
                    }
                }
            }
            else
            {
                goto MyError;
            }
        }

        return pT120One;
    }

MyError:

    ::FreeJoinSessionRequest(pT120One);
    return NULL;
}


void FreeJoinSessionRequest
(
    T120JoinSessionRequest  *pT120One
)
{
    if (NULL != pT120One)
    {
        ::FreeSessionKey(&pT120One->SessionKey);

        ::FreeNonCollapsedCaps(pT120One->apNonCollapsedCaps, pT120One->cNonCollapsedCaps);

        ::FreeCollapsedCaps(pT120One->apCollapsedCaps, pT120One->cCollapsedCaps);

        if (pT120One->cStaticChannels)
        {
            delete [] pT120One->aStaticChannels;
        }

        if (pT120One->cResourceReqs)
        {
            for (ULONG i = 0; i < pT120One->cResourceReqs; i++)
            {
                ::FreeRegistryKey(&pT120One->aResourceReqs[i].RegKey);
            }
            delete [] pT120One->aResourceReqs;
        }

        delete pT120One;
    }
}


BOOL ConvertCollapsedCaps(T120AppCap ***papDst, AppletCapability **apSrc, ULONG cItems)
{
    if (cItems)
    {
        T120AppCap **arr_ptr;
        ULONG cbTotalSize = cItems * (sizeof(T120AppCap*) + sizeof(T120AppCap));
        if (NULL != (arr_ptr = (T120AppCap**) new BYTE[cbTotalSize]))
        {
            ::ZeroMemory(arr_ptr, cbTotalSize);
            T120AppCap *arr_obj = (T120AppCap *) (arr_ptr + cItems);
            for (ULONG i = 0; i < cItems; i++)
            {
                arr_ptr[i] = &arr_obj[i];
                if (! ::DuplicateCollapsedCap(arr_ptr[i], (T120AppCap *) apSrc[i]))
                {
                    ::FreeCollapsedCaps(arr_ptr, cItems);
                    return FALSE;
                }
            }
        }

        *papDst = arr_ptr;
        return (NULL != arr_ptr);
    }

    *papDst = NULL;
    return TRUE;
}

void FreeCollapsedCaps(T120AppCap **apDst, ULONG cItems)
{
    if (cItems && NULL != apDst)
    {
        T120AppCap **arr_ptr = apDst;
        T120AppCap *arr_obj = (T120AppCap *) (arr_ptr + cItems);
        for (ULONG i = 0; i < cItems; i++)
        {
            ::FreeCollapsedCap(&arr_obj[i]);
        }
        delete [] (LPBYTE) arr_ptr;
    }
}


BOOL DuplicateCollapsedCap(T120AppCap *pDst, T120AppCap *pSrc)
{
    pDst->number_of_entities = pSrc->number_of_entities;
    pDst->capability_class = pSrc->capability_class; // no memory allocation
    return ::DuplicateCapID(&pDst->capability_id, &pSrc->capability_id);
}

void FreeCollapsedCap(T120AppCap *pDst)
{
    ::FreeCapID(&pDst->capability_id);
}


BOOL DuplicateCapID(T120CapID *pDst, T120CapID *pSrc)
{
    pDst->capability_id_type = pSrc->capability_id_type;
    switch (pDst->capability_id_type)
    {
    case GCC_STANDARD_CAPABILITY:
        pDst->standard_capability = pSrc->standard_capability;
        return TRUE;
    case GCC_NON_STANDARD_CAPABILITY:
        return ::DuplicateObjectKey(&pDst->non_standard_capability, &pSrc->non_standard_capability);
    }
    return FALSE;
}

void FreeCapID(T120CapID *pDst)
{
    switch (pDst->capability_id_type)
    {
    case GCC_NON_STANDARD_CAPABILITY:
        ::FreeObjectKey(&pDst->non_standard_capability);
        break;
    }
}


BOOL ConvertNonCollapsedCaps(T120NonCollCap ***papDst, AppletCapability2 **apSrc, ULONG cItems)
{
    if (cItems)
    {
        T120NonCollCap **arr_ptr;
        ULONG cbTotalSize = cItems * (sizeof(T120NonCollCap*) + sizeof(T120NonCollCap));
        if (NULL != (arr_ptr = (T120NonCollCap**) new BYTE[cbTotalSize]))
        {
            ::ZeroMemory(arr_ptr, cbTotalSize);
            T120NonCollCap *arr_obj = (T120NonCollCap *) (arr_ptr + cItems);
            for (ULONG i = 0; i < cItems; i++)
            {
                arr_ptr[i] = &arr_obj[i];
                if (! ::DuplicateNonCollapsedCap(arr_ptr[i], (T120NonCollCap *) apSrc[i]))
                {
                    ::FreeNonCollapsedCaps(arr_ptr, cItems);
                    return FALSE;
                }
            }
        }

        *papDst = arr_ptr;
        return (NULL != arr_ptr);
    }

    *papDst = NULL;
    return TRUE;
}

void FreeNonCollapsedCaps(T120NonCollCap **apDst, ULONG cItems)
{
    if (cItems && NULL != apDst)
    {
        T120NonCollCap **arr_ptr = apDst;
        T120NonCollCap *arr_obj = (T120NonCollCap *) (arr_ptr + cItems);
        for (ULONG i = 0; i < cItems; i++)
        {
            ::FreeNonCollapsedCap(&arr_obj[i]);
        }
        delete [] (LPBYTE) arr_ptr;
    }
}


BOOL DuplicateNonCollapsedCap(T120NonCollCap *pDst, T120NonCollCap *pSrc)
{
    if (::DuplicateCapID(&pDst->capability_id, &pSrc->capability_id))
    {
        if (NULL == pSrc->application_data)
        {
            return TRUE;
        }

        if (NULL != (pDst->application_data = new OSTR))
        {
            return ::DuplicateOSTR(pDst->application_data, pSrc->application_data);
        }
    }
    return FALSE;
}

void FreeNonCollapsedCap(T120NonCollCap *pDst)
{
    ::FreeCapID(&pDst->capability_id);

    if (NULL != pDst->application_data)
    {
        ::FreeOSTR(pDst->application_data);
        delete pDst->application_data;
    }
}


BOOL DuplicateRegistryKey(T120RegistryKey *pDst, T120RegistryKey *pSrc)
{
    if (::DuplicateSessionKey(&pDst->session_key, &pSrc->session_key))
    {
        return ::DuplicateOSTR(&pDst->resource_id, &pSrc->resource_id);
    }
    return FALSE;
}

void FreeRegistryKey(T120RegistryKey *pDst)
{
    ::FreeSessionKey(&pDst->session_key);
    ::FreeOSTR(&pDst->resource_id);
}


BOOL DuplicateSessionKey(T120SessionKey *pDst, T120SessionKey *pSrc)
{
    pDst->session_id = pSrc->session_id;
    return ::DuplicateObjectKey(&pDst->application_protocol_key, &pSrc->application_protocol_key);
}

void FreeSessionKey(T120SessionKey *pDst)
{
    ::FreeObjectKey(&pDst->application_protocol_key);
}


BOOL DuplicateObjectKey(T120ObjectKey *pDst, T120ObjectKey *pSrc)
{
    pDst->key_type = pSrc->key_type;
    switch (pDst->key_type)
    {
    case GCC_OBJECT_KEY:
        pDst->object_id.long_string_length = pSrc->object_id.long_string_length;
        if (pSrc->object_id.long_string_length && NULL != pSrc->object_id.long_string)
        {
            if (NULL != (pDst->object_id.long_string = new ULONG[pDst->object_id.long_string_length]))
            {
                ::CopyMemory(pDst->object_id.long_string,
                             pSrc->object_id.long_string,
                             pDst->object_id.long_string_length * sizeof(ULONG));
                return TRUE;
            }
        }
        break;
    case GCC_H221_NONSTANDARD_KEY:
        return ::DuplicateOSTR(&pDst->h221_non_standard_id, &pSrc->h221_non_standard_id);
    }
    return FALSE;
}


void FreeObjectKey(T120ObjectKey *pDst)
{
    switch (pDst->key_type)
    {
    case GCC_OBJECT_KEY:
        if (pDst->object_id.long_string_length)
        {
            delete [] pDst->object_id.long_string;
        }
        break;
    case GCC_H221_NONSTANDARD_KEY:
        ::FreeOSTR(&pDst->h221_non_standard_id);
        break;
    }
}


BOOL DuplicateOSTR(OSTR *pDst, OSTR *pSrc)
{
    if (pSrc->length && NULL != pSrc->value)
    {
        pDst->length = pSrc->length;
        if (NULL != (pDst->value = new BYTE[pDst->length]))
        {
            ::CopyMemory(pDst->value, pSrc->value, pDst->length);
            return TRUE;
        }
    }
    return FALSE;
}

void FreeOSTR(OSTR *pDst)
{
    if (pDst->length)
    {
        delete [] pDst->value;
    }
}


//////////////////////////////////////////////////
//
// Conversion
//

void AppletRegistryRequestToT120One
(
    AppletRegistryRequest   *pAppletRequest,
    T120RegistryRequest     *pT120One
)
{
    pT120One->eCommand = pAppletRequest->eCommand;
    pT120One->pRegistryKey = (T120RegistryKey *) &pAppletRequest->RegistryKey;
    switch (pT120One->eCommand)
    {
    case APPLET_REGISTER_CHANNEL:
        pT120One->nChannelID = pAppletRequest->nChannelID;
        break;
    case APPLET_SET_PARAMETER:
        pT120One->Param.postrValue = (OSTR *) &pAppletRequest->ostrParamValue;
        pT120One->Param.eModifyRights = pAppletRequest->eParamModifyRights;
        break;
    case APPLET_ALLOCATE_HANDLE:
        pT120One->cHandles = pAppletRequest->cHandles;
        break;
    case APPLET_RETRIEVE_ENTRY:
    case APPLET_DELETE_ENTRY:
    case APPLET_ASSIGN_TOKEN:
    case APPLET_MONITOR:
    default:
        break;
    }
}







#ifdef _DEBUG
void CheckStructCompatible(void)
{
    ASSERT(sizeof(AppletOctetString) == sizeof(OSTR));
    ASSERT(FIELD_OFFSET(AppletOctetString, cbStrSize) == FIELD_OFFSET(OSTR, length));
    ASSERT(FIELD_OFFSET(AppletOctetString, pbValue) == FIELD_OFFSET(OSTR, value));

    ASSERT(sizeof(AppletLongString) == sizeof(T120LongString));
    ASSERT(FIELD_OFFSET(AppletLongString, nStrLen) == FIELD_OFFSET(T120LongString, long_string_length));
    ASSERT(FIELD_OFFSET(AppletLongString, pnValue) == FIELD_OFFSET(T120LongString, long_string));

    ASSERT(sizeof(AppletObjectKey) == sizeof(T120ObjectKey));
    ASSERT(FIELD_OFFSET(AppletObjectKey, eType) == FIELD_OFFSET(T120ObjectKey, key_type));
    ASSERT(FIELD_OFFSET(AppletObjectKey, lstrObjectID) == FIELD_OFFSET(T120ObjectKey, object_id));
    ASSERT(FIELD_OFFSET(AppletObjectKey, ostrH221NonStdID) == FIELD_OFFSET(T120ObjectKey, h221_non_standard_id));

    ASSERT(sizeof(AppletSessionKey) == sizeof(T120SessionKey));
    ASSERT(FIELD_OFFSET(AppletSessionKey, AppletProtocolKey) == FIELD_OFFSET(T120SessionKey, application_protocol_key));
    ASSERT(FIELD_OFFSET(AppletSessionKey, nSessionID) == FIELD_OFFSET(T120SessionKey, session_id));

    ASSERT(sizeof(AppletRegistryKey) == sizeof(T120RegistryKey));
    ASSERT(FIELD_OFFSET(AppletRegistryKey, SessionKey) == FIELD_OFFSET(T120RegistryKey, session_key));
    ASSERT(FIELD_OFFSET(AppletRegistryKey, ostrResourceID) == FIELD_OFFSET(T120RegistryKey, resource_id));

    ASSERT(sizeof(AppletRegistryItem) == sizeof(T120RegistryItem));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, ItemType) == FIELD_OFFSET(T120RegistryItem, item_type));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, nChannelID) == FIELD_OFFSET(T120RegistryItem, channel_id));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, nTokenID) == FIELD_OFFSET(T120RegistryItem, token_id));
    ASSERT(FIELD_OFFSET(AppletRegistryItem, ostrParamValue) == FIELD_OFFSET(T120RegistryItem, parameter));

    ASSERT(sizeof(AppletRegistryEntryOwner) == sizeof(T120RegistryEntryOwner));
    ASSERT(FIELD_OFFSET(AppletRegistryEntryOwner, fEntryOwned) == FIELD_OFFSET(T120RegistryEntryOwner, entry_is_owned));
    ASSERT(FIELD_OFFSET(AppletRegistryEntryOwner, nOwnerNodeID) == FIELD_OFFSET(T120RegistryEntryOwner, owner_node_id));
    ASSERT(FIELD_OFFSET(AppletRegistryEntryOwner, nOwnerEntityID) == FIELD_OFFSET(T120RegistryEntryOwner, owner_entity_id));

    ASSERT(sizeof(AppletCapabilityID) == sizeof(T120CapID));
    ASSERT(FIELD_OFFSET(AppletCapabilityID, eType) == FIELD_OFFSET(T120CapID, capability_id_type));
    ASSERT(FIELD_OFFSET(AppletCapabilityID, nNonStdCap) == FIELD_OFFSET(T120CapID, non_standard_capability));
    ASSERT(FIELD_OFFSET(AppletCapabilityID, nStdCap) == FIELD_OFFSET(T120CapID, standard_capability));

    ASSERT(sizeof(AppletCapability) == sizeof(T120AppCap));
    ASSERT(FIELD_OFFSET(AppletCapability, CapID) == FIELD_OFFSET(T120AppCap, capability_id));
    ASSERT(FIELD_OFFSET(AppletCapability, CapClass) == FIELD_OFFSET(T120AppCap, capability_class));
    ASSERT(FIELD_OFFSET(AppletCapability, cEntities) == FIELD_OFFSET(T120AppCap, number_of_entities));

    ASSERT(sizeof(AppletCapability2) == sizeof(T120NonCollCap));
    ASSERT(FIELD_OFFSET(AppletCapability2, CapID) == FIELD_OFFSET(T120NonCollCap, capability_id));
    ASSERT(FIELD_OFFSET(AppletCapability2, pCapData) == FIELD_OFFSET(T120NonCollCap, application_data));

    ASSERT(sizeof(AppletProtocolEntity) == sizeof(T120APE)); // array of structs vs array of pointers
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, SessionKey) == FIELD_OFFSET(T120APE, session_key));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, eStartupChannelType) == FIELD_OFFSET(T120APE, startup_channel_type));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, fMustBeInvoked) == FIELD_OFFSET(T120APE, must_be_invoked));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, cExpectedCapabilities) == FIELD_OFFSET(T120APE, number_of_expected_capabilities));
    ASSERT(FIELD_OFFSET(AppletProtocolEntity, apExpectedCapabilities) == FIELD_OFFSET(T120APE, expected_capabilities_list));

    ASSERT(sizeof(AppletRecord) == sizeof(T120AppRecord));   // array of structs vs array of pointers
    ASSERT(FIELD_OFFSET(AppletRecord, nNodeID) == FIELD_OFFSET(T120AppRecord, node_id));
    ASSERT(FIELD_OFFSET(AppletRecord, nEntityID) == FIELD_OFFSET(T120AppRecord, entity_id));
    ASSERT(FIELD_OFFSET(AppletRecord, fEnrolledActively) == FIELD_OFFSET(T120AppRecord, is_enrolled_actively));
    ASSERT(FIELD_OFFSET(AppletRecord, fConductingCapable) == FIELD_OFFSET(T120AppRecord, is_conducting_capable));
    ASSERT(FIELD_OFFSET(AppletRecord, eStartupChannelType) == FIELD_OFFSET(T120AppRecord, startup_channel_type));
    ASSERT(FIELD_OFFSET(AppletRecord, nAppletUserID) == FIELD_OFFSET(T120AppRecord, application_user_id));
    ASSERT(FIELD_OFFSET(AppletRecord, cCapabilities) == FIELD_OFFSET(T120AppRecord, number_of_non_collapsed_caps));
    ASSERT(FIELD_OFFSET(AppletRecord, apCapabilities) == FIELD_OFFSET(T120AppRecord, non_collapsed_caps_list));

    ASSERT(sizeof(AppletRoster) == sizeof(T120AppRoster));   // array of structs vs array of pointers
    ASSERT(FIELD_OFFSET(AppletRoster, SessionKey) == FIELD_OFFSET(T120AppRoster, session_key));
    ASSERT(FIELD_OFFSET(AppletRoster, fRosterChanged) == FIELD_OFFSET(T120AppRoster, application_roster_was_changed));
    ASSERT(FIELD_OFFSET(AppletRoster, nInstanceNumber) == FIELD_OFFSET(T120AppRoster, instance_number));
    ASSERT(FIELD_OFFSET(AppletRoster, fNodesAdded) == FIELD_OFFSET(T120AppRoster, nodes_were_added));
    ASSERT(FIELD_OFFSET(AppletRoster, fNodesRemoved) == FIELD_OFFSET(T120AppRoster, nodes_were_removed));
    ASSERT(FIELD_OFFSET(AppletRoster, fCapabilitiesChanged) == FIELD_OFFSET(T120AppRoster, capabilities_were_changed));
    ASSERT(FIELD_OFFSET(AppletRoster, cRecords) == FIELD_OFFSET(T120AppRoster, number_of_records));
    ASSERT(FIELD_OFFSET(AppletRoster, apAppletRecords) == FIELD_OFFSET(T120AppRoster, application_record_list));
    ASSERT(FIELD_OFFSET(AppletRoster, cCapabilities) == FIELD_OFFSET(T120AppRoster, number_of_capabilities));
    ASSERT(FIELD_OFFSET(AppletRoster, apCapabilities) == FIELD_OFFSET(T120AppRoster, capabilities_list));


    ASSERT(sizeof(AppletChannelRequest) == sizeof(T120ChannelRequest));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, eCommand) == FIELD_OFFSET(T120ChannelRequest, eCommand));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, nChannelID) == FIELD_OFFSET(T120ChannelRequest, nChannelID));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, cUsers) == FIELD_OFFSET(T120ChannelRequest, cUsers));
    ASSERT(FIELD_OFFSET(AppletChannelRequest, aUsers) == FIELD_OFFSET(T120ChannelRequest, aUsers));

    ASSERT(sizeof(AppletTokenRequest) == sizeof(T120TokenRequest));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, eCommand) == FIELD_OFFSET(T120TokenRequest, eCommand));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, nTokenID) == FIELD_OFFSET(T120TokenRequest, nTokenID));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, uidGiveTo) == FIELD_OFFSET(T120TokenRequest, uidGiveTo));
    ASSERT(FIELD_OFFSET(AppletTokenRequest, hrGiveResponse) == FIELD_OFFSET(T120TokenRequest, eGiveResponse));
}
#endif // _DEBUG



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\t120app.h ===
#ifndef _T120_APPLET_H_
#define _T120_APPLET_H_

#include "iapplet.h"
#include <it120app.h>
#include "resource.h"


class CNmAppletObj;

class CNmAppletSession : public IAppletSession
{
public:

    CNmAppletSession(CNmAppletObj *, IT120AppletSession *, BOOL fAutoJoin = FALSE);
    ~CNmAppletSession(void);

    /* ------ IUnknown ------ */

    STDMETHODIMP    QueryInterface(REFIID iid, void **ppv);

    STDMETHODIMP_(ULONG)    AddRef(void);

    STDMETHODIMP_(ULONG)    Release(void);

    /* ------ Basic Info ------ */

    STDMETHODIMP    GetConfID(AppletConfID *pnConfID);

    STDMETHODIMP    IsThisNodeTopProvider(BOOL *pfTopProvider);

    /* ------ Join Conference ------ */

    STDMETHODIMP    Join(IN AppletSessionRequest *pRequest);

    STDMETHODIMP    Leave(void);

    /* ------ Send Data ------ */

    STDMETHODIMP    SendData(BOOL               fUniformSend,
                             AppletChannelID    nChannelID,
                             AppletPriority     ePriority,
                             ULONG              cbBufSize,
                             BYTE              *pBuffer); // size_is(cbBufSize)

    /* ------ Invoke Applet ------ */

    STDMETHODIMP    InvokeApplet(AppletRequestTag      *pnReqTag,
                                 AppletProtocolEntity  *pAPE,
                                 ULONG                  cNodes,
                                 AppletNodeID           aNodeIDs[]); // size_is(cNodes)

    /* ------ Inquiry ------ */

    STDMETHODIMP    InquireRoster(AppletSessionKey *pSessionKey);

    /* ------ Registry Services ------ */

    STDMETHODIMP    RegistryRequest(AppletRegistryRequest *pRequest);

    /* ------ Channel Services ------ */

    STDMETHODIMP    ChannelRequest(AppletChannelRequest *pRequest);

    /* ------ Token Services ------ */

    STDMETHODIMP    TokenRequest(AppletTokenRequest *pRequest);

    /* ------ Notification registration / unregistration------ */

    STDMETHODIMP    Advise(IAppletSessionNotify *pNotify, DWORD *pdwCookie);

    STDMETHODIMP    UnAdvise(DWORD dwCookie);


    void T120Callback(T120AppletSessionMsg *);

private:

    LONG                    m_cRef;

    CNmAppletObj           *m_pApplet;

    IT120AppletSession     *m_pT120Session;
    T120JoinSessionRequest *m_pT120SessReq;

    IAppletSessionNotify   *m_pNotify;
    CNmAppletSession       *m_pSessionObj;
    BOOL                    m_fAutoJoin;
};




class ATL_NO_VTABLE CNmAppletObj :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmAppletObj, &CLSID_NmApplet>,
	public IApplet
{
public:

    CNmAppletObj(void);
    ~CNmAppletObj(void);

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMAPPLET)
DECLARE_NOT_AGGREGATABLE(CNmAppletObj)

BEGIN_COM_MAP(CNmAppletObj)
	COM_INTERFACE_ENTRY(IApplet)
END_COM_MAP()

    /* ------ Initialization ------ */

    STDMETHODIMP    Initialize(void);

    /* ------ Auto Join ------ */

    STDMETHODIMP    RegisterAutoJoin(AppletSessionRequest *pRequest);

    STDMETHODIMP    UnregisterAutoJoin(void);

    /* ------ Session ------ */

    STDMETHODIMP    CreateSession(IAppletSession **ppSession, AppletConfID nConfID);

    /* ------ Notification registration / unregistration------ */

    STDMETHODIMP    Advise(IAppletNotify *pNotify, DWORD *pdwCookie);

    STDMETHODIMP    UnAdvise(DWORD dwCookie);


    void T120Callback(T120AppletMsg *);

private:

    LONG                    m_cRef;

    IT120Applet            *m_pT120Applet;
    T120JoinSessionRequest *m_pT120AutoJoinReq;

    IAppletNotify          *m_pNotify;
    CNmAppletObj           *m_pAppletObj;
    T120ConfID              m_nPendingConfID;
};


HRESULT GetHrResult(T120Result rc);
AppletReason GetAppletReason(T120Reason rc);

T120JoinSessionRequest * AllocateJoinSessionRequest(AppletSessionRequest *);
void FreeJoinSessionRequest(T120JoinSessionRequest *);

BOOL ConvertCollapsedCaps(T120AppCap ***papDst, AppletCapability **apSrc, ULONG cItems);
void FreeCollapsedCaps(T120AppCap **apDst, ULONG cItems);

BOOL DuplicateCollapsedCap(T120AppCap *pDst, T120AppCap *pSrc);
void FreeCollapsedCap(T120AppCap *pDst);

BOOL DuplicateCapID(T120CapID *pDst, T120CapID *pSrc);
void FreeCapID(T120CapID *pDst);

BOOL ConvertNonCollapsedCaps(T120NonCollCap ***papDst, AppletCapability2 **apSrc, ULONG cItems);
void FreeNonCollapsedCaps(T120NonCollCap **apDst, ULONG cItems);

BOOL DuplicateNonCollapsedCap(T120NonCollCap *pDst, T120NonCollCap *pSrc);
void FreeNonCollapsedCap(T120NonCollCap *pDst);

BOOL DuplicateRegistryKey(T120RegistryKey *pDst, T120RegistryKey *pSrc);
void FreeRegistryKey(T120RegistryKey *pDst);

BOOL DuplicateSessionKey(T120SessionKey *pDst, T120SessionKey *pSrc);
void FreeSessionKey(T120SessionKey *pDst);

BOOL DuplicateObjectKey(T120ObjectKey *pDst, T120ObjectKey *pSrc);
void FreeObjectKey(T120ObjectKey *pDst);

BOOL DuplicateOSTR(OSTR *pDst, OSTR *pSrc);
void FreeOSTR(OSTR *pDst);

void AppletRegistryRequestToT120One(AppletRegistryRequest *, T120RegistryRequest *);


#ifdef _DEBUG
void CheckStructCompatible(void);
#else
#define CheckStructCompatible()
#endif


#endif // _T120_APPLET_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\t120xprt.cpp ===
#include "precomp.h"
#include "iplgxprt.h"
#include "nmmanager.h"


IT120PluggableTransport   * CNmManagerObj::ms_pT120Transport = NULL;
#ifdef ENABLE_UPDATE_CONNECTION
IPluggableTransportNotify * CNmManagerObj::ms_pPluggableTransportNotify = NULL;
#endif

BSTR LPSTR2BSTR(LPSTR pszConnID);
BOOL BSTR2LPSTR(BSTR bstrConnID, LPSTR pszConnID);


//////////////////////////////////////////////////
//
//  CPluggableTransport
//

void CNmManagerObj::EnsureTransportInterface(void)
{
    if (NULL == ms_pT120Transport)
    {
        T120Error rc = ::T120_CreatePluggableTransport(&ms_pT120Transport);
        ASSERT(T120_NO_ERROR == rc);
    }
}


BOOL CNmManagerObj::InitPluggableTransportSDK(void)
{
    ms_pT120Transport = NULL;
#ifdef ENABLE_UPDATE_CONNECTION
    ms_pPluggableTransportNotify = NULL;
#endif
    return TRUE;
}


void CNmManagerObj::CleanupPluggableTransportSDK(void)
{
    if (NULL != ms_pT120Transport)
    {
        ms_pT120Transport->ReleaseInterface();
        ms_pT120Transport = NULL;
    }
#ifdef ENABLE_UPDATE_CONNECTION
    ms_pPluggableTransportNotify = NULL;
#endif
}


//////////////////////////////////////////////////
//
// Connection @ CApplet
//

HRESULT CNmManagerObj::CreateConnection
(
    BSTR               *pbstrConnID,    // For placing a call and closing connection
    PLUGXPRT_CALL_TYPE  eCaller,        // caller or callee
    DWORD               dwProcessID,    // Used for DuplicateHandle
    HCOMMDEV            _hCommLink,     // Handle to communications file handle
    HEVENT              _hevtRead,      // Ready To Read event ( data avail )
    HEVENT              _hevtWrite,     // Ready To Write event 
    HEVENT              _hevtClosed,    // Connection closed ( unexpectedly???) 
    PLUGXPRT_FRAMING    eFraming,       // framing of bits sent on link
    PLUGXPRT_PARAMETERS *pParams        // OPTIONAL framing specific paramters
)
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != pbstrConnID)
        {
            if (dwProcessID && _hCommLink && _hevtRead && _hevtWrite && _hevtClosed)
            {
                HRESULT hr = E_ACCESSDENIED;
                HANDLE hProcess = ::OpenProcess(PROCESS_DUP_HANDLE, TRUE, dwProcessID);
                if (NULL != hProcess)
                {
                    HANDLE hCommLink;
                    if (::DuplicateHandle(hProcess, (HANDLE) _hCommLink,
                                          ::GetCurrentProcess(), &hCommLink,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                    {
                        HANDLE hevtRead;
                        if (::DuplicateHandle(hProcess, (HANDLE) _hevtRead,
                                          ::GetCurrentProcess(), &hevtRead,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                        {
                            HANDLE hevtWrite;
                            if (::DuplicateHandle(hProcess, (HANDLE) _hevtWrite,
                                          ::GetCurrentProcess(), &hevtWrite,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                            {
                                HANDLE hevtClose;
                                if (::DuplicateHandle(hProcess, (HANDLE) _hevtClosed,
                                          ::GetCurrentProcess(), &hevtClose,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                                {
                                    char szConnID[T120_CONNECTION_ID_LENGTH];
                                    T120Error rc = ms_pT120Transport->CreateConnection(
                                                        szConnID, eCaller, hCommLink,
                                                        hevtRead, hevtWrite, hevtClose,
                                                        eFraming, pParams);
                                    ASSERT(T120_NO_ERROR == rc);

                                    if (T120_NO_ERROR == rc)
                                    {
                                        *pbstrConnID = ::LPSTR2BSTR(szConnID);
                                        if (NULL != *pbstrConnID)
                                        {
                                            ::CloseHandle(hProcess);
                                            return S_OK;
                                        }

                                        hr = E_OUTOFMEMORY;
                                    }
                                    else
                                    {
                                        hr = E_HANDLE;
                                    }

                                    ::CloseHandle(hevtClose);
                                }

                                ::CloseHandle(hevtWrite);
                            }

                            ::CloseHandle(hevtRead);
                        }

                        ::CloseHandle(hCommLink);
                    }

                    ::CloseHandle(hProcess);
                }

                return hr;
            }

            return E_INVALIDARG;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}


#ifdef ENABLE_UPDATE_CONNECTION
HRESULT CNmManagerObj::UpdateConnection
(
    BSTR            bstrConnID,
    DWORD           dwProcessID,    // Used for DuplicateHandle
    HCOMMDEV        _hCommLink      // Handle to communications file handle
)
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != bstrConnID)
        {
            if (dwProcessID && _hCommLink)
            {
                HRESULT hr = E_ACCESSDENIED;
                HANDLE hProcess = ::OpenProcess(PROCESS_DUP_HANDLE, TRUE, dwProcessID);
                if (NULL != hProcess)
                {
                    HANDLE hCommLink;
                    if (::DuplicateHandle(hProcess, (HANDLE) _hCommLink,
                                          ::GetCurrentProcess(), &hCommLink,
                                          0, FALSE, DUPLICATE_SAME_ACCESS))
                    {
                        char szConnID[T120_CONNECTION_ID_LENGTH];
                        if (::BSTR2LPSTR(bstrConnID, szConnID))
                        {
                            T120Error rc = ms_pT120Transport->UpdateConnection(szConnID, hCommLink);
                            ASSERT(T120_NO_ERROR == rc);

                            if (T120_NO_ERROR == rc)
                            {
                                ::CloseHandle(hProcess);
                                return S_OK;
                            }

                            hr = E_HANDLE;
                        }

                        ::CloseHandle(hCommLink);
                    }

                    ::CloseHandle(hProcess);
                }

                return hr;
            }

            return E_INVALIDARG;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}
#endif


HRESULT CNmManagerObj::CloseConnection(BSTR bstrConnID) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != bstrConnID)
        {
            char szConnID[T120_CONNECTION_ID_LENGTH];
            if (::BSTR2LPSTR(bstrConnID, szConnID))
            {
                T120Error rc = ms_pT120Transport->CloseConnection(szConnID);
                ASSERT(T120_NO_ERROR == rc);

                return (T120_NO_ERROR == rc) ? S_OK : E_INVALIDARG;
            }

            return E_INVALIDARG;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}


//////////////////////////////////////////////////
//
// Winsock @ CApplet
//

HRESULT CNmManagerObj::EnableWinsock(void)
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        T120Error rc = ms_pT120Transport->EnableWinsock();
        ASSERT(T120_NO_ERROR == rc);

        return (T120_NO_ERROR == rc) ? S_OK : E_ACCESSDENIED;
    }

    return E_OUTOFMEMORY;
} 


HRESULT CNmManagerObj::DisableWinsock(void) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        T120Error rc = ms_pT120Transport->DisableWinsock();
        ASSERT(T120_NO_ERROR == rc);

        return (T120_NO_ERROR == rc) ? S_OK : E_ACCESSDENIED;
    }

    return E_OUTOFMEMORY;
}


#ifdef ENABLE_UPDATE_CONNECTION
void CALLBACK OnPluggableTransportNotify(PLUGXPRT_MESSAGE *pMsg)
{
    if (NULL != pMsg->pContext)
    {
        CNmManagerObj *p = (CNmManagerObj *) pMsg->pContext;
        IPluggableTransportNotify *pNotify = p->ms_pPluggableTransportNotify;

        if (NULL != pNotify)
        {
            BSTR bstr = ::LPSTR2BSTR(pMsg->pszConnID);
            if (NULL != bstr)
            {
                switch (pMsg->eState)
                {
                case PLUGXPRT_CONNECTING:
                    pNotify->OnConnecting(bstr, pMsg->eProtocol);
                    break;
                case PLUGXPRT_CONNECTED:
                    pNotify->OnConnected(bstr, pMsg->eProtocol, pMsg->eResult);
                    break;
                case PLUGXPRT_DISCONNECTING:
                    pNotify->OnDisconnecting(bstr, pMsg->eProtocol);
                    break;
                case PLUGXPRT_DISCONNECTED:
                    pNotify->OnDisconnected(bstr, pMsg->eProtocol, pMsg->eResult);
                    break;
                }

                ::SysFreeString(bstr);
            }
        }
    }
}
#endif


#ifdef ENABLE_UPDATE_CONNECTION
HRESULT CNmManagerObj::AdvisePluggableTransport(IPluggableTransportNotify *pNotify, DWORD *pdwCookie) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        // only allow one advise
        if (NULL == ms_pPluggableTransportNotify)
        {
            if (NULL != pNotify && NULL != pdwCookie)
            {
                pNotify->AddRef();
                ms_pPluggableTransportNotify = pNotify;

                AddRef();
                ms_pT120Transport->Advise(OnPluggableTransportNotify, this);

                *pdwCookie = (DWORD) this;

                return S_OK;
            }

            return E_POINTER;
        }

        return E_ACCESSDENIED;
    }

    return E_OUTOFMEMORY;
}
#endif


#ifdef ENABLE_UPDATE_CONNECTION
HRESULT CNmManagerObj::UnAdvisePluggableTransport(DWORD dwCookie) 
{
    EnsureTransportInterface();
    if (NULL != ms_pT120Transport)
    {
        if (NULL != ms_pPluggableTransportNotify)
        {
            if (dwCookie == (DWORD) this)
            {
                ms_pPluggableTransportNotify->Release(); 
                ms_pPluggableTransportNotify = NULL;

                ms_pT120Transport->UnAdvise();
                Release();

                return S_OK;
            }

            return E_ACCESSDENIED;
        }

        return E_POINTER;
    }

    return E_OUTOFMEMORY;
}
#endif


BSTR LPSTR2BSTR(LPSTR pszConnID)
{
    WCHAR wszConnID[T120_CONNECTION_ID_LENGTH];

    if (::MultiByteToWideChar(CP_ACP, 0, pszConnID, -1, wszConnID, T120_CONNECTION_ID_LENGTH))
    {
        return ::SysAllocString(wszConnID);
    }

    return NULL;
}


BOOL BSTR2LPSTR(BSTR bstrConnID, LPSTR pszConnID)
{
    *pszConnID = '\0';
    return ::WideCharToMultiByte(CP_ACP, 0, bstrConnID, -1, pszConnID, T120_CONNECTION_ID_LENGTH, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\topwindow.h ===
// File: confroom.h

#ifndef _TOPWINDOW_H_
#define _TOPWINDOW_H_

#include "GenWindow.h"
#include "GenContainers.h"
#include "ConfUtil.h"

class CConfRoom;
class CConfStatusBar;
class CMainUI;
class CSeparator;
class CVideoWindow;

struct IComponentWnd;
struct IAppSharing;
struct MYOWNERDRAWSTRUCT;
struct TOOLSMENUSTRUCT;

class CTopWindow : public CFrame
{
public:
	CTopWindow();

	// IGenWindow stuff
	virtual void GetDesiredSize(SIZE *ppt);
	virtual HPALETTE GetPalette();

	BOOL		FIsClosing() { return m_fClosing; }

	BOOL		Create(CConfRoom *pConfRoom, BOOL fShowUI);

	VOID        SaveSettings();
	BOOL		BringToFront();
	VOID		UpdateUI(DWORD dwUIMask);
	VOID		ForceWindowResize();
    void        OnReleaseCamera();

	CVideoWindow*	GetLocalVideo();
	CVideoWindow*	GetRemoteVideo();

protected:
	~CTopWindow();

	LRESULT		ProcessMessage(		HWND hWnd,
									UINT message,
									WPARAM wParam,
									LPARAM lParam);

private:
	enum WindowState
	{
		State_Default = 0,
		State_Normal,
		State_Compact,
		State_DataOnly,
		State_Mask = 0x00ff
	} ;

	enum WindowSubStates
	{
		SubState_OnTop		= 0x2000,
		SubState_Dialpad	= 0x4000,
		SubState_PicInPic	= 0x8000,
	} ;

    HFONT               m_hFontMenu;
	CTranslateAccelTable * m_pAccel;
	CConfRoom *			m_pConfRoom;
	CSeparator *        m_pSeparator;
	CMainUI *           m_pMainUI;
	CConfStatusBar *    m_pStatusBar;
	POINT				m_ptTaskbarClickPos;
	HWND				m_hwndPrevFocus;
	HCURSOR				m_hWaitCursor;
	CSimpleArray<TOOLSMENUSTRUCT*>		m_ExtToolsList;

	BOOL				m_fTaskbarDblClick : 1;
	BOOL				m_fMinimized : 1;
	BOOL				m_fClosing : 1;  // set when closing the NM UI
	BOOL				m_fEnableAppSharingMenuItem : 1;
        BOOL                            m_fExitAndActivateRDSMenuItem : 1;
		BOOL				m_fStateChanged : 1;

	BOOL		IsOnTop();
	void		SetOnTop(BOOL bOnTop);

	VOID        CreateChildWindows(void);

	void		OnInitMenu(HWND hwnd, HMENU hMenu);
	void		OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu);
	void		OnMenuSelect(HWND hwnd, HMENU hMenu, int uItem, UINT fuFlags);
    void        OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpmis);
    void        OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpdis);
	void		OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify);
	void		OnClose(HWND hwnd, LPARAM lParam);

	BOOL        SelAndRealizePalette();
    VOID        InitMenuFont();
	VOID        ResizeChildWindows(void);
	BOOL		UpdateWindowTitle();
	VOID		UpdateStatusBar();
	VOID        UpdateCallAnim();

	VOID        UpdateCallMenu(HMENU hMenu);
	VOID        UpdateViewMenu(HMENU hMenu);
	VOID        UpdateToolsMenu(HMENU hMenu);
	VOID        UpdateHelpMenu(HMENU hMenu);

	VOID		ShowUI(void);
    VOID        TerminateAppSharing(void);
	VOID        CloseChildWindows(void);
	BOOL		OnExtToolsItem(UINT uID);

	CMainUI *		GetMainUI()					{ return m_pMainUI;			}
};

#endif // _TOPWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\taskbar.h ===
#ifndef _TASKBAR_H_
#define _TASKBAR_H_

BOOL AddTaskbarIcon(HWND hwnd);
BOOL RemoveTaskbarIcon(HWND hwnd);
BOOL OnRightClickTaskbar();
BOOL RefreshTaskbarIcon(HWND hwnd);

#endif // _TASKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\taskbar.cpp ===
// File: taskbar.cpp

#include "precomp.h"
#include "resource.h"
#include "confroom.h"      // for CreateConfRoom
#include "cmd.h"
#include "conf.h"
#include "taskbar.h"
#include "confwnd.h"

BOOL AddTaskbarIcon(HWND hwnd)
{
	BOOL bRet = FALSE;
	
	RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
	if (TASKBARICON_ALWAYS == re.GetNumber(REGVAL_TASKBAR_ICON, TASKBARICON_DEFAULT))
	{
		// Place a 16x16 icon in the taskbar notification area:	
		NOTIFYICONDATA tnid;

		tnid.cbSize = sizeof(NOTIFYICONDATA);
		tnid.hWnd = hwnd;
		tnid.uID = ID_TASKBAR_ICON;
		tnid.uFlags = NIF_MESSAGE | NIF_ICON | NIF_TIP;
		tnid.uCallbackMessage = WM_TASKBAR_NOTIFY;
		tnid.hIcon = LoadIcon(::GetInstanceHandle(), MAKEINTRESOURCE(IDI_SM_WORLD));

		::LoadString(::GetInstanceHandle(), IDS_MEDIAPHONE_TITLE,
			tnid.szTip, CCHMAX(tnid.szTip));

		if (FALSE == (bRet = Shell_NotifyIcon(NIM_ADD, &tnid)))
		{
				// We could just be re-adding the icon...
			if(GetLastError() != 0)
			{
				// ISSUE: How do we want to handle this error?
				ERROR_OUT(("Could not add notify icon!"));
			}
		}
		else
		{
			::RefreshTaskbarIcon(::GetHiddenWindow());
		}

		if (NULL != tnid.hIcon)
		{
			DestroyIcon(tnid.hIcon);
		}
	}
	
	return bRet;
}

BOOL RefreshTaskbarIcon(HWND hwnd)
{
	BOOL bRet = FALSE;
	
	RegEntry re(CONFERENCING_KEY, HKEY_CURRENT_USER);
	if (TASKBARICON_ALWAYS == re.GetNumber(REGVAL_TASKBAR_ICON, TASKBARICON_DEFAULT))
	{
		UINT uIconId = FDoNotDisturb() ? IDI_DO_NOT_DISTURB : IDI_SM_WORLD;

		NOTIFYICONDATA tnid;

		tnid.cbSize = sizeof(NOTIFYICONDATA);
		tnid.hWnd = hwnd;
		tnid.uID = ID_TASKBAR_ICON;
		tnid.uFlags = NIF_ICON;
		tnid.hIcon = LoadIcon(::GetInstanceHandle(), MAKEINTRESOURCE(uIconId));

		if (FALSE == (bRet = Shell_NotifyIcon(NIM_MODIFY, &tnid)))
		{
				// ISSUE: How do we want to handle this error?
			ERROR_OUT(("Could not change notify icon!"));
		}

		if (NULL != tnid.hIcon)
		{
			DestroyIcon(tnid.hIcon);
		}
	}

	return bRet;
}

BOOL RemoveTaskbarIcon(HWND hwnd)
{
	NOTIFYICONDATA tnid;

	tnid.cbSize = sizeof(NOTIFYICONDATA);
	tnid.hWnd = hwnd;
	tnid.uID = ID_TASKBAR_ICON;

	return Shell_NotifyIcon(NIM_DELETE, &tnid);
}		

BOOL OnRightClickTaskbar()
{
	TRACE_OUT(("OnRightClickTaskbar called"));

	POINT ptClick;
	if (FALSE == ::GetCursorPos(&ptClick))
	{
		ptClick.x = ptClick.y = 0;
	}
	
	// Get the menu for the popup from the resource file.
	HMENU hMenu = ::LoadMenu(GetInstanceHandle(), MAKEINTRESOURCE(IDR_TASKBAR_POPUP));
	if (NULL == hMenu)
	{
		return FALSE;
	}

	// Get the first menu in it which we will use for the call to
	// TrackPopup(). This could also have been created on the fly using
	// CreatePopupMenu and then we could have used InsertMenu() or
	// AppendMenu.
	HMENU hMenuTrackPopup = ::GetSubMenu(hMenu, 0);

	// Bold the Open menuitem.
	//
	MENUITEMINFO iInfo;

	iInfo.cbSize = sizeof(iInfo);
	iInfo.fMask = MIIM_STATE;
	if(::GetMenuItemInfo(hMenu, IDM_TBPOPUP_OPEN, FALSE, &iInfo))
	{
		iInfo.fState |= MFS_DEFAULT;
		::SetMenuItemInfo(hMenu, IDM_TBPOPUP_OPEN, FALSE , &iInfo);
	}

	if (0 != _Module.GetLockCount())
	{
		// Can't stop while an SDK app in charge...
		if(::GetMenuItemInfo(hMenu, IDM_TBPOPUP_STOP, FALSE, &iInfo))
		{
			iInfo.fState |= MFS_GRAYED | MFS_DISABLED;
			::SetMenuItemInfo(hMenu, IDM_TBPOPUP_STOP, FALSE , &iInfo);
		}
	}

	// Draw and track the "floating" popup 

	// According to the font view code, there is a bug in USER which causes
	// TrackPopupMenu to work incorrectly when the window doesn't have the
	// focus.  The work-around is to temporarily create a hidden window and
	// make it the foreground and focus window.

	HWND hwndDummy = ::CreateWindow(_TEXT("STATIC"), NULL, 0, 
									ptClick.x, 
									ptClick.y,
									1, 1, HWND_DESKTOP,
									NULL, _Module.GetModuleInstance(), NULL);
	if (NULL != hwndDummy)
	{
		HWND hwndPrev = ::GetForegroundWindow();	// to restore

		TPMPARAMS tpmp;
		tpmp.cbSize = sizeof(tpmp);
		tpmp.rcExclude.right = 1 + (tpmp.rcExclude.left = ptClick.x);
		tpmp.rcExclude.bottom = 1 + (tpmp.rcExclude.top = ptClick.y);
		
		::SetForegroundWindow(hwndDummy);
		::SetFocus(hwndDummy);

		int iRet = ::TrackPopupMenuEx(	hMenuTrackPopup, 
									TPM_RETURNCMD | TPM_HORIZONTAL | TPM_RIGHTALIGN | 
										TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
									ptClick.x, 
									ptClick.y,
									hwndDummy, 
									&tpmp);

		// Restore the previous foreground window (before destroying hwndDummy).
		if (hwndPrev)
		{
			::SetForegroundWindow(hwndPrev);
		}

		::DestroyWindow(hwndDummy);

		switch (iRet)
		{
			case IDM_TBPOPUP_OPEN:
			{
				::CreateConfRoomWindow();
				break;
			}
			case IDM_TBPOPUP_STOP:
			{
				::CmdShutdown();
				break;
			}
		}
	}
	
	// We are finished with the menu now, so destroy it
	::DestroyMenu(hMenuTrackPopup);
	::DestroyMenu(hMenu);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\trackbar.h ===
#ifndef _TRACKBAR_H_
#define _TRACKBAR_H_

#define TRB_HORZ_W	150
#define TRB_HORZ_H	30

#define TRB_VERT_W	30
// #define TRB_VERT_H	150
#define TRB_VERT_H	140

// audio control group box
#define AC_VERT_H	40	// height
#define AC_VERT_W	20	// width
#define AC_VERT_M_X	6	// margin in x
#define AC_VERT_M_Y	16	// margin in y

#define TRB_CAPTION_X_MARGIN	4
#define TRB_CAPTION_Y_MARGIN	0


typedef struct tagTrackBarInfo
{
	WORD	wId;
	HWND	hWnd;
	HWND	hWndParent;
	DWORD	dwStyle;
	BOOL	fDlgUnit;
	POINT	pt;
	SIZE	size;
	WORD	wMin;
	WORD	wMax;
	WORD	wCurrPos;
	WORD	wTickFreq;
	WORD	wPageSize;
	// description
	PTSTR	pszTitle;
	PTSTR	pszMin;
	PTSTR	pszMid;
	PTSTR	pszMax;
}
	TRBARINFO;


enum
{
	UITB_CPU_ALLOC,			// cpu allocation
	UITB_NETWORK_BW,		// network bandwidth
	UITB_SILENCE_LEVEL_PS,	// silence threshold in property sheet
	UITB_SILENCE_LIMIT,		// silence buffer count
	UITB_SPEAKER_VOLUME,	// playback volume control
	UITB_RECORDER_VOLUME,		// recording volume control
	UITB_SPEAKER_VOLUME_MAIN,	// playback volume control
	UITB_RECORDER_VOLUME_MAIN,// recording volume control
	UITB_SILENCE_LEVEL_MAIN,// silence threshold in main UI window
	UITB_SILENCE_LIMIT_MAIN,
	UITB_NumOfSliders
};


extern TRBARINFO g_TrBarInfo[UITB_NumOfSliders];

#define ReversePos(p)  (((p)->wMax - (p)->wCurrPos) + (p)->wMin)

extern HWND g_hChkbSpkMute;
extern HWND g_hChkbRecMute;
extern HWND g_hChkbAutoDet;
#define g_hTrbSpkVol		(g_TrBarInfo[UITB_SPEAKER_VOLUME_MAIN].hWnd)
#define g_hTrbRecVol		(g_TrBarInfo[UITB_RECORDER_VOLUME_MAIN].hWnd)
#define g_hTrbSilenceLevel	(g_TrBarInfo[UITB_SILENCE_LEVEL_MAIN].hWnd)
#define g_hTrbSilenceLimit	(g_TrBarInfo[UITB_SILENCE_LIMIT_MAIN].hWnd)

BOOL CreateTrBar ( HWND, TRBARINFO *, BOOL, UINT );
LRESULT TrBarNotify ( WPARAM, LPARAM );
TRBARINFO *LocateTrBar ( HWND );
TRBARINFO *LocateTrBarByParent ( HWND );
void DrawTrBarCaption ( HWND );
BOOL CALLBACK PlayVolumeDlgProc ( HWND, UINT, WPARAM, LPARAM );
BOOL CALLBACK RecordVolumeDlgProc ( HWND, UINT, WPARAM, LPARAM );
void TrBarConvertDlgUnitToPixelUnit ( void );
BOOL DockVolumeDlg ( int, BOOL );
static BOOL CalcVolumeDlgRect ( int, RECT * );


#endif // _TRACKBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\ulscpl.cpp ===
/****************************************************************************
*
*	 FILE:	   UlsCpl.cpp
*
*	 CREATED:  Claus Giloi (ClausGi) 4-18-96
*
*	 CONTENTS: ULS-related control panel control data exchange functions
*
****************************************************************************/

#include "precomp.h"

#include "help_ids.h"
#include "ulswizrd.h"
#include "confcpl.h"
#include "NmLdap.h"
#include "call.h"
#include "statbar.h"
#include "confpolicies.h"
#include "conf.h"
#include "callto.h"


// Globals
static CULSWizard* s_pUlsWizard = NULL;

static ULS_CONF g_Old_ulsC;
static BOOL g_fOld_ulsC_saved = FALSE;

static bool s_fOldUseUlsServer;
static bool s_fOldTaskbarSetting;
static bool s_fOldAlwaysRunning;

static HWND s_hDlgUserInfo = NULL;


static DWORD	aUserHelpIds[]	=
{
	//	User information settings...
	IDC_MYINFO_GROUP,				IDH_MYINFO_MYINFO,
	IDG_DIRECTMODE,					IDH_MYINFO_MYINFO,
	IDC_STATIC_MYINFO,				IDH_MYINFO_MYINFO,
	IDC_USER_NAME,					IDH_MYINFO_FIRSTNAME,
	IDC_USER_LASTNAME,				IDH_MYINFO_LASTNAME,
	IDC_USER_EMAIL, 				IDH_MYINFO_EMAIL,
	IDC_USER_LOCATION,				IDH_MYINFO_LOCATION,
	IDC_USER_INTERESTS, 			IDH_MYINFO_COMMENTS,

	//	ILS settings...
	IDC_USER_PUBLISH,				IDH_MYINFO_PUBLISH,
	IDC_USEULS,						IDH_MYINFO_DIRECTORY_AT_START,
	IDC_NAMESERVER,					IDH_MYINFO_ULS_SERVER,
	IDC_STATIC_SERVER_NAME,			IDH_MYINFO_ULS_SERVER,

	// General stuff
	IDC_SHOWONTASKBAR,				IDH_GENERAL_SHOW_ON_TASKBAR,
	IDC_BANDWIDTH,					IDH_CALLING_BANDWIDTH,
	IDC_ADVANCED_CALL_OPTS,			IDH_CALLING_ADVANCED,

	//	NULL terminator...
	0,								0
};


static const DWORD	_rgHelpIdsCalling[]	=
{
	//	GateKeeper settings...
	IDC_CALLOPT_GK_USE,				IDH_SERVERS_USE_GATEKEEPER,
	IDG_GKMODE,						IDH_GENERAL_GENERAL,
	IDE_CALLOPT_GK_SERVER,			IDH_SERVERS_GATEKEEPER_NAME,
	IDC_STATIC_GATEKEEPER_NAME,		IDH_SERVERS_GATEKEEPER_NAME,
	IDC_CHECK_USE_ACCOUNT,			IDH_ADVCALL_USE_ACCOUNT,
	IDS_STATIC_ACCOUNT,				IDH_ADVCALL_ACCOUNT_NO,
	IDE_CALLOPT_GK_ACCOUNT,			IDH_ADVCALL_ACCOUNT_NO,
	IDC_CHECK_USE_PHONE_NUMBERS,	IDH_SERVERS_GATEKEEPER_PHONENO,
	IDC_STATIC_PHONE_NUMBER,		IDH_MYINFO_PHONE,
	IDE_CALLOPT_GK_PHONE_NUMBER,	IDH_MYINFO_PHONE,

	//	Direct proxy settings...
	IDG_DIRECTMODE,					IDH_GENERAL_GENERAL,
	IDC_CHECK_USE_PROXY,			IDH_ADVCALL_USE_PROXY,
	IDC_STATIC_PROXY_NAME,			IDH_ADVCALL_PROXY_NAME,
	IDE_CALLOPT_PROXY_SERVER,		IDH_ADVCALL_PROXY_NAME,

	//	Direct gateway settings...
	IDC_CHECK_USE_GATEWAY,			IDH_AUDIO_USEGATEWAY,
	IDC_STATIC_GATEWAY_NAME,		IDH_AUDIO_H323_GATEWAY,
	IDE_CALLOPT_GW_SERVER,			IDH_AUDIO_H323_GATEWAY,

	//	NULL terminator...
	0,								0
};

VOID FixServerDropList(HWND hdlg, int id, LPTSTR pszServer, UINT cchMax);
static void _SetLogOntoIlsButton( HWND hDlg, bool bLogOntoIlsWhenNmStarts );
void InitGWInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch );
void InitProxyInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableProxy, LPTSTR szOldServerNameBuf, UINT cch );

// Functions

inline bool FIsDlgButtonChecked(HWND hDlg, int nIDButton)
{
	return ( BST_CHECKED == IsDlgButtonChecked(hDlg, nIDButton) );
}


static BOOL InitULSDll ( VOID )
{
	delete s_pUlsWizard;
	return (NULL != (s_pUlsWizard = new CULSWizard()));
}

static BOOL DeInitULSDll ( VOID )
{
	if( s_pUlsWizard )
	{
		delete s_pUlsWizard;
		s_pUlsWizard = NULL;
	}
	return TRUE;
}


// implemented in wizard.cpp
extern UINT GetBandwidth();
extern void SetBandwidth(UINT uBandwidth);

// implemented in audiocpl.cpp
extern VOID UpdateCodecSettings(UINT uBandWidth);



static HRESULT InitULSControls(HWND hDlg, CULSWizard* pWiz,
						UINT ideditServerName,
						UINT ideditFirstName,
						UINT ideditLastName,
						UINT ideditEmailName,
						UINT ideditLocation,
						UINT ideditInterests,
						UINT idbtnDontPublish )
{

	HRESULT hr = (pWiz == NULL) ? E_NOINTERFACE : S_OK;

	if (SUCCEEDED(hr))
	{
		// Build up the flags for the getconfiguration call
		ULS_CONF ulsC;
		ClearStruct(&ulsC);

		if ( ideditServerName )
			ulsC.dwFlags |= ULSCONF_F_SERVER_NAME;

		if ( ideditFirstName )
			ulsC.dwFlags |= ULSCONF_F_FIRST_NAME;

		if ( ideditLastName )
			ulsC.dwFlags |= ULSCONF_F_LAST_NAME;

		if ( ideditEmailName )
			ulsC.dwFlags |= ULSCONF_F_EMAIL_NAME;

		if ( ideditLocation )
			ulsC.dwFlags |= ULSCONF_F_LOCATION;

		if ( ideditInterests )
			ulsC.dwFlags |= ULSCONF_F_COMMENTS;

		if ( idbtnDontPublish )
			ulsC.dwFlags |= ULSCONF_F_PUBLISH;

		// Get the current data
		hr = s_pUlsWizard->GetConfig(&ulsC);

		if (SUCCEEDED(hr))
		{
			// Save a copy of the struct to detect changes later
			g_Old_ulsC = ulsC;
			g_fOld_ulsC_saved = TRUE;

			if ( ideditFirstName )
				SetDlgItemText ( hDlg, ideditFirstName, ulsC.szFirstName );
			if ( ideditLastName )
				SetDlgItemText ( hDlg, ideditLastName, ulsC.szLastName );
			if ( ideditEmailName )
				SetDlgItemText ( hDlg, ideditEmailName, ulsC.szEmailName );
			if ( ideditLocation )
				SetDlgItemText ( hDlg, ideditLocation, ulsC.szLocation );
			if ( ideditInterests )
				SetDlgItemText ( hDlg, ideditInterests, ulsC.szComments );
			if ( idbtnDontPublish )
				SendDlgItemMessage ( hDlg, idbtnDontPublish, BM_SETCHECK,
					ulsC.fDontPublish ? TRUE : FALSE, 0 );
		}
	}

	if (FAILED(hr))
	{
		// There was a problem - disable everything
		DisableControl(hDlg, ideditServerName);
		DisableControl(hDlg, ideditFirstName);
		DisableControl(hDlg, ideditLastName);
		DisableControl(hDlg, ideditEmailName);
		DisableControl(hDlg, ideditLocation);
		DisableControl(hDlg, ideditInterests);
		DisableControl(hDlg, idbtnDontPublish);
	}

	return hr;
}

static BOOL IsULSEqual ( ULS_CONF * u1, ULS_CONF *u2, DWORD dwFlags )
{
	if ( lstrcmp ( u1->szServerName, u2->szServerName ) &&
		( dwFlags & ULSCONF_F_SERVER_NAME ) ||
		lstrcmp ( u1->szFirstName, u2->szFirstName ) &&
		( dwFlags & ULSCONF_F_FIRST_NAME ) ||
		lstrcmp ( u1->szLastName, u2->szLastName ) &&
		( dwFlags & ULSCONF_F_LAST_NAME ) ||
		lstrcmp ( u1->szEmailName, u2->szEmailName ) &&
		( dwFlags & ULSCONF_F_EMAIL_NAME ) ||
		lstrcmp ( u1->szLocation, u2->szLocation ) &&
		( dwFlags & ULSCONF_F_LOCATION ) ||
		lstrcmp ( u1->szComments, u2->szComments ) &&
		( dwFlags & ULSCONF_F_COMMENTS ) ||
		u1->fDontPublish != u2->fDontPublish &&
		( dwFlags & ULSCONF_F_PUBLISH ) )

		return FALSE;
	return TRUE;
}

static HRESULT SaveULSControls ( HWND hDlg,
						UINT ideditServerName,
						UINT ideditFirstName,
						UINT ideditLastName,
						UINT ideditEmailName,
						UINT ideditLocation,
						UINT ideditInterests,
						UINT idbtnDontPublish,
						BOOL bServerNameChanged
						 )
{

	// Check to see if the ULS is initialized

	if ( s_pUlsWizard == NULL ) {
		return E_NOINTERFACE;
	}

	// Now build up the flags for the setconfiguration call

	ULS_CONF ulsC;

	ulsC.dwFlags = 0;

	if ( ideditServerName )
		ulsC.dwFlags |= ULSCONF_F_SERVER_NAME;
	if ( ideditFirstName )
		ulsC.dwFlags |= ULSCONF_F_FIRST_NAME;
	if ( ideditLastName )
		ulsC.dwFlags |= ULSCONF_F_LAST_NAME;
	if ( ideditEmailName )
		ulsC.dwFlags |= ULSCONF_F_EMAIL_NAME;
	if ( ideditLocation )
		ulsC.dwFlags |= ULSCONF_F_LOCATION;
	if ( ideditInterests )
		ulsC.dwFlags |= ULSCONF_F_COMMENTS;
	if ( idbtnDontPublish )
		ulsC.dwFlags |= ULSCONF_F_PUBLISH;

	// Initialize the structure from the controls

	if ( ideditServerName )
	{
		GetDlgItemText( hDlg, ideditServerName, ulsC.szServerName, sizeof ( ulsC.szServerName ) );
		lstrcpyn( ulsC.szServerName, CDirectoryManager::get_dnsName( ulsC.szServerName ), sizeof ( ulsC.szServerName ) );
	}

	if ( ideditFirstName )
		GetDlgItemText ( hDlg, ideditFirstName, ulsC.szFirstName,
			sizeof( ulsC.szFirstName ) );
	if ( ideditLastName )
		GetDlgItemText ( hDlg, ideditLastName, ulsC.szLastName,
			sizeof( ulsC.szLastName ) );
	if ( ideditEmailName )
		GetDlgItemText ( hDlg, ideditEmailName, ulsC.szEmailName,
			sizeof( ulsC.szEmailName ) );
	if ( ideditLocation )
		GetDlgItemText ( hDlg, ideditLocation, ulsC.szLocation,
			sizeof( ulsC.szLocation ) );
	if ( ideditInterests )
		GetDlgItemText ( hDlg, ideditInterests, ulsC.szComments,
			sizeof( ulsC.szComments ) );
	if ( idbtnDontPublish )
		ulsC.fDontPublish =
			(BOOL)SendDlgItemMessage ( hDlg, idbtnDontPublish, BM_GETCHECK, 0, 0 );

	// Make the call

	HRESULT hRes = s_pUlsWizard->SetConfig( &ulsC );

	if ( hRes ) {
		ERROR_OUT(("ULSSetConfig call failed: %lx", hRes ));
		return hRes;
	}

	// Now check for changed ULS settings
	if ( g_fOld_ulsC_saved || bServerNameChanged) {
		if ( bServerNameChanged || !IsULSEqual ( &ulsC , &g_Old_ulsC, ulsC.dwFlags ))
		{
			g_dwChangedSettings |= CSETTING_L_ULSSETTINGS;

			if(ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct)
			{
				BOOL bLogonToILSServer = TRUE;
				
				if(!g_pLDAP || !g_pLDAP->IsLoggedOn())
				{
					// Ask the user if they want to logon
					int iRet = ::MessageBox(hDlg,
											RES2T(IDS_ULS_CHANGED_PROMPT),
											RES2T(IDS_MSGBOX_TITLE),
											MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION);
					if(IDNO == iRet)
					{
						bLogonToILSServer = FALSE;
					}
				}

				if(bLogonToILSServer)
				{
					if(NULL == g_pLDAP)
					{
						InitNmLdapAndLogon();
					}
					else
					{
						g_pLDAP->LogonAsync();
					}
				}
			}
		}
	}

	return S_OK;
}


/*	_  I N I T	U S E R  D L G	P R O C  */
/*-------------------------------------------------------------------------
	%%Function: _InitUserDlgProc

	Initialize the conferencing name fields
-------------------------------------------------------------------------*/
static void _InitUserDlgProc(HWND hdlg, PROPSHEETPAGE * ps, LPTSTR szOldServerNameBuf, UINT cch )
{
	RegEntry reCU( CONFERENCING_KEY, HKEY_CURRENT_USER);

	s_fOldAlwaysRunning = (0 != reCU.GetNumber(
				REGVAL_CONF_ALWAYS_RUNNING,	ALWAYS_RUNNING_DEFAULT ));

	CheckDlgButton( hdlg, IDC_ALWAYS_RUNNING, s_fOldAlwaysRunning ? BST_CHECKED : BST_UNCHECKED );

#ifndef TASKBARBKGNDONLY
	///////////////////////////////////////////////////////////
	//
	// Taskbar Icon Settings
	//
	// Initialize the icon-on-taskbar settings

	// Check the right button for taskbar icon use

	s_fOldTaskbarSetting = reCU.GetNumber(
				REGVAL_TASKBAR_ICON, TASKBARICON_DEFAULT )
				== TASKBARICON_ALWAYS;

	SendDlgItemMessage ( hdlg, IDC_SHOWONTASKBAR,
						 BM_SETCHECK,
						 s_fOldTaskbarSetting ? BST_CHECKED : BST_UNCHECKED,
						 0L );
#endif // ! TASKBARBKGNDONLY

#if USE_GAL
		if( ConfPolicies::IsGetMyInfoFromGALEnabled() && ConfPolicies::GetMyInfoFromGALSucceeded())
		{
			EnableWindow( GetDlgItem( hdlg, IDC_USER_NAME), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_LASTNAME), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_EMAIL), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_LOCATION), FALSE );
			EnableWindow( GetDlgItem( hdlg, IDC_USER_INTERESTS), FALSE );

			TCHAR szBuffer[ MAX_PATH ];
			FLoadString( IDS_MYINFO_CAPTION_DISABLED, szBuffer, CCHMAX( szBuffer ) );
			SetWindowText( GetDlgItem( hdlg, IDC_STATIC_MYINFO ), szBuffer );
		}
		else
		{
			TCHAR szBuffer[ MAX_PATH ];
			FLoadString( IDS_MYINFO_CAPTION_ENABLED, szBuffer, CCHMAX( szBuffer ) );
			SetWindowText( GetDlgItem( hdlg, IDC_STATIC_MYINFO ), szBuffer );
		}
#endif // USE_GAL

	if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_GateKeeper)
	{
			// Disable the ILS-related stuff
		EnableWindow( GetDlgItem( hdlg, IDC_NAMESERVER), FALSE );
		EnableWindow( GetDlgItem( hdlg, IDC_USER_PUBLISH), FALSE );
		EnableWindow( GetDlgItem( hdlg, IDC_USEULS), FALSE );
		EnableWindow( GetDlgItem( hdlg, IDC_STATIC_SERVER_NAME), FALSE );
	}

    EnableWindow( GetDlgItem( hdlg, IDC_ADVANCED_CALL_OPTS),
        ConfPolicies::IsAdvancedCallingAllowed());


	// Set the font
	SendDlgItemMessage(hdlg, IDC_USER_NAME,      WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LASTNAME,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LOCATION,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hdlg, IDC_USER_INTERESTS, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

	// Limit the edit control
	SendDlgItemMessage(hdlg, IDC_USER_NAME, 	EM_LIMITTEXT, MAX_FIRST_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LASTNAME, EM_LIMITTEXT, MAX_LAST_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_EMAIL,	EM_LIMITTEXT, MAX_EMAIL_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_LOCATION, EM_LIMITTEXT, MAX_LOCATION_NAME_LENGTH-1, 0);
	SendDlgItemMessage(hdlg, IDC_USER_INTERESTS,EM_LIMITTEXT, UI_COMMENTS_LENGTH-1, 0);

	InitULSDll();

	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// Init the server combobox... can we skip this stuff if we are not using ILS????
	FixServerDropList(hdlg, IDC_NAMESERVER, szOldServerNameBuf, cch );

	InitULSControls(hdlg, s_pUlsWizard,
		IDC_NAMESERVER,
		IDC_USER_NAME, IDC_USER_LASTNAME, IDC_USER_EMAIL,
		IDC_USER_LOCATION, IDC_USER_INTERESTS,
		IDC_USER_PUBLISH);
	
	// First the log onto directory servers stuff...
    s_fOldUseUlsServer = ConfPolicies::LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode();

	_SetLogOntoIlsButton( hdlg, s_fOldUseUlsServer);

	if (!SysPol::AllowDirectoryServices())
	{
		// Disable all items in this group
		DisableControl(hdlg, IDC_USEULS);
		DisableControl(hdlg, IDC_NAMESERVER);
		DisableControl(hdlg, IDC_USER_PUBLISH);
		DisableControl(hdlg, IDC_STATIC_SERVER_NAME);
	}

	s_hDlgUserInfo = hdlg;
}			

static void General_OnCommand(HWND hDlg, int id, HWND hwndCtl, UINT codeNotify, UINT *puBandwidth)
{
	INT_PTR CALLBACK BandwidthDlg( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

	switch(id)
	{
	case IDC_ADVANCED_CALL_OPTS:
	{
		DialogBox( GetInstanceHandle(), MAKEINTRESOURCE( IDD_CALLOPT ), hDlg, CallOptDlgProc );
		BOOL bEnable = (ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_Direct);

			// Disable/Enable the ILS-related stuff
		EnableWindow( GetDlgItem( hDlg, IDC_NAMESERVER), bEnable );
		EnableWindow( GetDlgItem( hDlg, IDC_USER_PUBLISH), bEnable );
		EnableWindow( GetDlgItem( hDlg, IDC_USEULS), bEnable );
		EnableWindow( GetDlgItem( hDlg, IDC_STATIC_SERVER_NAME), bEnable );

			// We are now in Gatekeeper mode, we should log off the ILS server
		if(!bEnable && g_pLDAP && g_pLDAP->IsLoggedOn())
		{
			g_pLDAP->Logoff();
		}

		break;
	}

	case IDC_BANDWIDTH:
		int nRet;

		nRet = (int)DialogBoxParam(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDD_BANDWIDTH), hDlg, BandwidthDlg, *puBandwidth);

		if (nRet != 0)
		{
			*puBandwidth = nRet;
		}

		break;

	case IDC_ALWAYS_RUNNING:
		if (FIsDlgButtonChecked( hDlg, IDC_ALWAYS_RUNNING ))
		{
			VOID EnableRDS(BOOL fEnabledRDS);

            RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
            BOOL bRDSRunning = reLM.GetNumber(REMOTE_REG_RUNSERVICE, DEFAULT_REMOTE_RUNSERVICE);

			if (bRDSRunning)
			{
				TCHAR szMsg[2*RES_CH_MAX];
				if (IDYES != MessageBox(hDlg,
					Res2THelper(IDS_RDSWARNING, szMsg, ARRAY_ELEMENTS(szMsg)), RES2T(IDS_MSGBOX_TITLE),
					MB_YESNO|MB_ICONHAND))
				{
					CheckDlgButton(hDlg, IDC_ALWAYS_RUNNING, BST_UNCHECKED);
					break;
				}

				EnableRDS(FALSE);
			}
		}
		break;

	default:
		break;
	}
}
/*	U S E R  D L G	P R O C  */
/*-------------------------------------------------------------------------
	%%Function: UserDlgProc

-------------------------------------------------------------------------*/
INT_PTR APIENTRY UserDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE * ps;
	static TCHAR s_szOldServerNameBuf[MAX_PATH];
	static UINT uOldBandwidth=0;
	static UINT uNewBandwidth=0;

	switch (message)
	{

		case WM_INITDIALOG:
		{
			// Save the PROPSHEETPAGE information.
			ps = (PROPSHEETPAGE *)lParam;
			_InitUserDlgProc(hDlg, ps, s_szOldServerNameBuf, CCHMAX(s_szOldServerNameBuf) );

			uNewBandwidth = uOldBandwidth = GetBandwidth();

			return TRUE;
		}

		case WM_COMMAND:
			General_OnCommand(hDlg, LOWORD(wParam), (HWND)lParam, HIWORD(wParam), &uNewBandwidth);
			break;

		case WM_NOTIFY:
			switch (((NMHDR FAR *) lParam)->code) {

				case PSN_KILLACTIVE:
				{
					int _IdFocus = 0;

					TCHAR szName[MAX_FIRST_NAME_LENGTH];
					TCHAR szLastName[MAX_LAST_NAME_LENGTH];
					TCHAR szEMail[MAX_EMAIL_NAME_LENGTH];

					// Check for no data in user name
					if (0 == GetDlgItemTextTrimmed(hDlg, IDC_USER_NAME, szName, CCHMAX(szName) ))
					{
						ConfMsgBox(hDlg, (LPCTSTR)IDS_NEEDUSERNAME);
						_IdFocus = IDC_USER_NAME;
					}
						// Check for no data in user name
					else if( 0 == GetDlgItemTextTrimmed(hDlg, IDC_USER_LASTNAME, szLastName, CCHMAX(szLastName)))
					{	
						ConfMsgBox(hDlg, (LPCTSTR)IDS_NEEDUSERNAME);
						_IdFocus = IDC_USER_LASTNAME;
					}
					else if( (!GetDlgItemText(hDlg, IDC_USER_EMAIL, szEMail, CCHMAX(szEMail)) || !FLegalEmailSz(szEMail)))
					{
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGALEMAILNAME);
							_IdFocus = IDC_USER_EMAIL;
					}

					TCHAR	szServerNameBuf[ MAX_PATH ];

					if( (!_IdFocus) &&
						FIsDlgButtonChecked( hDlg, IDC_USEULS )	&&
						(GetDlgItemTextTrimmed( hDlg, IDC_NAMESERVER, szServerNameBuf, CCHMAX( szServerNameBuf ) ) == 0) )
					{
						//	They specified logon to ILS at startup but didn't specify an ILS...
						ConfMsgBox( hDlg, (LPCTSTR) IDS_NO_ILS_SERVER );
						_IdFocus = IDC_NAMESERVER;
					}

					if( _IdFocus )
					{
						SetFocus(GetDlgItem(hDlg, _IdFocus));
						SendDlgItemMessage(hDlg, _IdFocus, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE );
						return TRUE;
					}
				}
				break;

				case PSN_APPLY:
				{
					RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

					bool fAlwaysRunning;

					fAlwaysRunning = FIsDlgButtonChecked( hDlg, IDC_ALWAYS_RUNNING );

//					if ( fAlwaysRunning != s_fOldAlwaysRunning )
					{
						reConf.SetValue(REGVAL_CONF_ALWAYS_RUNNING, fAlwaysRunning);

						RegEntry reRun(WINDOWS_RUN_KEY, HKEY_CURRENT_USER);
						if (fAlwaysRunning)
						{
							TCHAR szRunTask[MAX_PATH*2];
							TCHAR szInstallDir[MAX_PATH];

							if (GetInstallDirectory(szInstallDir))
							{
								RegEntry reConfLM(CONFERENCING_KEY, HKEY_LOCAL_MACHINE);
								wsprintf(szRunTask, _TEXT("\"%s%s\" -%s"),
									szInstallDir,
									reConfLM.GetString(REGVAL_NC_NAME),
									g_cszBackgroundSwitch);
								reRun.SetValue(REGVAL_RUN_TASKNAME, szRunTask);
							}
						}
						else
						{
							reRun.DeleteValue(REGVAL_RUN_TASKNAME);
						}
					}

#ifndef TASKBARBKGNDONLY
					///////////////////////////////////////////////////////////
					//
					// Taskbar Icon Settings
					//
					// Save taskbar icon state

					bool fTaskbarSetting;

					fTaskbarSetting = FIsDlgButtonChecked( hDlg,
						IDC_SHOWONTASKBAR );

					if ( fTaskbarSetting != s_fOldTaskbarSetting )
					{
						reConf.SetValue( REGVAL_TASKBAR_ICON,
								fTaskbarSetting? TASKBARICON_ALWAYS :
									TASKBARICON_NEVER );
						g_dwChangedSettings |= CSETTING_L_SHOWTASKBAR;
					}
#endif // ! TASKBARBKGNDONLY

        			//	Process "use uls server" setting...
					bool	fUseUlsServer	= FIsDlgButtonChecked( hDlg, IDC_USEULS ) ? true : false;

					if( fUseUlsServer != s_fOldUseUlsServer )
					{
						reConf.SetValue( REGVAL_DONT_LOGON_ULS, !fUseUlsServer );
						g_dwChangedSettings |= CSETTING_L_USEULSSERVER;
					}

					TCHAR szServerNameBuf[MAX_PATH];

					GetDlgItemTextTrimmed( hDlg, IDC_NAMESERVER, szServerNameBuf, CCHMAX( szServerNameBuf ) );

					if( lstrcmpi( szServerNameBuf, s_szOldServerNameBuf ) != 0 )
					{
						g_dwChangedSettings |= CSETTING_L_ULSSETTINGS;
					}

					///////////////////////////////////////////////////////////
					//
					// Conferencing Name Settings
					//
					// Just clean the rest
					TrimDlgItemText(hDlg, IDC_USER_LOCATION);
					TrimDlgItemText(hDlg, IDC_USER_INTERESTS);

					BOOL bServerNameChanged = g_dwChangedSettings & CSETTING_L_USEULSSERVER;

					HRESULT hRes = SaveULSControls(	hDlg,
													((g_dwChangedSettings & CSETTING_L_ULSSETTINGS) != 0)? IDC_NAMESERVER: 0,
													IDC_USER_NAME,
													IDC_USER_LASTNAME,
													IDC_USER_EMAIL,
													IDC_USER_LOCATION,
													IDC_USER_INTERESTS,
													IDC_USER_PUBLISH,
													bServerNameChanged);

					if( (g_dwChangedSettings & CSETTING_L_ULSSETTINGS) != 0 )
					{
						g_pCCallto->SetIlsServerName( CDirectoryManager::get_dnsName( szServerNameBuf ) );
					}

					ASSERT(S_OK == hRes);

					if (uNewBandwidth != uOldBandwidth)
					{
						g_dwChangedSettings |= CSETTING_L_BANDWIDTH;
						SetBandwidth(uNewBandwidth);
						UpdateCodecSettings(uNewBandwidth);
					}

					break;
				}

				case PSN_RESET:
					break;
			}
			break;

        case WM_CONTEXTMENU:
            DoHelpWhatsThis(wParam, aUserHelpIds);
            break;

		case WM_HELP:
			DoHelp(lParam, aUserHelpIds);
			break;

		case WM_DESTROY:
		{
			DeInitULSDll();
			break;
		}
	}
	return (FALSE);
}


VOID FixServerDropList(HWND hdlg, int id, LPTSTR pszServer, UINT cchMax)
{
	HWND hwndCtrl = GetDlgItem(hdlg, id);
	ASSERT(NULL != hwndCtrl);

	BOOL fComboBox = SysPol::AllowAddingServers();
	
	if (fComboBox)
	{
		// Limit the text in the edit control
        ComboBox_LimitText(GetDlgItem(hdlg, id), MAX_SERVER_NAME_LENGTH - 1);
	}
	else
	{
		// System policy does not allow adding new servers
		// Replace the combo list with a simple drop list

		RECT rc;
		GetWindowRect(hwndCtrl, &rc);
		LONG xpTop = rc.top;
		ComboBox_GetDroppedControlRect(hwndCtrl, &rc);
		rc.top = xpTop;
		::MapWindowPoints(NULL, hdlg, (LPPOINT) &rc, 2);

		DWORD dwStyle = GetWindowLong(hwndCtrl, GWL_STYLE);
		DWORD dwStyleEx = GetWindowLong(hwndCtrl, GWL_EXSTYLE);
		INT_PTR id = GetWindowLong(hwndCtrl, GWL_ID);
		HFONT hFont = (HFONT) ::SendMessage(hwndCtrl, WM_GETFONT, 0, 0);
		HWND hwndPrev = ::GetNextWindow(hwndCtrl, GW_HWNDPREV);

		DestroyWindow(hwndCtrl);

		dwStyle = CBS_DROPDOWNLIST | (dwStyle & ~CBS_DROPDOWN);

		hwndCtrl = ::CreateWindowEx(dwStyleEx, TEXT("COMBOBOX"), g_szEmpty, dwStyle,
				rc.left, rc.top, RectWidth(rc), RectHeight(rc),
				hdlg, (HMENU) id, ::GetInstanceHandle(), 0);

		::SendMessage(hwndCtrl, WM_SETFONT, (WPARAM) hFont, 0);

		// Maintain the tab order
		::SetWindowPos(hwndCtrl, hwndPrev, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOOWNERZORDER | SWP_NOREDRAW);
	}

	FillServerComboBox(hwndCtrl);

	// Find the item in the list
	int	index	= (int)::SendMessage( hwndCtrl, CB_FINDSTRINGEXACT, -1, (LPARAM) CDirectoryManager::get_displayName( pszServer ) );

	ComboBox_SetCurSel( hwndCtrl, (index == CB_ERR)? 0: index );

}


static void _SetCallingMode( HWND hDlg, ConfPolicies::eCallingMode eMode )
{
	switch( eMode )
	{
		case ConfPolicies::CallingMode_Direct:
			CheckDlgButton( hDlg, IDC_CALLOPT_GK_USE, BST_UNCHECKED );
			SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(IDC_CALLOPT_GK_USE,0 ), 0 );
			break;

		case ConfPolicies::CallingMode_GateKeeper:
			CheckDlgButton( hDlg, IDC_CALLOPT_GK_USE, BST_CHECKED );
			SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(IDC_CALLOPT_GK_USE,0 ), 0 );

			break;

		default:
			ERROR_OUT(("Invalid return val"));
			break;

	}
}

static void _SetLogOntoIlsButton( HWND hDlg, bool bLogOntoIlsWhenNmStarts )
{
	if( bLogOntoIlsWhenNmStarts )
	{
		CheckDlgButton( hDlg, IDC_USEULS, bLogOntoIlsWhenNmStarts ? BST_CHECKED : BST_UNCHECKED );
		SendMessage( hDlg, WM_COMMAND, MAKEWPARAM(IDC_USEULS, 0 ), 0 );
	}
}


// NOTE: This function is shared by the wizard page IDD_PAGE_SERVER
void InitDirectoryServicesDlgInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch )
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

		// Init the server combobox... can we skip this stuff if we are not using ILS????
	FixServerDropList(hDlg, IDC_NAMESERVER, szOldServerNameBuf, cch );

	InitULSControls(hDlg, pWiz,
		IDC_NAMESERVER,
		0, 0, 0,
		0, 0,
		IDC_USER_PUBLISH);

	// First the log onto directory servers stuff...
    s_fOldUseUlsServer = ConfPolicies::LogOntoIlsWhenNetMeetingStartsIfInDirectCallingMode();
	_SetLogOntoIlsButton( hDlg, s_fOldUseUlsServer);

	if (!SysPol::AllowDirectoryServices())
	{
		// Disable all items in this group
		DisableControl(hDlg, IDC_USEULS);
		DisableControl(hDlg, IDC_NAMESERVER);
		DisableControl(hDlg, IDC_USER_PUBLISH);
	}

}


void InitProxyInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableProxy, LPTSTR szOldProxyNameBuf, UINT cch )
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// proxy settings...
	HWND	hEditProxyServer	= GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER );

	if( hEditProxyServer )
	{
		SetWindowText( hEditProxyServer, reConf.GetString( REGVAL_PROXY ) );
		SendMessage( hEditProxyServer, EM_LIMITTEXT, CCHMAXSZ_SERVER - 1, 0 );

		rbOldEnableProxy = reConf.GetNumber( REGVAL_USE_PROXY )? true: false;

		if( rbOldEnableProxy )
		{
			CheckDlgButton( hDlg, IDC_CHECK_USE_PROXY, BST_CHECKED );
		}
		else
		{
			EnableWindow( hEditProxyServer, FALSE );
			DisableControl( hDlg, IDC_STATIC_PROXY_NAME );
		}
	}
}


void InitGWInfo( HWND hDlg, CULSWizard* pWiz, bool& rbOldEnableGateway, LPTSTR szOldServerNameBuf, UINT cch )
{
	RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

	// H.323 gateway settings
	HWND	hEditGwServer	= GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER );

	if( hEditGwServer )
	{
		SetWindowText( hEditGwServer, reConf.GetString( REGVAL_H323_GATEWAY ) );
		SendMessage( hEditGwServer, EM_LIMITTEXT, CCHMAXSZ_SERVER - 1, 0 );

		rbOldEnableGateway = reConf.GetNumber( REGVAL_USE_H323_GATEWAY )? true: false;

		if( rbOldEnableGateway )
		{
			CheckDlgButton( hDlg, IDC_CHECK_USE_GATEWAY, BST_CHECKED );
		}
		else
		{
			EnableWindow( hEditGwServer, FALSE );
			DisableControl( hDlg, IDC_STATIC_GATEWAY_NAME );
		}
	}
}


// NOTE: This function is shared by the wizard page IDD_WIZPG_GKMODE_SETTINGS
void InitGatekeeperDlgInfo( HWND hDlg, HWND hDlgUserInfo, CULSWizard* pWiz)
{
	//////////////////////////////////////////
	// Set the gatekeeper data

		// First the server name
	TCHAR buffer[CCHMAXSZ_SERVER];

	ConfPolicies::GetGKServerName( buffer, CCHMAX( buffer ) );

	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_SERVER,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_SERVER, EM_LIMITTEXT, CCHMAXSZ_SERVER-1, 0);
	SetDlgItemText(hDlg, IDE_CALLOPT_GK_SERVER, buffer );

	ConfPolicies::GetGKAccountName( buffer, CCHMAX( buffer ) );

	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_ACCOUNT,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_ACCOUNT, EM_LIMITTEXT, CCHMAXSZ_SERVER-1, 0);
	SetDlgItemText(hDlg, IDE_CALLOPT_GK_ACCOUNT, buffer );

	ConfPolicies::eGKAddressingMode	addressingMode	= ConfPolicies::GetGKAddressingMode();

	bool bUsePhoneNumbers	= ((addressingMode == ConfPolicies::GKAddressing_PhoneNum) || (addressingMode == ConfPolicies::GKAddressing_Both));
	bool bUseAccount		= ((addressingMode == ConfPolicies::GKAddressing_Account) || (addressingMode == ConfPolicies::GKAddressing_Both));

	RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER,  WM_SETFONT, (WPARAM) g_hfontDlg, 0);
	SendDlgItemMessage(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, EM_LIMITTEXT, MAX_PHONENUM_LENGTH-1, 0);
	SetDlgItemText(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, reULS.GetString( REGVAL_ULS_PHONENUM_NAME ));

	if( bUsePhoneNumbers )
	{
		CheckDlgButton( hDlg, IDC_CHECK_USE_PHONE_NUMBERS, BST_CHECKED );
	}

	if( bUseAccount )
	{
		CheckDlgButton( hDlg, IDC_CHECK_USE_ACCOUNT, BST_CHECKED );
	}

  	EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), bUsePhoneNumbers );
    EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), bUsePhoneNumbers );
   	EnableWindow( GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), bUseAccount );
    EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ), bUseAccount );
}


/*  C A L L  O P T  D L G  P R O C  */
/*-------------------------------------------------------------------------
    %%Function: CallOptDlgProc

-------------------------------------------------------------------------*/
INT_PTR APIENTRY CallOptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	static PROPSHEETPAGE * ps;

	static bool s_fEnableGk;
	static bool s_fEnableGw;
	static bool s_fEnableProxy;
    static bool s_fCantChangeCallMode;
	static bool s_InitialbUsingPhoneNum;
	static bool s_InitialbUsingAccount;
	static TCHAR s_szOldGatewayNameBuf[MAX_PATH];
	static TCHAR s_szOldProxyNameBuf[MAX_PATH];

	switch (message)
	{
		case WM_INITDIALOG:
		{
            s_fCantChangeCallMode = !ConfPolicies::UserCanChangeCallMode();

			InitProxyInfo( hDlg, s_pUlsWizard, s_fEnableProxy, s_szOldProxyNameBuf, CCHMAX( s_szOldProxyNameBuf ) );
			InitGWInfo( hDlg, s_pUlsWizard, s_fEnableGw, s_szOldGatewayNameBuf, CCHMAX( s_szOldGatewayNameBuf ) );

			InitGatekeeperDlgInfo( hDlg, s_hDlgUserInfo, s_pUlsWizard);

			s_InitialbUsingPhoneNum = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS );
			s_InitialbUsingAccount = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT );

			s_fEnableGk = ( ConfPolicies::CallingMode_GateKeeper == ConfPolicies::GetCallingMode() );
			

			///////////////////////////////////////////	
			// Set the calling mode				
			_SetCallingMode( hDlg, ConfPolicies::GetCallingMode() );
			
			return TRUE;
		}
		break;

		case WM_COMMAND:
		
			switch (LOWORD(wParam))
			{

				case IDC_WARNME:
					EnableWindow(GetDlgItem(hDlg, IDC_WARNCOUNT),
							FIsDlgButtonChecked(hDlg, IDC_WARNME));
				break;

				case IDC_CALLOPT_GK_USE:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE ) )
					{
						BOOL fUsePhone		= FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS );
						BOOL fUseAccount	= FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT );

#if	defined( PROXY_SUPPORTED )
						// disable the non-gatekeeper items
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PROXY ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), FALSE );
#endif	//	defined( PROXY_SUPPORTED )

						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_GATEWAY ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), FALSE );

						// Enable the gatekeeper options
                        EnableWindow( GetDlgItem( hDlg, IDC_CALLOPT_GK_USE ), !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_SERVER ),  !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEKEEPER_NAME ),  !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ), !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), fUsePhone);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), fUsePhone);
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_ACCOUNT ), !s_fCantChangeCallMode );
						EnableWindow( GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), fUseAccount );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ),  fUseAccount );

                        if (!s_fCantChangeCallMode)
                        {
    						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_SERVER ) );
	    					SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_SERVER, EM_SETSEL, 0, -1 );
                        }
                        else
                        {
                            if (fUsePhone)
                            {
        						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ) );
	        					SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, EM_SETSEL, 0, -1 );
                            }
                            else if (fUseAccount)
                            {
        						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ) );
    	    					SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_ACCOUNT, EM_SETSEL, 0, -1 );
                            }
                        }
					}
					else
					{
#if	defined( PROXY_SUPPORTED )
						// Enable the direct use options
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PROXY ), TRUE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) );
#endif	//	defined( PROXY_SUPPORTED )

						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_GATEWAY ), !s_fCantChangeCallMode );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), !s_fCantChangeCallMode && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) );
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), !s_fCantChangeCallMode && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) );

						// Disable the gatekeeper options
                        EnableWindow( GetDlgItem( hDlg, IDC_CALLOPT_GK_USE ), !s_fCantChangeCallMode);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_SERVER ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_GATEKEEPER_NAME ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), FALSE);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ),  FALSE );
						EnableWindow( GetDlgItem( hDlg, IDC_CHECK_USE_ACCOUNT ), FALSE );
						EnableWindow( GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), FALSE);
						EnableWindow( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ),  FALSE );
					}
					break;
				}

				case IDC_CHECK_USE_ACCOUNT:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT ) )
					{	
						EnableWindow(GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), TRUE);
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ), TRUE);
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_ACCOUNT, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDS_STATIC_ACCOUNT ), FALSE);
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_ACCOUNT ), FALSE);
					}

					break;
				}

				case IDC_CHECK_USE_PHONE_NUMBERS:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ) )
					{	
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), TRUE);
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), TRUE);
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER ), FALSE);
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PHONE_NUMBER ), FALSE);
					}

					break;
				}

				case IDC_CHECK_USE_PROXY:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) != FALSE )
					{	
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), TRUE );
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), TRUE );
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_PROXY_SERVER, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_PROXY_NAME ), FALSE );
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_PROXY_SERVER ), FALSE );
					}
				}					
				break;

				case IDC_CHECK_USE_GATEWAY:
				{
					if( FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) != FALSE )
					{	
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), TRUE );
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), TRUE );
						SetFocus( GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ) );
						SendDlgItemMessage( hDlg, IDE_CALLOPT_GW_SERVER, EM_SETSEL, 0, -1 );
					}
					else
					{
						EnableWindow(GetDlgItem( hDlg, IDE_CALLOPT_GW_SERVER ), FALSE );
						EnableWindow(GetDlgItem( hDlg, IDC_STATIC_GATEWAY_NAME ), FALSE );
					}
				}					
				break;

				case IDOK:
				{
					////////////////////////////////////////////////////////////////////
					// First we check to see that we have valid data
					
					int _IdFocus = 0;
						
						// Check to see if we are in gatekeeper mode...
					if( FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE ) )
					{
							// Verify the gatekeeper settings
						TCHAR szServer[CCHMAXSZ_SERVER];
						if (!GetDlgItemText(hDlg, IDE_CALLOPT_GK_SERVER, szServer, CCHMAX(szServer)) ||
							!IsLegalGateKeeperServerSz(szServer))
						{
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_GATEKEEPERSERVER_NAME);
							_IdFocus = IDE_CALLOPT_GK_SERVER;
						}
						if( (!_IdFocus) && (!FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS )) &&
							(!FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT )) )
						{
								// must check either account or phone number...
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_GK_MODE);
							_IdFocus = IDC_CHECK_USE_PHONE_NUMBERS;
						}
						if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS ) )
						{
								// Verify the phone number
							TCHAR szPhone[MAX_PHONENUM_LENGTH];
							if (!GetDlgItemText(hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, szPhone, CCHMAX(szPhone)) ||
								!IsLegalE164Number(szPhone))
							{
								ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_PHONE_NUMBER);
								_IdFocus = IDE_CALLOPT_GK_PHONE_NUMBER;
							}
						}
						if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT ) )
						{
								// Verify the account
							TCHAR account[MAX_PATH];
							if (!GetDlgItemText(hDlg, IDE_CALLOPT_GK_ACCOUNT, account, CCHMAX(account)) )
							{
								ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_ACCOUNT);
								_IdFocus = IDE_CALLOPT_GK_ACCOUNT;
							}
						}
					}

#if	defined( PROXY_SUPPORTED )
					//	Verify the proxy settings...
					if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) && (!FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE )) )
					{
						TCHAR szServer[CCHMAXSZ_SERVER];
						if (!GetDlgItemText(hDlg, IDE_CALLOPT_PROXY_SERVER, szServer, CCHMAX(szServer)) ||
							!IsLegalGatewaySz(szServer))
						{
							ConfMsgBox(hDlg, (LPCTSTR) IDS_ILLEGAL_PROXY_NAME);
							_IdFocus = IDE_CALLOPT_PROXY_SERVER;
						}
					}
#endif	//	defined( PROXY_SUPPORTED )

					//	Verify the gateway settings...
					if( (!_IdFocus) && FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_GATEWAY ) && (!FIsDlgButtonChecked( hDlg, IDC_CALLOPT_GK_USE )) )
					{
						TCHAR szServer[CCHMAXSZ_SERVER];
						if (!GetDlgItemText(hDlg, IDE_CALLOPT_GW_SERVER, szServer, CCHMAX(szServer)) ||
							!IsLegalGatewaySz(szServer))
						{
							ConfMsgBox(hDlg, (LPCTSTR)IDS_ILLEGAL_GATEWAY_NAME);
							_IdFocus = IDE_CALLOPT_GW_SERVER;
						}
					}

					if( _IdFocus )
					{
						SetFocus(GetDlgItem(hDlg, _IdFocus));
						SendDlgItemMessage(hDlg, _IdFocus, EM_SETSEL, (WPARAM) 0, (LPARAM) -1);
						SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE );
					}
					else
					{
						RegEntry reConf(CONFERENCING_KEY, HKEY_CURRENT_USER);

						// Handle the H323 Gateway setting:
						TCHAR buffer[CCHMAXSZ_SERVER];
						GetDlgItemText(hDlg, IDE_CALLOPT_GW_SERVER, buffer, CCHMAX(buffer));
						reConf.SetValue(REGVAL_H323_GATEWAY, buffer);
						g_pCCallto->SetGatewayName( buffer );

						bool fEnable = FIsDlgButtonChecked(hDlg, IDC_CHECK_USE_GATEWAY) ? true : false;
						if (fEnable != s_fEnableGw)
						{
							reConf.SetValue(REGVAL_USE_H323_GATEWAY, fEnable);
						}

						g_pCCallto->SetGatewayEnabled( fEnable );

#if	defined( PROXY_SUPPORTED )
						reConf.SetValue( REGVAL_USE_PROXY, FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PROXY ) );
						GetDlgItemText( hDlg, IDE_CALLOPT_PROXY_SERVER, buffer, CCHMAX( buffer ) );
						reConf.SetValue( REGVAL_PROXY, buffer );
#endif	//	defined( PROXY_SUPPORTED )

						bool	relogonRequired = false;

						// Gatekeeper / alias settings
						{
							TCHAR szServer[CCHMAXSZ_SERVER];
							GetDlgItemTextTrimmed(hDlg, IDE_CALLOPT_GK_SERVER, szServer, CCHMAX(szServer));
							if (0 != lstrcmp(szServer, reConf.GetString(REGVAL_GK_SERVER)))
							{
								reConf.SetValue(REGVAL_GK_SERVER, szServer);
								relogonRequired = true;
							}

							fEnable = FIsDlgButtonChecked(hDlg, IDC_CALLOPT_GK_USE) ? true : false;

							if( fEnable != s_fEnableGk )
							{
									// Set the calling mode
								reConf.SetValue(REGVAL_CALLING_MODE, fEnable ? CALLING_MODE_GATEKEEPER : CALLING_MODE_DIRECT );
								relogonRequired = true;
							}

							bool bUsingPhoneNum = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_PHONE_NUMBERS );
							bool bUsingAccount = FIsDlgButtonChecked( hDlg, IDC_CHECK_USE_ACCOUNT );

							ConfPolicies::eGKAddressingMode	addressingMode;

							if( bUsingPhoneNum && bUsingAccount )
							{
								addressingMode = ConfPolicies::GKAddressing_Both;
							}
							else if( bUsingPhoneNum )
							{
								addressingMode = ConfPolicies::GKAddressing_PhoneNum;
							}
							else if( bUsingAccount )
							{
								addressingMode = ConfPolicies::GKAddressing_Account;
							}
							else
							{
								addressingMode = ConfPolicies::GKAddressing_Invalid;
							}

							if( (s_InitialbUsingPhoneNum != bUsingPhoneNum) ||
								(s_InitialbUsingAccount != bUsingAccount) )
							{
									// Set the calling mode
								reConf.SetValue(REGVAL_GK_METHOD, addressingMode );
								relogonRequired = true;
							}

							RegEntry reULS(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);

							GetDlgItemTextTrimmed( hDlg, IDE_CALLOPT_GK_PHONE_NUMBER, buffer, CCHMAX( buffer ) );

							if( lstrcmp( buffer, reULS.GetString( REGVAL_ULS_PHONENUM_NAME ) ) != 0 )
							{
								reULS.SetValue( REGVAL_ULS_PHONENUM_NAME, buffer );
								relogonRequired = true;
							}

							GetDlgItemTextTrimmed( hDlg, IDE_CALLOPT_GK_ACCOUNT, buffer, CCHMAX( buffer ) );

							if( lstrcmp( buffer, reULS.GetString( REGVAL_ULS_GK_ACCOUNT ) ) != 0 )
							{
								reULS.SetValue( REGVAL_ULS_GK_ACCOUNT, buffer );
								relogonRequired = true;
							}
						}

						if( relogonRequired )
						{
							//	This means that we need to log on to the gatekeeper with this new changed info...

							reConf.FlushKey();
															
							if( fEnable )
							{
								if( s_fEnableGk )
								{
									//	We are already logged on to the gatekeeper so we must log off first...
									GkLogoff();
								}

								GkLogon();	
							}
							else
							{
								//	We are now in direct mode, we should log off the GateKeeper....
								GkLogoff();
								SetGkLogonState( NM_GK_NOT_IN_GK_MODE );
							}

							//	Update the status Bar...
							CConfStatusBar* pStatusBar = CConfStatusBar::GetInstance();								

							if( pStatusBar )
							{
								pStatusBar->Update();
							}
						}

						EndDialog( hDlg, IDOK );
					}
				}
				break;

				case IDCANCEL:
				{
					EndDialog( hDlg, IDCANCEL );
				}					
				break;

				default:
					break;

			}
			break;

		case WM_CONTEXTMENU:
			DoHelpWhatsThis(wParam, _rgHelpIdsCalling);
			break;

		case WM_HELP:
			DoHelp(lParam, _rgHelpIdsCalling);
			break;

		case WM_DESTROY:
			s_hDlgUserInfo = NULL;
			break;

		default:
			break;
	}

	return FALSE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\ulswizrd.h ===
#ifndef _ULSWIZRD_H_
#define _ULSWIZRD_H_

// same as INTERNET_MAX_USER_NAME_LENGTH in wininet.h.
#define MAX_SERVER_NAME_LENGTH	128
#define MAX_FIRST_NAME_LENGTH	128
#define MAX_LAST_NAME_LENGTH	128
#define MAX_EMAIL_NAME_LENGTH	128
#define MAX_UID_LENGTH          256
#define MAX_LOCATION_NAME_LENGTH	128
#define MAX_PHONENUM_LENGTH	128
#define MAX_COMMENTS_LENGTH		256
#define	UI_COMMENTS_LENGTH		60	// ;Internal
#define MAX_CLNTSTRING_LENGTH	256 //max of above
//SS: username is concatenated first name with last name with space in between
#define MAX_USER_NAME_LENGTH	(MAX_FIRST_NAME_LENGTH + MAX_LAST_NAME_LENGTH + sizeof (TCHAR))

// Wizard

typedef struct tag_ULS_CONF
{
    DWORD   dwFlags;
    BOOL    fDontPublish;
    TCHAR   szServerName[MAX_SERVER_NAME_LENGTH];
    TCHAR   szFirstName[MAX_FIRST_NAME_LENGTH];
    TCHAR	szLastName[MAX_LAST_NAME_LENGTH];
    TCHAR   szEmailName[MAX_EMAIL_NAME_LENGTH];
    TCHAR	szLocation[MAX_LOCATION_NAME_LENGTH];
    TCHAR	szComments[MAX_COMMENTS_LENGTH];
	TCHAR	szUserName[MAX_USER_NAME_LENGTH];
}
    ULS_CONF;


#define ULSCONF_F_PUBLISH           0X00000001UL
#define ULSCONF_F_SERVER_NAME       0X00000002UL
#define ULSCONF_F_FIRST_NAME        0X00000004UL
#define ULSCONF_F_EMAIL_NAME        0X00000008UL
#define ULSCONF_F_LAST_NAME         0X00000010UL
#define ULSCONF_F_LOCATION	        0X00000020UL
#define ULSCONF_F_COMMENTS	        0X00000080UL
#define ULSCONF_F_USER_NAME			0x00000100UL

#define ULSWIZ_F_SHOW_BACK          0X00010000UL
#define ULSWIZ_F_NO_FINISH          0X00020000UL

class CULSWizard;

class CWizDirectCallingSettings
{
private:
	static HWND s_hDlg;
	CULSWizard* m_pWiz;
	ULS_CONF*	m_pConf;

	TCHAR m_szInitialServerName[MAX_SERVER_NAME_LENGTH];
	bool m_bInitialEnableGateway;
	
public:
	CWizDirectCallingSettings( CULSWizard* pWiz ) : m_pWiz( pWiz ) { ; }
	void SetULS_CONF( ULS_CONF* pConf ) { m_pConf = pConf; }
	static INT_PTR APIENTRY StaticDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
	static HWND GetHwnd(){ return s_hDlg; }
	static bool IsGatewayNameInvalid();
	static void OnWizFinish();
	


private:
	INT_PTR APIENTRY _DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
	BOOL _OnInitDialog();
	BOOL _OnSetActive();
	BOOL _OnKillActive();
	BOOL _OnWizBack();
	BOOL _OnWizNext();
	BOOL _OnWizFinish();
	BOOL _OnCommand( WPARAM wParam, LPARAM lParam );
	void _SetWizButtons();

};


class CULSWizard
{

CWizDirectCallingSettings	m_WizDirectCallingSettings;


public:

	CULSWizard::CULSWizard() : m_WizDirectCallingSettings( this )							
							   { ; }

    HRESULT GetWizardPages( PROPSHEETPAGE **, ULONG *, ULS_CONF **);
    HRESULT ReleaseWizardPages( PROPSHEETPAGE *);
    HRESULT SetConfig( ULS_CONF * );
    HRESULT GetConfig( ULS_CONF * );
};

#endif // _ULSWIZRD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\upropdlg.cpp ===
#include "precomp.h"

/****************************************************************************
*
*    FILE:     UPropDlg.cpp
*
*    CREATED:  Chris Pirich (ChrisPi) 6-18-96
*
*    CONTENTS: CUserPropertiesDlg object
*
****************************************************************************/

#include "resource.h"
#include "UPropDlg.h"
#include "certui.h"
#include "conf.h"

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   CUserPropertiesDlg()
*
*    PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CUserPropertiesDlg::CUserPropertiesDlg(    HWND hwndParent,
                                        UINT uIcon):
    m_hwndParent    (hwndParent),
    m_uIcon         (uIcon),
    m_pCert         (NULL)
{
    DebugEntry(CUserPropertiesDlg::CUserPropertiesDlg);

    m_hIcon = ::LoadIcon(    ::GetInstanceHandle(),
                            MAKEINTRESOURCE(m_uIcon));

    DebugExitVOID(CUserPropertiesDlg::CUserPropertiesDlg);
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   DoModal()
*
*    PURPOSE:  Brings up the modal dialog box
*
****************************************************************************/

INT_PTR CUserPropertiesDlg::DoModal
(
    PUPROPDLGENTRY  pUPDE,
    int             nProperties,
    LPTSTR          pszName,
    PCCERT_CONTEXT  pCert
)
{
    int             i;

    DBGENTRY(CUserPropertiesDlg::DoModal);

    m_pUPDE         = pUPDE;
    m_nProperties   = nProperties;
    m_pszName       = pszName;
    m_pCert         = pCert;

    PROPSHEETPAGE psp[PSP_MAX];
    for (i = 0; i < PSP_MAX; i++)
    {
        InitStruct(&psp[i]);
    }

    psp[0].dwFlags               = PSP_DEFAULT;
    psp[0].hInstance             = ::GetInstanceHandle();
    psp[0].pszTemplate           = MAKEINTRESOURCE(IDD_USER_PROPERTIES);
    psp[0].pfnDlgProc            = CUserPropertiesDlg::UserPropertiesDlgProc;
    psp[0].lParam                = (LPARAM) this;

    i = 1;

    if (pCert)
    {
        psp[i].dwFlags               = PSP_DEFAULT;
        psp[i].hInstance             = ::GetInstanceHandle();
        psp[i].pszTemplate           = MAKEINTRESOURCE(IDD_USER_CREDENTIALS);
        psp[i].pfnDlgProc            = CUserPropertiesDlg::UserCredentialsDlgProc;
        psp[i].lParam                = (LPARAM) this;
        i++;
    }


    PROPSHEETHEADER psh;
    InitStruct(&psh);

    psh.dwFlags         = PSH_NOAPPLYNOW | PSH_PROPTITLE | PSH_PROPSHEETPAGE;
    psh.hwndParent      = m_hwndParent;
    psh.hInstance       = ::GetInstanceHandle();
    psh.pszCaption      = m_pszName;

    psh.nPages =    i;

    ASSERT(0 == psh.nStartPage);
    psh.ppsp = psp;

    return ::PropertySheet(&psh);
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   UserPropertiesDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CUserPropertiesDlg::UserPropertiesDlgProc(HWND hDlg,
                                                        UINT uMsg,
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // uMsg may be any value.
    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hDlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT(NULL != lParam);
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*)
                                            ((PROPSHEETPAGE*) lParam)->lParam;
            ASSERT(NULL != pupd);
            pupd->m_hwnd = hDlg;
            bMsgHandled = pupd->OnInitPropertiesDialog();
            break;
        }

        default:
        {
#if 0
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*) ::GetWindowLongPtr(
                                                                    hDlg,
                                                                    DWLP_USER);

            if (NULL != pupd)
            {
                bMsgHandled = pupd->OnPropertiesMessage(uMsg, wParam, lParam);
            }
#endif // 0
        }
    }

    return bMsgHandled;
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   UserCredentialsDlgProc()
*
*    PURPOSE:  Dialog Proc - handles all messages
*
****************************************************************************/

INT_PTR CALLBACK CUserPropertiesDlg::UserCredentialsDlgProc(HWND hDlg,
                                                        UINT uMsg,
                                                        WPARAM wParam,
                                                        LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // uMsg may be any value.
    // wparam may be any value.
    // lparam may be any value.

    ASSERT(IS_VALID_HANDLE(hDlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT(NULL != lParam);
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*)
                                            ((PROPSHEETPAGE*) lParam)->lParam;
            ASSERT(NULL != pupd);
            pupd->m_hwnd = hDlg;
            ::SetWindowLongPtr(hDlg, DWLP_USER, (DWORD_PTR)pupd);
            bMsgHandled = pupd->OnInitCredentialsDialog();
            break;
        }

        default:
        {
            CUserPropertiesDlg* pupd = (CUserPropertiesDlg*) ::GetWindowLongPtr(
                                                                    hDlg,
                                                                    DWLP_USER);

            if (NULL != pupd)
            {
                bMsgHandled = pupd->OnCredentialsMessage(uMsg, wParam, lParam);
            }
        }
    }

    return bMsgHandled;
}





/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnInitPropertiesDialog()
*
*    PURPOSE:  processes WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnInitPropertiesDialog()
{
    ASSERT(m_hwnd);

    // Set the proper font (for DBCS systems)
    ::SendDlgItemMessage(m_hwnd, IDC_UPROP_NAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

    ::SetDlgItemText(m_hwnd, IDC_UPROP_NAME, m_pszName);
    ::SendDlgItemMessage(    m_hwnd,
                            IDC_UPROP_ICON,
                            STM_SETIMAGE,
                            IMAGE_ICON,
                            (LPARAM) m_hIcon);
    TCHAR szBuffer[MAX_PATH];
    for (int i = 0; i < m_nProperties; i++)
    {
        // Fill in property:
        if (::LoadString(    ::GetInstanceHandle(),
                            m_pUPDE[i].uProperty,
                            szBuffer,
                            ARRAY_ELEMENTS(szBuffer)))
        {
            // NOTE: relies on consecutive control ID's
            ::SetDlgItemText(m_hwnd, IDC_UP_PROP1 + i, szBuffer);
        }

        ::SendDlgItemMessage(m_hwnd, IDC_UP_VALUE1 + i, WM_SETFONT,
                (WPARAM) g_hfontDlg, 0);

        // Fill in value:
        ASSERT(NULL != m_pUPDE[i].pszValue);
        if (0 == HIWORD(m_pUPDE[i].pszValue))
        {
            if (::LoadString(    ::GetInstanceHandle(),
                                PtrToUint(m_pUPDE[i].pszValue),
                                szBuffer,
                                ARRAY_ELEMENTS(szBuffer)))
            {
                // NOTE: relies on consecutive control ID's
                ::SetDlgItemText(m_hwnd, IDC_UP_VALUE1 + i, szBuffer);
            }
        }
        else
        {
            // NOTE: relies on consecutive control ID's
            ::SetDlgItemText(m_hwnd, IDC_UP_VALUE1 + i, m_pUPDE[i].pszValue);
        }
    }
    return TRUE;
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnInitCredentialsDialog()
*
*    PURPOSE:  processes WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnInitCredentialsDialog()
{
    ASSERT(m_hwnd);

    // Set the proper font (for DBCS systems)
    ::SendDlgItemMessage(m_hwnd, IDC_UPROP_NAME, WM_SETFONT, (WPARAM) g_hfontDlg, 0);

    ::SetDlgItemText(m_hwnd, IDC_UPROP_NAME, m_pszName);
    ::SendDlgItemMessage(    m_hwnd,
                            IDC_UPROP_ICON,
                            STM_SETIMAGE,
                            IMAGE_ICON,
                            (LPARAM) m_hIcon);

    ASSERT(m_pCert != NULL);

    if ( TCHAR * pSecText = FormatCert ( m_pCert->pbCertEncoded,
                                        m_pCert->cbCertEncoded ))
    {
        ::SetDlgItemText(m_hwnd, IDC_AUTH_EDIT, pSecText );
        delete pSecText;
    }
    else
    {
        ERROR_OUT(("OnInitCredentialsDialog: FormatCert failed"));
    }
    return TRUE;
}




/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnPropertiesMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnPropertiesMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = FALSE;

    ASSERT(m_hwnd);

    switch (uMsg)
    {
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    bRet = OnOk();
                    break;
                }

                case IDCANCEL:
                {
                    // ::EndDialog(m_hwnd, LOWORD(wParam));
                    bRet = TRUE;
                    break;
                }

            }
            break;
        }

        default:
            break;
    }

    return bRet;
}

/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnCredentialsMessage()
*
*    PURPOSE:  processes all messages except WM_INITDIALOG
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnCredentialsMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL bRet = FALSE;

    ASSERT(m_hwnd);

    switch (uMsg)
    {
        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    bRet = OnOk();
                    break;
                }

                case IDCANCEL:
                {
                    // ::EndDialog(m_hwnd, LOWORD(wParam));
                    bRet = TRUE;
                    break;
                }

                case IDC_SEC_VIEWCREDS:
                {
                    ViewCertDlg ( m_hwnd, m_pCert );
                    break;
                }
            }
            break;
        }

        default:
            break;
    }

    return bRet;
}



/****************************************************************************
*
*    CLASS:    CUserPropertiesDlg
*
*    MEMBER:   OnOk()
*
*    PURPOSE:  processes the WM_COMMAND,IDOK message
*
****************************************************************************/

BOOL CUserPropertiesDlg::OnOk()
{
    DebugEntry(CUserPropertiesDlg::OnOk);
    BOOL bRet = TRUE;

    DebugExitBOOL(CUserPropertiesDlg::OnOk, bRet);
    return bRet;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\ui\conf\topwindow.cpp ===
// File: confroom.cpp

#include "precomp.h"

#include "TopWindow.h"

class CParticipant;

#include "dbgMenu.h"
#include "conf.h"
#include "FloatBar.h"
#include "StatBar.h"
#include "RToolbar.h"
#include "GenControls.h"
#include "resource.h"
#include "cr.h"
#include "taskbar.h"
#include "confman.h"
#include <EndSesn.h>
#include "cmd.h"
#include "MenuUtil.h"
#include "ConfPolicies.h"
#include "call.h"
#include "setupdd.h"
#include "VidView.h"
#include "audiowiz.h"
#include "NmLdap.h"
#include "ConfWnd.h"
#include <iappldr.h>
#include "ConfApi.h"
#include "confroom.h"
#include "NmManager.h"
#include "dlgAcd.h"
#include "dlgCall2.h"

static const TCHAR s_cszHtmlHelpFile[] = TEXT("conf.chm");

extern bool g_bInitControl;
BOOL IntCreateRDSWizard(HWND hwndOwner);
INT_PTR CALLBACK RDSSettingDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

extern BOOL FUiVisible(void);
extern BOOL FIsAVCapable();

inline DWORD MenuState(BOOL bEnabled)
{
	return(bEnabled ? MF_ENABLED : MF_DISABLED|MF_GRAYED);
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   CConfRoom()
*
*        PURPOSE:  Constructor - initializes variables
*
****************************************************************************/

CTopWindow::CTopWindow():
    m_hFontMenu                     (NULL),
	m_pConfRoom						(NULL),
	m_pSeparator					(NULL),
	m_pMainUI						(NULL),
	m_pStatusBar					(NULL),
	m_hwndPrevFocus					(NULL),

	m_fTaskbarDblClick				(FALSE),
	m_fMinimized					(FALSE),
	m_fClosing						(FALSE),
	m_fEnableAppSharingMenuItem		(FALSE),
        m_fExitAndActivateRDSMenuItem           (FALSE)
{
	DbgMsg(iZONE_OBJECTS, "Obj: %08X created CTopWindow", this);

	// Load cursors:
	m_hWaitCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ~CConfRoom()
*
*        PURPOSE:  Destructor
*
****************************************************************************/

CTopWindow::~CTopWindow()
{
    // Delete the menu font:
    DeleteObject(m_hFontMenu);

	// Empty the tools menu list:
	CleanTools(NULL, m_ExtToolsList);

	CloseChildWindows();

	DbgMsg(iZONE_OBJECTS, "Obj: %08X destroyed CTopWindow", this);
}

// This gets called from OnClose and from the destructor (just in case)
VOID CTopWindow::CloseChildWindows(void)
{
	HWND hwnd = GetWindow();

	// Hide the main window as soon as possible
	if (NULL != hwnd)
	{
		ShowWindow(hwnd, SW_HIDE);
	}

	// Delete the UI elements:
	delete m_pStatusBar;
	m_pStatusBar = NULL;

	// BUGBUG georgep: This function is getting called twice
	if (NULL != m_pMainUI)
	{
		m_pMainUI->Release();
		m_pMainUI = NULL;
	}
	
	if (NULL != m_pSeparator)
	{
		m_pSeparator->Release();
		m_pSeparator = NULL;
	}
	
    if (NULL != hwnd)
    {
		::DestroyWindow(hwnd);
        ASSERT(!GetWindow());
    }

	if (NULL != m_pConfRoom)
	{
		// Make sure we do not try this multiple times
		CConfRoom *pConfRoom = m_pConfRoom;
		m_pConfRoom = NULL;

		pConfRoom->Release();

		// BUGBUG georgep: We need true reference counting here
		delete pConfRoom;
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateUI(DWORD dwUIMask)
*
*        PURPOSE:  Updates the appropriate pieces of the UI
*
****************************************************************************/

VOID CTopWindow::UpdateUI(DWORD dwUIMask)
{
	if ((CRUI_TOOLBAR & dwUIMask) && (NULL != m_pMainUI))
	{
		m_pMainUI->UpdateButtons();
	}
	if (CRUI_TITLEBAR & dwUIMask)
	{
		UpdateWindowTitle();
	}
	if (CRUI_STATUSBAR & dwUIMask)
	{
		UpdateStatusBar();
	}
	if (CRUI_CALLANIM & dwUIMask)
	{
		UpdateCallAnim();
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateWindowTitle()
*
*        PURPOSE:  Updates the titlebar with the appropriate message
*
****************************************************************************/

BOOL CTopWindow::UpdateWindowTitle()
{
	TCHAR szTitle[MAX_PATH];
	TCHAR szBuf[MAX_PATH];
	BOOL bRet = FALSE;

	if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_TITLE, szBuf, sizeof(szBuf)))
	{
		lstrcpy(szTitle, szBuf);

		int nPart = m_pConfRoom->GetMemberCount();
		if (nPart > 2)
		{
			TCHAR szFormat[MAX_PATH];
			if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_INCALL, szFormat, sizeof(szFormat)))
			{
				wsprintf(szBuf, szFormat, (nPart - 1));
				lstrcat(szTitle, szBuf);
			}
		}
		else if (2 == nPart)
		{
			if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_INCALL_ONE, szBuf, sizeof(szBuf)))
			{
				lstrcat(szTitle, szBuf);
			}
		}
		else
		{
			if (::LoadString(GetInstanceHandle(), IDS_MEDIAPHONE_NOTINCALL, szBuf, sizeof(szBuf)))
			{
				lstrcat(szTitle, szBuf);
			}
		}

		HWND hwnd = GetWindow();
		if (NULL != hwnd)
		{
			bRet = ::SetWindowText(hwnd, szTitle);
		}
	}

	return bRet;
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   Create()
*
*        PURPOSE:  Creates a window
*
****************************************************************************/

BOOL CTopWindow::Create(CConfRoom *pConfRoom, BOOL fShowUI)
{
	ASSERT(NULL == m_pConfRoom);

	m_pConfRoom = pConfRoom;
	m_pConfRoom->AddRef();

	HICON hiBig = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_CONFROOM));

	if (!CFrame::Create(
		NULL,
		g_szEmpty,
		(WS_OVERLAPPEDWINDOW&~(WS_THICKFRAME|WS_MAXIMIZEBOX)) | WS_CLIPCHILDREN,
		0,
		0, 0,
		100,
		100,
		_Module.GetModuleInstance(),
		hiBig,
		LoadMenu(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDR_CONFROOM_MENU)),
		g_szConfRoomClass
		))
	{
		return(FALSE);
	}

	// Do a resize early so if the menu wraps, it will be taken into account
	// by the following GetDesiredSize call
	Resize();

	SIZE defSize;
	GetDesiredSize(&defSize);

    InitMenuFont();

	RegEntry reConf(UI_KEY, HKEY_CURRENT_USER);

	// NOTE: it isn't actually the width and the height of the
	// window - it is the right and the bottom.
	RECT rctSize;
	rctSize.right  = defSize.cx;
	rctSize.bottom = defSize.cy;

	rctSize.left   = reConf.GetNumber(REGVAL_MP_WINDOW_X, DEFAULT_MP_WINDOW_X);
	rctSize.top    = reConf.GetNumber(REGVAL_MP_WINDOW_Y, DEFAULT_MP_WINDOW_Y);
	if (ERROR_SUCCESS != reConf.GetError())
	{
		// Center the window on the screen
		int dx = GetSystemMetrics(SM_CXFULLSCREEN);
		if (dx > rctSize.right)
		{
			rctSize.left = (dx - rctSize.right) / 2;
		}

		int dy = GetSystemMetrics(SM_CYFULLSCREEN);

#if FALSE
		// BUGBUG georgep: Should this be in GetDesiredSize?
		// adjust default height if using large video windows on a LAN
		if (dy >= 553) // 800 x 600
		{
			RegEntry reAudio(AUDIO_KEY, HKEY_CURRENT_USER);
			if (BW_MOREKBS == reAudio.GetNumber(REGVAL_TYPICALBANDWIDTH,BW_DEFAULT))
			{
				ASSERT(DEFAULT_MP_WINDOW_HEIGHT == rctSize.bottom);
				rctSize.bottom = DEFAULT_MP_WINDOW_HEIGHT_LAN;
			}
		}
#endif

		if (dy > rctSize.bottom)
		{
			rctSize.top = (dy - rctSize.bottom) / 2;
		}
	}

	rctSize.right += rctSize.left;
	rctSize.bottom += rctSize.top;
	
	WINDOWPLACEMENT wp;
	wp.length = sizeof(wp);

	HWND hwnd = GetWindow();

	::GetWindowPlacement(hwnd, &wp);
	wp.flags = 0;


	if (!fShowUI)
	{
		// NOUI - must hide
		wp.showCmd = SW_HIDE;
	}
	else
	{
		wp.showCmd = SW_SHOWNORMAL;

		STARTUPINFO si;
		si.cb = sizeof(si);
		::GetStartupInfo(&si);
		if ((STARTF_USESHOWWINDOW & si.dwFlags) &&
			(SW_SHOWMAXIMIZED != si.wShowWindow))
		{
			wp.showCmd = si.wShowWindow;
		}
	}


	wp.rcNormalPosition = rctSize;

	CNmManagerObj::OnShowUI(fShowUI);

	::SetWindowPlacement(hwnd, &wp);

	switch (wp.showCmd)
	{
		case SW_SHOWMINIMIZED:
		case SW_MINIMIZE:
		case SW_SHOWMINNOACTIVE:
		case SW_FORCEMINIMIZE:
		case SW_HIDE:
			break;
		default:
			if (0 != ::SetForegroundWindow(hwnd))
			{
				// BUGBUG georgep: Shouldn't the system do this for us?
				FORWARD_WM_QUERYNEWPALETTE(GetWindow(), ProcessMessage);
			}
			break;
	}
		
	// Paint the window completely (bug 171):
	// ::UpdateWindow(hwnd);

	//
	// Call GetSystemMenu(m_hwnd, FALSE) to get the private copy
	// of the system menu created NOW before we enter menu mode the
	// first time.private copy created.  That way calling
	// GetSystemMenu(m_hwnd, FALSE) in OnMenuSelect
	// won't wipe out the old menu and cause the sysmenu to be
	// positioned in the wrong place the first time.
	//
	::GetSystemMenu(hwnd, FALSE);

#ifdef DEBUG
	// Verify all of the menus have the proper text
	// TODO: Verify accelerator keys are unique per menu
	{
		HMENU hMenuMain = ::GetMenu(hwnd);
		for (int iMenu = 0; iMenu <= MENUPOS_HELP; iMenu++)
		{
			HMENU hMenuSub = ::GetSubMenu(hMenuMain, iMenu);
			for (int i = 0; ; i++)
			{
				TCHAR szMenu[MAX_PATH];
				MENUITEMINFO mii;
				InitStruct(&mii);
				mii.fMask = MIIM_TYPE | MIIM_DATA | MIIM_ID | MIIM_SUBMENU;
				mii.dwTypeData = szMenu;
				mii.cch = CCHMAX(szMenu);
				if (!GetMenuItemInfo(hMenuSub, i, TRUE, &mii))
					break; // out of for loop

				if (0 != (mii.fType & MFT_SEPARATOR))
					continue; // skip separators

				if (0 != (mii.hSubMenu))
					continue; // skip submenus
			}
		}
	}
#endif /* DEBUG */

	UpdateStatusBar();

	return(TRUE);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   SaveSettings()
*
*        PURPOSE:  Saves UI settings in the registry
*
****************************************************************************/

VOID CTopWindow::SaveSettings()
{
	DebugEntry(CConfRoom::SaveSettings);
	RegEntry reConf(UI_KEY, HKEY_CURRENT_USER);
	
	// Save window coords to registry:
	WINDOWPLACEMENT wp;
	wp.length = sizeof(WINDOWPLACEMENT);

	if (::GetWindowPlacement(GetWindow(), &wp))
	{
		reConf.SetValue(REGVAL_MP_WINDOW_X,
						wp.rcNormalPosition.left);
		reConf.SetValue(REGVAL_MP_WINDOW_Y,
						wp.rcNormalPosition.top);
	}

	// Save window elements to the registry:
	reConf.SetValue(REGVAL_SHOW_STATUSBAR, CheckMenu_ViewStatusBar(NULL));

	if (NULL != m_pMainUI)
	{
		m_pMainUI->SaveSettings();

		// Only write if a setting has changed, so we can have default
		// behavior as long as possible
		if (m_fStateChanged)
		{
			int state = 0;

			if (m_pMainUI->IsCompact())
			{
				state = State_Compact;
			}
			else if (m_pMainUI->IsDataOnly())
			{
				state = State_DataOnly;
			}
			else
			{
				state = State_Normal;
			}

			if (m_pMainUI->IsPicInPic())
			{
				state |= SubState_PicInPic;
			}
			if (m_pMainUI->IsDialing())
			{
				state |= SubState_Dialpad;
			}
			if (IsOnTop())
			{
				state |= SubState_OnTop;
			}

			reConf.SetValue(REGVAL_MP_WINDOW_STATE, state);
		}
	}

	// NOTE: CMainUI saves its settings in its destructor
	
	DebugExitVOID(CConfRoom::SaveSettings);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   BringToFront()
*
*        PURPOSE:  Restores the window (if minimized) and brings it to the front
*
****************************************************************************/

BOOL CTopWindow::BringToFront()
{
	ShowUI();
	return TRUE;
}


/*  S H O W  U  I  */
/*-------------------------------------------------------------------------
    %%Function: ShowUI

    Show the main NetMeeting window.
-------------------------------------------------------------------------*/
VOID CTopWindow::ShowUI(void)
{
	HWND hwnd = GetWindow();

	if (NULL == hwnd)
		return; // no ui to show?

	if (!IsWindowVisible(hwnd))
	{
		CNmManagerObj::OnShowUI(TRUE);

		ShowWindow(hwnd, SW_SHOW);
	}

	WINDOWPLACEMENT wp;
	wp.length = sizeof(wp);

	if (::GetWindowPlacement(hwnd, &wp) &&
		((SW_MINIMIZE == wp.showCmd) || (SW_SHOWMINIMIZED == wp.showCmd)))
	{
		// The window is minimized - restore it:
		::ShowWindow(hwnd, SW_RESTORE);
	}

	::SetForegroundWindow(hwnd);
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ProcessMessage(HWND, UINT, WPARAM, LPARAM)
*
*        PURPOSE:  Handles messages except WM_CREATE and WM_COMMAND
*
****************************************************************************/

LRESULT CTopWindow::ProcessMessage( HWND hWnd,
								UINT message,
								WPARAM wParam,
								LPARAM lParam)
{
    static const UINT c_uMsgXchgConf = ::RegisterWindowMessage(_TEXT("Xchg_TAPIVideoRelease"));

	switch (message)
	{
		HANDLE_MSG(hWnd, WM_INITMENU     , OnInitMenu);
		HANDLE_MSG(hWnd, WM_INITMENUPOPUP, OnInitMenuPopup);
        HANDLE_MSG(hWnd, WM_MEASUREITEM,   OnMeasureItem);
        HANDLE_MSG(hWnd, WM_DRAWITEM,      OnDrawItem);
		HANDLE_MSG(hWnd, WM_COMMAND      , OnCommand);

		// The windowsx macro does not pass down the offset of the popup menu
		case WM_MENUSELECT:
			OnMenuSelect(hWnd, (HMENU)(lParam), (int)(LOWORD(wParam)),
				(UINT)(((short)HIWORD(wParam) == -1) ? 0xFFFFFFFF : HIWORD(wParam)));
			return(0);

		case WM_CREATE:
		{
			// We need to add our accelerator table before the children do
			m_pAccel = new CTranslateAccelTable(GetWindow(),
				::LoadAccelerators(GetInstanceHandle(), MAKEINTRESOURCE(IDR_ACCELERATORS)));
			if (NULL != m_pAccel)
			{
				AddTranslateAccelerator(m_pAccel);
			}

			// AddModelessDlg(hWnd);

			CreateChildWindows();

			InitDbgMenu(hWnd);

			break;
		}

		case WM_ACTIVATE:
		{
			if ((WA_INACTIVE == LOWORD(wParam)) && (FALSE == m_fMinimized))
			{
				m_hwndPrevFocus = ::GetFocus();
				TRACE_OUT(("Losing activation, focus on hwnd 0x%08x",
							m_hwndPrevFocus));
			}
			else if (NULL != m_hwndPrevFocus)
			{
				::SetFocus(m_hwndPrevFocus);
			}
			else
			{
				if (NULL != m_pMainUI)
				{
					::SetFocus(m_pMainUI->GetWindow());
				}
			}
			break;
		}

		case WM_GETMINMAXINFO:
		{
			if (FALSE != m_fMinimized)
			{
				// if the window is minimized, we don't want to handle this
				break;
			}

			SIZE size;
			GetDesiredSize(&size);

			((LPMINMAXINFO) lParam)->ptMinTrackSize.x = size.cx;
			((LPMINMAXINFO) lParam)->ptMinTrackSize.y = size.cy;
			return 0;
		}

		case WM_STATUSBAR_UPDATE:
			UpdateStatusBar();
			break;

		case WM_SYSCOLORCHANGE:
		{
			if (NULL != m_pMainUI)
			{
				m_pMainUI->ForwardSysChangeMsg(message, wParam, lParam);
			}
			break;
		}

		case WM_WININICHANGE:
		{
            InitMenuFont();

			// Propagate the message to the child windows:
			if (NULL != m_pStatusBar)
			{
				m_pStatusBar->ForwardSysChangeMsg(message, wParam, lParam);
			}
			if (NULL != m_pMainUI)
			{
				m_pMainUI->ForwardSysChangeMsg(message, wParam, lParam);
			}

			// Force a resize:
			if (NULL != m_pStatusBar)
			{
				m_pStatusBar->Resize(SIZE_RESTORED, 0);
			}
			ResizeChildWindows();
			break;
		}

		case WM_HELP:
		{
			LPHELPINFO phi = (LPHELPINFO) lParam;

			ASSERT(phi);
			TRACE_OUT(("WM_HELP, iContextType=%d, iCtrlId=%d",
						phi->iContextType, phi->iCtrlId));
			break;
		}

		case WM_SETCURSOR:
		{
			switch (LOWORD(lParam))
			{
				case HTLEFT:
				case HTRIGHT:
				case HTTOP:
				case HTTOPLEFT:
				case HTTOPRIGHT:
				case HTBOTTOM:
				case HTBOTTOMLEFT:
				case HTBOTTOMRIGHT:
				{
					break;
				}
				
				default:
				{
					if (g_cBusyOperations > 0)
					{
						::SetCursor(m_hWaitCursor);
						return TRUE;
					}
				}
			}
			// we didn't process the cursor msg:
			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
		}

		case WM_SIZE:
		{
			if (SIZE_MINIMIZED == wParam)
			{
				// transitioning to being minimized:
				m_fMinimized = TRUE;
			}
			else if ((SIZE_MAXIMIZED == wParam) || (SIZE_RESTORED == wParam))
			{
				if (m_fMinimized)
				{
					// transitioning from being minimized:
					m_fMinimized = FALSE;
					if (NULL != m_hwndPrevFocus)
					{
						::SetFocus(m_hwndPrevFocus);
					}
				}
				if (NULL != m_pStatusBar)
				{
					m_pStatusBar->Resize(wParam, lParam);
				}
				ResizeChildWindows();
			}

			// The menu may have wrapped or unwrapped
			OnDesiredSizeChanged();
			break;
		}

		case WM_SYSCOMMAND:
		{
			if (SC_MINIMIZE == wParam)
			{
				m_hwndPrevFocus = ::GetFocus();
				TRACE_OUT(("Being minimized, focus on hwnd 0x%08x",
							m_hwndPrevFocus));
			}
			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
		}
		
		// Doing this in QUERYENDSESSION so all apps have more CPU to shut down
		case WM_QUERYENDSESSION:
		{
			if (FIsConferenceActive() &&
				(IDNO == ::ConfMsgBox(  GetWindow(),
										(LPCTSTR) IDS_CLOSEWINDOW_PERMISSION,
										MB_SETFOREGROUND | MB_YESNO | MB_ICONQUESTION)))
			{
				return FALSE;
			}
			CMainUI *pMainUI = GetMainUI();
			if (NULL != pMainUI)
			{
				if (!pMainUI->OnQueryEndSession())
				{
					return(FALSE);
				}
			}
			m_pConfRoom->OnHangup(NULL, FALSE); // we've already confirmed
			return TRUE;
		}

		case WM_CLOSE:
			// HACKHACK: lParam shouldn't really be used in a WM_CLOSE
			OnClose(hWnd, lParam);
			break;

		case WM_DESTROY:
		{
			// RemoveModelessDlg(hWnd);

			if (NULL != m_pAccel)
			{
				RemoveTranslateAccelerator(m_pAccel);
				m_pAccel->Release();
				m_pAccel = NULL;
			}
			break;
		}

		case WM_POWERBROADCAST:
		{
			// Don't allow suspend while NetMeeting is running
			// so that we can receive calls.
			if (PBT_APMQUERYSUSPEND == wParam)
			{
				// Don't suspend on Win95 - we can't handle it
				if (g_osvi.dwMajorVersion == 4 && g_osvi.dwMinorVersion == 0
					&& g_osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
				{
					// Put up UI if lParam says it's ok to do so
					if ( lParam & 0x1 )
					{
						::PostConfMsgBox(IDS_WONT_SUSPEND);
					}
					return BROADCAST_QUERY_DENY;
				}
			}
			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
		}

		default:
		{
            if (message == c_uMsgXchgConf)
            {
                OnReleaseCamera();
            }
            else
            {
    			return CFrame::ProcessMessage(hWnd, message, wParam, lParam);
            }
            break;
		}
	}
	return 0;
}


//
// OnReleaseCamera()
//
// This is a hack for Exchange Real-Time server, so that NetMeeting will
// release the video camera while the user is in an Xchg multicast video
// conference, but can get it back when either
//      * the user goes to video options
//      * the conference ends
//
void CTopWindow::OnReleaseCamera(void)
{
    CVideoWindow *pLocal = GetLocalVideo();
    if (NULL != pLocal)
    {
        // Release camera if in use
        WARNING_OUT(("CTopWindow::OnReleaseCamera -- releasing capture device"));
        pLocal->SetCurrCapDevID((DWORD)-1);
    }
}


void CTopWindow::OnClose(HWND hwnd, LPARAM lParam)
{
	ASSERT(!m_fClosing);
	m_fClosing = TRUE;

	BOOL fNeedsHangup = FALSE;

	if (0 == CNmManagerObj::GetManagerCount(NM_INIT_OBJECT))
	{
		fNeedsHangup = FIsConferenceActive();

		if(fNeedsHangup && _Module.IsUIVisible())
		{
			UINT_PTR uMsg;
			if ((m_pConfRoom->GetMemberCount() <= 2) ||
				(FALSE == m_pConfRoom->FHasChildNodes()))
			{
				// Get confirmation
				// (DON'T mention that it will disconnect others)
				uMsg = IDS_CLOSEWINDOW_PERMISSION;
			}
			else
			{
				// Get confirmation
				// (DO mention that it will disconnect others)
				uMsg = IDS_CLOSE_DISCONNECT_PERMISSION;
			}
			UINT uMsgResult = ::ConfMsgBox( GetWindow(),
										(LPCTSTR) uMsg,
										MB_YESNO | MB_ICONQUESTION);
			if (IDNO == uMsgResult)
			{
				m_fClosing = FALSE;
				ShowUI();
				return;
			}
		}
	}

	BOOL fListen = (0 == lParam) && ConfPolicies::RunWhenWindowsStarts();

	if((0 != _Module.GetLockCount())  || fListen)
	{
			// Hang up before closing (don't need to confirm)
		if(fNeedsHangup)
		{
			m_pConfRoom->OnHangup(NULL, FALSE);
		}

		WARNING_OUT(("Hiding NetMeeting Window"));

		CNmManagerObj::OnShowUI(FALSE);

		ShowWindow(GetWindow(), SW_HIDE);

		m_fClosing = FALSE;
		return; // we're closed :-)
	}

	if (0 != g_uEndSessionMsg)
	{
		HWND hWndWB = FindWindow( "Wb32MainWindowClass", NULL );

		if (hWndWB)
		{
		DWORD_PTR dwResult = TRUE;

	::SendMessageTimeout( hWndWB,
							  g_uEndSessionMsg,
							  0,
							  0,
							  SMTO_BLOCK | SMTO_ABORTIFHUNG,
							  g_cuEndSessionMsgTimeout,
							  &dwResult
							);

			if( g_cuEndSessionAbort == dwResult )
		{
			m_fClosing = FALSE;
			ShowUI();
			return;
	}
		}
	}


	// Check to see if Chat can close

	if(!m_pConfRoom->CanCloseChat(GetWindow()) ||
	   !m_pConfRoom->CanCloseWhiteboard(GetWindow()) ||
	   !m_pConfRoom->CanCloseFileTransfer(GetWindow()))
	{
		m_fClosing = FALSE;
		if (!_Module.IsSDKCallerRTC())
		{
    		ShowUI();
        }
		return;
	}

	if(0 != _Module.GetLockCount())
	{
		m_fClosing = FALSE;
		return;
	}

	SignalShutdownStarting();

	// Shut the preview off, this speeds up closing the app
	// and avoids fault in connection point object
	// (see bug 3301)
	CMainUI *pMainUI = GetMainUI();
	if (NULL != pMainUI)
	{
		pMainUI->OnClose();
	}

	if (fNeedsHangup)
	{
		// Hang up before closing (don't need to confirm)
		m_pConfRoom->OnHangup(NULL, FALSE);
	}
	
	// Ensure that the help window goes away if it is up:
	ShutDownHelp();
	// Shut down the Find Someone window before destroying g_pConfRoom
	CFindSomeone::Destroy();

    m_pConfRoom->TerminateAppSharing();

	SaveSettings();

	m_pConfRoom->FreePartList();
	CloseChildWindows();
}

void CTopWindow::GetDesiredSize(SIZE *psize)
{
	HWND hwnd = GetWindow();

#if TRUE // {
	// Need to check the actual non-client area in case the menu has wrapped
	RECT rctWnd, rctCli;
	::GetWindowRect(hwnd, &rctWnd);
	::GetClientRect(hwnd, &rctCli);
	// Determine the size of the non-client portions of the window
	// NOTE: rctCli.left and rctCli.top are always zero
	int dx = rctWnd.right - rctWnd.left - rctCli.right;
	int dy = rctWnd.bottom - rctWnd.top - rctCli.bottom;
#else // }{
	RECT rcTemp = { 0, 0, 0, 0 };
	AdjustWindowRectEx(&rcTemp, GetWindowLong(hwnd, GWL_STYLE), TRUE,
		GetWindowLong(hwnd, GWL_EXSTYLE));

	int dx = rcTemp.right  - rcTemp.left;
	int dy = rcTemp.bottom - rcTemp.top;
#endif // }

	if (NULL != m_pMainUI)
	{
		SIZE size;

		m_pMainUI->GetDesiredSize(&size);
		dx += size.cx;
		dy += size.cy;
	}

	if (NULL != m_pSeparator)
	{
		SIZE size;

		m_pSeparator->GetDesiredSize(&size);
		dy += size.cy;
	}

	if (NULL != m_pStatusBar)
	{
		dy += m_pStatusBar->GetHeight();
	}

	psize->cx = dx;
	psize->cy = dy;
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnMeasureMenuItem(LPMEASUREITEMSTRUCT lpmis)
*
*        PURPOSE:  Handles WM_MEASUREITEM for owner drawn menus
*
****************************************************************************/

void CTopWindow::OnMeasureItem(HWND hwnd, MEASUREITEMSTRUCT * lpmis)
{
	if (ODT_MENU != lpmis->CtlType)
	{
		return;
	}

	ASSERT(ODT_MENU == lpmis->CtlType);
	PMYOWNERDRAWSTRUCT pmods = (PMYOWNERDRAWSTRUCT) lpmis->itemData;
	
	if (NULL != pmods)
	{
		//TRACE_OUT(("WM_MEASUREITEM, hIcon=0x%x, "
		//              "pszText=%s", pmods->hIcon, pmods->pszText));

		// get size of text:

		/* Retrieve a device context for the main window. */

		HDC hdc = GetDC(hwnd);


		HFONT hfontOld = SelectFont(hdc, m_hFontMenu);
		/*
		 * Retrieve the width and height of the item's string,
		 * and then copy the width and height into the
		 * MEASUREITEMSTRUCT structure's itemWidth and
		 * itemHeight members.
		 */

		SIZE size;
		GetTextExtentPoint32(   hdc,
								pmods->pszText,
								lstrlen(pmods->pszText),
								&size);
		
		/*
		 * Remember to leave space in the menu item for the
		 * check mark bitmap. Retrieve the width of the bitmap
		 * and add it to the width of the menu item.
		 */
		lpmis->itemHeight = size.cy;
		lpmis->itemWidth = size.cx + MENUICONSIZE + MENUICONGAP + (2 * MENUICONSPACE);
		if (pmods->fCanCheck)
		{
			lpmis->itemWidth += ::GetSystemMetrics(SM_CXMENUCHECK);
		}
		
		// Adjust height if necessary:
		NONCLIENTMETRICS ncm;
		ncm.cbSize = sizeof(ncm);
		if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, FALSE))
		{
			// BUGBUG: In order to look correct,
			// this is necessary - I'm not sure why - investigate
			ncm.iMenuHeight += 2;
			
			if (lpmis->itemHeight < (UINT) ncm.iMenuHeight)
			{
				lpmis->itemHeight = ncm.iMenuHeight;
			}
		}

		/*
		 * Select the old font back into the device context,
		 * and then release the device context.
		 */

		SelectObject(hdc, hfontOld);
		ReleaseDC(hwnd, hdc);
	}
	else
	{
		WARNING_OUT(("NULL pmods passed in WM_MEASUREITEM"));
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnDrawItem(LPDRAWITEMSTRUCT lpdis)
*
*        PURPOSE:  Handles WM_DRAWITEM for owner drawn menus
*
****************************************************************************/

void CTopWindow::OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT * lpdis)
{
	if (ID_STATUS == lpdis->CtlID)
	{
		if (NULL != m_pStatusBar)
		{
			m_pStatusBar->OnDraw(const_cast<DRAWITEMSTRUCT*>(lpdis));
		}
		return;
	}

	if (ODT_MENU != lpdis->CtlType)
	{
		return;
	}

	PMYOWNERDRAWSTRUCT pmods = (PMYOWNERDRAWSTRUCT) lpdis->itemData;
	BOOL fSelected = 0 != (lpdis->itemState & ODS_SELECTED);

	COLORREF crText = SetTextColor(lpdis->hDC,
		::GetSysColor(fSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT));
	COLORREF crBkgnd = SetBkColor(lpdis->hDC,
		::GetSysColor(fSelected ? COLOR_HIGHLIGHT : COLOR_MENU));

	/*
	 * Remember to leave space in the menu item for the
	 * check mark bitmap. Retrieve the width of the bitmap
	 * and add it to the width of the menu item.
	 */
	int nIconX = (pmods->fCanCheck ? ::GetSystemMetrics(SM_CXMENUCHECK) : 0)
					+ lpdis->rcItem.left;
	int nTextY = lpdis->rcItem.top;

	// BUGBUG: remove hard-coded constants:
	int nTextX = nIconX + MENUTEXTOFFSET;
	
    HFONT hfontOld = SelectFont(lpdis->hDC, m_hFontMenu);

	// Adjust vertical centering:
	SIZE size;
	GetTextExtentPoint32(   lpdis->hDC,
							pmods->pszText,
							lstrlen(pmods->pszText),
							&size);

	if (size.cy < (lpdis->rcItem.bottom - lpdis->rcItem.top))
	{
		nTextY += ((lpdis->rcItem.bottom - lpdis->rcItem.top) - size.cy) / 2;
	}

	RECT rctTextOut = lpdis->rcItem;
	if (fSelected)
	{
		rctTextOut.left += (nIconX + MENUSELTEXTOFFSET);
	}
	ExtTextOut(lpdis->hDC, nTextX, nTextY, ETO_OPAQUE,
		&rctTextOut, pmods->pszText,
		lstrlen(pmods->pszText), NULL);

	if (pmods->fChecked)
	{
		ASSERT(pmods->fCanCheck);
		HDC hdcMem = ::CreateCompatibleDC(NULL);
		if (NULL != hdcMem)
		{
			HBITMAP hbmpCheck = ::LoadBitmap(       NULL,
												MAKEINTRESOURCE(OBM_CHECK));
			if (NULL != hbmpCheck)
			{
				HBITMAP hBmpOld = (HBITMAP) ::SelectObject(hdcMem, hbmpCheck);
				COLORREF crOldText = ::SetTextColor(lpdis->hDC, ::GetSysColor(COLOR_MENUTEXT));
											//              ::GetSysColor(fSelected ?
											//                      COLOR_HIGHLIGHTTEXT :
											//                      COLOR_MENUTEXT));
				COLORREF crOldBkgnd = ::SetBkColor( lpdis->hDC, ::GetSysColor(COLOR_MENU));
											//              ::GetSysColor(fSelected ?
											//                      COLOR_HIGHLIGHT :
											//                      COLOR_MENU));

				::BitBlt(       lpdis->hDC,
							lpdis->rcItem.left,
							nTextY,
                            ::GetSystemMetrics(SM_CXMENUCHECK),
                            ::GetSystemMetrics(SM_CYMENUCHECK),
							hdcMem,
							0,
							0,
							SRCCOPY);

				::SetTextColor(lpdis->hDC, crOldText);
				::SetBkColor(lpdis->hDC, crOldBkgnd);

				::SelectObject(hdcMem, hBmpOld);

		::DeleteObject(hbmpCheck);
			}
			::DeleteDC(hdcMem);
		}
	}

	HICON hIconMenu = pmods->hIcon;
	
	if (fSelected)
	{
		if (NULL != pmods->hIconSel)
		{
			hIconMenu = pmods->hIconSel;
		}

		RECT rctIcon = lpdis->rcItem;
		rctIcon.left = nIconX;
		rctIcon.right = nIconX + MENUICONSIZE + (2 * MENUICONSPACE);
		::DrawEdge( lpdis->hDC,
					&rctIcon,
					BDR_RAISEDINNER,
					BF_RECT | BF_MIDDLE);
	}
	int nIconY = lpdis->rcItem.top;
	if (MENUICONSIZE < (lpdis->rcItem.bottom - lpdis->rcItem.top))
	{
		nIconY += ((lpdis->rcItem.bottom - lpdis->rcItem.top) - MENUICONSIZE) / 2;
	}
	if (NULL != hIconMenu)
	{
		::DrawIconEx(   lpdis->hDC,
						nIconX + MENUICONSPACE,
						nIconY,
						hIconMenu,
						MENUICONSIZE,
						MENUICONSIZE,
						0,
						NULL,
						DI_NORMAL);
	}
	else
	{
		DrawIconSmall(lpdis->hDC, pmods->iImage,
						nIconX + MENUICONSPACE, nIconY);
	}

    SelectFont(lpdis->hDC, hfontOld);

	/*
	 * Return the text and background colors to their
	 * normal state (not selected).
	 */

	// Restore the colors
	SetTextColor(lpdis->hDC, crText);
	SetBkColor(lpdis->hDC, crBkgnd);
}



/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   ForceWindowResize()
*
*        PURPOSE:  Handles redrawing the window after something changed
*
****************************************************************************/

VOID CTopWindow::ForceWindowResize()
{
	HWND hwnd = GetWindow();

	DBGENTRY(CConfRoom::ForceWindowResize);

	if (m_fMinimized || !FUiVisible())
		return; // nothing to resize

	// Turn off redraws:
	::SendMessage(hwnd, WM_SETREDRAW, FALSE, 0);
	// resize:
	ResizeChildWindows();
	// Turn on redraws and then redraw everything:
	::SendMessage(hwnd, WM_SETREDRAW, TRUE, 0);
	::RedrawWindow( hwnd,
					NULL,
					NULL,
					RDW_ALLCHILDREN | RDW_INVALIDATE |
						RDW_ERASE | RDW_ERASENOW);
}




/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnCommand(WPARAM, LPARAM)
*
*        PURPOSE:  Handles command messages
*
****************************************************************************/

void CTopWindow::OnCommand(HWND hwnd, int wCommand, HWND hwndCtl, UINT codeNotify)
{
	switch(wCommand)
	{
		case ID_AUTOACCEPT:
			ConfPolicies::SetAutoAcceptCallsEnabled(!ConfPolicies::IsAutoAcceptCallsEnabled());
			break;

		case ID_PRIVATE_UPDATE_UI:
		{
			UpdateUI(codeNotify);
			break;
		}

		case ID_HELP_WEB_FREE:
		case ID_HELP_WEB_FAQ:
		case ID_HELP_WEB_FEEDBACK:
		case ID_HELP_WEB_MSHOME:
		case ID_HELP_WEB_SUPPORT:
		case ID_HELP_WEB_NEWS:
		{
			CmdLaunchWebPage(wCommand);
			break;
		}
		
		case IDM_FILE_DIRECTORY:
		{
			CFindSomeone::findSomeone(m_pConfRoom);
		}
		break;

		case IDM_FILE_LOGON_ULS:
		{
			
			if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_GateKeeper )
			{ // this means that we are in Gatekeeper mode

				if( IsGatekeeperLoggedOn() || IsGatekeeperLoggingOn() )
				{
						// The text of the menu item should have read "LogOff Gatekeeper"
						// so we are going to take the command and log off
					GkLogoff();
				}
				else
				{
						// The text of the menu item should have read "LogOn Gatekeeper"
						// so we are going to take the command and log on
					GkLogon();
				}
			}
			else
			{
				g_pConfRoom->ToggleLdapLogon();
			}
			break;
		}

		case ID_HELP_HELPTOPICS:
		{
			ShowNmHelp(s_cszHtmlHelpFile);
			break;
		}
		
		case ID_HELP_ABOUTOPRAH:
		{
			CmdShowAbout(hwnd);
			break;
		}

		case ID_HELP_RELEASE_NOTES:
		{
			CmdShowReleaseNotes();
			break;
		}

		case ID_STOP:
		{
			CancelAllOutgoingCalls();
			break;
		}

		// General Toolbar Commands:
        case ID_FILE_EXIT_ACTIVATERDS:
        {
            RegEntry re(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
            re.SetValue(REMOTE_REG_ACTIVATESERVICE, 1);
            // then fall through IDM_FILE_EXIT
        }

		case IDM_FILE_EXIT:
		{
			// ISSUE: Should this be a PostMessage?
			::SendMessage(GetWindow(), WM_CLOSE, 0, 0);
			break;
		}

		case ID_FILE_CONF_HOST:
		{
			CmdHostConference(hwnd);
			break;
		}

		case ID_FILE_DO_NOT_DISTURB:
		{
			CmdDoNotDisturb(hwnd);
			UpdateUI(CRUI_STATUSBAR);
			break;
		}

		case IDM_VIEW_STATUSBAR:
		{
			CmdViewStatusBar();
			OnDesiredSizeChanged();
			break;
		}

		case IDM_VIEW_COMPACT:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetCompact(!m_pMainUI->IsCompact());
			}
			break;

		case IDM_VIEW_DATAONLY:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetDataOnly(!m_pMainUI->IsDataOnly());
			}
			break;

		case IDM_VIEW_DIALPAD:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetDialing(!m_pMainUI->IsDialing());
			}
			break;

		case ID_TB_PICINPIC:
			if (NULL != m_pMainUI)
			{
				m_fStateChanged = TRUE;
				m_pMainUI->SetPicInPic(!m_pMainUI->IsPicInPic());
			}
			break;

		case IDM_VIEW_ONTOP:
			m_fStateChanged = TRUE;
			SetOnTop(!IsOnTop());
			break;

		case ID_TOOLS_ENABLEAPPSHARING:
		{
			::OnEnableAppSharing(GetWindow());
			break;
		}

                case ID_TOOLS_RDSWIZARD:
                {
					RegEntry reCU( CONFERENCING_KEY, HKEY_CURRENT_USER);

					BOOL fAlwaysRunning = (0 != reCU.GetNumber(
								REGVAL_CONF_ALWAYS_RUNNING,	ALWAYS_RUNNING_DEFAULT ));

					if (fAlwaysRunning)
					{
						TCHAR szMsg[2*RES_CH_MAX];
						if (IDYES != MessageBox(GetWindow(),
							Res2THelper(IDS_RWSWARNING, szMsg, ARRAY_ELEMENTS(szMsg)), RES2T(IDS_MSGBOX_TITLE),
							MB_YESNO|MB_ICONHAND))
						{
							break;
						}

						reCU.SetValue(REGVAL_CONF_ALWAYS_RUNNING, (int)FALSE);
						RegEntry reRun(WINDOWS_RUN_KEY, HKEY_CURRENT_USER);
						reRun.DeleteValue(REGVAL_RUN_TASKNAME);
					}

                    RegEntry reLM( REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                    if (-1 != reLM.GetNumber(REMOTE_REG_RUNSERVICE,-1))
                    {
                        DialogBox(::GetInstanceHandle(), MAKEINTRESOURCE(IDD_RDS_SETTINGS), hwnd, RDSSettingDlgProc);
                    }
                    else
                    {
                        IntCreateRDSWizard(hwnd);
                    }
                    break;
                }

		case ID_TOOLS_OPTIONS:
		{
			::LaunchConfCpl(hwnd, OPTIONS_DEFAULT_PAGE);
			break;
		}

		case ID_TOOLS_SENDVIDEO:
		{
			CVideoWindow *pVideo = GetLocalVideo();
			if (NULL != pVideo)
			{
				pVideo->Pause(!pVideo->IsPaused());
			}
			break;
		}
		
		case ID_TOOLS_RECEIVEVIDEO:
		{
			CVideoWindow *pVideo = GetRemoteVideo();
			if (NULL != pVideo)
			{
				pVideo->Pause(!pVideo->IsPaused());
			}
			break;
		}
		
		case ID_TOOLS_AUDIO_WIZARD:
		{
			CmdAudioCalibWizard(hwnd);
			break;
		}

		case IDM_FILE_HANGUP:
        case ID_TB_FILETRANSFER:
		case ID_TB_NEWWHITEBOARD:
		case ID_TB_WHITEBOARD:
		case ID_TB_CHAT:
        case ID_TB_SHARING:
		case ID_TB_NEW_CALL:
        case IDM_CALL_MEETINGSETTINGS:
			m_pConfRoom->OnCommand(hwnd, wCommand, NULL, 0);
            break;

		case IDM_VIDEO_ZOOM1:
		case IDM_VIDEO_ZOOM2:
		case IDM_VIDEO_ZOOM3:
		case IDM_VIDEO_ZOOM4:
		case IDM_VIDEO_UNDOCK:
		case IDM_VIDEO_GETACAMERA:
		case IDM_POPUP_EJECT:
		case IDM_POPUP_PROPERTIES:
		case IDM_POPUP_SPEEDDIAL:
		case IDM_POPUP_ADDRESSBOOK:
        case IDM_POPUP_GIVECONTROL:
        case IDM_POPUP_CANCELGIVECONTROL:
		case ID_FILE_CREATE_SPEED_DIAL:
		{
			if (NULL != m_pMainUI)
			{
				m_pMainUI->OnCommand(wCommand);
			}
			break;
		}

		default:
		{
			if ((wCommand >= ID_EXTENDED_TOOLS_ITEM) &&
				(wCommand <= ID_EXTENDED_TOOLS_ITEM + MAX_EXTENDED_TOOLS_ITEMS))
			{
				// The user clicked on a extensible tools menu item:
				OnExtToolsItem(wCommand);
				return;
			}
#ifdef DEBUG
			else if ((wCommand >= IDM_DEBUG_FIRST) &&
					(wCommand < IDM_DEBUG_LAST))
			{
				// The user clicked on a debug menu item:
				::OnDebugCommand(wCommand);
				return;
			}
#endif
			else
			{
				// The message was not handled:
				WARNING_OUT(("Command not handled [%08X]", wCommand));
				return;
			}
		}
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: OnExtToolsItem(UINT uID)
*
*        PURPOSE:  Handles the action after a user selects an item from the
*                          extensible Tools menu.
*
****************************************************************************/

BOOL CTopWindow::OnExtToolsItem(UINT uID)
{
	HWND hwnd = GetWindow();

	DebugEntry(CConfRoom::OnExtToolsItem);
	
	BOOL bRet = FALSE;
	
	HMENU hMenuMain = GetMenu(hwnd);
	if (hMenuMain)
	{
		// Get the tools menu
		HMENU hMenuTools = GetSubMenu(hMenuMain, MENUPOS_TOOLS);
		if (hMenuTools)
		{
			MENUITEMINFO mmi;
			mmi.cbSize = sizeof(mmi);
			mmi.fMask = MIIM_DATA;
			if (GetMenuItemInfo(hMenuTools,
								uID,
								FALSE,
								&mmi))
			{
				TOOLSMENUSTRUCT* ptms = (TOOLSMENUSTRUCT*) mmi.dwItemData;
				ASSERT(NULL != ptms);
				TRACE_OUT(("Selected \"%s\" from Tools", ptms->szDisplayName));
				TRACE_OUT(("\tExeName: \"%s\"", ptms->szExeName));
				if ((HINSTANCE) 32 < ::ShellExecute(hwnd,
													NULL,
													ptms->szExeName,
													NULL,
													NULL,
													SW_SHOWDEFAULT))
				{
					bRet = TRUE;
				}
			}
		}
	}

	DebugExitBOOL(OnExtToolsItem, bRet);
	return bRet;
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        FUNCTION: ResizeChildWindows()
*
*        PURPOSE:  Calculates the correct size of the child windows and resizes
*
****************************************************************************/

VOID CTopWindow::ResizeChildWindows(void)
{
	if (m_fMinimized)
		return;

	RECT rcl;
	GetClientRect(GetWindow(), &rcl);

	if (NULL != m_pStatusBar)
	{
		rcl.bottom -= m_pStatusBar->GetHeight();
	}

	if (NULL != m_pSeparator)
	{
		SIZE size;
		m_pSeparator->GetDesiredSize(&size);

		::SetWindowPos(m_pSeparator->GetWindow(), NULL,
						rcl.left, rcl.top, rcl.right-rcl.left, size.cy,
						SWP_NOACTIVATE | SWP_NOZORDER);

		rcl.top += size.cy;
	}

	if (NULL != m_pMainUI)
	{
		// Fill the window with the main UI
		::SetWindowPos(m_pMainUI->GetWindow(), NULL,
						rcl.left, rcl.top, rcl.right-rcl.left, rcl.bottom-rcl.top,
						SWP_NOACTIVATE | SWP_NOZORDER);
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnMenuSelect(UINT, UINT, HMENU)
*
*        PURPOSE:  Called when passing over a menu item (to display status text)
*
****************************************************************************/

void CTopWindow::OnMenuSelect(HWND hwnd, HMENU hMenu, int uItem, UINT fuFlags)
{
	UINT uHelpID;
	TCHAR szHelpText[MAX_PATH];

	if (NULL == m_pStatusBar)
		return;

	if ((0xFFFF == LOWORD(fuFlags)) && (NULL == hMenu))
	{
		m_pStatusBar->RemoveHelpText();
		return;
	}

	if (!(MF_POPUP & fuFlags))
	{
		if (MF_SEPARATOR & fuFlags)
		{
			// show blank text in the status bar
			uHelpID = 0;
		}
		else if (MF_SYSMENU & fuFlags)
		{
			// An item from the system menu (these ID's map to our
			// string ID's directly)
			uHelpID = uItem;
		}
		else if ((uItem >= ID_EXTENDED_TOOLS_ITEM) &&
			(uItem <= ID_EXTENDED_TOOLS_ITEM + MAX_EXTENDED_TOOLS_ITEMS))
		{
			// BUGBUG georgep: No help for the extended tools items
			uHelpID = 0;
		}
#ifdef DEBUG
		else if ((uItem >= IDM_DEBUG) &&
				 (uItem <= IDM_DEBUG_LAST))
		{
			// debug only - don't complain
			uHelpID = 0;
		}
#endif
		else
		{
			uHelpID = MENU_ID_HELP_OFFSET + uItem;
		}
		
	}
	else
	{
		// This is a popup menu

		HMENU hMenuMain = ::GetMenu(GetWindow());
		if (hMenu == hMenuMain)
		{
#ifdef DEBUG
			if (uItem == (MENUPOS_HELP+1))
			{
				// This is a popup from the debug menu
				uHelpID = 0;
			}
			else
#endif
			{
				// This is a popup from the main window (i.e. Edit, View, etc.)
				uHelpID = MAIN_MENU_POPUP_HELP_OFFSET + uItem;
			}
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_TOOLS))
		{
			// This is a popup from the tools window (Video)
			uHelpID = TOOLS_MENU_POPUP_HELP_OFFSET + uItem;
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_HELP))
		{
			// This is a popup from the tools window (i.e. "Microsoft on the Web")
			uHelpID = HELP_MENU_POPUP_HELP_OFFSET + uItem;
		}

		// toolbar menu
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_VIEW))
		{
				uHelpID = VIEW_MENU_POPUP_HELP_OFFSET + uItem;
		}
		// system menu
		else if (MF_SYSMENU & fuFlags)
		{
				uHelpID = IDS_SYSTEM_HELP;
		}
		else
		{
			// popup-menu that we haven't handled yet:
			// BUGBUG: this shouldn't be needed if we handle all pop-up menus!
			uHelpID = 0;
			WARNING_OUT(("Missing help text for popup menu"));
		}
	}


	if (0 == uHelpID)
	{
		// show blank text in the status bar
		szHelpText[0] = _T('\0');
	}
	else
	{
		int cch = ::LoadString(::GetInstanceHandle(), uHelpID,
			szHelpText, CCHMAX(szHelpText));
#ifdef DEBUG
		if (0 == cch)
		{
			wsprintf(szHelpText, TEXT("Missing help text for id=%d"), uHelpID);
			WARNING_OUT((szHelpText));
		}
#endif
	}

	m_pStatusBar->SetHelpText(szHelpText);
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   OnInitMenuPopup(HMENU)
*
*        PURPOSE:  Insures that menus are updated when they are selected
*
****************************************************************************/

void CTopWindow::OnInitMenuPopup(HWND hwnd, HMENU hMenu, UINT item, BOOL fSystemMenu)
{
	if (fSystemMenu)
	{
		FORWARD_WM_INITMENUPOPUP(hwnd, hMenu, item, fSystemMenu, CFrame::ProcessMessage);
		return;
	}

	HMENU hMenuMain = ::GetMenu(GetWindow());
	if (hMenuMain)
	{
		// Check to see if we are on a dynamic menu:

		if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_CALL))
		{
			UpdateCallMenu(hMenu);
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_VIEW))
		{
			UpdateViewMenu(hMenu);
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_TOOLS))
		{
			UpdateToolsMenu(hMenu);
		}
		else if (hMenu == ::GetSubMenu(hMenuMain, MENUPOS_HELP))
		{
			UpdateHelpMenu(hMenu);
		}
	}
}


void CTopWindow::OnInitMenu(HWND hwnd, HMENU hMenu)
{
	if (NULL != m_pMainUI)
	{
		m_pMainUI->OnInitMenu(hMenu);
	}
}


/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateCallAnim()
*
*        PURPOSE:  Handles the starting and stopping of the call progress anim
*
****************************************************************************/

VOID CTopWindow::UpdateCallAnim()
{


}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateStatusBar()
*
*        PURPOSE:  Updates the status bar object
*
****************************************************************************/

VOID CTopWindow::UpdateStatusBar()
{
	if (NULL != m_pStatusBar)
	{
		m_pStatusBar->Update();
	}
}


/*  C R E A T E  C H I L D  W I N D O W S  */
/*-------------------------------------------------------------------------
    %%Function: CreateChildWindows

    Creates all of the child windows and views
-------------------------------------------------------------------------*/
VOID CTopWindow::CreateChildWindows(void)
{
	DBGENTRY(CreateChildWindows);

    HRESULT hr = S_OK;

	RegEntry re(UI_KEY, HKEY_CURRENT_USER);
	
	HWND hwnd = GetWindow();

	ASSERT(NULL != hwnd);
	
	// get the size and position of the parent window
	RECT rcl;
	::GetClientRect(hwnd, &rcl);

	// Create the status bar:
	m_pStatusBar = new CConfStatusBar(m_pConfRoom);
	if (NULL != m_pStatusBar)
	{
		if (m_pStatusBar->Create(hwnd))
		{
			if (re.GetNumber(REGVAL_SHOW_STATUSBAR, DEFAULT_SHOW_STATUSBAR))
			{
				m_pStatusBar->Show(TRUE);
			}
		}
	}


	/*** Create the main views ***/

	m_pSeparator = new CSeparator();
	if (NULL != m_pSeparator)
	{
		m_pSeparator->Create(hwnd);
	}

	// Create the toolbar
	m_pMainUI = new CMainUI();
	if (NULL != m_pMainUI)
	{
		if (!m_pMainUI->Create(hwnd, m_pConfRoom))
		{
			ERROR_OUT(("ConfRoom creation of toolbar window failed!"));
		}
		else
		{
			int state = re.GetNumber(REGVAL_MP_WINDOW_STATE, DEFAULT_MP_WINDOW_STATE);

			switch (state & State_Mask)
			{
			case State_Normal:
				break;

			case State_Compact:
				m_pMainUI->SetCompact(TRUE);
				break;

			case State_DataOnly:
				m_pMainUI->SetDataOnly(TRUE);
				break;

			default:
				if (!FIsAVCapable())
				{
					// initialize the toolbar buttons:
					m_pMainUI->SetDataOnly(TRUE);
				}
				break;
			}

			if (0 != (state & SubState_PicInPic))
			{
				m_pMainUI->SetPicInPic(TRUE);
			}
			if (0 != (state & SubState_Dialpad))
			{
				m_pMainUI->SetDialing(TRUE);
			}
			if (0 != (state & SubState_OnTop))
			{
				SetOnTop(TRUE);
			}

			m_pMainUI->UpdateButtons();
		}
	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateCallMenu(HMENU hMenuCall)
*
*        PURPOSE:  Updates the call menu
*
****************************************************************************/

VOID CTopWindow::UpdateCallMenu(HMENU hMenuCall)
{
	if (NULL != hMenuCall)
	{
		{
			bool bEnabled = ConfPolicies::IsAutoAcceptCallsOptionEnabled();
			bool bChecked = ConfPolicies::IsAutoAcceptCallsEnabled();
			EnableMenuItem(hMenuCall, ID_AUTOACCEPT, MF_BYCOMMAND | (bEnabled ? MF_ENABLED : MF_GRAYED));
			CheckMenuItem (hMenuCall, ID_AUTOACCEPT, MF_BYCOMMAND | (bChecked ? MF_CHECKED : MF_UNCHECKED));
		}

		TCHAR szMenu[ MAX_PATH * 2 ];

		if( ConfPolicies::GetCallingMode() == ConfPolicies::CallingMode_GateKeeper )
		{
			//	This means that we are in gatekeeper mode...

			RegEntry	reConf( CONFERENCING_KEY, HKEY_CURRENT_USER );

			FLoadString1( IsGatekeeperLoggedOn()? IDS_LOGOFF_ULS: IDS_LOGON_ULS, szMenu, reConf.GetString( REGVAL_GK_SERVER ) );

			::ModifyMenu( hMenuCall, IDM_FILE_LOGON_ULS, MF_BYCOMMAND | MF_STRING, IDM_FILE_LOGON_ULS, szMenu );
		}
		else
		{
			const TCHAR * const	defaultServer	= CDirectoryManager::get_displayName( CDirectoryManager::get_defaultServer() );

			bool	bMenuItemShouldSayLogon	= ((NULL == g_pLDAP) || !(g_pLDAP->IsLoggedOn() || g_pLDAP ->IsLoggingOn()));

			FLoadString1( bMenuItemShouldSayLogon? IDS_LOGON_ULS: IDS_LOGOFF_ULS, szMenu, (void *) defaultServer );

			::ModifyMenu( hMenuCall, IDM_FILE_LOGON_ULS, MF_BYCOMMAND | MF_STRING, IDM_FILE_LOGON_ULS, szMenu );
			::EnableMenuItem( hMenuCall, IDM_FILE_LOGON_ULS, SysPol::AllowDirectoryServices()? MF_ENABLED: MF_GRAYED );
		}

		// Set the state of the hangup item:
		::EnableMenuItem(       hMenuCall,
							IDM_FILE_HANGUP,
							FIsConferenceActive() ? MF_ENABLED : MF_GRAYED);
		
		// Only enable the host conference item if we're not in a call:
		::EnableMenuItem(       hMenuCall,
							ID_FILE_CONF_HOST,
							(FIsConferenceActive() ||
							FIsCallInProgress()) ? MF_GRAYED : MF_ENABLED);

        //
        // Only enable the meeting settings item if we're in a call and there
        // are settings.
        //
        ::EnableMenuItem(hMenuCall,
            IDM_CALL_MEETINGSETTINGS,
            MF_BYCOMMAND |
            ((FIsConferenceActive() && (m_pConfRoom->GetMeetingSettings() != NM_PERMIT_ALL)) ?
                MF_ENABLED : MF_GRAYED));


        // Only enable the New Call menu item if permitted by settings
        ::EnableMenuItem(hMenuCall,
                         ID_TB_NEW_CALL,
                         MF_BYCOMMAND|MenuState(m_pConfRoom->IsNewCallAllowed()));

		// Check the "Do Not Disturb" menu item:
		::CheckMenuItem(hMenuCall,
						ID_FILE_DO_NOT_DISTURB,
						::FDoNotDisturb() ? MF_CHECKED : MF_UNCHECKED);

                RegEntry reLM(REMOTECONTROL_KEY, HKEY_LOCAL_MACHINE);
                BOOL fActivated = reLM.GetNumber(REMOTE_REG_ACTIVATESERVICE, DEFAULT_REMOTE_ACTIVATESERVICE);
                BOOL fEnabled = reLM.GetNumber(REMOTE_REG_RUNSERVICE,DEFAULT_REMOTE_RUNSERVICE);
                if (fEnabled && !fActivated && !m_fExitAndActivateRDSMenuItem)
                {
                    TCHAR szExitAndActivateRDSMenuItem[MAX_PATH];
                    MENUITEMINFO mmi;

                    int cchExitAndActivateRDSMenuItem = ::LoadString(GetInstanceHandle(),
                                                                   ID_FILE_EXIT_ACTIVATERDS,
                                                                   szExitAndActivateRDSMenuItem,
                                                                   CCHMAX(szExitAndActivateRDSMenuItem));

                    if (0 == cchExitAndActivateRDSMenuItem)
                    {
                        ERROR_OUT(("LoadString(%d) failed", (int) ID_FILE_EXIT_ACTIVATERDS));
                    }
                    else
                    {
                        //ZeroMemory((PVOID) &mmi, sizeof(mmi));
                        mmi.cbSize = sizeof(mmi);
                        mmi.fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;
                        mmi.fState = MFS_ENABLED;
                        mmi.wID = ID_FILE_EXIT_ACTIVATERDS;
                        mmi.fType = MFT_STRING;
                        mmi.dwTypeData = szExitAndActivateRDSMenuItem;
                        mmi.cch = cchExitAndActivateRDSMenuItem;

                        if (InsertMenuItem(hMenuCall,-1,FALSE,&mmi))
                        {
                            m_fExitAndActivateRDSMenuItem = TRUE;
                        }
                        else
                        {
                            ERROR_OUT(("InsertMenuItem() failed, rc=%lu", (ULONG) GetLastError()));
                        }
                    }
                }
                else if (m_fExitAndActivateRDSMenuItem && (fActivated || !fEnabled))
                {
                    if (DeleteMenu(hMenuCall,ID_FILE_EXIT_ACTIVATERDS,MF_BYCOMMAND))
                    {
                        m_fExitAndActivateRDSMenuItem = FALSE;
                    }
                    else
                    {
                        ERROR_OUT(("DeleteMenu() failed, rc=%lu", (ULONG) GetLastError()));
                    }
                }

	}
}

/****************************************************************************
*
*        CLASS:    CConfRoom
*
*        MEMBER:   UpdateHelpMenu(HMENU hMenuHelp)
*
*        PURPOSE:  Updates the help menu
*
*****************************************************